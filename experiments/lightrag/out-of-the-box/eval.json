[
    {
        "sample_idx": 0,
        "question": "What is the default CPU configuration for a created Endpoint?",
        "answer": "2 x 4GB vCPUs with Intel Xeon Ice Lake.",
        "rag_answer": "According to the provided Data Sources, the default CPU configuration for a created Endpoint is a medium CPU, which consists of 2 x 4GB vCPUs with Intel Xeon Ice Lake.",
        "rag_score": 5,
        "rag_feedback": "The system's response is completely correct, accurate, and factual. It correctly states that the default CPU configuration for a created Endpoint is a medium CPU, which consists of 2 x 4GB vCPUs with Intel Xeon Ice Lake, which matches the expected answer.",
        "rag_context": {
            "kg_context": "-----Entities-----\n    ```csv\n    id,\tentity,\ttype,\tdescription,\trankcreated_at\n1,\tEndpoint creation page,event,The Endpoint creation page is a webpage where users can create new endpoints.,5,2025-03-24 13:16:13\n2,\tIntel Xeon Ice Lake,category,Intel Xeon Ice Lake is a type of CPU used in endpoint deployment.,1,2025-03-24 13:16:13\n3,\tAWS,organization,AWS is a cloud provider that is currently available for deploying endpoints, with regions us-east-1 and eu-west-1.,3,2025-03-24 13:16:13\n4,\tus-east-1,geo,us-east-1 is a region in the United States where endpoints can be deployed.,1,2025-03-24 13:16:13\n5,\teu-west-1,geo,eu-west-1 is a region in Europe where endpoints can be deployed.,1,2025-03-24 13:16:13\n6,\tAzure,organization,Azure is a cloud provider that will be added soon for deploying endpoints.,0,UNKNOWN\n7,\tAWS,organization,AWS is a cloud provider that is currently available for deploying endpoints, with regions us-east-1 and eu-west-1.,3,UNKNOWN\n8,\tIntel Xeon Ice Lake,category,Intel Xeon Ice Lake is a type of CPU used in endpoint deployment.,1,UNKNOWN\n    ```\n    -----Relationships-----\n    ```csv\n    id,\tsource,\ttarget,\tdescription,\tkeywords,\tweight,\trank,\tcreated_at\n1,\tEndpoint creation page,Intel Xeon Ice Lake,The Endpoint creation page uses Intel Xeon Ice Lake CPUs for endpoint deployment.,CPU, endpoint deployment,7.0,6,2025-03-24 13:16:13\n2,\tAWS,us-east-1,AWS provides the us-east-1 region for deploying endpoints.,region, cloud provider,14.0,4,2025-03-24 13:16:13\n3,\tAWS,eu-west-1,AWS provides the eu-west-1 region for deploying endpoints.,region, cloud provider,14.0,4,2025-03-24 13:16:13\n4,\tAWS,Hugging Face,Hugging Face uses AWS as a cloud provider for deploying endpoints.,cloud provider, partnership,16.0,11,UNKNOWN\n5,\tEndpoint creation page,Intel Xeon Ice Lake,The Endpoint creation page uses Intel Xeon Ice Lake CPUs for endpoint deployment.,CPU, endpoint deployment,7.0,6,UNKNOWN\n6,\tAWS,us-east-1,AWS provides the us-east-1 region for deploying endpoints.,region, cloud provider,14.0,4,UNKNOWN\n7,\tAWS,eu-west-1,AWS provides the eu-west-1 region for deploying endpoints.,region, cloud provider,14.0,4,UNKNOWN\n    ```\n    -----Sources-----\n    ```csv\n    id,\tcontent\n1,\tCreate an Endpoint\n\nAfter your first login, you will be directed to the [Endpoint creation page](https://ui.endpoints.huggingface.co/new). As an example, this guide will go through the steps to deploy [distilbert-base-uncased-finetuned-sst-2-english](https://huggingface.co/distilbert-base-uncased-finetuned-sst-2-english) for text classification. \n\n## 1. Enter the Hugging Face Repository ID and your desired endpoint name:\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_repository.png\" alt=\"select repository\" />\n\n## 2. Select your Cloud Provider and region. Initially, only AWS will be available as a Cloud Provider with the `us-east-1` and `eu-west-1` regions. We will add Azure soon, and if you need to test Endpoints with other Cloud Providers or regions, please let us know.\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_region.png\" alt=\"select region\" />\n\n## 3. Define the [Security Level](security) for the Endpoint:\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_security.png\" alt=\"define security\" />\n\n## 4. Create your Endpoint by clicking **Create Endpoint**. By default, your Endpoint is created with a medium CPU (2 x 4GB vCPUs with Intel Xeon Ice Lake) The cost estimate assumes the Endpoint will be up for an entire month, and does not take autoscaling into account.\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_create_cost.png\" alt=\"create endpoint\" />\n\n## 5. Wait for the Endpoint to build, initialize and run which can take between 1 to 5 minutes.\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/overview.png\" alt=\"overview\" />\n\n## 6. Test your Endpoint in the overview with the Inference widget \ud83c\udfc1 \ud83c\udf89!\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_inference.png\" alt=\"run inference\" />\n    ```",
            "vector_context": "[Created at: 2025-03-24 13:15:42]\nCreate an Endpoint\n\nAfter your first login, you will be directed to the [Endpoint creation page](https://ui.endpoints.huggingface.co/new). As an example, this guide will go through the steps to deploy [distilbert-base-uncased-finetuned-sst-2-english](https://huggingface.co/distilbert-base-uncased-finetuned-sst-2-english) for text classification. \n\n## 1. Enter the Hugging Face Repository ID and your desired endpoint name:\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_repository.png\" alt=\"select repository\" />\n\n## 2. Select your Cloud Provider and region. Initially, only AWS will be available as a Cloud Provider with the `us-east-1` and `eu-west-1` regions. We will add Azure soon, and if you need to test Endpoints with other Cloud Providers or regions, please let us know.\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_region.png\" alt=\"select region\" />\n\n## 3. Define the [Security Level](security) for the Endpoint:\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_security.png\" alt=\"define security\" />\n\n## 4. Create your Endpoint by clicking **Create Endpoint**. By default, your Endpoint is created with a medium CPU (2 x 4GB vCPUs with Intel Xeon Ice Lake) The cost estimate assumes the Endpoint will be up for an entire month, and does not take autoscaling into account.\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_create_cost.png\" alt=\"create endpoint\" />\n\n## 5. Wait for the Endpoint to build, initialize and run which can take between 1 to 5 minutes.\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/overview.png\" alt=\"overview\" />\n\n## 6. Test your Endpoint in the overview with the Inference widget \ud83c\udfc1 \ud83c\udf89!\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_inference.png\" alt=\"run inference\" />\n--New Chunk--\n[Created at: 2025-03-24 13:17:32]\n(for example, a v3-32), your TPU fleet is referred to as a **pod slice.**\n\nWhen you access a free TPU via Colab, you generally get a single v2-8 TPU.\n\n### I keep hearing about this XLA thing. What\u2019s XLA, and how does it relate to TPUs?\n\nXLA is an optimizing compiler, used by both TensorFlow and JAX. In JAX it is the only compiler, whereas in TensorFlow it is optional (but mandatory on TPU!). The easiest way to enable it when training a Keras model is to pass the argument `jit_compile=True` to `model.compile()`. If you don\u2019t get any errors and performance is good, that\u2019s a great sign that you\u2019re ready to move to TPU!\n\nDebugging on TPU is generally a bit harder than on CPU/GPU, so we recommend getting your code running on CPU/GPU with XLA first before trying it on TPU. You don\u2019t have to train for long, of course - just for a few steps to make sure that your model and data pipeline are working like you expect them to.\n\n<Tip>\n\nXLA compiled code is usually faster - so even if you\u2019re not planning to run on TPU, adding `jit_compile=True` can improve your performance. Be sure to note the caveats below about XLA compatibility, though!\n\n</Tip>\n\n<Tip warning={true}>\n\n**Tip born of painful experience:** Although using `jit_compile=True` is a good way to get a speed boost and test if your CPU/GPU code is XLA-compatible, it can actually cause a lot of problems if you leave it in when actually training on TPU. XLA compilation will happen implicitly on TPU, so remember to remove that line before actually running your code on a TPU!\n\n</Tip>\n\n### How do I make my model XLA compatible?\n\nIn many cases, your code is probably XLA-compatible already! However, there are a few things that work in normal TensorFlow that don\u2019t work in XLA. We\u2019ve distilled them into three core rules below:\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** We\u2019ve put a lot of effort into rewriting our TensorFlow models and loss functions to be XLA-compatible. Our models and loss functions generally obey rule #1 and #2 by default, so you can skip over them if you\u2019re using `transformers` models. Don\u2019t forget about these rules when writing your own models and loss functions, though!\n\n</Tip>\n\n#### XLA Rule #1: Your code cannot have \u201cdata-dependent conditionals\u201d\n\nWhat that means is that any `if` statement cannot depend on values inside a `tf.Tensor`. For example, this code block cannot be compiled with XLA!\n\n```python\nif tf.reduce_sum(tensor) > 10:\n    tensor = tensor / 2.0\n```\n\nThis might seem very restrictive at first, but most neural net code doesn\u2019t need to do this. You can often get around this restriction by using `tf.cond` (see the documentation [here](https://www.tensorflow.org/api_docs/python/tf/cond)) or by removing the conditional and finding a clever math trick with indicator variables instead, like so:\n\n```python\nsum_over_10 = tf.cast(tf.reduce_sum(tensor) > 10, tf.float32)\ntensor = tensor / (1.0 + sum_over_10)\n```\n\nThis code has exactly the same effect as the code above, but by avoiding a conditional, we ensure it will compile with XLA without problems!\n\n#### XLA Rule #2: Your code cannot have \u201cdata-dependent shapes\u201d\n\nWhat this means is that the shape of all of the `tf.Tensor` objects in your code cannot depend on their values. For example, the function `tf.unique` cannot be compiled with XLA, because it returns a `tensor` containing one instance of each unique value in the input. The shape of this output will obviously be different depending on how repetitive the input `Tensor` was, and so XLA refuses to handle it!\n\nIn general, most neural network code obeys rule #2 by default. However, there are a few common cases where it becomes a problem. One very common one is when you use **label masking**, setting your labels to a negative value to indicate that those positions should be ignored when computing the loss. If you look at NumPy or PyTorch loss functions that support label masking, you will often see code like this that uses [boolean indexing](https://numpy.org/doc/stable/user/basics.indexing.html#boolean-array-indexing):\n\n```python\nlabel_mask = labels >= 0\nmasked_outputs = outputs[label_mask]\nmasked_labels = labels[label_mask]\nloss = compute_loss(masked_outputs, masked_labels)\nmean_loss = torch.mean(loss)\n```\n\nThis code is totally fine in NumPy or PyTorch, but it breaks in XLA! Why? Because the shape of `masked_outputs` and `masked_labels` depends on how many positions are masked - that makes it a **data-dependent shape.** However, just like for rule #1, we can often rewrite this code to yield exactly the same output without any data-dependent shapes.\n\n```python\nlabel_mask = tf.cast(labels >= 0, tf.float32)\nloss = compute_loss(outputs, labels)\nloss = loss * label_mask  # Set negative label positions to 0\nmean_loss = tf.reduce_sum(loss) / tf.reduce_sum(label_mask)\n```\n\nHere, we avoid data-dependent shapes by computing the loss for every position, but zeroing out the masked positions in both the numerator and denominator when we calculate the mean, which yields exactly the same result as the first block while maintaining XLA compatibility. Note that we use the same trick as in rule #1 - converting a `tf.bool` to `\n--New Chunk--\n[Created at: 2025-03-24 13:17:32]\n!--Copyright 2023 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\nthe License. You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under the License is distributed on\nan \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n\n\u26a0\ufe0f Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be\nrendered properly in your Markdown viewer.\n\n-->\n\n# Training on TPU with TensorFlow\n\n<Tip>\n\nIf you don't need long explanations and just want TPU code samples to get started with, check out [our TPU example notebook!](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb)\n\n</Tip>\n\n### What is a TPU?\n\nA TPU is a **Tensor Processing Unit.** They are hardware designed by Google, which are used to greatly speed up the tensor computations within neural networks, much like GPUs. They can be used for both network training and inference. They are generally accessed through Google\u2019s cloud services, but small TPUs can also be accessed directly for free through Google Colab and Kaggle Kernels.\n\nBecause [all TensorFlow models in \ud83e\udd17 Transformers are Keras models](https://huggingface.co/blog/tensorflow-philosophy), most of the methods in this document are generally applicable to TPU training for any Keras model! However, there are a few points that are specific to the HuggingFace ecosystem (hug-o-system?) of Transformers and Datasets, and we\u2019ll make sure to flag them up when we get to them.\n\n### What kinds of TPU are available?\n\nNew users are often very confused by the range of TPUs, and the different ways to access them. The first key distinction to understand is the difference between **TPU Nodes** and **TPU VMs.**\n\nWhen you use a **TPU Node**, you are effectively indirectly accessing a remote TPU. You will need a separate VM, which will initialize your network and data pipeline and then forward them to the remote node. When you use a TPU on Google Colab, you are accessing it in the **TPU Node** style.\n\nUsing TPU Nodes can have some quite unexpected behaviour for people who aren\u2019t used to them! In particular, because the TPU is located on a physically different system to the machine you\u2019re running your Python code on, your data cannot be local to your machine - any data pipeline that loads from your machine\u2019s internal storage will totally fail! Instead, data must be stored in Google Cloud Storage where your data pipeline can still access it, even when the pipeline is running on the remote TPU node.\n\n<Tip>\n\nIf you can fit all your data in memory as `np.ndarray` or `tf.Tensor`, then you can `fit()` on that data even when using Colab or a TPU Node, without needing to upload it to Google Cloud Storage.\n\n</Tip>\n\n<Tip>\n\n**\ud83e\udd17Specific Hugging Face Tip\ud83e\udd17:** The methods `Dataset.to_tf_dataset()` and its higher-level wrapper `model.prepare_tf_dataset()` , which you will see throughout our TF code examples, will both fail on a TPU Node. The reason for this is that even though they create a `tf.data.Dataset` it is not a \u201cpure\u201d `tf.data` pipeline and uses `tf.numpy_function` or `Dataset.from_generator()` to stream data from the underlying HuggingFace `Dataset`. This HuggingFace `Dataset` is backed by data that is on a local disc and which the remote TPU Node will not be able to read.\n\n</Tip>\n\nThe second way to access a TPU is via a **TPU VM.** When using a TPU VM, you connect directly to the machine that the TPU is attached to, much like training on a GPU VM. TPU VMs are generally easier to work with, particularly when it comes to your data pipeline. All of the above warnings do not apply to TPU VMs!\n\nThis is an opinionated document, so here\u2019s our opinion: **Avoid using TPU Node if possible.** It is more confusing and more difficult to debug than TPU VMs. It is also likely to be unsupported in future - Google\u2019s latest TPU, TPUv4, can only be accessed as a TPU VM, which suggests that TPU Nodes are increasingly going to become a \u201clegacy\u201d access method. However, we understand that the only free TPU access is on Colab and Kaggle Kernels, which uses TPU Node - so we\u2019ll try to explain how to handle it if you have to! Check the [TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) for code samples that explain this in more detail.\n\n### What sizes of TPU are available?\n\nA single TPU (a v2-8/v3-8/v4-8) runs 8 replicas. TPUs exist in **pods** that can run hundreds or thousands of replicas simultaneously. When you use more than a single TPU but less than a whole pod (for example, a v3-32), your TPU fleet is referred to as a **pod slice.**\n\nWhen you access a free TPU via Colab, you generally get a single v2-8 TPU.\n\n### I keep hearing about this XLA thing. What\u2019s XLA, and how does it relate to TPUs?\n\nXLA is an optimizing compiler, used by both TensorFlow and JAX. In JAX it is the only compiler, whereas in TensorFlow it is optional"
        }
    },
    {
        "sample_idx": 1,
        "question": "How long does it take for an Endpoint to build, initialize, and run?",
        "answer": "Between 1 to 5 minutes.",
        "rag_answer": "According to the provided documentation, it can take between 1 to 5 minutes for an Endpoint to build, initialize, and run.",
        "rag_score": 5,
        "rag_feedback": "The system's response is completely correct, accurate, and factual. It directly quotes the relevant information from the provided documentation, stating that it can take between 1 to 5 minutes for an Endpoint to build, initialize, and run.",
        "rag_context": {
            "kg_context": "-----Entities-----\n    ```csv\n    id,\tentity,\ttype,\tdescription,\trankcreated_at\n1,\tEndpoint creation page,event,The Endpoint creation page is a webpage where users can create new endpoints.,5,2025-03-24 13:16:13\n2,\tIntel Xeon Ice Lake,category,Intel Xeon Ice Lake is a type of CPU used in endpoint deployment.,1,2025-03-24 13:16:13\n3,\tInference widget,category,Inference widget is a tool used for testing endpoints.,1,2025-03-24 13:16:13\n4,\tSecurity Level,category,Security Level refers to the level of security for an endpoint, which can be defined during creation.,1,2025-03-24 13:16:13\n5,\tMicrosoft,organization,Microsoft is the provider of the LayoutLMv3-base model used for fine-tuning.,1,UNKNOWN\n6,\tAzure,organization,Azure is a cloud provider that will be added soon for deploying endpoints.,0,UNKNOWN\n7,\tPods,category,Pods are a way to organize and manage TPUs, allowing for hundreds or thousands of replicas to run simultaneously.,0,UNKNOWN\n    ```\n    -----Relationships-----\n    ```csv\n    id,\tsource,\ttarget,\tdescription,\tkeywords,\tweight,\trank,\tcreated_at\n1,\tEndpoint creation page,Intel Xeon Ice Lake,The Endpoint creation page uses Intel Xeon Ice Lake CPUs for endpoint deployment.,CPU, endpoint deployment,7.0,6,2025-03-24 13:16:13\n2,\tEndpoint creation page,Inference widget,The Endpoint creation page provides an Inference widget for testing endpoints.,testing, endpoint creation,7.0,6,2025-03-24 13:16:13\n3,\tEndpoint creation page,Security Level,The Endpoint creation page allows users to define the Security Level for an endpoint.,security, endpoint creation,7.0,6,2025-03-24 13:16:13\n4,\tLayoutLMv3,Microsoft,Microsoft provides the LayoutLMv3-base model used for fine-tuning.,model provision, technology,18.0,12,UNKNOWN\n    ```\n    -----Sources-----\n    ```csv\n    id,\tcontent\n1,\tCreate an Endpoint\n\nAfter your first login, you will be directed to the [Endpoint creation page](https://ui.endpoints.huggingface.co/new). As an example, this guide will go through the steps to deploy [distilbert-base-uncased-finetuned-sst-2-english](https://huggingface.co/distilbert-base-uncased-finetuned-sst-2-english) for text classification. \n\n## 1. Enter the Hugging Face Repository ID and your desired endpoint name:\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_repository.png\" alt=\"select repository\" />\n\n## 2. Select your Cloud Provider and region. Initially, only AWS will be available as a Cloud Provider with the `us-east-1` and `eu-west-1` regions. We will add Azure soon, and if you need to test Endpoints with other Cloud Providers or regions, please let us know.\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_region.png\" alt=\"select region\" />\n\n## 3. Define the [Security Level](security) for the Endpoint:\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_security.png\" alt=\"define security\" />\n\n## 4. Create your Endpoint by clicking **Create Endpoint**. By default, your Endpoint is created with a medium CPU (2 x 4GB vCPUs with Intel Xeon Ice Lake) The cost estimate assumes the Endpoint will be up for an entire month, and does not take autoscaling into account.\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_create_cost.png\" alt=\"create endpoint\" />\n\n## 5. Wait for the Endpoint to build, initialize and run which can take between 1 to 5 minutes.\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/overview.png\" alt=\"overview\" />\n\n## 6. Test your Endpoint in the overview with the Inference widget \ud83c\udfc1 \ud83c\udf89!\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_inference.png\" alt=\"run inference\" />\n2,\t!---\nCopyright 2022 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n-->\n\n# Token classification with LayoutLMv3 (PyTorch version)\n\nThis directory contains a script, `run_funsd_cord.py`, that can be used to fine-tune (or evaluate) LayoutLMv3 on form understanding datasets, such as [FUNSD](https://guillaumejaume.github.io/FUNSD/) and [CORD](https://github.com/clovaai/cord).\n\nThe script `run_funsd_cord.py` leverages the \ud83e\udd17 Datasets library and the Trainer API. You can easily customize it to your needs.\n\n## Fine-tuning on FUNSD\n\nFine-tuning LayoutLMv3 for token classification on [FUNSD](https://guillaumejaume.github.io/FUNSD/) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name funsd \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 1e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-funsd\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd. By specifying the `push_to_hub` flag, the model gets uploaded automatically to the hub (regularly), together with a model card, which includes metrics such as precision, recall and F1. Note that you can easily update the model card, as it's just a README file of the respective repo on the hub.\n\nThere's also the \"Training metrics\" [tab](https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd/tensorboard), which shows Tensorboard logs over the course of training. Pretty neat, huh?\n\n## Fine-tuning on CORD\n\nFine-tuning LayoutLMv3 for token classification on [CORD](https://github.com/clovaai/cord) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name cord \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 5e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-cord\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-cord. Note that a model card gets generated automatically in case you specify the `push_to_hub` flag.\n3,\t!--Copyright 2023 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\nthe License. You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under the License is distributed on\nan \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n\n\u26a0\ufe0f Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be\nrendered properly in your Markdown viewer.\n\n-->\n\n# Training on TPU with TensorFlow\n\n<Tip>\n\nIf you don't need long explanations and just want TPU code samples to get started with, check out [our TPU example notebook!](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb)\n\n</Tip>\n\n### What is a TPU?\n\nA TPU is a **Tensor Processing Unit.** They are hardware designed by Google, which are used to greatly speed up the tensor computations within neural networks, much like GPUs. They can be used for both network training and inference. They are generally accessed through Google\u2019s cloud services, but small TPUs can also be accessed directly for free through Google Colab and Kaggle Kernels.\n\nBecause [all TensorFlow models in \ud83e\udd17 Transformers are Keras models](https://huggingface.co/blog/tensorflow-philosophy), most of the methods in this document are generally applicable to TPU training for any Keras model! However, there are a few points that are specific to the HuggingFace ecosystem (hug-o-system?) of Transformers and Datasets, and we\u2019ll make sure to flag them up when we get to them.\n\n### What kinds of TPU are available?\n\nNew users are often very confused by the range of TPUs, and the different ways to access them. The first key distinction to understand is the difference between **TPU Nodes** and **TPU VMs.**\n\nWhen you use a **TPU Node**, you are effectively indirectly accessing a remote TPU. You will need a separate VM, which will initialize your network and data pipeline and then forward them to the remote node. When you use a TPU on Google Colab, you are accessing it in the **TPU Node** style.\n\nUsing TPU Nodes can have some quite unexpected behaviour for people who aren\u2019t used to them! In particular, because the TPU is located on a physically different system to the machine you\u2019re running your Python code on, your data cannot be local to your machine - any data pipeline that loads from your machine\u2019s internal storage will totally fail! Instead, data must be stored in Google Cloud Storage where your data pipeline can still access it, even when the pipeline is running on the remote TPU node.\n\n<Tip>\n\nIf you can fit all your data in memory as `np.ndarray` or `tf.Tensor`, then you can `fit()` on that data even when using Colab or a TPU Node, without needing to upload it to Google Cloud Storage.\n\n</Tip>\n\n<Tip>\n\n**\ud83e\udd17Specific Hugging Face Tip\ud83e\udd17:** The methods `Dataset.to_tf_dataset()` and its higher-level wrapper `model.prepare_tf_dataset()` , which you will see throughout our TF code examples, will both fail on a TPU Node. The reason for this is that even though they create a `tf.data.Dataset` it is not a \u201cpure\u201d `tf.data` pipeline and uses `tf.numpy_function` or `Dataset.from_generator()` to stream data from the underlying HuggingFace `Dataset`. This HuggingFace `Dataset` is backed by data that is on a local disc and which the remote TPU Node will not be able to read.\n\n</Tip>\n\nThe second way to access a TPU is via a **TPU VM.** When using a TPU VM, you connect directly to the machine that the TPU is attached to, much like training on a GPU VM. TPU VMs are generally easier to work with, particularly when it comes to your data pipeline. All of the above warnings do not apply to TPU VMs!\n\nThis is an opinionated document, so here\u2019s our opinion: **Avoid using TPU Node if possible.** It is more confusing and more difficult to debug than TPU VMs. It is also likely to be unsupported in future - Google\u2019s latest TPU, TPUv4, can only be accessed as a TPU VM, which suggests that TPU Nodes are increasingly going to become a \u201clegacy\u201d access method. However, we understand that the only free TPU access is on Colab and Kaggle Kernels, which uses TPU Node - so we\u2019ll try to explain how to handle it if you have to! Check the [TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) for code samples that explain this in more detail.\n\n### What sizes of TPU are available?\n\nA single TPU (a v2-8/v3-8/v4-8) runs 8 replicas. TPUs exist in **pods** that can run hundreds or thousands of replicas simultaneously. When you use more than a single TPU but less than a whole pod (for example, a v3-32), your TPU fleet is referred to as a **pod slice.**\n\nWhen you access a free TPU via Colab, you generally get a single v2-8 TPU.\n\n### I keep hearing about this XLA thing. What\u2019s XLA, and how does it relate to TPUs?\n\nXLA is an optimizing compiler, used by both TensorFlow and JAX. In JAX it is the only compiler, whereas in TensorFlow it is optional\n    ```",
            "vector_context": "[Created at: 2025-03-24 13:15:42]\nCreate an Endpoint\n\nAfter your first login, you will be directed to the [Endpoint creation page](https://ui.endpoints.huggingface.co/new). As an example, this guide will go through the steps to deploy [distilbert-base-uncased-finetuned-sst-2-english](https://huggingface.co/distilbert-base-uncased-finetuned-sst-2-english) for text classification. \n\n## 1. Enter the Hugging Face Repository ID and your desired endpoint name:\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_repository.png\" alt=\"select repository\" />\n\n## 2. Select your Cloud Provider and region. Initially, only AWS will be available as a Cloud Provider with the `us-east-1` and `eu-west-1` regions. We will add Azure soon, and if you need to test Endpoints with other Cloud Providers or regions, please let us know.\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_region.png\" alt=\"select region\" />\n\n## 3. Define the [Security Level](security) for the Endpoint:\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_security.png\" alt=\"define security\" />\n\n## 4. Create your Endpoint by clicking **Create Endpoint**. By default, your Endpoint is created with a medium CPU (2 x 4GB vCPUs with Intel Xeon Ice Lake) The cost estimate assumes the Endpoint will be up for an entire month, and does not take autoscaling into account.\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_create_cost.png\" alt=\"create endpoint\" />\n\n## 5. Wait for the Endpoint to build, initialize and run which can take between 1 to 5 minutes.\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/overview.png\" alt=\"overview\" />\n\n## 6. Test your Endpoint in the overview with the Inference widget \ud83c\udfc1 \ud83c\udf89!\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_inference.png\" alt=\"run inference\" />\n--New Chunk--\n[Created at: 2025-03-24 13:16:48]\n\u4e0e\u5e38\u89c4\u51fd\u6570\u76f8\u540c\u7684\u65b9\u5f0f\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio\u3002\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\uff08\u865a\u62df\u7684\uff09\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5b83\u5728\u8f93\u51fa\u56fe\u50cf\u4e4b\u524d\u751f\u6210\u6570\u4e2a\u6b65\u9aa4\u7684\u566a\u97f3\uff1a\n\n$code_fake_diffusion\n$demo_fake_diffusion\n\n\u8bf7\u6ce8\u610f\uff0c\u6211\u4eec\u5728\u8fed\u4ee3\u5668\u4e2d\u6dfb\u52a0\u4e86 `time.sleep(1)`\uff0c\u4ee5\u521b\u5efa\u6b65\u9aa4\u4e4b\u95f4\u7684\u4eba\u5de5\u6682\u505c\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u89c2\u5bdf\u8fed\u4ee3\u5668\u7684\u6b65\u9aa4\uff08\u5728\u771f\u5b9e\u7684\u56fe\u50cf\u751f\u6210\u6a21\u578b\u4e2d\uff0c\u8fd9\u53ef\u80fd\u662f\u4e0d\u5fc5\u8981\u7684\uff09\u3002\n\n\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio **\u9700\u8981**\u5728\u5e95\u5c42 Interface \u6216 Blocks \u4e2d\u542f\u7528\u961f\u5217\uff08\u8bf7\u53c2\u9605\u4e0a\u9762\u7684\u961f\u5217\u90e8\u5206\uff09\u3002\n\n## \u8fdb\u5ea6\u6761\n\nGradio \u652f\u6301\u521b\u5efa\u81ea\u5b9a\u4e49\u8fdb\u5ea6\u6761\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u81ea\u5b9a\u4e49\u548c\u63a7\u5236\u5411\u7528\u6237\u663e\u793a\u7684\u8fdb\u5ea6\u66f4\u65b0\u3002\u8981\u542f\u7528\u6b64\u529f\u80fd\uff0c\u53ea\u9700\u4e3a\u65b9\u6cd5\u6dfb\u52a0\u4e00\u4e2a\u9ed8\u8ba4\u503c\u4e3a `gr.Progress` \u5b9e\u4f8b\u7684\u53c2\u6570\u5373\u53ef\u3002\u7136\u540e\uff0c\u60a8\u53ef\u4ee5\u76f4\u63a5\u8c03\u7528\u6b64\u5b9e\u4f8b\u5e76\u4f20\u5165 0 \u5230 1 \u4e4b\u95f4\u7684\u6d6e\u70b9\u6570\u6765\u66f4\u65b0\u8fdb\u5ea6\u7ea7\u522b\uff0c\u6216\u8005 with `Progress` \u5b9e\u4f8b\u7684 `tqdm()` \u65b9\u6cd5\u6765\u8ddf\u8e2a\u53ef\u8fed\u4ee3\u5bf9\u8c61\u4e0a\u7684\u8fdb\u5ea6\uff0c\u5982\u4e0b\u6240\u793a\u3002\u5fc5\u987b\u542f\u7528\u961f\u5217\u4ee5\u8fdb\u884c\u8fdb\u5ea6\u66f4\u65b0\u3002\n\n$code_progress_simple\n$demo_progress_simple\n\n\u5982\u679c\u60a8 with `tqdm` \u5e93\uff0c\u5e76\u4e14\u5e0c\u671b\u4ece\u51fd\u6570\u5185\u90e8\u7684\u4efb\u4f55 `tqdm.tqdm` \u81ea\u52a8\u62a5\u544a\u8fdb\u5ea6\u66f4\u65b0\uff0c\u8bf7\u5c06\u9ed8\u8ba4\u53c2\u6570\u8bbe\u7f6e\u4e3a `gr.Progress(track_tqdm=True)`\uff01\n\n## \u6279\u5904\u7406\u51fd\u6570 (Batch Functions)\n\nGradio \u652f\u6301\u4f20\u9012*\u6279\u5904\u7406*\u51fd\u6570\u3002\u6279\u5904\u7406\u51fd\u6570\u53ea\u662f\u63a5\u53d7\u8f93\u5165\u5217\u8868\u5e76\u8fd4\u56de\u9884\u6d4b\u5217\u8868\u7684\u51fd\u6570\u3002\n\n\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\u6279\u5904\u7406\u51fd\u6570\uff0c\u5b83\u63a5\u53d7\u4e24\u4e2a\u8f93\u5165\u5217\u8868\uff08\u4e00\u4e2a\u5355\u8bcd\u5217\u8868\u548c\u4e00\u4e2a\u6574\u6570\u5217\u8868\uff09\uff0c\u5e76\u8fd4\u56de\u4fee\u526a\u8fc7\u7684\u5355\u8bcd\u5217\u8868\u4f5c\u4e3a\u8f93\u51fa\uff1a\n\n```python\nimport time\n\ndef trim_words(words, lens):\n    trimmed_words = []\n    time.sleep(5)\n    for w, l in zip(words, lens):\n        trimmed_words.append(w[:int(l)])\n    return [trimmed_words]\n    for w, l in zip(words, lens):\n```\n\n\u4f7f\u7528\u6279\u5904\u7406\u51fd\u6570\u7684\u4f18\u70b9\u662f\uff0c\u5982\u679c\u542f\u7528\u4e86\u961f\u5217\uff0cGradio \u670d\u52a1\u5668\u53ef\u4ee5\u81ea\u52a8*\u6279\u5904\u7406*\u4f20\u5165\u7684\u8bf7\u6c42\u5e76\u5e76\u884c\u5904\u7406\u5b83\u4eec\uff0c\u4ece\u800c\u53ef\u80fd\u52a0\u5feb\u6f14\u793a\u901f\u5ea6\u3002\u4ee5\u4e0b\u662f Gradio \u4ee3\u7801\u7684\u793a\u4f8b\uff08\u8bf7\u6ce8\u610f `batch=True` \u548c `max_batch_size=16` - \u8fd9\u4e24\u4e2a\u53c2\u6570\u90fd\u53ef\u4ee5\u4f20\u9012\u7ed9\u4e8b\u4ef6\u89e6\u53d1\u5668\u6216 `Interface` \u7c7b\uff09\n\nwith `Interface`\uff1a\n\n```python\ndemo = gr.Interface(trim_words, [\"textbox\", \"number\"], [\"output\"],\n                    batch=True, max_batch_size=16)\ndemo.queue()\ndemo.launch()\n```\n\nwith `Blocks`\uff1a\n\n```python\nimport gradio as gr\n\nwith gr.Blocks() as demo:\n    with gr.Row():\n        word = gr.Textbox(label=\"word\")\n        leng = gr.Number(label=\"leng\")\n        output = gr.Textbox(label=\"Output\")\n    with gr.Row():\n        run = gr.Button()\n\n    event = run.click(trim_words, [word, leng], output, batch=True, max_batch_size=16)\n\ndemo.queue()\ndemo.launch()\n```\n\n\u5728\u4e0a\u9762\u7684\u793a\u4f8b\u4e2d\uff0c\u53ef\u4ee5\u5e76\u884c\u5904\u7406 16 \u4e2a\u8bf7\u6c42\uff08\u603b\u63a8\u7406\u65f6\u95f4\u4e3a 5 \u79d2\uff09\uff0c\u800c\u4e0d\u662f\u5206\u522b\u5904\u7406\u6bcf\u4e2a\u8bf7\u6c42\uff08\u603b\u63a8\u7406\u65f6\u95f4\u4e3a 80 \u79d2\uff09\u3002\u8bb8\u591a Hugging Face \u7684 `transformers` \u548c `diffusers` \u6a21\u578b\u5728 Gradio \u7684\u6279\u5904\u7406\u6a21\u5f0f\u4e0b\u81ea\u7136\u5de5\u4f5c\uff1a\u8fd9\u662f[\u4f7f\u7528\u6279\u5904\u7406\u751f\u6210\u56fe\u50cf\u7684\u793a\u4f8b\u6f14\u793a](https://github.com/gradio-app/gradio/blob/main/demo/diffusers_with_batching/run.py)\n\n\u6ce8\u610f\uff1a\u4f7f\u7528 Gradio \u7684\u6279\u5904\u7406\u51fd\u6570 **requires** \u5728\u5e95\u5c42 Interface \u6216 Blocks \u4e2d\u542f\u7528\u961f\u5217\uff08\u8bf7\u53c2\u9605\u4e0a\u9762\u7684\u961f\u5217\u90e8\u5206\uff09\u3002\n\n## Gradio \u7b14\u8bb0\u672c (Colab Notebooks)\n\nGradio \u53ef\u4ee5\u5728\u4efb\u4f55\u8fd0\u884c Python \u7684\u5730\u65b9\u8fd0\u884c\uff0c\u5305\u62ec\u672c\u5730 Jupyter \u7b14\u8bb0\u672c\u548c\u534f\u4f5c\u7b14\u8bb0\u672c\uff0c\u5982[Google Colab](https://colab.research.google.com/)\u3002\u5bf9\u4e8e\u672c\u5730 Jupyter \u7b14\u8bb0\u672c\u548c Google Colab \u7b14\u8bb0\u672c\uff0cGradio \u5728\u672c\u5730\u670d\u52a1\u5668\u4e0a\u8fd0\u884c\uff0c\u60a8\u53ef\u4ee5\u5728\u6d4f\u89c8\u5668\u4e2d\u4e0e\u4e4b\u4ea4\u4e92\u3002\uff08\u6ce8\u610f\uff1a\u5bf9\u4e8e Google Colab\uff0c\u8fd9\u662f\u901a\u8fc7[\u670d\u52a1\u5de5\u4f5c\u5668\u96a7\u9053](https://github.com/tensorflow/tensorboard/blob/master/docs/design/colab_integration.md)\u5b9e\u73b0\u7684\uff0c\u60a8\u7684\u6d4f\u89c8\u5668\u9700\u8981\u542f\u7528 cookies\u3002\uff09\u5bf9\u4e8e\u5176\u4ed6\u8fdc\u7a0b\u7b14\u8bb0\u672c\uff0cGradio \u4e5f\u5c06\u5728\u670d\u52a1\u5668\u4e0a\u8fd0\u884c\uff0c\u4f46\u60a8\u9700\u8981\u4f7f\u7528[SSH \u96a7\u9053](https://coderwall.com/p/ohk6cg/remote-access-to-ipython-notebooks-via-ssh)\u5728\u672c\u5730\u6d4f\u89c8\u5668\u4e2d\u67e5\u770b\u5e94\u7528\u7a0b\u5e8f\u3002\u901a\u5e38\uff0c\u66f4\u7b80\u5355\u7684\u9009\u62e9\u662f\u4f7f\u7528 Gradio \u5185\u7f6e\u7684\u516c\u5171\u94fe\u63a5\uff0c[\u5728\u4e0b\u4e00\u7bc7\u6307\u5357\u4e2d\u8ba8\u8bba](/sharing-your-app/#sharing-demos)\u3002\n--New Chunk--\n[Created at: 2025-03-24 13:16:13]\nChoosing a metric for your task\n\n**So you've trained your model and want to see how well it\u2019s doing on a dataset of your choice. Where do you start?**\n\nThere is no \u201cone size fits all\u201d approach to choosing an evaluation metric, but some good guidelines to keep in mind are:\n\n## Categories of metrics\n\nThere are 3 high-level categories of metrics:\n\n1. *Generic metrics*, which can be applied to a variety of situations and datasets, such as precision and accuracy.\n2. *Task-specific metrics*, which are limited to a given task, such as Machine Translation (often evaluated using metrics [BLEU](https://huggingface.co/metrics/bleu) or [ROUGE](https://huggingface.co/metrics/rouge)) or Named Entity Recognition (often evaluated with [seqeval](https://huggingface.co/metrics/seqeval)).\n3. *Dataset-specific metrics*, which aim to measure model performance on specific benchmarks: for instance, the [GLUE benchmark](https://huggingface.co/datasets/glue) has a dedicated [evaluation metric](https://huggingface.co/metrics/glue).\n\nLet's look at each of these three cases:\n\n### Generic metrics\n\nMany of the metrics used in the Machine Learning community are quite generic and can be applied in a variety of tasks and datasets.\n\nThis is the case for metrics like [accuracy](https://huggingface.co/metrics/accuracy) and [precision](https://huggingface.co/metrics/precision), which can be used for evaluating labeled (supervised) datasets, as well as [perplexity](https://huggingface.co/metrics/perplexity), which can be used for evaluating different kinds of (unsupervised) generative tasks.\n\nTo see the input structure of a given metric, you can look at its metric card. For example, in the case of [precision](https://huggingface.co/metrics/precision), the format is:\n```\n>>> precision_metric = evaluate.load(\"precision\")\n>>> results = precision_metric.compute(references=[0, 1], predictions=[0, 1])\n>>> print(results)\n{'precision': 1.0}\n```\n\n### Task-specific metrics\n\nPopular ML tasks like Machine Translation and Named Entity Recognition have specific metrics that can be used to compare models. For example, a series of different metrics have been proposed for text generation, ranging from [BLEU](https://huggingface.co/metrics/bleu) and its derivatives such as [GoogleBLEU](https://huggingface.co/metrics/google_bleu) and [GLEU](https://huggingface.co/metrics/gleu), but also [ROUGE](https://huggingface.co/metrics/rouge), [MAUVE](https://huggingface.co/metrics/mauve), etc.\n\nYou can find the right metric for your task by:\n\n- **Looking at the [Task pages](https://huggingface.co/tasks)** to see what metrics can be used for evaluating models for a given task.\n- **Checking out leaderboards** on sites like [Papers With Code](https://paperswithcode.com/) (you can search by task and by dataset).\n-  **Reading the metric cards** for the relevant metrics and see which ones are a good fit for your use case. For example, see the [BLEU metric card](https://github.com/huggingface/evaluate/tree/main/metrics/bleu) or [SQuaD metric card](https://github.com/huggingface/evaluate/tree/main/metrics/squad).\n- **Looking at papers and blog posts** published on the topic and see what metrics they report. This can change over time, so try to pick papers from the last couple of years!\n\n### Dataset-specific metrics\n\nSome datasets have specific metrics associated with them -- this is especially in the case of popular benchmarks like [GLUE](https://huggingface.co/metrics/glue) and [SQuAD](https://huggingface.co/metrics/squad).\n\n<Tip warning={true}>\n\ud83d\udca1\nGLUE is actually a collection of different subsets on different tasks, so first you need to choose the one that corresponds to the NLI task, such as mnli, which is described as \u201ccrowdsourced collection of sentence pairs with textual entailment annotations\u201d\n</Tip>\n\n\nIf you are evaluating your model on a benchmark dataset like the ones mentioned above, you can use its dedicated evaluation metric. Make sure you respect the format that they require. For example, to evaluate your model on the [SQuAD](https://huggingface.co/datasets/squad) dataset, you need to feed the `question` and `context` into your model and return the `prediction_text`, which should be compared with the `references` (based on matching the `id` of the question) :\n\n```\n>>> from evaluate import load\n>>> squad_metric = load(\"squad\")\n>>> predictions = [{'prediction_text': '1976', 'id': '56e10a3be3433e1400422b22'}]\n>>> references = [{'answers': {'answer_start': [97], 'text': ['1976']}, 'id': '56e10a3be3433e1400422b22'}]\n>>> results = squad_metric.compute(predictions=predictions, references=references)\n>>> results\n{'exact_match': 100.0, 'f1': 100.0}\n```\n\nYou can find examples of dataset structures by consulting the \"Dataset Preview\" function or the dataset card for a given dataset, and you can see how to use its dedicated evaluation function based on the metric card."
        }
    },
    {
        "sample_idx": 2,
        "question": "What is the initial Cloud Provider available for Endpoint creation?",
        "answer": "AWS.",
        "rag_answer": "The initial Cloud Provider available for Endpoint creation is AWS, with the `us-east-1` and `eu-west-1` regions. [KG]",
        "rag_score": 5,
        "rag_feedback": "The system's response is completely correct, accurate, and factual. It correctly answers the question by stating that the initial Cloud Provider available for Endpoint creation is AWS, with the us-east-1 and eu-west-1 regions, which matches the expected answer.",
        "rag_context": {
            "kg_context": "-----Entities-----\n    ```csv\n    id,\tentity,\ttype,\tdescription,\trankcreated_at\n1,\tAWS,organization,AWS is a cloud provider that is currently available for deploying endpoints, with regions us-east-1 and eu-west-1.,3,2025-03-24 13:16:13\n2,\tHugging Face,organization,Hugging Face is an organization that provides a platform for deploying and managing endpoints for text classification and other AI models.<SEP>Hugging Face is an organization that provides a platform for evaluating and comparing machine learning models.<SEP>Hugging Face is an organization that provides a range of machine learning models and tools.,8,2025-03-24 13:16:13\n3,\teu-west-1,geo,eu-west-1 is a region in Europe where endpoints can be deployed.,1,2025-03-24 13:16:13\n4,\tus-east-1,geo,us-east-1 is a region in the United States where endpoints can be deployed.,1,2025-03-24 13:16:13\n5,\tAzure,organization,Azure is a cloud provider that will be added soon for deploying endpoints.,0,UNKNOWN\n6,\tAWS,organization,AWS is a cloud provider that is currently available for deploying endpoints, with regions us-east-1 and eu-west-1.,3,UNKNOWN\n7,\teu-west-1,geo,eu-west-1 is a region in Europe where endpoints can be deployed.,1,UNKNOWN\n    ```\n    -----Relationships-----\n    ```csv\n    id,\tsource,\ttarget,\tdescription,\tkeywords,\tweight,\trank,\tcreated_at\n1,\tAWS,Hugging Face,Hugging Face uses AWS as a cloud provider for deploying endpoints.,cloud provider, partnership,16.0,11,2025-03-24 13:16:13\n2,\tAWS,eu-west-1,AWS provides the eu-west-1 region for deploying endpoints.,region, cloud provider,14.0,4,2025-03-24 13:16:13\n3,\tAWS,us-east-1,AWS provides the us-east-1 region for deploying endpoints.,region, cloud provider,14.0,4,2025-03-24 13:16:13\n4,\tAWS,Hugging Face,Hugging Face uses AWS as a cloud provider for deploying endpoints.,cloud provider, partnership,16.0,11,UNKNOWN\n5,\tAWS,us-east-1,AWS provides the us-east-1 region for deploying endpoints.,region, cloud provider,14.0,4,UNKNOWN\n6,\tAWS,eu-west-1,AWS provides the eu-west-1 region for deploying endpoints.,region, cloud provider,14.0,4,UNKNOWN\n    ```\n    -----Sources-----\n    ```csv\n    id,\tcontent\n1,\tCreate an Endpoint\n\nAfter your first login, you will be directed to the [Endpoint creation page](https://ui.endpoints.huggingface.co/new). As an example, this guide will go through the steps to deploy [distilbert-base-uncased-finetuned-sst-2-english](https://huggingface.co/distilbert-base-uncased-finetuned-sst-2-english) for text classification. \n\n## 1. Enter the Hugging Face Repository ID and your desired endpoint name:\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_repository.png\" alt=\"select repository\" />\n\n## 2. Select your Cloud Provider and region. Initially, only AWS will be available as a Cloud Provider with the `us-east-1` and `eu-west-1` regions. We will add Azure soon, and if you need to test Endpoints with other Cloud Providers or regions, please let us know.\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_region.png\" alt=\"select region\" />\n\n## 3. Define the [Security Level](security) for the Endpoint:\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_security.png\" alt=\"define security\" />\n\n## 4. Create your Endpoint by clicking **Create Endpoint**. By default, your Endpoint is created with a medium CPU (2 x 4GB vCPUs with Intel Xeon Ice Lake) The cost estimate assumes the Endpoint will be up for an entire month, and does not take autoscaling into account.\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_create_cost.png\" alt=\"create endpoint\" />\n\n## 5. Wait for the Endpoint to build, initialize and run which can take between 1 to 5 minutes.\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/overview.png\" alt=\"overview\" />\n\n## 6. Test your Endpoint in the overview with the Inference widget \ud83c\udfc1 \ud83c\udf89!\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_inference.png\" alt=\"run inference\" />\n    ```",
            "vector_context": "[Created at: 2025-03-24 13:15:42]\nCreate an Endpoint\n\nAfter your first login, you will be directed to the [Endpoint creation page](https://ui.endpoints.huggingface.co/new). As an example, this guide will go through the steps to deploy [distilbert-base-uncased-finetuned-sst-2-english](https://huggingface.co/distilbert-base-uncased-finetuned-sst-2-english) for text classification. \n\n## 1. Enter the Hugging Face Repository ID and your desired endpoint name:\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_repository.png\" alt=\"select repository\" />\n\n## 2. Select your Cloud Provider and region. Initially, only AWS will be available as a Cloud Provider with the `us-east-1` and `eu-west-1` regions. We will add Azure soon, and if you need to test Endpoints with other Cloud Providers or regions, please let us know.\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_region.png\" alt=\"select region\" />\n\n## 3. Define the [Security Level](security) for the Endpoint:\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_security.png\" alt=\"define security\" />\n\n## 4. Create your Endpoint by clicking **Create Endpoint**. By default, your Endpoint is created with a medium CPU (2 x 4GB vCPUs with Intel Xeon Ice Lake) The cost estimate assumes the Endpoint will be up for an entire month, and does not take autoscaling into account.\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_create_cost.png\" alt=\"create endpoint\" />\n\n## 5. Wait for the Endpoint to build, initialize and run which can take between 1 to 5 minutes.\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/overview.png\" alt=\"overview\" />\n\n## 6. Test your Endpoint in the overview with the Inference widget \ud83c\udfc1 \ud83c\udf89!\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_inference.png\" alt=\"run inference\" />\n--New Chunk--\n[Created at: 2025-03-24 13:17:32]\n!--Copyright 2023 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\nthe License. You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under the License is distributed on\nan \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n\n\u26a0\ufe0f Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be\nrendered properly in your Markdown viewer.\n\n-->\n\n# Training on TPU with TensorFlow\n\n<Tip>\n\nIf you don't need long explanations and just want TPU code samples to get started with, check out [our TPU example notebook!](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb)\n\n</Tip>\n\n### What is a TPU?\n\nA TPU is a **Tensor Processing Unit.** They are hardware designed by Google, which are used to greatly speed up the tensor computations within neural networks, much like GPUs. They can be used for both network training and inference. They are generally accessed through Google\u2019s cloud services, but small TPUs can also be accessed directly for free through Google Colab and Kaggle Kernels.\n\nBecause [all TensorFlow models in \ud83e\udd17 Transformers are Keras models](https://huggingface.co/blog/tensorflow-philosophy), most of the methods in this document are generally applicable to TPU training for any Keras model! However, there are a few points that are specific to the HuggingFace ecosystem (hug-o-system?) of Transformers and Datasets, and we\u2019ll make sure to flag them up when we get to them.\n\n### What kinds of TPU are available?\n\nNew users are often very confused by the range of TPUs, and the different ways to access them. The first key distinction to understand is the difference between **TPU Nodes** and **TPU VMs.**\n\nWhen you use a **TPU Node**, you are effectively indirectly accessing a remote TPU. You will need a separate VM, which will initialize your network and data pipeline and then forward them to the remote node. When you use a TPU on Google Colab, you are accessing it in the **TPU Node** style.\n\nUsing TPU Nodes can have some quite unexpected behaviour for people who aren\u2019t used to them! In particular, because the TPU is located on a physically different system to the machine you\u2019re running your Python code on, your data cannot be local to your machine - any data pipeline that loads from your machine\u2019s internal storage will totally fail! Instead, data must be stored in Google Cloud Storage where your data pipeline can still access it, even when the pipeline is running on the remote TPU node.\n\n<Tip>\n\nIf you can fit all your data in memory as `np.ndarray` or `tf.Tensor`, then you can `fit()` on that data even when using Colab or a TPU Node, without needing to upload it to Google Cloud Storage.\n\n</Tip>\n\n<Tip>\n\n**\ud83e\udd17Specific Hugging Face Tip\ud83e\udd17:** The methods `Dataset.to_tf_dataset()` and its higher-level wrapper `model.prepare_tf_dataset()` , which you will see throughout our TF code examples, will both fail on a TPU Node. The reason for this is that even though they create a `tf.data.Dataset` it is not a \u201cpure\u201d `tf.data` pipeline and uses `tf.numpy_function` or `Dataset.from_generator()` to stream data from the underlying HuggingFace `Dataset`. This HuggingFace `Dataset` is backed by data that is on a local disc and which the remote TPU Node will not be able to read.\n\n</Tip>\n\nThe second way to access a TPU is via a **TPU VM.** When using a TPU VM, you connect directly to the machine that the TPU is attached to, much like training on a GPU VM. TPU VMs are generally easier to work with, particularly when it comes to your data pipeline. All of the above warnings do not apply to TPU VMs!\n\nThis is an opinionated document, so here\u2019s our opinion: **Avoid using TPU Node if possible.** It is more confusing and more difficult to debug than TPU VMs. It is also likely to be unsupported in future - Google\u2019s latest TPU, TPUv4, can only be accessed as a TPU VM, which suggests that TPU Nodes are increasingly going to become a \u201clegacy\u201d access method. However, we understand that the only free TPU access is on Colab and Kaggle Kernels, which uses TPU Node - so we\u2019ll try to explain how to handle it if you have to! Check the [TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) for code samples that explain this in more detail.\n\n### What sizes of TPU are available?\n\nA single TPU (a v2-8/v3-8/v4-8) runs 8 replicas. TPUs exist in **pods** that can run hundreds or thousands of replicas simultaneously. When you use more than a single TPU but less than a whole pod (for example, a v3-32), your TPU fleet is referred to as a **pod slice.**\n\nWhen you access a free TPU via Colab, you generally get a single v2-8 TPU.\n\n### I keep hearing about this XLA thing. What\u2019s XLA, and how does it relate to TPUs?\n\nXLA is an optimizing compiler, used by both TensorFlow and JAX. In JAX it is the only compiler, whereas in TensorFlow it is optional\n--New Chunk--\n[Created at: 2025-03-24 13:16:48]\n\u4e0e\u5e38\u89c4\u51fd\u6570\u76f8\u540c\u7684\u65b9\u5f0f\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio\u3002\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\uff08\u865a\u62df\u7684\uff09\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5b83\u5728\u8f93\u51fa\u56fe\u50cf\u4e4b\u524d\u751f\u6210\u6570\u4e2a\u6b65\u9aa4\u7684\u566a\u97f3\uff1a\n\n$code_fake_diffusion\n$demo_fake_diffusion\n\n\u8bf7\u6ce8\u610f\uff0c\u6211\u4eec\u5728\u8fed\u4ee3\u5668\u4e2d\u6dfb\u52a0\u4e86 `time.sleep(1)`\uff0c\u4ee5\u521b\u5efa\u6b65\u9aa4\u4e4b\u95f4\u7684\u4eba\u5de5\u6682\u505c\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u89c2\u5bdf\u8fed\u4ee3\u5668\u7684\u6b65\u9aa4\uff08\u5728\u771f\u5b9e\u7684\u56fe\u50cf\u751f\u6210\u6a21\u578b\u4e2d\uff0c\u8fd9\u53ef\u80fd\u662f\u4e0d\u5fc5\u8981\u7684\uff09\u3002\n\n\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio **\u9700\u8981**\u5728\u5e95\u5c42 Interface \u6216 Blocks \u4e2d\u542f\u7528\u961f\u5217\uff08\u8bf7\u53c2\u9605\u4e0a\u9762\u7684\u961f\u5217\u90e8\u5206\uff09\u3002\n\n## \u8fdb\u5ea6\u6761\n\nGradio \u652f\u6301\u521b\u5efa\u81ea\u5b9a\u4e49\u8fdb\u5ea6\u6761\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u81ea\u5b9a\u4e49\u548c\u63a7\u5236\u5411\u7528\u6237\u663e\u793a\u7684\u8fdb\u5ea6\u66f4\u65b0\u3002\u8981\u542f\u7528\u6b64\u529f\u80fd\uff0c\u53ea\u9700\u4e3a\u65b9\u6cd5\u6dfb\u52a0\u4e00\u4e2a\u9ed8\u8ba4\u503c\u4e3a `gr.Progress` \u5b9e\u4f8b\u7684\u53c2\u6570\u5373\u53ef\u3002\u7136\u540e\uff0c\u60a8\u53ef\u4ee5\u76f4\u63a5\u8c03\u7528\u6b64\u5b9e\u4f8b\u5e76\u4f20\u5165 0 \u5230 1 \u4e4b\u95f4\u7684\u6d6e\u70b9\u6570\u6765\u66f4\u65b0\u8fdb\u5ea6\u7ea7\u522b\uff0c\u6216\u8005 with `Progress` \u5b9e\u4f8b\u7684 `tqdm()` \u65b9\u6cd5\u6765\u8ddf\u8e2a\u53ef\u8fed\u4ee3\u5bf9\u8c61\u4e0a\u7684\u8fdb\u5ea6\uff0c\u5982\u4e0b\u6240\u793a\u3002\u5fc5\u987b\u542f\u7528\u961f\u5217\u4ee5\u8fdb\u884c\u8fdb\u5ea6\u66f4\u65b0\u3002\n\n$code_progress_simple\n$demo_progress_simple\n\n\u5982\u679c\u60a8 with `tqdm` \u5e93\uff0c\u5e76\u4e14\u5e0c\u671b\u4ece\u51fd\u6570\u5185\u90e8\u7684\u4efb\u4f55 `tqdm.tqdm` \u81ea\u52a8\u62a5\u544a\u8fdb\u5ea6\u66f4\u65b0\uff0c\u8bf7\u5c06\u9ed8\u8ba4\u53c2\u6570\u8bbe\u7f6e\u4e3a `gr.Progress(track_tqdm=True)`\uff01\n\n## \u6279\u5904\u7406\u51fd\u6570 (Batch Functions)\n\nGradio \u652f\u6301\u4f20\u9012*\u6279\u5904\u7406*\u51fd\u6570\u3002\u6279\u5904\u7406\u51fd\u6570\u53ea\u662f\u63a5\u53d7\u8f93\u5165\u5217\u8868\u5e76\u8fd4\u56de\u9884\u6d4b\u5217\u8868\u7684\u51fd\u6570\u3002\n\n\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\u6279\u5904\u7406\u51fd\u6570\uff0c\u5b83\u63a5\u53d7\u4e24\u4e2a\u8f93\u5165\u5217\u8868\uff08\u4e00\u4e2a\u5355\u8bcd\u5217\u8868\u548c\u4e00\u4e2a\u6574\u6570\u5217\u8868\uff09\uff0c\u5e76\u8fd4\u56de\u4fee\u526a\u8fc7\u7684\u5355\u8bcd\u5217\u8868\u4f5c\u4e3a\u8f93\u51fa\uff1a\n\n```python\nimport time\n\ndef trim_words(words, lens):\n    trimmed_words = []\n    time.sleep(5)\n    for w, l in zip(words, lens):\n        trimmed_words.append(w[:int(l)])\n    return [trimmed_words]\n    for w, l in zip(words, lens):\n```\n\n\u4f7f\u7528\u6279\u5904\u7406\u51fd\u6570\u7684\u4f18\u70b9\u662f\uff0c\u5982\u679c\u542f\u7528\u4e86\u961f\u5217\uff0cGradio \u670d\u52a1\u5668\u53ef\u4ee5\u81ea\u52a8*\u6279\u5904\u7406*\u4f20\u5165\u7684\u8bf7\u6c42\u5e76\u5e76\u884c\u5904\u7406\u5b83\u4eec\uff0c\u4ece\u800c\u53ef\u80fd\u52a0\u5feb\u6f14\u793a\u901f\u5ea6\u3002\u4ee5\u4e0b\u662f Gradio \u4ee3\u7801\u7684\u793a\u4f8b\uff08\u8bf7\u6ce8\u610f `batch=True` \u548c `max_batch_size=16` - \u8fd9\u4e24\u4e2a\u53c2\u6570\u90fd\u53ef\u4ee5\u4f20\u9012\u7ed9\u4e8b\u4ef6\u89e6\u53d1\u5668\u6216 `Interface` \u7c7b\uff09\n\nwith `Interface`\uff1a\n\n```python\ndemo = gr.Interface(trim_words, [\"textbox\", \"number\"], [\"output\"],\n                    batch=True, max_batch_size=16)\ndemo.queue()\ndemo.launch()\n```\n\nwith `Blocks`\uff1a\n\n```python\nimport gradio as gr\n\nwith gr.Blocks() as demo:\n    with gr.Row():\n        word = gr.Textbox(label=\"word\")\n        leng = gr.Number(label=\"leng\")\n        output = gr.Textbox(label=\"Output\")\n    with gr.Row():\n        run = gr.Button()\n\n    event = run.click(trim_words, [word, leng], output, batch=True, max_batch_size=16)\n\ndemo.queue()\ndemo.launch()\n```\n\n\u5728\u4e0a\u9762\u7684\u793a\u4f8b\u4e2d\uff0c\u53ef\u4ee5\u5e76\u884c\u5904\u7406 16 \u4e2a\u8bf7\u6c42\uff08\u603b\u63a8\u7406\u65f6\u95f4\u4e3a 5 \u79d2\uff09\uff0c\u800c\u4e0d\u662f\u5206\u522b\u5904\u7406\u6bcf\u4e2a\u8bf7\u6c42\uff08\u603b\u63a8\u7406\u65f6\u95f4\u4e3a 80 \u79d2\uff09\u3002\u8bb8\u591a Hugging Face \u7684 `transformers` \u548c `diffusers` \u6a21\u578b\u5728 Gradio \u7684\u6279\u5904\u7406\u6a21\u5f0f\u4e0b\u81ea\u7136\u5de5\u4f5c\uff1a\u8fd9\u662f[\u4f7f\u7528\u6279\u5904\u7406\u751f\u6210\u56fe\u50cf\u7684\u793a\u4f8b\u6f14\u793a](https://github.com/gradio-app/gradio/blob/main/demo/diffusers_with_batching/run.py)\n\n\u6ce8\u610f\uff1a\u4f7f\u7528 Gradio \u7684\u6279\u5904\u7406\u51fd\u6570 **requires** \u5728\u5e95\u5c42 Interface \u6216 Blocks \u4e2d\u542f\u7528\u961f\u5217\uff08\u8bf7\u53c2\u9605\u4e0a\u9762\u7684\u961f\u5217\u90e8\u5206\uff09\u3002\n\n## Gradio \u7b14\u8bb0\u672c (Colab Notebooks)\n\nGradio \u53ef\u4ee5\u5728\u4efb\u4f55\u8fd0\u884c Python \u7684\u5730\u65b9\u8fd0\u884c\uff0c\u5305\u62ec\u672c\u5730 Jupyter \u7b14\u8bb0\u672c\u548c\u534f\u4f5c\u7b14\u8bb0\u672c\uff0c\u5982[Google Colab](https://colab.research.google.com/)\u3002\u5bf9\u4e8e\u672c\u5730 Jupyter \u7b14\u8bb0\u672c\u548c Google Colab \u7b14\u8bb0\u672c\uff0cGradio \u5728\u672c\u5730\u670d\u52a1\u5668\u4e0a\u8fd0\u884c\uff0c\u60a8\u53ef\u4ee5\u5728\u6d4f\u89c8\u5668\u4e2d\u4e0e\u4e4b\u4ea4\u4e92\u3002\uff08\u6ce8\u610f\uff1a\u5bf9\u4e8e Google Colab\uff0c\u8fd9\u662f\u901a\u8fc7[\u670d\u52a1\u5de5\u4f5c\u5668\u96a7\u9053](https://github.com/tensorflow/tensorboard/blob/master/docs/design/colab_integration.md)\u5b9e\u73b0\u7684\uff0c\u60a8\u7684\u6d4f\u89c8\u5668\u9700\u8981\u542f\u7528 cookies\u3002\uff09\u5bf9\u4e8e\u5176\u4ed6\u8fdc\u7a0b\u7b14\u8bb0\u672c\uff0cGradio \u4e5f\u5c06\u5728\u670d\u52a1\u5668\u4e0a\u8fd0\u884c\uff0c\u4f46\u60a8\u9700\u8981\u4f7f\u7528[SSH \u96a7\u9053](https://coderwall.com/p/ohk6cg/remote-access-to-ipython-notebooks-via-ssh)\u5728\u672c\u5730\u6d4f\u89c8\u5668\u4e2d\u67e5\u770b\u5e94\u7528\u7a0b\u5e8f\u3002\u901a\u5e38\uff0c\u66f4\u7b80\u5355\u7684\u9009\u62e9\u662f\u4f7f\u7528 Gradio \u5185\u7f6e\u7684\u516c\u5171\u94fe\u63a5\uff0c[\u5728\u4e0b\u4e00\u7bc7\u6307\u5357\u4e2d\u8ba8\u8bba](/sharing-your-app/#sharing-demos)\u3002"
        }
    },
    {
        "sample_idx": 3,
        "question": "What are the initial regions available for Endpoint creation on AWS?",
        "answer": "us-east-1 and eu-west-1.",
        "rag_answer": "The initial regions available for Endpoint creation on AWS are `us-east-1` and `eu-west-1`. [KG]",
        "rag_score": 5,
        "rag_feedback": "The system's response is completely correct, accurate, and factual. It exactly matches the expected answer, stating that the initial regions available for Endpoint creation on AWS are us-east-1 and eu-west-1.",
        "rag_context": {
            "kg_context": "-----Entities-----\n    ```csv\n    id,\tentity,\ttype,\tdescription,\trankcreated_at\n1,\tAWS,organization,AWS is a cloud provider that is currently available for deploying endpoints, with regions us-east-1 and eu-west-1.,3,2025-03-24 13:16:13\n2,\tHugging Face,organization,Hugging Face is an organization that provides a platform for deploying and managing endpoints for text classification and other AI models.<SEP>Hugging Face is an organization that provides a platform for evaluating and comparing machine learning models.<SEP>Hugging Face is an organization that provides a range of machine learning models and tools.,8,2025-03-24 13:16:13\n3,\teu-west-1,geo,eu-west-1 is a region in Europe where endpoints can be deployed.,1,2025-03-24 13:16:13\n4,\tus-east-1,geo,us-east-1 is a region in the United States where endpoints can be deployed.,1,2025-03-24 13:16:13\n5,\tAWS,organization,AWS is a cloud provider that is currently available for deploying endpoints, with regions us-east-1 and eu-west-1.,3,UNKNOWN\n6,\teu-west-1,geo,eu-west-1 is a region in Europe where endpoints can be deployed.,1,UNKNOWN\n7,\tus-east-1,geo,us-east-1 is a region in the United States where endpoints can be deployed.,1,UNKNOWN\n    ```\n    -----Relationships-----\n    ```csv\n    id,\tsource,\ttarget,\tdescription,\tkeywords,\tweight,\trank,\tcreated_at\n1,\tAWS,Hugging Face,Hugging Face uses AWS as a cloud provider for deploying endpoints.,cloud provider, partnership,16.0,11,2025-03-24 13:16:13\n2,\tAWS,eu-west-1,AWS provides the eu-west-1 region for deploying endpoints.,region, cloud provider,14.0,4,2025-03-24 13:16:13\n3,\tAWS,us-east-1,AWS provides the us-east-1 region for deploying endpoints.,region, cloud provider,14.0,4,2025-03-24 13:16:13\n4,\tAWS,Hugging Face,Hugging Face uses AWS as a cloud provider for deploying endpoints.,cloud provider, partnership,16.0,11,UNKNOWN\n5,\tAWS,us-east-1,AWS provides the us-east-1 region for deploying endpoints.,region, cloud provider,14.0,4,UNKNOWN\n6,\tAWS,eu-west-1,AWS provides the eu-west-1 region for deploying endpoints.,region, cloud provider,14.0,4,UNKNOWN\n    ```\n    -----Sources-----\n    ```csv\n    id,\tcontent\n1,\tCreate an Endpoint\n\nAfter your first login, you will be directed to the [Endpoint creation page](https://ui.endpoints.huggingface.co/new). As an example, this guide will go through the steps to deploy [distilbert-base-uncased-finetuned-sst-2-english](https://huggingface.co/distilbert-base-uncased-finetuned-sst-2-english) for text classification. \n\n## 1. Enter the Hugging Face Repository ID and your desired endpoint name:\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_repository.png\" alt=\"select repository\" />\n\n## 2. Select your Cloud Provider and region. Initially, only AWS will be available as a Cloud Provider with the `us-east-1` and `eu-west-1` regions. We will add Azure soon, and if you need to test Endpoints with other Cloud Providers or regions, please let us know.\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_region.png\" alt=\"select region\" />\n\n## 3. Define the [Security Level](security) for the Endpoint:\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_security.png\" alt=\"define security\" />\n\n## 4. Create your Endpoint by clicking **Create Endpoint**. By default, your Endpoint is created with a medium CPU (2 x 4GB vCPUs with Intel Xeon Ice Lake) The cost estimate assumes the Endpoint will be up for an entire month, and does not take autoscaling into account.\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_create_cost.png\" alt=\"create endpoint\" />\n\n## 5. Wait for the Endpoint to build, initialize and run which can take between 1 to 5 minutes.\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/overview.png\" alt=\"overview\" />\n\n## 6. Test your Endpoint in the overview with the Inference widget \ud83c\udfc1 \ud83c\udf89!\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_inference.png\" alt=\"run inference\" />\n    ```",
            "vector_context": "[Created at: 2025-03-24 13:15:42]\nCreate an Endpoint\n\nAfter your first login, you will be directed to the [Endpoint creation page](https://ui.endpoints.huggingface.co/new). As an example, this guide will go through the steps to deploy [distilbert-base-uncased-finetuned-sst-2-english](https://huggingface.co/distilbert-base-uncased-finetuned-sst-2-english) for text classification. \n\n## 1. Enter the Hugging Face Repository ID and your desired endpoint name:\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_repository.png\" alt=\"select repository\" />\n\n## 2. Select your Cloud Provider and region. Initially, only AWS will be available as a Cloud Provider with the `us-east-1` and `eu-west-1` regions. We will add Azure soon, and if you need to test Endpoints with other Cloud Providers or regions, please let us know.\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_region.png\" alt=\"select region\" />\n\n## 3. Define the [Security Level](security) for the Endpoint:\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_security.png\" alt=\"define security\" />\n\n## 4. Create your Endpoint by clicking **Create Endpoint**. By default, your Endpoint is created with a medium CPU (2 x 4GB vCPUs with Intel Xeon Ice Lake) The cost estimate assumes the Endpoint will be up for an entire month, and does not take autoscaling into account.\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_create_cost.png\" alt=\"create endpoint\" />\n\n## 5. Wait for the Endpoint to build, initialize and run which can take between 1 to 5 minutes.\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/overview.png\" alt=\"overview\" />\n\n## 6. Test your Endpoint in the overview with the Inference widget \ud83c\udfc1 \ud83c\udf89!\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_inference.png\" alt=\"run inference\" />\n--New Chunk--\n[Created at: 2025-03-24 13:17:32]\n!--Copyright 2023 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\nthe License. You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under the License is distributed on\nan \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n\n\u26a0\ufe0f Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be\nrendered properly in your Markdown viewer.\n\n-->\n\n# Training on TPU with TensorFlow\n\n<Tip>\n\nIf you don't need long explanations and just want TPU code samples to get started with, check out [our TPU example notebook!](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb)\n\n</Tip>\n\n### What is a TPU?\n\nA TPU is a **Tensor Processing Unit.** They are hardware designed by Google, which are used to greatly speed up the tensor computations within neural networks, much like GPUs. They can be used for both network training and inference. They are generally accessed through Google\u2019s cloud services, but small TPUs can also be accessed directly for free through Google Colab and Kaggle Kernels.\n\nBecause [all TensorFlow models in \ud83e\udd17 Transformers are Keras models](https://huggingface.co/blog/tensorflow-philosophy), most of the methods in this document are generally applicable to TPU training for any Keras model! However, there are a few points that are specific to the HuggingFace ecosystem (hug-o-system?) of Transformers and Datasets, and we\u2019ll make sure to flag them up when we get to them.\n\n### What kinds of TPU are available?\n\nNew users are often very confused by the range of TPUs, and the different ways to access them. The first key distinction to understand is the difference between **TPU Nodes** and **TPU VMs.**\n\nWhen you use a **TPU Node**, you are effectively indirectly accessing a remote TPU. You will need a separate VM, which will initialize your network and data pipeline and then forward them to the remote node. When you use a TPU on Google Colab, you are accessing it in the **TPU Node** style.\n\nUsing TPU Nodes can have some quite unexpected behaviour for people who aren\u2019t used to them! In particular, because the TPU is located on a physically different system to the machine you\u2019re running your Python code on, your data cannot be local to your machine - any data pipeline that loads from your machine\u2019s internal storage will totally fail! Instead, data must be stored in Google Cloud Storage where your data pipeline can still access it, even when the pipeline is running on the remote TPU node.\n\n<Tip>\n\nIf you can fit all your data in memory as `np.ndarray` or `tf.Tensor`, then you can `fit()` on that data even when using Colab or a TPU Node, without needing to upload it to Google Cloud Storage.\n\n</Tip>\n\n<Tip>\n\n**\ud83e\udd17Specific Hugging Face Tip\ud83e\udd17:** The methods `Dataset.to_tf_dataset()` and its higher-level wrapper `model.prepare_tf_dataset()` , which you will see throughout our TF code examples, will both fail on a TPU Node. The reason for this is that even though they create a `tf.data.Dataset` it is not a \u201cpure\u201d `tf.data` pipeline and uses `tf.numpy_function` or `Dataset.from_generator()` to stream data from the underlying HuggingFace `Dataset`. This HuggingFace `Dataset` is backed by data that is on a local disc and which the remote TPU Node will not be able to read.\n\n</Tip>\n\nThe second way to access a TPU is via a **TPU VM.** When using a TPU VM, you connect directly to the machine that the TPU is attached to, much like training on a GPU VM. TPU VMs are generally easier to work with, particularly when it comes to your data pipeline. All of the above warnings do not apply to TPU VMs!\n\nThis is an opinionated document, so here\u2019s our opinion: **Avoid using TPU Node if possible.** It is more confusing and more difficult to debug than TPU VMs. It is also likely to be unsupported in future - Google\u2019s latest TPU, TPUv4, can only be accessed as a TPU VM, which suggests that TPU Nodes are increasingly going to become a \u201clegacy\u201d access method. However, we understand that the only free TPU access is on Colab and Kaggle Kernels, which uses TPU Node - so we\u2019ll try to explain how to handle it if you have to! Check the [TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) for code samples that explain this in more detail.\n\n### What sizes of TPU are available?\n\nA single TPU (a v2-8/v3-8/v4-8) runs 8 replicas. TPUs exist in **pods** that can run hundreds or thousands of replicas simultaneously. When you use more than a single TPU but less than a whole pod (for example, a v3-32), your TPU fleet is referred to as a **pod slice.**\n\nWhen you access a free TPU via Colab, you generally get a single v2-8 TPU.\n\n### I keep hearing about this XLA thing. What\u2019s XLA, and how does it relate to TPUs?\n\nXLA is an optimizing compiler, used by both TensorFlow and JAX. In JAX it is the only compiler, whereas in TensorFlow it is optional\n--New Chunk--\n[Created at: 2025-03-24 13:16:13]\n=predictions, references=references)\n>>> results\n{'exact_match': 100.0, 'f1': 100.0}\n```\n\nYou can find examples of dataset structures by consulting the \"Dataset Preview\" function or the dataset card for a given dataset, and you can see how to use its dedicated evaluation function based on the metric card."
        }
    },
    {
        "sample_idx": 4,
        "question": "What is the number of the step to test your Endpoint in the overview with the Inference widget?",
        "answer": "6",
        "rag_answer": "The number of the step to test your Endpoint in the overview with the Inference widget is **6**.",
        "rag_score": 5,
        "rag_feedback": "The system's response is completely correct, accurate, and factual. It provides a detailed and relevant answer to the question, including the correct step number (6) and a brief description of the process.",
        "rag_context": {
            "kg_context": "-----Entities-----\n    ```csv\n    id,\tentity,\ttype,\tdescription,\trankcreated_at\n1,\tLayoutLMv3,technology,LayoutLMv3 is a model used for token classification and form understanding tasks.,11,2025-03-24 13:16:13\n2,\trun_funsd_cord.py,UNKNOWN,run_funsd_cord.py is a script used for fine-tuning the LayoutLMv3 model.,1,2025-03-24 13:16:13\n3,\tTrainer API,technology,Trainer API is a tool used for fine-tuning the LayoutLMv3 model.,1,2025-03-24 13:16:13\n4,\tEndpoint creation page,event,The Endpoint creation page is a webpage where users can create new endpoints.,5,2025-03-24 13:16:13\n5,\tInference widget,category,Inference widget is a tool used for testing endpoints.,1,2025-03-24 13:16:13\n6,\tProgress,category,Progress is a category of components in Gradio that enables the creation of custom progress bars.,1,UNKNOWN\n7,\thttps://huggingface.co/nielsr/layoutlmv3-finetuned-funsd,geo,https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd is the URL of the fine-tuned LayoutLMv3 model.,1,UNKNOWN\n8,\tNumber,category,Number is a component in Gradio that allows users to input numbers.,1,UNKNOWN\n    ```\n    -----Relationships-----\n    ```csv\n    id,\tsource,\ttarget,\tdescription,\tkeywords,\tweight,\trank,\tcreated_at\n1,\tLayoutLMv3,run_funsd_cord.py,run_funsd_cord.py is a script used for fine-tuning the LayoutLMv3 model.,script, model fine-tuning,7.0,12,2025-03-24 13:19:57\n2,\tLayoutLMv3,Trainer API,Trainer API is a tool used for fine-tuning the LayoutLMv3 model.,tool, model fine-tuning,7.0,12,2025-03-24 13:19:57\n3,\tEndpoint creation page,Inference widget,The Endpoint creation page provides an Inference widget for testing endpoints.,testing, endpoint creation,7.0,6,2025-03-24 13:16:13\n4,\tGradio,Progress,Gradio provides the Progress component for creating custom progress bars.,component relationship, progress tracking,14.0,37,UNKNOWN\n5,\tLayoutLMv3,https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd,https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd is the URL of the fine-tuned LayoutLMv3 model.,model URL, knowledge sharing,8.0,12,UNKNOWN\n6,\tNumber,Textbox,Number is a type of input component in Gradio, similar to Textbox.,input components, interface features,7.0,3,UNKNOWN\n    ```\n    -----Sources-----\n    ```csv\n    id,\tcontent\n1,\t!---\nCopyright 2022 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n-->\n\n# Token classification with LayoutLMv3 (PyTorch version)\n\nThis directory contains a script, `run_funsd_cord.py`, that can be used to fine-tune (or evaluate) LayoutLMv3 on form understanding datasets, such as [FUNSD](https://guillaumejaume.github.io/FUNSD/) and [CORD](https://github.com/clovaai/cord).\n\nThe script `run_funsd_cord.py` leverages the \ud83e\udd17 Datasets library and the Trainer API. You can easily customize it to your needs.\n\n## Fine-tuning on FUNSD\n\nFine-tuning LayoutLMv3 for token classification on [FUNSD](https://guillaumejaume.github.io/FUNSD/) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name funsd \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 1e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-funsd\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd. By specifying the `push_to_hub` flag, the model gets uploaded automatically to the hub (regularly), together with a model card, which includes metrics such as precision, recall and F1. Note that you can easily update the model card, as it's just a README file of the respective repo on the hub.\n\nThere's also the \"Training metrics\" [tab](https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd/tensorboard), which shows Tensorboard logs over the course of training. Pretty neat, huh?\n\n## Fine-tuning on CORD\n\nFine-tuning LayoutLMv3 for token classification on [CORD](https://github.com/clovaai/cord) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name cord \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 5e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-cord\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-cord. Note that a model card gets generated automatically in case you specify the `push_to_hub` flag.\n2,\tCreate an Endpoint\n\nAfter your first login, you will be directed to the [Endpoint creation page](https://ui.endpoints.huggingface.co/new). As an example, this guide will go through the steps to deploy [distilbert-base-uncased-finetuned-sst-2-english](https://huggingface.co/distilbert-base-uncased-finetuned-sst-2-english) for text classification. \n\n## 1. Enter the Hugging Face Repository ID and your desired endpoint name:\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_repository.png\" alt=\"select repository\" />\n\n## 2. Select your Cloud Provider and region. Initially, only AWS will be available as a Cloud Provider with the `us-east-1` and `eu-west-1` regions. We will add Azure soon, and if you need to test Endpoints with other Cloud Providers or regions, please let us know.\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_region.png\" alt=\"select region\" />\n\n## 3. Define the [Security Level](security) for the Endpoint:\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_security.png\" alt=\"define security\" />\n\n## 4. Create your Endpoint by clicking **Create Endpoint**. By default, your Endpoint is created with a medium CPU (2 x 4GB vCPUs with Intel Xeon Ice Lake) The cost estimate assumes the Endpoint will be up for an entire month, and does not take autoscaling into account.\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_create_cost.png\" alt=\"create endpoint\" />\n\n## 5. Wait for the Endpoint to build, initialize and run which can take between 1 to 5 minutes.\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/overview.png\" alt=\"overview\" />\n\n## 6. Test your Endpoint in the overview with the Inference widget \ud83c\udfc1 \ud83c\udf89!\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_inference.png\" alt=\"run inference\" />\n3,\t\u4e0e\u5e38\u89c4\u51fd\u6570\u76f8\u540c\u7684\u65b9\u5f0f\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio\u3002\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\uff08\u865a\u62df\u7684\uff09\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5b83\u5728\u8f93\u51fa\u56fe\u50cf\u4e4b\u524d\u751f\u6210\u6570\u4e2a\u6b65\u9aa4\u7684\u566a\u97f3\uff1a\n\n$code_fake_diffusion\n$demo_fake_diffusion\n\n\u8bf7\u6ce8\u610f\uff0c\u6211\u4eec\u5728\u8fed\u4ee3\u5668\u4e2d\u6dfb\u52a0\u4e86 `time.sleep(1)`\uff0c\u4ee5\u521b\u5efa\u6b65\u9aa4\u4e4b\u95f4\u7684\u4eba\u5de5\u6682\u505c\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u89c2\u5bdf\u8fed\u4ee3\u5668\u7684\u6b65\u9aa4\uff08\u5728\u771f\u5b9e\u7684\u56fe\u50cf\u751f\u6210\u6a21\u578b\u4e2d\uff0c\u8fd9\u53ef\u80fd\u662f\u4e0d\u5fc5\u8981\u7684\uff09\u3002\n\n\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio **\u9700\u8981**\u5728\u5e95\u5c42 Interface \u6216 Blocks \u4e2d\u542f\u7528\u961f\u5217\uff08\u8bf7\u53c2\u9605\u4e0a\u9762\u7684\u961f\u5217\u90e8\u5206\uff09\u3002\n\n## \u8fdb\u5ea6\u6761\n\nGradio \u652f\u6301\u521b\u5efa\u81ea\u5b9a\u4e49\u8fdb\u5ea6\u6761\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u81ea\u5b9a\u4e49\u548c\u63a7\u5236\u5411\u7528\u6237\u663e\u793a\u7684\u8fdb\u5ea6\u66f4\u65b0\u3002\u8981\u542f\u7528\u6b64\u529f\u80fd\uff0c\u53ea\u9700\u4e3a\u65b9\u6cd5\u6dfb\u52a0\u4e00\u4e2a\u9ed8\u8ba4\u503c\u4e3a `gr.Progress` \u5b9e\u4f8b\u7684\u53c2\u6570\u5373\u53ef\u3002\u7136\u540e\uff0c\u60a8\u53ef\u4ee5\u76f4\u63a5\u8c03\u7528\u6b64\u5b9e\u4f8b\u5e76\u4f20\u5165 0 \u5230 1 \u4e4b\u95f4\u7684\u6d6e\u70b9\u6570\u6765\u66f4\u65b0\u8fdb\u5ea6\u7ea7\u522b\uff0c\u6216\u8005 with `Progress` \u5b9e\u4f8b\u7684 `tqdm()` \u65b9\u6cd5\u6765\u8ddf\u8e2a\u53ef\u8fed\u4ee3\u5bf9\u8c61\u4e0a\u7684\u8fdb\u5ea6\uff0c\u5982\u4e0b\u6240\u793a\u3002\u5fc5\u987b\u542f\u7528\u961f\u5217\u4ee5\u8fdb\u884c\u8fdb\u5ea6\u66f4\u65b0\u3002\n\n$code_progress_simple\n$demo_progress_simple\n\n\u5982\u679c\u60a8 with `tqdm` \u5e93\uff0c\u5e76\u4e14\u5e0c\u671b\u4ece\u51fd\u6570\u5185\u90e8\u7684\u4efb\u4f55 `tqdm.tqdm` \u81ea\u52a8\u62a5\u544a\u8fdb\u5ea6\u66f4\u65b0\uff0c\u8bf7\u5c06\u9ed8\u8ba4\u53c2\u6570\u8bbe\u7f6e\u4e3a `gr.Progress(track_tqdm=True)`\uff01\n\n## \u6279\u5904\u7406\u51fd\u6570 (Batch Functions)\n\nGradio \u652f\u6301\u4f20\u9012*\u6279\u5904\u7406*\u51fd\u6570\u3002\u6279\u5904\u7406\u51fd\u6570\u53ea\u662f\u63a5\u53d7\u8f93\u5165\u5217\u8868\u5e76\u8fd4\u56de\u9884\u6d4b\u5217\u8868\u7684\u51fd\u6570\u3002\n\n\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\u6279\u5904\u7406\u51fd\u6570\uff0c\u5b83\u63a5\u53d7\u4e24\u4e2a\u8f93\u5165\u5217\u8868\uff08\u4e00\u4e2a\u5355\u8bcd\u5217\u8868\u548c\u4e00\u4e2a\u6574\u6570\u5217\u8868\uff09\uff0c\u5e76\u8fd4\u56de\u4fee\u526a\u8fc7\u7684\u5355\u8bcd\u5217\u8868\u4f5c\u4e3a\u8f93\u51fa\uff1a\n\n```python\nimport time\n\ndef trim_words(words, lens):\n    trimmed_words = []\n    time.sleep(5)\n    for w, l in zip(words, lens):\n        trimmed_words.append(w[:int(l)])\n    return [trimmed_words]\n    for w, l in zip(words, lens):\n```\n\n\u4f7f\u7528\u6279\u5904\u7406\u51fd\u6570\u7684\u4f18\u70b9\u662f\uff0c\u5982\u679c\u542f\u7528\u4e86\u961f\u5217\uff0cGradio \u670d\u52a1\u5668\u53ef\u4ee5\u81ea\u52a8*\u6279\u5904\u7406*\u4f20\u5165\u7684\u8bf7\u6c42\u5e76\u5e76\u884c\u5904\u7406\u5b83\u4eec\uff0c\u4ece\u800c\u53ef\u80fd\u52a0\u5feb\u6f14\u793a\u901f\u5ea6\u3002\u4ee5\u4e0b\u662f Gradio \u4ee3\u7801\u7684\u793a\u4f8b\uff08\u8bf7\u6ce8\u610f `batch=True` \u548c `max_batch_size=16` - \u8fd9\u4e24\u4e2a\u53c2\u6570\u90fd\u53ef\u4ee5\u4f20\u9012\u7ed9\u4e8b\u4ef6\u89e6\u53d1\u5668\u6216 `Interface` \u7c7b\uff09\n\nwith `Interface`\uff1a\n\n```python\ndemo = gr.Interface(trim_words, [\"textbox\", \"number\"], [\"output\"],\n                    batch=True, max_batch_size=16)\ndemo.queue()\ndemo.launch()\n```\n\nwith `Blocks`\uff1a\n\n```python\nimport gradio as gr\n\nwith gr.Blocks() as demo:\n    with gr.Row():\n        word = gr.Textbox(label=\"word\")\n        leng = gr.Number(label=\"leng\")\n        output = gr.Textbox(label=\"Output\")\n    with gr.Row():\n        run = gr.Button()\n\n    event = run.click(trim_words, [word, leng], output, batch=True, max_batch_size=16)\n\ndemo.queue()\ndemo.launch()\n```\n\n\u5728\u4e0a\u9762\u7684\u793a\u4f8b\u4e2d\uff0c\u53ef\u4ee5\u5e76\u884c\u5904\u7406 16 \u4e2a\u8bf7\u6c42\uff08\u603b\u63a8\u7406\u65f6\u95f4\u4e3a 5 \u79d2\uff09\uff0c\u800c\u4e0d\u662f\u5206\u522b\u5904\u7406\u6bcf\u4e2a\u8bf7\u6c42\uff08\u603b\u63a8\u7406\u65f6\u95f4\u4e3a 80 \u79d2\uff09\u3002\u8bb8\u591a Hugging Face \u7684 `transformers` \u548c `diffusers` \u6a21\u578b\u5728 Gradio \u7684\u6279\u5904\u7406\u6a21\u5f0f\u4e0b\u81ea\u7136\u5de5\u4f5c\uff1a\u8fd9\u662f[\u4f7f\u7528\u6279\u5904\u7406\u751f\u6210\u56fe\u50cf\u7684\u793a\u4f8b\u6f14\u793a](https://github.com/gradio-app/gradio/blob/main/demo/diffusers_with_batching/run.py)\n\n\u6ce8\u610f\uff1a\u4f7f\u7528 Gradio \u7684\u6279\u5904\u7406\u51fd\u6570 **requires** \u5728\u5e95\u5c42 Interface \u6216 Blocks \u4e2d\u542f\u7528\u961f\u5217\uff08\u8bf7\u53c2\u9605\u4e0a\u9762\u7684\u961f\u5217\u90e8\u5206\uff09\u3002\n\n## Gradio \u7b14\u8bb0\u672c (Colab Notebooks)\n\nGradio \u53ef\u4ee5\u5728\u4efb\u4f55\u8fd0\u884c Python \u7684\u5730\u65b9\u8fd0\u884c\uff0c\u5305\u62ec\u672c\u5730 Jupyter \u7b14\u8bb0\u672c\u548c\u534f\u4f5c\u7b14\u8bb0\u672c\uff0c\u5982[Google Colab](https://colab.research.google.com/)\u3002\u5bf9\u4e8e\u672c\u5730 Jupyter \u7b14\u8bb0\u672c\u548c Google Colab \u7b14\u8bb0\u672c\uff0cGradio \u5728\u672c\u5730\u670d\u52a1\u5668\u4e0a\u8fd0\u884c\uff0c\u60a8\u53ef\u4ee5\u5728\u6d4f\u89c8\u5668\u4e2d\u4e0e\u4e4b\u4ea4\u4e92\u3002\uff08\u6ce8\u610f\uff1a\u5bf9\u4e8e Google Colab\uff0c\u8fd9\u662f\u901a\u8fc7[\u670d\u52a1\u5de5\u4f5c\u5668\u96a7\u9053](https://github.com/tensorflow/tensorboard/blob/master/docs/design/colab_integration.md)\u5b9e\u73b0\u7684\uff0c\u60a8\u7684\u6d4f\u89c8\u5668\u9700\u8981\u542f\u7528 cookies\u3002\uff09\u5bf9\u4e8e\u5176\u4ed6\u8fdc\u7a0b\u7b14\u8bb0\u672c\uff0cGradio \u4e5f\u5c06\u5728\u670d\u52a1\u5668\u4e0a\u8fd0\u884c\uff0c\u4f46\u60a8\u9700\u8981\u4f7f\u7528[SSH \u96a7\u9053](https://coderwall.com/p/ohk6cg/remote-access-to-ipython-notebooks-via-ssh)\u5728\u672c\u5730\u6d4f\u89c8\u5668\u4e2d\u67e5\u770b\u5e94\u7528\u7a0b\u5e8f\u3002\u901a\u5e38\uff0c\u66f4\u7b80\u5355\u7684\u9009\u62e9\u662f\u4f7f\u7528 Gradio \u5185\u7f6e\u7684\u516c\u5171\u94fe\u63a5\uff0c[\u5728\u4e0b\u4e00\u7bc7\u6307\u5357\u4e2d\u8ba8\u8bba](/sharing-your-app/#sharing-demos)\u3002\n4,\t\u4e3b\u8981\u7279\u70b9\n\n\u8ba9\u6211\u4eec\u6765\u4ecb\u7ecd\u4e00\u4e0b Gradio \u6700\u53d7\u6b22\u8fce\u7684\u4e00\u4e9b\u529f\u80fd\uff01\u8fd9\u91cc\u662f Gradio \u7684\u4e3b\u8981\u7279\u70b9\uff1a\n\n1. [\u6dfb\u52a0\u793a\u4f8b\u8f93\u5165](#example-inputs)\n2. [\u4f20\u9012\u81ea\u5b9a\u4e49\u9519\u8bef\u6d88\u606f](#errors)\n3. [\u6dfb\u52a0\u63cf\u8ff0\u5185\u5bb9](#descriptive-content)\n4. [\u8bbe\u7f6e\u65d7\u6807](#flagging)\n5. [\u9884\u5904\u7406\u548c\u540e\u5904\u7406](#preprocessing-and-postprocessing)\n6. [\u6837\u5f0f\u5316\u6f14\u793a](#styling)\n7. [\u6392\u961f\u7528\u6237](#queuing)\n8. [\u8fed\u4ee3\u8f93\u51fa](#iterative-outputs)\n9. [\u8fdb\u5ea6\u6761](#progress-bars)\n10. [\u6279\u5904\u7406\u51fd\u6570](#batch-functions)\n11. [\u5728\u534f\u4f5c\u7b14\u8bb0\u672c\u4e0a\u8fd0\u884c](#colab-notebooks)\n\n## \u793a\u4f8b\u8f93\u5165\n\n\u60a8\u53ef\u4ee5\u63d0\u4f9b\u7528\u6237\u53ef\u4ee5\u8f7b\u677e\u52a0\u8f7d\u5230 \"Interface\" \u4e2d\u7684\u793a\u4f8b\u6570\u636e\u3002\u8fd9\u5bf9\u4e8e\u6f14\u793a\u6a21\u578b\u671f\u671b\u7684\u8f93\u5165\u7c7b\u578b\u4ee5\u53ca\u6f14\u793a\u6570\u636e\u96c6\u548c\u6a21\u578b\u4e00\u8d77\u63a2\u7d22\u7684\u65b9\u5f0f\u975e\u5e38\u6709\u5e2e\u52a9\u3002\u8981\u52a0\u8f7d\u793a\u4f8b\u6570\u636e\uff0c\u60a8\u53ef\u4ee5\u5c06\u5d4c\u5957\u5217\u8868\u63d0\u4f9b\u7ed9 Interface \u6784\u9020\u51fd\u6570\u7684 `examples=` \u5173\u952e\u5b57\u53c2\u6570\u3002\u5916\u90e8\u5217\u8868\u4e2d\u7684\u6bcf\u4e2a\u5b50\u5217\u8868\u8868\u793a\u4e00\u4e2a\u6570\u636e\u6837\u672c\uff0c\u5b50\u5217\u8868\u4e2d\u7684\u6bcf\u4e2a\u5143\u7d20\u8868\u793a\u6bcf\u4e2a\u8f93\u5165\u7ec4\u4ef6\u7684\u8f93\u5165\u3002\u6709\u5173\u6bcf\u4e2a\u7ec4\u4ef6\u7684\u793a\u4f8b\u6570\u636e\u683c\u5f0f\u5728[Docs](https://gradio.app/docs#components)\u4e2d\u6709\u8bf4\u660e\u3002\n\n$code_calculator\n$demo_calculator\n\n\u60a8\u53ef\u4ee5\u5c06\u5927\u578b\u6570\u636e\u96c6\u52a0\u8f7d\u5230\u793a\u4f8b\u4e2d\uff0c\u901a\u8fc7 Gradio \u6d4f\u89c8\u548c\u4e0e\u6570\u636e\u96c6\u8fdb\u884c\u4ea4\u4e92\u3002\u793a\u4f8b\u5c06\u81ea\u52a8\u5206\u9875\uff08\u53ef\u4ee5\u901a\u8fc7 Interface \u7684 `examples_per_page` \u53c2\u6570\u8fdb\u884c\u914d\u7f6e\uff09\u3002\n\n\u7ee7\u7eed\u4e86\u89e3\u793a\u4f8b\uff0c\u8bf7\u53c2\u9605[\u66f4\u591a\u793a\u4f8b](https://gradio.app/more-on-examples)\u6307\u5357\u3002\n\n## \u9519\u8bef\n\n\u60a8\u5e0c\u671b\u5411\u7528\u6237\u4f20\u9012\u81ea\u5b9a\u4e49\u9519\u8bef\u6d88\u606f\u3002\u4e3a\u6b64\uff0cwith `gr.Error(\"custom message\")` \u6765\u663e\u793a\u9519\u8bef\u6d88\u606f\u3002\u5982\u679c\u5728\u4e0a\u9762\u7684\u8ba1\u7b97\u5668\u793a\u4f8b\u4e2d\u5c1d\u8bd5\u9664\u4ee5\u96f6\uff0c\u5c06\u663e\u793a\u81ea\u5b9a\u4e49\u9519\u8bef\u6d88\u606f\u7684\u5f39\u51fa\u6a21\u6001\u7a97\u53e3\u3002\u4e86\u89e3\u6709\u5173\u9519\u8bef\u7684\u66f4\u591a\u4fe1\u606f\uff0c\u8bf7\u53c2\u9605[\u6587\u6863](https://gradio.app/docs#error)\u3002\n\n## \u63cf\u8ff0\u6027\u5185\u5bb9\n\n\u5728\u524d\u9762\u7684\u793a\u4f8b\u4e2d\uff0c\u60a8\u53ef\u80fd\u5df2\u7ecf\u6ce8\u610f\u5230 Interface \u6784\u9020\u51fd\u6570\u4e2d\u7684 `title=` \u548c `description=` \u5173\u952e\u5b57\u53c2\u6570\uff0c\u5e2e\u52a9\u7528\u6237\u4e86\u89e3\u60a8\u7684\u5e94\u7528\u7a0b\u5e8f\u3002\n\nInterface \u6784\u9020\u51fd\u6570\u4e2d\u6709\u4e09\u4e2a\u53c2\u6570\u7528\u4e8e\u6307\u5b9a\u6b64\u5185\u5bb9\u5e94\u653e\u7f6e\u5728\u54ea\u91cc\uff1a\n\n- `title`\uff1a\u63a5\u53d7\u6587\u672c\uff0c\u5e76\u53ef\u4ee5\u5c06\u5176\u663e\u793a\u5728\u754c\u9762\u7684\u9876\u90e8\uff0c\u4e5f\u5c06\u6210\u4e3a\u9875\u9762\u6807\u9898\u3002\n- `description`\uff1a\u63a5\u53d7\u6587\u672c\u3001Markdown \u6216 HTML\uff0c\u5e76\u5c06\u5176\u653e\u7f6e\u5728\u6807\u9898\u6b63\u4e0b\u65b9\u3002\n- `article`\uff1a\u4e5f\u63a5\u53d7\u6587\u672c\u3001Markdown \u6216 HTML\uff0c\u5e76\u5c06\u5176\u653e\u7f6e\u5728\u754c\u9762\u4e0b\u65b9\u3002\n\n![annotated](/assets/guides/annotated.png)\n\n\u5982\u679c\u60a8\u4f7f\u7528\u7684\u662f `Blocks` API\uff0c\u5219\u53ef\u4ee5 with `gr.Markdown(...)` \u6216 `gr.HTML(...)` \u7ec4\u4ef6\u5728\u4efb\u4f55\u4f4d\u7f6e\u63d2\u5165\u6587\u672c\u3001Markdown \u6216 HTML\uff0c\u5176\u4e2d\u63cf\u8ff0\u6027\u5185\u5bb9\u4f4d\u4e8e `Component` \u6784\u9020\u51fd\u6570\u5185\u90e8\u3002\n\n\u53e6\u4e00\u4e2a\u6709\u7528\u7684\u5173\u952e\u5b57\u53c2\u6570\u662f `label=`\uff0c\u5b83\u5b58\u5728\u4e8e\u6bcf\u4e2a `Component` \u4e2d\u3002\u8fd9\u4fee\u6539\u4e86\u6bcf\u4e2a `Component` \u9876\u90e8\u7684\u6807\u7b7e\u6587\u672c\u3002\u8fd8\u53ef\u4ee5\u4e3a\u8bf8\u5982 `Textbox` \u6216 `Radio` \u4e4b\u7c7b\u7684\u8868\u5355\u5143\u7d20\u6dfb\u52a0 `info=` \u5173\u952e\u5b57\u53c2\u6570\uff0c\u4ee5\u63d0\u4f9b\u6709\u5173\u5176\u7528\u6cd5\u7684\u8fdb\u4e00\u6b65\u4fe1\u606f\u3002\n\n```python\ngr.Number(label='\u5e74\u9f84', info='\u4ee5\u5e74\u4e3a\u5355\u4f4d\uff0c\u5fc5\u987b\u5927\u4e8e0')\n```\n\n## \u65d7\u6807\n\n\u9ed8\u8ba4\u60c5\u51b5\u4e0b\uff0c\"Interface\" \u5c06\u6709\u4e00\u4e2a \"Flag\" \u6309\u94ae\u3002\u5f53\u7528\u6237\u6d4b\u8bd5\u60a8\u7684 `Interface` \u65f6\uff0c\u5982\u679c\u770b\u5230\u6709\u8da3\u7684\u8f93\u51fa\uff0c\u4f8b\u5982\u9519\u8bef\u6216\u610f\u5916\u7684\u6a21\u578b\u884c\u4e3a\uff0c\u4ed6\u4eec\u53ef\u4ee5\u5c06\u8f93\u5165\u6807\u8bb0\u4e3a\u60a8\u8fdb\u884c\u67e5\u770b\u3002\u5728\u7531 `Interface` \u6784\u9020\u51fd\u6570\u7684 `flagging_dir=` \u53c2\u6570\u63d0\u4f9b\u7684\u76ee\u5f55\u4e2d\uff0c\u5c06\u8bb0\u5f55\u6807\u8bb0\u7684\u8f93\u5165\u5230\u4e00\u4e2a CSV \u6587\u4ef6\u4e2d\u3002\u5982\u679c\u754c\u9762\u6d89\u53ca\u6587\u4ef6\u6570\u636e\uff0c\u4f8b\u5982\u56fe\u50cf\u548c\u97f3\u9891\u7ec4\u4ef6\uff0c\u5c06\u521b\u5efa\u6587\u4ef6\u5939\u6765\u5b58\u50a8\u8fd9\u4e9b\u6807\u8bb0\u7684\u6570\u636e\u3002\n\n\u4f8b\u5982\uff0c\u5bf9\u4e8e\u4e0a\u9762\u663e\u793a\u7684\u8ba1\u7b97\u5668\u754c\u9762\uff0c\u6211\u4eec\u5c06\u5728\u4e0b\u9762\u7684\u65d7\u6807\u76ee\u5f55\u4e2d\u5b58\u50a8\u6807\u8bb0\u7684\u6570\u636e\uff1a\n\n```directory\n+-- calculator.py\n+-- flagged/\n|   +-- logs.csv\n```\n\n_flagged/logs.csv_\n\n```csv\nnum1,operation,num2,Output\n5,add,7,12\n6,subtract,1.5,4.5\n```\n\n\u4e0e\u65e9\u671f\u663e\u793a\u7684\u51b7\u8272\u754c\u9762\u76f8\u5bf9\u5e94\uff0c\u6211\u4eec\u5c06\u5728\u4e0b\u9762\u7684\u65d7\u6807\u76ee\u5f55\u4e2d\u5b58\u50a8\u6807\u8bb0\u7684\u6570\u636e\uff1a\n\n```directory\n+-- sepia.py\n+-- flagged/\n|   +-- logs.csv\n|   +-- im/\n|   |   +-- 0.png\n|   |   +-- 1.png\n|   +-- Output/\n|   |   +-- 0.png\n|   |   +-- 1.png\n```\n\n_flagged/logs.csv_\n\n```csv\nim,Output\nim/0.png,Output/0.png\nim/1.png,Output/1.png\n```\n\n\u5982\u679c\u60a8\u5e0c\u671b\u7528\u6237\u63d0\u4f9b\u65d7\u6807\u539f\u56e0\uff0c\u53ef\u4ee5\u5c06\u5b57\u7b26\u4e32\u5217\u8868\u4f20\u9012\u7ed9 Interface \u7684 `flagging_options` \u53c2\u6570\u3002\u7528\u6237\u5728\u8fdb\u884c\u65d7\u6807\u65f6\u5fc5\u987b\u9009\u62e9\u5176\u4e2d\u4e00\u4e2a\u5b57\u7b26\u4e32\uff0c\u8fd9\u5c06\u4f5c\u4e3a\u9644\u52a0\u5217\u4fdd\u5b58\u5230 CSV \u4e2d\u3002\n\n## \u9884\u5904\u7406\u548c\u540e\u5904\u7406 (Preprocessing and Postprocessing)\n\n![annotated](/assets/img/dataflow.svg)\n\n\u5982\u60a8\u6240\u89c1\uff0cGradio \u5305\u62ec\u53ef\u4ee5\u5904\u7406\u5404\u79cd\u4e0d\u540c\u6570\u636e\u7c7b\u578b\u7684\u7ec4\u4ef6\uff0c\u4f8b\u5982\u56fe\u50cf\u3001\u97f3\u9891\u548c\u89c6\u9891\u3002\u5927\u591a\u6570\u7ec4\u4ef6\u90fd\u53ef\u4ee5\u7528\u4f5c\u8f93\u5165\u6216\u8f93\u51fa\u3002\n\n\u5f53\u7ec4\u4ef6\u7528\u4f5c\u8f93\u5165\u65f6\uff0cGradio \u81ea\u52a8\u5904\u7406*\u9884\u5904\u7406*\uff0c\u5c06\u6570\u636e\u4ece\u7528\u6237\n    ```",
            "vector_context": "[Created at: 2025-03-24 13:15:42]\nCreate an Endpoint\n\nAfter your first login, you will be directed to the [Endpoint creation page](https://ui.endpoints.huggingface.co/new). As an example, this guide will go through the steps to deploy [distilbert-base-uncased-finetuned-sst-2-english](https://huggingface.co/distilbert-base-uncased-finetuned-sst-2-english) for text classification. \n\n## 1. Enter the Hugging Face Repository ID and your desired endpoint name:\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_repository.png\" alt=\"select repository\" />\n\n## 2. Select your Cloud Provider and region. Initially, only AWS will be available as a Cloud Provider with the `us-east-1` and `eu-west-1` regions. We will add Azure soon, and if you need to test Endpoints with other Cloud Providers or regions, please let us know.\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_region.png\" alt=\"select region\" />\n\n## 3. Define the [Security Level](security) for the Endpoint:\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_security.png\" alt=\"define security\" />\n\n## 4. Create your Endpoint by clicking **Create Endpoint**. By default, your Endpoint is created with a medium CPU (2 x 4GB vCPUs with Intel Xeon Ice Lake) The cost estimate assumes the Endpoint will be up for an entire month, and does not take autoscaling into account.\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_create_cost.png\" alt=\"create endpoint\" />\n\n## 5. Wait for the Endpoint to build, initialize and run which can take between 1 to 5 minutes.\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/overview.png\" alt=\"overview\" />\n\n## 6. Test your Endpoint in the overview with the Inference widget \ud83c\udfc1 \ud83c\udf89!\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_inference.png\" alt=\"run inference\" />\n--New Chunk--\n[Created at: 2025-03-24 13:16:13]\n=predictions, references=references)\n>>> results\n{'exact_match': 100.0, 'f1': 100.0}\n```\n\nYou can find examples of dataset structures by consulting the \"Dataset Preview\" function or the dataset card for a given dataset, and you can see how to use its dedicated evaluation function based on the metric card.\n--New Chunk--\n[Created at: 2025-03-24 13:16:48]\n\u4e0e\u5e38\u89c4\u51fd\u6570\u76f8\u540c\u7684\u65b9\u5f0f\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio\u3002\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\uff08\u865a\u62df\u7684\uff09\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5b83\u5728\u8f93\u51fa\u56fe\u50cf\u4e4b\u524d\u751f\u6210\u6570\u4e2a\u6b65\u9aa4\u7684\u566a\u97f3\uff1a\n\n$code_fake_diffusion\n$demo_fake_diffusion\n\n\u8bf7\u6ce8\u610f\uff0c\u6211\u4eec\u5728\u8fed\u4ee3\u5668\u4e2d\u6dfb\u52a0\u4e86 `time.sleep(1)`\uff0c\u4ee5\u521b\u5efa\u6b65\u9aa4\u4e4b\u95f4\u7684\u4eba\u5de5\u6682\u505c\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u89c2\u5bdf\u8fed\u4ee3\u5668\u7684\u6b65\u9aa4\uff08\u5728\u771f\u5b9e\u7684\u56fe\u50cf\u751f\u6210\u6a21\u578b\u4e2d\uff0c\u8fd9\u53ef\u80fd\u662f\u4e0d\u5fc5\u8981\u7684\uff09\u3002\n\n\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio **\u9700\u8981**\u5728\u5e95\u5c42 Interface \u6216 Blocks \u4e2d\u542f\u7528\u961f\u5217\uff08\u8bf7\u53c2\u9605\u4e0a\u9762\u7684\u961f\u5217\u90e8\u5206\uff09\u3002\n\n## \u8fdb\u5ea6\u6761\n\nGradio \u652f\u6301\u521b\u5efa\u81ea\u5b9a\u4e49\u8fdb\u5ea6\u6761\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u81ea\u5b9a\u4e49\u548c\u63a7\u5236\u5411\u7528\u6237\u663e\u793a\u7684\u8fdb\u5ea6\u66f4\u65b0\u3002\u8981\u542f\u7528\u6b64\u529f\u80fd\uff0c\u53ea\u9700\u4e3a\u65b9\u6cd5\u6dfb\u52a0\u4e00\u4e2a\u9ed8\u8ba4\u503c\u4e3a `gr.Progress` \u5b9e\u4f8b\u7684\u53c2\u6570\u5373\u53ef\u3002\u7136\u540e\uff0c\u60a8\u53ef\u4ee5\u76f4\u63a5\u8c03\u7528\u6b64\u5b9e\u4f8b\u5e76\u4f20\u5165 0 \u5230 1 \u4e4b\u95f4\u7684\u6d6e\u70b9\u6570\u6765\u66f4\u65b0\u8fdb\u5ea6\u7ea7\u522b\uff0c\u6216\u8005 with `Progress` \u5b9e\u4f8b\u7684 `tqdm()` \u65b9\u6cd5\u6765\u8ddf\u8e2a\u53ef\u8fed\u4ee3\u5bf9\u8c61\u4e0a\u7684\u8fdb\u5ea6\uff0c\u5982\u4e0b\u6240\u793a\u3002\u5fc5\u987b\u542f\u7528\u961f\u5217\u4ee5\u8fdb\u884c\u8fdb\u5ea6\u66f4\u65b0\u3002\n\n$code_progress_simple\n$demo_progress_simple\n\n\u5982\u679c\u60a8 with `tqdm` \u5e93\uff0c\u5e76\u4e14\u5e0c\u671b\u4ece\u51fd\u6570\u5185\u90e8\u7684\u4efb\u4f55 `tqdm.tqdm` \u81ea\u52a8\u62a5\u544a\u8fdb\u5ea6\u66f4\u65b0\uff0c\u8bf7\u5c06\u9ed8\u8ba4\u53c2\u6570\u8bbe\u7f6e\u4e3a `gr.Progress(track_tqdm=True)`\uff01\n\n## \u6279\u5904\u7406\u51fd\u6570 (Batch Functions)\n\nGradio \u652f\u6301\u4f20\u9012*\u6279\u5904\u7406*\u51fd\u6570\u3002\u6279\u5904\u7406\u51fd\u6570\u53ea\u662f\u63a5\u53d7\u8f93\u5165\u5217\u8868\u5e76\u8fd4\u56de\u9884\u6d4b\u5217\u8868\u7684\u51fd\u6570\u3002\n\n\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\u6279\u5904\u7406\u51fd\u6570\uff0c\u5b83\u63a5\u53d7\u4e24\u4e2a\u8f93\u5165\u5217\u8868\uff08\u4e00\u4e2a\u5355\u8bcd\u5217\u8868\u548c\u4e00\u4e2a\u6574\u6570\u5217\u8868\uff09\uff0c\u5e76\u8fd4\u56de\u4fee\u526a\u8fc7\u7684\u5355\u8bcd\u5217\u8868\u4f5c\u4e3a\u8f93\u51fa\uff1a\n\n```python\nimport time\n\ndef trim_words(words, lens):\n    trimmed_words = []\n    time.sleep(5)\n    for w, l in zip(words, lens):\n        trimmed_words.append(w[:int(l)])\n    return [trimmed_words]\n    for w, l in zip(words, lens):\n```\n\n\u4f7f\u7528\u6279\u5904\u7406\u51fd\u6570\u7684\u4f18\u70b9\u662f\uff0c\u5982\u679c\u542f\u7528\u4e86\u961f\u5217\uff0cGradio \u670d\u52a1\u5668\u53ef\u4ee5\u81ea\u52a8*\u6279\u5904\u7406*\u4f20\u5165\u7684\u8bf7\u6c42\u5e76\u5e76\u884c\u5904\u7406\u5b83\u4eec\uff0c\u4ece\u800c\u53ef\u80fd\u52a0\u5feb\u6f14\u793a\u901f\u5ea6\u3002\u4ee5\u4e0b\u662f Gradio \u4ee3\u7801\u7684\u793a\u4f8b\uff08\u8bf7\u6ce8\u610f `batch=True` \u548c `max_batch_size=16` - \u8fd9\u4e24\u4e2a\u53c2\u6570\u90fd\u53ef\u4ee5\u4f20\u9012\u7ed9\u4e8b\u4ef6\u89e6\u53d1\u5668\u6216 `Interface` \u7c7b\uff09\n\nwith `Interface`\uff1a\n\n```python\ndemo = gr.Interface(trim_words, [\"textbox\", \"number\"], [\"output\"],\n                    batch=True, max_batch_size=16)\ndemo.queue()\ndemo.launch()\n```\n\nwith `Blocks`\uff1a\n\n```python\nimport gradio as gr\n\nwith gr.Blocks() as demo:\n    with gr.Row():\n        word = gr.Textbox(label=\"word\")\n        leng = gr.Number(label=\"leng\")\n        output = gr.Textbox(label=\"Output\")\n    with gr.Row():\n        run = gr.Button()\n\n    event = run.click(trim_words, [word, leng], output, batch=True, max_batch_size=16)\n\ndemo.queue()\ndemo.launch()\n```\n\n\u5728\u4e0a\u9762\u7684\u793a\u4f8b\u4e2d\uff0c\u53ef\u4ee5\u5e76\u884c\u5904\u7406 16 \u4e2a\u8bf7\u6c42\uff08\u603b\u63a8\u7406\u65f6\u95f4\u4e3a 5 \u79d2\uff09\uff0c\u800c\u4e0d\u662f\u5206\u522b\u5904\u7406\u6bcf\u4e2a\u8bf7\u6c42\uff08\u603b\u63a8\u7406\u65f6\u95f4\u4e3a 80 \u79d2\uff09\u3002\u8bb8\u591a Hugging Face \u7684 `transformers` \u548c `diffusers` \u6a21\u578b\u5728 Gradio \u7684\u6279\u5904\u7406\u6a21\u5f0f\u4e0b\u81ea\u7136\u5de5\u4f5c\uff1a\u8fd9\u662f[\u4f7f\u7528\u6279\u5904\u7406\u751f\u6210\u56fe\u50cf\u7684\u793a\u4f8b\u6f14\u793a](https://github.com/gradio-app/gradio/blob/main/demo/diffusers_with_batching/run.py)\n\n\u6ce8\u610f\uff1a\u4f7f\u7528 Gradio \u7684\u6279\u5904\u7406\u51fd\u6570 **requires** \u5728\u5e95\u5c42 Interface \u6216 Blocks \u4e2d\u542f\u7528\u961f\u5217\uff08\u8bf7\u53c2\u9605\u4e0a\u9762\u7684\u961f\u5217\u90e8\u5206\uff09\u3002\n\n## Gradio \u7b14\u8bb0\u672c (Colab Notebooks)\n\nGradio \u53ef\u4ee5\u5728\u4efb\u4f55\u8fd0\u884c Python \u7684\u5730\u65b9\u8fd0\u884c\uff0c\u5305\u62ec\u672c\u5730 Jupyter \u7b14\u8bb0\u672c\u548c\u534f\u4f5c\u7b14\u8bb0\u672c\uff0c\u5982[Google Colab](https://colab.research.google.com/)\u3002\u5bf9\u4e8e\u672c\u5730 Jupyter \u7b14\u8bb0\u672c\u548c Google Colab \u7b14\u8bb0\u672c\uff0cGradio \u5728\u672c\u5730\u670d\u52a1\u5668\u4e0a\u8fd0\u884c\uff0c\u60a8\u53ef\u4ee5\u5728\u6d4f\u89c8\u5668\u4e2d\u4e0e\u4e4b\u4ea4\u4e92\u3002\uff08\u6ce8\u610f\uff1a\u5bf9\u4e8e Google Colab\uff0c\u8fd9\u662f\u901a\u8fc7[\u670d\u52a1\u5de5\u4f5c\u5668\u96a7\u9053](https://github.com/tensorflow/tensorboard/blob/master/docs/design/colab_integration.md)\u5b9e\u73b0\u7684\uff0c\u60a8\u7684\u6d4f\u89c8\u5668\u9700\u8981\u542f\u7528 cookies\u3002\uff09\u5bf9\u4e8e\u5176\u4ed6\u8fdc\u7a0b\u7b14\u8bb0\u672c\uff0cGradio \u4e5f\u5c06\u5728\u670d\u52a1\u5668\u4e0a\u8fd0\u884c\uff0c\u4f46\u60a8\u9700\u8981\u4f7f\u7528[SSH \u96a7\u9053](https://coderwall.com/p/ohk6cg/remote-access-to-ipython-notebooks-via-ssh)\u5728\u672c\u5730\u6d4f\u89c8\u5668\u4e2d\u67e5\u770b\u5e94\u7528\u7a0b\u5e8f\u3002\u901a\u5e38\uff0c\u66f4\u7b80\u5355\u7684\u9009\u62e9\u662f\u4f7f\u7528 Gradio \u5185\u7f6e\u7684\u516c\u5171\u94fe\u63a5\uff0c[\u5728\u4e0b\u4e00\u7bc7\u6307\u5357\u4e2d\u8ba8\u8bba](/sharing-your-app/#sharing-demos)\u3002"
        }
    },
    {
        "sample_idx": 5,
        "question": "What is the name of the widget used to test your Endpoint in the overview?",
        "answer": "Inference widget",
        "rag_answer": "The widget used to test your Endpoint in the overview is called the Inference widget.",
        "rag_score": 5,
        "rag_feedback": "The system's response is completely correct, accurate, and factual. It correctly identifies the Inference widget as the tool used for testing endpoints in the overview.",
        "rag_context": {
            "kg_context": "-----Entities-----\n    ```csv\n    id,\tentity,\ttype,\tdescription,\trankcreated_at\n1,\tEndpoint creation page,event,The Endpoint creation page is a webpage where users can create new endpoints.,5,2025-03-24 13:16:13\n2,\tHugging Face,organization,Hugging Face is an organization that provides a platform for deploying and managing endpoints for text classification and other AI models.<SEP>Hugging Face is an organization that provides a platform for evaluating and comparing machine learning models.<SEP>Hugging Face is an organization that provides a range of machine learning models and tools.,8,2025-03-24 13:16:13\n3,\tInference widget,category,Inference widget is a tool used for testing endpoints.,1,2025-03-24 13:16:13\n4,\tSecurity Level,category,Security Level refers to the level of security for an endpoint, which can be defined during creation.,1,2025-03-24 13:16:13\n5,\tInference widget,category,Inference widget is a tool used for testing endpoints.,1,UNKNOWN\n6,\tEndpoint creation page,event,The Endpoint creation page is a webpage where users can create new endpoints.,5,UNKNOWN\n7,\tTrainer API,technology,Trainer API is a tool used for fine-tuning the LayoutLMv3 model.,1,UNKNOWN\n    ```\n    -----Relationships-----\n    ```csv\n    id,\tsource,\ttarget,\tdescription,\tkeywords,\tweight,\trank,\tcreated_at\n1,\tEndpoint creation page,Hugging Face,Hugging Face provides an Endpoint creation page for users to create new endpoints.,platform, endpoint creation,8.0,13,2025-03-24 13:16:13\n2,\tEndpoint creation page,Inference widget,The Endpoint creation page provides an Inference widget for testing endpoints.,testing, endpoint creation,7.0,6,2025-03-24 13:16:13\n3,\tEndpoint creation page,Security Level,The Endpoint creation page allows users to define the Security Level for an endpoint.,security, endpoint creation,7.0,6,2025-03-24 13:16:13\n4,\tEndpoint creation page,Hugging Face,Hugging Face provides an Endpoint creation page for users to create new endpoints.,platform, endpoint creation,8.0,13,UNKNOWN\n5,\tLayoutLMv3,Trainer API,Trainer API is a tool used for fine-tuning the LayoutLMv3 model.,tool, model fine-tuning,7.0,12,UNKNOWN\n6,\tEndpoint creation page,Inference widget,The Endpoint creation page provides an Inference widget for testing endpoints.,testing, endpoint creation,7.0,6,UNKNOWN\n7,\tEndpoint creation page,Hugging Face Repository ID,The Endpoint creation page requires a Hugging Face Repository ID for endpoint creation.,repository ID, endpoint creation,7.0,6,UNKNOWN\n8,\tEndpoint creation page,Security Level,The Endpoint creation page allows users to define the Security Level for an endpoint.,security, endpoint creation,7.0,6,UNKNOWN\n9,\tEndpoint creation page,Intel Xeon Ice Lake,The Endpoint creation page uses Intel Xeon Ice Lake CPUs for endpoint deployment.,CPU, endpoint deployment,7.0,6,UNKNOWN\n    ```\n    -----Sources-----\n    ```csv\n    id,\tcontent\n1,\tCreate an Endpoint\n\nAfter your first login, you will be directed to the [Endpoint creation page](https://ui.endpoints.huggingface.co/new). As an example, this guide will go through the steps to deploy [distilbert-base-uncased-finetuned-sst-2-english](https://huggingface.co/distilbert-base-uncased-finetuned-sst-2-english) for text classification. \n\n## 1. Enter the Hugging Face Repository ID and your desired endpoint name:\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_repository.png\" alt=\"select repository\" />\n\n## 2. Select your Cloud Provider and region. Initially, only AWS will be available as a Cloud Provider with the `us-east-1` and `eu-west-1` regions. We will add Azure soon, and if you need to test Endpoints with other Cloud Providers or regions, please let us know.\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_region.png\" alt=\"select region\" />\n\n## 3. Define the [Security Level](security) for the Endpoint:\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_security.png\" alt=\"define security\" />\n\n## 4. Create your Endpoint by clicking **Create Endpoint**. By default, your Endpoint is created with a medium CPU (2 x 4GB vCPUs with Intel Xeon Ice Lake) The cost estimate assumes the Endpoint will be up for an entire month, and does not take autoscaling into account.\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_create_cost.png\" alt=\"create endpoint\" />\n\n## 5. Wait for the Endpoint to build, initialize and run which can take between 1 to 5 minutes.\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/overview.png\" alt=\"overview\" />\n\n## 6. Test your Endpoint in the overview with the Inference widget \ud83c\udfc1 \ud83c\udf89!\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_inference.png\" alt=\"run inference\" />\n2,\t!---\nCopyright 2022 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n-->\n\n# Token classification with LayoutLMv3 (PyTorch version)\n\nThis directory contains a script, `run_funsd_cord.py`, that can be used to fine-tune (or evaluate) LayoutLMv3 on form understanding datasets, such as [FUNSD](https://guillaumejaume.github.io/FUNSD/) and [CORD](https://github.com/clovaai/cord).\n\nThe script `run_funsd_cord.py` leverages the \ud83e\udd17 Datasets library and the Trainer API. You can easily customize it to your needs.\n\n## Fine-tuning on FUNSD\n\nFine-tuning LayoutLMv3 for token classification on [FUNSD](https://guillaumejaume.github.io/FUNSD/) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name funsd \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 1e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-funsd\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd. By specifying the `push_to_hub` flag, the model gets uploaded automatically to the hub (regularly), together with a model card, which includes metrics such as precision, recall and F1. Note that you can easily update the model card, as it's just a README file of the respective repo on the hub.\n\nThere's also the \"Training metrics\" [tab](https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd/tensorboard), which shows Tensorboard logs over the course of training. Pretty neat, huh?\n\n## Fine-tuning on CORD\n\nFine-tuning LayoutLMv3 for token classification on [CORD](https://github.com/clovaai/cord) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name cord \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 5e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-cord\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-cord. Note that a model card gets generated automatically in case you specify the `push_to_hub` flag.\n    ```",
            "vector_context": "[Created at: 2025-03-24 13:15:42]\nCreate an Endpoint\n\nAfter your first login, you will be directed to the [Endpoint creation page](https://ui.endpoints.huggingface.co/new). As an example, this guide will go through the steps to deploy [distilbert-base-uncased-finetuned-sst-2-english](https://huggingface.co/distilbert-base-uncased-finetuned-sst-2-english) for text classification. \n\n## 1. Enter the Hugging Face Repository ID and your desired endpoint name:\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_repository.png\" alt=\"select repository\" />\n\n## 2. Select your Cloud Provider and region. Initially, only AWS will be available as a Cloud Provider with the `us-east-1` and `eu-west-1` regions. We will add Azure soon, and if you need to test Endpoints with other Cloud Providers or regions, please let us know.\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_region.png\" alt=\"select region\" />\n\n## 3. Define the [Security Level](security) for the Endpoint:\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_security.png\" alt=\"define security\" />\n\n## 4. Create your Endpoint by clicking **Create Endpoint**. By default, your Endpoint is created with a medium CPU (2 x 4GB vCPUs with Intel Xeon Ice Lake) The cost estimate assumes the Endpoint will be up for an entire month, and does not take autoscaling into account.\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_create_cost.png\" alt=\"create endpoint\" />\n\n## 5. Wait for the Endpoint to build, initialize and run which can take between 1 to 5 minutes.\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/overview.png\" alt=\"overview\" />\n\n## 6. Test your Endpoint in the overview with the Inference widget \ud83c\udfc1 \ud83c\udf89!\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_inference.png\" alt=\"run inference\" />\n--New Chunk--\n[Created at: 2025-03-24 13:16:13]\n=predictions, references=references)\n>>> results\n{'exact_match': 100.0, 'f1': 100.0}\n```\n\nYou can find examples of dataset structures by consulting the \"Dataset Preview\" function or the dataset card for a given dataset, and you can see how to use its dedicated evaluation function based on the metric card.\n--New Chunk--\n[Created at: 2025-03-24 13:19:17]\n!---\nCopyright 2022 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n-->\n\n# Token classification with LayoutLMv3 (PyTorch version)\n\nThis directory contains a script, `run_funsd_cord.py`, that can be used to fine-tune (or evaluate) LayoutLMv3 on form understanding datasets, such as [FUNSD](https://guillaumejaume.github.io/FUNSD/) and [CORD](https://github.com/clovaai/cord).\n\nThe script `run_funsd_cord.py` leverages the \ud83e\udd17 Datasets library and the Trainer API. You can easily customize it to your needs.\n\n## Fine-tuning on FUNSD\n\nFine-tuning LayoutLMv3 for token classification on [FUNSD](https://guillaumejaume.github.io/FUNSD/) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name funsd \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 1e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-funsd\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd. By specifying the `push_to_hub` flag, the model gets uploaded automatically to the hub (regularly), together with a model card, which includes metrics such as precision, recall and F1. Note that you can easily update the model card, as it's just a README file of the respective repo on the hub.\n\nThere's also the \"Training metrics\" [tab](https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd/tensorboard), which shows Tensorboard logs over the course of training. Pretty neat, huh?\n\n## Fine-tuning on CORD\n\nFine-tuning LayoutLMv3 for token classification on [CORD](https://github.com/clovaai/cord) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name cord \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 5e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-cord\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-cord. Note that a model card gets generated automatically in case you specify the `push_to_hub` flag."
        }
    },
    {
        "sample_idx": 6,
        "question": "How many high-level categories of metrics are there?",
        "answer": "There are 3 high-level categories of metrics.",
        "rag_answer": "There are 3 high-level categories of metrics:\n\n1. **Generic metrics**: These can be applied to a variety of situations and datasets, such as precision and accuracy.\n2. **Task-specific metrics**: These are limited to a given task, such as Machine Translation (often evaluated using metrics like BLEU or ROUGE) or Named Entity Recognition (often evaluated with seqeval).\n3. **Dataset-specific metrics**: These aim to measure model performance on specific benchmarks, such as the GLUE benchmark, which has a dedicated evaluation metric.\n\nReferences:\n[DC] Choosing a metric for your task\n[KG] Entities and relationships",
        "rag_score": 5,
        "rag_feedback": "The system's response is completely correct, accurate, and factual. It provides a clear and detailed explanation of the three high-level categories of metrics, including generic metrics, task-specific metrics, and dataset-specific metrics, which aligns with the expected answer.",
        "rag_context": {
            "kg_context": "-----Entities-----\n    ```csv\n    id,\tentity,\ttype,\tdescription,\trankcreated_at\n1,\tMachine Learning,category,Machine Learning is a field of study that involves training models to make predictions.,5,2025-03-24 13:16:48\n2,\tprecision,category,precision is a category of evaluation metrics for machine learning models.,1,2025-03-24 13:16:48\n3,\taccuracy,category,accuracy is a category of evaluation metrics for machine learning models.,1,2025-03-24 13:16:48\n4,\tExact Match,category,Exact Match is a metric used to evaluate the performance of a model.,1,2025-03-24 13:16:48\n5,\tF1,category,F1 is a metric used to evaluate the performance of a model.,1,2025-03-24 13:16:48\n6,\taccuracy,category,accuracy is a category of evaluation metrics for machine learning models.,1,UNKNOWN\n7,\tprecision,category,precision is a category of evaluation metrics for machine learning models.,1,UNKNOWN\n8,\tF1,category,F1 is a metric used to evaluate the performance of a model.,1,UNKNOWN\n    ```\n    -----Relationships-----\n    ```csv\n    id,\tsource,\ttarget,\tdescription,\tkeywords,\tweight,\trank,\tcreated_at\n1,\tMachine Learning,precision,precision is a metric used to evaluate machine learning models.,evaluation metric, task,9.0,6,2025-03-24 13:16:48\n2,\tMachine Learning,accuracy,accuracy is a metric used to evaluate machine learning models.,evaluation metric, task,9.0,6,2025-03-24 13:16:48\n3,\tExact Match,F1,Exact Match and F1 are both metrics used to evaluate the performance of a model.,evaluation metrics, performance assessment,8.0,2,2025-03-24 13:16:48\n4,\tMachine Learning,accuracy,accuracy is a metric used to evaluate machine learning models.,evaluation metric, task,9.0,6,UNKNOWN\n5,\tMachine Learning,precision,precision is a metric used to evaluate machine learning models.,evaluation metric, task,9.0,6,UNKNOWN\n6,\tExact Match,F1,Exact Match and F1 are both metrics used to evaluate the performance of a model.,evaluation metrics, performance assessment,8.0,2,UNKNOWN\n    ```\n    -----Sources-----\n    ```csv\n    id,\tcontent\n1,\tChoosing a metric for your task\n\n**So you've trained your model and want to see how well it\u2019s doing on a dataset of your choice. Where do you start?**\n\nThere is no \u201cone size fits all\u201d approach to choosing an evaluation metric, but some good guidelines to keep in mind are:\n\n## Categories of metrics\n\nThere are 3 high-level categories of metrics:\n\n1. *Generic metrics*, which can be applied to a variety of situations and datasets, such as precision and accuracy.\n2. *Task-specific metrics*, which are limited to a given task, such as Machine Translation (often evaluated using metrics [BLEU](https://huggingface.co/metrics/bleu) or [ROUGE](https://huggingface.co/metrics/rouge)) or Named Entity Recognition (often evaluated with [seqeval](https://huggingface.co/metrics/seqeval)).\n3. *Dataset-specific metrics*, which aim to measure model performance on specific benchmarks: for instance, the [GLUE benchmark](https://huggingface.co/datasets/glue) has a dedicated [evaluation metric](https://huggingface.co/metrics/glue).\n\nLet's look at each of these three cases:\n\n### Generic metrics\n\nMany of the metrics used in the Machine Learning community are quite generic and can be applied in a variety of tasks and datasets.\n\nThis is the case for metrics like [accuracy](https://huggingface.co/metrics/accuracy) and [precision](https://huggingface.co/metrics/precision), which can be used for evaluating labeled (supervised) datasets, as well as [perplexity](https://huggingface.co/metrics/perplexity), which can be used for evaluating different kinds of (unsupervised) generative tasks.\n\nTo see the input structure of a given metric, you can look at its metric card. For example, in the case of [precision](https://huggingface.co/metrics/precision), the format is:\n```\n>>> precision_metric = evaluate.load(\"precision\")\n>>> results = precision_metric.compute(references=[0, 1], predictions=[0, 1])\n>>> print(results)\n{'precision': 1.0}\n```\n\n### Task-specific metrics\n\nPopular ML tasks like Machine Translation and Named Entity Recognition have specific metrics that can be used to compare models. For example, a series of different metrics have been proposed for text generation, ranging from [BLEU](https://huggingface.co/metrics/bleu) and its derivatives such as [GoogleBLEU](https://huggingface.co/metrics/google_bleu) and [GLEU](https://huggingface.co/metrics/gleu), but also [ROUGE](https://huggingface.co/metrics/rouge), [MAUVE](https://huggingface.co/metrics/mauve), etc.\n\nYou can find the right metric for your task by:\n\n- **Looking at the [Task pages](https://huggingface.co/tasks)** to see what metrics can be used for evaluating models for a given task.\n- **Checking out leaderboards** on sites like [Papers With Code](https://paperswithcode.com/) (you can search by task and by dataset).\n-  **Reading the metric cards** for the relevant metrics and see which ones are a good fit for your use case. For example, see the [BLEU metric card](https://github.com/huggingface/evaluate/tree/main/metrics/bleu) or [SQuaD metric card](https://github.com/huggingface/evaluate/tree/main/metrics/squad).\n- **Looking at papers and blog posts** published on the topic and see what metrics they report. This can change over time, so try to pick papers from the last couple of years!\n\n### Dataset-specific metrics\n\nSome datasets have specific metrics associated with them -- this is especially in the case of popular benchmarks like [GLUE](https://huggingface.co/metrics/glue) and [SQuAD](https://huggingface.co/metrics/squad).\n\n<Tip warning={true}>\n\ud83d\udca1\nGLUE is actually a collection of different subsets on different tasks, so first you need to choose the one that corresponds to the NLI task, such as mnli, which is described as \u201ccrowdsourced collection of sentence pairs with textual entailment annotations\u201d\n</Tip>\n\n\nIf you are evaluating your model on a benchmark dataset like the ones mentioned above, you can use its dedicated evaluation metric. Make sure you respect the format that they require. For example, to evaluate your model on the [SQuAD](https://huggingface.co/datasets/squad) dataset, you need to feed the `question` and `context` into your model and return the `prediction_text`, which should be compared with the `references` (based on matching the `id` of the question) :\n\n```\n>>> from evaluate import load\n>>> squad_metric = load(\"squad\")\n>>> predictions = [{'prediction_text': '1976', 'id': '56e10a3be3433e1400422b22'}]\n>>> references = [{'answers': {'answer_start': [97], 'text': ['1976']}, 'id': '56e10a3be3433e1400422b22'}]\n>>> results = squad_metric.compute(predictions=predictions, references=references)\n>>> results\n{'exact_match': 100.0, 'f1': 100.0}\n```\n\nYou can find examples of dataset structures by consulting the \"Dataset Preview\" function or the dataset card for a given dataset, and you can see how to use its dedicated evaluation function based on the metric card.\n2,\t=predictions, references=references)\n>>> results\n{'exact_match': 100.0, 'f1': 100.0}\n```\n\nYou can find examples of dataset structures by consulting the \"Dataset Preview\" function or the dataset card for a given dataset, and you can see how to use its dedicated evaluation function based on the metric card.\n    ```",
            "vector_context": "[Created at: 2025-03-24 13:16:13]\nChoosing a metric for your task\n\n**So you've trained your model and want to see how well it\u2019s doing on a dataset of your choice. Where do you start?**\n\nThere is no \u201cone size fits all\u201d approach to choosing an evaluation metric, but some good guidelines to keep in mind are:\n\n## Categories of metrics\n\nThere are 3 high-level categories of metrics:\n\n1. *Generic metrics*, which can be applied to a variety of situations and datasets, such as precision and accuracy.\n2. *Task-specific metrics*, which are limited to a given task, such as Machine Translation (often evaluated using metrics [BLEU](https://huggingface.co/metrics/bleu) or [ROUGE](https://huggingface.co/metrics/rouge)) or Named Entity Recognition (often evaluated with [seqeval](https://huggingface.co/metrics/seqeval)).\n3. *Dataset-specific metrics*, which aim to measure model performance on specific benchmarks: for instance, the [GLUE benchmark](https://huggingface.co/datasets/glue) has a dedicated [evaluation metric](https://huggingface.co/metrics/glue).\n\nLet's look at each of these three cases:\n\n### Generic metrics\n\nMany of the metrics used in the Machine Learning community are quite generic and can be applied in a variety of tasks and datasets.\n\nThis is the case for metrics like [accuracy](https://huggingface.co/metrics/accuracy) and [precision](https://huggingface.co/metrics/precision), which can be used for evaluating labeled (supervised) datasets, as well as [perplexity](https://huggingface.co/metrics/perplexity), which can be used for evaluating different kinds of (unsupervised) generative tasks.\n\nTo see the input structure of a given metric, you can look at its metric card. For example, in the case of [precision](https://huggingface.co/metrics/precision), the format is:\n```\n>>> precision_metric = evaluate.load(\"precision\")\n>>> results = precision_metric.compute(references=[0, 1], predictions=[0, 1])\n>>> print(results)\n{'precision': 1.0}\n```\n\n### Task-specific metrics\n\nPopular ML tasks like Machine Translation and Named Entity Recognition have specific metrics that can be used to compare models. For example, a series of different metrics have been proposed for text generation, ranging from [BLEU](https://huggingface.co/metrics/bleu) and its derivatives such as [GoogleBLEU](https://huggingface.co/metrics/google_bleu) and [GLEU](https://huggingface.co/metrics/gleu), but also [ROUGE](https://huggingface.co/metrics/rouge), [MAUVE](https://huggingface.co/metrics/mauve), etc.\n\nYou can find the right metric for your task by:\n\n- **Looking at the [Task pages](https://huggingface.co/tasks)** to see what metrics can be used for evaluating models for a given task.\n- **Checking out leaderboards** on sites like [Papers With Code](https://paperswithcode.com/) (you can search by task and by dataset).\n-  **Reading the metric cards** for the relevant metrics and see which ones are a good fit for your use case. For example, see the [BLEU metric card](https://github.com/huggingface/evaluate/tree/main/metrics/bleu) or [SQuaD metric card](https://github.com/huggingface/evaluate/tree/main/metrics/squad).\n- **Looking at papers and blog posts** published on the topic and see what metrics they report. This can change over time, so try to pick papers from the last couple of years!\n\n### Dataset-specific metrics\n\nSome datasets have specific metrics associated with them -- this is especially in the case of popular benchmarks like [GLUE](https://huggingface.co/metrics/glue) and [SQuAD](https://huggingface.co/metrics/squad).\n\n<Tip warning={true}>\n\ud83d\udca1\nGLUE is actually a collection of different subsets on different tasks, so first you need to choose the one that corresponds to the NLI task, such as mnli, which is described as \u201ccrowdsourced collection of sentence pairs with textual entailment annotations\u201d\n</Tip>\n\n\nIf you are evaluating your model on a benchmark dataset like the ones mentioned above, you can use its dedicated evaluation metric. Make sure you respect the format that they require. For example, to evaluate your model on the [SQuAD](https://huggingface.co/datasets/squad) dataset, you need to feed the `question` and `context` into your model and return the `prediction_text`, which should be compared with the `references` (based on matching the `id` of the question) :\n\n```\n>>> from evaluate import load\n>>> squad_metric = load(\"squad\")\n>>> predictions = [{'prediction_text': '1976', 'id': '56e10a3be3433e1400422b22'}]\n>>> references = [{'answers': {'answer_start': [97], 'text': ['1976']}, 'id': '56e10a3be3433e1400422b22'}]\n>>> results = squad_metric.compute(predictions=predictions, references=references)\n>>> results\n{'exact_match': 100.0, 'f1': 100.0}\n```\n\nYou can find examples of dataset structures by consulting the \"Dataset Preview\" function or the dataset card for a given dataset, and you can see how to use its dedicated evaluation function based on the metric card.\n--New Chunk--\n[Created at: 2025-03-24 13:16:13]\n=predictions, references=references)\n>>> results\n{'exact_match': 100.0, 'f1': 100.0}\n```\n\nYou can find examples of dataset structures by consulting the \"Dataset Preview\" function or the dataset card for a given dataset, and you can see how to use its dedicated evaluation function based on the metric card.\n--New Chunk--\n[Created at: 2025-03-24 13:19:17]\n!---\nCopyright 2022 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n-->\n\n# Token classification with LayoutLMv3 (PyTorch version)\n\nThis directory contains a script, `run_funsd_cord.py`, that can be used to fine-tune (or evaluate) LayoutLMv3 on form understanding datasets, such as [FUNSD](https://guillaumejaume.github.io/FUNSD/) and [CORD](https://github.com/clovaai/cord).\n\nThe script `run_funsd_cord.py` leverages the \ud83e\udd17 Datasets library and the Trainer API. You can easily customize it to your needs.\n\n## Fine-tuning on FUNSD\n\nFine-tuning LayoutLMv3 for token classification on [FUNSD](https://guillaumejaume.github.io/FUNSD/) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name funsd \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 1e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-funsd\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd. By specifying the `push_to_hub` flag, the model gets uploaded automatically to the hub (regularly), together with a model card, which includes metrics such as precision, recall and F1. Note that you can easily update the model card, as it's just a README file of the respective repo on the hub.\n\nThere's also the \"Training metrics\" [tab](https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd/tensorboard), which shows Tensorboard logs over the course of training. Pretty neat, huh?\n\n## Fine-tuning on CORD\n\nFine-tuning LayoutLMv3 for token classification on [CORD](https://github.com/clovaai/cord) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name cord \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 5e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-cord\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-cord. Note that a model card gets generated automatically in case you specify the `push_to_hub` flag."
        }
    },
    {
        "sample_idx": 7,
        "question": "What are the three high-level categories of metrics?",
        "answer": "The three high-level categories of metrics are generic metrics, task-specific metrics, and dataset-specific metrics.",
        "rag_answer": "The three high-level categories of metrics are:\n\n### 1. Generic metrics\nThese metrics can be applied to a variety of situations and datasets, such as precision and accuracy.\n\n### 2. Task-specific metrics\nThese metrics are limited to a given task, such as Machine Translation (often evaluated using metrics [BLEU](https://huggingface.co/metrics/bleu) or [ROUGE](https://huggingface.co/metrics/rouge)) or Named Entity Recognition (often evaluated with [seqeval](https://huggingface.co/metrics/seqeval)).\n\n### 3. Dataset-specific metrics\nThese metrics aim to measure model performance on specific benchmarks: for instance, the [GLUE benchmark](https://huggingface.co/datasets/glue) has a dedicated [evaluation metric](https://huggingface.co/metrics/glue).\n\nReferences:\n[KG] Entities: Machine Learning, precision, accuracy, Exact Match, F1\n[DC] Choosing a metric for your task",
        "rag_score": 5,
        "rag_feedback": "The system's response is completely correct, accurate, and factual. It provides a clear and detailed explanation of the three high-level categories of metrics, including generic metrics, task-specific metrics, and dataset-specific metrics, which matches the expected answer.",
        "rag_context": {
            "kg_context": "-----Entities-----\n    ```csv\n    id,\tentity,\ttype,\tdescription,\trankcreated_at\n1,\tMachine Learning,category,Machine Learning is a field of study that involves training models to make predictions.,5,2025-03-24 13:16:48\n2,\tprecision,category,precision is a category of evaluation metrics for machine learning models.,1,2025-03-24 13:16:48\n3,\taccuracy,category,accuracy is a category of evaluation metrics for machine learning models.,1,2025-03-24 13:16:48\n4,\tExact Match,category,Exact Match is a metric used to evaluate the performance of a model.,1,2025-03-24 13:16:48\n5,\tF1,category,F1 is a metric used to evaluate the performance of a model.,1,2025-03-24 13:16:48\n6,\tF1,category,F1 is a metric used to evaluate the performance of a model.,1,UNKNOWN\n7,\tprecision,category,precision is a category of evaluation metrics for machine learning models.,1,UNKNOWN\n8,\taccuracy,category,accuracy is a category of evaluation metrics for machine learning models.,1,UNKNOWN\n    ```\n    -----Relationships-----\n    ```csv\n    id,\tsource,\ttarget,\tdescription,\tkeywords,\tweight,\trank,\tcreated_at\n1,\tMachine Learning,precision,precision is a metric used to evaluate machine learning models.,evaluation metric, task,9.0,6,2025-03-24 13:16:48\n2,\tMachine Learning,accuracy,accuracy is a metric used to evaluate machine learning models.,evaluation metric, task,9.0,6,2025-03-24 13:16:48\n3,\tExact Match,F1,Exact Match and F1 are both metrics used to evaluate the performance of a model.,evaluation metrics, performance assessment,8.0,2,2025-03-24 13:16:48\n4,\tMachine Learning,precision,precision is a metric used to evaluate machine learning models.,evaluation metric, task,9.0,6,UNKNOWN\n5,\tMachine Learning,accuracy,accuracy is a metric used to evaluate machine learning models.,evaluation metric, task,9.0,6,UNKNOWN\n6,\tExact Match,F1,Exact Match and F1 are both metrics used to evaluate the performance of a model.,evaluation metrics, performance assessment,8.0,2,UNKNOWN\n    ```\n    -----Sources-----\n    ```csv\n    id,\tcontent\n1,\tChoosing a metric for your task\n\n**So you've trained your model and want to see how well it\u2019s doing on a dataset of your choice. Where do you start?**\n\nThere is no \u201cone size fits all\u201d approach to choosing an evaluation metric, but some good guidelines to keep in mind are:\n\n## Categories of metrics\n\nThere are 3 high-level categories of metrics:\n\n1. *Generic metrics*, which can be applied to a variety of situations and datasets, such as precision and accuracy.\n2. *Task-specific metrics*, which are limited to a given task, such as Machine Translation (often evaluated using metrics [BLEU](https://huggingface.co/metrics/bleu) or [ROUGE](https://huggingface.co/metrics/rouge)) or Named Entity Recognition (often evaluated with [seqeval](https://huggingface.co/metrics/seqeval)).\n3. *Dataset-specific metrics*, which aim to measure model performance on specific benchmarks: for instance, the [GLUE benchmark](https://huggingface.co/datasets/glue) has a dedicated [evaluation metric](https://huggingface.co/metrics/glue).\n\nLet's look at each of these three cases:\n\n### Generic metrics\n\nMany of the metrics used in the Machine Learning community are quite generic and can be applied in a variety of tasks and datasets.\n\nThis is the case for metrics like [accuracy](https://huggingface.co/metrics/accuracy) and [precision](https://huggingface.co/metrics/precision), which can be used for evaluating labeled (supervised) datasets, as well as [perplexity](https://huggingface.co/metrics/perplexity), which can be used for evaluating different kinds of (unsupervised) generative tasks.\n\nTo see the input structure of a given metric, you can look at its metric card. For example, in the case of [precision](https://huggingface.co/metrics/precision), the format is:\n```\n>>> precision_metric = evaluate.load(\"precision\")\n>>> results = precision_metric.compute(references=[0, 1], predictions=[0, 1])\n>>> print(results)\n{'precision': 1.0}\n```\n\n### Task-specific metrics\n\nPopular ML tasks like Machine Translation and Named Entity Recognition have specific metrics that can be used to compare models. For example, a series of different metrics have been proposed for text generation, ranging from [BLEU](https://huggingface.co/metrics/bleu) and its derivatives such as [GoogleBLEU](https://huggingface.co/metrics/google_bleu) and [GLEU](https://huggingface.co/metrics/gleu), but also [ROUGE](https://huggingface.co/metrics/rouge), [MAUVE](https://huggingface.co/metrics/mauve), etc.\n\nYou can find the right metric for your task by:\n\n- **Looking at the [Task pages](https://huggingface.co/tasks)** to see what metrics can be used for evaluating models for a given task.\n- **Checking out leaderboards** on sites like [Papers With Code](https://paperswithcode.com/) (you can search by task and by dataset).\n-  **Reading the metric cards** for the relevant metrics and see which ones are a good fit for your use case. For example, see the [BLEU metric card](https://github.com/huggingface/evaluate/tree/main/metrics/bleu) or [SQuaD metric card](https://github.com/huggingface/evaluate/tree/main/metrics/squad).\n- **Looking at papers and blog posts** published on the topic and see what metrics they report. This can change over time, so try to pick papers from the last couple of years!\n\n### Dataset-specific metrics\n\nSome datasets have specific metrics associated with them -- this is especially in the case of popular benchmarks like [GLUE](https://huggingface.co/metrics/glue) and [SQuAD](https://huggingface.co/metrics/squad).\n\n<Tip warning={true}>\n\ud83d\udca1\nGLUE is actually a collection of different subsets on different tasks, so first you need to choose the one that corresponds to the NLI task, such as mnli, which is described as \u201ccrowdsourced collection of sentence pairs with textual entailment annotations\u201d\n</Tip>\n\n\nIf you are evaluating your model on a benchmark dataset like the ones mentioned above, you can use its dedicated evaluation metric. Make sure you respect the format that they require. For example, to evaluate your model on the [SQuAD](https://huggingface.co/datasets/squad) dataset, you need to feed the `question` and `context` into your model and return the `prediction_text`, which should be compared with the `references` (based on matching the `id` of the question) :\n\n```\n>>> from evaluate import load\n>>> squad_metric = load(\"squad\")\n>>> predictions = [{'prediction_text': '1976', 'id': '56e10a3be3433e1400422b22'}]\n>>> references = [{'answers': {'answer_start': [97], 'text': ['1976']}, 'id': '56e10a3be3433e1400422b22'}]\n>>> results = squad_metric.compute(predictions=predictions, references=references)\n>>> results\n{'exact_match': 100.0, 'f1': 100.0}\n```\n\nYou can find examples of dataset structures by consulting the \"Dataset Preview\" function or the dataset card for a given dataset, and you can see how to use its dedicated evaluation function based on the metric card.\n2,\t=predictions, references=references)\n>>> results\n{'exact_match': 100.0, 'f1': 100.0}\n```\n\nYou can find examples of dataset structures by consulting the \"Dataset Preview\" function or the dataset card for a given dataset, and you can see how to use its dedicated evaluation function based on the metric card.\n    ```",
            "vector_context": "[Created at: 2025-03-24 13:16:13]\nChoosing a metric for your task\n\n**So you've trained your model and want to see how well it\u2019s doing on a dataset of your choice. Where do you start?**\n\nThere is no \u201cone size fits all\u201d approach to choosing an evaluation metric, but some good guidelines to keep in mind are:\n\n## Categories of metrics\n\nThere are 3 high-level categories of metrics:\n\n1. *Generic metrics*, which can be applied to a variety of situations and datasets, such as precision and accuracy.\n2. *Task-specific metrics*, which are limited to a given task, such as Machine Translation (often evaluated using metrics [BLEU](https://huggingface.co/metrics/bleu) or [ROUGE](https://huggingface.co/metrics/rouge)) or Named Entity Recognition (often evaluated with [seqeval](https://huggingface.co/metrics/seqeval)).\n3. *Dataset-specific metrics*, which aim to measure model performance on specific benchmarks: for instance, the [GLUE benchmark](https://huggingface.co/datasets/glue) has a dedicated [evaluation metric](https://huggingface.co/metrics/glue).\n\nLet's look at each of these three cases:\n\n### Generic metrics\n\nMany of the metrics used in the Machine Learning community are quite generic and can be applied in a variety of tasks and datasets.\n\nThis is the case for metrics like [accuracy](https://huggingface.co/metrics/accuracy) and [precision](https://huggingface.co/metrics/precision), which can be used for evaluating labeled (supervised) datasets, as well as [perplexity](https://huggingface.co/metrics/perplexity), which can be used for evaluating different kinds of (unsupervised) generative tasks.\n\nTo see the input structure of a given metric, you can look at its metric card. For example, in the case of [precision](https://huggingface.co/metrics/precision), the format is:\n```\n>>> precision_metric = evaluate.load(\"precision\")\n>>> results = precision_metric.compute(references=[0, 1], predictions=[0, 1])\n>>> print(results)\n{'precision': 1.0}\n```\n\n### Task-specific metrics\n\nPopular ML tasks like Machine Translation and Named Entity Recognition have specific metrics that can be used to compare models. For example, a series of different metrics have been proposed for text generation, ranging from [BLEU](https://huggingface.co/metrics/bleu) and its derivatives such as [GoogleBLEU](https://huggingface.co/metrics/google_bleu) and [GLEU](https://huggingface.co/metrics/gleu), but also [ROUGE](https://huggingface.co/metrics/rouge), [MAUVE](https://huggingface.co/metrics/mauve), etc.\n\nYou can find the right metric for your task by:\n\n- **Looking at the [Task pages](https://huggingface.co/tasks)** to see what metrics can be used for evaluating models for a given task.\n- **Checking out leaderboards** on sites like [Papers With Code](https://paperswithcode.com/) (you can search by task and by dataset).\n-  **Reading the metric cards** for the relevant metrics and see which ones are a good fit for your use case. For example, see the [BLEU metric card](https://github.com/huggingface/evaluate/tree/main/metrics/bleu) or [SQuaD metric card](https://github.com/huggingface/evaluate/tree/main/metrics/squad).\n- **Looking at papers and blog posts** published on the topic and see what metrics they report. This can change over time, so try to pick papers from the last couple of years!\n\n### Dataset-specific metrics\n\nSome datasets have specific metrics associated with them -- this is especially in the case of popular benchmarks like [GLUE](https://huggingface.co/metrics/glue) and [SQuAD](https://huggingface.co/metrics/squad).\n\n<Tip warning={true}>\n\ud83d\udca1\nGLUE is actually a collection of different subsets on different tasks, so first you need to choose the one that corresponds to the NLI task, such as mnli, which is described as \u201ccrowdsourced collection of sentence pairs with textual entailment annotations\u201d\n</Tip>\n\n\nIf you are evaluating your model on a benchmark dataset like the ones mentioned above, you can use its dedicated evaluation metric. Make sure you respect the format that they require. For example, to evaluate your model on the [SQuAD](https://huggingface.co/datasets/squad) dataset, you need to feed the `question` and `context` into your model and return the `prediction_text`, which should be compared with the `references` (based on matching the `id` of the question) :\n\n```\n>>> from evaluate import load\n>>> squad_metric = load(\"squad\")\n>>> predictions = [{'prediction_text': '1976', 'id': '56e10a3be3433e1400422b22'}]\n>>> references = [{'answers': {'answer_start': [97], 'text': ['1976']}, 'id': '56e10a3be3433e1400422b22'}]\n>>> results = squad_metric.compute(predictions=predictions, references=references)\n>>> results\n{'exact_match': 100.0, 'f1': 100.0}\n```\n\nYou can find examples of dataset structures by consulting the \"Dataset Preview\" function or the dataset card for a given dataset, and you can see how to use its dedicated evaluation function based on the metric card.\n--New Chunk--\n[Created at: 2025-03-24 13:19:17]\n!---\nCopyright 2022 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n-->\n\n# Token classification with LayoutLMv3 (PyTorch version)\n\nThis directory contains a script, `run_funsd_cord.py`, that can be used to fine-tune (or evaluate) LayoutLMv3 on form understanding datasets, such as [FUNSD](https://guillaumejaume.github.io/FUNSD/) and [CORD](https://github.com/clovaai/cord).\n\nThe script `run_funsd_cord.py` leverages the \ud83e\udd17 Datasets library and the Trainer API. You can easily customize it to your needs.\n\n## Fine-tuning on FUNSD\n\nFine-tuning LayoutLMv3 for token classification on [FUNSD](https://guillaumejaume.github.io/FUNSD/) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name funsd \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 1e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-funsd\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd. By specifying the `push_to_hub` flag, the model gets uploaded automatically to the hub (regularly), together with a model card, which includes metrics such as precision, recall and F1. Note that you can easily update the model card, as it's just a README file of the respective repo on the hub.\n\nThere's also the \"Training metrics\" [tab](https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd/tensorboard), which shows Tensorboard logs over the course of training. Pretty neat, huh?\n\n## Fine-tuning on CORD\n\nFine-tuning LayoutLMv3 for token classification on [CORD](https://github.com/clovaai/cord) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name cord \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 5e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-cord\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-cord. Note that a model card gets generated automatically in case you specify the `push_to_hub` flag.\n--New Chunk--\n[Created at: 2025-03-24 13:16:13]\n=predictions, references=references)\n>>> results\n{'exact_match': 100.0, 'f1': 100.0}\n```\n\nYou can find examples of dataset structures by consulting the \"Dataset Preview\" function or the dataset card for a given dataset, and you can see how to use its dedicated evaluation function based on the metric card."
        }
    },
    {
        "sample_idx": 8,
        "question": "What is an example of a task-specific metric for Machine Translation?",
        "answer": "BLEU and ROUGE are examples of task-specific metrics for Machine Translation.",
        "rag_answer": "According to the provided Data Sources, an example of a task-specific metric for Machine Translation is BLEU (Bilingual Evaluation Understudy). Additionally, its derivatives such as GoogleBLEU and GLEU are also task-specific metrics for Machine Translation. Another example is ROUGE, which is often used to evaluate text generation tasks, including Machine Translation.\n\nReferences:\n[KG] Machine Translation event\n[KG] BLEU category\n[DC] Choosing a metric for your task",
        "rag_score": 5,
        "rag_feedback": "The system's response is completely correct, accurate, and factual. It not only mentions BLEU and ROUGE as task-specific metrics for Machine Translation but also provides additional information about their derivatives and other related metrics. The response is well-structured and easy to follow.",
        "rag_context": {
            "kg_context": "-----Entities-----\n    ```csv\n    id,\tentity,\ttype,\tdescription,\trankcreated_at\n1,\tBLEU,category,BLEU is a category of evaluation metrics for machine translation tasks.,1,2025-03-24 13:16:48\n2,\tMachine Translation,event,Machine Translation is an event or task in natural language processing.,3,2025-03-24 13:16:48\n3,\tGoogleBLEU,category,GoogleBLEU is a category of evaluation metrics for machine translation tasks.,1,2025-03-24 13:16:48\n4,\tGLEU,category,GLEU is a category of evaluation metrics for machine translation tasks.,1,2025-03-24 13:16:48\n5,\tBLEU,category,BLEU is a category of evaluation metrics for machine translation tasks.,1,UNKNOWN\n6,\tGLEU,category,GLEU is a category of evaluation metrics for machine translation tasks.,1,UNKNOWN\n7,\tROUGE,category,ROUGE is a category of evaluation metrics for text generation tasks.,1,UNKNOWN\n    ```\n    -----Relationships-----\n    ```csv\n    id,\tsource,\ttarget,\tdescription,\tkeywords,\tweight,\trank,\tcreated_at\n1,\tBLEU,Machine Translation,BLEU is a metric used to evaluate machine translation models.,evaluation metric, task,18.0,4,2025-03-24 13:16:48\n2,\tGoogleBLEU,Machine Translation,GoogleBLEU is a metric used to evaluate machine translation models.,evaluation metric, task,9.0,4,2025-03-24 13:16:48\n3,\tGLEU,Machine Translation,GLEU is a metric used to evaluate machine translation models.,evaluation metric, task,9.0,4,2025-03-24 13:16:48\n4,\tBLEU,Machine Translation,BLEU is a metric used to evaluate machine translation models.,evaluation metric, task,18.0,4,UNKNOWN\n5,\tGLEU,Machine Translation,GLEU is a metric used to evaluate machine translation models.,evaluation metric, task,9.0,4,UNKNOWN\n6,\tROUGE,Text Generation,ROUGE is a metric used to evaluate text generation models.,evaluation metric, task,18.0,3,UNKNOWN\n    ```\n    -----Sources-----\n    ```csv\n    id,\tcontent\n1,\tChoosing a metric for your task\n\n**So you've trained your model and want to see how well it\u2019s doing on a dataset of your choice. Where do you start?**\n\nThere is no \u201cone size fits all\u201d approach to choosing an evaluation metric, but some good guidelines to keep in mind are:\n\n## Categories of metrics\n\nThere are 3 high-level categories of metrics:\n\n1. *Generic metrics*, which can be applied to a variety of situations and datasets, such as precision and accuracy.\n2. *Task-specific metrics*, which are limited to a given task, such as Machine Translation (often evaluated using metrics [BLEU](https://huggingface.co/metrics/bleu) or [ROUGE](https://huggingface.co/metrics/rouge)) or Named Entity Recognition (often evaluated with [seqeval](https://huggingface.co/metrics/seqeval)).\n3. *Dataset-specific metrics*, which aim to measure model performance on specific benchmarks: for instance, the [GLUE benchmark](https://huggingface.co/datasets/glue) has a dedicated [evaluation metric](https://huggingface.co/metrics/glue).\n\nLet's look at each of these three cases:\n\n### Generic metrics\n\nMany of the metrics used in the Machine Learning community are quite generic and can be applied in a variety of tasks and datasets.\n\nThis is the case for metrics like [accuracy](https://huggingface.co/metrics/accuracy) and [precision](https://huggingface.co/metrics/precision), which can be used for evaluating labeled (supervised) datasets, as well as [perplexity](https://huggingface.co/metrics/perplexity), which can be used for evaluating different kinds of (unsupervised) generative tasks.\n\nTo see the input structure of a given metric, you can look at its metric card. For example, in the case of [precision](https://huggingface.co/metrics/precision), the format is:\n```\n>>> precision_metric = evaluate.load(\"precision\")\n>>> results = precision_metric.compute(references=[0, 1], predictions=[0, 1])\n>>> print(results)\n{'precision': 1.0}\n```\n\n### Task-specific metrics\n\nPopular ML tasks like Machine Translation and Named Entity Recognition have specific metrics that can be used to compare models. For example, a series of different metrics have been proposed for text generation, ranging from [BLEU](https://huggingface.co/metrics/bleu) and its derivatives such as [GoogleBLEU](https://huggingface.co/metrics/google_bleu) and [GLEU](https://huggingface.co/metrics/gleu), but also [ROUGE](https://huggingface.co/metrics/rouge), [MAUVE](https://huggingface.co/metrics/mauve), etc.\n\nYou can find the right metric for your task by:\n\n- **Looking at the [Task pages](https://huggingface.co/tasks)** to see what metrics can be used for evaluating models for a given task.\n- **Checking out leaderboards** on sites like [Papers With Code](https://paperswithcode.com/) (you can search by task and by dataset).\n-  **Reading the metric cards** for the relevant metrics and see which ones are a good fit for your use case. For example, see the [BLEU metric card](https://github.com/huggingface/evaluate/tree/main/metrics/bleu) or [SQuaD metric card](https://github.com/huggingface/evaluate/tree/main/metrics/squad).\n- **Looking at papers and blog posts** published on the topic and see what metrics they report. This can change over time, so try to pick papers from the last couple of years!\n\n### Dataset-specific metrics\n\nSome datasets have specific metrics associated with them -- this is especially in the case of popular benchmarks like [GLUE](https://huggingface.co/metrics/glue) and [SQuAD](https://huggingface.co/metrics/squad).\n\n<Tip warning={true}>\n\ud83d\udca1\nGLUE is actually a collection of different subsets on different tasks, so first you need to choose the one that corresponds to the NLI task, such as mnli, which is described as \u201ccrowdsourced collection of sentence pairs with textual entailment annotations\u201d\n</Tip>\n\n\nIf you are evaluating your model on a benchmark dataset like the ones mentioned above, you can use its dedicated evaluation metric. Make sure you respect the format that they require. For example, to evaluate your model on the [SQuAD](https://huggingface.co/datasets/squad) dataset, you need to feed the `question` and `context` into your model and return the `prediction_text`, which should be compared with the `references` (based on matching the `id` of the question) :\n\n```\n>>> from evaluate import load\n>>> squad_metric = load(\"squad\")\n>>> predictions = [{'prediction_text': '1976', 'id': '56e10a3be3433e1400422b22'}]\n>>> references = [{'answers': {'answer_start': [97], 'text': ['1976']}, 'id': '56e10a3be3433e1400422b22'}]\n>>> results = squad_metric.compute(predictions=predictions, references=references)\n>>> results\n{'exact_match': 100.0, 'f1': 100.0}\n```\n\nYou can find examples of dataset structures by consulting the \"Dataset Preview\" function or the dataset card for a given dataset, and you can see how to use its dedicated evaluation function based on the metric card.\n    ```",
            "vector_context": "[Created at: 2025-03-24 13:16:13]\nChoosing a metric for your task\n\n**So you've trained your model and want to see how well it\u2019s doing on a dataset of your choice. Where do you start?**\n\nThere is no \u201cone size fits all\u201d approach to choosing an evaluation metric, but some good guidelines to keep in mind are:\n\n## Categories of metrics\n\nThere are 3 high-level categories of metrics:\n\n1. *Generic metrics*, which can be applied to a variety of situations and datasets, such as precision and accuracy.\n2. *Task-specific metrics*, which are limited to a given task, such as Machine Translation (often evaluated using metrics [BLEU](https://huggingface.co/metrics/bleu) or [ROUGE](https://huggingface.co/metrics/rouge)) or Named Entity Recognition (often evaluated with [seqeval](https://huggingface.co/metrics/seqeval)).\n3. *Dataset-specific metrics*, which aim to measure model performance on specific benchmarks: for instance, the [GLUE benchmark](https://huggingface.co/datasets/glue) has a dedicated [evaluation metric](https://huggingface.co/metrics/glue).\n\nLet's look at each of these three cases:\n\n### Generic metrics\n\nMany of the metrics used in the Machine Learning community are quite generic and can be applied in a variety of tasks and datasets.\n\nThis is the case for metrics like [accuracy](https://huggingface.co/metrics/accuracy) and [precision](https://huggingface.co/metrics/precision), which can be used for evaluating labeled (supervised) datasets, as well as [perplexity](https://huggingface.co/metrics/perplexity), which can be used for evaluating different kinds of (unsupervised) generative tasks.\n\nTo see the input structure of a given metric, you can look at its metric card. For example, in the case of [precision](https://huggingface.co/metrics/precision), the format is:\n```\n>>> precision_metric = evaluate.load(\"precision\")\n>>> results = precision_metric.compute(references=[0, 1], predictions=[0, 1])\n>>> print(results)\n{'precision': 1.0}\n```\n\n### Task-specific metrics\n\nPopular ML tasks like Machine Translation and Named Entity Recognition have specific metrics that can be used to compare models. For example, a series of different metrics have been proposed for text generation, ranging from [BLEU](https://huggingface.co/metrics/bleu) and its derivatives such as [GoogleBLEU](https://huggingface.co/metrics/google_bleu) and [GLEU](https://huggingface.co/metrics/gleu), but also [ROUGE](https://huggingface.co/metrics/rouge), [MAUVE](https://huggingface.co/metrics/mauve), etc.\n\nYou can find the right metric for your task by:\n\n- **Looking at the [Task pages](https://huggingface.co/tasks)** to see what metrics can be used for evaluating models for a given task.\n- **Checking out leaderboards** on sites like [Papers With Code](https://paperswithcode.com/) (you can search by task and by dataset).\n-  **Reading the metric cards** for the relevant metrics and see which ones are a good fit for your use case. For example, see the [BLEU metric card](https://github.com/huggingface/evaluate/tree/main/metrics/bleu) or [SQuaD metric card](https://github.com/huggingface/evaluate/tree/main/metrics/squad).\n- **Looking at papers and blog posts** published on the topic and see what metrics they report. This can change over time, so try to pick papers from the last couple of years!\n\n### Dataset-specific metrics\n\nSome datasets have specific metrics associated with them -- this is especially in the case of popular benchmarks like [GLUE](https://huggingface.co/metrics/glue) and [SQuAD](https://huggingface.co/metrics/squad).\n\n<Tip warning={true}>\n\ud83d\udca1\nGLUE is actually a collection of different subsets on different tasks, so first you need to choose the one that corresponds to the NLI task, such as mnli, which is described as \u201ccrowdsourced collection of sentence pairs with textual entailment annotations\u201d\n</Tip>\n\n\nIf you are evaluating your model on a benchmark dataset like the ones mentioned above, you can use its dedicated evaluation metric. Make sure you respect the format that they require. For example, to evaluate your model on the [SQuAD](https://huggingface.co/datasets/squad) dataset, you need to feed the `question` and `context` into your model and return the `prediction_text`, which should be compared with the `references` (based on matching the `id` of the question) :\n\n```\n>>> from evaluate import load\n>>> squad_metric = load(\"squad\")\n>>> predictions = [{'prediction_text': '1976', 'id': '56e10a3be3433e1400422b22'}]\n>>> references = [{'answers': {'answer_start': [97], 'text': ['1976']}, 'id': '56e10a3be3433e1400422b22'}]\n>>> results = squad_metric.compute(predictions=predictions, references=references)\n>>> results\n{'exact_match': 100.0, 'f1': 100.0}\n```\n\nYou can find examples of dataset structures by consulting the \"Dataset Preview\" function or the dataset card for a given dataset, and you can see how to use its dedicated evaluation function based on the metric card.\n--New Chunk--\n[Created at: 2025-03-24 13:19:17]\n!---\nCopyright 2022 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n-->\n\n# Token classification with LayoutLMv3 (PyTorch version)\n\nThis directory contains a script, `run_funsd_cord.py`, that can be used to fine-tune (or evaluate) LayoutLMv3 on form understanding datasets, such as [FUNSD](https://guillaumejaume.github.io/FUNSD/) and [CORD](https://github.com/clovaai/cord).\n\nThe script `run_funsd_cord.py` leverages the \ud83e\udd17 Datasets library and the Trainer API. You can easily customize it to your needs.\n\n## Fine-tuning on FUNSD\n\nFine-tuning LayoutLMv3 for token classification on [FUNSD](https://guillaumejaume.github.io/FUNSD/) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name funsd \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 1e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-funsd\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd. By specifying the `push_to_hub` flag, the model gets uploaded automatically to the hub (regularly), together with a model card, which includes metrics such as precision, recall and F1. Note that you can easily update the model card, as it's just a README file of the respective repo on the hub.\n\nThere's also the \"Training metrics\" [tab](https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd/tensorboard), which shows Tensorboard logs over the course of training. Pretty neat, huh?\n\n## Fine-tuning on CORD\n\nFine-tuning LayoutLMv3 for token classification on [CORD](https://github.com/clovaai/cord) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name cord \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 5e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-cord\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-cord. Note that a model card gets generated automatically in case you specify the `push_to_hub` flag.\n--New Chunk--\n[Created at: 2025-03-24 13:16:13]\n=predictions, references=references)\n>>> results\n{'exact_match': 100.0, 'f1': 100.0}\n```\n\nYou can find examples of dataset structures by consulting the \"Dataset Preview\" function or the dataset card for a given dataset, and you can see how to use its dedicated evaluation function based on the metric card."
        }
    },
    {
        "sample_idx": 9,
        "question": "What is an example of a task-specific metric for Named Entity Recognition?",
        "answer": "Seqeval is an example of a task-specific metric for Named Entity Recognition.",
        "rag_answer": "An example of a task-specific metric for Named Entity Recognition (NER) is seqeval. This metric is specifically designed to evaluate the performance of NER models and is often used for this task.",
        "rag_score": 5,
        "rag_feedback": "The system's response is completely correct, accurate, and factual. It correctly identifies seqeval as a task-specific metric for Named Entity Recognition and provides additional relevant information about task-specific metrics and their usage.",
        "rag_context": {
            "kg_context": "-----Entities-----\n    ```csv\n    id,\tentity,\ttype,\tdescription,\trankcreated_at\n1,\tMachine Learning,category,Machine Learning is a field of study that involves training models to make predictions.,5,2025-03-24 13:16:48\n2,\tprecision,category,precision is a category of evaluation metrics for machine learning models.,1,2025-03-24 13:16:48\n3,\tGLEU,category,GLEU is a category of evaluation metrics for machine translation tasks.,1,2025-03-24 13:16:48\n4,\tMachine Translation,event,Machine Translation is an event or task in natural language processing.,3,2025-03-24 13:16:48\n5,\tNamed Entity Recognition,event,Named Entity Recognition is an event or task in natural language processing.,1,2025-03-24 13:16:48\n6,\tseqeval,category,seqeval is a category of evaluation metrics for named entity recognition tasks.,1,2025-03-24 13:16:48\n7,\tNamed Entity Recognition,event,Named Entity Recognition is an event or task in natural language processing.,1,UNKNOWN\n8,\tseqeval,category,seqeval is a category of evaluation metrics for named entity recognition tasks.,1,UNKNOWN\n9,\tF1,category,F1 is a metric used to evaluate the performance of a model.,1,UNKNOWN\n    ```\n    -----Relationships-----\n    ```csv\n    id,\tsource,\ttarget,\tdescription,\tkeywords,\tweight,\trank,\tcreated_at\n1,\tMachine Learning,precision,precision is a metric used to evaluate machine learning models.,evaluation metric, task,9.0,6,2025-03-24 13:16:48\n2,\tGLEU,Machine Translation,GLEU is a metric used to evaluate machine translation models.,evaluation metric, task,9.0,4,2025-03-24 13:16:48\n3,\tNamed Entity Recognition,seqeval,seqeval is a metric used to evaluate named entity recognition models.,evaluation metric, task,9.0,2,2025-03-24 13:16:48\n4,\tNamed Entity Recognition,seqeval,seqeval is a metric used to evaluate named entity recognition models.,evaluation metric, task,9.0,2,UNKNOWN\n5,\tExact Match,F1,Exact Match and F1 are both metrics used to evaluate the performance of a model.,evaluation metrics, performance assessment,8.0,2,UNKNOWN\n    ```\n    -----Sources-----\n    ```csv\n    id,\tcontent\n1,\tChoosing a metric for your task\n\n**So you've trained your model and want to see how well it\u2019s doing on a dataset of your choice. Where do you start?**\n\nThere is no \u201cone size fits all\u201d approach to choosing an evaluation metric, but some good guidelines to keep in mind are:\n\n## Categories of metrics\n\nThere are 3 high-level categories of metrics:\n\n1. *Generic metrics*, which can be applied to a variety of situations and datasets, such as precision and accuracy.\n2. *Task-specific metrics*, which are limited to a given task, such as Machine Translation (often evaluated using metrics [BLEU](https://huggingface.co/metrics/bleu) or [ROUGE](https://huggingface.co/metrics/rouge)) or Named Entity Recognition (often evaluated with [seqeval](https://huggingface.co/metrics/seqeval)).\n3. *Dataset-specific metrics*, which aim to measure model performance on specific benchmarks: for instance, the [GLUE benchmark](https://huggingface.co/datasets/glue) has a dedicated [evaluation metric](https://huggingface.co/metrics/glue).\n\nLet's look at each of these three cases:\n\n### Generic metrics\n\nMany of the metrics used in the Machine Learning community are quite generic and can be applied in a variety of tasks and datasets.\n\nThis is the case for metrics like [accuracy](https://huggingface.co/metrics/accuracy) and [precision](https://huggingface.co/metrics/precision), which can be used for evaluating labeled (supervised) datasets, as well as [perplexity](https://huggingface.co/metrics/perplexity), which can be used for evaluating different kinds of (unsupervised) generative tasks.\n\nTo see the input structure of a given metric, you can look at its metric card. For example, in the case of [precision](https://huggingface.co/metrics/precision), the format is:\n```\n>>> precision_metric = evaluate.load(\"precision\")\n>>> results = precision_metric.compute(references=[0, 1], predictions=[0, 1])\n>>> print(results)\n{'precision': 1.0}\n```\n\n### Task-specific metrics\n\nPopular ML tasks like Machine Translation and Named Entity Recognition have specific metrics that can be used to compare models. For example, a series of different metrics have been proposed for text generation, ranging from [BLEU](https://huggingface.co/metrics/bleu) and its derivatives such as [GoogleBLEU](https://huggingface.co/metrics/google_bleu) and [GLEU](https://huggingface.co/metrics/gleu), but also [ROUGE](https://huggingface.co/metrics/rouge), [MAUVE](https://huggingface.co/metrics/mauve), etc.\n\nYou can find the right metric for your task by:\n\n- **Looking at the [Task pages](https://huggingface.co/tasks)** to see what metrics can be used for evaluating models for a given task.\n- **Checking out leaderboards** on sites like [Papers With Code](https://paperswithcode.com/) (you can search by task and by dataset).\n-  **Reading the metric cards** for the relevant metrics and see which ones are a good fit for your use case. For example, see the [BLEU metric card](https://github.com/huggingface/evaluate/tree/main/metrics/bleu) or [SQuaD metric card](https://github.com/huggingface/evaluate/tree/main/metrics/squad).\n- **Looking at papers and blog posts** published on the topic and see what metrics they report. This can change over time, so try to pick papers from the last couple of years!\n\n### Dataset-specific metrics\n\nSome datasets have specific metrics associated with them -- this is especially in the case of popular benchmarks like [GLUE](https://huggingface.co/metrics/glue) and [SQuAD](https://huggingface.co/metrics/squad).\n\n<Tip warning={true}>\n\ud83d\udca1\nGLUE is actually a collection of different subsets on different tasks, so first you need to choose the one that corresponds to the NLI task, such as mnli, which is described as \u201ccrowdsourced collection of sentence pairs with textual entailment annotations\u201d\n</Tip>\n\n\nIf you are evaluating your model on a benchmark dataset like the ones mentioned above, you can use its dedicated evaluation metric. Make sure you respect the format that they require. For example, to evaluate your model on the [SQuAD](https://huggingface.co/datasets/squad) dataset, you need to feed the `question` and `context` into your model and return the `prediction_text`, which should be compared with the `references` (based on matching the `id` of the question) :\n\n```\n>>> from evaluate import load\n>>> squad_metric = load(\"squad\")\n>>> predictions = [{'prediction_text': '1976', 'id': '56e10a3be3433e1400422b22'}]\n>>> references = [{'answers': {'answer_start': [97], 'text': ['1976']}, 'id': '56e10a3be3433e1400422b22'}]\n>>> results = squad_metric.compute(predictions=predictions, references=references)\n>>> results\n{'exact_match': 100.0, 'f1': 100.0}\n```\n\nYou can find examples of dataset structures by consulting the \"Dataset Preview\" function or the dataset card for a given dataset, and you can see how to use its dedicated evaluation function based on the metric card.\n2,\t=predictions, references=references)\n>>> results\n{'exact_match': 100.0, 'f1': 100.0}\n```\n\nYou can find examples of dataset structures by consulting the \"Dataset Preview\" function or the dataset card for a given dataset, and you can see how to use its dedicated evaluation function based on the metric card.\n    ```",
            "vector_context": "[Created at: 2025-03-24 13:16:13]\nChoosing a metric for your task\n\n**So you've trained your model and want to see how well it\u2019s doing on a dataset of your choice. Where do you start?**\n\nThere is no \u201cone size fits all\u201d approach to choosing an evaluation metric, but some good guidelines to keep in mind are:\n\n## Categories of metrics\n\nThere are 3 high-level categories of metrics:\n\n1. *Generic metrics*, which can be applied to a variety of situations and datasets, such as precision and accuracy.\n2. *Task-specific metrics*, which are limited to a given task, such as Machine Translation (often evaluated using metrics [BLEU](https://huggingface.co/metrics/bleu) or [ROUGE](https://huggingface.co/metrics/rouge)) or Named Entity Recognition (often evaluated with [seqeval](https://huggingface.co/metrics/seqeval)).\n3. *Dataset-specific metrics*, which aim to measure model performance on specific benchmarks: for instance, the [GLUE benchmark](https://huggingface.co/datasets/glue) has a dedicated [evaluation metric](https://huggingface.co/metrics/glue).\n\nLet's look at each of these three cases:\n\n### Generic metrics\n\nMany of the metrics used in the Machine Learning community are quite generic and can be applied in a variety of tasks and datasets.\n\nThis is the case for metrics like [accuracy](https://huggingface.co/metrics/accuracy) and [precision](https://huggingface.co/metrics/precision), which can be used for evaluating labeled (supervised) datasets, as well as [perplexity](https://huggingface.co/metrics/perplexity), which can be used for evaluating different kinds of (unsupervised) generative tasks.\n\nTo see the input structure of a given metric, you can look at its metric card. For example, in the case of [precision](https://huggingface.co/metrics/precision), the format is:\n```\n>>> precision_metric = evaluate.load(\"precision\")\n>>> results = precision_metric.compute(references=[0, 1], predictions=[0, 1])\n>>> print(results)\n{'precision': 1.0}\n```\n\n### Task-specific metrics\n\nPopular ML tasks like Machine Translation and Named Entity Recognition have specific metrics that can be used to compare models. For example, a series of different metrics have been proposed for text generation, ranging from [BLEU](https://huggingface.co/metrics/bleu) and its derivatives such as [GoogleBLEU](https://huggingface.co/metrics/google_bleu) and [GLEU](https://huggingface.co/metrics/gleu), but also [ROUGE](https://huggingface.co/metrics/rouge), [MAUVE](https://huggingface.co/metrics/mauve), etc.\n\nYou can find the right metric for your task by:\n\n- **Looking at the [Task pages](https://huggingface.co/tasks)** to see what metrics can be used for evaluating models for a given task.\n- **Checking out leaderboards** on sites like [Papers With Code](https://paperswithcode.com/) (you can search by task and by dataset).\n-  **Reading the metric cards** for the relevant metrics and see which ones are a good fit for your use case. For example, see the [BLEU metric card](https://github.com/huggingface/evaluate/tree/main/metrics/bleu) or [SQuaD metric card](https://github.com/huggingface/evaluate/tree/main/metrics/squad).\n- **Looking at papers and blog posts** published on the topic and see what metrics they report. This can change over time, so try to pick papers from the last couple of years!\n\n### Dataset-specific metrics\n\nSome datasets have specific metrics associated with them -- this is especially in the case of popular benchmarks like [GLUE](https://huggingface.co/metrics/glue) and [SQuAD](https://huggingface.co/metrics/squad).\n\n<Tip warning={true}>\n\ud83d\udca1\nGLUE is actually a collection of different subsets on different tasks, so first you need to choose the one that corresponds to the NLI task, such as mnli, which is described as \u201ccrowdsourced collection of sentence pairs with textual entailment annotations\u201d\n</Tip>\n\n\nIf you are evaluating your model on a benchmark dataset like the ones mentioned above, you can use its dedicated evaluation metric. Make sure you respect the format that they require. For example, to evaluate your model on the [SQuAD](https://huggingface.co/datasets/squad) dataset, you need to feed the `question` and `context` into your model and return the `prediction_text`, which should be compared with the `references` (based on matching the `id` of the question) :\n\n```\n>>> from evaluate import load\n>>> squad_metric = load(\"squad\")\n>>> predictions = [{'prediction_text': '1976', 'id': '56e10a3be3433e1400422b22'}]\n>>> references = [{'answers': {'answer_start': [97], 'text': ['1976']}, 'id': '56e10a3be3433e1400422b22'}]\n>>> results = squad_metric.compute(predictions=predictions, references=references)\n>>> results\n{'exact_match': 100.0, 'f1': 100.0}\n```\n\nYou can find examples of dataset structures by consulting the \"Dataset Preview\" function or the dataset card for a given dataset, and you can see how to use its dedicated evaluation function based on the metric card.\n--New Chunk--\n[Created at: 2025-03-24 13:16:13]\n=predictions, references=references)\n>>> results\n{'exact_match': 100.0, 'f1': 100.0}\n```\n\nYou can find examples of dataset structures by consulting the \"Dataset Preview\" function or the dataset card for a given dataset, and you can see how to use its dedicated evaluation function based on the metric card.\n--New Chunk--\n[Created at: 2025-03-24 13:19:17]\n!---\nCopyright 2022 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n-->\n\n# Token classification with LayoutLMv3 (PyTorch version)\n\nThis directory contains a script, `run_funsd_cord.py`, that can be used to fine-tune (or evaluate) LayoutLMv3 on form understanding datasets, such as [FUNSD](https://guillaumejaume.github.io/FUNSD/) and [CORD](https://github.com/clovaai/cord).\n\nThe script `run_funsd_cord.py` leverages the \ud83e\udd17 Datasets library and the Trainer API. You can easily customize it to your needs.\n\n## Fine-tuning on FUNSD\n\nFine-tuning LayoutLMv3 for token classification on [FUNSD](https://guillaumejaume.github.io/FUNSD/) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name funsd \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 1e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-funsd\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd. By specifying the `push_to_hub` flag, the model gets uploaded automatically to the hub (regularly), together with a model card, which includes metrics such as precision, recall and F1. Note that you can easily update the model card, as it's just a README file of the respective repo on the hub.\n\nThere's also the \"Training metrics\" [tab](https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd/tensorboard), which shows Tensorboard logs over the course of training. Pretty neat, huh?\n\n## Fine-tuning on CORD\n\nFine-tuning LayoutLMv3 for token classification on [CORD](https://github.com/clovaai/cord) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name cord \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 5e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-cord\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-cord. Note that a model card gets generated automatically in case you specify the `push_to_hub` flag."
        }
    },
    {
        "sample_idx": 10,
        "question": "What is an example of a dataset-specific metric?",
        "answer": "The GLUE benchmark has a dedicated evaluation metric.",
        "rag_answer": "An example of a dataset-specific metric is the SQuAD metric, which is used to measure model performance on the SQuAD dataset. The SQuAD metric evaluates the model's ability to answer questions based on a given context. It computes two scores: exact match (EM) and F1-score. The exact match score measures the proportion of predictions that exactly match the correct answer, while the F1-score measures the overlap between the predicted and correct answers.\n\nHere's an example of how to use the SQuAD metric in Python:\n```\n>>> from evaluate import load\n>>> squad_metric = load(\"squad\")\n>>> predictions = [{'prediction_text': '1976', 'id': '56e10a3be3433e1400422b22'}]\n>>> references = [{'answers': {'answer_start': [97], 'text': ['1976']}, 'id': '56e10a3be3433e1400422b22'}]\n>>> results = squad_metric.compute(predictions=predictions, references=references)\n>>> results\n{'exact_match': 100.0, 'f1': 100.0}\n```\nThe SQuAD metric is specific to the SQuAD dataset and is used to evaluate models on this particular task.\n\nReferences:\n[KG] Hugging Face, SQuAD dataset\n[DC] Choosing a metric for your task",
        "rag_score": 5,
        "rag_feedback": "The system's response is completely correct, accurate, and factual. It provides a detailed explanation of dataset-specific metrics, including the SQuAD metric, and provides an example of how to use it in Python. The response is well-structured and easy to follow, and it provides relevant information about the SQuAD dataset and its evaluation metric.",
        "rag_context": {
            "kg_context": "-----Entities-----\n    ```csv\n    id,\tentity,\ttype,\tdescription,\trankcreated_at\n1,\tHugging Face,organization,Hugging Face is an organization that provides a platform for deploying and managing endpoints for text classification and other AI models.<SEP>Hugging Face is an organization that provides a platform for evaluating and comparing machine learning models.<SEP>Hugging Face is an organization that provides a range of machine learning models and tools.,8,2025-03-24 13:16:48\n2,\tSQuAD,dataset,SQuAD is a benchmark dataset for evaluating question answering models.,1,2025-03-24 13:16:48\n3,\tDataset Preview,organization,Dataset Preview is a function that provides examples of dataset structures.,1,2025-03-24 13:16:48\n4,\tMetric Card,organization,Metric Card is a resource that explains how to use a dedicated evaluation function.,1,2025-03-24 13:16:48\n5,\tExact Match,category,Exact Match is a metric used to evaluate the performance of a model.,1,2025-03-24 13:16:48\n6,\tF1,category,F1 is a metric used to evaluate the performance of a model.,1,2025-03-24 13:16:48\n7,\tF1,category,F1 is a metric used to evaluate the performance of a model.,1,UNKNOWN\n8,\taccuracy,category,accuracy is a category of evaluation metrics for machine learning models.,1,UNKNOWN\n9,\tprecision,category,precision is a category of evaluation metrics for machine learning models.,1,UNKNOWN\n    ```\n    -----Relationships-----\n    ```csv\n    id,\tsource,\ttarget,\tdescription,\tkeywords,\tweight,\trank,\tcreated_at\n1,\tHugging Face,SQuAD,Hugging Face provides a platform for evaluating models on the SQuAD benchmark dataset.,evaluation platform, benchmark dataset,16.0,9,2025-03-24 13:16:48\n2,\tDataset Preview,Metric Card,Dataset Preview and Metric Card are related resources that provide information about dataset structures and evaluation functions.,information resources, dataset structure,16.0,2,2025-03-24 13:16:48\n3,\tExact Match,F1,Exact Match and F1 are both metrics used to evaluate the performance of a model.,evaluation metrics, performance assessment,8.0,2,2025-03-24 13:16:48\n4,\tMachine Learning,accuracy,accuracy is a metric used to evaluate machine learning models.,evaluation metric, task,9.0,6,UNKNOWN\n5,\tMachine Learning,precision,precision is a metric used to evaluate machine learning models.,evaluation metric, task,9.0,6,UNKNOWN\n6,\tExact Match,F1,Exact Match and F1 are both metrics used to evaluate the performance of a model.,evaluation metrics, performance assessment,8.0,2,UNKNOWN\n    ```\n    -----Sources-----\n    ```csv\n    id,\tcontent\n1,\tChoosing a metric for your task\n\n**So you've trained your model and want to see how well it\u2019s doing on a dataset of your choice. Where do you start?**\n\nThere is no \u201cone size fits all\u201d approach to choosing an evaluation metric, but some good guidelines to keep in mind are:\n\n## Categories of metrics\n\nThere are 3 high-level categories of metrics:\n\n1. *Generic metrics*, which can be applied to a variety of situations and datasets, such as precision and accuracy.\n2. *Task-specific metrics*, which are limited to a given task, such as Machine Translation (often evaluated using metrics [BLEU](https://huggingface.co/metrics/bleu) or [ROUGE](https://huggingface.co/metrics/rouge)) or Named Entity Recognition (often evaluated with [seqeval](https://huggingface.co/metrics/seqeval)).\n3. *Dataset-specific metrics*, which aim to measure model performance on specific benchmarks: for instance, the [GLUE benchmark](https://huggingface.co/datasets/glue) has a dedicated [evaluation metric](https://huggingface.co/metrics/glue).\n\nLet's look at each of these three cases:\n\n### Generic metrics\n\nMany of the metrics used in the Machine Learning community are quite generic and can be applied in a variety of tasks and datasets.\n\nThis is the case for metrics like [accuracy](https://huggingface.co/metrics/accuracy) and [precision](https://huggingface.co/metrics/precision), which can be used for evaluating labeled (supervised) datasets, as well as [perplexity](https://huggingface.co/metrics/perplexity), which can be used for evaluating different kinds of (unsupervised) generative tasks.\n\nTo see the input structure of a given metric, you can look at its metric card. For example, in the case of [precision](https://huggingface.co/metrics/precision), the format is:\n```\n>>> precision_metric = evaluate.load(\"precision\")\n>>> results = precision_metric.compute(references=[0, 1], predictions=[0, 1])\n>>> print(results)\n{'precision': 1.0}\n```\n\n### Task-specific metrics\n\nPopular ML tasks like Machine Translation and Named Entity Recognition have specific metrics that can be used to compare models. For example, a series of different metrics have been proposed for text generation, ranging from [BLEU](https://huggingface.co/metrics/bleu) and its derivatives such as [GoogleBLEU](https://huggingface.co/metrics/google_bleu) and [GLEU](https://huggingface.co/metrics/gleu), but also [ROUGE](https://huggingface.co/metrics/rouge), [MAUVE](https://huggingface.co/metrics/mauve), etc.\n\nYou can find the right metric for your task by:\n\n- **Looking at the [Task pages](https://huggingface.co/tasks)** to see what metrics can be used for evaluating models for a given task.\n- **Checking out leaderboards** on sites like [Papers With Code](https://paperswithcode.com/) (you can search by task and by dataset).\n-  **Reading the metric cards** for the relevant metrics and see which ones are a good fit for your use case. For example, see the [BLEU metric card](https://github.com/huggingface/evaluate/tree/main/metrics/bleu) or [SQuaD metric card](https://github.com/huggingface/evaluate/tree/main/metrics/squad).\n- **Looking at papers and blog posts** published on the topic and see what metrics they report. This can change over time, so try to pick papers from the last couple of years!\n\n### Dataset-specific metrics\n\nSome datasets have specific metrics associated with them -- this is especially in the case of popular benchmarks like [GLUE](https://huggingface.co/metrics/glue) and [SQuAD](https://huggingface.co/metrics/squad).\n\n<Tip warning={true}>\n\ud83d\udca1\nGLUE is actually a collection of different subsets on different tasks, so first you need to choose the one that corresponds to the NLI task, such as mnli, which is described as \u201ccrowdsourced collection of sentence pairs with textual entailment annotations\u201d\n</Tip>\n\n\nIf you are evaluating your model on a benchmark dataset like the ones mentioned above, you can use its dedicated evaluation metric. Make sure you respect the format that they require. For example, to evaluate your model on the [SQuAD](https://huggingface.co/datasets/squad) dataset, you need to feed the `question` and `context` into your model and return the `prediction_text`, which should be compared with the `references` (based on matching the `id` of the question) :\n\n```\n>>> from evaluate import load\n>>> squad_metric = load(\"squad\")\n>>> predictions = [{'prediction_text': '1976', 'id': '56e10a3be3433e1400422b22'}]\n>>> references = [{'answers': {'answer_start': [97], 'text': ['1976']}, 'id': '56e10a3be3433e1400422b22'}]\n>>> results = squad_metric.compute(predictions=predictions, references=references)\n>>> results\n{'exact_match': 100.0, 'f1': 100.0}\n```\n\nYou can find examples of dataset structures by consulting the \"Dataset Preview\" function or the dataset card for a given dataset, and you can see how to use its dedicated evaluation function based on the metric card.\n2,\t=predictions, references=references)\n>>> results\n{'exact_match': 100.0, 'f1': 100.0}\n```\n\nYou can find examples of dataset structures by consulting the \"Dataset Preview\" function or the dataset card for a given dataset, and you can see how to use its dedicated evaluation function based on the metric card.\n    ```",
            "vector_context": "[Created at: 2025-03-24 13:16:13]\nChoosing a metric for your task\n\n**So you've trained your model and want to see how well it\u2019s doing on a dataset of your choice. Where do you start?**\n\nThere is no \u201cone size fits all\u201d approach to choosing an evaluation metric, but some good guidelines to keep in mind are:\n\n## Categories of metrics\n\nThere are 3 high-level categories of metrics:\n\n1. *Generic metrics*, which can be applied to a variety of situations and datasets, such as precision and accuracy.\n2. *Task-specific metrics*, which are limited to a given task, such as Machine Translation (often evaluated using metrics [BLEU](https://huggingface.co/metrics/bleu) or [ROUGE](https://huggingface.co/metrics/rouge)) or Named Entity Recognition (often evaluated with [seqeval](https://huggingface.co/metrics/seqeval)).\n3. *Dataset-specific metrics*, which aim to measure model performance on specific benchmarks: for instance, the [GLUE benchmark](https://huggingface.co/datasets/glue) has a dedicated [evaluation metric](https://huggingface.co/metrics/glue).\n\nLet's look at each of these three cases:\n\n### Generic metrics\n\nMany of the metrics used in the Machine Learning community are quite generic and can be applied in a variety of tasks and datasets.\n\nThis is the case for metrics like [accuracy](https://huggingface.co/metrics/accuracy) and [precision](https://huggingface.co/metrics/precision), which can be used for evaluating labeled (supervised) datasets, as well as [perplexity](https://huggingface.co/metrics/perplexity), which can be used for evaluating different kinds of (unsupervised) generative tasks.\n\nTo see the input structure of a given metric, you can look at its metric card. For example, in the case of [precision](https://huggingface.co/metrics/precision), the format is:\n```\n>>> precision_metric = evaluate.load(\"precision\")\n>>> results = precision_metric.compute(references=[0, 1], predictions=[0, 1])\n>>> print(results)\n{'precision': 1.0}\n```\n\n### Task-specific metrics\n\nPopular ML tasks like Machine Translation and Named Entity Recognition have specific metrics that can be used to compare models. For example, a series of different metrics have been proposed for text generation, ranging from [BLEU](https://huggingface.co/metrics/bleu) and its derivatives such as [GoogleBLEU](https://huggingface.co/metrics/google_bleu) and [GLEU](https://huggingface.co/metrics/gleu), but also [ROUGE](https://huggingface.co/metrics/rouge), [MAUVE](https://huggingface.co/metrics/mauve), etc.\n\nYou can find the right metric for your task by:\n\n- **Looking at the [Task pages](https://huggingface.co/tasks)** to see what metrics can be used for evaluating models for a given task.\n- **Checking out leaderboards** on sites like [Papers With Code](https://paperswithcode.com/) (you can search by task and by dataset).\n-  **Reading the metric cards** for the relevant metrics and see which ones are a good fit for your use case. For example, see the [BLEU metric card](https://github.com/huggingface/evaluate/tree/main/metrics/bleu) or [SQuaD metric card](https://github.com/huggingface/evaluate/tree/main/metrics/squad).\n- **Looking at papers and blog posts** published on the topic and see what metrics they report. This can change over time, so try to pick papers from the last couple of years!\n\n### Dataset-specific metrics\n\nSome datasets have specific metrics associated with them -- this is especially in the case of popular benchmarks like [GLUE](https://huggingface.co/metrics/glue) and [SQuAD](https://huggingface.co/metrics/squad).\n\n<Tip warning={true}>\n\ud83d\udca1\nGLUE is actually a collection of different subsets on different tasks, so first you need to choose the one that corresponds to the NLI task, such as mnli, which is described as \u201ccrowdsourced collection of sentence pairs with textual entailment annotations\u201d\n</Tip>\n\n\nIf you are evaluating your model on a benchmark dataset like the ones mentioned above, you can use its dedicated evaluation metric. Make sure you respect the format that they require. For example, to evaluate your model on the [SQuAD](https://huggingface.co/datasets/squad) dataset, you need to feed the `question` and `context` into your model and return the `prediction_text`, which should be compared with the `references` (based on matching the `id` of the question) :\n\n```\n>>> from evaluate import load\n>>> squad_metric = load(\"squad\")\n>>> predictions = [{'prediction_text': '1976', 'id': '56e10a3be3433e1400422b22'}]\n>>> references = [{'answers': {'answer_start': [97], 'text': ['1976']}, 'id': '56e10a3be3433e1400422b22'}]\n>>> results = squad_metric.compute(predictions=predictions, references=references)\n>>> results\n{'exact_match': 100.0, 'f1': 100.0}\n```\n\nYou can find examples of dataset structures by consulting the \"Dataset Preview\" function or the dataset card for a given dataset, and you can see how to use its dedicated evaluation function based on the metric card.\n--New Chunk--\n[Created at: 2025-03-24 13:16:13]\n=predictions, references=references)\n>>> results\n{'exact_match': 100.0, 'f1': 100.0}\n```\n\nYou can find examples of dataset structures by consulting the \"Dataset Preview\" function or the dataset card for a given dataset, and you can see how to use its dedicated evaluation function based on the metric card.\n--New Chunk--\n[Created at: 2025-03-24 13:19:17]\n!---\nCopyright 2022 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n-->\n\n# Token classification with LayoutLMv3 (PyTorch version)\n\nThis directory contains a script, `run_funsd_cord.py`, that can be used to fine-tune (or evaluate) LayoutLMv3 on form understanding datasets, such as [FUNSD](https://guillaumejaume.github.io/FUNSD/) and [CORD](https://github.com/clovaai/cord).\n\nThe script `run_funsd_cord.py` leverages the \ud83e\udd17 Datasets library and the Trainer API. You can easily customize it to your needs.\n\n## Fine-tuning on FUNSD\n\nFine-tuning LayoutLMv3 for token classification on [FUNSD](https://guillaumejaume.github.io/FUNSD/) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name funsd \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 1e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-funsd\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd. By specifying the `push_to_hub` flag, the model gets uploaded automatically to the hub (regularly), together with a model card, which includes metrics such as precision, recall and F1. Note that you can easily update the model card, as it's just a README file of the respective repo on the hub.\n\nThere's also the \"Training metrics\" [tab](https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd/tensorboard), which shows Tensorboard logs over the course of training. Pretty neat, huh?\n\n## Fine-tuning on CORD\n\nFine-tuning LayoutLMv3 for token classification on [CORD](https://github.com/clovaai/cord) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name cord \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 5e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-cord\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-cord. Note that a model card gets generated automatically in case you specify the `push_to_hub` flag."
        }
    },
    {
        "sample_idx": 11,
        "question": "What are some examples of generic metrics?",
        "answer": "Accuracy, precision, and perplexity are examples of generic metrics.",
        "rag_answer": "Generic metrics are metrics that can be applied to a variety of situations and datasets. Some examples of generic metrics include:\n\n### Accuracy\n\nAccuracy is a metric that measures the proportion of correctly classified instances out of all instances in the dataset. It's a common metric used in supervised learning tasks.\n\n### Precision\n\nPrecision is a metric that measures the proportion of true positives (correctly predicted instances) out of all positive predictions made by the model. It's often used in combination with recall to get a more comprehensive picture of a model's performance.\n\n### Perplexity\n\nPerplexity is a metric that measures how well a probability distribution or probability model predicts a sample. It may be used to compare probability models.\n\nThese metrics are considered generic because they can be applied to different types of tasks and datasets, such as image classification, natural language processing, or recommender systems.\n\nReferences:\n[KG] Evaluation Function\n[DC] Choosing a metric for your task",
        "rag_score": 5,
        "rag_feedback": "The system's response is completely correct, accurate, and factual. It provides a detailed explanation of generic metrics, including accuracy, precision, and perplexity, and provides examples of how they can be applied to different tasks and datasets. The response is well-structured and easy to follow, and it provides additional information on task-specific and dataset-specific metrics, which is not required by the question but adds value to the response.",
        "rag_context": {
            "kg_context": "-----Entities-----\n    ```csv\n    id,\tentity,\ttype,\tdescription,\trankcreated_at\n1,\tEvaluation Function,category,Evaluation Function is a tool used to assess the performance of a model.,2,2025-03-24 13:16:48\n2,\tModel,category,Model refers to a machine learning model being evaluated.,3,2025-03-24 13:16:48\n3,\tResults,event,Results are the outcome of evaluating a model, in this case, showing perfect accuracy.,1,2025-03-24 13:16:48\n4,\tExact Match,category,Exact Match is a metric used to evaluate the performance of a model.,1,2025-03-24 13:16:48\n5,\tF1,category,F1 is a metric used to evaluate the performance of a model.,1,2025-03-24 13:16:48\n6,\tprecision,category,precision is a category of evaluation metrics for machine learning models.,1,UNKNOWN\n7,\taccuracy,category,accuracy is a category of evaluation metrics for machine learning models.,1,UNKNOWN\n8,\tF1,category,F1 is a metric used to evaluate the performance of a model.,1,UNKNOWN\n    ```\n    -----Relationships-----\n    ```csv\n    id,\tsource,\ttarget,\tdescription,\tkeywords,\tweight,\trank,\tcreated_at\n1,\tEvaluation Function,Model,The evaluation function is used to assess the performance of the model.,model evaluation, performance assessment,18.0,5,2025-03-24 13:16:48\n2,\tEvaluation Function,Results,The results are obtained by using the evaluation function.,evaluation outcome, accuracy,20.0,3,2025-03-24 13:16:48\n3,\tExact Match,F1,Exact Match and F1 are both metrics used to evaluate the performance of a model.,evaluation metrics, performance assessment,8.0,2,2025-03-24 13:16:48\n4,\tMachine Learning,precision,precision is a metric used to evaluate machine learning models.,evaluation metric, task,9.0,6,UNKNOWN\n5,\tMachine Learning,accuracy,accuracy is a metric used to evaluate machine learning models.,evaluation metric, task,9.0,6,UNKNOWN\n6,\tExact Match,F1,Exact Match and F1 are both metrics used to evaluate the performance of a model.,evaluation metrics, performance assessment,8.0,2,UNKNOWN\n    ```\n    -----Sources-----\n    ```csv\n    id,\tcontent\n1,\t=predictions, references=references)\n>>> results\n{'exact_match': 100.0, 'f1': 100.0}\n```\n\nYou can find examples of dataset structures by consulting the \"Dataset Preview\" function or the dataset card for a given dataset, and you can see how to use its dedicated evaluation function based on the metric card.\n2,\tChoosing a metric for your task\n\n**So you've trained your model and want to see how well it\u2019s doing on a dataset of your choice. Where do you start?**\n\nThere is no \u201cone size fits all\u201d approach to choosing an evaluation metric, but some good guidelines to keep in mind are:\n\n## Categories of metrics\n\nThere are 3 high-level categories of metrics:\n\n1. *Generic metrics*, which can be applied to a variety of situations and datasets, such as precision and accuracy.\n2. *Task-specific metrics*, which are limited to a given task, such as Machine Translation (often evaluated using metrics [BLEU](https://huggingface.co/metrics/bleu) or [ROUGE](https://huggingface.co/metrics/rouge)) or Named Entity Recognition (often evaluated with [seqeval](https://huggingface.co/metrics/seqeval)).\n3. *Dataset-specific metrics*, which aim to measure model performance on specific benchmarks: for instance, the [GLUE benchmark](https://huggingface.co/datasets/glue) has a dedicated [evaluation metric](https://huggingface.co/metrics/glue).\n\nLet's look at each of these three cases:\n\n### Generic metrics\n\nMany of the metrics used in the Machine Learning community are quite generic and can be applied in a variety of tasks and datasets.\n\nThis is the case for metrics like [accuracy](https://huggingface.co/metrics/accuracy) and [precision](https://huggingface.co/metrics/precision), which can be used for evaluating labeled (supervised) datasets, as well as [perplexity](https://huggingface.co/metrics/perplexity), which can be used for evaluating different kinds of (unsupervised) generative tasks.\n\nTo see the input structure of a given metric, you can look at its metric card. For example, in the case of [precision](https://huggingface.co/metrics/precision), the format is:\n```\n>>> precision_metric = evaluate.load(\"precision\")\n>>> results = precision_metric.compute(references=[0, 1], predictions=[0, 1])\n>>> print(results)\n{'precision': 1.0}\n```\n\n### Task-specific metrics\n\nPopular ML tasks like Machine Translation and Named Entity Recognition have specific metrics that can be used to compare models. For example, a series of different metrics have been proposed for text generation, ranging from [BLEU](https://huggingface.co/metrics/bleu) and its derivatives such as [GoogleBLEU](https://huggingface.co/metrics/google_bleu) and [GLEU](https://huggingface.co/metrics/gleu), but also [ROUGE](https://huggingface.co/metrics/rouge), [MAUVE](https://huggingface.co/metrics/mauve), etc.\n\nYou can find the right metric for your task by:\n\n- **Looking at the [Task pages](https://huggingface.co/tasks)** to see what metrics can be used for evaluating models for a given task.\n- **Checking out leaderboards** on sites like [Papers With Code](https://paperswithcode.com/) (you can search by task and by dataset).\n-  **Reading the metric cards** for the relevant metrics and see which ones are a good fit for your use case. For example, see the [BLEU metric card](https://github.com/huggingface/evaluate/tree/main/metrics/bleu) or [SQuaD metric card](https://github.com/huggingface/evaluate/tree/main/metrics/squad).\n- **Looking at papers and blog posts** published on the topic and see what metrics they report. This can change over time, so try to pick papers from the last couple of years!\n\n### Dataset-specific metrics\n\nSome datasets have specific metrics associated with them -- this is especially in the case of popular benchmarks like [GLUE](https://huggingface.co/metrics/glue) and [SQuAD](https://huggingface.co/metrics/squad).\n\n<Tip warning={true}>\n\ud83d\udca1\nGLUE is actually a collection of different subsets on different tasks, so first you need to choose the one that corresponds to the NLI task, such as mnli, which is described as \u201ccrowdsourced collection of sentence pairs with textual entailment annotations\u201d\n</Tip>\n\n\nIf you are evaluating your model on a benchmark dataset like the ones mentioned above, you can use its dedicated evaluation metric. Make sure you respect the format that they require. For example, to evaluate your model on the [SQuAD](https://huggingface.co/datasets/squad) dataset, you need to feed the `question` and `context` into your model and return the `prediction_text`, which should be compared with the `references` (based on matching the `id` of the question) :\n\n```\n>>> from evaluate import load\n>>> squad_metric = load(\"squad\")\n>>> predictions = [{'prediction_text': '1976', 'id': '56e10a3be3433e1400422b22'}]\n>>> references = [{'answers': {'answer_start': [97], 'text': ['1976']}, 'id': '56e10a3be3433e1400422b22'}]\n>>> results = squad_metric.compute(predictions=predictions, references=references)\n>>> results\n{'exact_match': 100.0, 'f1': 100.0}\n```\n\nYou can find examples of dataset structures by consulting the \"Dataset Preview\" function or the dataset card for a given dataset, and you can see how to use its dedicated evaluation function based on the metric card.\n    ```",
            "vector_context": "[Created at: 2025-03-24 13:16:13]\nChoosing a metric for your task\n\n**So you've trained your model and want to see how well it\u2019s doing on a dataset of your choice. Where do you start?**\n\nThere is no \u201cone size fits all\u201d approach to choosing an evaluation metric, but some good guidelines to keep in mind are:\n\n## Categories of metrics\n\nThere are 3 high-level categories of metrics:\n\n1. *Generic metrics*, which can be applied to a variety of situations and datasets, such as precision and accuracy.\n2. *Task-specific metrics*, which are limited to a given task, such as Machine Translation (often evaluated using metrics [BLEU](https://huggingface.co/metrics/bleu) or [ROUGE](https://huggingface.co/metrics/rouge)) or Named Entity Recognition (often evaluated with [seqeval](https://huggingface.co/metrics/seqeval)).\n3. *Dataset-specific metrics*, which aim to measure model performance on specific benchmarks: for instance, the [GLUE benchmark](https://huggingface.co/datasets/glue) has a dedicated [evaluation metric](https://huggingface.co/metrics/glue).\n\nLet's look at each of these three cases:\n\n### Generic metrics\n\nMany of the metrics used in the Machine Learning community are quite generic and can be applied in a variety of tasks and datasets.\n\nThis is the case for metrics like [accuracy](https://huggingface.co/metrics/accuracy) and [precision](https://huggingface.co/metrics/precision), which can be used for evaluating labeled (supervised) datasets, as well as [perplexity](https://huggingface.co/metrics/perplexity), which can be used for evaluating different kinds of (unsupervised) generative tasks.\n\nTo see the input structure of a given metric, you can look at its metric card. For example, in the case of [precision](https://huggingface.co/metrics/precision), the format is:\n```\n>>> precision_metric = evaluate.load(\"precision\")\n>>> results = precision_metric.compute(references=[0, 1], predictions=[0, 1])\n>>> print(results)\n{'precision': 1.0}\n```\n\n### Task-specific metrics\n\nPopular ML tasks like Machine Translation and Named Entity Recognition have specific metrics that can be used to compare models. For example, a series of different metrics have been proposed for text generation, ranging from [BLEU](https://huggingface.co/metrics/bleu) and its derivatives such as [GoogleBLEU](https://huggingface.co/metrics/google_bleu) and [GLEU](https://huggingface.co/metrics/gleu), but also [ROUGE](https://huggingface.co/metrics/rouge), [MAUVE](https://huggingface.co/metrics/mauve), etc.\n\nYou can find the right metric for your task by:\n\n- **Looking at the [Task pages](https://huggingface.co/tasks)** to see what metrics can be used for evaluating models for a given task.\n- **Checking out leaderboards** on sites like [Papers With Code](https://paperswithcode.com/) (you can search by task and by dataset).\n-  **Reading the metric cards** for the relevant metrics and see which ones are a good fit for your use case. For example, see the [BLEU metric card](https://github.com/huggingface/evaluate/tree/main/metrics/bleu) or [SQuaD metric card](https://github.com/huggingface/evaluate/tree/main/metrics/squad).\n- **Looking at papers and blog posts** published on the topic and see what metrics they report. This can change over time, so try to pick papers from the last couple of years!\n\n### Dataset-specific metrics\n\nSome datasets have specific metrics associated with them -- this is especially in the case of popular benchmarks like [GLUE](https://huggingface.co/metrics/glue) and [SQuAD](https://huggingface.co/metrics/squad).\n\n<Tip warning={true}>\n\ud83d\udca1\nGLUE is actually a collection of different subsets on different tasks, so first you need to choose the one that corresponds to the NLI task, such as mnli, which is described as \u201ccrowdsourced collection of sentence pairs with textual entailment annotations\u201d\n</Tip>\n\n\nIf you are evaluating your model on a benchmark dataset like the ones mentioned above, you can use its dedicated evaluation metric. Make sure you respect the format that they require. For example, to evaluate your model on the [SQuAD](https://huggingface.co/datasets/squad) dataset, you need to feed the `question` and `context` into your model and return the `prediction_text`, which should be compared with the `references` (based on matching the `id` of the question) :\n\n```\n>>> from evaluate import load\n>>> squad_metric = load(\"squad\")\n>>> predictions = [{'prediction_text': '1976', 'id': '56e10a3be3433e1400422b22'}]\n>>> references = [{'answers': {'answer_start': [97], 'text': ['1976']}, 'id': '56e10a3be3433e1400422b22'}]\n>>> results = squad_metric.compute(predictions=predictions, references=references)\n>>> results\n{'exact_match': 100.0, 'f1': 100.0}\n```\n\nYou can find examples of dataset structures by consulting the \"Dataset Preview\" function or the dataset card for a given dataset, and you can see how to use its dedicated evaluation function based on the metric card.\n--New Chunk--\n[Created at: 2025-03-24 13:16:13]\n=predictions, references=references)\n>>> results\n{'exact_match': 100.0, 'f1': 100.0}\n```\n\nYou can find examples of dataset structures by consulting the \"Dataset Preview\" function or the dataset card for a given dataset, and you can see how to use its dedicated evaluation function based on the metric card.\n--New Chunk--\n[Created at: 2025-03-24 13:19:17]\n!---\nCopyright 2022 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n-->\n\n# Token classification with LayoutLMv3 (PyTorch version)\n\nThis directory contains a script, `run_funsd_cord.py`, that can be used to fine-tune (or evaluate) LayoutLMv3 on form understanding datasets, such as [FUNSD](https://guillaumejaume.github.io/FUNSD/) and [CORD](https://github.com/clovaai/cord).\n\nThe script `run_funsd_cord.py` leverages the \ud83e\udd17 Datasets library and the Trainer API. You can easily customize it to your needs.\n\n## Fine-tuning on FUNSD\n\nFine-tuning LayoutLMv3 for token classification on [FUNSD](https://guillaumejaume.github.io/FUNSD/) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name funsd \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 1e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-funsd\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd. By specifying the `push_to_hub` flag, the model gets uploaded automatically to the hub (regularly), together with a model card, which includes metrics such as precision, recall and F1. Note that you can easily update the model card, as it's just a README file of the respective repo on the hub.\n\nThere's also the \"Training metrics\" [tab](https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd/tensorboard), which shows Tensorboard logs over the course of training. Pretty neat, huh?\n\n## Fine-tuning on CORD\n\nFine-tuning LayoutLMv3 for token classification on [CORD](https://github.com/clovaai/cord) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name cord \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 5e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-cord\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-cord. Note that a model card gets generated automatically in case you specify the `push_to_hub` flag."
        }
    },
    {
        "sample_idx": 12,
        "question": "What type of tasks can accuracy and precision be used for?",
        "answer": "Accuracy and precision can be used for evaluating labeled (supervised) datasets.",
        "rag_answer": "**Generic Metrics**\nAccuracy and precision are examples of generic metrics that can be applied to a variety of situations and datasets. They can be used for evaluating labeled (supervised) datasets, specifically in tasks such as classification, object detection, and information retrieval.\n\n**Specific Use Cases**\nAccuracy is a suitable metric when the classes are balanced, meaning they have an equal number of instances. It provides an overall measure of how often the model is correct.\n\nPrecision, on the other hand, is more useful when the classes are imbalanced, meaning one class has a significantly larger number of instances than the others. It focuses on the proportion of true positives among all positive predictions made by the model.\n\nThese metrics can be used in various applications, such as:\n\n* Image classification\n* Sentiment analysis\n* Spam detection\n* Recommendation systems\n\n**References**\n[KG] Evaluation Function, category\n[DC] Choosing a metric for your task\n[KG] precision, category\n[KG] accuracy, category",
        "rag_score": 5,
        "rag_feedback": "The system's response is completely correct, accurate, and factual. It provides a detailed explanation of how accuracy and precision can be used for evaluating labeled (supervised) datasets, and also provides additional information on generic metrics, task-specific metrics, and dataset-specific metrics, which is relevant to the question.",
        "rag_context": {
            "kg_context": "-----Entities-----\n    ```csv\n    id,\tentity,\ttype,\tdescription,\trankcreated_at\n1,\tEvaluation Function,category,Evaluation Function is a tool used to assess the performance of a model.,2,2025-03-24 13:16:48\n2,\tModel,category,Model refers to a machine learning model being evaluated.,3,2025-03-24 13:16:48\n3,\tPredictions,category,Predictions are the outcome of a model's performance.,2,2025-03-24 13:16:48\n4,\tResults,event,Results are the outcome of evaluating a model, in this case, showing perfect accuracy.,1,2025-03-24 13:16:48\n5,\tResults,event,Results are the outcome of evaluating a model, in this case, showing perfect accuracy.,1,UNKNOWN\n6,\tprecision,category,precision is a category of evaluation metrics for machine learning models.,1,UNKNOWN\n7,\taccuracy,category,accuracy is a category of evaluation metrics for machine learning models.,1,UNKNOWN\n    ```\n    -----Relationships-----\n    ```csv\n    id,\tsource,\ttarget,\tdescription,\tkeywords,\tweight,\trank,\tcreated_at\n1,\tEvaluation Function,Model,The evaluation function is used to assess the performance of the model.,model evaluation, performance assessment,18.0,5,2025-03-24 13:16:48\n2,\tModel,Predictions,The model makes predictions based on the input data.,model output, predictions,8.0,5,2025-03-24 13:16:48\n3,\tEvaluation Function,Results,The results are obtained by using the evaluation function.,evaluation outcome, accuracy,20.0,3,2025-03-24 13:16:48\n4,\tMachine Learning,precision,precision is a metric used to evaluate machine learning models.,evaluation metric, task,9.0,6,UNKNOWN\n5,\tMachine Learning,accuracy,accuracy is a metric used to evaluate machine learning models.,evaluation metric, task,9.0,6,UNKNOWN\n6,\tEvaluation Function,Results,The results are obtained by using the evaluation function.,evaluation outcome, accuracy,20.0,3,UNKNOWN\n    ```\n    -----Sources-----\n    ```csv\n    id,\tcontent\n1,\t=predictions, references=references)\n>>> results\n{'exact_match': 100.0, 'f1': 100.0}\n```\n\nYou can find examples of dataset structures by consulting the \"Dataset Preview\" function or the dataset card for a given dataset, and you can see how to use its dedicated evaluation function based on the metric card.\n2,\tChoosing a metric for your task\n\n**So you've trained your model and want to see how well it\u2019s doing on a dataset of your choice. Where do you start?**\n\nThere is no \u201cone size fits all\u201d approach to choosing an evaluation metric, but some good guidelines to keep in mind are:\n\n## Categories of metrics\n\nThere are 3 high-level categories of metrics:\n\n1. *Generic metrics*, which can be applied to a variety of situations and datasets, such as precision and accuracy.\n2. *Task-specific metrics*, which are limited to a given task, such as Machine Translation (often evaluated using metrics [BLEU](https://huggingface.co/metrics/bleu) or [ROUGE](https://huggingface.co/metrics/rouge)) or Named Entity Recognition (often evaluated with [seqeval](https://huggingface.co/metrics/seqeval)).\n3. *Dataset-specific metrics*, which aim to measure model performance on specific benchmarks: for instance, the [GLUE benchmark](https://huggingface.co/datasets/glue) has a dedicated [evaluation metric](https://huggingface.co/metrics/glue).\n\nLet's look at each of these three cases:\n\n### Generic metrics\n\nMany of the metrics used in the Machine Learning community are quite generic and can be applied in a variety of tasks and datasets.\n\nThis is the case for metrics like [accuracy](https://huggingface.co/metrics/accuracy) and [precision](https://huggingface.co/metrics/precision), which can be used for evaluating labeled (supervised) datasets, as well as [perplexity](https://huggingface.co/metrics/perplexity), which can be used for evaluating different kinds of (unsupervised) generative tasks.\n\nTo see the input structure of a given metric, you can look at its metric card. For example, in the case of [precision](https://huggingface.co/metrics/precision), the format is:\n```\n>>> precision_metric = evaluate.load(\"precision\")\n>>> results = precision_metric.compute(references=[0, 1], predictions=[0, 1])\n>>> print(results)\n{'precision': 1.0}\n```\n\n### Task-specific metrics\n\nPopular ML tasks like Machine Translation and Named Entity Recognition have specific metrics that can be used to compare models. For example, a series of different metrics have been proposed for text generation, ranging from [BLEU](https://huggingface.co/metrics/bleu) and its derivatives such as [GoogleBLEU](https://huggingface.co/metrics/google_bleu) and [GLEU](https://huggingface.co/metrics/gleu), but also [ROUGE](https://huggingface.co/metrics/rouge), [MAUVE](https://huggingface.co/metrics/mauve), etc.\n\nYou can find the right metric for your task by:\n\n- **Looking at the [Task pages](https://huggingface.co/tasks)** to see what metrics can be used for evaluating models for a given task.\n- **Checking out leaderboards** on sites like [Papers With Code](https://paperswithcode.com/) (you can search by task and by dataset).\n-  **Reading the metric cards** for the relevant metrics and see which ones are a good fit for your use case. For example, see the [BLEU metric card](https://github.com/huggingface/evaluate/tree/main/metrics/bleu) or [SQuaD metric card](https://github.com/huggingface/evaluate/tree/main/metrics/squad).\n- **Looking at papers and blog posts** published on the topic and see what metrics they report. This can change over time, so try to pick papers from the last couple of years!\n\n### Dataset-specific metrics\n\nSome datasets have specific metrics associated with them -- this is especially in the case of popular benchmarks like [GLUE](https://huggingface.co/metrics/glue) and [SQuAD](https://huggingface.co/metrics/squad).\n\n<Tip warning={true}>\n\ud83d\udca1\nGLUE is actually a collection of different subsets on different tasks, so first you need to choose the one that corresponds to the NLI task, such as mnli, which is described as \u201ccrowdsourced collection of sentence pairs with textual entailment annotations\u201d\n</Tip>\n\n\nIf you are evaluating your model on a benchmark dataset like the ones mentioned above, you can use its dedicated evaluation metric. Make sure you respect the format that they require. For example, to evaluate your model on the [SQuAD](https://huggingface.co/datasets/squad) dataset, you need to feed the `question` and `context` into your model and return the `prediction_text`, which should be compared with the `references` (based on matching the `id` of the question) :\n\n```\n>>> from evaluate import load\n>>> squad_metric = load(\"squad\")\n>>> predictions = [{'prediction_text': '1976', 'id': '56e10a3be3433e1400422b22'}]\n>>> references = [{'answers': {'answer_start': [97], 'text': ['1976']}, 'id': '56e10a3be3433e1400422b22'}]\n>>> results = squad_metric.compute(predictions=predictions, references=references)\n>>> results\n{'exact_match': 100.0, 'f1': 100.0}\n```\n\nYou can find examples of dataset structures by consulting the \"Dataset Preview\" function or the dataset card for a given dataset, and you can see how to use its dedicated evaluation function based on the metric card.\n    ```",
            "vector_context": "[Created at: 2025-03-24 13:16:13]\nChoosing a metric for your task\n\n**So you've trained your model and want to see how well it\u2019s doing on a dataset of your choice. Where do you start?**\n\nThere is no \u201cone size fits all\u201d approach to choosing an evaluation metric, but some good guidelines to keep in mind are:\n\n## Categories of metrics\n\nThere are 3 high-level categories of metrics:\n\n1. *Generic metrics*, which can be applied to a variety of situations and datasets, such as precision and accuracy.\n2. *Task-specific metrics*, which are limited to a given task, such as Machine Translation (often evaluated using metrics [BLEU](https://huggingface.co/metrics/bleu) or [ROUGE](https://huggingface.co/metrics/rouge)) or Named Entity Recognition (often evaluated with [seqeval](https://huggingface.co/metrics/seqeval)).\n3. *Dataset-specific metrics*, which aim to measure model performance on specific benchmarks: for instance, the [GLUE benchmark](https://huggingface.co/datasets/glue) has a dedicated [evaluation metric](https://huggingface.co/metrics/glue).\n\nLet's look at each of these three cases:\n\n### Generic metrics\n\nMany of the metrics used in the Machine Learning community are quite generic and can be applied in a variety of tasks and datasets.\n\nThis is the case for metrics like [accuracy](https://huggingface.co/metrics/accuracy) and [precision](https://huggingface.co/metrics/precision), which can be used for evaluating labeled (supervised) datasets, as well as [perplexity](https://huggingface.co/metrics/perplexity), which can be used for evaluating different kinds of (unsupervised) generative tasks.\n\nTo see the input structure of a given metric, you can look at its metric card. For example, in the case of [precision](https://huggingface.co/metrics/precision), the format is:\n```\n>>> precision_metric = evaluate.load(\"precision\")\n>>> results = precision_metric.compute(references=[0, 1], predictions=[0, 1])\n>>> print(results)\n{'precision': 1.0}\n```\n\n### Task-specific metrics\n\nPopular ML tasks like Machine Translation and Named Entity Recognition have specific metrics that can be used to compare models. For example, a series of different metrics have been proposed for text generation, ranging from [BLEU](https://huggingface.co/metrics/bleu) and its derivatives such as [GoogleBLEU](https://huggingface.co/metrics/google_bleu) and [GLEU](https://huggingface.co/metrics/gleu), but also [ROUGE](https://huggingface.co/metrics/rouge), [MAUVE](https://huggingface.co/metrics/mauve), etc.\n\nYou can find the right metric for your task by:\n\n- **Looking at the [Task pages](https://huggingface.co/tasks)** to see what metrics can be used for evaluating models for a given task.\n- **Checking out leaderboards** on sites like [Papers With Code](https://paperswithcode.com/) (you can search by task and by dataset).\n-  **Reading the metric cards** for the relevant metrics and see which ones are a good fit for your use case. For example, see the [BLEU metric card](https://github.com/huggingface/evaluate/tree/main/metrics/bleu) or [SQuaD metric card](https://github.com/huggingface/evaluate/tree/main/metrics/squad).\n- **Looking at papers and blog posts** published on the topic and see what metrics they report. This can change over time, so try to pick papers from the last couple of years!\n\n### Dataset-specific metrics\n\nSome datasets have specific metrics associated with them -- this is especially in the case of popular benchmarks like [GLUE](https://huggingface.co/metrics/glue) and [SQuAD](https://huggingface.co/metrics/squad).\n\n<Tip warning={true}>\n\ud83d\udca1\nGLUE is actually a collection of different subsets on different tasks, so first you need to choose the one that corresponds to the NLI task, such as mnli, which is described as \u201ccrowdsourced collection of sentence pairs with textual entailment annotations\u201d\n</Tip>\n\n\nIf you are evaluating your model on a benchmark dataset like the ones mentioned above, you can use its dedicated evaluation metric. Make sure you respect the format that they require. For example, to evaluate your model on the [SQuAD](https://huggingface.co/datasets/squad) dataset, you need to feed the `question` and `context` into your model and return the `prediction_text`, which should be compared with the `references` (based on matching the `id` of the question) :\n\n```\n>>> from evaluate import load\n>>> squad_metric = load(\"squad\")\n>>> predictions = [{'prediction_text': '1976', 'id': '56e10a3be3433e1400422b22'}]\n>>> references = [{'answers': {'answer_start': [97], 'text': ['1976']}, 'id': '56e10a3be3433e1400422b22'}]\n>>> results = squad_metric.compute(predictions=predictions, references=references)\n>>> results\n{'exact_match': 100.0, 'f1': 100.0}\n```\n\nYou can find examples of dataset structures by consulting the \"Dataset Preview\" function or the dataset card for a given dataset, and you can see how to use its dedicated evaluation function based on the metric card.\n--New Chunk--\n[Created at: 2025-03-24 13:16:13]\n=predictions, references=references)\n>>> results\n{'exact_match': 100.0, 'f1': 100.0}\n```\n\nYou can find examples of dataset structures by consulting the \"Dataset Preview\" function or the dataset card for a given dataset, and you can see how to use its dedicated evaluation function based on the metric card.\n--New Chunk--\n[Created at: 2025-03-24 13:17:32]\n!--Copyright 2023 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\nthe License. You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under the License is distributed on\nan \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n\n\u26a0\ufe0f Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be\nrendered properly in your Markdown viewer.\n\n-->\n\n# Training on TPU with TensorFlow\n\n<Tip>\n\nIf you don't need long explanations and just want TPU code samples to get started with, check out [our TPU example notebook!](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb)\n\n</Tip>\n\n### What is a TPU?\n\nA TPU is a **Tensor Processing Unit.** They are hardware designed by Google, which are used to greatly speed up the tensor computations within neural networks, much like GPUs. They can be used for both network training and inference. They are generally accessed through Google\u2019s cloud services, but small TPUs can also be accessed directly for free through Google Colab and Kaggle Kernels.\n\nBecause [all TensorFlow models in \ud83e\udd17 Transformers are Keras models](https://huggingface.co/blog/tensorflow-philosophy), most of the methods in this document are generally applicable to TPU training for any Keras model! However, there are a few points that are specific to the HuggingFace ecosystem (hug-o-system?) of Transformers and Datasets, and we\u2019ll make sure to flag them up when we get to them.\n\n### What kinds of TPU are available?\n\nNew users are often very confused by the range of TPUs, and the different ways to access them. The first key distinction to understand is the difference between **TPU Nodes** and **TPU VMs.**\n\nWhen you use a **TPU Node**, you are effectively indirectly accessing a remote TPU. You will need a separate VM, which will initialize your network and data pipeline and then forward them to the remote node. When you use a TPU on Google Colab, you are accessing it in the **TPU Node** style.\n\nUsing TPU Nodes can have some quite unexpected behaviour for people who aren\u2019t used to them! In particular, because the TPU is located on a physically different system to the machine you\u2019re running your Python code on, your data cannot be local to your machine - any data pipeline that loads from your machine\u2019s internal storage will totally fail! Instead, data must be stored in Google Cloud Storage where your data pipeline can still access it, even when the pipeline is running on the remote TPU node.\n\n<Tip>\n\nIf you can fit all your data in memory as `np.ndarray` or `tf.Tensor`, then you can `fit()` on that data even when using Colab or a TPU Node, without needing to upload it to Google Cloud Storage.\n\n</Tip>\n\n<Tip>\n\n**\ud83e\udd17Specific Hugging Face Tip\ud83e\udd17:** The methods `Dataset.to_tf_dataset()` and its higher-level wrapper `model.prepare_tf_dataset()` , which you will see throughout our TF code examples, will both fail on a TPU Node. The reason for this is that even though they create a `tf.data.Dataset` it is not a \u201cpure\u201d `tf.data` pipeline and uses `tf.numpy_function` or `Dataset.from_generator()` to stream data from the underlying HuggingFace `Dataset`. This HuggingFace `Dataset` is backed by data that is on a local disc and which the remote TPU Node will not be able to read.\n\n</Tip>\n\nThe second way to access a TPU is via a **TPU VM.** When using a TPU VM, you connect directly to the machine that the TPU is attached to, much like training on a GPU VM. TPU VMs are generally easier to work with, particularly when it comes to your data pipeline. All of the above warnings do not apply to TPU VMs!\n\nThis is an opinionated document, so here\u2019s our opinion: **Avoid using TPU Node if possible.** It is more confusing and more difficult to debug than TPU VMs. It is also likely to be unsupported in future - Google\u2019s latest TPU, TPUv4, can only be accessed as a TPU VM, which suggests that TPU Nodes are increasingly going to become a \u201clegacy\u201d access method. However, we understand that the only free TPU access is on Colab and Kaggle Kernels, which uses TPU Node - so we\u2019ll try to explain how to handle it if you have to! Check the [TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) for code samples that explain this in more detail.\n\n### What sizes of TPU are available?\n\nA single TPU (a v2-8/v3-8/v4-8) runs 8 replicas. TPUs exist in **pods** that can run hundreds or thousands of replicas simultaneously. When you use more than a single TPU but less than a whole pod (for example, a v3-32), your TPU fleet is referred to as a **pod slice.**\n\nWhen you access a free TPU via Colab, you generally get a single v2-8 TPU.\n\n### I keep hearing about this XLA thing. What\u2019s XLA, and how does it relate to TPUs?\n\nXLA is an optimizing compiler, used by both TensorFlow and JAX. In JAX it is the only compiler, whereas in TensorFlow it is optional"
        }
    },
    {
        "sample_idx": 13,
        "question": "What type of tasks can perplexity be used for?",
        "answer": "Perplexity can be used for evaluating different kinds of (unsupervised) generative tasks.",
        "rag_answer": "Perplexity is a metric that can be used for evaluating the performance of models on unsupervised generative tasks. It measures how well a probability distribution or probability model predicts a sample. It may be used for tasks such as:\n\n### Generative tasks\n\nPerplexity is particularly useful for evaluating models that generate text, such as language models, or models that generate images, such as generative adversarial networks (GANs).\n\n### Language models\n\nPerplexity is widely used to evaluate the performance of language models. A lower perplexity indicates that the model is better at predicting the test data.\n\n### Text generation\n\nPerplexity can be used to evaluate the quality of generated text in tasks such as machine translation, text summarization, and chatbots.\n\nReferences:\n[KG] Machine Learning, category\n[KG] perplexity, category\n[DC] Choosing a metric for your task",
        "rag_score": 5,
        "rag_feedback": "The system's response is completely correct, accurate, and factual. It provides a detailed explanation of how perplexity can be used for evaluating different kinds of unsupervised generative tasks, including language models and generative adversarial networks (GANs). The response also provides specific examples of how perplexity can be used for evaluating the quality of generated text in tasks such as machine translation, text summarization, and chatbots.",
        "rag_context": {
            "kg_context": "-----Entities-----\n    ```csv\n    id,\tentity,\ttype,\tdescription,\trankcreated_at\n1,\tMachine Learning,category,Machine Learning is a field of study that involves training models to make predictions.,5,2025-03-24 13:16:48\n2,\tperplexity,category,perplexity is a category of evaluation metrics for machine learning models.,1,2025-03-24 13:16:48\n3,\tBLEU,category,BLEU is a category of evaluation metrics for machine translation tasks.,1,2025-03-24 13:16:48\n4,\tMachine Translation,event,Machine Translation is an event or task in natural language processing.,3,2025-03-24 13:16:48\n5,\tGoogleBLEU,category,GoogleBLEU is a category of evaluation metrics for machine translation tasks.,1,2025-03-24 13:16:48\n6,\tNLP,category,NLP is a field of study focused on natural language processing and machine learning.,1,UNKNOWN\n7,\tdistilbert-base-uncased-finetuned-sst-2-english,category,distilbert-base-uncased-finetuned-sst-2-english is a specific AI model for text classification.,1,UNKNOWN\n8,\tword,category,Word refers to a unit of language or text.,0,UNKNOWN\n    ```\n    -----Relationships-----\n    ```csv\n    id,\tsource,\ttarget,\tdescription,\tkeywords,\tweight,\trank,\tcreated_at\n1,\tMachine Learning,perplexity,perplexity is a metric used to evaluate machine learning models.,evaluation metric, task,9.0,6,2025-03-24 13:16:48\n2,\tBLEU,Machine Translation,BLEU is a metric used to evaluate machine translation models.,evaluation metric, task,18.0,4,2025-03-24 13:16:48\n3,\tGoogleBLEU,Machine Translation,GoogleBLEU is a metric used to evaluate machine translation models.,evaluation metric, task,9.0,4,2025-03-24 13:16:48\n4,\tHugging Face,distilbert-base-uncased-finetuned-sst-2-english,Hugging Face provides a platform for deploying the distilbert-base-uncased-finetuned-sst-2-english model.,platform, model deployment,18.0,9,UNKNOWN\n5,\tHuggingFace,NLP,HuggingFace provides tools and resources for NLP and machine learning.,resource provision, NLP support,16.0,6,UNKNOWN\n    ```\n    -----Sources-----\n    ```csv\n    id,\tcontent\n1,\tChoosing a metric for your task\n\n**So you've trained your model and want to see how well it\u2019s doing on a dataset of your choice. Where do you start?**\n\nThere is no \u201cone size fits all\u201d approach to choosing an evaluation metric, but some good guidelines to keep in mind are:\n\n## Categories of metrics\n\nThere are 3 high-level categories of metrics:\n\n1. *Generic metrics*, which can be applied to a variety of situations and datasets, such as precision and accuracy.\n2. *Task-specific metrics*, which are limited to a given task, such as Machine Translation (often evaluated using metrics [BLEU](https://huggingface.co/metrics/bleu) or [ROUGE](https://huggingface.co/metrics/rouge)) or Named Entity Recognition (often evaluated with [seqeval](https://huggingface.co/metrics/seqeval)).\n3. *Dataset-specific metrics*, which aim to measure model performance on specific benchmarks: for instance, the [GLUE benchmark](https://huggingface.co/datasets/glue) has a dedicated [evaluation metric](https://huggingface.co/metrics/glue).\n\nLet's look at each of these three cases:\n\n### Generic metrics\n\nMany of the metrics used in the Machine Learning community are quite generic and can be applied in a variety of tasks and datasets.\n\nThis is the case for metrics like [accuracy](https://huggingface.co/metrics/accuracy) and [precision](https://huggingface.co/metrics/precision), which can be used for evaluating labeled (supervised) datasets, as well as [perplexity](https://huggingface.co/metrics/perplexity), which can be used for evaluating different kinds of (unsupervised) generative tasks.\n\nTo see the input structure of a given metric, you can look at its metric card. For example, in the case of [precision](https://huggingface.co/metrics/precision), the format is:\n```\n>>> precision_metric = evaluate.load(\"precision\")\n>>> results = precision_metric.compute(references=[0, 1], predictions=[0, 1])\n>>> print(results)\n{'precision': 1.0}\n```\n\n### Task-specific metrics\n\nPopular ML tasks like Machine Translation and Named Entity Recognition have specific metrics that can be used to compare models. For example, a series of different metrics have been proposed for text generation, ranging from [BLEU](https://huggingface.co/metrics/bleu) and its derivatives such as [GoogleBLEU](https://huggingface.co/metrics/google_bleu) and [GLEU](https://huggingface.co/metrics/gleu), but also [ROUGE](https://huggingface.co/metrics/rouge), [MAUVE](https://huggingface.co/metrics/mauve), etc.\n\nYou can find the right metric for your task by:\n\n- **Looking at the [Task pages](https://huggingface.co/tasks)** to see what metrics can be used for evaluating models for a given task.\n- **Checking out leaderboards** on sites like [Papers With Code](https://paperswithcode.com/) (you can search by task and by dataset).\n-  **Reading the metric cards** for the relevant metrics and see which ones are a good fit for your use case. For example, see the [BLEU metric card](https://github.com/huggingface/evaluate/tree/main/metrics/bleu) or [SQuaD metric card](https://github.com/huggingface/evaluate/tree/main/metrics/squad).\n- **Looking at papers and blog posts** published on the topic and see what metrics they report. This can change over time, so try to pick papers from the last couple of years!\n\n### Dataset-specific metrics\n\nSome datasets have specific metrics associated with them -- this is especially in the case of popular benchmarks like [GLUE](https://huggingface.co/metrics/glue) and [SQuAD](https://huggingface.co/metrics/squad).\n\n<Tip warning={true}>\n\ud83d\udca1\nGLUE is actually a collection of different subsets on different tasks, so first you need to choose the one that corresponds to the NLI task, such as mnli, which is described as \u201ccrowdsourced collection of sentence pairs with textual entailment annotations\u201d\n</Tip>\n\n\nIf you are evaluating your model on a benchmark dataset like the ones mentioned above, you can use its dedicated evaluation metric. Make sure you respect the format that they require. For example, to evaluate your model on the [SQuAD](https://huggingface.co/datasets/squad) dataset, you need to feed the `question` and `context` into your model and return the `prediction_text`, which should be compared with the `references` (based on matching the `id` of the question) :\n\n```\n>>> from evaluate import load\n>>> squad_metric = load(\"squad\")\n>>> predictions = [{'prediction_text': '1976', 'id': '56e10a3be3433e1400422b22'}]\n>>> references = [{'answers': {'answer_start': [97], 'text': ['1976']}, 'id': '56e10a3be3433e1400422b22'}]\n>>> results = squad_metric.compute(predictions=predictions, references=references)\n>>> results\n{'exact_match': 100.0, 'f1': 100.0}\n```\n\nYou can find examples of dataset structures by consulting the \"Dataset Preview\" function or the dataset card for a given dataset, and you can see how to use its dedicated evaluation function based on the metric card.\n2,\tlabel_mask  # Set negative label positions to 0\nmean_loss = tf.reduce_sum(loss) / tf.reduce_sum(label_mask)\n```\n\nHere, we avoid data-dependent shapes by computing the loss for every position, but zeroing out the masked positions in both the numerator and denominator when we calculate the mean, which yields exactly the same result as the first block while maintaining XLA compatibility. Note that we use the same trick as in rule #1 - converting a `tf.bool` to `tf.float32` and using it as an indicator variable. This is a really useful trick, so remember it if you need to convert your own code to XLA!\n\n#### XLA Rule #3: XLA will need to recompile your model for every different input shape it sees\n\nThis is the big one. What this means is that if your input shapes are very variable, XLA will have to recompile your model over and over, which will create huge performance problems. This commonly arises in NLP models, where input texts have variable lengths after tokenization. In other modalities, static shapes are more common and this rule is much less of a problem.\n\nHow can you get around rule #3? The key is **padding** - if you pad all your inputs to the same length, and then use an `attention_mask`, you can get the same results as you\u2019d get from variable shapes, but without any XLA issues. However, excessive padding can cause severe slowdown too - if you pad all your samples to the maximum length in the whole dataset, you might end up with batches consisting endless padding tokens, which will waste a lot of compute and memory!\n\nThere isn\u2019t a perfect solution to this problem. However, you can try some tricks. One very useful trick is to **pad batches of samples up to a multiple of a number like 32 or 64 tokens.** This often only increases the number of tokens by a small amount, but it hugely reduces the number of unique input shapes, because every input shape now has to be a multiple of 32 or 64. Fewer unique input shapes means fewer XLA compilations!\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** Our tokenizers and data collators have methods that can help you here. You can use `padding=\"max_length\"` or `padding=\"longest\"` when calling tokenizers to get them to output padded data. Our tokenizers and data collators also have a `pad_to_multiple_of` argument that you can use to reduce the number of unique input shapes you see!\n\n</Tip>\n\n### How do I actually train my model on TPU?\n\nOnce your training is XLA-compatible and (if you\u2019re using TPU Node / Colab) your dataset has been prepared appropriately, running on TPU is surprisingly easy! All you really need to change in your code is to add a few lines to initialize your TPU, and to ensure that your model and dataset are created inside a `TPUStrategy` scope. Take a look at [our TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) to see this in action!\n\n### Summary\n\nThere was a lot in here, so let\u2019s summarize with a quick checklist you can follow when you want to get your model ready for TPU training:\n\n- Make sure your code follows the three rules of XLA\n- Compile your model with `jit_compile=True` on CPU/GPU and confirm that you can train it with XLA\n- Either load your dataset into memory or use a TPU-compatible dataset loading approach (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Migrate your code either to Colab (with accelerator set to \u201cTPU\u201d) or a TPU VM on Google Cloud\n- Add TPU initializer code (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Create your `TPUStrategy` and make sure dataset loading and model creation are inside the `strategy.scope()` (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Don\u2019t forget to take `jit_compile=True` out again when you move to TPU!\n- \ud83d\ude4f\ud83d\ude4f\ud83d\ude4f\ud83e\udd7a\ud83e\udd7a\ud83e\udd7a\n- Call model.fit()\n- You did it!\n3,\tCreate an Endpoint\n\nAfter your first login, you will be directed to the [Endpoint creation page](https://ui.endpoints.huggingface.co/new). As an example, this guide will go through the steps to deploy [distilbert-base-uncased-finetuned-sst-2-english](https://huggingface.co/distilbert-base-uncased-finetuned-sst-2-english) for text classification. \n\n## 1. Enter the Hugging Face Repository ID and your desired endpoint name:\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_repository.png\" alt=\"select repository\" />\n\n## 2. Select your Cloud Provider and region. Initially, only AWS will be available as a Cloud Provider with the `us-east-1` and `eu-west-1` regions. We will add Azure soon, and if you need to test Endpoints with other Cloud Providers or regions, please let us know.\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_region.png\" alt=\"select region\" />\n\n## 3. Define the [Security Level](security) for the Endpoint:\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_security.png\" alt=\"define security\" />\n\n## 4. Create your Endpoint by clicking **Create Endpoint**. By default, your Endpoint is created with a medium CPU (2 x 4GB vCPUs with Intel Xeon Ice Lake) The cost estimate assumes the Endpoint will be up for an entire month, and does not take autoscaling into account.\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_create_cost.png\" alt=\"create endpoint\" />\n\n## 5. Wait for the Endpoint to build, initialize and run which can take between 1 to 5 minutes.\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/overview.png\" alt=\"overview\" />\n\n## 6. Test your Endpoint in the overview with the Inference widget \ud83c\udfc1 \ud83c\udf89!\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_inference.png\" alt=\"run inference\" />\n4,\t\u4e0e\u5e38\u89c4\u51fd\u6570\u76f8\u540c\u7684\u65b9\u5f0f\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio\u3002\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\uff08\u865a\u62df\u7684\uff09\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5b83\u5728\u8f93\u51fa\u56fe\u50cf\u4e4b\u524d\u751f\u6210\u6570\u4e2a\u6b65\u9aa4\u7684\u566a\u97f3\uff1a\n\n$code_fake_diffusion\n$demo_fake_diffusion\n\n\u8bf7\u6ce8\u610f\uff0c\u6211\u4eec\u5728\u8fed\u4ee3\u5668\u4e2d\u6dfb\u52a0\u4e86 `time.sleep(1)`\uff0c\u4ee5\u521b\u5efa\u6b65\u9aa4\u4e4b\u95f4\u7684\u4eba\u5de5\u6682\u505c\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u89c2\u5bdf\u8fed\u4ee3\u5668\u7684\u6b65\u9aa4\uff08\u5728\u771f\u5b9e\u7684\u56fe\u50cf\u751f\u6210\u6a21\u578b\u4e2d\uff0c\u8fd9\u53ef\u80fd\u662f\u4e0d\u5fc5\u8981\u7684\uff09\u3002\n\n\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio **\u9700\u8981**\u5728\u5e95\u5c42 Interface \u6216 Blocks \u4e2d\u542f\u7528\u961f\u5217\uff08\u8bf7\u53c2\u9605\u4e0a\u9762\u7684\u961f\u5217\u90e8\u5206\uff09\u3002\n\n## \u8fdb\u5ea6\u6761\n\nGradio \u652f\u6301\u521b\u5efa\u81ea\u5b9a\u4e49\u8fdb\u5ea6\u6761\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u81ea\u5b9a\u4e49\u548c\u63a7\u5236\u5411\u7528\u6237\u663e\u793a\u7684\u8fdb\u5ea6\u66f4\u65b0\u3002\u8981\u542f\u7528\u6b64\u529f\u80fd\uff0c\u53ea\u9700\u4e3a\u65b9\u6cd5\u6dfb\u52a0\u4e00\u4e2a\u9ed8\u8ba4\u503c\u4e3a `gr.Progress` \u5b9e\u4f8b\u7684\u53c2\u6570\u5373\u53ef\u3002\u7136\u540e\uff0c\u60a8\u53ef\u4ee5\u76f4\u63a5\u8c03\u7528\u6b64\u5b9e\u4f8b\u5e76\u4f20\u5165 0 \u5230 1 \u4e4b\u95f4\u7684\u6d6e\u70b9\u6570\u6765\u66f4\u65b0\u8fdb\u5ea6\u7ea7\u522b\uff0c\u6216\u8005 with `Progress` \u5b9e\u4f8b\u7684 `tqdm()` \u65b9\u6cd5\u6765\u8ddf\u8e2a\u53ef\u8fed\u4ee3\u5bf9\u8c61\u4e0a\u7684\u8fdb\u5ea6\uff0c\u5982\u4e0b\u6240\u793a\u3002\u5fc5\u987b\u542f\u7528\u961f\u5217\u4ee5\u8fdb\u884c\u8fdb\u5ea6\u66f4\u65b0\u3002\n\n$code_progress_simple\n$demo_progress_simple\n\n\u5982\u679c\u60a8 with `tqdm` \u5e93\uff0c\u5e76\u4e14\u5e0c\u671b\u4ece\u51fd\u6570\u5185\u90e8\u7684\u4efb\u4f55 `tqdm.tqdm` \u81ea\u52a8\u62a5\u544a\u8fdb\u5ea6\u66f4\u65b0\uff0c\u8bf7\u5c06\u9ed8\u8ba4\u53c2\u6570\u8bbe\u7f6e\u4e3a `gr.Progress(track_tqdm=True)`\uff01\n\n## \u6279\u5904\u7406\u51fd\u6570 (Batch Functions)\n\nGradio \u652f\u6301\u4f20\u9012*\u6279\u5904\u7406*\u51fd\u6570\u3002\u6279\u5904\u7406\u51fd\u6570\u53ea\u662f\u63a5\u53d7\u8f93\u5165\u5217\u8868\u5e76\u8fd4\u56de\u9884\u6d4b\u5217\u8868\u7684\u51fd\u6570\u3002\n\n\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\u6279\u5904\u7406\u51fd\u6570\uff0c\u5b83\u63a5\u53d7\u4e24\u4e2a\u8f93\u5165\u5217\u8868\uff08\u4e00\u4e2a\u5355\u8bcd\u5217\u8868\u548c\u4e00\u4e2a\u6574\u6570\u5217\u8868\uff09\uff0c\u5e76\u8fd4\u56de\u4fee\u526a\u8fc7\u7684\u5355\u8bcd\u5217\u8868\u4f5c\u4e3a\u8f93\u51fa\uff1a\n\n```python\nimport time\n\ndef trim_words(words, lens):\n    trimmed_words = []\n    time.sleep(5)\n    for w, l in zip(words, lens):\n        trimmed_words.append(w[:int(l)])\n    return [trimmed_words]\n    for w, l in zip(words, lens):\n```\n\n\u4f7f\u7528\u6279\u5904\u7406\u51fd\u6570\u7684\u4f18\u70b9\u662f\uff0c\u5982\u679c\u542f\u7528\u4e86\u961f\u5217\uff0cGradio \u670d\u52a1\u5668\u53ef\u4ee5\u81ea\u52a8*\u6279\u5904\u7406*\u4f20\u5165\u7684\u8bf7\u6c42\u5e76\u5e76\u884c\u5904\u7406\u5b83\u4eec\uff0c\u4ece\u800c\u53ef\u80fd\u52a0\u5feb\u6f14\u793a\u901f\u5ea6\u3002\u4ee5\u4e0b\u662f Gradio \u4ee3\u7801\u7684\u793a\u4f8b\uff08\u8bf7\u6ce8\u610f `batch=True` \u548c `max_batch_size=16` - \u8fd9\u4e24\u4e2a\u53c2\u6570\u90fd\u53ef\u4ee5\u4f20\u9012\u7ed9\u4e8b\u4ef6\u89e6\u53d1\u5668\u6216 `Interface` \u7c7b\uff09\n\nwith `Interface`\uff1a\n\n```python\ndemo = gr.Interface(trim_words, [\"textbox\", \"number\"], [\"output\"],\n                    batch=True, max_batch_size=16)\ndemo.queue()\ndemo.launch()\n```\n\nwith `Blocks`\uff1a\n\n```python\nimport gradio as gr\n\nwith gr.Blocks() as demo:\n    with gr.Row():\n        word = gr.Textbox(label=\"word\")\n        leng = gr.Number(label=\"leng\")\n        output = gr.Textbox(label=\"Output\")\n    with gr.Row():\n        run = gr.Button()\n\n    event = run.click(trim_words, [word, leng], output, batch=True, max_batch_size=16)\n\ndemo.queue()\ndemo.launch()\n```\n\n\u5728\u4e0a\u9762\u7684\u793a\u4f8b\u4e2d\uff0c\u53ef\u4ee5\u5e76\u884c\u5904\u7406 16 \u4e2a\u8bf7\u6c42\uff08\u603b\u63a8\u7406\u65f6\u95f4\u4e3a 5 \u79d2\uff09\uff0c\u800c\u4e0d\u662f\u5206\u522b\u5904\u7406\u6bcf\u4e2a\u8bf7\u6c42\uff08\u603b\u63a8\u7406\u65f6\u95f4\u4e3a 80 \u79d2\uff09\u3002\u8bb8\u591a Hugging Face \u7684 `transformers` \u548c `diffusers` \u6a21\u578b\u5728 Gradio \u7684\u6279\u5904\u7406\u6a21\u5f0f\u4e0b\u81ea\u7136\u5de5\u4f5c\uff1a\u8fd9\u662f[\u4f7f\u7528\u6279\u5904\u7406\u751f\u6210\u56fe\u50cf\u7684\u793a\u4f8b\u6f14\u793a](https://github.com/gradio-app/gradio/blob/main/demo/diffusers_with_batching/run.py)\n\n\u6ce8\u610f\uff1a\u4f7f\u7528 Gradio \u7684\u6279\u5904\u7406\u51fd\u6570 **requires** \u5728\u5e95\u5c42 Interface \u6216 Blocks \u4e2d\u542f\u7528\u961f\u5217\uff08\u8bf7\u53c2\u9605\u4e0a\u9762\u7684\u961f\u5217\u90e8\u5206\uff09\u3002\n\n## Gradio \u7b14\u8bb0\u672c (Colab Notebooks)\n\nGradio \u53ef\u4ee5\u5728\u4efb\u4f55\u8fd0\u884c Python \u7684\u5730\u65b9\u8fd0\u884c\uff0c\u5305\u62ec\u672c\u5730 Jupyter \u7b14\u8bb0\u672c\u548c\u534f\u4f5c\u7b14\u8bb0\u672c\uff0c\u5982[Google Colab](https://colab.research.google.com/)\u3002\u5bf9\u4e8e\u672c\u5730 Jupyter \u7b14\u8bb0\u672c\u548c Google Colab \u7b14\u8bb0\u672c\uff0cGradio \u5728\u672c\u5730\u670d\u52a1\u5668\u4e0a\u8fd0\u884c\uff0c\u60a8\u53ef\u4ee5\u5728\u6d4f\u89c8\u5668\u4e2d\u4e0e\u4e4b\u4ea4\u4e92\u3002\uff08\u6ce8\u610f\uff1a\u5bf9\u4e8e Google Colab\uff0c\u8fd9\u662f\u901a\u8fc7[\u670d\u52a1\u5de5\u4f5c\u5668\u96a7\u9053](https://github.com/tensorflow/tensorboard/blob/master/docs/design/colab_integration.md)\u5b9e\u73b0\u7684\uff0c\u60a8\u7684\u6d4f\u89c8\u5668\u9700\u8981\u542f\u7528 cookies\u3002\uff09\u5bf9\u4e8e\u5176\u4ed6\u8fdc\u7a0b\u7b14\u8bb0\u672c\uff0cGradio \u4e5f\u5c06\u5728\u670d\u52a1\u5668\u4e0a\u8fd0\u884c\uff0c\u4f46\u60a8\u9700\u8981\u4f7f\u7528[SSH \u96a7\u9053](https://coderwall.com/p/ohk6cg/remote-access-to-ipython-notebooks-via-ssh)\u5728\u672c\u5730\u6d4f\u89c8\u5668\u4e2d\u67e5\u770b\u5e94\u7528\u7a0b\u5e8f\u3002\u901a\u5e38\uff0c\u66f4\u7b80\u5355\u7684\u9009\u62e9\u662f\u4f7f\u7528 Gradio \u5185\u7f6e\u7684\u516c\u5171\u94fe\u63a5\uff0c[\u5728\u4e0b\u4e00\u7bc7\u6307\u5357\u4e2d\u8ba8\u8bba](/sharing-your-app/#sharing-demos)\u3002\n    ```",
            "vector_context": "[Created at: 2025-03-24 13:16:13]\nChoosing a metric for your task\n\n**So you've trained your model and want to see how well it\u2019s doing on a dataset of your choice. Where do you start?**\n\nThere is no \u201cone size fits all\u201d approach to choosing an evaluation metric, but some good guidelines to keep in mind are:\n\n## Categories of metrics\n\nThere are 3 high-level categories of metrics:\n\n1. *Generic metrics*, which can be applied to a variety of situations and datasets, such as precision and accuracy.\n2. *Task-specific metrics*, which are limited to a given task, such as Machine Translation (often evaluated using metrics [BLEU](https://huggingface.co/metrics/bleu) or [ROUGE](https://huggingface.co/metrics/rouge)) or Named Entity Recognition (often evaluated with [seqeval](https://huggingface.co/metrics/seqeval)).\n3. *Dataset-specific metrics*, which aim to measure model performance on specific benchmarks: for instance, the [GLUE benchmark](https://huggingface.co/datasets/glue) has a dedicated [evaluation metric](https://huggingface.co/metrics/glue).\n\nLet's look at each of these three cases:\n\n### Generic metrics\n\nMany of the metrics used in the Machine Learning community are quite generic and can be applied in a variety of tasks and datasets.\n\nThis is the case for metrics like [accuracy](https://huggingface.co/metrics/accuracy) and [precision](https://huggingface.co/metrics/precision), which can be used for evaluating labeled (supervised) datasets, as well as [perplexity](https://huggingface.co/metrics/perplexity), which can be used for evaluating different kinds of (unsupervised) generative tasks.\n\nTo see the input structure of a given metric, you can look at its metric card. For example, in the case of [precision](https://huggingface.co/metrics/precision), the format is:\n```\n>>> precision_metric = evaluate.load(\"precision\")\n>>> results = precision_metric.compute(references=[0, 1], predictions=[0, 1])\n>>> print(results)\n{'precision': 1.0}\n```\n\n### Task-specific metrics\n\nPopular ML tasks like Machine Translation and Named Entity Recognition have specific metrics that can be used to compare models. For example, a series of different metrics have been proposed for text generation, ranging from [BLEU](https://huggingface.co/metrics/bleu) and its derivatives such as [GoogleBLEU](https://huggingface.co/metrics/google_bleu) and [GLEU](https://huggingface.co/metrics/gleu), but also [ROUGE](https://huggingface.co/metrics/rouge), [MAUVE](https://huggingface.co/metrics/mauve), etc.\n\nYou can find the right metric for your task by:\n\n- **Looking at the [Task pages](https://huggingface.co/tasks)** to see what metrics can be used for evaluating models for a given task.\n- **Checking out leaderboards** on sites like [Papers With Code](https://paperswithcode.com/) (you can search by task and by dataset).\n-  **Reading the metric cards** for the relevant metrics and see which ones are a good fit for your use case. For example, see the [BLEU metric card](https://github.com/huggingface/evaluate/tree/main/metrics/bleu) or [SQuaD metric card](https://github.com/huggingface/evaluate/tree/main/metrics/squad).\n- **Looking at papers and blog posts** published on the topic and see what metrics they report. This can change over time, so try to pick papers from the last couple of years!\n\n### Dataset-specific metrics\n\nSome datasets have specific metrics associated with them -- this is especially in the case of popular benchmarks like [GLUE](https://huggingface.co/metrics/glue) and [SQuAD](https://huggingface.co/metrics/squad).\n\n<Tip warning={true}>\n\ud83d\udca1\nGLUE is actually a collection of different subsets on different tasks, so first you need to choose the one that corresponds to the NLI task, such as mnli, which is described as \u201ccrowdsourced collection of sentence pairs with textual entailment annotations\u201d\n</Tip>\n\n\nIf you are evaluating your model on a benchmark dataset like the ones mentioned above, you can use its dedicated evaluation metric. Make sure you respect the format that they require. For example, to evaluate your model on the [SQuAD](https://huggingface.co/datasets/squad) dataset, you need to feed the `question` and `context` into your model and return the `prediction_text`, which should be compared with the `references` (based on matching the `id` of the question) :\n\n```\n>>> from evaluate import load\n>>> squad_metric = load(\"squad\")\n>>> predictions = [{'prediction_text': '1976', 'id': '56e10a3be3433e1400422b22'}]\n>>> references = [{'answers': {'answer_start': [97], 'text': ['1976']}, 'id': '56e10a3be3433e1400422b22'}]\n>>> results = squad_metric.compute(predictions=predictions, references=references)\n>>> results\n{'exact_match': 100.0, 'f1': 100.0}\n```\n\nYou can find examples of dataset structures by consulting the \"Dataset Preview\" function or the dataset card for a given dataset, and you can see how to use its dedicated evaluation function based on the metric card.\n--New Chunk--\n[Created at: 2025-03-24 13:19:17]\n!---\nCopyright 2022 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n-->\n\n# Token classification with LayoutLMv3 (PyTorch version)\n\nThis directory contains a script, `run_funsd_cord.py`, that can be used to fine-tune (or evaluate) LayoutLMv3 on form understanding datasets, such as [FUNSD](https://guillaumejaume.github.io/FUNSD/) and [CORD](https://github.com/clovaai/cord).\n\nThe script `run_funsd_cord.py` leverages the \ud83e\udd17 Datasets library and the Trainer API. You can easily customize it to your needs.\n\n## Fine-tuning on FUNSD\n\nFine-tuning LayoutLMv3 for token classification on [FUNSD](https://guillaumejaume.github.io/FUNSD/) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name funsd \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 1e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-funsd\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd. By specifying the `push_to_hub` flag, the model gets uploaded automatically to the hub (regularly), together with a model card, which includes metrics such as precision, recall and F1. Note that you can easily update the model card, as it's just a README file of the respective repo on the hub.\n\nThere's also the \"Training metrics\" [tab](https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd/tensorboard), which shows Tensorboard logs over the course of training. Pretty neat, huh?\n\n## Fine-tuning on CORD\n\nFine-tuning LayoutLMv3 for token classification on [CORD](https://github.com/clovaai/cord) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name cord \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 5e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-cord\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-cord. Note that a model card gets generated automatically in case you specify the `push_to_hub` flag.\n--New Chunk--\n[Created at: 2025-03-24 13:16:13]\n=predictions, references=references)\n>>> results\n{'exact_match': 100.0, 'f1': 100.0}\n```\n\nYou can find examples of dataset structures by consulting the \"Dataset Preview\" function or the dataset card for a given dataset, and you can see how to use its dedicated evaluation function based on the metric card."
        }
    },
    {
        "sample_idx": 14,
        "question": "What is the name of the metric used for evaluating models in Machine Translation and Named Entity Recognition tasks?",
        "answer": "Metrics such as BLEU, GoogleBLEU, GLEU, ROUGE, and MAUVE are used for evaluating models in Machine Translation and Named Entity Recognition tasks.",
        "rag_answer": "The metrics used for evaluating models in Machine Translation and Named Entity Recognition tasks are:\n\n**Machine Translation:**\n\n* BLEU (Bilingual Evaluation Understudy)\n* ROUGE (Recall-Oriented Understudy for Gisting Evaluation)\n* GLEU (Google's Machine Translation Metrics)\n* GoogleBLEU (a variant of BLEU)\n\n**Named Entity Recognition:**\n\n* seqeval (a metric for evaluating named entity recognition models)\n\nThese metrics are task-specific and can be used to compare models for a given task. You can find more information about these metrics and how to use them in the [Task pages](https://huggingface.co/tasks) and [metric cards](https://huggingface.co/metrics).\n\nReferences:\n[KG] BLEU, GLEU, GoogleBLEU, seqeval\n[DC] Choosing a metric for your task",
        "rag_score": 4,
        "rag_feedback": "The system's response is mostly correct, accurate, and factual. It provides a detailed explanation of the metrics used for evaluating models in Machine Translation and Named Entity Recognition tasks, including BLEU, GoogleBLEU, GLEU, ROUGE, and MAUVE. However, it also provides additional information that is not directly related to the question, such as the categories of metrics and how to choose the right metric for a task. The response is well-structured and easy to follow, but it could be more concise and focused on the specific question being asked.",
        "rag_context": {
            "kg_context": "-----Entities-----\n    ```csv\n    id,\tentity,\ttype,\tdescription,\trankcreated_at\n1,\tBLEU,category,BLEU is a category of evaluation metrics for machine translation tasks.,1,2025-03-24 13:16:48\n2,\tMachine Translation,event,Machine Translation is an event or task in natural language processing.,3,2025-03-24 13:16:48\n3,\tGLEU,category,GLEU is a category of evaluation metrics for machine translation tasks.,1,2025-03-24 13:16:48\n4,\tNamed Entity Recognition,event,Named Entity Recognition is an event or task in natural language processing.,1,2025-03-24 13:16:48\n5,\tseqeval,category,seqeval is a category of evaluation metrics for named entity recognition tasks.,1,2025-03-24 13:16:48\n6,\tBLEU,category,BLEU is a category of evaluation metrics for machine translation tasks.,1,UNKNOWN\n7,\tGLEU,category,GLEU is a category of evaluation metrics for machine translation tasks.,1,UNKNOWN\n8,\tGoogleBLEU,category,GoogleBLEU is a category of evaluation metrics for machine translation tasks.,1,UNKNOWN\n    ```\n    -----Relationships-----\n    ```csv\n    id,\tsource,\ttarget,\tdescription,\tkeywords,\tweight,\trank,\tcreated_at\n1,\tBLEU,Machine Translation,BLEU is a metric used to evaluate machine translation models.,evaluation metric, task,18.0,4,2025-03-24 13:16:48\n2,\tGLEU,Machine Translation,GLEU is a metric used to evaluate machine translation models.,evaluation metric, task,9.0,4,2025-03-24 13:16:48\n3,\tNamed Entity Recognition,seqeval,seqeval is a metric used to evaluate named entity recognition models.,evaluation metric, task,9.0,2,2025-03-24 13:16:48\n4,\tBLEU,Machine Translation,BLEU is a metric used to evaluate machine translation models.,evaluation metric, task,18.0,4,UNKNOWN\n5,\tGLEU,Machine Translation,GLEU is a metric used to evaluate machine translation models.,evaluation metric, task,9.0,4,UNKNOWN\n6,\tGoogleBLEU,Machine Translation,GoogleBLEU is a metric used to evaluate machine translation models.,evaluation metric, task,9.0,4,UNKNOWN\n    ```\n    -----Sources-----\n    ```csv\n    id,\tcontent\n1,\tChoosing a metric for your task\n\n**So you've trained your model and want to see how well it\u2019s doing on a dataset of your choice. Where do you start?**\n\nThere is no \u201cone size fits all\u201d approach to choosing an evaluation metric, but some good guidelines to keep in mind are:\n\n## Categories of metrics\n\nThere are 3 high-level categories of metrics:\n\n1. *Generic metrics*, which can be applied to a variety of situations and datasets, such as precision and accuracy.\n2. *Task-specific metrics*, which are limited to a given task, such as Machine Translation (often evaluated using metrics [BLEU](https://huggingface.co/metrics/bleu) or [ROUGE](https://huggingface.co/metrics/rouge)) or Named Entity Recognition (often evaluated with [seqeval](https://huggingface.co/metrics/seqeval)).\n3. *Dataset-specific metrics*, which aim to measure model performance on specific benchmarks: for instance, the [GLUE benchmark](https://huggingface.co/datasets/glue) has a dedicated [evaluation metric](https://huggingface.co/metrics/glue).\n\nLet's look at each of these three cases:\n\n### Generic metrics\n\nMany of the metrics used in the Machine Learning community are quite generic and can be applied in a variety of tasks and datasets.\n\nThis is the case for metrics like [accuracy](https://huggingface.co/metrics/accuracy) and [precision](https://huggingface.co/metrics/precision), which can be used for evaluating labeled (supervised) datasets, as well as [perplexity](https://huggingface.co/metrics/perplexity), which can be used for evaluating different kinds of (unsupervised) generative tasks.\n\nTo see the input structure of a given metric, you can look at its metric card. For example, in the case of [precision](https://huggingface.co/metrics/precision), the format is:\n```\n>>> precision_metric = evaluate.load(\"precision\")\n>>> results = precision_metric.compute(references=[0, 1], predictions=[0, 1])\n>>> print(results)\n{'precision': 1.0}\n```\n\n### Task-specific metrics\n\nPopular ML tasks like Machine Translation and Named Entity Recognition have specific metrics that can be used to compare models. For example, a series of different metrics have been proposed for text generation, ranging from [BLEU](https://huggingface.co/metrics/bleu) and its derivatives such as [GoogleBLEU](https://huggingface.co/metrics/google_bleu) and [GLEU](https://huggingface.co/metrics/gleu), but also [ROUGE](https://huggingface.co/metrics/rouge), [MAUVE](https://huggingface.co/metrics/mauve), etc.\n\nYou can find the right metric for your task by:\n\n- **Looking at the [Task pages](https://huggingface.co/tasks)** to see what metrics can be used for evaluating models for a given task.\n- **Checking out leaderboards** on sites like [Papers With Code](https://paperswithcode.com/) (you can search by task and by dataset).\n-  **Reading the metric cards** for the relevant metrics and see which ones are a good fit for your use case. For example, see the [BLEU metric card](https://github.com/huggingface/evaluate/tree/main/metrics/bleu) or [SQuaD metric card](https://github.com/huggingface/evaluate/tree/main/metrics/squad).\n- **Looking at papers and blog posts** published on the topic and see what metrics they report. This can change over time, so try to pick papers from the last couple of years!\n\n### Dataset-specific metrics\n\nSome datasets have specific metrics associated with them -- this is especially in the case of popular benchmarks like [GLUE](https://huggingface.co/metrics/glue) and [SQuAD](https://huggingface.co/metrics/squad).\n\n<Tip warning={true}>\n\ud83d\udca1\nGLUE is actually a collection of different subsets on different tasks, so first you need to choose the one that corresponds to the NLI task, such as mnli, which is described as \u201ccrowdsourced collection of sentence pairs with textual entailment annotations\u201d\n</Tip>\n\n\nIf you are evaluating your model on a benchmark dataset like the ones mentioned above, you can use its dedicated evaluation metric. Make sure you respect the format that they require. For example, to evaluate your model on the [SQuAD](https://huggingface.co/datasets/squad) dataset, you need to feed the `question` and `context` into your model and return the `prediction_text`, which should be compared with the `references` (based on matching the `id` of the question) :\n\n```\n>>> from evaluate import load\n>>> squad_metric = load(\"squad\")\n>>> predictions = [{'prediction_text': '1976', 'id': '56e10a3be3433e1400422b22'}]\n>>> references = [{'answers': {'answer_start': [97], 'text': ['1976']}, 'id': '56e10a3be3433e1400422b22'}]\n>>> results = squad_metric.compute(predictions=predictions, references=references)\n>>> results\n{'exact_match': 100.0, 'f1': 100.0}\n```\n\nYou can find examples of dataset structures by consulting the \"Dataset Preview\" function or the dataset card for a given dataset, and you can see how to use its dedicated evaluation function based on the metric card.\n    ```",
            "vector_context": "[Created at: 2025-03-24 13:16:13]\nChoosing a metric for your task\n\n**So you've trained your model and want to see how well it\u2019s doing on a dataset of your choice. Where do you start?**\n\nThere is no \u201cone size fits all\u201d approach to choosing an evaluation metric, but some good guidelines to keep in mind are:\n\n## Categories of metrics\n\nThere are 3 high-level categories of metrics:\n\n1. *Generic metrics*, which can be applied to a variety of situations and datasets, such as precision and accuracy.\n2. *Task-specific metrics*, which are limited to a given task, such as Machine Translation (often evaluated using metrics [BLEU](https://huggingface.co/metrics/bleu) or [ROUGE](https://huggingface.co/metrics/rouge)) or Named Entity Recognition (often evaluated with [seqeval](https://huggingface.co/metrics/seqeval)).\n3. *Dataset-specific metrics*, which aim to measure model performance on specific benchmarks: for instance, the [GLUE benchmark](https://huggingface.co/datasets/glue) has a dedicated [evaluation metric](https://huggingface.co/metrics/glue).\n\nLet's look at each of these three cases:\n\n### Generic metrics\n\nMany of the metrics used in the Machine Learning community are quite generic and can be applied in a variety of tasks and datasets.\n\nThis is the case for metrics like [accuracy](https://huggingface.co/metrics/accuracy) and [precision](https://huggingface.co/metrics/precision), which can be used for evaluating labeled (supervised) datasets, as well as [perplexity](https://huggingface.co/metrics/perplexity), which can be used for evaluating different kinds of (unsupervised) generative tasks.\n\nTo see the input structure of a given metric, you can look at its metric card. For example, in the case of [precision](https://huggingface.co/metrics/precision), the format is:\n```\n>>> precision_metric = evaluate.load(\"precision\")\n>>> results = precision_metric.compute(references=[0, 1], predictions=[0, 1])\n>>> print(results)\n{'precision': 1.0}\n```\n\n### Task-specific metrics\n\nPopular ML tasks like Machine Translation and Named Entity Recognition have specific metrics that can be used to compare models. For example, a series of different metrics have been proposed for text generation, ranging from [BLEU](https://huggingface.co/metrics/bleu) and its derivatives such as [GoogleBLEU](https://huggingface.co/metrics/google_bleu) and [GLEU](https://huggingface.co/metrics/gleu), but also [ROUGE](https://huggingface.co/metrics/rouge), [MAUVE](https://huggingface.co/metrics/mauve), etc.\n\nYou can find the right metric for your task by:\n\n- **Looking at the [Task pages](https://huggingface.co/tasks)** to see what metrics can be used for evaluating models for a given task.\n- **Checking out leaderboards** on sites like [Papers With Code](https://paperswithcode.com/) (you can search by task and by dataset).\n-  **Reading the metric cards** for the relevant metrics and see which ones are a good fit for your use case. For example, see the [BLEU metric card](https://github.com/huggingface/evaluate/tree/main/metrics/bleu) or [SQuaD metric card](https://github.com/huggingface/evaluate/tree/main/metrics/squad).\n- **Looking at papers and blog posts** published on the topic and see what metrics they report. This can change over time, so try to pick papers from the last couple of years!\n\n### Dataset-specific metrics\n\nSome datasets have specific metrics associated with them -- this is especially in the case of popular benchmarks like [GLUE](https://huggingface.co/metrics/glue) and [SQuAD](https://huggingface.co/metrics/squad).\n\n<Tip warning={true}>\n\ud83d\udca1\nGLUE is actually a collection of different subsets on different tasks, so first you need to choose the one that corresponds to the NLI task, such as mnli, which is described as \u201ccrowdsourced collection of sentence pairs with textual entailment annotations\u201d\n</Tip>\n\n\nIf you are evaluating your model on a benchmark dataset like the ones mentioned above, you can use its dedicated evaluation metric. Make sure you respect the format that they require. For example, to evaluate your model on the [SQuAD](https://huggingface.co/datasets/squad) dataset, you need to feed the `question` and `context` into your model and return the `prediction_text`, which should be compared with the `references` (based on matching the `id` of the question) :\n\n```\n>>> from evaluate import load\n>>> squad_metric = load(\"squad\")\n>>> predictions = [{'prediction_text': '1976', 'id': '56e10a3be3433e1400422b22'}]\n>>> references = [{'answers': {'answer_start': [97], 'text': ['1976']}, 'id': '56e10a3be3433e1400422b22'}]\n>>> results = squad_metric.compute(predictions=predictions, references=references)\n>>> results\n{'exact_match': 100.0, 'f1': 100.0}\n```\n\nYou can find examples of dataset structures by consulting the \"Dataset Preview\" function or the dataset card for a given dataset, and you can see how to use its dedicated evaluation function based on the metric card.\n--New Chunk--\n[Created at: 2025-03-24 13:19:17]\n!---\nCopyright 2022 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n-->\n\n# Token classification with LayoutLMv3 (PyTorch version)\n\nThis directory contains a script, `run_funsd_cord.py`, that can be used to fine-tune (or evaluate) LayoutLMv3 on form understanding datasets, such as [FUNSD](https://guillaumejaume.github.io/FUNSD/) and [CORD](https://github.com/clovaai/cord).\n\nThe script `run_funsd_cord.py` leverages the \ud83e\udd17 Datasets library and the Trainer API. You can easily customize it to your needs.\n\n## Fine-tuning on FUNSD\n\nFine-tuning LayoutLMv3 for token classification on [FUNSD](https://guillaumejaume.github.io/FUNSD/) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name funsd \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 1e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-funsd\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd. By specifying the `push_to_hub` flag, the model gets uploaded automatically to the hub (regularly), together with a model card, which includes metrics such as precision, recall and F1. Note that you can easily update the model card, as it's just a README file of the respective repo on the hub.\n\nThere's also the \"Training metrics\" [tab](https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd/tensorboard), which shows Tensorboard logs over the course of training. Pretty neat, huh?\n\n## Fine-tuning on CORD\n\nFine-tuning LayoutLMv3 for token classification on [CORD](https://github.com/clovaai/cord) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name cord \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 5e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-cord\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-cord. Note that a model card gets generated automatically in case you specify the `push_to_hub` flag.\n--New Chunk--\n[Created at: 2025-03-24 13:16:13]\n=predictions, references=references)\n>>> results\n{'exact_match': 100.0, 'f1': 100.0}\n```\n\nYou can find examples of dataset structures by consulting the \"Dataset Preview\" function or the dataset card for a given dataset, and you can see how to use its dedicated evaluation function based on the metric card."
        }
    },
    {
        "sample_idx": 15,
        "question": "Where can I find the right metric for my task?",
        "answer": "You can find the right metric for your task by looking at the Task pages, checking out leaderboards, reading the metric cards, and looking at papers and blog posts published on the topic.",
        "rag_answer": "To find the right metric for your task, you can follow these guidelines:\n\n### Generic Metrics\n\nFor generic metrics, you can look at the metric card for a given metric, such as [accuracy](https://huggingface.co/metrics/accuracy) or [precision](https://huggingface.co/metrics/precision). These metrics can be applied to a variety of tasks and datasets.\n\n### Task-Specific Metrics\n\nFor task-specific metrics, you can:\n\n* **Look at the Task pages** to see what metrics can be used for evaluating models for a given task.\n* **Check out leaderboards** on sites like [Papers With Code](https://paperswithcode.com/) (you can search by task and by dataset).\n* **Read the metric cards** for the relevant metrics and see which ones are a good fit for your use case. For example, see the [BLEU metric card](https://github.com/huggingface/evaluate/tree/main/metrics/bleu) or [SQuaD metric card](https://github.com/huggingface/evaluate/tree/main/metrics/squad).\n* **Look at papers and blog posts** published on the topic and see what metrics they report. This can change over time, so try to pick papers from the last couple of years!\n\n### Dataset-Specific Metrics\n\nFor dataset-specific metrics, you can:\n\n* **Check the dataset card** for a given dataset, such as [SQuAD](https://huggingface.co/datasets/squad) or [GLUE](https://huggingface.co/datasets/glue).\n* **Look at the metric card** for the dataset-specific metric, such as [SQuAD metric card](https://github.com/huggingface/evaluate/tree/main/metrics/squad) or [GLUE metric card](https://github.com/huggingface/evaluate/tree/main/metrics/glue).\n\nReferences:\n[DC] Choosing a metric for your task\n[KG] Machine Learning, accuracy, precision, perplexity",
        "rag_score": 5,
        "rag_feedback": "The system's response is completely correct, accurate, and factual. It provides a detailed and structured answer that matches the expected answer. The response covers all the necessary points, including looking at task pages, checking out leaderboards, reading metric cards, and looking at papers and blog posts published on the topic. The system's response is well-organized, easy to follow, and provides relevant examples and references.",
        "rag_context": {
            "kg_context": "-----Entities-----\n    ```csv\n    id,\tentity,\ttype,\tdescription,\trankcreated_at\n1,\tMachine Learning,category,Machine Learning is a field of study that involves training models to make predictions.,5,2025-03-24 13:16:48\n2,\taccuracy,category,accuracy is a category of evaluation metrics for machine learning models.,1,2025-03-24 13:16:48\n3,\tprecision,category,precision is a category of evaluation metrics for machine learning models.,1,2025-03-24 13:16:48\n4,\tperplexity,category,perplexity is a category of evaluation metrics for machine learning models.,1,2025-03-24 13:16:48\n5,\tResults,event,Results are the outcome of evaluating a model, in this case, showing perfect accuracy.,1,UNKNOWN\n6,\taccuracy,category,accuracy is a category of evaluation metrics for machine learning models.,1,UNKNOWN\n7,\tprecision,category,precision is a category of evaluation metrics for machine learning models.,1,UNKNOWN\n    ```\n    -----Relationships-----\n    ```csv\n    id,\tsource,\ttarget,\tdescription,\tkeywords,\tweight,\trank,\tcreated_at\n1,\tMachine Learning,accuracy,accuracy is a metric used to evaluate machine learning models.,evaluation metric, task,9.0,6,2025-03-24 13:16:48\n2,\tMachine Learning,precision,precision is a metric used to evaluate machine learning models.,evaluation metric, task,9.0,6,2025-03-24 13:16:48\n3,\tMachine Learning,perplexity,perplexity is a metric used to evaluate machine learning models.,evaluation metric, task,9.0,6,2025-03-24 13:16:48\n4,\tMachine Learning,accuracy,accuracy is a metric used to evaluate machine learning models.,evaluation metric, task,9.0,6,UNKNOWN\n5,\tMachine Learning,precision,precision is a metric used to evaluate machine learning models.,evaluation metric, task,9.0,6,UNKNOWN\n6,\tEvaluation Function,Results,The results are obtained by using the evaluation function.,evaluation outcome, accuracy,20.0,3,UNKNOWN\n    ```\n    -----Sources-----\n    ```csv\n    id,\tcontent\n1,\tChoosing a metric for your task\n\n**So you've trained your model and want to see how well it\u2019s doing on a dataset of your choice. Where do you start?**\n\nThere is no \u201cone size fits all\u201d approach to choosing an evaluation metric, but some good guidelines to keep in mind are:\n\n## Categories of metrics\n\nThere are 3 high-level categories of metrics:\n\n1. *Generic metrics*, which can be applied to a variety of situations and datasets, such as precision and accuracy.\n2. *Task-specific metrics*, which are limited to a given task, such as Machine Translation (often evaluated using metrics [BLEU](https://huggingface.co/metrics/bleu) or [ROUGE](https://huggingface.co/metrics/rouge)) or Named Entity Recognition (often evaluated with [seqeval](https://huggingface.co/metrics/seqeval)).\n3. *Dataset-specific metrics*, which aim to measure model performance on specific benchmarks: for instance, the [GLUE benchmark](https://huggingface.co/datasets/glue) has a dedicated [evaluation metric](https://huggingface.co/metrics/glue).\n\nLet's look at each of these three cases:\n\n### Generic metrics\n\nMany of the metrics used in the Machine Learning community are quite generic and can be applied in a variety of tasks and datasets.\n\nThis is the case for metrics like [accuracy](https://huggingface.co/metrics/accuracy) and [precision](https://huggingface.co/metrics/precision), which can be used for evaluating labeled (supervised) datasets, as well as [perplexity](https://huggingface.co/metrics/perplexity), which can be used for evaluating different kinds of (unsupervised) generative tasks.\n\nTo see the input structure of a given metric, you can look at its metric card. For example, in the case of [precision](https://huggingface.co/metrics/precision), the format is:\n```\n>>> precision_metric = evaluate.load(\"precision\")\n>>> results = precision_metric.compute(references=[0, 1], predictions=[0, 1])\n>>> print(results)\n{'precision': 1.0}\n```\n\n### Task-specific metrics\n\nPopular ML tasks like Machine Translation and Named Entity Recognition have specific metrics that can be used to compare models. For example, a series of different metrics have been proposed for text generation, ranging from [BLEU](https://huggingface.co/metrics/bleu) and its derivatives such as [GoogleBLEU](https://huggingface.co/metrics/google_bleu) and [GLEU](https://huggingface.co/metrics/gleu), but also [ROUGE](https://huggingface.co/metrics/rouge), [MAUVE](https://huggingface.co/metrics/mauve), etc.\n\nYou can find the right metric for your task by:\n\n- **Looking at the [Task pages](https://huggingface.co/tasks)** to see what metrics can be used for evaluating models for a given task.\n- **Checking out leaderboards** on sites like [Papers With Code](https://paperswithcode.com/) (you can search by task and by dataset).\n-  **Reading the metric cards** for the relevant metrics and see which ones are a good fit for your use case. For example, see the [BLEU metric card](https://github.com/huggingface/evaluate/tree/main/metrics/bleu) or [SQuaD metric card](https://github.com/huggingface/evaluate/tree/main/metrics/squad).\n- **Looking at papers and blog posts** published on the topic and see what metrics they report. This can change over time, so try to pick papers from the last couple of years!\n\n### Dataset-specific metrics\n\nSome datasets have specific metrics associated with them -- this is especially in the case of popular benchmarks like [GLUE](https://huggingface.co/metrics/glue) and [SQuAD](https://huggingface.co/metrics/squad).\n\n<Tip warning={true}>\n\ud83d\udca1\nGLUE is actually a collection of different subsets on different tasks, so first you need to choose the one that corresponds to the NLI task, such as mnli, which is described as \u201ccrowdsourced collection of sentence pairs with textual entailment annotations\u201d\n</Tip>\n\n\nIf you are evaluating your model on a benchmark dataset like the ones mentioned above, you can use its dedicated evaluation metric. Make sure you respect the format that they require. For example, to evaluate your model on the [SQuAD](https://huggingface.co/datasets/squad) dataset, you need to feed the `question` and `context` into your model and return the `prediction_text`, which should be compared with the `references` (based on matching the `id` of the question) :\n\n```\n>>> from evaluate import load\n>>> squad_metric = load(\"squad\")\n>>> predictions = [{'prediction_text': '1976', 'id': '56e10a3be3433e1400422b22'}]\n>>> references = [{'answers': {'answer_start': [97], 'text': ['1976']}, 'id': '56e10a3be3433e1400422b22'}]\n>>> results = squad_metric.compute(predictions=predictions, references=references)\n>>> results\n{'exact_match': 100.0, 'f1': 100.0}\n```\n\nYou can find examples of dataset structures by consulting the \"Dataset Preview\" function or the dataset card for a given dataset, and you can see how to use its dedicated evaluation function based on the metric card.\n2,\t=predictions, references=references)\n>>> results\n{'exact_match': 100.0, 'f1': 100.0}\n```\n\nYou can find examples of dataset structures by consulting the \"Dataset Preview\" function or the dataset card for a given dataset, and you can see how to use its dedicated evaluation function based on the metric card.\n    ```",
            "vector_context": "[Created at: 2025-03-24 13:16:13]\nChoosing a metric for your task\n\n**So you've trained your model and want to see how well it\u2019s doing on a dataset of your choice. Where do you start?**\n\nThere is no \u201cone size fits all\u201d approach to choosing an evaluation metric, but some good guidelines to keep in mind are:\n\n## Categories of metrics\n\nThere are 3 high-level categories of metrics:\n\n1. *Generic metrics*, which can be applied to a variety of situations and datasets, such as precision and accuracy.\n2. *Task-specific metrics*, which are limited to a given task, such as Machine Translation (often evaluated using metrics [BLEU](https://huggingface.co/metrics/bleu) or [ROUGE](https://huggingface.co/metrics/rouge)) or Named Entity Recognition (often evaluated with [seqeval](https://huggingface.co/metrics/seqeval)).\n3. *Dataset-specific metrics*, which aim to measure model performance on specific benchmarks: for instance, the [GLUE benchmark](https://huggingface.co/datasets/glue) has a dedicated [evaluation metric](https://huggingface.co/metrics/glue).\n\nLet's look at each of these three cases:\n\n### Generic metrics\n\nMany of the metrics used in the Machine Learning community are quite generic and can be applied in a variety of tasks and datasets.\n\nThis is the case for metrics like [accuracy](https://huggingface.co/metrics/accuracy) and [precision](https://huggingface.co/metrics/precision), which can be used for evaluating labeled (supervised) datasets, as well as [perplexity](https://huggingface.co/metrics/perplexity), which can be used for evaluating different kinds of (unsupervised) generative tasks.\n\nTo see the input structure of a given metric, you can look at its metric card. For example, in the case of [precision](https://huggingface.co/metrics/precision), the format is:\n```\n>>> precision_metric = evaluate.load(\"precision\")\n>>> results = precision_metric.compute(references=[0, 1], predictions=[0, 1])\n>>> print(results)\n{'precision': 1.0}\n```\n\n### Task-specific metrics\n\nPopular ML tasks like Machine Translation and Named Entity Recognition have specific metrics that can be used to compare models. For example, a series of different metrics have been proposed for text generation, ranging from [BLEU](https://huggingface.co/metrics/bleu) and its derivatives such as [GoogleBLEU](https://huggingface.co/metrics/google_bleu) and [GLEU](https://huggingface.co/metrics/gleu), but also [ROUGE](https://huggingface.co/metrics/rouge), [MAUVE](https://huggingface.co/metrics/mauve), etc.\n\nYou can find the right metric for your task by:\n\n- **Looking at the [Task pages](https://huggingface.co/tasks)** to see what metrics can be used for evaluating models for a given task.\n- **Checking out leaderboards** on sites like [Papers With Code](https://paperswithcode.com/) (you can search by task and by dataset).\n-  **Reading the metric cards** for the relevant metrics and see which ones are a good fit for your use case. For example, see the [BLEU metric card](https://github.com/huggingface/evaluate/tree/main/metrics/bleu) or [SQuaD metric card](https://github.com/huggingface/evaluate/tree/main/metrics/squad).\n- **Looking at papers and blog posts** published on the topic and see what metrics they report. This can change over time, so try to pick papers from the last couple of years!\n\n### Dataset-specific metrics\n\nSome datasets have specific metrics associated with them -- this is especially in the case of popular benchmarks like [GLUE](https://huggingface.co/metrics/glue) and [SQuAD](https://huggingface.co/metrics/squad).\n\n<Tip warning={true}>\n\ud83d\udca1\nGLUE is actually a collection of different subsets on different tasks, so first you need to choose the one that corresponds to the NLI task, such as mnli, which is described as \u201ccrowdsourced collection of sentence pairs with textual entailment annotations\u201d\n</Tip>\n\n\nIf you are evaluating your model on a benchmark dataset like the ones mentioned above, you can use its dedicated evaluation metric. Make sure you respect the format that they require. For example, to evaluate your model on the [SQuAD](https://huggingface.co/datasets/squad) dataset, you need to feed the `question` and `context` into your model and return the `prediction_text`, which should be compared with the `references` (based on matching the `id` of the question) :\n\n```\n>>> from evaluate import load\n>>> squad_metric = load(\"squad\")\n>>> predictions = [{'prediction_text': '1976', 'id': '56e10a3be3433e1400422b22'}]\n>>> references = [{'answers': {'answer_start': [97], 'text': ['1976']}, 'id': '56e10a3be3433e1400422b22'}]\n>>> results = squad_metric.compute(predictions=predictions, references=references)\n>>> results\n{'exact_match': 100.0, 'f1': 100.0}\n```\n\nYou can find examples of dataset structures by consulting the \"Dataset Preview\" function or the dataset card for a given dataset, and you can see how to use its dedicated evaluation function based on the metric card.\n--New Chunk--\n[Created at: 2025-03-24 13:16:13]\n=predictions, references=references)\n>>> results\n{'exact_match': 100.0, 'f1': 100.0}\n```\n\nYou can find examples of dataset structures by consulting the \"Dataset Preview\" function or the dataset card for a given dataset, and you can see how to use its dedicated evaluation function based on the metric card.\n--New Chunk--\n[Created at: 2025-03-24 13:19:17]\n!---\nCopyright 2022 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n-->\n\n# Token classification with LayoutLMv3 (PyTorch version)\n\nThis directory contains a script, `run_funsd_cord.py`, that can be used to fine-tune (or evaluate) LayoutLMv3 on form understanding datasets, such as [FUNSD](https://guillaumejaume.github.io/FUNSD/) and [CORD](https://github.com/clovaai/cord).\n\nThe script `run_funsd_cord.py` leverages the \ud83e\udd17 Datasets library and the Trainer API. You can easily customize it to your needs.\n\n## Fine-tuning on FUNSD\n\nFine-tuning LayoutLMv3 for token classification on [FUNSD](https://guillaumejaume.github.io/FUNSD/) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name funsd \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 1e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-funsd\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd. By specifying the `push_to_hub` flag, the model gets uploaded automatically to the hub (regularly), together with a model card, which includes metrics such as precision, recall and F1. Note that you can easily update the model card, as it's just a README file of the respective repo on the hub.\n\nThere's also the \"Training metrics\" [tab](https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd/tensorboard), which shows Tensorboard logs over the course of training. Pretty neat, huh?\n\n## Fine-tuning on CORD\n\nFine-tuning LayoutLMv3 for token classification on [CORD](https://github.com/clovaai/cord) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name cord \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 5e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-cord\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-cord. Note that a model card gets generated automatically in case you specify the `push_to_hub` flag."
        }
    },
    {
        "sample_idx": 16,
        "question": "What is GLUE?",
        "answer": "GLUE is a collection of different subsets on different tasks.",
        "rag_answer": "**What is GLUE?**\n\nGLUE (General Language Understanding Evaluation) is a benchmark dataset for evaluating natural language processing (NLP) models. It is a collection of different subsets on different tasks, aiming to measure model performance on various NLP tasks. GLUE has a dedicated evaluation metric, which is used to compare the performance of different models on these tasks.\n\nGLUE is a popular benchmark dataset in the NLP community, and it provides a standardized way to evaluate the performance of NLP models. It consists of nine different tasks, including question-answering, sentiment analysis, and textual entailment, among others.\n\n**References:**\n\n[KG] GLUE, dataset, GLUE is a benchmark dataset for evaluating natural language processing models.\n[DC] Choosing a metric for your task, Categories of metrics, Dataset-specific metrics.",
        "rag_score": 5,
        "rag_feedback": "The system's response is completely correct, accurate, and factual. It provides a detailed and informative answer to the question, including the definition of GLUE and its purpose. The response also includes additional relevant information about the GLUE benchmark dataset and its evaluation metric.",
        "rag_context": {
            "kg_context": "-----Entities-----\n    ```csv\n    id,\tentity,\ttype,\tdescription,\trankcreated_at\n1,\tMachine Learning,category,Machine Learning is a field of study that involves training models to make predictions.,5,2025-03-24 13:16:48\n2,\tModel,category,Model refers to a machine learning model being evaluated.,3,2025-03-24 13:16:48\n3,\tBLEU,category,BLEU is a category of evaluation metrics for machine translation tasks.,1,2025-03-24 13:16:48\n4,\tMachine Translation,event,Machine Translation is an event or task in natural language processing.,3,2025-03-24 13:16:48\n5,\tGLEU,category,GLEU is a category of evaluation metrics for machine translation tasks.,1,2025-03-24 13:16:48\n6,\tGLUE,dataset,GLUE is a benchmark dataset for evaluating natural language processing models.,1,UNKNOWN\n7,\tSQuAD,dataset,SQuAD is a benchmark dataset for evaluating question answering models.,1,UNKNOWN\n8,\tGoogleBLEU,category,GoogleBLEU is a category of evaluation metrics for machine translation tasks.,1,UNKNOWN\n    ```\n    -----Relationships-----\n    ```csv\n    id,\tsource,\ttarget,\tdescription,\tkeywords,\tweight,\trank,\tcreated_at\n1,\tMachine Learning,Model,Machine Learning involves training models to make predictions.,field of study, model training,9.0,8,2025-03-24 13:16:48\n2,\tBLEU,Machine Translation,BLEU is a metric used to evaluate machine translation models.,evaluation metric, task,18.0,4,2025-03-24 13:16:48\n3,\tGLEU,Machine Translation,GLEU is a metric used to evaluate machine translation models.,evaluation metric, task,9.0,4,2025-03-24 13:16:48\n4,\tGLUE,Hugging Face,Hugging Face provides a platform for evaluating models on the GLUE benchmark dataset.,evaluation platform, benchmark dataset,16.0,9,UNKNOWN\n5,\tHugging Face,SQuAD,Hugging Face provides a platform for evaluating models on the SQuAD benchmark dataset.,evaluation platform, benchmark dataset,16.0,9,UNKNOWN\n6,\tGoogleBLEU,Machine Translation,GoogleBLEU is a metric used to evaluate machine translation models.,evaluation metric, task,9.0,4,UNKNOWN\n    ```\n    -----Sources-----\n    ```csv\n    id,\tcontent\n1,\t=predictions, references=references)\n>>> results\n{'exact_match': 100.0, 'f1': 100.0}\n```\n\nYou can find examples of dataset structures by consulting the \"Dataset Preview\" function or the dataset card for a given dataset, and you can see how to use its dedicated evaluation function based on the metric card.\n2,\tChoosing a metric for your task\n\n**So you've trained your model and want to see how well it\u2019s doing on a dataset of your choice. Where do you start?**\n\nThere is no \u201cone size fits all\u201d approach to choosing an evaluation metric, but some good guidelines to keep in mind are:\n\n## Categories of metrics\n\nThere are 3 high-level categories of metrics:\n\n1. *Generic metrics*, which can be applied to a variety of situations and datasets, such as precision and accuracy.\n2. *Task-specific metrics*, which are limited to a given task, such as Machine Translation (often evaluated using metrics [BLEU](https://huggingface.co/metrics/bleu) or [ROUGE](https://huggingface.co/metrics/rouge)) or Named Entity Recognition (often evaluated with [seqeval](https://huggingface.co/metrics/seqeval)).\n3. *Dataset-specific metrics*, which aim to measure model performance on specific benchmarks: for instance, the [GLUE benchmark](https://huggingface.co/datasets/glue) has a dedicated [evaluation metric](https://huggingface.co/metrics/glue).\n\nLet's look at each of these three cases:\n\n### Generic metrics\n\nMany of the metrics used in the Machine Learning community are quite generic and can be applied in a variety of tasks and datasets.\n\nThis is the case for metrics like [accuracy](https://huggingface.co/metrics/accuracy) and [precision](https://huggingface.co/metrics/precision), which can be used for evaluating labeled (supervised) datasets, as well as [perplexity](https://huggingface.co/metrics/perplexity), which can be used for evaluating different kinds of (unsupervised) generative tasks.\n\nTo see the input structure of a given metric, you can look at its metric card. For example, in the case of [precision](https://huggingface.co/metrics/precision), the format is:\n```\n>>> precision_metric = evaluate.load(\"precision\")\n>>> results = precision_metric.compute(references=[0, 1], predictions=[0, 1])\n>>> print(results)\n{'precision': 1.0}\n```\n\n### Task-specific metrics\n\nPopular ML tasks like Machine Translation and Named Entity Recognition have specific metrics that can be used to compare models. For example, a series of different metrics have been proposed for text generation, ranging from [BLEU](https://huggingface.co/metrics/bleu) and its derivatives such as [GoogleBLEU](https://huggingface.co/metrics/google_bleu) and [GLEU](https://huggingface.co/metrics/gleu), but also [ROUGE](https://huggingface.co/metrics/rouge), [MAUVE](https://huggingface.co/metrics/mauve), etc.\n\nYou can find the right metric for your task by:\n\n- **Looking at the [Task pages](https://huggingface.co/tasks)** to see what metrics can be used for evaluating models for a given task.\n- **Checking out leaderboards** on sites like [Papers With Code](https://paperswithcode.com/) (you can search by task and by dataset).\n-  **Reading the metric cards** for the relevant metrics and see which ones are a good fit for your use case. For example, see the [BLEU metric card](https://github.com/huggingface/evaluate/tree/main/metrics/bleu) or [SQuaD metric card](https://github.com/huggingface/evaluate/tree/main/metrics/squad).\n- **Looking at papers and blog posts** published on the topic and see what metrics they report. This can change over time, so try to pick papers from the last couple of years!\n\n### Dataset-specific metrics\n\nSome datasets have specific metrics associated with them -- this is especially in the case of popular benchmarks like [GLUE](https://huggingface.co/metrics/glue) and [SQuAD](https://huggingface.co/metrics/squad).\n\n<Tip warning={true}>\n\ud83d\udca1\nGLUE is actually a collection of different subsets on different tasks, so first you need to choose the one that corresponds to the NLI task, such as mnli, which is described as \u201ccrowdsourced collection of sentence pairs with textual entailment annotations\u201d\n</Tip>\n\n\nIf you are evaluating your model on a benchmark dataset like the ones mentioned above, you can use its dedicated evaluation metric. Make sure you respect the format that they require. For example, to evaluate your model on the [SQuAD](https://huggingface.co/datasets/squad) dataset, you need to feed the `question` and `context` into your model and return the `prediction_text`, which should be compared with the `references` (based on matching the `id` of the question) :\n\n```\n>>> from evaluate import load\n>>> squad_metric = load(\"squad\")\n>>> predictions = [{'prediction_text': '1976', 'id': '56e10a3be3433e1400422b22'}]\n>>> references = [{'answers': {'answer_start': [97], 'text': ['1976']}, 'id': '56e10a3be3433e1400422b22'}]\n>>> results = squad_metric.compute(predictions=predictions, references=references)\n>>> results\n{'exact_match': 100.0, 'f1': 100.0}\n```\n\nYou can find examples of dataset structures by consulting the \"Dataset Preview\" function or the dataset card for a given dataset, and you can see how to use its dedicated evaluation function based on the metric card.\n    ```",
            "vector_context": "[Created at: 2025-03-24 13:16:48]\n\u4e0e\u5e38\u89c4\u51fd\u6570\u76f8\u540c\u7684\u65b9\u5f0f\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio\u3002\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\uff08\u865a\u62df\u7684\uff09\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5b83\u5728\u8f93\u51fa\u56fe\u50cf\u4e4b\u524d\u751f\u6210\u6570\u4e2a\u6b65\u9aa4\u7684\u566a\u97f3\uff1a\n\n$code_fake_diffusion\n$demo_fake_diffusion\n\n\u8bf7\u6ce8\u610f\uff0c\u6211\u4eec\u5728\u8fed\u4ee3\u5668\u4e2d\u6dfb\u52a0\u4e86 `time.sleep(1)`\uff0c\u4ee5\u521b\u5efa\u6b65\u9aa4\u4e4b\u95f4\u7684\u4eba\u5de5\u6682\u505c\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u89c2\u5bdf\u8fed\u4ee3\u5668\u7684\u6b65\u9aa4\uff08\u5728\u771f\u5b9e\u7684\u56fe\u50cf\u751f\u6210\u6a21\u578b\u4e2d\uff0c\u8fd9\u53ef\u80fd\u662f\u4e0d\u5fc5\u8981\u7684\uff09\u3002\n\n\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio **\u9700\u8981**\u5728\u5e95\u5c42 Interface \u6216 Blocks \u4e2d\u542f\u7528\u961f\u5217\uff08\u8bf7\u53c2\u9605\u4e0a\u9762\u7684\u961f\u5217\u90e8\u5206\uff09\u3002\n\n## \u8fdb\u5ea6\u6761\n\nGradio \u652f\u6301\u521b\u5efa\u81ea\u5b9a\u4e49\u8fdb\u5ea6\u6761\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u81ea\u5b9a\u4e49\u548c\u63a7\u5236\u5411\u7528\u6237\u663e\u793a\u7684\u8fdb\u5ea6\u66f4\u65b0\u3002\u8981\u542f\u7528\u6b64\u529f\u80fd\uff0c\u53ea\u9700\u4e3a\u65b9\u6cd5\u6dfb\u52a0\u4e00\u4e2a\u9ed8\u8ba4\u503c\u4e3a `gr.Progress` \u5b9e\u4f8b\u7684\u53c2\u6570\u5373\u53ef\u3002\u7136\u540e\uff0c\u60a8\u53ef\u4ee5\u76f4\u63a5\u8c03\u7528\u6b64\u5b9e\u4f8b\u5e76\u4f20\u5165 0 \u5230 1 \u4e4b\u95f4\u7684\u6d6e\u70b9\u6570\u6765\u66f4\u65b0\u8fdb\u5ea6\u7ea7\u522b\uff0c\u6216\u8005 with `Progress` \u5b9e\u4f8b\u7684 `tqdm()` \u65b9\u6cd5\u6765\u8ddf\u8e2a\u53ef\u8fed\u4ee3\u5bf9\u8c61\u4e0a\u7684\u8fdb\u5ea6\uff0c\u5982\u4e0b\u6240\u793a\u3002\u5fc5\u987b\u542f\u7528\u961f\u5217\u4ee5\u8fdb\u884c\u8fdb\u5ea6\u66f4\u65b0\u3002\n\n$code_progress_simple\n$demo_progress_simple\n\n\u5982\u679c\u60a8 with `tqdm` \u5e93\uff0c\u5e76\u4e14\u5e0c\u671b\u4ece\u51fd\u6570\u5185\u90e8\u7684\u4efb\u4f55 `tqdm.tqdm` \u81ea\u52a8\u62a5\u544a\u8fdb\u5ea6\u66f4\u65b0\uff0c\u8bf7\u5c06\u9ed8\u8ba4\u53c2\u6570\u8bbe\u7f6e\u4e3a `gr.Progress(track_tqdm=True)`\uff01\n\n## \u6279\u5904\u7406\u51fd\u6570 (Batch Functions)\n\nGradio \u652f\u6301\u4f20\u9012*\u6279\u5904\u7406*\u51fd\u6570\u3002\u6279\u5904\u7406\u51fd\u6570\u53ea\u662f\u63a5\u53d7\u8f93\u5165\u5217\u8868\u5e76\u8fd4\u56de\u9884\u6d4b\u5217\u8868\u7684\u51fd\u6570\u3002\n\n\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\u6279\u5904\u7406\u51fd\u6570\uff0c\u5b83\u63a5\u53d7\u4e24\u4e2a\u8f93\u5165\u5217\u8868\uff08\u4e00\u4e2a\u5355\u8bcd\u5217\u8868\u548c\u4e00\u4e2a\u6574\u6570\u5217\u8868\uff09\uff0c\u5e76\u8fd4\u56de\u4fee\u526a\u8fc7\u7684\u5355\u8bcd\u5217\u8868\u4f5c\u4e3a\u8f93\u51fa\uff1a\n\n```python\nimport time\n\ndef trim_words(words, lens):\n    trimmed_words = []\n    time.sleep(5)\n    for w, l in zip(words, lens):\n        trimmed_words.append(w[:int(l)])\n    return [trimmed_words]\n    for w, l in zip(words, lens):\n```\n\n\u4f7f\u7528\u6279\u5904\u7406\u51fd\u6570\u7684\u4f18\u70b9\u662f\uff0c\u5982\u679c\u542f\u7528\u4e86\u961f\u5217\uff0cGradio \u670d\u52a1\u5668\u53ef\u4ee5\u81ea\u52a8*\u6279\u5904\u7406*\u4f20\u5165\u7684\u8bf7\u6c42\u5e76\u5e76\u884c\u5904\u7406\u5b83\u4eec\uff0c\u4ece\u800c\u53ef\u80fd\u52a0\u5feb\u6f14\u793a\u901f\u5ea6\u3002\u4ee5\u4e0b\u662f Gradio \u4ee3\u7801\u7684\u793a\u4f8b\uff08\u8bf7\u6ce8\u610f `batch=True` \u548c `max_batch_size=16` - \u8fd9\u4e24\u4e2a\u53c2\u6570\u90fd\u53ef\u4ee5\u4f20\u9012\u7ed9\u4e8b\u4ef6\u89e6\u53d1\u5668\u6216 `Interface` \u7c7b\uff09\n\nwith `Interface`\uff1a\n\n```python\ndemo = gr.Interface(trim_words, [\"textbox\", \"number\"], [\"output\"],\n                    batch=True, max_batch_size=16)\ndemo.queue()\ndemo.launch()\n```\n\nwith `Blocks`\uff1a\n\n```python\nimport gradio as gr\n\nwith gr.Blocks() as demo:\n    with gr.Row():\n        word = gr.Textbox(label=\"word\")\n        leng = gr.Number(label=\"leng\")\n        output = gr.Textbox(label=\"Output\")\n    with gr.Row():\n        run = gr.Button()\n\n    event = run.click(trim_words, [word, leng], output, batch=True, max_batch_size=16)\n\ndemo.queue()\ndemo.launch()\n```\n\n\u5728\u4e0a\u9762\u7684\u793a\u4f8b\u4e2d\uff0c\u53ef\u4ee5\u5e76\u884c\u5904\u7406 16 \u4e2a\u8bf7\u6c42\uff08\u603b\u63a8\u7406\u65f6\u95f4\u4e3a 5 \u79d2\uff09\uff0c\u800c\u4e0d\u662f\u5206\u522b\u5904\u7406\u6bcf\u4e2a\u8bf7\u6c42\uff08\u603b\u63a8\u7406\u65f6\u95f4\u4e3a 80 \u79d2\uff09\u3002\u8bb8\u591a Hugging Face \u7684 `transformers` \u548c `diffusers` \u6a21\u578b\u5728 Gradio \u7684\u6279\u5904\u7406\u6a21\u5f0f\u4e0b\u81ea\u7136\u5de5\u4f5c\uff1a\u8fd9\u662f[\u4f7f\u7528\u6279\u5904\u7406\u751f\u6210\u56fe\u50cf\u7684\u793a\u4f8b\u6f14\u793a](https://github.com/gradio-app/gradio/blob/main/demo/diffusers_with_batching/run.py)\n\n\u6ce8\u610f\uff1a\u4f7f\u7528 Gradio \u7684\u6279\u5904\u7406\u51fd\u6570 **requires** \u5728\u5e95\u5c42 Interface \u6216 Blocks \u4e2d\u542f\u7528\u961f\u5217\uff08\u8bf7\u53c2\u9605\u4e0a\u9762\u7684\u961f\u5217\u90e8\u5206\uff09\u3002\n\n## Gradio \u7b14\u8bb0\u672c (Colab Notebooks)\n\nGradio \u53ef\u4ee5\u5728\u4efb\u4f55\u8fd0\u884c Python \u7684\u5730\u65b9\u8fd0\u884c\uff0c\u5305\u62ec\u672c\u5730 Jupyter \u7b14\u8bb0\u672c\u548c\u534f\u4f5c\u7b14\u8bb0\u672c\uff0c\u5982[Google Colab](https://colab.research.google.com/)\u3002\u5bf9\u4e8e\u672c\u5730 Jupyter \u7b14\u8bb0\u672c\u548c Google Colab \u7b14\u8bb0\u672c\uff0cGradio \u5728\u672c\u5730\u670d\u52a1\u5668\u4e0a\u8fd0\u884c\uff0c\u60a8\u53ef\u4ee5\u5728\u6d4f\u89c8\u5668\u4e2d\u4e0e\u4e4b\u4ea4\u4e92\u3002\uff08\u6ce8\u610f\uff1a\u5bf9\u4e8e Google Colab\uff0c\u8fd9\u662f\u901a\u8fc7[\u670d\u52a1\u5de5\u4f5c\u5668\u96a7\u9053](https://github.com/tensorflow/tensorboard/blob/master/docs/design/colab_integration.md)\u5b9e\u73b0\u7684\uff0c\u60a8\u7684\u6d4f\u89c8\u5668\u9700\u8981\u542f\u7528 cookies\u3002\uff09\u5bf9\u4e8e\u5176\u4ed6\u8fdc\u7a0b\u7b14\u8bb0\u672c\uff0cGradio \u4e5f\u5c06\u5728\u670d\u52a1\u5668\u4e0a\u8fd0\u884c\uff0c\u4f46\u60a8\u9700\u8981\u4f7f\u7528[SSH \u96a7\u9053](https://coderwall.com/p/ohk6cg/remote-access-to-ipython-notebooks-via-ssh)\u5728\u672c\u5730\u6d4f\u89c8\u5668\u4e2d\u67e5\u770b\u5e94\u7528\u7a0b\u5e8f\u3002\u901a\u5e38\uff0c\u66f4\u7b80\u5355\u7684\u9009\u62e9\u662f\u4f7f\u7528 Gradio \u5185\u7f6e\u7684\u516c\u5171\u94fe\u63a5\uff0c[\u5728\u4e0b\u4e00\u7bc7\u6307\u5357\u4e2d\u8ba8\u8bba](/sharing-your-app/#sharing-demos)\u3002\n--New Chunk--\n[Created at: 2025-03-24 13:16:48]\n\u65f6\u5fc5\u987b\u9009\u62e9\u5176\u4e2d\u4e00\u4e2a\u5b57\u7b26\u4e32\uff0c\u8fd9\u5c06\u4f5c\u4e3a\u9644\u52a0\u5217\u4fdd\u5b58\u5230 CSV \u4e2d\u3002\n\n## \u9884\u5904\u7406\u548c\u540e\u5904\u7406 (Preprocessing and Postprocessing)\n\n![annotated](/assets/img/dataflow.svg)\n\n\u5982\u60a8\u6240\u89c1\uff0cGradio \u5305\u62ec\u53ef\u4ee5\u5904\u7406\u5404\u79cd\u4e0d\u540c\u6570\u636e\u7c7b\u578b\u7684\u7ec4\u4ef6\uff0c\u4f8b\u5982\u56fe\u50cf\u3001\u97f3\u9891\u548c\u89c6\u9891\u3002\u5927\u591a\u6570\u7ec4\u4ef6\u90fd\u53ef\u4ee5\u7528\u4f5c\u8f93\u5165\u6216\u8f93\u51fa\u3002\n\n\u5f53\u7ec4\u4ef6\u7528\u4f5c\u8f93\u5165\u65f6\uff0cGradio \u81ea\u52a8\u5904\u7406*\u9884\u5904\u7406*\uff0c\u5c06\u6570\u636e\u4ece\u7528\u6237\u6d4f\u89c8\u5668\u53d1\u9001\u7684\u7c7b\u578b\uff08\u4f8b\u5982\u7f51\u7edc\u6444\u50cf\u5934\u5feb\u7167\u7684 base64 \u8868\u793a\uff09\u8f6c\u6362\u4e3a\u60a8\u7684\u51fd\u6570\u53ef\u4ee5\u63a5\u53d7\u7684\u5f62\u5f0f\uff08\u4f8b\u5982 `numpy` \u6570\u7ec4\uff09\u3002\n\n\u540c\u6837\uff0c\u5f53\u7ec4\u4ef6\u7528\u4f5c\u8f93\u51fa\u65f6\uff0cGradio \u81ea\u52a8\u5904\u7406*\u540e\u5904\u7406*\uff0c\u5c06\u6570\u636e\u4ece\u51fd\u6570\u8fd4\u56de\u7684\u5f62\u5f0f\uff08\u4f8b\u5982\u56fe\u50cf\u8def\u5f84\u5217\u8868\uff09\u8f6c\u6362\u4e3a\u53ef\u4ee5\u5728\u7528\u6237\u6d4f\u89c8\u5668\u4e2d\u663e\u793a\u7684\u5f62\u5f0f\uff08\u4f8b\u5982\u4ee5 base64 \u683c\u5f0f\u663e\u793a\u56fe\u50cf\u7684 `Gallery`\uff09\u3002\n\n\u60a8\u53ef\u4ee5\u4f7f\u7528\u6784\u5efa\u56fe\u50cf\u7ec4\u4ef6\u65f6\u7684\u53c2\u6570\u63a7\u5236*\u9884\u5904\u7406*\u3002\u4f8b\u5982\uff0c\u5982\u679c\u60a8\u4f7f\u7528\u4ee5\u4e0b\u53c2\u6570\u5b9e\u4f8b\u5316 `Image` \u7ec4\u4ef6\uff0c\u5b83\u5c06\u5c06\u56fe\u50cf\u8f6c\u6362\u4e3a `PIL` \u7c7b\u578b\uff0c\u5e76\u5c06\u5176\u91cd\u5851\u4e3a`(100, 100)`\uff0c\u800c\u4e0d\u7ba1\u63d0\u4ea4\u65f6\u7684\u539f\u59cb\u5927\u5c0f\u5982\u4f55\uff1a\n\n```py\nimg = gr.Image(shape=(100, 100), type=\"pil\")\n```\n\n\u76f8\u53cd\uff0c\u8fd9\u91cc\u6211\u4eec\u4fdd\u7559\u56fe\u50cf\u7684\u539f\u59cb\u5927\u5c0f\uff0c\u4f46\u5728\u5c06\u5176\u8f6c\u6362\u4e3a numpy \u6570\u7ec4\u4e4b\u524d\u53cd\u8f6c\u989c\u8272\uff1a\n\n```py\nimg = gr.Image(invert_colors=True, type=\"numpy\")\n```\n\n\u540e\u5904\u7406\u8981\u5bb9\u6613\u5f97\u591a\uff01Gradio \u81ea\u52a8\u8bc6\u522b\u8fd4\u56de\u6570\u636e\u7684\u683c\u5f0f\uff08\u4f8b\u5982 `Image` \u662f `numpy` \u6570\u7ec4\u8fd8\u662f `str` \u6587\u4ef6\u8def\u5f84\uff1f\uff09\uff0c\u5e76\u5c06\u5176\u540e\u5904\u7406\u4e3a\u53ef\u4ee5\u7531\u6d4f\u89c8\u5668\u663e\u793a\u7684\u683c\u5f0f\u3002\n\n\u8bf7\u67e5\u770b[\u6587\u6863](https://gradio.app/docs)\uff0c\u4e86\u89e3\u6bcf\u4e2a\u7ec4\u4ef6\u7684\u6240\u6709\u4e0e\u9884\u5904\u7406\u76f8\u5173\u7684\u53c2\u6570\u3002\n\n## \u6837\u5f0f (Styling)\n\nGradio \u4e3b\u9898\u662f\u81ea\u5b9a\u4e49\u5e94\u7528\u7a0b\u5e8f\u5916\u89c2\u548c\u611f\u89c9\u7684\u6700\u7b80\u5355\u65b9\u6cd5\u3002\u60a8\u53ef\u4ee5\u9009\u62e9\u591a\u79cd\u4e3b\u9898\u6216\u521b\u5efa\u81ea\u5df1\u7684\u4e3b\u9898\u3002\u8981\u8fd9\u6837\u505a\uff0c\u8bf7\u5c06 `theme=` \u53c2\u6570\u4f20\u9012\u7ed9 `Interface` \u6784\u9020\u51fd\u6570\u3002\u4f8b\u5982\uff1a\n\n```python\ndemo = gr.Interface(..., theme=gr.themes.Monochrome())\n```\n\nGradio \u5e26\u6709\u4e00\u7ec4\u9884\u5148\u6784\u5efa\u7684\u4e3b\u9898\uff0c\u60a8\u53ef\u4ee5\u4ece `gr.themes.*` \u52a0\u8f7d\u3002\u60a8\u53ef\u4ee5\u6269\u5c55\u8fd9\u4e9b\u4e3b\u9898\u6216\u4ece\u5934\u5f00\u59cb\u521b\u5efa\u81ea\u5df1\u7684\u4e3b\u9898 - \u6709\u5173\u66f4\u591a\u8be6\u7ec6\u4fe1\u606f\uff0c\u8bf7\u53c2\u9605[\u4e3b\u9898\u6307\u5357](https://gradio.app/theming-guide)\u3002\n\n\u8981\u589e\u52a0\u989d\u5916\u7684\u6837\u5f0f\u80fd\u529b\uff0c\u60a8\u53ef\u4ee5 with `css=` \u5173\u952e\u5b57\u5c06\u4efb\u4f55 CSS \u4f20\u9012\u7ed9\u60a8\u7684\u5e94\u7528\u7a0b\u5e8f\u3002\nGradio \u5e94\u7528\u7a0b\u5e8f\u7684\u57fa\u7c7b\u662f `gradio-container`\uff0c\u56e0\u6b64\u4ee5\u4e0b\u662f\u4e00\u4e2a\u66f4\u6539 Gradio \u5e94\u7528\u7a0b\u5e8f\u80cc\u666f\u989c\u8272\u7684\u793a\u4f8b\uff1a\n\n```python\nwith `gr.Interface(css=\".gradio-container {background-color: red}\") as demo:\n    ...\n```\n\n## \u961f\u5217 (Queuing)\n\n\u5982\u679c\u60a8\u7684\u5e94\u7528\u7a0b\u5e8f\u9884\u8ba1\u4f1a\u6709\u5927\u91cf\u6d41\u91cf\uff0c\u8bf7 with `queue()` \u65b9\u6cd5\u6765\u63a7\u5236\u5904\u7406\u901f\u7387\u3002\u8fd9\u5c06\u6392\u961f\u5904\u7406\u8c03\u7528\uff0c\u56e0\u6b64\u4e00\u6b21\u53ea\u5904\u7406\u4e00\u5b9a\u6570\u91cf\u7684\u8bf7\u6c42\u3002\u961f\u5217\u4f7f\u7528 Websockets\uff0c\u8fd8\u53ef\u4ee5\u9632\u6b62\u7f51\u7edc\u8d85\u65f6\uff0c\u56e0\u6b64\u5982\u679c\u60a8\u7684\u51fd\u6570\u7684\u63a8\u7406\u65f6\u95f4\u5f88\u957f\uff08> 1 \u5206\u949f\uff09\uff0c\u5e94\u4f7f\u7528\u961f\u5217\u3002\n\nwith `Interface`\uff1a\n\n```python\ndemo = gr.Interface(...).queue()\ndemo.launch()\n```\n\nwith `Blocks`\uff1a\n\n```python\nwith gr.Blocks() as demo\uff1a\n    #...\ndemo.queue()\ndemo.launch()\n```\n\n\u60a8\u53ef\u4ee5\u901a\u8fc7\u4ee5\u4e0b\u65b9\u5f0f\u63a7\u5236\u4e00\u6b21\u5904\u7406\u7684\u8bf7\u6c42\u6570\u91cf\uff1a\n\n```python\ndemo.queue(concurrency_count=3)\n```\n\n\u67e5\u770b\u6709\u5173\u914d\u7f6e\u5176\u4ed6\u961f\u5217\u53c2\u6570\u7684[\u961f\u5217\u6587\u6863](/docs/#queue)\u3002\n\n\u5728 Blocks \u4e2d\u6307\u5b9a\u4ec5\u5bf9\u67d0\u4e9b\u51fd\u6570\u8fdb\u884c\u6392\u961f\uff1a\n\n```python\nwith gr.Blocks() as demo2\uff1a\n    num1 = gr.Number()\n    num2 = gr.Number()\n    output = gr.Number()\n    gr.Button(\"Add\").click(\n        lambda a, b: a + b, [num1, num2], output)\n    gr.Button(\"Multiply\").click(\n        lambda a, b: a * b, [num1, num2], output, queue=True)\ndemo2.launch()\n```\n\n## \u8fed\u4ee3\u8f93\u51fa (Iterative Outputs)\n\n\u5728\u67d0\u4e9b\u60c5\u51b5\u4e0b\uff0c\u60a8\u53ef\u80fd\u9700\u8981\u4f20\u8f93\u4e00\u7cfb\u5217\u8f93\u51fa\u800c\u4e0d\u662f\u4e00\u6b21\u663e\u793a\u5355\u4e2a\u8f93\u51fa\u3002\u4f8b\u5982\uff0c\u60a8\u53ef\u80fd\u6709\u4e00\u4e2a\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5e0c\u671b\u663e\u793a\u751f\u6210\u7684\u6bcf\u4e2a\u6b65\u9aa4\u7684\u56fe\u50cf\uff0c\u76f4\u5230\u6700\u7ec8\u56fe\u50cf\u3002\u6216\u8005\u60a8\u53ef\u80fd\u6709\u4e00\u4e2a\u804a\u5929\u673a\u5668\u4eba\uff0c\u5b83\u9010\u5b57\u9010\u53e5\u5730\u6d41\u5f0f\u4f20\u8f93\u54cd\u5e94\uff0c\u800c\u4e0d\u662f\u4e00\u6b21\u8fd4\u56de\u5168\u90e8\u54cd\u5e94\u3002\n\n\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u60a8\u53ef\u4ee5\u5c06**\u751f\u6210\u5668**\u51fd\u6570\u63d0\u4f9b\u7ed9 Gradio\uff0c\u800c\u4e0d\u662f\u5e38\u89c4\u51fd\u6570\u3002\u5728 Python \u4e2d\u521b\u5efa\u751f\u6210\u5668\u975e\u5e38\u7b80\u5355\uff1a\u51fd\u6570\u4e0d\u5e94\u8be5\u6709\u4e00\u4e2a\u5355\u72ec\u7684 `return` \u503c\uff0c\u800c\u662f\u5e94\u8be5 with `yield` \u8fde\u7eed\u8fd4\u56de\u4e00\u7cfb\u5217\u503c\u3002\u901a\u5e38\uff0c`yield` \u8bed\u53e5\u653e\u7f6e\u5728\u67d0\u79cd\u5faa\u73af\u4e2d\u3002\u4e0b\u9762\u662f\u4e00\u4e2a\u7b80\u5355\u793a\u4f8b\uff0c\u751f\u6210\u5668\u53ea\u662f\u7b80\u5355\u8ba1\u6570\u5230\u7ed9\u5b9a\u6570\u5b57\uff1a\n\n```python\ndef my_generator(x):\n    for i in range(x):\n        yield i\n```\n\n\u60a8\u4ee5\u4e0e\u5e38\u89c4\u51fd\u6570\u76f8\u540c\u7684\u65b9\u5f0f\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio\u3002\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\uff08\u865a\u62df\u7684\uff09\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5b83\u5728\u8f93\u51fa\u56fe\u50cf\u4e4b\u524d\u751f\u6210\u6570\u4e2a\u6b65\u9aa4\u7684\u566a\u97f3\uff1a\n\n$code_fake_diffusion\n$demo_fake_diffusion\n\n\u8bf7\u6ce8\u610f\uff0c\u6211\u4eec\u5728\u8fed\u4ee3\u5668\u4e2d\u6dfb\u52a0\u4e86 `time.sleep(1)`\uff0c\u4ee5\u521b\u5efa\u6b65\u9aa4\u4e4b\u95f4\u7684\u4eba\u5de5\u6682\u505c\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u89c2\u5bdf\u8fed\u4ee3\u5668\u7684\u6b65\u9aa4\uff08\u5728\u771f\u5b9e\u7684\u56fe\u50cf\u751f\u6210\u6a21\u578b\u4e2d\uff0c\u8fd9\n--New Chunk--\n[Created at: 2025-03-24 13:16:13]\n=predictions, references=references)\n>>> results\n{'exact_match': 100.0, 'f1': 100.0}\n```\n\nYou can find examples of dataset structures by consulting the \"Dataset Preview\" function or the dataset card for a given dataset, and you can see how to use its dedicated evaluation function based on the metric card."
        }
    },
    {
        "sample_idx": 17,
        "question": "What is mnli?",
        "answer": "mnli is a crowdsourced collection of sentence pairs with textual entailment annotations, which is a subset of GLUE corresponding to the NLI task.",
        "rag_answer": "MNLI (Multi-Genre Natural Language Inference) is a dataset for evaluating natural language inference models. It is a crowdsourced collection of sentence pairs with textual entailment annotations. In other words, MNLI is a benchmark dataset used to evaluate the ability of AI models to perform natural language inference, which involves determining whether a given sentence entails, contradicts, or is neutral with respect to another sentence.\n\nMNLI is a popular dataset in the field of natural language processing (NLP) and is often used to fine-tune language models for specific NLP tasks, such as text classification, sentiment analysis, and question-answering.\n\nAccording to the Data Sources, MNLI is a dataset for evaluating natural language inference models, and it is mentioned as an example of a dataset that can be used to fine-tune LayoutLMv3, a model for token classification.\n\nReferences:\n[KG] mnli, dataset, natural language inference models\n[DC] Choosing a metric for your task, GLUE is actually a collection of different subsets on different tasks, so first you need to choose the one that corresponds to the NLI task, such as mnli, which is described as \u201ccrowdsourced collection of sentence pairs with textual entailment annotations\u201d",
        "rag_score": 5,
        "rag_feedback": "The system's response is completely correct, accurate, and factual. It provides a detailed and relevant explanation of what MNLI is, including its definition, purpose, and usage. The response also provides additional information about natural language inference models and their evaluation, which is relevant to the context of MNLI.",
        "rag_context": {
            "kg_context": "-----Entities-----\n    ```csv\n    id,\tentity,\ttype,\tdescription,\trankcreated_at\n1,\tMachine Learning,category,Machine Learning is a field of study that involves training models to make predictions.,5,2025-03-24 13:16:48\n2,\tModel,category,Model refers to a machine learning model being evaluated.,3,2025-03-24 13:16:48\n3,\tBLEU,category,BLEU is a category of evaluation metrics for machine translation tasks.,1,2025-03-24 13:16:48\n4,\tMachine Translation,event,Machine Translation is an event or task in natural language processing.,3,2025-03-24 13:16:48\n5,\tGLEU,category,GLEU is a category of evaluation metrics for machine translation tasks.,1,2025-03-24 13:16:48\n6,\tmnli,dataset,mnli is a dataset for evaluating natural language inference models.,0,UNKNOWN\n7,\tDatasets library,technology,Datasets library is a tool used for fine-tuning the LayoutLMv3 model.,1,UNKNOWN\n8,\tdistilbert-base-uncased-finetuned-sst-2-english,category,distilbert-base-uncased-finetuned-sst-2-english is a specific AI model for text classification.,1,UNKNOWN\n    ```\n    -----Relationships-----\n    ```csv\n    id,\tsource,\ttarget,\tdescription,\tkeywords,\tweight,\trank,\tcreated_at\n1,\tMachine Learning,Model,Machine Learning involves training models to make predictions.,field of study, model training,9.0,8,2025-03-24 13:16:48\n2,\tBLEU,Machine Translation,BLEU is a metric used to evaluate machine translation models.,evaluation metric, task,18.0,4,2025-03-24 13:16:48\n3,\tGLEU,Machine Translation,GLEU is a metric used to evaluate machine translation models.,evaluation metric, task,9.0,4,2025-03-24 13:16:48\n4,\tDatasets library,LayoutLMv3,Datasets library is a tool used for fine-tuning the LayoutLMv3 model.,tool, model fine-tuning,7.0,12,UNKNOWN\n5,\tHugging Face,distilbert-base-uncased-finetuned-sst-2-english,Hugging Face provides a platform for deploying the distilbert-base-uncased-finetuned-sst-2-english model.,platform, model deployment,18.0,9,UNKNOWN\n    ```\n    -----Sources-----\n    ```csv\n    id,\tcontent\n1,\t=predictions, references=references)\n>>> results\n{'exact_match': 100.0, 'f1': 100.0}\n```\n\nYou can find examples of dataset structures by consulting the \"Dataset Preview\" function or the dataset card for a given dataset, and you can see how to use its dedicated evaluation function based on the metric card.\n2,\tChoosing a metric for your task\n\n**So you've trained your model and want to see how well it\u2019s doing on a dataset of your choice. Where do you start?**\n\nThere is no \u201cone size fits all\u201d approach to choosing an evaluation metric, but some good guidelines to keep in mind are:\n\n## Categories of metrics\n\nThere are 3 high-level categories of metrics:\n\n1. *Generic metrics*, which can be applied to a variety of situations and datasets, such as precision and accuracy.\n2. *Task-specific metrics*, which are limited to a given task, such as Machine Translation (often evaluated using metrics [BLEU](https://huggingface.co/metrics/bleu) or [ROUGE](https://huggingface.co/metrics/rouge)) or Named Entity Recognition (often evaluated with [seqeval](https://huggingface.co/metrics/seqeval)).\n3. *Dataset-specific metrics*, which aim to measure model performance on specific benchmarks: for instance, the [GLUE benchmark](https://huggingface.co/datasets/glue) has a dedicated [evaluation metric](https://huggingface.co/metrics/glue).\n\nLet's look at each of these three cases:\n\n### Generic metrics\n\nMany of the metrics used in the Machine Learning community are quite generic and can be applied in a variety of tasks and datasets.\n\nThis is the case for metrics like [accuracy](https://huggingface.co/metrics/accuracy) and [precision](https://huggingface.co/metrics/precision), which can be used for evaluating labeled (supervised) datasets, as well as [perplexity](https://huggingface.co/metrics/perplexity), which can be used for evaluating different kinds of (unsupervised) generative tasks.\n\nTo see the input structure of a given metric, you can look at its metric card. For example, in the case of [precision](https://huggingface.co/metrics/precision), the format is:\n```\n>>> precision_metric = evaluate.load(\"precision\")\n>>> results = precision_metric.compute(references=[0, 1], predictions=[0, 1])\n>>> print(results)\n{'precision': 1.0}\n```\n\n### Task-specific metrics\n\nPopular ML tasks like Machine Translation and Named Entity Recognition have specific metrics that can be used to compare models. For example, a series of different metrics have been proposed for text generation, ranging from [BLEU](https://huggingface.co/metrics/bleu) and its derivatives such as [GoogleBLEU](https://huggingface.co/metrics/google_bleu) and [GLEU](https://huggingface.co/metrics/gleu), but also [ROUGE](https://huggingface.co/metrics/rouge), [MAUVE](https://huggingface.co/metrics/mauve), etc.\n\nYou can find the right metric for your task by:\n\n- **Looking at the [Task pages](https://huggingface.co/tasks)** to see what metrics can be used for evaluating models for a given task.\n- **Checking out leaderboards** on sites like [Papers With Code](https://paperswithcode.com/) (you can search by task and by dataset).\n-  **Reading the metric cards** for the relevant metrics and see which ones are a good fit for your use case. For example, see the [BLEU metric card](https://github.com/huggingface/evaluate/tree/main/metrics/bleu) or [SQuaD metric card](https://github.com/huggingface/evaluate/tree/main/metrics/squad).\n- **Looking at papers and blog posts** published on the topic and see what metrics they report. This can change over time, so try to pick papers from the last couple of years!\n\n### Dataset-specific metrics\n\nSome datasets have specific metrics associated with them -- this is especially in the case of popular benchmarks like [GLUE](https://huggingface.co/metrics/glue) and [SQuAD](https://huggingface.co/metrics/squad).\n\n<Tip warning={true}>\n\ud83d\udca1\nGLUE is actually a collection of different subsets on different tasks, so first you need to choose the one that corresponds to the NLI task, such as mnli, which is described as \u201ccrowdsourced collection of sentence pairs with textual entailment annotations\u201d\n</Tip>\n\n\nIf you are evaluating your model on a benchmark dataset like the ones mentioned above, you can use its dedicated evaluation metric. Make sure you respect the format that they require. For example, to evaluate your model on the [SQuAD](https://huggingface.co/datasets/squad) dataset, you need to feed the `question` and `context` into your model and return the `prediction_text`, which should be compared with the `references` (based on matching the `id` of the question) :\n\n```\n>>> from evaluate import load\n>>> squad_metric = load(\"squad\")\n>>> predictions = [{'prediction_text': '1976', 'id': '56e10a3be3433e1400422b22'}]\n>>> references = [{'answers': {'answer_start': [97], 'text': ['1976']}, 'id': '56e10a3be3433e1400422b22'}]\n>>> results = squad_metric.compute(predictions=predictions, references=references)\n>>> results\n{'exact_match': 100.0, 'f1': 100.0}\n```\n\nYou can find examples of dataset structures by consulting the \"Dataset Preview\" function or the dataset card for a given dataset, and you can see how to use its dedicated evaluation function based on the metric card.\n3,\t!---\nCopyright 2022 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n-->\n\n# Token classification with LayoutLMv3 (PyTorch version)\n\nThis directory contains a script, `run_funsd_cord.py`, that can be used to fine-tune (or evaluate) LayoutLMv3 on form understanding datasets, such as [FUNSD](https://guillaumejaume.github.io/FUNSD/) and [CORD](https://github.com/clovaai/cord).\n\nThe script `run_funsd_cord.py` leverages the \ud83e\udd17 Datasets library and the Trainer API. You can easily customize it to your needs.\n\n## Fine-tuning on FUNSD\n\nFine-tuning LayoutLMv3 for token classification on [FUNSD](https://guillaumejaume.github.io/FUNSD/) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name funsd \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 1e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-funsd\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd. By specifying the `push_to_hub` flag, the model gets uploaded automatically to the hub (regularly), together with a model card, which includes metrics such as precision, recall and F1. Note that you can easily update the model card, as it's just a README file of the respective repo on the hub.\n\nThere's also the \"Training metrics\" [tab](https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd/tensorboard), which shows Tensorboard logs over the course of training. Pretty neat, huh?\n\n## Fine-tuning on CORD\n\nFine-tuning LayoutLMv3 for token classification on [CORD](https://github.com/clovaai/cord) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name cord \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 5e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-cord\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-cord. Note that a model card gets generated automatically in case you specify the `push_to_hub` flag.\n4,\tCreate an Endpoint\n\nAfter your first login, you will be directed to the [Endpoint creation page](https://ui.endpoints.huggingface.co/new). As an example, this guide will go through the steps to deploy [distilbert-base-uncased-finetuned-sst-2-english](https://huggingface.co/distilbert-base-uncased-finetuned-sst-2-english) for text classification. \n\n## 1. Enter the Hugging Face Repository ID and your desired endpoint name:\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_repository.png\" alt=\"select repository\" />\n\n## 2. Select your Cloud Provider and region. Initially, only AWS will be available as a Cloud Provider with the `us-east-1` and `eu-west-1` regions. We will add Azure soon, and if you need to test Endpoints with other Cloud Providers or regions, please let us know.\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_region.png\" alt=\"select region\" />\n\n## 3. Define the [Security Level](security) for the Endpoint:\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_security.png\" alt=\"define security\" />\n\n## 4. Create your Endpoint by clicking **Create Endpoint**. By default, your Endpoint is created with a medium CPU (2 x 4GB vCPUs with Intel Xeon Ice Lake) The cost estimate assumes the Endpoint will be up for an entire month, and does not take autoscaling into account.\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_create_cost.png\" alt=\"create endpoint\" />\n\n## 5. Wait for the Endpoint to build, initialize and run which can take between 1 to 5 minutes.\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/overview.png\" alt=\"overview\" />\n\n## 6. Test your Endpoint in the overview with the Inference widget \ud83c\udfc1 \ud83c\udf89!\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_inference.png\" alt=\"run inference\" />\n    ```",
            "vector_context": "[Created at: 2025-03-24 13:15:42]\nCreate an Endpoint\n\nAfter your first login, you will be directed to the [Endpoint creation page](https://ui.endpoints.huggingface.co/new). As an example, this guide will go through the steps to deploy [distilbert-base-uncased-finetuned-sst-2-english](https://huggingface.co/distilbert-base-uncased-finetuned-sst-2-english) for text classification. \n\n## 1. Enter the Hugging Face Repository ID and your desired endpoint name:\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_repository.png\" alt=\"select repository\" />\n\n## 2. Select your Cloud Provider and region. Initially, only AWS will be available as a Cloud Provider with the `us-east-1` and `eu-west-1` regions. We will add Azure soon, and if you need to test Endpoints with other Cloud Providers or regions, please let us know.\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_region.png\" alt=\"select region\" />\n\n## 3. Define the [Security Level](security) for the Endpoint:\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_security.png\" alt=\"define security\" />\n\n## 4. Create your Endpoint by clicking **Create Endpoint**. By default, your Endpoint is created with a medium CPU (2 x 4GB vCPUs with Intel Xeon Ice Lake) The cost estimate assumes the Endpoint will be up for an entire month, and does not take autoscaling into account.\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_create_cost.png\" alt=\"create endpoint\" />\n\n## 5. Wait for the Endpoint to build, initialize and run which can take between 1 to 5 minutes.\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/overview.png\" alt=\"overview\" />\n\n## 6. Test your Endpoint in the overview with the Inference widget \ud83c\udfc1 \ud83c\udf89!\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_inference.png\" alt=\"run inference\" />\n--New Chunk--\n[Created at: 2025-03-24 13:16:13]\n=predictions, references=references)\n>>> results\n{'exact_match': 100.0, 'f1': 100.0}\n```\n\nYou can find examples of dataset structures by consulting the \"Dataset Preview\" function or the dataset card for a given dataset, and you can see how to use its dedicated evaluation function based on the metric card.\n--New Chunk--\n[Created at: 2025-03-24 13:19:17]\n!---\nCopyright 2022 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n-->\n\n# Token classification with LayoutLMv3 (PyTorch version)\n\nThis directory contains a script, `run_funsd_cord.py`, that can be used to fine-tune (or evaluate) LayoutLMv3 on form understanding datasets, such as [FUNSD](https://guillaumejaume.github.io/FUNSD/) and [CORD](https://github.com/clovaai/cord).\n\nThe script `run_funsd_cord.py` leverages the \ud83e\udd17 Datasets library and the Trainer API. You can easily customize it to your needs.\n\n## Fine-tuning on FUNSD\n\nFine-tuning LayoutLMv3 for token classification on [FUNSD](https://guillaumejaume.github.io/FUNSD/) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name funsd \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 1e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-funsd\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd. By specifying the `push_to_hub` flag, the model gets uploaded automatically to the hub (regularly), together with a model card, which includes metrics such as precision, recall and F1. Note that you can easily update the model card, as it's just a README file of the respective repo on the hub.\n\nThere's also the \"Training metrics\" [tab](https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd/tensorboard), which shows Tensorboard logs over the course of training. Pretty neat, huh?\n\n## Fine-tuning on CORD\n\nFine-tuning LayoutLMv3 for token classification on [CORD](https://github.com/clovaai/cord) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name cord \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 5e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-cord\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-cord. Note that a model card gets generated automatically in case you specify the `push_to_hub` flag."
        }
    },
    {
        "sample_idx": 18,
        "question": "What is the name of the dataset that requires feeding the 'question' and 'context' into the model and returning the 'prediction_text'?",
        "answer": "SQuAD",
        "rag_answer": "The dataset that requires feeding the 'question' and 'context' into the model and returning the 'prediction_text' is called SQuAD (Stanford Question Answering Dataset).",
        "rag_score": 5,
        "rag_feedback": "The system's response is completely correct, accurate, and factual. It correctly identifies the dataset as SQuAD and provides additional information about the dataset and its evaluation metric.",
        "rag_context": {
            "kg_context": "-----Entities-----\n    ```csv\n    id,\tentity,\ttype,\tdescription,\trankcreated_at\n1,\tMachine Learning,category,Machine Learning is a field of study that involves training models to make predictions.,5,2025-03-24 13:16:48\n2,\tModel,category,Model refers to a machine learning model being evaluated.,3,2025-03-24 13:16:48\n3,\tKeras,category,Keras is a high-level neural networks API, used for building and training neural networks.<SEP>Keras is a machine learning framework that uses XLA for optimization.,2,2025-03-24 13:16:48\n4,\tXLA,technology,XLA is a technology that compiles TensorFlow graphs into executable code for various platforms.<SEP>XLA is an optimizing compiler used by TensorFlow and JAX to improve performance.<SEP>XLA is an optimizing compiler, used by both TensorFlow and JAX to optimize computations.,6,2025-03-24 13:16:48\n5,\tPredictions,category,Predictions are the outcome of a model's performance.,2,2025-03-24 13:16:48\n6,\tSQuAD,dataset,SQuAD is a benchmark dataset for evaluating question answering models.,1,UNKNOWN\n7,\tPredictions,category,Predictions are the outcome of a model's performance.,2,UNKNOWN\n8,\tGLUE,dataset,GLUE is a benchmark dataset for evaluating natural language processing models.,1,UNKNOWN\n    ```\n    -----Relationships-----\n    ```csv\n    id,\tsource,\ttarget,\tdescription,\tkeywords,\tweight,\trank,\tcreated_at\n1,\tMachine Learning,Model,Machine Learning involves training models to make predictions.,field of study, model training,9.0,8,2025-03-24 13:16:48\n2,\tKeras,XLA,Keras uses XLA for optimization.,compiler, performance optimization,8.0,8,2025-03-24 13:18:20\n3,\tModel,Predictions,The model makes predictions based on the input data.,model output, predictions,8.0,5,2025-03-24 13:16:48\n4,\tHugging Face,SQuAD,Hugging Face provides a platform for evaluating models on the SQuAD benchmark dataset.,evaluation platform, benchmark dataset,16.0,9,UNKNOWN\n5,\tGLUE,Hugging Face,Hugging Face provides a platform for evaluating models on the GLUE benchmark dataset.,evaluation platform, benchmark dataset,16.0,9,UNKNOWN\n6,\tModel,Predictions,The model makes predictions based on the input data.,model output, predictions,8.0,5,UNKNOWN\n7,\tPredictions,References,References are used to support predictions.,information sources, prediction support,14.0,3,UNKNOWN\n    ```\n    -----Sources-----\n    ```csv\n    id,\tcontent\n1,\t=predictions, references=references)\n>>> results\n{'exact_match': 100.0, 'f1': 100.0}\n```\n\nYou can find examples of dataset structures by consulting the \"Dataset Preview\" function or the dataset card for a given dataset, and you can see how to use its dedicated evaluation function based on the metric card.\n2,\t(for example, a v3-32), your TPU fleet is referred to as a **pod slice.**\n\nWhen you access a free TPU via Colab, you generally get a single v2-8 TPU.\n\n### I keep hearing about this XLA thing. What\u2019s XLA, and how does it relate to TPUs?\n\nXLA is an optimizing compiler, used by both TensorFlow and JAX. In JAX it is the only compiler, whereas in TensorFlow it is optional (but mandatory on TPU!). The easiest way to enable it when training a Keras model is to pass the argument `jit_compile=True` to `model.compile()`. If you don\u2019t get any errors and performance is good, that\u2019s a great sign that you\u2019re ready to move to TPU!\n\nDebugging on TPU is generally a bit harder than on CPU/GPU, so we recommend getting your code running on CPU/GPU with XLA first before trying it on TPU. You don\u2019t have to train for long, of course - just for a few steps to make sure that your model and data pipeline are working like you expect them to.\n\n<Tip>\n\nXLA compiled code is usually faster - so even if you\u2019re not planning to run on TPU, adding `jit_compile=True` can improve your performance. Be sure to note the caveats below about XLA compatibility, though!\n\n</Tip>\n\n<Tip warning={true}>\n\n**Tip born of painful experience:** Although using `jit_compile=True` is a good way to get a speed boost and test if your CPU/GPU code is XLA-compatible, it can actually cause a lot of problems if you leave it in when actually training on TPU. XLA compilation will happen implicitly on TPU, so remember to remove that line before actually running your code on a TPU!\n\n</Tip>\n\n### How do I make my model XLA compatible?\n\nIn many cases, your code is probably XLA-compatible already! However, there are a few things that work in normal TensorFlow that don\u2019t work in XLA. We\u2019ve distilled them into three core rules below:\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** We\u2019ve put a lot of effort into rewriting our TensorFlow models and loss functions to be XLA-compatible. Our models and loss functions generally obey rule #1 and #2 by default, so you can skip over them if you\u2019re using `transformers` models. Don\u2019t forget about these rules when writing your own models and loss functions, though!\n\n</Tip>\n\n#### XLA Rule #1: Your code cannot have \u201cdata-dependent conditionals\u201d\n\nWhat that means is that any `if` statement cannot depend on values inside a `tf.Tensor`. For example, this code block cannot be compiled with XLA!\n\n```python\nif tf.reduce_sum(tensor) > 10:\n    tensor = tensor / 2.0\n```\n\nThis might seem very restrictive at first, but most neural net code doesn\u2019t need to do this. You can often get around this restriction by using `tf.cond` (see the documentation [here](https://www.tensorflow.org/api_docs/python/tf/cond)) or by removing the conditional and finding a clever math trick with indicator variables instead, like so:\n\n```python\nsum_over_10 = tf.cast(tf.reduce_sum(tensor) > 10, tf.float32)\ntensor = tensor / (1.0 + sum_over_10)\n```\n\nThis code has exactly the same effect as the code above, but by avoiding a conditional, we ensure it will compile with XLA without problems!\n\n#### XLA Rule #2: Your code cannot have \u201cdata-dependent shapes\u201d\n\nWhat this means is that the shape of all of the `tf.Tensor` objects in your code cannot depend on their values. For example, the function `tf.unique` cannot be compiled with XLA, because it returns a `tensor` containing one instance of each unique value in the input. The shape of this output will obviously be different depending on how repetitive the input `Tensor` was, and so XLA refuses to handle it!\n\nIn general, most neural network code obeys rule #2 by default. However, there are a few common cases where it becomes a problem. One very common one is when you use **label masking**, setting your labels to a negative value to indicate that those positions should be ignored when computing the loss. If you look at NumPy or PyTorch loss functions that support label masking, you will often see code like this that uses [boolean indexing](https://numpy.org/doc/stable/user/basics.indexing.html#boolean-array-indexing):\n\n```python\nlabel_mask = labels >= 0\nmasked_outputs = outputs[label_mask]\nmasked_labels = labels[label_mask]\nloss = compute_loss(masked_outputs, masked_labels)\nmean_loss = torch.mean(loss)\n```\n\nThis code is totally fine in NumPy or PyTorch, but it breaks in XLA! Why? Because the shape of `masked_outputs` and `masked_labels` depends on how many positions are masked - that makes it a **data-dependent shape.** However, just like for rule #1, we can often rewrite this code to yield exactly the same output without any data-dependent shapes.\n\n```python\nlabel_mask = tf.cast(labels >= 0, tf.float32)\nloss = compute_loss(outputs, labels)\nloss = loss * label_mask  # Set negative label positions to 0\nmean_loss = tf.reduce_sum(loss) / tf.reduce_sum(label_mask)\n```\n\nHere, we avoid data-dependent shapes by computing the loss for every position, but zeroing out the masked positions in both the numerator and denominator when we calculate the mean, which yields exactly the same result as the first block while maintaining XLA compatibility. Note that we use the same trick as in rule #1 - converting a `tf.bool` to `\n3,\tChoosing a metric for your task\n\n**So you've trained your model and want to see how well it\u2019s doing on a dataset of your choice. Where do you start?**\n\nThere is no \u201cone size fits all\u201d approach to choosing an evaluation metric, but some good guidelines to keep in mind are:\n\n## Categories of metrics\n\nThere are 3 high-level categories of metrics:\n\n1. *Generic metrics*, which can be applied to a variety of situations and datasets, such as precision and accuracy.\n2. *Task-specific metrics*, which are limited to a given task, such as Machine Translation (often evaluated using metrics [BLEU](https://huggingface.co/metrics/bleu) or [ROUGE](https://huggingface.co/metrics/rouge)) or Named Entity Recognition (often evaluated with [seqeval](https://huggingface.co/metrics/seqeval)).\n3. *Dataset-specific metrics*, which aim to measure model performance on specific benchmarks: for instance, the [GLUE benchmark](https://huggingface.co/datasets/glue) has a dedicated [evaluation metric](https://huggingface.co/metrics/glue).\n\nLet's look at each of these three cases:\n\n### Generic metrics\n\nMany of the metrics used in the Machine Learning community are quite generic and can be applied in a variety of tasks and datasets.\n\nThis is the case for metrics like [accuracy](https://huggingface.co/metrics/accuracy) and [precision](https://huggingface.co/metrics/precision), which can be used for evaluating labeled (supervised) datasets, as well as [perplexity](https://huggingface.co/metrics/perplexity), which can be used for evaluating different kinds of (unsupervised) generative tasks.\n\nTo see the input structure of a given metric, you can look at its metric card. For example, in the case of [precision](https://huggingface.co/metrics/precision), the format is:\n```\n>>> precision_metric = evaluate.load(\"precision\")\n>>> results = precision_metric.compute(references=[0, 1], predictions=[0, 1])\n>>> print(results)\n{'precision': 1.0}\n```\n\n### Task-specific metrics\n\nPopular ML tasks like Machine Translation and Named Entity Recognition have specific metrics that can be used to compare models. For example, a series of different metrics have been proposed for text generation, ranging from [BLEU](https://huggingface.co/metrics/bleu) and its derivatives such as [GoogleBLEU](https://huggingface.co/metrics/google_bleu) and [GLEU](https://huggingface.co/metrics/gleu), but also [ROUGE](https://huggingface.co/metrics/rouge), [MAUVE](https://huggingface.co/metrics/mauve), etc.\n\nYou can find the right metric for your task by:\n\n- **Looking at the [Task pages](https://huggingface.co/tasks)** to see what metrics can be used for evaluating models for a given task.\n- **Checking out leaderboards** on sites like [Papers With Code](https://paperswithcode.com/) (you can search by task and by dataset).\n-  **Reading the metric cards** for the relevant metrics and see which ones are a good fit for your use case. For example, see the [BLEU metric card](https://github.com/huggingface/evaluate/tree/main/metrics/bleu) or [SQuaD metric card](https://github.com/huggingface/evaluate/tree/main/metrics/squad).\n- **Looking at papers and blog posts** published on the topic and see what metrics they report. This can change over time, so try to pick papers from the last couple of years!\n\n### Dataset-specific metrics\n\nSome datasets have specific metrics associated with them -- this is especially in the case of popular benchmarks like [GLUE](https://huggingface.co/metrics/glue) and [SQuAD](https://huggingface.co/metrics/squad).\n\n<Tip warning={true}>\n\ud83d\udca1\nGLUE is actually a collection of different subsets on different tasks, so first you need to choose the one that corresponds to the NLI task, such as mnli, which is described as \u201ccrowdsourced collection of sentence pairs with textual entailment annotations\u201d\n</Tip>\n\n\nIf you are evaluating your model on a benchmark dataset like the ones mentioned above, you can use its dedicated evaluation metric. Make sure you respect the format that they require. For example, to evaluate your model on the [SQuAD](https://huggingface.co/datasets/squad) dataset, you need to feed the `question` and `context` into your model and return the `prediction_text`, which should be compared with the `references` (based on matching the `id` of the question) :\n\n```\n>>> from evaluate import load\n>>> squad_metric = load(\"squad\")\n>>> predictions = [{'prediction_text': '1976', 'id': '56e10a3be3433e1400422b22'}]\n>>> references = [{'answers': {'answer_start': [97], 'text': ['1976']}, 'id': '56e10a3be3433e1400422b22'}]\n>>> results = squad_metric.compute(predictions=predictions, references=references)\n>>> results\n{'exact_match': 100.0, 'f1': 100.0}\n```\n\nYou can find examples of dataset structures by consulting the \"Dataset Preview\" function or the dataset card for a given dataset, and you can see how to use its dedicated evaluation function based on the metric card.\n    ```",
            "vector_context": "[Created at: 2025-03-24 13:16:13]\n=predictions, references=references)\n>>> results\n{'exact_match': 100.0, 'f1': 100.0}\n```\n\nYou can find examples of dataset structures by consulting the \"Dataset Preview\" function or the dataset card for a given dataset, and you can see how to use its dedicated evaluation function based on the metric card.\n--New Chunk--\n[Created at: 2025-03-24 13:16:13]\nChoosing a metric for your task\n\n**So you've trained your model and want to see how well it\u2019s doing on a dataset of your choice. Where do you start?**\n\nThere is no \u201cone size fits all\u201d approach to choosing an evaluation metric, but some good guidelines to keep in mind are:\n\n## Categories of metrics\n\nThere are 3 high-level categories of metrics:\n\n1. *Generic metrics*, which can be applied to a variety of situations and datasets, such as precision and accuracy.\n2. *Task-specific metrics*, which are limited to a given task, such as Machine Translation (often evaluated using metrics [BLEU](https://huggingface.co/metrics/bleu) or [ROUGE](https://huggingface.co/metrics/rouge)) or Named Entity Recognition (often evaluated with [seqeval](https://huggingface.co/metrics/seqeval)).\n3. *Dataset-specific metrics*, which aim to measure model performance on specific benchmarks: for instance, the [GLUE benchmark](https://huggingface.co/datasets/glue) has a dedicated [evaluation metric](https://huggingface.co/metrics/glue).\n\nLet's look at each of these three cases:\n\n### Generic metrics\n\nMany of the metrics used in the Machine Learning community are quite generic and can be applied in a variety of tasks and datasets.\n\nThis is the case for metrics like [accuracy](https://huggingface.co/metrics/accuracy) and [precision](https://huggingface.co/metrics/precision), which can be used for evaluating labeled (supervised) datasets, as well as [perplexity](https://huggingface.co/metrics/perplexity), which can be used for evaluating different kinds of (unsupervised) generative tasks.\n\nTo see the input structure of a given metric, you can look at its metric card. For example, in the case of [precision](https://huggingface.co/metrics/precision), the format is:\n```\n>>> precision_metric = evaluate.load(\"precision\")\n>>> results = precision_metric.compute(references=[0, 1], predictions=[0, 1])\n>>> print(results)\n{'precision': 1.0}\n```\n\n### Task-specific metrics\n\nPopular ML tasks like Machine Translation and Named Entity Recognition have specific metrics that can be used to compare models. For example, a series of different metrics have been proposed for text generation, ranging from [BLEU](https://huggingface.co/metrics/bleu) and its derivatives such as [GoogleBLEU](https://huggingface.co/metrics/google_bleu) and [GLEU](https://huggingface.co/metrics/gleu), but also [ROUGE](https://huggingface.co/metrics/rouge), [MAUVE](https://huggingface.co/metrics/mauve), etc.\n\nYou can find the right metric for your task by:\n\n- **Looking at the [Task pages](https://huggingface.co/tasks)** to see what metrics can be used for evaluating models for a given task.\n- **Checking out leaderboards** on sites like [Papers With Code](https://paperswithcode.com/) (you can search by task and by dataset).\n-  **Reading the metric cards** for the relevant metrics and see which ones are a good fit for your use case. For example, see the [BLEU metric card](https://github.com/huggingface/evaluate/tree/main/metrics/bleu) or [SQuaD metric card](https://github.com/huggingface/evaluate/tree/main/metrics/squad).\n- **Looking at papers and blog posts** published on the topic and see what metrics they report. This can change over time, so try to pick papers from the last couple of years!\n\n### Dataset-specific metrics\n\nSome datasets have specific metrics associated with them -- this is especially in the case of popular benchmarks like [GLUE](https://huggingface.co/metrics/glue) and [SQuAD](https://huggingface.co/metrics/squad).\n\n<Tip warning={true}>\n\ud83d\udca1\nGLUE is actually a collection of different subsets on different tasks, so first you need to choose the one that corresponds to the NLI task, such as mnli, which is described as \u201ccrowdsourced collection of sentence pairs with textual entailment annotations\u201d\n</Tip>\n\n\nIf you are evaluating your model on a benchmark dataset like the ones mentioned above, you can use its dedicated evaluation metric. Make sure you respect the format that they require. For example, to evaluate your model on the [SQuAD](https://huggingface.co/datasets/squad) dataset, you need to feed the `question` and `context` into your model and return the `prediction_text`, which should be compared with the `references` (based on matching the `id` of the question) :\n\n```\n>>> from evaluate import load\n>>> squad_metric = load(\"squad\")\n>>> predictions = [{'prediction_text': '1976', 'id': '56e10a3be3433e1400422b22'}]\n>>> references = [{'answers': {'answer_start': [97], 'text': ['1976']}, 'id': '56e10a3be3433e1400422b22'}]\n>>> results = squad_metric.compute(predictions=predictions, references=references)\n>>> results\n{'exact_match': 100.0, 'f1': 100.0}\n```\n\nYou can find examples of dataset structures by consulting the \"Dataset Preview\" function or the dataset card for a given dataset, and you can see how to use its dedicated evaluation function based on the metric card.\n--New Chunk--\n[Created at: 2025-03-24 13:19:17]\n!---\nCopyright 2022 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n-->\n\n# Token classification with LayoutLMv3 (PyTorch version)\n\nThis directory contains a script, `run_funsd_cord.py`, that can be used to fine-tune (or evaluate) LayoutLMv3 on form understanding datasets, such as [FUNSD](https://guillaumejaume.github.io/FUNSD/) and [CORD](https://github.com/clovaai/cord).\n\nThe script `run_funsd_cord.py` leverages the \ud83e\udd17 Datasets library and the Trainer API. You can easily customize it to your needs.\n\n## Fine-tuning on FUNSD\n\nFine-tuning LayoutLMv3 for token classification on [FUNSD](https://guillaumejaume.github.io/FUNSD/) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name funsd \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 1e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-funsd\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd. By specifying the `push_to_hub` flag, the model gets uploaded automatically to the hub (regularly), together with a model card, which includes metrics such as precision, recall and F1. Note that you can easily update the model card, as it's just a README file of the respective repo on the hub.\n\nThere's also the \"Training metrics\" [tab](https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd/tensorboard), which shows Tensorboard logs over the course of training. Pretty neat, huh?\n\n## Fine-tuning on CORD\n\nFine-tuning LayoutLMv3 for token classification on [CORD](https://github.com/clovaai/cord) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name cord \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 5e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-cord\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-cord. Note that a model card gets generated automatically in case you specify the `push_to_hub` flag."
        }
    },
    {
        "sample_idx": 19,
        "question": "What is the name of the function used to compute the evaluation results in the example code?",
        "answer": "compute",
        "rag_answer": "The function used to compute the evaluation results in the example code is `compute`. This function is part of the `evaluate` library and is used to compute the evaluation metrics for a given model. \n\nFor example, in the code snippet: \n```\n>>> precision_metric = evaluate.load(\"precision\")\n>>> results = precision_metric.compute(references=[0, 1], predictions=[0, 1])\n>>> print(results)\n{'precision': 1.0}\n```\nThe `compute` function is used to compute the precision metric for the given references and predictions.",
        "rag_score": 5,
        "rag_feedback": "The system's response is completely correct, accurate, and factual. It provides a detailed explanation of the function used to compute the evaluation results in the example code, which is the `compute` function. The response also includes a code snippet that demonstrates how to use the `compute` function to compute the precision metric for a given model.",
        "rag_context": {
            "kg_context": "-----Entities-----\n    ```csv\n    id,\tentity,\ttype,\tdescription,\trankcreated_at\n1,\tMachine Learning,category,Machine Learning is a field of study that involves training models to make predictions.,5,2025-03-24 13:16:48\n2,\tPapers With Code,organization,Papers With Code is an organization that provides a platform for tracking machine learning papers and their corresponding code.,1,2025-03-24 13:16:48\n3,\tEvaluation Function,category,Evaluation Function is a tool used to assess the performance of a model.,2,2025-03-24 13:16:48\n4,\tModel,category,Model refers to a machine learning model being evaluated.,3,2025-03-24 13:16:48\n5,\tResults,event,Results are the outcome of evaluating a model, in this case, showing perfect accuracy.,1,2025-03-24 13:16:48\n6,\tJupyter,category,Jupyter is a platform for interactive computing and data science.,2,UNKNOWN\n7,\tPapers With Code,organization,Papers With Code is an organization that provides a platform for tracking machine learning papers and their corresponding code.,1,UNKNOWN\n8,\tnumpy,technology,numpy is a type of numerical computing library that can be used with Gradio components.,1,UNKNOWN\n    ```\n    -----Relationships-----\n    ```csv\n    id,\tsource,\ttarget,\tdescription,\tkeywords,\tweight,\trank,\tcreated_at\n1,\tMachine Learning,Papers With Code,Papers With Code provides a platform for tracking machine learning papers and their corresponding code.,research platform, machine learning,8.0,6,2025-03-24 13:16:48\n2,\tEvaluation Function,Model,The evaluation function is used to assess the performance of the model.,model evaluation, performance assessment,18.0,5,2025-03-24 13:16:48\n3,\tEvaluation Function,Results,The results are obtained by using the evaluation function.,evaluation outcome, accuracy,20.0,3,2025-03-24 13:16:48\n4,\tGradio,Jupyter,Gradio can be run on Jupyter notebooks.,platform compatibility, interactive computing,7.0,38,UNKNOWN\n5,\tGradio,numpy,Gradio can use numpy library for numerical computing.,library integration, numerical computing,14.0,37,UNKNOWN\n6,\tMachine Learning,Papers With Code,Papers With Code provides a platform for tracking machine learning papers and their corresponding code.,research platform, machine learning,8.0,6,UNKNOWN\n7,\tJupyter,notebooks,Notebooks are a type of interactive document used in Jupyter.,document type, interactive computing,7.0,3,UNKNOWN\n    ```\n    -----Sources-----\n    ```csv\n    id,\tcontent\n1,\tChoosing a metric for your task\n\n**So you've trained your model and want to see how well it\u2019s doing on a dataset of your choice. Where do you start?**\n\nThere is no \u201cone size fits all\u201d approach to choosing an evaluation metric, but some good guidelines to keep in mind are:\n\n## Categories of metrics\n\nThere are 3 high-level categories of metrics:\n\n1. *Generic metrics*, which can be applied to a variety of situations and datasets, such as precision and accuracy.\n2. *Task-specific metrics*, which are limited to a given task, such as Machine Translation (often evaluated using metrics [BLEU](https://huggingface.co/metrics/bleu) or [ROUGE](https://huggingface.co/metrics/rouge)) or Named Entity Recognition (often evaluated with [seqeval](https://huggingface.co/metrics/seqeval)).\n3. *Dataset-specific metrics*, which aim to measure model performance on specific benchmarks: for instance, the [GLUE benchmark](https://huggingface.co/datasets/glue) has a dedicated [evaluation metric](https://huggingface.co/metrics/glue).\n\nLet's look at each of these three cases:\n\n### Generic metrics\n\nMany of the metrics used in the Machine Learning community are quite generic and can be applied in a variety of tasks and datasets.\n\nThis is the case for metrics like [accuracy](https://huggingface.co/metrics/accuracy) and [precision](https://huggingface.co/metrics/precision), which can be used for evaluating labeled (supervised) datasets, as well as [perplexity](https://huggingface.co/metrics/perplexity), which can be used for evaluating different kinds of (unsupervised) generative tasks.\n\nTo see the input structure of a given metric, you can look at its metric card. For example, in the case of [precision](https://huggingface.co/metrics/precision), the format is:\n```\n>>> precision_metric = evaluate.load(\"precision\")\n>>> results = precision_metric.compute(references=[0, 1], predictions=[0, 1])\n>>> print(results)\n{'precision': 1.0}\n```\n\n### Task-specific metrics\n\nPopular ML tasks like Machine Translation and Named Entity Recognition have specific metrics that can be used to compare models. For example, a series of different metrics have been proposed for text generation, ranging from [BLEU](https://huggingface.co/metrics/bleu) and its derivatives such as [GoogleBLEU](https://huggingface.co/metrics/google_bleu) and [GLEU](https://huggingface.co/metrics/gleu), but also [ROUGE](https://huggingface.co/metrics/rouge), [MAUVE](https://huggingface.co/metrics/mauve), etc.\n\nYou can find the right metric for your task by:\n\n- **Looking at the [Task pages](https://huggingface.co/tasks)** to see what metrics can be used for evaluating models for a given task.\n- **Checking out leaderboards** on sites like [Papers With Code](https://paperswithcode.com/) (you can search by task and by dataset).\n-  **Reading the metric cards** for the relevant metrics and see which ones are a good fit for your use case. For example, see the [BLEU metric card](https://github.com/huggingface/evaluate/tree/main/metrics/bleu) or [SQuaD metric card](https://github.com/huggingface/evaluate/tree/main/metrics/squad).\n- **Looking at papers and blog posts** published on the topic and see what metrics they report. This can change over time, so try to pick papers from the last couple of years!\n\n### Dataset-specific metrics\n\nSome datasets have specific metrics associated with them -- this is especially in the case of popular benchmarks like [GLUE](https://huggingface.co/metrics/glue) and [SQuAD](https://huggingface.co/metrics/squad).\n\n<Tip warning={true}>\n\ud83d\udca1\nGLUE is actually a collection of different subsets on different tasks, so first you need to choose the one that corresponds to the NLI task, such as mnli, which is described as \u201ccrowdsourced collection of sentence pairs with textual entailment annotations\u201d\n</Tip>\n\n\nIf you are evaluating your model on a benchmark dataset like the ones mentioned above, you can use its dedicated evaluation metric. Make sure you respect the format that they require. For example, to evaluate your model on the [SQuAD](https://huggingface.co/datasets/squad) dataset, you need to feed the `question` and `context` into your model and return the `prediction_text`, which should be compared with the `references` (based on matching the `id` of the question) :\n\n```\n>>> from evaluate import load\n>>> squad_metric = load(\"squad\")\n>>> predictions = [{'prediction_text': '1976', 'id': '56e10a3be3433e1400422b22'}]\n>>> references = [{'answers': {'answer_start': [97], 'text': ['1976']}, 'id': '56e10a3be3433e1400422b22'}]\n>>> results = squad_metric.compute(predictions=predictions, references=references)\n>>> results\n{'exact_match': 100.0, 'f1': 100.0}\n```\n\nYou can find examples of dataset structures by consulting the \"Dataset Preview\" function or the dataset card for a given dataset, and you can see how to use its dedicated evaluation function based on the metric card.\n2,\t=predictions, references=references)\n>>> results\n{'exact_match': 100.0, 'f1': 100.0}\n```\n\nYou can find examples of dataset structures by consulting the \"Dataset Preview\" function or the dataset card for a given dataset, and you can see how to use its dedicated evaluation function based on the metric card.\n3,\t\u4e0e\u5e38\u89c4\u51fd\u6570\u76f8\u540c\u7684\u65b9\u5f0f\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio\u3002\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\uff08\u865a\u62df\u7684\uff09\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5b83\u5728\u8f93\u51fa\u56fe\u50cf\u4e4b\u524d\u751f\u6210\u6570\u4e2a\u6b65\u9aa4\u7684\u566a\u97f3\uff1a\n\n$code_fake_diffusion\n$demo_fake_diffusion\n\n\u8bf7\u6ce8\u610f\uff0c\u6211\u4eec\u5728\u8fed\u4ee3\u5668\u4e2d\u6dfb\u52a0\u4e86 `time.sleep(1)`\uff0c\u4ee5\u521b\u5efa\u6b65\u9aa4\u4e4b\u95f4\u7684\u4eba\u5de5\u6682\u505c\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u89c2\u5bdf\u8fed\u4ee3\u5668\u7684\u6b65\u9aa4\uff08\u5728\u771f\u5b9e\u7684\u56fe\u50cf\u751f\u6210\u6a21\u578b\u4e2d\uff0c\u8fd9\u53ef\u80fd\u662f\u4e0d\u5fc5\u8981\u7684\uff09\u3002\n\n\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio **\u9700\u8981**\u5728\u5e95\u5c42 Interface \u6216 Blocks \u4e2d\u542f\u7528\u961f\u5217\uff08\u8bf7\u53c2\u9605\u4e0a\u9762\u7684\u961f\u5217\u90e8\u5206\uff09\u3002\n\n## \u8fdb\u5ea6\u6761\n\nGradio \u652f\u6301\u521b\u5efa\u81ea\u5b9a\u4e49\u8fdb\u5ea6\u6761\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u81ea\u5b9a\u4e49\u548c\u63a7\u5236\u5411\u7528\u6237\u663e\u793a\u7684\u8fdb\u5ea6\u66f4\u65b0\u3002\u8981\u542f\u7528\u6b64\u529f\u80fd\uff0c\u53ea\u9700\u4e3a\u65b9\u6cd5\u6dfb\u52a0\u4e00\u4e2a\u9ed8\u8ba4\u503c\u4e3a `gr.Progress` \u5b9e\u4f8b\u7684\u53c2\u6570\u5373\u53ef\u3002\u7136\u540e\uff0c\u60a8\u53ef\u4ee5\u76f4\u63a5\u8c03\u7528\u6b64\u5b9e\u4f8b\u5e76\u4f20\u5165 0 \u5230 1 \u4e4b\u95f4\u7684\u6d6e\u70b9\u6570\u6765\u66f4\u65b0\u8fdb\u5ea6\u7ea7\u522b\uff0c\u6216\u8005 with `Progress` \u5b9e\u4f8b\u7684 `tqdm()` \u65b9\u6cd5\u6765\u8ddf\u8e2a\u53ef\u8fed\u4ee3\u5bf9\u8c61\u4e0a\u7684\u8fdb\u5ea6\uff0c\u5982\u4e0b\u6240\u793a\u3002\u5fc5\u987b\u542f\u7528\u961f\u5217\u4ee5\u8fdb\u884c\u8fdb\u5ea6\u66f4\u65b0\u3002\n\n$code_progress_simple\n$demo_progress_simple\n\n\u5982\u679c\u60a8 with `tqdm` \u5e93\uff0c\u5e76\u4e14\u5e0c\u671b\u4ece\u51fd\u6570\u5185\u90e8\u7684\u4efb\u4f55 `tqdm.tqdm` \u81ea\u52a8\u62a5\u544a\u8fdb\u5ea6\u66f4\u65b0\uff0c\u8bf7\u5c06\u9ed8\u8ba4\u53c2\u6570\u8bbe\u7f6e\u4e3a `gr.Progress(track_tqdm=True)`\uff01\n\n## \u6279\u5904\u7406\u51fd\u6570 (Batch Functions)\n\nGradio \u652f\u6301\u4f20\u9012*\u6279\u5904\u7406*\u51fd\u6570\u3002\u6279\u5904\u7406\u51fd\u6570\u53ea\u662f\u63a5\u53d7\u8f93\u5165\u5217\u8868\u5e76\u8fd4\u56de\u9884\u6d4b\u5217\u8868\u7684\u51fd\u6570\u3002\n\n\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\u6279\u5904\u7406\u51fd\u6570\uff0c\u5b83\u63a5\u53d7\u4e24\u4e2a\u8f93\u5165\u5217\u8868\uff08\u4e00\u4e2a\u5355\u8bcd\u5217\u8868\u548c\u4e00\u4e2a\u6574\u6570\u5217\u8868\uff09\uff0c\u5e76\u8fd4\u56de\u4fee\u526a\u8fc7\u7684\u5355\u8bcd\u5217\u8868\u4f5c\u4e3a\u8f93\u51fa\uff1a\n\n```python\nimport time\n\ndef trim_words(words, lens):\n    trimmed_words = []\n    time.sleep(5)\n    for w, l in zip(words, lens):\n        trimmed_words.append(w[:int(l)])\n    return [trimmed_words]\n    for w, l in zip(words, lens):\n```\n\n\u4f7f\u7528\u6279\u5904\u7406\u51fd\u6570\u7684\u4f18\u70b9\u662f\uff0c\u5982\u679c\u542f\u7528\u4e86\u961f\u5217\uff0cGradio \u670d\u52a1\u5668\u53ef\u4ee5\u81ea\u52a8*\u6279\u5904\u7406*\u4f20\u5165\u7684\u8bf7\u6c42\u5e76\u5e76\u884c\u5904\u7406\u5b83\u4eec\uff0c\u4ece\u800c\u53ef\u80fd\u52a0\u5feb\u6f14\u793a\u901f\u5ea6\u3002\u4ee5\u4e0b\u662f Gradio \u4ee3\u7801\u7684\u793a\u4f8b\uff08\u8bf7\u6ce8\u610f `batch=True` \u548c `max_batch_size=16` - \u8fd9\u4e24\u4e2a\u53c2\u6570\u90fd\u53ef\u4ee5\u4f20\u9012\u7ed9\u4e8b\u4ef6\u89e6\u53d1\u5668\u6216 `Interface` \u7c7b\uff09\n\nwith `Interface`\uff1a\n\n```python\ndemo = gr.Interface(trim_words, [\"textbox\", \"number\"], [\"output\"],\n                    batch=True, max_batch_size=16)\ndemo.queue()\ndemo.launch()\n```\n\nwith `Blocks`\uff1a\n\n```python\nimport gradio as gr\n\nwith gr.Blocks() as demo:\n    with gr.Row():\n        word = gr.Textbox(label=\"word\")\n        leng = gr.Number(label=\"leng\")\n        output = gr.Textbox(label=\"Output\")\n    with gr.Row():\n        run = gr.Button()\n\n    event = run.click(trim_words, [word, leng], output, batch=True, max_batch_size=16)\n\ndemo.queue()\ndemo.launch()\n```\n\n\u5728\u4e0a\u9762\u7684\u793a\u4f8b\u4e2d\uff0c\u53ef\u4ee5\u5e76\u884c\u5904\u7406 16 \u4e2a\u8bf7\u6c42\uff08\u603b\u63a8\u7406\u65f6\u95f4\u4e3a 5 \u79d2\uff09\uff0c\u800c\u4e0d\u662f\u5206\u522b\u5904\u7406\u6bcf\u4e2a\u8bf7\u6c42\uff08\u603b\u63a8\u7406\u65f6\u95f4\u4e3a 80 \u79d2\uff09\u3002\u8bb8\u591a Hugging Face \u7684 `transformers` \u548c `diffusers` \u6a21\u578b\u5728 Gradio \u7684\u6279\u5904\u7406\u6a21\u5f0f\u4e0b\u81ea\u7136\u5de5\u4f5c\uff1a\u8fd9\u662f[\u4f7f\u7528\u6279\u5904\u7406\u751f\u6210\u56fe\u50cf\u7684\u793a\u4f8b\u6f14\u793a](https://github.com/gradio-app/gradio/blob/main/demo/diffusers_with_batching/run.py)\n\n\u6ce8\u610f\uff1a\u4f7f\u7528 Gradio \u7684\u6279\u5904\u7406\u51fd\u6570 **requires** \u5728\u5e95\u5c42 Interface \u6216 Blocks \u4e2d\u542f\u7528\u961f\u5217\uff08\u8bf7\u53c2\u9605\u4e0a\u9762\u7684\u961f\u5217\u90e8\u5206\uff09\u3002\n\n## Gradio \u7b14\u8bb0\u672c (Colab Notebooks)\n\nGradio \u53ef\u4ee5\u5728\u4efb\u4f55\u8fd0\u884c Python \u7684\u5730\u65b9\u8fd0\u884c\uff0c\u5305\u62ec\u672c\u5730 Jupyter \u7b14\u8bb0\u672c\u548c\u534f\u4f5c\u7b14\u8bb0\u672c\uff0c\u5982[Google Colab](https://colab.research.google.com/)\u3002\u5bf9\u4e8e\u672c\u5730 Jupyter \u7b14\u8bb0\u672c\u548c Google Colab \u7b14\u8bb0\u672c\uff0cGradio \u5728\u672c\u5730\u670d\u52a1\u5668\u4e0a\u8fd0\u884c\uff0c\u60a8\u53ef\u4ee5\u5728\u6d4f\u89c8\u5668\u4e2d\u4e0e\u4e4b\u4ea4\u4e92\u3002\uff08\u6ce8\u610f\uff1a\u5bf9\u4e8e Google Colab\uff0c\u8fd9\u662f\u901a\u8fc7[\u670d\u52a1\u5de5\u4f5c\u5668\u96a7\u9053](https://github.com/tensorflow/tensorboard/blob/master/docs/design/colab_integration.md)\u5b9e\u73b0\u7684\uff0c\u60a8\u7684\u6d4f\u89c8\u5668\u9700\u8981\u542f\u7528 cookies\u3002\uff09\u5bf9\u4e8e\u5176\u4ed6\u8fdc\u7a0b\u7b14\u8bb0\u672c\uff0cGradio \u4e5f\u5c06\u5728\u670d\u52a1\u5668\u4e0a\u8fd0\u884c\uff0c\u4f46\u60a8\u9700\u8981\u4f7f\u7528[SSH \u96a7\u9053](https://coderwall.com/p/ohk6cg/remote-access-to-ipython-notebooks-via-ssh)\u5728\u672c\u5730\u6d4f\u89c8\u5668\u4e2d\u67e5\u770b\u5e94\u7528\u7a0b\u5e8f\u3002\u901a\u5e38\uff0c\u66f4\u7b80\u5355\u7684\u9009\u62e9\u662f\u4f7f\u7528 Gradio \u5185\u7f6e\u7684\u516c\u5171\u94fe\u63a5\uff0c[\u5728\u4e0b\u4e00\u7bc7\u6307\u5357\u4e2d\u8ba8\u8bba](/sharing-your-app/#sharing-demos)\u3002\n4,\t\u65f6\u5fc5\u987b\u9009\u62e9\u5176\u4e2d\u4e00\u4e2a\u5b57\u7b26\u4e32\uff0c\u8fd9\u5c06\u4f5c\u4e3a\u9644\u52a0\u5217\u4fdd\u5b58\u5230 CSV \u4e2d\u3002\n\n## \u9884\u5904\u7406\u548c\u540e\u5904\u7406 (Preprocessing and Postprocessing)\n\n![annotated](/assets/img/dataflow.svg)\n\n\u5982\u60a8\u6240\u89c1\uff0cGradio \u5305\u62ec\u53ef\u4ee5\u5904\u7406\u5404\u79cd\u4e0d\u540c\u6570\u636e\u7c7b\u578b\u7684\u7ec4\u4ef6\uff0c\u4f8b\u5982\u56fe\u50cf\u3001\u97f3\u9891\u548c\u89c6\u9891\u3002\u5927\u591a\u6570\u7ec4\u4ef6\u90fd\u53ef\u4ee5\u7528\u4f5c\u8f93\u5165\u6216\u8f93\u51fa\u3002\n\n\u5f53\u7ec4\u4ef6\u7528\u4f5c\u8f93\u5165\u65f6\uff0cGradio \u81ea\u52a8\u5904\u7406*\u9884\u5904\u7406*\uff0c\u5c06\u6570\u636e\u4ece\u7528\u6237\u6d4f\u89c8\u5668\u53d1\u9001\u7684\u7c7b\u578b\uff08\u4f8b\u5982\u7f51\u7edc\u6444\u50cf\u5934\u5feb\u7167\u7684 base64 \u8868\u793a\uff09\u8f6c\u6362\u4e3a\u60a8\u7684\u51fd\u6570\u53ef\u4ee5\u63a5\u53d7\u7684\u5f62\u5f0f\uff08\u4f8b\u5982 `numpy` \u6570\u7ec4\uff09\u3002\n\n\u540c\u6837\uff0c\u5f53\u7ec4\u4ef6\u7528\u4f5c\u8f93\u51fa\u65f6\uff0cGradio \u81ea\u52a8\u5904\u7406*\u540e\u5904\u7406*\uff0c\u5c06\u6570\u636e\u4ece\u51fd\u6570\u8fd4\u56de\u7684\u5f62\u5f0f\uff08\u4f8b\u5982\u56fe\u50cf\u8def\u5f84\u5217\u8868\uff09\u8f6c\u6362\u4e3a\u53ef\u4ee5\u5728\u7528\u6237\u6d4f\u89c8\u5668\u4e2d\u663e\u793a\u7684\u5f62\u5f0f\uff08\u4f8b\u5982\u4ee5 base64 \u683c\u5f0f\u663e\u793a\u56fe\u50cf\u7684 `Gallery`\uff09\u3002\n\n\u60a8\u53ef\u4ee5\u4f7f\u7528\u6784\u5efa\u56fe\u50cf\u7ec4\u4ef6\u65f6\u7684\u53c2\u6570\u63a7\u5236*\u9884\u5904\u7406*\u3002\u4f8b\u5982\uff0c\u5982\u679c\u60a8\u4f7f\u7528\u4ee5\u4e0b\u53c2\u6570\u5b9e\u4f8b\u5316 `Image` \u7ec4\u4ef6\uff0c\u5b83\u5c06\u5c06\u56fe\u50cf\u8f6c\u6362\u4e3a `PIL` \u7c7b\u578b\uff0c\u5e76\u5c06\u5176\u91cd\u5851\u4e3a`(100, 100)`\uff0c\u800c\u4e0d\u7ba1\u63d0\u4ea4\u65f6\u7684\u539f\u59cb\u5927\u5c0f\u5982\u4f55\uff1a\n\n```py\nimg = gr.Image(shape=(100, 100), type=\"pil\")\n```\n\n\u76f8\u53cd\uff0c\u8fd9\u91cc\u6211\u4eec\u4fdd\u7559\u56fe\u50cf\u7684\u539f\u59cb\u5927\u5c0f\uff0c\u4f46\u5728\u5c06\u5176\u8f6c\u6362\u4e3a numpy \u6570\u7ec4\u4e4b\u524d\u53cd\u8f6c\u989c\u8272\uff1a\n\n```py\nimg = gr.Image(invert_colors=True, type=\"numpy\")\n```\n\n\u540e\u5904\u7406\u8981\u5bb9\u6613\u5f97\u591a\uff01Gradio \u81ea\u52a8\u8bc6\u522b\u8fd4\u56de\u6570\u636e\u7684\u683c\u5f0f\uff08\u4f8b\u5982 `Image` \u662f `numpy` \u6570\u7ec4\u8fd8\u662f `str` \u6587\u4ef6\u8def\u5f84\uff1f\uff09\uff0c\u5e76\u5c06\u5176\u540e\u5904\u7406\u4e3a\u53ef\u4ee5\u7531\u6d4f\u89c8\u5668\u663e\u793a\u7684\u683c\u5f0f\u3002\n\n\u8bf7\u67e5\u770b[\u6587\u6863](https://gradio.app/docs)\uff0c\u4e86\u89e3\u6bcf\u4e2a\u7ec4\u4ef6\u7684\u6240\u6709\u4e0e\u9884\u5904\u7406\u76f8\u5173\u7684\u53c2\u6570\u3002\n\n## \u6837\u5f0f (Styling)\n\nGradio \u4e3b\u9898\u662f\u81ea\u5b9a\u4e49\u5e94\u7528\u7a0b\u5e8f\u5916\u89c2\u548c\u611f\u89c9\u7684\u6700\u7b80\u5355\u65b9\u6cd5\u3002\u60a8\u53ef\u4ee5\u9009\u62e9\u591a\u79cd\u4e3b\u9898\u6216\u521b\u5efa\u81ea\u5df1\u7684\u4e3b\u9898\u3002\u8981\u8fd9\u6837\u505a\uff0c\u8bf7\u5c06 `theme=` \u53c2\u6570\u4f20\u9012\u7ed9 `Interface` \u6784\u9020\u51fd\u6570\u3002\u4f8b\u5982\uff1a\n\n```python\ndemo = gr.Interface(..., theme=gr.themes.Monochrome())\n```\n\nGradio \u5e26\u6709\u4e00\u7ec4\u9884\u5148\u6784\u5efa\u7684\u4e3b\u9898\uff0c\u60a8\u53ef\u4ee5\u4ece `gr.themes.*` \u52a0\u8f7d\u3002\u60a8\u53ef\u4ee5\u6269\u5c55\u8fd9\u4e9b\u4e3b\u9898\u6216\u4ece\u5934\u5f00\u59cb\u521b\u5efa\u81ea\u5df1\u7684\u4e3b\u9898 - \u6709\u5173\u66f4\u591a\u8be6\u7ec6\u4fe1\u606f\uff0c\u8bf7\u53c2\u9605[\u4e3b\u9898\u6307\u5357](https://gradio.app/theming-guide)\u3002\n\n\u8981\u589e\u52a0\u989d\u5916\u7684\u6837\u5f0f\u80fd\u529b\uff0c\u60a8\u53ef\u4ee5 with `css=` \u5173\u952e\u5b57\u5c06\u4efb\u4f55 CSS \u4f20\u9012\u7ed9\u60a8\u7684\u5e94\u7528\u7a0b\u5e8f\u3002\nGradio \u5e94\u7528\u7a0b\u5e8f\u7684\u57fa\u7c7b\u662f `gradio-container`\uff0c\u56e0\u6b64\u4ee5\u4e0b\u662f\u4e00\u4e2a\u66f4\u6539 Gradio \u5e94\u7528\u7a0b\u5e8f\u80cc\u666f\u989c\u8272\u7684\u793a\u4f8b\uff1a\n\n```python\nwith `gr.Interface(css=\".gradio-container {background-color: red}\") as demo:\n    ...\n```\n\n## \u961f\u5217 (Queuing)\n\n\u5982\u679c\u60a8\u7684\u5e94\u7528\u7a0b\u5e8f\u9884\u8ba1\u4f1a\u6709\u5927\u91cf\u6d41\u91cf\uff0c\u8bf7 with `queue()` \u65b9\u6cd5\u6765\u63a7\u5236\u5904\u7406\u901f\u7387\u3002\u8fd9\u5c06\u6392\u961f\u5904\u7406\u8c03\u7528\uff0c\u56e0\u6b64\u4e00\u6b21\u53ea\u5904\u7406\u4e00\u5b9a\u6570\u91cf\u7684\u8bf7\u6c42\u3002\u961f\u5217\u4f7f\u7528 Websockets\uff0c\u8fd8\u53ef\u4ee5\u9632\u6b62\u7f51\u7edc\u8d85\u65f6\uff0c\u56e0\u6b64\u5982\u679c\u60a8\u7684\u51fd\u6570\u7684\u63a8\u7406\u65f6\u95f4\u5f88\u957f\uff08> 1 \u5206\u949f\uff09\uff0c\u5e94\u4f7f\u7528\u961f\u5217\u3002\n\nwith `Interface`\uff1a\n\n```python\ndemo = gr.Interface(...).queue()\ndemo.launch()\n```\n\nwith `Blocks`\uff1a\n\n```python\nwith gr.Blocks() as demo\uff1a\n    #...\ndemo.queue()\ndemo.launch()\n```\n\n\u60a8\u53ef\u4ee5\u901a\u8fc7\u4ee5\u4e0b\u65b9\u5f0f\u63a7\u5236\u4e00\u6b21\u5904\u7406\u7684\u8bf7\u6c42\u6570\u91cf\uff1a\n\n```python\ndemo.queue(concurrency_count=3)\n```\n\n\u67e5\u770b\u6709\u5173\u914d\u7f6e\u5176\u4ed6\u961f\u5217\u53c2\u6570\u7684[\u961f\u5217\u6587\u6863](/docs/#queue)\u3002\n\n\u5728 Blocks \u4e2d\u6307\u5b9a\u4ec5\u5bf9\u67d0\u4e9b\u51fd\u6570\u8fdb\u884c\u6392\u961f\uff1a\n\n```python\nwith gr.Blocks() as demo2\uff1a\n    num1 = gr.Number()\n    num2 = gr.Number()\n    output = gr.Number()\n    gr.Button(\"Add\").click(\n        lambda a, b: a + b, [num1, num2], output)\n    gr.Button(\"Multiply\").click(\n        lambda a, b: a * b, [num1, num2], output, queue=True)\ndemo2.launch()\n```\n\n## \u8fed\u4ee3\u8f93\u51fa (Iterative Outputs)\n\n\u5728\u67d0\u4e9b\u60c5\u51b5\u4e0b\uff0c\u60a8\u53ef\u80fd\u9700\u8981\u4f20\u8f93\u4e00\u7cfb\u5217\u8f93\u51fa\u800c\u4e0d\u662f\u4e00\u6b21\u663e\u793a\u5355\u4e2a\u8f93\u51fa\u3002\u4f8b\u5982\uff0c\u60a8\u53ef\u80fd\u6709\u4e00\u4e2a\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5e0c\u671b\u663e\u793a\u751f\u6210\u7684\u6bcf\u4e2a\u6b65\u9aa4\u7684\u56fe\u50cf\uff0c\u76f4\u5230\u6700\u7ec8\u56fe\u50cf\u3002\u6216\u8005\u60a8\u53ef\u80fd\u6709\u4e00\u4e2a\u804a\u5929\u673a\u5668\u4eba\uff0c\u5b83\u9010\u5b57\u9010\u53e5\u5730\u6d41\u5f0f\u4f20\u8f93\u54cd\u5e94\uff0c\u800c\u4e0d\u662f\u4e00\u6b21\u8fd4\u56de\u5168\u90e8\u54cd\u5e94\u3002\n\n\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u60a8\u53ef\u4ee5\u5c06**\u751f\u6210\u5668**\u51fd\u6570\u63d0\u4f9b\u7ed9 Gradio\uff0c\u800c\u4e0d\u662f\u5e38\u89c4\u51fd\u6570\u3002\u5728 Python \u4e2d\u521b\u5efa\u751f\u6210\u5668\u975e\u5e38\u7b80\u5355\uff1a\u51fd\u6570\u4e0d\u5e94\u8be5\u6709\u4e00\u4e2a\u5355\u72ec\u7684 `return` \u503c\uff0c\u800c\u662f\u5e94\u8be5 with `yield` \u8fde\u7eed\u8fd4\u56de\u4e00\u7cfb\u5217\u503c\u3002\u901a\u5e38\uff0c`yield` \u8bed\u53e5\u653e\u7f6e\u5728\u67d0\u79cd\u5faa\u73af\u4e2d\u3002\u4e0b\u9762\u662f\u4e00\u4e2a\u7b80\u5355\u793a\u4f8b\uff0c\u751f\u6210\u5668\u53ea\u662f\u7b80\u5355\u8ba1\u6570\u5230\u7ed9\u5b9a\u6570\u5b57\uff1a\n\n```python\ndef my_generator(x):\n    for i in range(x):\n        yield i\n```\n\n\u60a8\u4ee5\u4e0e\u5e38\u89c4\u51fd\u6570\u76f8\u540c\u7684\u65b9\u5f0f\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio\u3002\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\uff08\u865a\u62df\u7684\uff09\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5b83\u5728\u8f93\u51fa\u56fe\u50cf\u4e4b\u524d\u751f\u6210\u6570\u4e2a\u6b65\u9aa4\u7684\u566a\u97f3\uff1a\n\n$code_fake_diffusion\n$demo_fake_diffusion\n\n\u8bf7\u6ce8\u610f\uff0c\u6211\u4eec\u5728\u8fed\u4ee3\u5668\u4e2d\u6dfb\u52a0\u4e86 `time.sleep(1)`\uff0c\u4ee5\u521b\u5efa\u6b65\u9aa4\u4e4b\u95f4\u7684\u4eba\u5de5\u6682\u505c\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u89c2\u5bdf\u8fed\u4ee3\u5668\u7684\u6b65\u9aa4\uff08\u5728\u771f\u5b9e\u7684\u56fe\u50cf\u751f\u6210\u6a21\u578b\u4e2d\uff0c\u8fd9\n    ```",
            "vector_context": "[Created at: 2025-03-24 13:16:13]\n=predictions, references=references)\n>>> results\n{'exact_match': 100.0, 'f1': 100.0}\n```\n\nYou can find examples of dataset structures by consulting the \"Dataset Preview\" function or the dataset card for a given dataset, and you can see how to use its dedicated evaluation function based on the metric card.\n--New Chunk--\n[Created at: 2025-03-24 13:18:21]\nGradio Demo: blocks_random_slider\n\n\n```\n!pip install -q gradio \n```\n\n\n```\n\nimport gradio as gr\n\n\ndef func(slider_1, slider_2):\n    return slider_1 * 5 + slider_2\n\n\nwith gr.Blocks() as demo:\n    slider = gr.Slider(minimum=-10.2, maximum=15, label=\"Random Slider (Static)\", randomize=True)\n    slider_1 = gr.Slider(minimum=100, maximum=200, label=\"Random Slider (Input 1)\", randomize=True)\n    slider_2 = gr.Slider(minimum=10, maximum=23.2, label=\"Random Slider (Input 2)\", randomize=True)\n    slider_3 = gr.Slider(value=3, label=\"Non random slider\")\n    btn = gr.Button(\"Run\")\n    btn.click(func, inputs=[slider_1, slider_2], outputs=gr.Number())\n\nif __name__ == \"__main__\":\n    demo.launch()\n\n```\n--New Chunk--\n[Created at: 2025-03-24 13:16:48]\n\u4e0e\u5e38\u89c4\u51fd\u6570\u76f8\u540c\u7684\u65b9\u5f0f\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio\u3002\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\uff08\u865a\u62df\u7684\uff09\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5b83\u5728\u8f93\u51fa\u56fe\u50cf\u4e4b\u524d\u751f\u6210\u6570\u4e2a\u6b65\u9aa4\u7684\u566a\u97f3\uff1a\n\n$code_fake_diffusion\n$demo_fake_diffusion\n\n\u8bf7\u6ce8\u610f\uff0c\u6211\u4eec\u5728\u8fed\u4ee3\u5668\u4e2d\u6dfb\u52a0\u4e86 `time.sleep(1)`\uff0c\u4ee5\u521b\u5efa\u6b65\u9aa4\u4e4b\u95f4\u7684\u4eba\u5de5\u6682\u505c\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u89c2\u5bdf\u8fed\u4ee3\u5668\u7684\u6b65\u9aa4\uff08\u5728\u771f\u5b9e\u7684\u56fe\u50cf\u751f\u6210\u6a21\u578b\u4e2d\uff0c\u8fd9\u53ef\u80fd\u662f\u4e0d\u5fc5\u8981\u7684\uff09\u3002\n\n\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio **\u9700\u8981**\u5728\u5e95\u5c42 Interface \u6216 Blocks \u4e2d\u542f\u7528\u961f\u5217\uff08\u8bf7\u53c2\u9605\u4e0a\u9762\u7684\u961f\u5217\u90e8\u5206\uff09\u3002\n\n## \u8fdb\u5ea6\u6761\n\nGradio \u652f\u6301\u521b\u5efa\u81ea\u5b9a\u4e49\u8fdb\u5ea6\u6761\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u81ea\u5b9a\u4e49\u548c\u63a7\u5236\u5411\u7528\u6237\u663e\u793a\u7684\u8fdb\u5ea6\u66f4\u65b0\u3002\u8981\u542f\u7528\u6b64\u529f\u80fd\uff0c\u53ea\u9700\u4e3a\u65b9\u6cd5\u6dfb\u52a0\u4e00\u4e2a\u9ed8\u8ba4\u503c\u4e3a `gr.Progress` \u5b9e\u4f8b\u7684\u53c2\u6570\u5373\u53ef\u3002\u7136\u540e\uff0c\u60a8\u53ef\u4ee5\u76f4\u63a5\u8c03\u7528\u6b64\u5b9e\u4f8b\u5e76\u4f20\u5165 0 \u5230 1 \u4e4b\u95f4\u7684\u6d6e\u70b9\u6570\u6765\u66f4\u65b0\u8fdb\u5ea6\u7ea7\u522b\uff0c\u6216\u8005 with `Progress` \u5b9e\u4f8b\u7684 `tqdm()` \u65b9\u6cd5\u6765\u8ddf\u8e2a\u53ef\u8fed\u4ee3\u5bf9\u8c61\u4e0a\u7684\u8fdb\u5ea6\uff0c\u5982\u4e0b\u6240\u793a\u3002\u5fc5\u987b\u542f\u7528\u961f\u5217\u4ee5\u8fdb\u884c\u8fdb\u5ea6\u66f4\u65b0\u3002\n\n$code_progress_simple\n$demo_progress_simple\n\n\u5982\u679c\u60a8 with `tqdm` \u5e93\uff0c\u5e76\u4e14\u5e0c\u671b\u4ece\u51fd\u6570\u5185\u90e8\u7684\u4efb\u4f55 `tqdm.tqdm` \u81ea\u52a8\u62a5\u544a\u8fdb\u5ea6\u66f4\u65b0\uff0c\u8bf7\u5c06\u9ed8\u8ba4\u53c2\u6570\u8bbe\u7f6e\u4e3a `gr.Progress(track_tqdm=True)`\uff01\n\n## \u6279\u5904\u7406\u51fd\u6570 (Batch Functions)\n\nGradio \u652f\u6301\u4f20\u9012*\u6279\u5904\u7406*\u51fd\u6570\u3002\u6279\u5904\u7406\u51fd\u6570\u53ea\u662f\u63a5\u53d7\u8f93\u5165\u5217\u8868\u5e76\u8fd4\u56de\u9884\u6d4b\u5217\u8868\u7684\u51fd\u6570\u3002\n\n\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\u6279\u5904\u7406\u51fd\u6570\uff0c\u5b83\u63a5\u53d7\u4e24\u4e2a\u8f93\u5165\u5217\u8868\uff08\u4e00\u4e2a\u5355\u8bcd\u5217\u8868\u548c\u4e00\u4e2a\u6574\u6570\u5217\u8868\uff09\uff0c\u5e76\u8fd4\u56de\u4fee\u526a\u8fc7\u7684\u5355\u8bcd\u5217\u8868\u4f5c\u4e3a\u8f93\u51fa\uff1a\n\n```python\nimport time\n\ndef trim_words(words, lens):\n    trimmed_words = []\n    time.sleep(5)\n    for w, l in zip(words, lens):\n        trimmed_words.append(w[:int(l)])\n    return [trimmed_words]\n    for w, l in zip(words, lens):\n```\n\n\u4f7f\u7528\u6279\u5904\u7406\u51fd\u6570\u7684\u4f18\u70b9\u662f\uff0c\u5982\u679c\u542f\u7528\u4e86\u961f\u5217\uff0cGradio \u670d\u52a1\u5668\u53ef\u4ee5\u81ea\u52a8*\u6279\u5904\u7406*\u4f20\u5165\u7684\u8bf7\u6c42\u5e76\u5e76\u884c\u5904\u7406\u5b83\u4eec\uff0c\u4ece\u800c\u53ef\u80fd\u52a0\u5feb\u6f14\u793a\u901f\u5ea6\u3002\u4ee5\u4e0b\u662f Gradio \u4ee3\u7801\u7684\u793a\u4f8b\uff08\u8bf7\u6ce8\u610f `batch=True` \u548c `max_batch_size=16` - \u8fd9\u4e24\u4e2a\u53c2\u6570\u90fd\u53ef\u4ee5\u4f20\u9012\u7ed9\u4e8b\u4ef6\u89e6\u53d1\u5668\u6216 `Interface` \u7c7b\uff09\n\nwith `Interface`\uff1a\n\n```python\ndemo = gr.Interface(trim_words, [\"textbox\", \"number\"], [\"output\"],\n                    batch=True, max_batch_size=16)\ndemo.queue()\ndemo.launch()\n```\n\nwith `Blocks`\uff1a\n\n```python\nimport gradio as gr\n\nwith gr.Blocks() as demo:\n    with gr.Row():\n        word = gr.Textbox(label=\"word\")\n        leng = gr.Number(label=\"leng\")\n        output = gr.Textbox(label=\"Output\")\n    with gr.Row():\n        run = gr.Button()\n\n    event = run.click(trim_words, [word, leng], output, batch=True, max_batch_size=16)\n\ndemo.queue()\ndemo.launch()\n```\n\n\u5728\u4e0a\u9762\u7684\u793a\u4f8b\u4e2d\uff0c\u53ef\u4ee5\u5e76\u884c\u5904\u7406 16 \u4e2a\u8bf7\u6c42\uff08\u603b\u63a8\u7406\u65f6\u95f4\u4e3a 5 \u79d2\uff09\uff0c\u800c\u4e0d\u662f\u5206\u522b\u5904\u7406\u6bcf\u4e2a\u8bf7\u6c42\uff08\u603b\u63a8\u7406\u65f6\u95f4\u4e3a 80 \u79d2\uff09\u3002\u8bb8\u591a Hugging Face \u7684 `transformers` \u548c `diffusers` \u6a21\u578b\u5728 Gradio \u7684\u6279\u5904\u7406\u6a21\u5f0f\u4e0b\u81ea\u7136\u5de5\u4f5c\uff1a\u8fd9\u662f[\u4f7f\u7528\u6279\u5904\u7406\u751f\u6210\u56fe\u50cf\u7684\u793a\u4f8b\u6f14\u793a](https://github.com/gradio-app/gradio/blob/main/demo/diffusers_with_batching/run.py)\n\n\u6ce8\u610f\uff1a\u4f7f\u7528 Gradio \u7684\u6279\u5904\u7406\u51fd\u6570 **requires** \u5728\u5e95\u5c42 Interface \u6216 Blocks \u4e2d\u542f\u7528\u961f\u5217\uff08\u8bf7\u53c2\u9605\u4e0a\u9762\u7684\u961f\u5217\u90e8\u5206\uff09\u3002\n\n## Gradio \u7b14\u8bb0\u672c (Colab Notebooks)\n\nGradio \u53ef\u4ee5\u5728\u4efb\u4f55\u8fd0\u884c Python \u7684\u5730\u65b9\u8fd0\u884c\uff0c\u5305\u62ec\u672c\u5730 Jupyter \u7b14\u8bb0\u672c\u548c\u534f\u4f5c\u7b14\u8bb0\u672c\uff0c\u5982[Google Colab](https://colab.research.google.com/)\u3002\u5bf9\u4e8e\u672c\u5730 Jupyter \u7b14\u8bb0\u672c\u548c Google Colab \u7b14\u8bb0\u672c\uff0cGradio \u5728\u672c\u5730\u670d\u52a1\u5668\u4e0a\u8fd0\u884c\uff0c\u60a8\u53ef\u4ee5\u5728\u6d4f\u89c8\u5668\u4e2d\u4e0e\u4e4b\u4ea4\u4e92\u3002\uff08\u6ce8\u610f\uff1a\u5bf9\u4e8e Google Colab\uff0c\u8fd9\u662f\u901a\u8fc7[\u670d\u52a1\u5de5\u4f5c\u5668\u96a7\u9053](https://github.com/tensorflow/tensorboard/blob/master/docs/design/colab_integration.md)\u5b9e\u73b0\u7684\uff0c\u60a8\u7684\u6d4f\u89c8\u5668\u9700\u8981\u542f\u7528 cookies\u3002\uff09\u5bf9\u4e8e\u5176\u4ed6\u8fdc\u7a0b\u7b14\u8bb0\u672c\uff0cGradio \u4e5f\u5c06\u5728\u670d\u52a1\u5668\u4e0a\u8fd0\u884c\uff0c\u4f46\u60a8\u9700\u8981\u4f7f\u7528[SSH \u96a7\u9053](https://coderwall.com/p/ohk6cg/remote-access-to-ipython-notebooks-via-ssh)\u5728\u672c\u5730\u6d4f\u89c8\u5668\u4e2d\u67e5\u770b\u5e94\u7528\u7a0b\u5e8f\u3002\u901a\u5e38\uff0c\u66f4\u7b80\u5355\u7684\u9009\u62e9\u662f\u4f7f\u7528 Gradio \u5185\u7f6e\u7684\u516c\u5171\u94fe\u63a5\uff0c[\u5728\u4e0b\u4e00\u7bc7\u6307\u5357\u4e2d\u8ba8\u8bba](/sharing-your-app/#sharing-demos)\u3002"
        }
    },
    {
        "sample_idx": 20,
        "question": "What are the two metrics returned by the 'compute' function in the example code?",
        "answer": "exact_match and f1",
        "rag_answer": "The two metrics returned by the 'compute' function in the example code are 'exact_match' and 'f1'. These metrics are commonly used to evaluate the performance of a model, with 'exact_match' measuring the proportion of predictions that exactly match the references, and 'f1' measuring the harmonic mean of precision and recall.",
        "rag_score": 5,
        "rag_feedback": "The system's response is completely correct, accurate, and factual. It correctly identifies the two metrics returned by the 'compute' function in the example code as 'exact_match' and 'f1', and provides additional context and explanations about these metrics.",
        "rag_context": {
            "kg_context": "-----Entities-----\n    ```csv\n    id,\tentity,\ttype,\tdescription,\trankcreated_at\n1,\tModel,category,Model refers to a machine learning model being evaluated.,3,2025-03-24 13:20:24\n2,\tPredictions,category,Predictions are the outcome of a model's performance.,2,2025-03-24 13:20:24\n3,\tEvaluation Function,category,Evaluation Function is a tool used to assess the performance of a model.,2,2025-03-24 13:20:24\n4,\tResults,event,Results are the outcome of evaluating a model, in this case, showing perfect accuracy.,1,2025-03-24 13:20:24\n5,\tguess_letter,event,guess_letter is a function in the hangman game that updates the state of used letters.,2,2025-03-24 13:20:24\n6,\tused_letters_var,category,used_letters_var is a variable that stores the used letters in the hangman game.,1,2025-03-24 13:20:24\n7,\tEvaluation Function,category,Evaluation Function is a tool used to assess the performance of a model.,2,UNKNOWN\n8,\tResults,event,Results are the outcome of evaluating a model, in this case, showing perfect accuracy.,1,UNKNOWN\n9,\tfunc,event,func is an event that occurs when the button is clicked, executing a specific function.,1,UNKNOWN\n    ```\n    -----Relationships-----\n    ```csv\n    id,\tsource,\ttarget,\tdescription,\tkeywords,\tweight,\trank,\tcreated_at\n1,\tModel,Predictions,The model makes predictions based on the input data.,model output, predictions,8.0,5,2025-03-24 13:16:48\n2,\tEvaluation Function,Results,The results are obtained by using the evaluation function.,evaluation outcome, accuracy,20.0,3,2025-03-24 13:16:48\n3,\tguess_letter,used_letters_var,used_letters_var is updated by the guess_letter function.,variable update, game logic,8.0,3,2025-03-24 13:20:24\n4,\tGradio Demo,func,func is an event that occurs in Gradio Demo when the button is clicked.,event, event,8.0,9,UNKNOWN\n5,\tEvaluation Function,Model,The evaluation function is used to assess the performance of the model.,model evaluation, performance assessment,18.0,5,UNKNOWN\n6,\tEvaluation Function,Results,The results are obtained by using the evaluation function.,evaluation outcome, accuracy,20.0,3,UNKNOWN\n    ```\n    -----Sources-----\n    ```csv\n    id,\tcontent\n1,\t=predictions, references=references)\n>>> results\n{'exact_match': 100.0, 'f1': 100.0}\n```\n\nYou can find examples of dataset structures by consulting the \"Dataset Preview\" function or the dataset card for a given dataset, and you can see how to use its dedicated evaluation function based on the metric card.\n2,\tState in Blocks\n\nWe covered [State in Interfaces](https://gradio.app/interface-state), this guide takes a look at state in Blocks, which works mostly the same.\n\n## Global State\n\nGlobal state in Blocks works the same as in Interface. Any variable created outside a function call is a reference shared between all users.\n\n## Session State\n\nGradio supports session **state**, where data persists across multiple submits within a page session, in Blocks apps as well. To reiterate, session data is _not_ shared between different users of your model. To store data in a session state, you need to do three things:\n\n1. Create a `gr.State()` object. If there is a default value to this stateful object, pass that into the constructor.\n2. In the event listener, put the `State` object as an input and output.\n3. In the event listener function, add the variable to the input parameters and the return value.\n\nLet's take a look at a game of hangman.\n\n$code_hangman\n$demo_hangman\n\nLet's see how we do each of the 3 steps listed above in this game:\n\n1. We store the used letters in `used_letters_var`. In the constructor of `State`, we set the initial value of this to `[]`, an empty list.\n2. In `btn.click()`, we have a reference to `used_letters_var` in both the inputs and outputs.\n3. In `guess_letter`, we pass the value of this `State` to `used_letters`, and then return an updated value of this `State` in the return statement.\n\nWith more complex apps, you will likely have many State variables storing session state in a single Blocks app.\n\nLearn more about `State` in the [docs](https://gradio.app/docs#state).\n3,\tGradio Demo: blocks_random_slider\n\n\n```\n!pip install -q gradio \n```\n\n\n```\n\nimport gradio as gr\n\n\ndef func(slider_1, slider_2):\n    return slider_1 * 5 + slider_2\n\n\nwith gr.Blocks() as demo:\n    slider = gr.Slider(minimum=-10.2, maximum=15, label=\"Random Slider (Static)\", randomize=True)\n    slider_1 = gr.Slider(minimum=100, maximum=200, label=\"Random Slider (Input 1)\", randomize=True)\n    slider_2 = gr.Slider(minimum=10, maximum=23.2, label=\"Random Slider (Input 2)\", randomize=True)\n    slider_3 = gr.Slider(value=3, label=\"Non random slider\")\n    btn = gr.Button(\"Run\")\n    btn.click(func, inputs=[slider_1, slider_2], outputs=gr.Number())\n\nif __name__ == \"__main__\":\n    demo.launch()\n\n```\n    ```",
            "vector_context": "[Created at: 2025-03-24 13:16:13]\nChoosing a metric for your task\n\n**So you've trained your model and want to see how well it\u2019s doing on a dataset of your choice. Where do you start?**\n\nThere is no \u201cone size fits all\u201d approach to choosing an evaluation metric, but some good guidelines to keep in mind are:\n\n## Categories of metrics\n\nThere are 3 high-level categories of metrics:\n\n1. *Generic metrics*, which can be applied to a variety of situations and datasets, such as precision and accuracy.\n2. *Task-specific metrics*, which are limited to a given task, such as Machine Translation (often evaluated using metrics [BLEU](https://huggingface.co/metrics/bleu) or [ROUGE](https://huggingface.co/metrics/rouge)) or Named Entity Recognition (often evaluated with [seqeval](https://huggingface.co/metrics/seqeval)).\n3. *Dataset-specific metrics*, which aim to measure model performance on specific benchmarks: for instance, the [GLUE benchmark](https://huggingface.co/datasets/glue) has a dedicated [evaluation metric](https://huggingface.co/metrics/glue).\n\nLet's look at each of these three cases:\n\n### Generic metrics\n\nMany of the metrics used in the Machine Learning community are quite generic and can be applied in a variety of tasks and datasets.\n\nThis is the case for metrics like [accuracy](https://huggingface.co/metrics/accuracy) and [precision](https://huggingface.co/metrics/precision), which can be used for evaluating labeled (supervised) datasets, as well as [perplexity](https://huggingface.co/metrics/perplexity), which can be used for evaluating different kinds of (unsupervised) generative tasks.\n\nTo see the input structure of a given metric, you can look at its metric card. For example, in the case of [precision](https://huggingface.co/metrics/precision), the format is:\n```\n>>> precision_metric = evaluate.load(\"precision\")\n>>> results = precision_metric.compute(references=[0, 1], predictions=[0, 1])\n>>> print(results)\n{'precision': 1.0}\n```\n\n### Task-specific metrics\n\nPopular ML tasks like Machine Translation and Named Entity Recognition have specific metrics that can be used to compare models. For example, a series of different metrics have been proposed for text generation, ranging from [BLEU](https://huggingface.co/metrics/bleu) and its derivatives such as [GoogleBLEU](https://huggingface.co/metrics/google_bleu) and [GLEU](https://huggingface.co/metrics/gleu), but also [ROUGE](https://huggingface.co/metrics/rouge), [MAUVE](https://huggingface.co/metrics/mauve), etc.\n\nYou can find the right metric for your task by:\n\n- **Looking at the [Task pages](https://huggingface.co/tasks)** to see what metrics can be used for evaluating models for a given task.\n- **Checking out leaderboards** on sites like [Papers With Code](https://paperswithcode.com/) (you can search by task and by dataset).\n-  **Reading the metric cards** for the relevant metrics and see which ones are a good fit for your use case. For example, see the [BLEU metric card](https://github.com/huggingface/evaluate/tree/main/metrics/bleu) or [SQuaD metric card](https://github.com/huggingface/evaluate/tree/main/metrics/squad).\n- **Looking at papers and blog posts** published on the topic and see what metrics they report. This can change over time, so try to pick papers from the last couple of years!\n\n### Dataset-specific metrics\n\nSome datasets have specific metrics associated with them -- this is especially in the case of popular benchmarks like [GLUE](https://huggingface.co/metrics/glue) and [SQuAD](https://huggingface.co/metrics/squad).\n\n<Tip warning={true}>\n\ud83d\udca1\nGLUE is actually a collection of different subsets on different tasks, so first you need to choose the one that corresponds to the NLI task, such as mnli, which is described as \u201ccrowdsourced collection of sentence pairs with textual entailment annotations\u201d\n</Tip>\n\n\nIf you are evaluating your model on a benchmark dataset like the ones mentioned above, you can use its dedicated evaluation metric. Make sure you respect the format that they require. For example, to evaluate your model on the [SQuAD](https://huggingface.co/datasets/squad) dataset, you need to feed the `question` and `context` into your model and return the `prediction_text`, which should be compared with the `references` (based on matching the `id` of the question) :\n\n```\n>>> from evaluate import load\n>>> squad_metric = load(\"squad\")\n>>> predictions = [{'prediction_text': '1976', 'id': '56e10a3be3433e1400422b22'}]\n>>> references = [{'answers': {'answer_start': [97], 'text': ['1976']}, 'id': '56e10a3be3433e1400422b22'}]\n>>> results = squad_metric.compute(predictions=predictions, references=references)\n>>> results\n{'exact_match': 100.0, 'f1': 100.0}\n```\n\nYou can find examples of dataset structures by consulting the \"Dataset Preview\" function or the dataset card for a given dataset, and you can see how to use its dedicated evaluation function based on the metric card.\n--New Chunk--\n[Created at: 2025-03-24 13:16:13]\n=predictions, references=references)\n>>> results\n{'exact_match': 100.0, 'f1': 100.0}\n```\n\nYou can find examples of dataset structures by consulting the \"Dataset Preview\" function or the dataset card for a given dataset, and you can see how to use its dedicated evaluation function based on the metric card.\n--New Chunk--\n[Created at: 2025-03-24 13:16:48]\n\u4e0e\u5e38\u89c4\u51fd\u6570\u76f8\u540c\u7684\u65b9\u5f0f\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio\u3002\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\uff08\u865a\u62df\u7684\uff09\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5b83\u5728\u8f93\u51fa\u56fe\u50cf\u4e4b\u524d\u751f\u6210\u6570\u4e2a\u6b65\u9aa4\u7684\u566a\u97f3\uff1a\n\n$code_fake_diffusion\n$demo_fake_diffusion\n\n\u8bf7\u6ce8\u610f\uff0c\u6211\u4eec\u5728\u8fed\u4ee3\u5668\u4e2d\u6dfb\u52a0\u4e86 `time.sleep(1)`\uff0c\u4ee5\u521b\u5efa\u6b65\u9aa4\u4e4b\u95f4\u7684\u4eba\u5de5\u6682\u505c\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u89c2\u5bdf\u8fed\u4ee3\u5668\u7684\u6b65\u9aa4\uff08\u5728\u771f\u5b9e\u7684\u56fe\u50cf\u751f\u6210\u6a21\u578b\u4e2d\uff0c\u8fd9\u53ef\u80fd\u662f\u4e0d\u5fc5\u8981\u7684\uff09\u3002\n\n\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio **\u9700\u8981**\u5728\u5e95\u5c42 Interface \u6216 Blocks \u4e2d\u542f\u7528\u961f\u5217\uff08\u8bf7\u53c2\u9605\u4e0a\u9762\u7684\u961f\u5217\u90e8\u5206\uff09\u3002\n\n## \u8fdb\u5ea6\u6761\n\nGradio \u652f\u6301\u521b\u5efa\u81ea\u5b9a\u4e49\u8fdb\u5ea6\u6761\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u81ea\u5b9a\u4e49\u548c\u63a7\u5236\u5411\u7528\u6237\u663e\u793a\u7684\u8fdb\u5ea6\u66f4\u65b0\u3002\u8981\u542f\u7528\u6b64\u529f\u80fd\uff0c\u53ea\u9700\u4e3a\u65b9\u6cd5\u6dfb\u52a0\u4e00\u4e2a\u9ed8\u8ba4\u503c\u4e3a `gr.Progress` \u5b9e\u4f8b\u7684\u53c2\u6570\u5373\u53ef\u3002\u7136\u540e\uff0c\u60a8\u53ef\u4ee5\u76f4\u63a5\u8c03\u7528\u6b64\u5b9e\u4f8b\u5e76\u4f20\u5165 0 \u5230 1 \u4e4b\u95f4\u7684\u6d6e\u70b9\u6570\u6765\u66f4\u65b0\u8fdb\u5ea6\u7ea7\u522b\uff0c\u6216\u8005 with `Progress` \u5b9e\u4f8b\u7684 `tqdm()` \u65b9\u6cd5\u6765\u8ddf\u8e2a\u53ef\u8fed\u4ee3\u5bf9\u8c61\u4e0a\u7684\u8fdb\u5ea6\uff0c\u5982\u4e0b\u6240\u793a\u3002\u5fc5\u987b\u542f\u7528\u961f\u5217\u4ee5\u8fdb\u884c\u8fdb\u5ea6\u66f4\u65b0\u3002\n\n$code_progress_simple\n$demo_progress_simple\n\n\u5982\u679c\u60a8 with `tqdm` \u5e93\uff0c\u5e76\u4e14\u5e0c\u671b\u4ece\u51fd\u6570\u5185\u90e8\u7684\u4efb\u4f55 `tqdm.tqdm` \u81ea\u52a8\u62a5\u544a\u8fdb\u5ea6\u66f4\u65b0\uff0c\u8bf7\u5c06\u9ed8\u8ba4\u53c2\u6570\u8bbe\u7f6e\u4e3a `gr.Progress(track_tqdm=True)`\uff01\n\n## \u6279\u5904\u7406\u51fd\u6570 (Batch Functions)\n\nGradio \u652f\u6301\u4f20\u9012*\u6279\u5904\u7406*\u51fd\u6570\u3002\u6279\u5904\u7406\u51fd\u6570\u53ea\u662f\u63a5\u53d7\u8f93\u5165\u5217\u8868\u5e76\u8fd4\u56de\u9884\u6d4b\u5217\u8868\u7684\u51fd\u6570\u3002\n\n\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\u6279\u5904\u7406\u51fd\u6570\uff0c\u5b83\u63a5\u53d7\u4e24\u4e2a\u8f93\u5165\u5217\u8868\uff08\u4e00\u4e2a\u5355\u8bcd\u5217\u8868\u548c\u4e00\u4e2a\u6574\u6570\u5217\u8868\uff09\uff0c\u5e76\u8fd4\u56de\u4fee\u526a\u8fc7\u7684\u5355\u8bcd\u5217\u8868\u4f5c\u4e3a\u8f93\u51fa\uff1a\n\n```python\nimport time\n\ndef trim_words(words, lens):\n    trimmed_words = []\n    time.sleep(5)\n    for w, l in zip(words, lens):\n        trimmed_words.append(w[:int(l)])\n    return [trimmed_words]\n    for w, l in zip(words, lens):\n```\n\n\u4f7f\u7528\u6279\u5904\u7406\u51fd\u6570\u7684\u4f18\u70b9\u662f\uff0c\u5982\u679c\u542f\u7528\u4e86\u961f\u5217\uff0cGradio \u670d\u52a1\u5668\u53ef\u4ee5\u81ea\u52a8*\u6279\u5904\u7406*\u4f20\u5165\u7684\u8bf7\u6c42\u5e76\u5e76\u884c\u5904\u7406\u5b83\u4eec\uff0c\u4ece\u800c\u53ef\u80fd\u52a0\u5feb\u6f14\u793a\u901f\u5ea6\u3002\u4ee5\u4e0b\u662f Gradio \u4ee3\u7801\u7684\u793a\u4f8b\uff08\u8bf7\u6ce8\u610f `batch=True` \u548c `max_batch_size=16` - \u8fd9\u4e24\u4e2a\u53c2\u6570\u90fd\u53ef\u4ee5\u4f20\u9012\u7ed9\u4e8b\u4ef6\u89e6\u53d1\u5668\u6216 `Interface` \u7c7b\uff09\n\nwith `Interface`\uff1a\n\n```python\ndemo = gr.Interface(trim_words, [\"textbox\", \"number\"], [\"output\"],\n                    batch=True, max_batch_size=16)\ndemo.queue()\ndemo.launch()\n```\n\nwith `Blocks`\uff1a\n\n```python\nimport gradio as gr\n\nwith gr.Blocks() as demo:\n    with gr.Row():\n        word = gr.Textbox(label=\"word\")\n        leng = gr.Number(label=\"leng\")\n        output = gr.Textbox(label=\"Output\")\n    with gr.Row():\n        run = gr.Button()\n\n    event = run.click(trim_words, [word, leng], output, batch=True, max_batch_size=16)\n\ndemo.queue()\ndemo.launch()\n```\n\n\u5728\u4e0a\u9762\u7684\u793a\u4f8b\u4e2d\uff0c\u53ef\u4ee5\u5e76\u884c\u5904\u7406 16 \u4e2a\u8bf7\u6c42\uff08\u603b\u63a8\u7406\u65f6\u95f4\u4e3a 5 \u79d2\uff09\uff0c\u800c\u4e0d\u662f\u5206\u522b\u5904\u7406\u6bcf\u4e2a\u8bf7\u6c42\uff08\u603b\u63a8\u7406\u65f6\u95f4\u4e3a 80 \u79d2\uff09\u3002\u8bb8\u591a Hugging Face \u7684 `transformers` \u548c `diffusers` \u6a21\u578b\u5728 Gradio \u7684\u6279\u5904\u7406\u6a21\u5f0f\u4e0b\u81ea\u7136\u5de5\u4f5c\uff1a\u8fd9\u662f[\u4f7f\u7528\u6279\u5904\u7406\u751f\u6210\u56fe\u50cf\u7684\u793a\u4f8b\u6f14\u793a](https://github.com/gradio-app/gradio/blob/main/demo/diffusers_with_batching/run.py)\n\n\u6ce8\u610f\uff1a\u4f7f\u7528 Gradio \u7684\u6279\u5904\u7406\u51fd\u6570 **requires** \u5728\u5e95\u5c42 Interface \u6216 Blocks \u4e2d\u542f\u7528\u961f\u5217\uff08\u8bf7\u53c2\u9605\u4e0a\u9762\u7684\u961f\u5217\u90e8\u5206\uff09\u3002\n\n## Gradio \u7b14\u8bb0\u672c (Colab Notebooks)\n\nGradio \u53ef\u4ee5\u5728\u4efb\u4f55\u8fd0\u884c Python \u7684\u5730\u65b9\u8fd0\u884c\uff0c\u5305\u62ec\u672c\u5730 Jupyter \u7b14\u8bb0\u672c\u548c\u534f\u4f5c\u7b14\u8bb0\u672c\uff0c\u5982[Google Colab](https://colab.research.google.com/)\u3002\u5bf9\u4e8e\u672c\u5730 Jupyter \u7b14\u8bb0\u672c\u548c Google Colab \u7b14\u8bb0\u672c\uff0cGradio \u5728\u672c\u5730\u670d\u52a1\u5668\u4e0a\u8fd0\u884c\uff0c\u60a8\u53ef\u4ee5\u5728\u6d4f\u89c8\u5668\u4e2d\u4e0e\u4e4b\u4ea4\u4e92\u3002\uff08\u6ce8\u610f\uff1a\u5bf9\u4e8e Google Colab\uff0c\u8fd9\u662f\u901a\u8fc7[\u670d\u52a1\u5de5\u4f5c\u5668\u96a7\u9053](https://github.com/tensorflow/tensorboard/blob/master/docs/design/colab_integration.md)\u5b9e\u73b0\u7684\uff0c\u60a8\u7684\u6d4f\u89c8\u5668\u9700\u8981\u542f\u7528 cookies\u3002\uff09\u5bf9\u4e8e\u5176\u4ed6\u8fdc\u7a0b\u7b14\u8bb0\u672c\uff0cGradio \u4e5f\u5c06\u5728\u670d\u52a1\u5668\u4e0a\u8fd0\u884c\uff0c\u4f46\u60a8\u9700\u8981\u4f7f\u7528[SSH \u96a7\u9053](https://coderwall.com/p/ohk6cg/remote-access-to-ipython-notebooks-via-ssh)\u5728\u672c\u5730\u6d4f\u89c8\u5668\u4e2d\u67e5\u770b\u5e94\u7528\u7a0b\u5e8f\u3002\u901a\u5e38\uff0c\u66f4\u7b80\u5355\u7684\u9009\u62e9\u662f\u4f7f\u7528 Gradio \u5185\u7f6e\u7684\u516c\u5171\u94fe\u63a5\uff0c[\u5728\u4e0b\u4e00\u7bc7\u6307\u5357\u4e2d\u8ba8\u8bba](/sharing-your-app/#sharing-demos)\u3002"
        }
    },
    {
        "sample_idx": 21,
        "question": "Where can you find examples of dataset structures?",
        "answer": "The 'Dataset Preview' function or the dataset card for a given dataset",
        "rag_answer": "You can find examples of dataset structures by consulting the \"Dataset Preview\" function or the dataset card for a given dataset. Additionally, you can see how to use its dedicated evaluation function based on the metric card. [DC]",
        "rag_score": 5,
        "rag_feedback": "The system's response is completely correct, accurate, and factual. It correctly answers the question by stating that examples of dataset structures can be found in the 'Dataset Preview' function or the dataset card for a given dataset, and also mentions the dedicated evaluation function based on the metric card.",
        "rag_context": {
            "kg_context": "-----Entities-----\n    ```csv\n    id,\tentity,\ttype,\tdescription,\trankcreated_at\n1,\tDatasets library,technology,Datasets library is a tool used for fine-tuning the LayoutLMv3 model.,1,2025-03-24 13:16:48\n2,\tLayoutLMv3,technology,LayoutLMv3 is a model used for token classification and form understanding tasks.,11,2025-03-24 13:16:48\n3,\tInterface,category,Interface is a category of components in Gradio that enables the creation of custom interfaces.<SEP>Interface is a component of Gradio that allows users to interact with machine learning models.<SEP>Interface is a concept in Gradio that refers to a user interface for demonstrating models.<SEP>Interface is a category related to Gradio, where state works similarly to Blocks.,3,2025-03-24 13:16:48\n4,\tState,category,State is a concept in Gradio that refers to the storage of data, including global state and session state.,2,2025-03-24 13:16:48\n5,\tDataset Preview,organization,Dataset Preview is a function that provides examples of dataset structures.,1,2025-03-24 13:16:48\n6,\tMetric Card,organization,Metric Card is a resource that explains how to use a dedicated evaluation function.,1,2025-03-24 13:16:48\n7,\tdocs,geo,docs is a location where more information about Gradio's state can be found.,1,UNKNOWN\n8,\tDatasets library,technology,Datasets library is a tool used for fine-tuning the LayoutLMv3 model.,1,UNKNOWN\n9,\tPreprocessing and Postprocessing,category,Preprocessing and Postprocessing are features in Gradio that allow users to process data before and after it is input into a model.,1,UNKNOWN\n    ```\n    -----Relationships-----\n    ```csv\n    id,\tsource,\ttarget,\tdescription,\tkeywords,\tweight,\trank,\tcreated_at\n1,\tDatasets library,LayoutLMv3,Datasets library is a tool used for fine-tuning the LayoutLMv3 model.,tool, model fine-tuning,7.0,12,2025-03-24 13:19:57\n2,\tInterface,State,State works similarly in Interface and Blocks.,similar concept, data storage,14.0,5,2025-03-24 13:20:24\n3,\tDataset Preview,Metric Card,Dataset Preview and Metric Card are related resources that provide information about dataset structures and evaluation functions.,information resources, dataset structure,16.0,2,2025-03-24 13:16:48\n4,\tGradio,docs,The Gradio docs provide more information about state.,documentation, platform information,8.0,37,UNKNOWN\n5,\tGradio,Preprocessing and Postprocessing,Gradio provides features for preprocessing and postprocessing data.,data processing, interface feature,8.0,37,UNKNOWN\n6,\tDatasets library,LayoutLMv3,Datasets library is a tool used for fine-tuning the LayoutLMv3 model.,tool, model fine-tuning,7.0,12,UNKNOWN\n    ```\n    -----Sources-----\n    ```csv\n    id,\tcontent\n1,\t!---\nCopyright 2022 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n-->\n\n# Token classification with LayoutLMv3 (PyTorch version)\n\nThis directory contains a script, `run_funsd_cord.py`, that can be used to fine-tune (or evaluate) LayoutLMv3 on form understanding datasets, such as [FUNSD](https://guillaumejaume.github.io/FUNSD/) and [CORD](https://github.com/clovaai/cord).\n\nThe script `run_funsd_cord.py` leverages the \ud83e\udd17 Datasets library and the Trainer API. You can easily customize it to your needs.\n\n## Fine-tuning on FUNSD\n\nFine-tuning LayoutLMv3 for token classification on [FUNSD](https://guillaumejaume.github.io/FUNSD/) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name funsd \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 1e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-funsd\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd. By specifying the `push_to_hub` flag, the model gets uploaded automatically to the hub (regularly), together with a model card, which includes metrics such as precision, recall and F1. Note that you can easily update the model card, as it's just a README file of the respective repo on the hub.\n\nThere's also the \"Training metrics\" [tab](https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd/tensorboard), which shows Tensorboard logs over the course of training. Pretty neat, huh?\n\n## Fine-tuning on CORD\n\nFine-tuning LayoutLMv3 for token classification on [CORD](https://github.com/clovaai/cord) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name cord \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 5e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-cord\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-cord. Note that a model card gets generated automatically in case you specify the `push_to_hub` flag.\n2,\tState in Blocks\n\nWe covered [State in Interfaces](https://gradio.app/interface-state), this guide takes a look at state in Blocks, which works mostly the same.\n\n## Global State\n\nGlobal state in Blocks works the same as in Interface. Any variable created outside a function call is a reference shared between all users.\n\n## Session State\n\nGradio supports session **state**, where data persists across multiple submits within a page session, in Blocks apps as well. To reiterate, session data is _not_ shared between different users of your model. To store data in a session state, you need to do three things:\n\n1. Create a `gr.State()` object. If there is a default value to this stateful object, pass that into the constructor.\n2. In the event listener, put the `State` object as an input and output.\n3. In the event listener function, add the variable to the input parameters and the return value.\n\nLet's take a look at a game of hangman.\n\n$code_hangman\n$demo_hangman\n\nLet's see how we do each of the 3 steps listed above in this game:\n\n1. We store the used letters in `used_letters_var`. In the constructor of `State`, we set the initial value of this to `[]`, an empty list.\n2. In `btn.click()`, we have a reference to `used_letters_var` in both the inputs and outputs.\n3. In `guess_letter`, we pass the value of this `State` to `used_letters`, and then return an updated value of this `State` in the return statement.\n\nWith more complex apps, you will likely have many State variables storing session state in a single Blocks app.\n\nLearn more about `State` in the [docs](https://gradio.app/docs#state).\n3,\t=predictions, references=references)\n>>> results\n{'exact_match': 100.0, 'f1': 100.0}\n```\n\nYou can find examples of dataset structures by consulting the \"Dataset Preview\" function or the dataset card for a given dataset, and you can see how to use its dedicated evaluation function based on the metric card.\n4,\t\u4e3b\u8981\u7279\u70b9\n\n\u8ba9\u6211\u4eec\u6765\u4ecb\u7ecd\u4e00\u4e0b Gradio \u6700\u53d7\u6b22\u8fce\u7684\u4e00\u4e9b\u529f\u80fd\uff01\u8fd9\u91cc\u662f Gradio \u7684\u4e3b\u8981\u7279\u70b9\uff1a\n\n1. [\u6dfb\u52a0\u793a\u4f8b\u8f93\u5165](#example-inputs)\n2. [\u4f20\u9012\u81ea\u5b9a\u4e49\u9519\u8bef\u6d88\u606f](#errors)\n3. [\u6dfb\u52a0\u63cf\u8ff0\u5185\u5bb9](#descriptive-content)\n4. [\u8bbe\u7f6e\u65d7\u6807](#flagging)\n5. [\u9884\u5904\u7406\u548c\u540e\u5904\u7406](#preprocessing-and-postprocessing)\n6. [\u6837\u5f0f\u5316\u6f14\u793a](#styling)\n7. [\u6392\u961f\u7528\u6237](#queuing)\n8. [\u8fed\u4ee3\u8f93\u51fa](#iterative-outputs)\n9. [\u8fdb\u5ea6\u6761](#progress-bars)\n10. [\u6279\u5904\u7406\u51fd\u6570](#batch-functions)\n11. [\u5728\u534f\u4f5c\u7b14\u8bb0\u672c\u4e0a\u8fd0\u884c](#colab-notebooks)\n\n## \u793a\u4f8b\u8f93\u5165\n\n\u60a8\u53ef\u4ee5\u63d0\u4f9b\u7528\u6237\u53ef\u4ee5\u8f7b\u677e\u52a0\u8f7d\u5230 \"Interface\" \u4e2d\u7684\u793a\u4f8b\u6570\u636e\u3002\u8fd9\u5bf9\u4e8e\u6f14\u793a\u6a21\u578b\u671f\u671b\u7684\u8f93\u5165\u7c7b\u578b\u4ee5\u53ca\u6f14\u793a\u6570\u636e\u96c6\u548c\u6a21\u578b\u4e00\u8d77\u63a2\u7d22\u7684\u65b9\u5f0f\u975e\u5e38\u6709\u5e2e\u52a9\u3002\u8981\u52a0\u8f7d\u793a\u4f8b\u6570\u636e\uff0c\u60a8\u53ef\u4ee5\u5c06\u5d4c\u5957\u5217\u8868\u63d0\u4f9b\u7ed9 Interface \u6784\u9020\u51fd\u6570\u7684 `examples=` \u5173\u952e\u5b57\u53c2\u6570\u3002\u5916\u90e8\u5217\u8868\u4e2d\u7684\u6bcf\u4e2a\u5b50\u5217\u8868\u8868\u793a\u4e00\u4e2a\u6570\u636e\u6837\u672c\uff0c\u5b50\u5217\u8868\u4e2d\u7684\u6bcf\u4e2a\u5143\u7d20\u8868\u793a\u6bcf\u4e2a\u8f93\u5165\u7ec4\u4ef6\u7684\u8f93\u5165\u3002\u6709\u5173\u6bcf\u4e2a\u7ec4\u4ef6\u7684\u793a\u4f8b\u6570\u636e\u683c\u5f0f\u5728[Docs](https://gradio.app/docs#components)\u4e2d\u6709\u8bf4\u660e\u3002\n\n$code_calculator\n$demo_calculator\n\n\u60a8\u53ef\u4ee5\u5c06\u5927\u578b\u6570\u636e\u96c6\u52a0\u8f7d\u5230\u793a\u4f8b\u4e2d\uff0c\u901a\u8fc7 Gradio \u6d4f\u89c8\u548c\u4e0e\u6570\u636e\u96c6\u8fdb\u884c\u4ea4\u4e92\u3002\u793a\u4f8b\u5c06\u81ea\u52a8\u5206\u9875\uff08\u53ef\u4ee5\u901a\u8fc7 Interface \u7684 `examples_per_page` \u53c2\u6570\u8fdb\u884c\u914d\u7f6e\uff09\u3002\n\n\u7ee7\u7eed\u4e86\u89e3\u793a\u4f8b\uff0c\u8bf7\u53c2\u9605[\u66f4\u591a\u793a\u4f8b](https://gradio.app/more-on-examples)\u6307\u5357\u3002\n\n## \u9519\u8bef\n\n\u60a8\u5e0c\u671b\u5411\u7528\u6237\u4f20\u9012\u81ea\u5b9a\u4e49\u9519\u8bef\u6d88\u606f\u3002\u4e3a\u6b64\uff0cwith `gr.Error(\"custom message\")` \u6765\u663e\u793a\u9519\u8bef\u6d88\u606f\u3002\u5982\u679c\u5728\u4e0a\u9762\u7684\u8ba1\u7b97\u5668\u793a\u4f8b\u4e2d\u5c1d\u8bd5\u9664\u4ee5\u96f6\uff0c\u5c06\u663e\u793a\u81ea\u5b9a\u4e49\u9519\u8bef\u6d88\u606f\u7684\u5f39\u51fa\u6a21\u6001\u7a97\u53e3\u3002\u4e86\u89e3\u6709\u5173\u9519\u8bef\u7684\u66f4\u591a\u4fe1\u606f\uff0c\u8bf7\u53c2\u9605[\u6587\u6863](https://gradio.app/docs#error)\u3002\n\n## \u63cf\u8ff0\u6027\u5185\u5bb9\n\n\u5728\u524d\u9762\u7684\u793a\u4f8b\u4e2d\uff0c\u60a8\u53ef\u80fd\u5df2\u7ecf\u6ce8\u610f\u5230 Interface \u6784\u9020\u51fd\u6570\u4e2d\u7684 `title=` \u548c `description=` \u5173\u952e\u5b57\u53c2\u6570\uff0c\u5e2e\u52a9\u7528\u6237\u4e86\u89e3\u60a8\u7684\u5e94\u7528\u7a0b\u5e8f\u3002\n\nInterface \u6784\u9020\u51fd\u6570\u4e2d\u6709\u4e09\u4e2a\u53c2\u6570\u7528\u4e8e\u6307\u5b9a\u6b64\u5185\u5bb9\u5e94\u653e\u7f6e\u5728\u54ea\u91cc\uff1a\n\n- `title`\uff1a\u63a5\u53d7\u6587\u672c\uff0c\u5e76\u53ef\u4ee5\u5c06\u5176\u663e\u793a\u5728\u754c\u9762\u7684\u9876\u90e8\uff0c\u4e5f\u5c06\u6210\u4e3a\u9875\u9762\u6807\u9898\u3002\n- `description`\uff1a\u63a5\u53d7\u6587\u672c\u3001Markdown \u6216 HTML\uff0c\u5e76\u5c06\u5176\u653e\u7f6e\u5728\u6807\u9898\u6b63\u4e0b\u65b9\u3002\n- `article`\uff1a\u4e5f\u63a5\u53d7\u6587\u672c\u3001Markdown \u6216 HTML\uff0c\u5e76\u5c06\u5176\u653e\u7f6e\u5728\u754c\u9762\u4e0b\u65b9\u3002\n\n![annotated](/assets/guides/annotated.png)\n\n\u5982\u679c\u60a8\u4f7f\u7528\u7684\u662f `Blocks` API\uff0c\u5219\u53ef\u4ee5 with `gr.Markdown(...)` \u6216 `gr.HTML(...)` \u7ec4\u4ef6\u5728\u4efb\u4f55\u4f4d\u7f6e\u63d2\u5165\u6587\u672c\u3001Markdown \u6216 HTML\uff0c\u5176\u4e2d\u63cf\u8ff0\u6027\u5185\u5bb9\u4f4d\u4e8e `Component` \u6784\u9020\u51fd\u6570\u5185\u90e8\u3002\n\n\u53e6\u4e00\u4e2a\u6709\u7528\u7684\u5173\u952e\u5b57\u53c2\u6570\u662f `label=`\uff0c\u5b83\u5b58\u5728\u4e8e\u6bcf\u4e2a `Component` \u4e2d\u3002\u8fd9\u4fee\u6539\u4e86\u6bcf\u4e2a `Component` \u9876\u90e8\u7684\u6807\u7b7e\u6587\u672c\u3002\u8fd8\u53ef\u4ee5\u4e3a\u8bf8\u5982 `Textbox` \u6216 `Radio` \u4e4b\u7c7b\u7684\u8868\u5355\u5143\u7d20\u6dfb\u52a0 `info=` \u5173\u952e\u5b57\u53c2\u6570\uff0c\u4ee5\u63d0\u4f9b\u6709\u5173\u5176\u7528\u6cd5\u7684\u8fdb\u4e00\u6b65\u4fe1\u606f\u3002\n\n```python\ngr.Number(label='\u5e74\u9f84', info='\u4ee5\u5e74\u4e3a\u5355\u4f4d\uff0c\u5fc5\u987b\u5927\u4e8e0')\n```\n\n## \u65d7\u6807\n\n\u9ed8\u8ba4\u60c5\u51b5\u4e0b\uff0c\"Interface\" \u5c06\u6709\u4e00\u4e2a \"Flag\" \u6309\u94ae\u3002\u5f53\u7528\u6237\u6d4b\u8bd5\u60a8\u7684 `Interface` \u65f6\uff0c\u5982\u679c\u770b\u5230\u6709\u8da3\u7684\u8f93\u51fa\uff0c\u4f8b\u5982\u9519\u8bef\u6216\u610f\u5916\u7684\u6a21\u578b\u884c\u4e3a\uff0c\u4ed6\u4eec\u53ef\u4ee5\u5c06\u8f93\u5165\u6807\u8bb0\u4e3a\u60a8\u8fdb\u884c\u67e5\u770b\u3002\u5728\u7531 `Interface` \u6784\u9020\u51fd\u6570\u7684 `flagging_dir=` \u53c2\u6570\u63d0\u4f9b\u7684\u76ee\u5f55\u4e2d\uff0c\u5c06\u8bb0\u5f55\u6807\u8bb0\u7684\u8f93\u5165\u5230\u4e00\u4e2a CSV \u6587\u4ef6\u4e2d\u3002\u5982\u679c\u754c\u9762\u6d89\u53ca\u6587\u4ef6\u6570\u636e\uff0c\u4f8b\u5982\u56fe\u50cf\u548c\u97f3\u9891\u7ec4\u4ef6\uff0c\u5c06\u521b\u5efa\u6587\u4ef6\u5939\u6765\u5b58\u50a8\u8fd9\u4e9b\u6807\u8bb0\u7684\u6570\u636e\u3002\n\n\u4f8b\u5982\uff0c\u5bf9\u4e8e\u4e0a\u9762\u663e\u793a\u7684\u8ba1\u7b97\u5668\u754c\u9762\uff0c\u6211\u4eec\u5c06\u5728\u4e0b\u9762\u7684\u65d7\u6807\u76ee\u5f55\u4e2d\u5b58\u50a8\u6807\u8bb0\u7684\u6570\u636e\uff1a\n\n```directory\n+-- calculator.py\n+-- flagged/\n|   +-- logs.csv\n```\n\n_flagged/logs.csv_\n\n```csv\nnum1,operation,num2,Output\n5,add,7,12\n6,subtract,1.5,4.5\n```\n\n\u4e0e\u65e9\u671f\u663e\u793a\u7684\u51b7\u8272\u754c\u9762\u76f8\u5bf9\u5e94\uff0c\u6211\u4eec\u5c06\u5728\u4e0b\u9762\u7684\u65d7\u6807\u76ee\u5f55\u4e2d\u5b58\u50a8\u6807\u8bb0\u7684\u6570\u636e\uff1a\n\n```directory\n+-- sepia.py\n+-- flagged/\n|   +-- logs.csv\n|   +-- im/\n|   |   +-- 0.png\n|   |   +-- 1.png\n|   +-- Output/\n|   |   +-- 0.png\n|   |   +-- 1.png\n```\n\n_flagged/logs.csv_\n\n```csv\nim,Output\nim/0.png,Output/0.png\nim/1.png,Output/1.png\n```\n\n\u5982\u679c\u60a8\u5e0c\u671b\u7528\u6237\u63d0\u4f9b\u65d7\u6807\u539f\u56e0\uff0c\u53ef\u4ee5\u5c06\u5b57\u7b26\u4e32\u5217\u8868\u4f20\u9012\u7ed9 Interface \u7684 `flagging_options` \u53c2\u6570\u3002\u7528\u6237\u5728\u8fdb\u884c\u65d7\u6807\u65f6\u5fc5\u987b\u9009\u62e9\u5176\u4e2d\u4e00\u4e2a\u5b57\u7b26\u4e32\uff0c\u8fd9\u5c06\u4f5c\u4e3a\u9644\u52a0\u5217\u4fdd\u5b58\u5230 CSV \u4e2d\u3002\n\n## \u9884\u5904\u7406\u548c\u540e\u5904\u7406 (Preprocessing and Postprocessing)\n\n![annotated](/assets/img/dataflow.svg)\n\n\u5982\u60a8\u6240\u89c1\uff0cGradio \u5305\u62ec\u53ef\u4ee5\u5904\u7406\u5404\u79cd\u4e0d\u540c\u6570\u636e\u7c7b\u578b\u7684\u7ec4\u4ef6\uff0c\u4f8b\u5982\u56fe\u50cf\u3001\u97f3\u9891\u548c\u89c6\u9891\u3002\u5927\u591a\u6570\u7ec4\u4ef6\u90fd\u53ef\u4ee5\u7528\u4f5c\u8f93\u5165\u6216\u8f93\u51fa\u3002\n\n\u5f53\u7ec4\u4ef6\u7528\u4f5c\u8f93\u5165\u65f6\uff0cGradio \u81ea\u52a8\u5904\u7406*\u9884\u5904\u7406*\uff0c\u5c06\u6570\u636e\u4ece\u7528\u6237\n    ```",
            "vector_context": "[Created at: 2025-03-24 13:16:13]\n=predictions, references=references)\n>>> results\n{'exact_match': 100.0, 'f1': 100.0}\n```\n\nYou can find examples of dataset structures by consulting the \"Dataset Preview\" function or the dataset card for a given dataset, and you can see how to use its dedicated evaluation function based on the metric card.\n--New Chunk--\n[Created at: 2025-03-24 13:16:48]\n\u65f6\u5fc5\u987b\u9009\u62e9\u5176\u4e2d\u4e00\u4e2a\u5b57\u7b26\u4e32\uff0c\u8fd9\u5c06\u4f5c\u4e3a\u9644\u52a0\u5217\u4fdd\u5b58\u5230 CSV \u4e2d\u3002\n\n## \u9884\u5904\u7406\u548c\u540e\u5904\u7406 (Preprocessing and Postprocessing)\n\n![annotated](/assets/img/dataflow.svg)\n\n\u5982\u60a8\u6240\u89c1\uff0cGradio \u5305\u62ec\u53ef\u4ee5\u5904\u7406\u5404\u79cd\u4e0d\u540c\u6570\u636e\u7c7b\u578b\u7684\u7ec4\u4ef6\uff0c\u4f8b\u5982\u56fe\u50cf\u3001\u97f3\u9891\u548c\u89c6\u9891\u3002\u5927\u591a\u6570\u7ec4\u4ef6\u90fd\u53ef\u4ee5\u7528\u4f5c\u8f93\u5165\u6216\u8f93\u51fa\u3002\n\n\u5f53\u7ec4\u4ef6\u7528\u4f5c\u8f93\u5165\u65f6\uff0cGradio \u81ea\u52a8\u5904\u7406*\u9884\u5904\u7406*\uff0c\u5c06\u6570\u636e\u4ece\u7528\u6237\u6d4f\u89c8\u5668\u53d1\u9001\u7684\u7c7b\u578b\uff08\u4f8b\u5982\u7f51\u7edc\u6444\u50cf\u5934\u5feb\u7167\u7684 base64 \u8868\u793a\uff09\u8f6c\u6362\u4e3a\u60a8\u7684\u51fd\u6570\u53ef\u4ee5\u63a5\u53d7\u7684\u5f62\u5f0f\uff08\u4f8b\u5982 `numpy` \u6570\u7ec4\uff09\u3002\n\n\u540c\u6837\uff0c\u5f53\u7ec4\u4ef6\u7528\u4f5c\u8f93\u51fa\u65f6\uff0cGradio \u81ea\u52a8\u5904\u7406*\u540e\u5904\u7406*\uff0c\u5c06\u6570\u636e\u4ece\u51fd\u6570\u8fd4\u56de\u7684\u5f62\u5f0f\uff08\u4f8b\u5982\u56fe\u50cf\u8def\u5f84\u5217\u8868\uff09\u8f6c\u6362\u4e3a\u53ef\u4ee5\u5728\u7528\u6237\u6d4f\u89c8\u5668\u4e2d\u663e\u793a\u7684\u5f62\u5f0f\uff08\u4f8b\u5982\u4ee5 base64 \u683c\u5f0f\u663e\u793a\u56fe\u50cf\u7684 `Gallery`\uff09\u3002\n\n\u60a8\u53ef\u4ee5\u4f7f\u7528\u6784\u5efa\u56fe\u50cf\u7ec4\u4ef6\u65f6\u7684\u53c2\u6570\u63a7\u5236*\u9884\u5904\u7406*\u3002\u4f8b\u5982\uff0c\u5982\u679c\u60a8\u4f7f\u7528\u4ee5\u4e0b\u53c2\u6570\u5b9e\u4f8b\u5316 `Image` \u7ec4\u4ef6\uff0c\u5b83\u5c06\u5c06\u56fe\u50cf\u8f6c\u6362\u4e3a `PIL` \u7c7b\u578b\uff0c\u5e76\u5c06\u5176\u91cd\u5851\u4e3a`(100, 100)`\uff0c\u800c\u4e0d\u7ba1\u63d0\u4ea4\u65f6\u7684\u539f\u59cb\u5927\u5c0f\u5982\u4f55\uff1a\n\n```py\nimg = gr.Image(shape=(100, 100), type=\"pil\")\n```\n\n\u76f8\u53cd\uff0c\u8fd9\u91cc\u6211\u4eec\u4fdd\u7559\u56fe\u50cf\u7684\u539f\u59cb\u5927\u5c0f\uff0c\u4f46\u5728\u5c06\u5176\u8f6c\u6362\u4e3a numpy \u6570\u7ec4\u4e4b\u524d\u53cd\u8f6c\u989c\u8272\uff1a\n\n```py\nimg = gr.Image(invert_colors=True, type=\"numpy\")\n```\n\n\u540e\u5904\u7406\u8981\u5bb9\u6613\u5f97\u591a\uff01Gradio \u81ea\u52a8\u8bc6\u522b\u8fd4\u56de\u6570\u636e\u7684\u683c\u5f0f\uff08\u4f8b\u5982 `Image` \u662f `numpy` \u6570\u7ec4\u8fd8\u662f `str` \u6587\u4ef6\u8def\u5f84\uff1f\uff09\uff0c\u5e76\u5c06\u5176\u540e\u5904\u7406\u4e3a\u53ef\u4ee5\u7531\u6d4f\u89c8\u5668\u663e\u793a\u7684\u683c\u5f0f\u3002\n\n\u8bf7\u67e5\u770b[\u6587\u6863](https://gradio.app/docs)\uff0c\u4e86\u89e3\u6bcf\u4e2a\u7ec4\u4ef6\u7684\u6240\u6709\u4e0e\u9884\u5904\u7406\u76f8\u5173\u7684\u53c2\u6570\u3002\n\n## \u6837\u5f0f (Styling)\n\nGradio \u4e3b\u9898\u662f\u81ea\u5b9a\u4e49\u5e94\u7528\u7a0b\u5e8f\u5916\u89c2\u548c\u611f\u89c9\u7684\u6700\u7b80\u5355\u65b9\u6cd5\u3002\u60a8\u53ef\u4ee5\u9009\u62e9\u591a\u79cd\u4e3b\u9898\u6216\u521b\u5efa\u81ea\u5df1\u7684\u4e3b\u9898\u3002\u8981\u8fd9\u6837\u505a\uff0c\u8bf7\u5c06 `theme=` \u53c2\u6570\u4f20\u9012\u7ed9 `Interface` \u6784\u9020\u51fd\u6570\u3002\u4f8b\u5982\uff1a\n\n```python\ndemo = gr.Interface(..., theme=gr.themes.Monochrome())\n```\n\nGradio \u5e26\u6709\u4e00\u7ec4\u9884\u5148\u6784\u5efa\u7684\u4e3b\u9898\uff0c\u60a8\u53ef\u4ee5\u4ece `gr.themes.*` \u52a0\u8f7d\u3002\u60a8\u53ef\u4ee5\u6269\u5c55\u8fd9\u4e9b\u4e3b\u9898\u6216\u4ece\u5934\u5f00\u59cb\u521b\u5efa\u81ea\u5df1\u7684\u4e3b\u9898 - \u6709\u5173\u66f4\u591a\u8be6\u7ec6\u4fe1\u606f\uff0c\u8bf7\u53c2\u9605[\u4e3b\u9898\u6307\u5357](https://gradio.app/theming-guide)\u3002\n\n\u8981\u589e\u52a0\u989d\u5916\u7684\u6837\u5f0f\u80fd\u529b\uff0c\u60a8\u53ef\u4ee5 with `css=` \u5173\u952e\u5b57\u5c06\u4efb\u4f55 CSS \u4f20\u9012\u7ed9\u60a8\u7684\u5e94\u7528\u7a0b\u5e8f\u3002\nGradio \u5e94\u7528\u7a0b\u5e8f\u7684\u57fa\u7c7b\u662f `gradio-container`\uff0c\u56e0\u6b64\u4ee5\u4e0b\u662f\u4e00\u4e2a\u66f4\u6539 Gradio \u5e94\u7528\u7a0b\u5e8f\u80cc\u666f\u989c\u8272\u7684\u793a\u4f8b\uff1a\n\n```python\nwith `gr.Interface(css=\".gradio-container {background-color: red}\") as demo:\n    ...\n```\n\n## \u961f\u5217 (Queuing)\n\n\u5982\u679c\u60a8\u7684\u5e94\u7528\u7a0b\u5e8f\u9884\u8ba1\u4f1a\u6709\u5927\u91cf\u6d41\u91cf\uff0c\u8bf7 with `queue()` \u65b9\u6cd5\u6765\u63a7\u5236\u5904\u7406\u901f\u7387\u3002\u8fd9\u5c06\u6392\u961f\u5904\u7406\u8c03\u7528\uff0c\u56e0\u6b64\u4e00\u6b21\u53ea\u5904\u7406\u4e00\u5b9a\u6570\u91cf\u7684\u8bf7\u6c42\u3002\u961f\u5217\u4f7f\u7528 Websockets\uff0c\u8fd8\u53ef\u4ee5\u9632\u6b62\u7f51\u7edc\u8d85\u65f6\uff0c\u56e0\u6b64\u5982\u679c\u60a8\u7684\u51fd\u6570\u7684\u63a8\u7406\u65f6\u95f4\u5f88\u957f\uff08> 1 \u5206\u949f\uff09\uff0c\u5e94\u4f7f\u7528\u961f\u5217\u3002\n\nwith `Interface`\uff1a\n\n```python\ndemo = gr.Interface(...).queue()\ndemo.launch()\n```\n\nwith `Blocks`\uff1a\n\n```python\nwith gr.Blocks() as demo\uff1a\n    #...\ndemo.queue()\ndemo.launch()\n```\n\n\u60a8\u53ef\u4ee5\u901a\u8fc7\u4ee5\u4e0b\u65b9\u5f0f\u63a7\u5236\u4e00\u6b21\u5904\u7406\u7684\u8bf7\u6c42\u6570\u91cf\uff1a\n\n```python\ndemo.queue(concurrency_count=3)\n```\n\n\u67e5\u770b\u6709\u5173\u914d\u7f6e\u5176\u4ed6\u961f\u5217\u53c2\u6570\u7684[\u961f\u5217\u6587\u6863](/docs/#queue)\u3002\n\n\u5728 Blocks \u4e2d\u6307\u5b9a\u4ec5\u5bf9\u67d0\u4e9b\u51fd\u6570\u8fdb\u884c\u6392\u961f\uff1a\n\n```python\nwith gr.Blocks() as demo2\uff1a\n    num1 = gr.Number()\n    num2 = gr.Number()\n    output = gr.Number()\n    gr.Button(\"Add\").click(\n        lambda a, b: a + b, [num1, num2], output)\n    gr.Button(\"Multiply\").click(\n        lambda a, b: a * b, [num1, num2], output, queue=True)\ndemo2.launch()\n```\n\n## \u8fed\u4ee3\u8f93\u51fa (Iterative Outputs)\n\n\u5728\u67d0\u4e9b\u60c5\u51b5\u4e0b\uff0c\u60a8\u53ef\u80fd\u9700\u8981\u4f20\u8f93\u4e00\u7cfb\u5217\u8f93\u51fa\u800c\u4e0d\u662f\u4e00\u6b21\u663e\u793a\u5355\u4e2a\u8f93\u51fa\u3002\u4f8b\u5982\uff0c\u60a8\u53ef\u80fd\u6709\u4e00\u4e2a\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5e0c\u671b\u663e\u793a\u751f\u6210\u7684\u6bcf\u4e2a\u6b65\u9aa4\u7684\u56fe\u50cf\uff0c\u76f4\u5230\u6700\u7ec8\u56fe\u50cf\u3002\u6216\u8005\u60a8\u53ef\u80fd\u6709\u4e00\u4e2a\u804a\u5929\u673a\u5668\u4eba\uff0c\u5b83\u9010\u5b57\u9010\u53e5\u5730\u6d41\u5f0f\u4f20\u8f93\u54cd\u5e94\uff0c\u800c\u4e0d\u662f\u4e00\u6b21\u8fd4\u56de\u5168\u90e8\u54cd\u5e94\u3002\n\n\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u60a8\u53ef\u4ee5\u5c06**\u751f\u6210\u5668**\u51fd\u6570\u63d0\u4f9b\u7ed9 Gradio\uff0c\u800c\u4e0d\u662f\u5e38\u89c4\u51fd\u6570\u3002\u5728 Python \u4e2d\u521b\u5efa\u751f\u6210\u5668\u975e\u5e38\u7b80\u5355\uff1a\u51fd\u6570\u4e0d\u5e94\u8be5\u6709\u4e00\u4e2a\u5355\u72ec\u7684 `return` \u503c\uff0c\u800c\u662f\u5e94\u8be5 with `yield` \u8fde\u7eed\u8fd4\u56de\u4e00\u7cfb\u5217\u503c\u3002\u901a\u5e38\uff0c`yield` \u8bed\u53e5\u653e\u7f6e\u5728\u67d0\u79cd\u5faa\u73af\u4e2d\u3002\u4e0b\u9762\u662f\u4e00\u4e2a\u7b80\u5355\u793a\u4f8b\uff0c\u751f\u6210\u5668\u53ea\u662f\u7b80\u5355\u8ba1\u6570\u5230\u7ed9\u5b9a\u6570\u5b57\uff1a\n\n```python\ndef my_generator(x):\n    for i in range(x):\n        yield i\n```\n\n\u60a8\u4ee5\u4e0e\u5e38\u89c4\u51fd\u6570\u76f8\u540c\u7684\u65b9\u5f0f\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio\u3002\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\uff08\u865a\u62df\u7684\uff09\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5b83\u5728\u8f93\u51fa\u56fe\u50cf\u4e4b\u524d\u751f\u6210\u6570\u4e2a\u6b65\u9aa4\u7684\u566a\u97f3\uff1a\n\n$code_fake_diffusion\n$demo_fake_diffusion\n\n\u8bf7\u6ce8\u610f\uff0c\u6211\u4eec\u5728\u8fed\u4ee3\u5668\u4e2d\u6dfb\u52a0\u4e86 `time.sleep(1)`\uff0c\u4ee5\u521b\u5efa\u6b65\u9aa4\u4e4b\u95f4\u7684\u4eba\u5de5\u6682\u505c\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u89c2\u5bdf\u8fed\u4ee3\u5668\u7684\u6b65\u9aa4\uff08\u5728\u771f\u5b9e\u7684\u56fe\u50cf\u751f\u6210\u6a21\u578b\u4e2d\uff0c\u8fd9\n--New Chunk--\n[Created at: 2025-03-24 13:18:21]\nGradio Demo: blocks_random_slider\n\n\n```\n!pip install -q gradio \n```\n\n\n```\n\nimport gradio as gr\n\n\ndef func(slider_1, slider_2):\n    return slider_1 * 5 + slider_2\n\n\nwith gr.Blocks() as demo:\n    slider = gr.Slider(minimum=-10.2, maximum=15, label=\"Random Slider (Static)\", randomize=True)\n    slider_1 = gr.Slider(minimum=100, maximum=200, label=\"Random Slider (Input 1)\", randomize=True)\n    slider_2 = gr.Slider(minimum=10, maximum=23.2, label=\"Random Slider (Input 2)\", randomize=True)\n    slider_3 = gr.Slider(value=3, label=\"Non random slider\")\n    btn = gr.Button(\"Run\")\n    btn.click(func, inputs=[slider_1, slider_2], outputs=gr.Number())\n\nif __name__ == \"__main__\":\n    demo.launch()\n\n```"
        }
    },
    {
        "sample_idx": 22,
        "question": "Where can you see how to use a dataset's dedicated evaluation function?",
        "answer": "The metric card",
        "rag_answer": "You can see how to use a dataset's dedicated evaluation function by consulting the \"Dataset Preview\" function or the dataset card for a given dataset, and then looking at the metric card.",
        "rag_score": 4,
        "rag_feedback": "The system's response is mostly correct, accurate, and factual. It provides a detailed explanation of how to use a dataset's dedicated evaluation function, mentioning the metric card, dataset preview, and dataset card. However, it also includes a lot of unnecessary information and examples that are not directly related to the question, which makes the response somewhat confusing and hard to follow.",
        "rag_context": {
            "kg_context": "-----Entities-----\n    ```csv\n    id,\tentity,\ttype,\tdescription,\trankcreated_at\n1,\tEvaluation Function,category,Evaluation Function is a tool used to assess the performance of a model.,2,2025-03-24 13:16:48\n2,\tModel,category,Model refers to a machine learning model being evaluated.,3,2025-03-24 13:16:48\n3,\tPredictions,category,Predictions are the outcome of a model's performance.,2,2025-03-24 13:16:48\n4,\tExact Match,category,Exact Match is a metric used to evaluate the performance of a model.,1,2025-03-24 13:16:48\n5,\tF1,category,F1 is a metric used to evaluate the performance of a model.,1,2025-03-24 13:16:48\n6,\tEvaluation Function,category,Evaluation Function is a tool used to assess the performance of a model.,2,UNKNOWN\n7,\tGLUE,dataset,GLUE is a benchmark dataset for evaluating natural language processing models.,1,UNKNOWN\n8,\tModel,category,Model refers to a machine learning model being evaluated.,3,UNKNOWN\n    ```\n    -----Relationships-----\n    ```csv\n    id,\tsource,\ttarget,\tdescription,\tkeywords,\tweight,\trank,\tcreated_at\n1,\tEvaluation Function,Model,The evaluation function is used to assess the performance of the model.,model evaluation, performance assessment,18.0,5,2025-03-24 13:16:48\n2,\tModel,Predictions,The model makes predictions based on the input data.,model output, predictions,8.0,5,2025-03-24 13:16:48\n3,\tExact Match,F1,Exact Match and F1 are both metrics used to evaluate the performance of a model.,evaluation metrics, performance assessment,8.0,2,2025-03-24 13:16:48\n4,\tGLUE,Hugging Face,Hugging Face provides a platform for evaluating models on the GLUE benchmark dataset.,evaluation platform, benchmark dataset,16.0,9,UNKNOWN\n5,\tMachine Learning,Model,Machine Learning involves training models to make predictions.,field of study, model training,9.0,8,UNKNOWN\n6,\tEvaluation Function,Model,The evaluation function is used to assess the performance of the model.,model evaluation, performance assessment,18.0,5,UNKNOWN\n7,\tModel,Predictions,The model makes predictions based on the input data.,model output, predictions,8.0,5,UNKNOWN\n8,\tEvaluation Function,Results,The results are obtained by using the evaluation function.,evaluation outcome, accuracy,20.0,3,UNKNOWN\n    ```\n    -----Sources-----\n    ```csv\n    id,\tcontent\n1,\t=predictions, references=references)\n>>> results\n{'exact_match': 100.0, 'f1': 100.0}\n```\n\nYou can find examples of dataset structures by consulting the \"Dataset Preview\" function or the dataset card for a given dataset, and you can see how to use its dedicated evaluation function based on the metric card.\n2,\tChoosing a metric for your task\n\n**So you've trained your model and want to see how well it\u2019s doing on a dataset of your choice. Where do you start?**\n\nThere is no \u201cone size fits all\u201d approach to choosing an evaluation metric, but some good guidelines to keep in mind are:\n\n## Categories of metrics\n\nThere are 3 high-level categories of metrics:\n\n1. *Generic metrics*, which can be applied to a variety of situations and datasets, such as precision and accuracy.\n2. *Task-specific metrics*, which are limited to a given task, such as Machine Translation (often evaluated using metrics [BLEU](https://huggingface.co/metrics/bleu) or [ROUGE](https://huggingface.co/metrics/rouge)) or Named Entity Recognition (often evaluated with [seqeval](https://huggingface.co/metrics/seqeval)).\n3. *Dataset-specific metrics*, which aim to measure model performance on specific benchmarks: for instance, the [GLUE benchmark](https://huggingface.co/datasets/glue) has a dedicated [evaluation metric](https://huggingface.co/metrics/glue).\n\nLet's look at each of these three cases:\n\n### Generic metrics\n\nMany of the metrics used in the Machine Learning community are quite generic and can be applied in a variety of tasks and datasets.\n\nThis is the case for metrics like [accuracy](https://huggingface.co/metrics/accuracy) and [precision](https://huggingface.co/metrics/precision), which can be used for evaluating labeled (supervised) datasets, as well as [perplexity](https://huggingface.co/metrics/perplexity), which can be used for evaluating different kinds of (unsupervised) generative tasks.\n\nTo see the input structure of a given metric, you can look at its metric card. For example, in the case of [precision](https://huggingface.co/metrics/precision), the format is:\n```\n>>> precision_metric = evaluate.load(\"precision\")\n>>> results = precision_metric.compute(references=[0, 1], predictions=[0, 1])\n>>> print(results)\n{'precision': 1.0}\n```\n\n### Task-specific metrics\n\nPopular ML tasks like Machine Translation and Named Entity Recognition have specific metrics that can be used to compare models. For example, a series of different metrics have been proposed for text generation, ranging from [BLEU](https://huggingface.co/metrics/bleu) and its derivatives such as [GoogleBLEU](https://huggingface.co/metrics/google_bleu) and [GLEU](https://huggingface.co/metrics/gleu), but also [ROUGE](https://huggingface.co/metrics/rouge), [MAUVE](https://huggingface.co/metrics/mauve), etc.\n\nYou can find the right metric for your task by:\n\n- **Looking at the [Task pages](https://huggingface.co/tasks)** to see what metrics can be used for evaluating models for a given task.\n- **Checking out leaderboards** on sites like [Papers With Code](https://paperswithcode.com/) (you can search by task and by dataset).\n-  **Reading the metric cards** for the relevant metrics and see which ones are a good fit for your use case. For example, see the [BLEU metric card](https://github.com/huggingface/evaluate/tree/main/metrics/bleu) or [SQuaD metric card](https://github.com/huggingface/evaluate/tree/main/metrics/squad).\n- **Looking at papers and blog posts** published on the topic and see what metrics they report. This can change over time, so try to pick papers from the last couple of years!\n\n### Dataset-specific metrics\n\nSome datasets have specific metrics associated with them -- this is especially in the case of popular benchmarks like [GLUE](https://huggingface.co/metrics/glue) and [SQuAD](https://huggingface.co/metrics/squad).\n\n<Tip warning={true}>\n\ud83d\udca1\nGLUE is actually a collection of different subsets on different tasks, so first you need to choose the one that corresponds to the NLI task, such as mnli, which is described as \u201ccrowdsourced collection of sentence pairs with textual entailment annotations\u201d\n</Tip>\n\n\nIf you are evaluating your model on a benchmark dataset like the ones mentioned above, you can use its dedicated evaluation metric. Make sure you respect the format that they require. For example, to evaluate your model on the [SQuAD](https://huggingface.co/datasets/squad) dataset, you need to feed the `question` and `context` into your model and return the `prediction_text`, which should be compared with the `references` (based on matching the `id` of the question) :\n\n```\n>>> from evaluate import load\n>>> squad_metric = load(\"squad\")\n>>> predictions = [{'prediction_text': '1976', 'id': '56e10a3be3433e1400422b22'}]\n>>> references = [{'answers': {'answer_start': [97], 'text': ['1976']}, 'id': '56e10a3be3433e1400422b22'}]\n>>> results = squad_metric.compute(predictions=predictions, references=references)\n>>> results\n{'exact_match': 100.0, 'f1': 100.0}\n```\n\nYou can find examples of dataset structures by consulting the \"Dataset Preview\" function or the dataset card for a given dataset, and you can see how to use its dedicated evaluation function based on the metric card.\n    ```",
            "vector_context": "[Created at: 2025-03-24 13:16:13]\n=predictions, references=references)\n>>> results\n{'exact_match': 100.0, 'f1': 100.0}\n```\n\nYou can find examples of dataset structures by consulting the \"Dataset Preview\" function or the dataset card for a given dataset, and you can see how to use its dedicated evaluation function based on the metric card.\n--New Chunk--\n[Created at: 2025-03-24 13:16:13]\nChoosing a metric for your task\n\n**So you've trained your model and want to see how well it\u2019s doing on a dataset of your choice. Where do you start?**\n\nThere is no \u201cone size fits all\u201d approach to choosing an evaluation metric, but some good guidelines to keep in mind are:\n\n## Categories of metrics\n\nThere are 3 high-level categories of metrics:\n\n1. *Generic metrics*, which can be applied to a variety of situations and datasets, such as precision and accuracy.\n2. *Task-specific metrics*, which are limited to a given task, such as Machine Translation (often evaluated using metrics [BLEU](https://huggingface.co/metrics/bleu) or [ROUGE](https://huggingface.co/metrics/rouge)) or Named Entity Recognition (often evaluated with [seqeval](https://huggingface.co/metrics/seqeval)).\n3. *Dataset-specific metrics*, which aim to measure model performance on specific benchmarks: for instance, the [GLUE benchmark](https://huggingface.co/datasets/glue) has a dedicated [evaluation metric](https://huggingface.co/metrics/glue).\n\nLet's look at each of these three cases:\n\n### Generic metrics\n\nMany of the metrics used in the Machine Learning community are quite generic and can be applied in a variety of tasks and datasets.\n\nThis is the case for metrics like [accuracy](https://huggingface.co/metrics/accuracy) and [precision](https://huggingface.co/metrics/precision), which can be used for evaluating labeled (supervised) datasets, as well as [perplexity](https://huggingface.co/metrics/perplexity), which can be used for evaluating different kinds of (unsupervised) generative tasks.\n\nTo see the input structure of a given metric, you can look at its metric card. For example, in the case of [precision](https://huggingface.co/metrics/precision), the format is:\n```\n>>> precision_metric = evaluate.load(\"precision\")\n>>> results = precision_metric.compute(references=[0, 1], predictions=[0, 1])\n>>> print(results)\n{'precision': 1.0}\n```\n\n### Task-specific metrics\n\nPopular ML tasks like Machine Translation and Named Entity Recognition have specific metrics that can be used to compare models. For example, a series of different metrics have been proposed for text generation, ranging from [BLEU](https://huggingface.co/metrics/bleu) and its derivatives such as [GoogleBLEU](https://huggingface.co/metrics/google_bleu) and [GLEU](https://huggingface.co/metrics/gleu), but also [ROUGE](https://huggingface.co/metrics/rouge), [MAUVE](https://huggingface.co/metrics/mauve), etc.\n\nYou can find the right metric for your task by:\n\n- **Looking at the [Task pages](https://huggingface.co/tasks)** to see what metrics can be used for evaluating models for a given task.\n- **Checking out leaderboards** on sites like [Papers With Code](https://paperswithcode.com/) (you can search by task and by dataset).\n-  **Reading the metric cards** for the relevant metrics and see which ones are a good fit for your use case. For example, see the [BLEU metric card](https://github.com/huggingface/evaluate/tree/main/metrics/bleu) or [SQuaD metric card](https://github.com/huggingface/evaluate/tree/main/metrics/squad).\n- **Looking at papers and blog posts** published on the topic and see what metrics they report. This can change over time, so try to pick papers from the last couple of years!\n\n### Dataset-specific metrics\n\nSome datasets have specific metrics associated with them -- this is especially in the case of popular benchmarks like [GLUE](https://huggingface.co/metrics/glue) and [SQuAD](https://huggingface.co/metrics/squad).\n\n<Tip warning={true}>\n\ud83d\udca1\nGLUE is actually a collection of different subsets on different tasks, so first you need to choose the one that corresponds to the NLI task, such as mnli, which is described as \u201ccrowdsourced collection of sentence pairs with textual entailment annotations\u201d\n</Tip>\n\n\nIf you are evaluating your model on a benchmark dataset like the ones mentioned above, you can use its dedicated evaluation metric. Make sure you respect the format that they require. For example, to evaluate your model on the [SQuAD](https://huggingface.co/datasets/squad) dataset, you need to feed the `question` and `context` into your model and return the `prediction_text`, which should be compared with the `references` (based on matching the `id` of the question) :\n\n```\n>>> from evaluate import load\n>>> squad_metric = load(\"squad\")\n>>> predictions = [{'prediction_text': '1976', 'id': '56e10a3be3433e1400422b22'}]\n>>> references = [{'answers': {'answer_start': [97], 'text': ['1976']}, 'id': '56e10a3be3433e1400422b22'}]\n>>> results = squad_metric.compute(predictions=predictions, references=references)\n>>> results\n{'exact_match': 100.0, 'f1': 100.0}\n```\n\nYou can find examples of dataset structures by consulting the \"Dataset Preview\" function or the dataset card for a given dataset, and you can see how to use its dedicated evaluation function based on the metric card.\n--New Chunk--\n[Created at: 2025-03-24 13:19:17]\n!---\nCopyright 2022 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n-->\n\n# Token classification with LayoutLMv3 (PyTorch version)\n\nThis directory contains a script, `run_funsd_cord.py`, that can be used to fine-tune (or evaluate) LayoutLMv3 on form understanding datasets, such as [FUNSD](https://guillaumejaume.github.io/FUNSD/) and [CORD](https://github.com/clovaai/cord).\n\nThe script `run_funsd_cord.py` leverages the \ud83e\udd17 Datasets library and the Trainer API. You can easily customize it to your needs.\n\n## Fine-tuning on FUNSD\n\nFine-tuning LayoutLMv3 for token classification on [FUNSD](https://guillaumejaume.github.io/FUNSD/) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name funsd \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 1e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-funsd\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd. By specifying the `push_to_hub` flag, the model gets uploaded automatically to the hub (regularly), together with a model card, which includes metrics such as precision, recall and F1. Note that you can easily update the model card, as it's just a README file of the respective repo on the hub.\n\nThere's also the \"Training metrics\" [tab](https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd/tensorboard), which shows Tensorboard logs over the course of training. Pretty neat, huh?\n\n## Fine-tuning on CORD\n\nFine-tuning LayoutLMv3 for token classification on [CORD](https://github.com/clovaai/cord) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name cord \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 5e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-cord\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-cord. Note that a model card gets generated automatically in case you specify the `push_to_hub` flag."
        }
    },
    {
        "sample_idx": 23,
        "question": "What is the purpose of using the `queue()` method in Gradio?",
        "answer": "To control the processing rate and handle a large amount of traffic.",
        "rag_answer": "The purpose of using the `queue()` method in Gradio is to control the processing rate of requests. This method allows you to enable queuing, which means that Gradio will process requests in a queue, handling a limited number of requests at a time. This can be particularly useful when you expect a large volume of traffic or when your function has a long inference time (> 1 minute).\n\nBy using `queue()`, you can:\n\n1. **Prevent network timeouts**: Queuing helps prevent network timeouts by ensuring that Gradio processes requests in a controlled manner, rather than overwhelming the server with a large number of requests at once.\n2. **Control concurrency**: You can specify the concurrency count, which determines how many requests are processed simultaneously. This allows you to optimize the processing rate based on your server's capacity.\n3. **Improve performance**: Queuing can improve performance by reducing the load on your server and preventing it from becoming overwhelmed by a large number of requests.\n\nHere's an example of how to use the `queue()` method:\n```python\ndemo = gr.Interface(...).queue()\ndemo.launch()\n```\nIn this example, the `queue()` method is called on the `Interface` object, enabling queuing for the demo.",
        "rag_score": 5,
        "rag_feedback": "The system's response is completely correct, accurate, and factual. It provides a detailed explanation of the purpose of using the `queue()` method in Gradio, including controlling the processing rate, handling a large amount of traffic, preventing network timeouts, and improving performance. The response also provides examples of how to use the `queue()` method with `Interface` and `Blocks`, and explains how to control the concurrency count.",
        "rag_context": {
            "kg_context": "-----Entities-----\n    ```csv\n    id,\tentity,\ttype,\tdescription,\trankcreated_at\n1,\tConcurrency,concept,Concurrency refers to the ability of Gradio to process multiple requests simultaneously.,1,2025-03-24 13:17:31\n2,\tGradio,organization,Gradio is a platform that supports state in Blocks, providing features such as global state and session state.<SEP>Gradio is an interface that provides various features for demonstrating models, including adding example inputs, custom error messages, descriptive content, flagging, and more.<SEP>Gradio is an organization that provides a platform for building and deploying machine learning models.<SEP>Gradio is an organization that provides a platform for creating and deploying machine learning models.<SEP>Gradio is an organization that provides a demo for blocks_random_slider, and its library is used to create interactive interfaces.,36,2025-03-24 13:17:31\n3,\tqueue,category,Queue is a component in Gradio that enables the processing of batches of inputs.,1,2025-03-24 13:17:31\n4,\tQueuing,concept,Queuing refers to the process of managing the flow of requests to machine learning models in Gradio.,1,2025-03-24 13:17:31\n5,\tqueue,category,Queue is a component in Gradio that enables the processing of batches of inputs.,1,UNKNOWN\n6,\tConcurrency,concept,Concurrency refers to the ability of Gradio to process multiple requests simultaneously.,1,UNKNOWN\n7,\tQueuing,concept,Queuing refers to the process of managing the flow of requests to machine learning models in Gradio.,1,UNKNOWN\n    ```\n    -----Relationships-----\n    ```csv\n    id,\tsource,\ttarget,\tdescription,\tkeywords,\tweight,\trank,\tcreated_at\n1,\tConcurrency,Gradio,Gradio supports concurrency for processing multiple requests simultaneously.,request processing, concurrency,9.0,37,2025-03-24 13:17:31\n2,\tGradio,queue,Queue is a component in Gradio that enables batch processing.,component relationship, batch processing,8.0,37,2025-03-24 13:17:31\n3,\tGradio,Queuing,Gradio supports queuing for managing the flow of requests to machine learning models.,request management, machine learning,8.0,37,2025-03-24 13:17:31\n4,\tConcurrency,Gradio,Gradio supports concurrency for processing multiple requests simultaneously.,request processing, concurrency,9.0,37,UNKNOWN\n5,\tGradio,queue,Queue is a component in Gradio that enables batch processing.,component relationship, batch processing,8.0,37,UNKNOWN\n6,\tGradio,Queuing,Gradio supports queuing for managing the flow of requests to machine learning models.,request management, machine learning,8.0,37,UNKNOWN\n    ```\n    -----Sources-----\n    ```csv\n    id,\tcontent\n1,\t\u65f6\u5fc5\u987b\u9009\u62e9\u5176\u4e2d\u4e00\u4e2a\u5b57\u7b26\u4e32\uff0c\u8fd9\u5c06\u4f5c\u4e3a\u9644\u52a0\u5217\u4fdd\u5b58\u5230 CSV \u4e2d\u3002\n\n## \u9884\u5904\u7406\u548c\u540e\u5904\u7406 (Preprocessing and Postprocessing)\n\n![annotated](/assets/img/dataflow.svg)\n\n\u5982\u60a8\u6240\u89c1\uff0cGradio \u5305\u62ec\u53ef\u4ee5\u5904\u7406\u5404\u79cd\u4e0d\u540c\u6570\u636e\u7c7b\u578b\u7684\u7ec4\u4ef6\uff0c\u4f8b\u5982\u56fe\u50cf\u3001\u97f3\u9891\u548c\u89c6\u9891\u3002\u5927\u591a\u6570\u7ec4\u4ef6\u90fd\u53ef\u4ee5\u7528\u4f5c\u8f93\u5165\u6216\u8f93\u51fa\u3002\n\n\u5f53\u7ec4\u4ef6\u7528\u4f5c\u8f93\u5165\u65f6\uff0cGradio \u81ea\u52a8\u5904\u7406*\u9884\u5904\u7406*\uff0c\u5c06\u6570\u636e\u4ece\u7528\u6237\u6d4f\u89c8\u5668\u53d1\u9001\u7684\u7c7b\u578b\uff08\u4f8b\u5982\u7f51\u7edc\u6444\u50cf\u5934\u5feb\u7167\u7684 base64 \u8868\u793a\uff09\u8f6c\u6362\u4e3a\u60a8\u7684\u51fd\u6570\u53ef\u4ee5\u63a5\u53d7\u7684\u5f62\u5f0f\uff08\u4f8b\u5982 `numpy` \u6570\u7ec4\uff09\u3002\n\n\u540c\u6837\uff0c\u5f53\u7ec4\u4ef6\u7528\u4f5c\u8f93\u51fa\u65f6\uff0cGradio \u81ea\u52a8\u5904\u7406*\u540e\u5904\u7406*\uff0c\u5c06\u6570\u636e\u4ece\u51fd\u6570\u8fd4\u56de\u7684\u5f62\u5f0f\uff08\u4f8b\u5982\u56fe\u50cf\u8def\u5f84\u5217\u8868\uff09\u8f6c\u6362\u4e3a\u53ef\u4ee5\u5728\u7528\u6237\u6d4f\u89c8\u5668\u4e2d\u663e\u793a\u7684\u5f62\u5f0f\uff08\u4f8b\u5982\u4ee5 base64 \u683c\u5f0f\u663e\u793a\u56fe\u50cf\u7684 `Gallery`\uff09\u3002\n\n\u60a8\u53ef\u4ee5\u4f7f\u7528\u6784\u5efa\u56fe\u50cf\u7ec4\u4ef6\u65f6\u7684\u53c2\u6570\u63a7\u5236*\u9884\u5904\u7406*\u3002\u4f8b\u5982\uff0c\u5982\u679c\u60a8\u4f7f\u7528\u4ee5\u4e0b\u53c2\u6570\u5b9e\u4f8b\u5316 `Image` \u7ec4\u4ef6\uff0c\u5b83\u5c06\u5c06\u56fe\u50cf\u8f6c\u6362\u4e3a `PIL` \u7c7b\u578b\uff0c\u5e76\u5c06\u5176\u91cd\u5851\u4e3a`(100, 100)`\uff0c\u800c\u4e0d\u7ba1\u63d0\u4ea4\u65f6\u7684\u539f\u59cb\u5927\u5c0f\u5982\u4f55\uff1a\n\n```py\nimg = gr.Image(shape=(100, 100), type=\"pil\")\n```\n\n\u76f8\u53cd\uff0c\u8fd9\u91cc\u6211\u4eec\u4fdd\u7559\u56fe\u50cf\u7684\u539f\u59cb\u5927\u5c0f\uff0c\u4f46\u5728\u5c06\u5176\u8f6c\u6362\u4e3a numpy \u6570\u7ec4\u4e4b\u524d\u53cd\u8f6c\u989c\u8272\uff1a\n\n```py\nimg = gr.Image(invert_colors=True, type=\"numpy\")\n```\n\n\u540e\u5904\u7406\u8981\u5bb9\u6613\u5f97\u591a\uff01Gradio \u81ea\u52a8\u8bc6\u522b\u8fd4\u56de\u6570\u636e\u7684\u683c\u5f0f\uff08\u4f8b\u5982 `Image` \u662f `numpy` \u6570\u7ec4\u8fd8\u662f `str` \u6587\u4ef6\u8def\u5f84\uff1f\uff09\uff0c\u5e76\u5c06\u5176\u540e\u5904\u7406\u4e3a\u53ef\u4ee5\u7531\u6d4f\u89c8\u5668\u663e\u793a\u7684\u683c\u5f0f\u3002\n\n\u8bf7\u67e5\u770b[\u6587\u6863](https://gradio.app/docs)\uff0c\u4e86\u89e3\u6bcf\u4e2a\u7ec4\u4ef6\u7684\u6240\u6709\u4e0e\u9884\u5904\u7406\u76f8\u5173\u7684\u53c2\u6570\u3002\n\n## \u6837\u5f0f (Styling)\n\nGradio \u4e3b\u9898\u662f\u81ea\u5b9a\u4e49\u5e94\u7528\u7a0b\u5e8f\u5916\u89c2\u548c\u611f\u89c9\u7684\u6700\u7b80\u5355\u65b9\u6cd5\u3002\u60a8\u53ef\u4ee5\u9009\u62e9\u591a\u79cd\u4e3b\u9898\u6216\u521b\u5efa\u81ea\u5df1\u7684\u4e3b\u9898\u3002\u8981\u8fd9\u6837\u505a\uff0c\u8bf7\u5c06 `theme=` \u53c2\u6570\u4f20\u9012\u7ed9 `Interface` \u6784\u9020\u51fd\u6570\u3002\u4f8b\u5982\uff1a\n\n```python\ndemo = gr.Interface(..., theme=gr.themes.Monochrome())\n```\n\nGradio \u5e26\u6709\u4e00\u7ec4\u9884\u5148\u6784\u5efa\u7684\u4e3b\u9898\uff0c\u60a8\u53ef\u4ee5\u4ece `gr.themes.*` \u52a0\u8f7d\u3002\u60a8\u53ef\u4ee5\u6269\u5c55\u8fd9\u4e9b\u4e3b\u9898\u6216\u4ece\u5934\u5f00\u59cb\u521b\u5efa\u81ea\u5df1\u7684\u4e3b\u9898 - \u6709\u5173\u66f4\u591a\u8be6\u7ec6\u4fe1\u606f\uff0c\u8bf7\u53c2\u9605[\u4e3b\u9898\u6307\u5357](https://gradio.app/theming-guide)\u3002\n\n\u8981\u589e\u52a0\u989d\u5916\u7684\u6837\u5f0f\u80fd\u529b\uff0c\u60a8\u53ef\u4ee5 with `css=` \u5173\u952e\u5b57\u5c06\u4efb\u4f55 CSS \u4f20\u9012\u7ed9\u60a8\u7684\u5e94\u7528\u7a0b\u5e8f\u3002\nGradio \u5e94\u7528\u7a0b\u5e8f\u7684\u57fa\u7c7b\u662f `gradio-container`\uff0c\u56e0\u6b64\u4ee5\u4e0b\u662f\u4e00\u4e2a\u66f4\u6539 Gradio \u5e94\u7528\u7a0b\u5e8f\u80cc\u666f\u989c\u8272\u7684\u793a\u4f8b\uff1a\n\n```python\nwith `gr.Interface(css=\".gradio-container {background-color: red}\") as demo:\n    ...\n```\n\n## \u961f\u5217 (Queuing)\n\n\u5982\u679c\u60a8\u7684\u5e94\u7528\u7a0b\u5e8f\u9884\u8ba1\u4f1a\u6709\u5927\u91cf\u6d41\u91cf\uff0c\u8bf7 with `queue()` \u65b9\u6cd5\u6765\u63a7\u5236\u5904\u7406\u901f\u7387\u3002\u8fd9\u5c06\u6392\u961f\u5904\u7406\u8c03\u7528\uff0c\u56e0\u6b64\u4e00\u6b21\u53ea\u5904\u7406\u4e00\u5b9a\u6570\u91cf\u7684\u8bf7\u6c42\u3002\u961f\u5217\u4f7f\u7528 Websockets\uff0c\u8fd8\u53ef\u4ee5\u9632\u6b62\u7f51\u7edc\u8d85\u65f6\uff0c\u56e0\u6b64\u5982\u679c\u60a8\u7684\u51fd\u6570\u7684\u63a8\u7406\u65f6\u95f4\u5f88\u957f\uff08> 1 \u5206\u949f\uff09\uff0c\u5e94\u4f7f\u7528\u961f\u5217\u3002\n\nwith `Interface`\uff1a\n\n```python\ndemo = gr.Interface(...).queue()\ndemo.launch()\n```\n\nwith `Blocks`\uff1a\n\n```python\nwith gr.Blocks() as demo\uff1a\n    #...\ndemo.queue()\ndemo.launch()\n```\n\n\u60a8\u53ef\u4ee5\u901a\u8fc7\u4ee5\u4e0b\u65b9\u5f0f\u63a7\u5236\u4e00\u6b21\u5904\u7406\u7684\u8bf7\u6c42\u6570\u91cf\uff1a\n\n```python\ndemo.queue(concurrency_count=3)\n```\n\n\u67e5\u770b\u6709\u5173\u914d\u7f6e\u5176\u4ed6\u961f\u5217\u53c2\u6570\u7684[\u961f\u5217\u6587\u6863](/docs/#queue)\u3002\n\n\u5728 Blocks \u4e2d\u6307\u5b9a\u4ec5\u5bf9\u67d0\u4e9b\u51fd\u6570\u8fdb\u884c\u6392\u961f\uff1a\n\n```python\nwith gr.Blocks() as demo2\uff1a\n    num1 = gr.Number()\n    num2 = gr.Number()\n    output = gr.Number()\n    gr.Button(\"Add\").click(\n        lambda a, b: a + b, [num1, num2], output)\n    gr.Button(\"Multiply\").click(\n        lambda a, b: a * b, [num1, num2], output, queue=True)\ndemo2.launch()\n```\n\n## \u8fed\u4ee3\u8f93\u51fa (Iterative Outputs)\n\n\u5728\u67d0\u4e9b\u60c5\u51b5\u4e0b\uff0c\u60a8\u53ef\u80fd\u9700\u8981\u4f20\u8f93\u4e00\u7cfb\u5217\u8f93\u51fa\u800c\u4e0d\u662f\u4e00\u6b21\u663e\u793a\u5355\u4e2a\u8f93\u51fa\u3002\u4f8b\u5982\uff0c\u60a8\u53ef\u80fd\u6709\u4e00\u4e2a\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5e0c\u671b\u663e\u793a\u751f\u6210\u7684\u6bcf\u4e2a\u6b65\u9aa4\u7684\u56fe\u50cf\uff0c\u76f4\u5230\u6700\u7ec8\u56fe\u50cf\u3002\u6216\u8005\u60a8\u53ef\u80fd\u6709\u4e00\u4e2a\u804a\u5929\u673a\u5668\u4eba\uff0c\u5b83\u9010\u5b57\u9010\u53e5\u5730\u6d41\u5f0f\u4f20\u8f93\u54cd\u5e94\uff0c\u800c\u4e0d\u662f\u4e00\u6b21\u8fd4\u56de\u5168\u90e8\u54cd\u5e94\u3002\n\n\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u60a8\u53ef\u4ee5\u5c06**\u751f\u6210\u5668**\u51fd\u6570\u63d0\u4f9b\u7ed9 Gradio\uff0c\u800c\u4e0d\u662f\u5e38\u89c4\u51fd\u6570\u3002\u5728 Python \u4e2d\u521b\u5efa\u751f\u6210\u5668\u975e\u5e38\u7b80\u5355\uff1a\u51fd\u6570\u4e0d\u5e94\u8be5\u6709\u4e00\u4e2a\u5355\u72ec\u7684 `return` \u503c\uff0c\u800c\u662f\u5e94\u8be5 with `yield` \u8fde\u7eed\u8fd4\u56de\u4e00\u7cfb\u5217\u503c\u3002\u901a\u5e38\uff0c`yield` \u8bed\u53e5\u653e\u7f6e\u5728\u67d0\u79cd\u5faa\u73af\u4e2d\u3002\u4e0b\u9762\u662f\u4e00\u4e2a\u7b80\u5355\u793a\u4f8b\uff0c\u751f\u6210\u5668\u53ea\u662f\u7b80\u5355\u8ba1\u6570\u5230\u7ed9\u5b9a\u6570\u5b57\uff1a\n\n```python\ndef my_generator(x):\n    for i in range(x):\n        yield i\n```\n\n\u60a8\u4ee5\u4e0e\u5e38\u89c4\u51fd\u6570\u76f8\u540c\u7684\u65b9\u5f0f\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio\u3002\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\uff08\u865a\u62df\u7684\uff09\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5b83\u5728\u8f93\u51fa\u56fe\u50cf\u4e4b\u524d\u751f\u6210\u6570\u4e2a\u6b65\u9aa4\u7684\u566a\u97f3\uff1a\n\n$code_fake_diffusion\n$demo_fake_diffusion\n\n\u8bf7\u6ce8\u610f\uff0c\u6211\u4eec\u5728\u8fed\u4ee3\u5668\u4e2d\u6dfb\u52a0\u4e86 `time.sleep(1)`\uff0c\u4ee5\u521b\u5efa\u6b65\u9aa4\u4e4b\u95f4\u7684\u4eba\u5de5\u6682\u505c\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u89c2\u5bdf\u8fed\u4ee3\u5668\u7684\u6b65\u9aa4\uff08\u5728\u771f\u5b9e\u7684\u56fe\u50cf\u751f\u6210\u6a21\u578b\u4e2d\uff0c\u8fd9\n2,\t\u4e0e\u5e38\u89c4\u51fd\u6570\u76f8\u540c\u7684\u65b9\u5f0f\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio\u3002\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\uff08\u865a\u62df\u7684\uff09\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5b83\u5728\u8f93\u51fa\u56fe\u50cf\u4e4b\u524d\u751f\u6210\u6570\u4e2a\u6b65\u9aa4\u7684\u566a\u97f3\uff1a\n\n$code_fake_diffusion\n$demo_fake_diffusion\n\n\u8bf7\u6ce8\u610f\uff0c\u6211\u4eec\u5728\u8fed\u4ee3\u5668\u4e2d\u6dfb\u52a0\u4e86 `time.sleep(1)`\uff0c\u4ee5\u521b\u5efa\u6b65\u9aa4\u4e4b\u95f4\u7684\u4eba\u5de5\u6682\u505c\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u89c2\u5bdf\u8fed\u4ee3\u5668\u7684\u6b65\u9aa4\uff08\u5728\u771f\u5b9e\u7684\u56fe\u50cf\u751f\u6210\u6a21\u578b\u4e2d\uff0c\u8fd9\u53ef\u80fd\u662f\u4e0d\u5fc5\u8981\u7684\uff09\u3002\n\n\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio **\u9700\u8981**\u5728\u5e95\u5c42 Interface \u6216 Blocks \u4e2d\u542f\u7528\u961f\u5217\uff08\u8bf7\u53c2\u9605\u4e0a\u9762\u7684\u961f\u5217\u90e8\u5206\uff09\u3002\n\n## \u8fdb\u5ea6\u6761\n\nGradio \u652f\u6301\u521b\u5efa\u81ea\u5b9a\u4e49\u8fdb\u5ea6\u6761\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u81ea\u5b9a\u4e49\u548c\u63a7\u5236\u5411\u7528\u6237\u663e\u793a\u7684\u8fdb\u5ea6\u66f4\u65b0\u3002\u8981\u542f\u7528\u6b64\u529f\u80fd\uff0c\u53ea\u9700\u4e3a\u65b9\u6cd5\u6dfb\u52a0\u4e00\u4e2a\u9ed8\u8ba4\u503c\u4e3a `gr.Progress` \u5b9e\u4f8b\u7684\u53c2\u6570\u5373\u53ef\u3002\u7136\u540e\uff0c\u60a8\u53ef\u4ee5\u76f4\u63a5\u8c03\u7528\u6b64\u5b9e\u4f8b\u5e76\u4f20\u5165 0 \u5230 1 \u4e4b\u95f4\u7684\u6d6e\u70b9\u6570\u6765\u66f4\u65b0\u8fdb\u5ea6\u7ea7\u522b\uff0c\u6216\u8005 with `Progress` \u5b9e\u4f8b\u7684 `tqdm()` \u65b9\u6cd5\u6765\u8ddf\u8e2a\u53ef\u8fed\u4ee3\u5bf9\u8c61\u4e0a\u7684\u8fdb\u5ea6\uff0c\u5982\u4e0b\u6240\u793a\u3002\u5fc5\u987b\u542f\u7528\u961f\u5217\u4ee5\u8fdb\u884c\u8fdb\u5ea6\u66f4\u65b0\u3002\n\n$code_progress_simple\n$demo_progress_simple\n\n\u5982\u679c\u60a8 with `tqdm` \u5e93\uff0c\u5e76\u4e14\u5e0c\u671b\u4ece\u51fd\u6570\u5185\u90e8\u7684\u4efb\u4f55 `tqdm.tqdm` \u81ea\u52a8\u62a5\u544a\u8fdb\u5ea6\u66f4\u65b0\uff0c\u8bf7\u5c06\u9ed8\u8ba4\u53c2\u6570\u8bbe\u7f6e\u4e3a `gr.Progress(track_tqdm=True)`\uff01\n\n## \u6279\u5904\u7406\u51fd\u6570 (Batch Functions)\n\nGradio \u652f\u6301\u4f20\u9012*\u6279\u5904\u7406*\u51fd\u6570\u3002\u6279\u5904\u7406\u51fd\u6570\u53ea\u662f\u63a5\u53d7\u8f93\u5165\u5217\u8868\u5e76\u8fd4\u56de\u9884\u6d4b\u5217\u8868\u7684\u51fd\u6570\u3002\n\n\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\u6279\u5904\u7406\u51fd\u6570\uff0c\u5b83\u63a5\u53d7\u4e24\u4e2a\u8f93\u5165\u5217\u8868\uff08\u4e00\u4e2a\u5355\u8bcd\u5217\u8868\u548c\u4e00\u4e2a\u6574\u6570\u5217\u8868\uff09\uff0c\u5e76\u8fd4\u56de\u4fee\u526a\u8fc7\u7684\u5355\u8bcd\u5217\u8868\u4f5c\u4e3a\u8f93\u51fa\uff1a\n\n```python\nimport time\n\ndef trim_words(words, lens):\n    trimmed_words = []\n    time.sleep(5)\n    for w, l in zip(words, lens):\n        trimmed_words.append(w[:int(l)])\n    return [trimmed_words]\n    for w, l in zip(words, lens):\n```\n\n\u4f7f\u7528\u6279\u5904\u7406\u51fd\u6570\u7684\u4f18\u70b9\u662f\uff0c\u5982\u679c\u542f\u7528\u4e86\u961f\u5217\uff0cGradio \u670d\u52a1\u5668\u53ef\u4ee5\u81ea\u52a8*\u6279\u5904\u7406*\u4f20\u5165\u7684\u8bf7\u6c42\u5e76\u5e76\u884c\u5904\u7406\u5b83\u4eec\uff0c\u4ece\u800c\u53ef\u80fd\u52a0\u5feb\u6f14\u793a\u901f\u5ea6\u3002\u4ee5\u4e0b\u662f Gradio \u4ee3\u7801\u7684\u793a\u4f8b\uff08\u8bf7\u6ce8\u610f `batch=True` \u548c `max_batch_size=16` - \u8fd9\u4e24\u4e2a\u53c2\u6570\u90fd\u53ef\u4ee5\u4f20\u9012\u7ed9\u4e8b\u4ef6\u89e6\u53d1\u5668\u6216 `Interface` \u7c7b\uff09\n\nwith `Interface`\uff1a\n\n```python\ndemo = gr.Interface(trim_words, [\"textbox\", \"number\"], [\"output\"],\n                    batch=True, max_batch_size=16)\ndemo.queue()\ndemo.launch()\n```\n\nwith `Blocks`\uff1a\n\n```python\nimport gradio as gr\n\nwith gr.Blocks() as demo:\n    with gr.Row():\n        word = gr.Textbox(label=\"word\")\n        leng = gr.Number(label=\"leng\")\n        output = gr.Textbox(label=\"Output\")\n    with gr.Row():\n        run = gr.Button()\n\n    event = run.click(trim_words, [word, leng], output, batch=True, max_batch_size=16)\n\ndemo.queue()\ndemo.launch()\n```\n\n\u5728\u4e0a\u9762\u7684\u793a\u4f8b\u4e2d\uff0c\u53ef\u4ee5\u5e76\u884c\u5904\u7406 16 \u4e2a\u8bf7\u6c42\uff08\u603b\u63a8\u7406\u65f6\u95f4\u4e3a 5 \u79d2\uff09\uff0c\u800c\u4e0d\u662f\u5206\u522b\u5904\u7406\u6bcf\u4e2a\u8bf7\u6c42\uff08\u603b\u63a8\u7406\u65f6\u95f4\u4e3a 80 \u79d2\uff09\u3002\u8bb8\u591a Hugging Face \u7684 `transformers` \u548c `diffusers` \u6a21\u578b\u5728 Gradio \u7684\u6279\u5904\u7406\u6a21\u5f0f\u4e0b\u81ea\u7136\u5de5\u4f5c\uff1a\u8fd9\u662f[\u4f7f\u7528\u6279\u5904\u7406\u751f\u6210\u56fe\u50cf\u7684\u793a\u4f8b\u6f14\u793a](https://github.com/gradio-app/gradio/blob/main/demo/diffusers_with_batching/run.py)\n\n\u6ce8\u610f\uff1a\u4f7f\u7528 Gradio \u7684\u6279\u5904\u7406\u51fd\u6570 **requires** \u5728\u5e95\u5c42 Interface \u6216 Blocks \u4e2d\u542f\u7528\u961f\u5217\uff08\u8bf7\u53c2\u9605\u4e0a\u9762\u7684\u961f\u5217\u90e8\u5206\uff09\u3002\n\n## Gradio \u7b14\u8bb0\u672c (Colab Notebooks)\n\nGradio \u53ef\u4ee5\u5728\u4efb\u4f55\u8fd0\u884c Python \u7684\u5730\u65b9\u8fd0\u884c\uff0c\u5305\u62ec\u672c\u5730 Jupyter \u7b14\u8bb0\u672c\u548c\u534f\u4f5c\u7b14\u8bb0\u672c\uff0c\u5982[Google Colab](https://colab.research.google.com/)\u3002\u5bf9\u4e8e\u672c\u5730 Jupyter \u7b14\u8bb0\u672c\u548c Google Colab \u7b14\u8bb0\u672c\uff0cGradio \u5728\u672c\u5730\u670d\u52a1\u5668\u4e0a\u8fd0\u884c\uff0c\u60a8\u53ef\u4ee5\u5728\u6d4f\u89c8\u5668\u4e2d\u4e0e\u4e4b\u4ea4\u4e92\u3002\uff08\u6ce8\u610f\uff1a\u5bf9\u4e8e Google Colab\uff0c\u8fd9\u662f\u901a\u8fc7[\u670d\u52a1\u5de5\u4f5c\u5668\u96a7\u9053](https://github.com/tensorflow/tensorboard/blob/master/docs/design/colab_integration.md)\u5b9e\u73b0\u7684\uff0c\u60a8\u7684\u6d4f\u89c8\u5668\u9700\u8981\u542f\u7528 cookies\u3002\uff09\u5bf9\u4e8e\u5176\u4ed6\u8fdc\u7a0b\u7b14\u8bb0\u672c\uff0cGradio \u4e5f\u5c06\u5728\u670d\u52a1\u5668\u4e0a\u8fd0\u884c\uff0c\u4f46\u60a8\u9700\u8981\u4f7f\u7528[SSH \u96a7\u9053](https://coderwall.com/p/ohk6cg/remote-access-to-ipython-notebooks-via-ssh)\u5728\u672c\u5730\u6d4f\u89c8\u5668\u4e2d\u67e5\u770b\u5e94\u7528\u7a0b\u5e8f\u3002\u901a\u5e38\uff0c\u66f4\u7b80\u5355\u7684\u9009\u62e9\u662f\u4f7f\u7528 Gradio \u5185\u7f6e\u7684\u516c\u5171\u94fe\u63a5\uff0c[\u5728\u4e0b\u4e00\u7bc7\u6307\u5357\u4e2d\u8ba8\u8bba](/sharing-your-app/#sharing-demos)\u3002\n    ```",
            "vector_context": "[Created at: 2025-03-24 13:16:48]\n\u65f6\u5fc5\u987b\u9009\u62e9\u5176\u4e2d\u4e00\u4e2a\u5b57\u7b26\u4e32\uff0c\u8fd9\u5c06\u4f5c\u4e3a\u9644\u52a0\u5217\u4fdd\u5b58\u5230 CSV \u4e2d\u3002\n\n## \u9884\u5904\u7406\u548c\u540e\u5904\u7406 (Preprocessing and Postprocessing)\n\n![annotated](/assets/img/dataflow.svg)\n\n\u5982\u60a8\u6240\u89c1\uff0cGradio \u5305\u62ec\u53ef\u4ee5\u5904\u7406\u5404\u79cd\u4e0d\u540c\u6570\u636e\u7c7b\u578b\u7684\u7ec4\u4ef6\uff0c\u4f8b\u5982\u56fe\u50cf\u3001\u97f3\u9891\u548c\u89c6\u9891\u3002\u5927\u591a\u6570\u7ec4\u4ef6\u90fd\u53ef\u4ee5\u7528\u4f5c\u8f93\u5165\u6216\u8f93\u51fa\u3002\n\n\u5f53\u7ec4\u4ef6\u7528\u4f5c\u8f93\u5165\u65f6\uff0cGradio \u81ea\u52a8\u5904\u7406*\u9884\u5904\u7406*\uff0c\u5c06\u6570\u636e\u4ece\u7528\u6237\u6d4f\u89c8\u5668\u53d1\u9001\u7684\u7c7b\u578b\uff08\u4f8b\u5982\u7f51\u7edc\u6444\u50cf\u5934\u5feb\u7167\u7684 base64 \u8868\u793a\uff09\u8f6c\u6362\u4e3a\u60a8\u7684\u51fd\u6570\u53ef\u4ee5\u63a5\u53d7\u7684\u5f62\u5f0f\uff08\u4f8b\u5982 `numpy` \u6570\u7ec4\uff09\u3002\n\n\u540c\u6837\uff0c\u5f53\u7ec4\u4ef6\u7528\u4f5c\u8f93\u51fa\u65f6\uff0cGradio \u81ea\u52a8\u5904\u7406*\u540e\u5904\u7406*\uff0c\u5c06\u6570\u636e\u4ece\u51fd\u6570\u8fd4\u56de\u7684\u5f62\u5f0f\uff08\u4f8b\u5982\u56fe\u50cf\u8def\u5f84\u5217\u8868\uff09\u8f6c\u6362\u4e3a\u53ef\u4ee5\u5728\u7528\u6237\u6d4f\u89c8\u5668\u4e2d\u663e\u793a\u7684\u5f62\u5f0f\uff08\u4f8b\u5982\u4ee5 base64 \u683c\u5f0f\u663e\u793a\u56fe\u50cf\u7684 `Gallery`\uff09\u3002\n\n\u60a8\u53ef\u4ee5\u4f7f\u7528\u6784\u5efa\u56fe\u50cf\u7ec4\u4ef6\u65f6\u7684\u53c2\u6570\u63a7\u5236*\u9884\u5904\u7406*\u3002\u4f8b\u5982\uff0c\u5982\u679c\u60a8\u4f7f\u7528\u4ee5\u4e0b\u53c2\u6570\u5b9e\u4f8b\u5316 `Image` \u7ec4\u4ef6\uff0c\u5b83\u5c06\u5c06\u56fe\u50cf\u8f6c\u6362\u4e3a `PIL` \u7c7b\u578b\uff0c\u5e76\u5c06\u5176\u91cd\u5851\u4e3a`(100, 100)`\uff0c\u800c\u4e0d\u7ba1\u63d0\u4ea4\u65f6\u7684\u539f\u59cb\u5927\u5c0f\u5982\u4f55\uff1a\n\n```py\nimg = gr.Image(shape=(100, 100), type=\"pil\")\n```\n\n\u76f8\u53cd\uff0c\u8fd9\u91cc\u6211\u4eec\u4fdd\u7559\u56fe\u50cf\u7684\u539f\u59cb\u5927\u5c0f\uff0c\u4f46\u5728\u5c06\u5176\u8f6c\u6362\u4e3a numpy \u6570\u7ec4\u4e4b\u524d\u53cd\u8f6c\u989c\u8272\uff1a\n\n```py\nimg = gr.Image(invert_colors=True, type=\"numpy\")\n```\n\n\u540e\u5904\u7406\u8981\u5bb9\u6613\u5f97\u591a\uff01Gradio \u81ea\u52a8\u8bc6\u522b\u8fd4\u56de\u6570\u636e\u7684\u683c\u5f0f\uff08\u4f8b\u5982 `Image` \u662f `numpy` \u6570\u7ec4\u8fd8\u662f `str` \u6587\u4ef6\u8def\u5f84\uff1f\uff09\uff0c\u5e76\u5c06\u5176\u540e\u5904\u7406\u4e3a\u53ef\u4ee5\u7531\u6d4f\u89c8\u5668\u663e\u793a\u7684\u683c\u5f0f\u3002\n\n\u8bf7\u67e5\u770b[\u6587\u6863](https://gradio.app/docs)\uff0c\u4e86\u89e3\u6bcf\u4e2a\u7ec4\u4ef6\u7684\u6240\u6709\u4e0e\u9884\u5904\u7406\u76f8\u5173\u7684\u53c2\u6570\u3002\n\n## \u6837\u5f0f (Styling)\n\nGradio \u4e3b\u9898\u662f\u81ea\u5b9a\u4e49\u5e94\u7528\u7a0b\u5e8f\u5916\u89c2\u548c\u611f\u89c9\u7684\u6700\u7b80\u5355\u65b9\u6cd5\u3002\u60a8\u53ef\u4ee5\u9009\u62e9\u591a\u79cd\u4e3b\u9898\u6216\u521b\u5efa\u81ea\u5df1\u7684\u4e3b\u9898\u3002\u8981\u8fd9\u6837\u505a\uff0c\u8bf7\u5c06 `theme=` \u53c2\u6570\u4f20\u9012\u7ed9 `Interface` \u6784\u9020\u51fd\u6570\u3002\u4f8b\u5982\uff1a\n\n```python\ndemo = gr.Interface(..., theme=gr.themes.Monochrome())\n```\n\nGradio \u5e26\u6709\u4e00\u7ec4\u9884\u5148\u6784\u5efa\u7684\u4e3b\u9898\uff0c\u60a8\u53ef\u4ee5\u4ece `gr.themes.*` \u52a0\u8f7d\u3002\u60a8\u53ef\u4ee5\u6269\u5c55\u8fd9\u4e9b\u4e3b\u9898\u6216\u4ece\u5934\u5f00\u59cb\u521b\u5efa\u81ea\u5df1\u7684\u4e3b\u9898 - \u6709\u5173\u66f4\u591a\u8be6\u7ec6\u4fe1\u606f\uff0c\u8bf7\u53c2\u9605[\u4e3b\u9898\u6307\u5357](https://gradio.app/theming-guide)\u3002\n\n\u8981\u589e\u52a0\u989d\u5916\u7684\u6837\u5f0f\u80fd\u529b\uff0c\u60a8\u53ef\u4ee5 with `css=` \u5173\u952e\u5b57\u5c06\u4efb\u4f55 CSS \u4f20\u9012\u7ed9\u60a8\u7684\u5e94\u7528\u7a0b\u5e8f\u3002\nGradio \u5e94\u7528\u7a0b\u5e8f\u7684\u57fa\u7c7b\u662f `gradio-container`\uff0c\u56e0\u6b64\u4ee5\u4e0b\u662f\u4e00\u4e2a\u66f4\u6539 Gradio \u5e94\u7528\u7a0b\u5e8f\u80cc\u666f\u989c\u8272\u7684\u793a\u4f8b\uff1a\n\n```python\nwith `gr.Interface(css=\".gradio-container {background-color: red}\") as demo:\n    ...\n```\n\n## \u961f\u5217 (Queuing)\n\n\u5982\u679c\u60a8\u7684\u5e94\u7528\u7a0b\u5e8f\u9884\u8ba1\u4f1a\u6709\u5927\u91cf\u6d41\u91cf\uff0c\u8bf7 with `queue()` \u65b9\u6cd5\u6765\u63a7\u5236\u5904\u7406\u901f\u7387\u3002\u8fd9\u5c06\u6392\u961f\u5904\u7406\u8c03\u7528\uff0c\u56e0\u6b64\u4e00\u6b21\u53ea\u5904\u7406\u4e00\u5b9a\u6570\u91cf\u7684\u8bf7\u6c42\u3002\u961f\u5217\u4f7f\u7528 Websockets\uff0c\u8fd8\u53ef\u4ee5\u9632\u6b62\u7f51\u7edc\u8d85\u65f6\uff0c\u56e0\u6b64\u5982\u679c\u60a8\u7684\u51fd\u6570\u7684\u63a8\u7406\u65f6\u95f4\u5f88\u957f\uff08> 1 \u5206\u949f\uff09\uff0c\u5e94\u4f7f\u7528\u961f\u5217\u3002\n\nwith `Interface`\uff1a\n\n```python\ndemo = gr.Interface(...).queue()\ndemo.launch()\n```\n\nwith `Blocks`\uff1a\n\n```python\nwith gr.Blocks() as demo\uff1a\n    #...\ndemo.queue()\ndemo.launch()\n```\n\n\u60a8\u53ef\u4ee5\u901a\u8fc7\u4ee5\u4e0b\u65b9\u5f0f\u63a7\u5236\u4e00\u6b21\u5904\u7406\u7684\u8bf7\u6c42\u6570\u91cf\uff1a\n\n```python\ndemo.queue(concurrency_count=3)\n```\n\n\u67e5\u770b\u6709\u5173\u914d\u7f6e\u5176\u4ed6\u961f\u5217\u53c2\u6570\u7684[\u961f\u5217\u6587\u6863](/docs/#queue)\u3002\n\n\u5728 Blocks \u4e2d\u6307\u5b9a\u4ec5\u5bf9\u67d0\u4e9b\u51fd\u6570\u8fdb\u884c\u6392\u961f\uff1a\n\n```python\nwith gr.Blocks() as demo2\uff1a\n    num1 = gr.Number()\n    num2 = gr.Number()\n    output = gr.Number()\n    gr.Button(\"Add\").click(\n        lambda a, b: a + b, [num1, num2], output)\n    gr.Button(\"Multiply\").click(\n        lambda a, b: a * b, [num1, num2], output, queue=True)\ndemo2.launch()\n```\n\n## \u8fed\u4ee3\u8f93\u51fa (Iterative Outputs)\n\n\u5728\u67d0\u4e9b\u60c5\u51b5\u4e0b\uff0c\u60a8\u53ef\u80fd\u9700\u8981\u4f20\u8f93\u4e00\u7cfb\u5217\u8f93\u51fa\u800c\u4e0d\u662f\u4e00\u6b21\u663e\u793a\u5355\u4e2a\u8f93\u51fa\u3002\u4f8b\u5982\uff0c\u60a8\u53ef\u80fd\u6709\u4e00\u4e2a\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5e0c\u671b\u663e\u793a\u751f\u6210\u7684\u6bcf\u4e2a\u6b65\u9aa4\u7684\u56fe\u50cf\uff0c\u76f4\u5230\u6700\u7ec8\u56fe\u50cf\u3002\u6216\u8005\u60a8\u53ef\u80fd\u6709\u4e00\u4e2a\u804a\u5929\u673a\u5668\u4eba\uff0c\u5b83\u9010\u5b57\u9010\u53e5\u5730\u6d41\u5f0f\u4f20\u8f93\u54cd\u5e94\uff0c\u800c\u4e0d\u662f\u4e00\u6b21\u8fd4\u56de\u5168\u90e8\u54cd\u5e94\u3002\n\n\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u60a8\u53ef\u4ee5\u5c06**\u751f\u6210\u5668**\u51fd\u6570\u63d0\u4f9b\u7ed9 Gradio\uff0c\u800c\u4e0d\u662f\u5e38\u89c4\u51fd\u6570\u3002\u5728 Python \u4e2d\u521b\u5efa\u751f\u6210\u5668\u975e\u5e38\u7b80\u5355\uff1a\u51fd\u6570\u4e0d\u5e94\u8be5\u6709\u4e00\u4e2a\u5355\u72ec\u7684 `return` \u503c\uff0c\u800c\u662f\u5e94\u8be5 with `yield` \u8fde\u7eed\u8fd4\u56de\u4e00\u7cfb\u5217\u503c\u3002\u901a\u5e38\uff0c`yield` \u8bed\u53e5\u653e\u7f6e\u5728\u67d0\u79cd\u5faa\u73af\u4e2d\u3002\u4e0b\u9762\u662f\u4e00\u4e2a\u7b80\u5355\u793a\u4f8b\uff0c\u751f\u6210\u5668\u53ea\u662f\u7b80\u5355\u8ba1\u6570\u5230\u7ed9\u5b9a\u6570\u5b57\uff1a\n\n```python\ndef my_generator(x):\n    for i in range(x):\n        yield i\n```\n\n\u60a8\u4ee5\u4e0e\u5e38\u89c4\u51fd\u6570\u76f8\u540c\u7684\u65b9\u5f0f\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio\u3002\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\uff08\u865a\u62df\u7684\uff09\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5b83\u5728\u8f93\u51fa\u56fe\u50cf\u4e4b\u524d\u751f\u6210\u6570\u4e2a\u6b65\u9aa4\u7684\u566a\u97f3\uff1a\n\n$code_fake_diffusion\n$demo_fake_diffusion\n\n\u8bf7\u6ce8\u610f\uff0c\u6211\u4eec\u5728\u8fed\u4ee3\u5668\u4e2d\u6dfb\u52a0\u4e86 `time.sleep(1)`\uff0c\u4ee5\u521b\u5efa\u6b65\u9aa4\u4e4b\u95f4\u7684\u4eba\u5de5\u6682\u505c\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u89c2\u5bdf\u8fed\u4ee3\u5668\u7684\u6b65\u9aa4\uff08\u5728\u771f\u5b9e\u7684\u56fe\u50cf\u751f\u6210\u6a21\u578b\u4e2d\uff0c\u8fd9\n--New Chunk--\n[Created at: 2025-03-24 13:16:48]\n\u4e3b\u8981\u7279\u70b9\n\n\u8ba9\u6211\u4eec\u6765\u4ecb\u7ecd\u4e00\u4e0b Gradio \u6700\u53d7\u6b22\u8fce\u7684\u4e00\u4e9b\u529f\u80fd\uff01\u8fd9\u91cc\u662f Gradio \u7684\u4e3b\u8981\u7279\u70b9\uff1a\n\n1. [\u6dfb\u52a0\u793a\u4f8b\u8f93\u5165](#example-inputs)\n2. [\u4f20\u9012\u81ea\u5b9a\u4e49\u9519\u8bef\u6d88\u606f](#errors)\n3. [\u6dfb\u52a0\u63cf\u8ff0\u5185\u5bb9](#descriptive-content)\n4. [\u8bbe\u7f6e\u65d7\u6807](#flagging)\n5. [\u9884\u5904\u7406\u548c\u540e\u5904\u7406](#preprocessing-and-postprocessing)\n6. [\u6837\u5f0f\u5316\u6f14\u793a](#styling)\n7. [\u6392\u961f\u7528\u6237](#queuing)\n8. [\u8fed\u4ee3\u8f93\u51fa](#iterative-outputs)\n9. [\u8fdb\u5ea6\u6761](#progress-bars)\n10. [\u6279\u5904\u7406\u51fd\u6570](#batch-functions)\n11. [\u5728\u534f\u4f5c\u7b14\u8bb0\u672c\u4e0a\u8fd0\u884c](#colab-notebooks)\n\n## \u793a\u4f8b\u8f93\u5165\n\n\u60a8\u53ef\u4ee5\u63d0\u4f9b\u7528\u6237\u53ef\u4ee5\u8f7b\u677e\u52a0\u8f7d\u5230 \"Interface\" \u4e2d\u7684\u793a\u4f8b\u6570\u636e\u3002\u8fd9\u5bf9\u4e8e\u6f14\u793a\u6a21\u578b\u671f\u671b\u7684\u8f93\u5165\u7c7b\u578b\u4ee5\u53ca\u6f14\u793a\u6570\u636e\u96c6\u548c\u6a21\u578b\u4e00\u8d77\u63a2\u7d22\u7684\u65b9\u5f0f\u975e\u5e38\u6709\u5e2e\u52a9\u3002\u8981\u52a0\u8f7d\u793a\u4f8b\u6570\u636e\uff0c\u60a8\u53ef\u4ee5\u5c06\u5d4c\u5957\u5217\u8868\u63d0\u4f9b\u7ed9 Interface \u6784\u9020\u51fd\u6570\u7684 `examples=` \u5173\u952e\u5b57\u53c2\u6570\u3002\u5916\u90e8\u5217\u8868\u4e2d\u7684\u6bcf\u4e2a\u5b50\u5217\u8868\u8868\u793a\u4e00\u4e2a\u6570\u636e\u6837\u672c\uff0c\u5b50\u5217\u8868\u4e2d\u7684\u6bcf\u4e2a\u5143\u7d20\u8868\u793a\u6bcf\u4e2a\u8f93\u5165\u7ec4\u4ef6\u7684\u8f93\u5165\u3002\u6709\u5173\u6bcf\u4e2a\u7ec4\u4ef6\u7684\u793a\u4f8b\u6570\u636e\u683c\u5f0f\u5728[Docs](https://gradio.app/docs#components)\u4e2d\u6709\u8bf4\u660e\u3002\n\n$code_calculator\n$demo_calculator\n\n\u60a8\u53ef\u4ee5\u5c06\u5927\u578b\u6570\u636e\u96c6\u52a0\u8f7d\u5230\u793a\u4f8b\u4e2d\uff0c\u901a\u8fc7 Gradio \u6d4f\u89c8\u548c\u4e0e\u6570\u636e\u96c6\u8fdb\u884c\u4ea4\u4e92\u3002\u793a\u4f8b\u5c06\u81ea\u52a8\u5206\u9875\uff08\u53ef\u4ee5\u901a\u8fc7 Interface \u7684 `examples_per_page` \u53c2\u6570\u8fdb\u884c\u914d\u7f6e\uff09\u3002\n\n\u7ee7\u7eed\u4e86\u89e3\u793a\u4f8b\uff0c\u8bf7\u53c2\u9605[\u66f4\u591a\u793a\u4f8b](https://gradio.app/more-on-examples)\u6307\u5357\u3002\n\n## \u9519\u8bef\n\n\u60a8\u5e0c\u671b\u5411\u7528\u6237\u4f20\u9012\u81ea\u5b9a\u4e49\u9519\u8bef\u6d88\u606f\u3002\u4e3a\u6b64\uff0cwith `gr.Error(\"custom message\")` \u6765\u663e\u793a\u9519\u8bef\u6d88\u606f\u3002\u5982\u679c\u5728\u4e0a\u9762\u7684\u8ba1\u7b97\u5668\u793a\u4f8b\u4e2d\u5c1d\u8bd5\u9664\u4ee5\u96f6\uff0c\u5c06\u663e\u793a\u81ea\u5b9a\u4e49\u9519\u8bef\u6d88\u606f\u7684\u5f39\u51fa\u6a21\u6001\u7a97\u53e3\u3002\u4e86\u89e3\u6709\u5173\u9519\u8bef\u7684\u66f4\u591a\u4fe1\u606f\uff0c\u8bf7\u53c2\u9605[\u6587\u6863](https://gradio.app/docs#error)\u3002\n\n## \u63cf\u8ff0\u6027\u5185\u5bb9\n\n\u5728\u524d\u9762\u7684\u793a\u4f8b\u4e2d\uff0c\u60a8\u53ef\u80fd\u5df2\u7ecf\u6ce8\u610f\u5230 Interface \u6784\u9020\u51fd\u6570\u4e2d\u7684 `title=` \u548c `description=` \u5173\u952e\u5b57\u53c2\u6570\uff0c\u5e2e\u52a9\u7528\u6237\u4e86\u89e3\u60a8\u7684\u5e94\u7528\u7a0b\u5e8f\u3002\n\nInterface \u6784\u9020\u51fd\u6570\u4e2d\u6709\u4e09\u4e2a\u53c2\u6570\u7528\u4e8e\u6307\u5b9a\u6b64\u5185\u5bb9\u5e94\u653e\u7f6e\u5728\u54ea\u91cc\uff1a\n\n- `title`\uff1a\u63a5\u53d7\u6587\u672c\uff0c\u5e76\u53ef\u4ee5\u5c06\u5176\u663e\u793a\u5728\u754c\u9762\u7684\u9876\u90e8\uff0c\u4e5f\u5c06\u6210\u4e3a\u9875\u9762\u6807\u9898\u3002\n- `description`\uff1a\u63a5\u53d7\u6587\u672c\u3001Markdown \u6216 HTML\uff0c\u5e76\u5c06\u5176\u653e\u7f6e\u5728\u6807\u9898\u6b63\u4e0b\u65b9\u3002\n- `article`\uff1a\u4e5f\u63a5\u53d7\u6587\u672c\u3001Markdown \u6216 HTML\uff0c\u5e76\u5c06\u5176\u653e\u7f6e\u5728\u754c\u9762\u4e0b\u65b9\u3002\n\n![annotated](/assets/guides/annotated.png)\n\n\u5982\u679c\u60a8\u4f7f\u7528\u7684\u662f `Blocks` API\uff0c\u5219\u53ef\u4ee5 with `gr.Markdown(...)` \u6216 `gr.HTML(...)` \u7ec4\u4ef6\u5728\u4efb\u4f55\u4f4d\u7f6e\u63d2\u5165\u6587\u672c\u3001Markdown \u6216 HTML\uff0c\u5176\u4e2d\u63cf\u8ff0\u6027\u5185\u5bb9\u4f4d\u4e8e `Component` \u6784\u9020\u51fd\u6570\u5185\u90e8\u3002\n\n\u53e6\u4e00\u4e2a\u6709\u7528\u7684\u5173\u952e\u5b57\u53c2\u6570\u662f `label=`\uff0c\u5b83\u5b58\u5728\u4e8e\u6bcf\u4e2a `Component` \u4e2d\u3002\u8fd9\u4fee\u6539\u4e86\u6bcf\u4e2a `Component` \u9876\u90e8\u7684\u6807\u7b7e\u6587\u672c\u3002\u8fd8\u53ef\u4ee5\u4e3a\u8bf8\u5982 `Textbox` \u6216 `Radio` \u4e4b\u7c7b\u7684\u8868\u5355\u5143\u7d20\u6dfb\u52a0 `info=` \u5173\u952e\u5b57\u53c2\u6570\uff0c\u4ee5\u63d0\u4f9b\u6709\u5173\u5176\u7528\u6cd5\u7684\u8fdb\u4e00\u6b65\u4fe1\u606f\u3002\n\n```python\ngr.Number(label='\u5e74\u9f84', info='\u4ee5\u5e74\u4e3a\u5355\u4f4d\uff0c\u5fc5\u987b\u5927\u4e8e0')\n```\n\n## \u65d7\u6807\n\n\u9ed8\u8ba4\u60c5\u51b5\u4e0b\uff0c\"Interface\" \u5c06\u6709\u4e00\u4e2a \"Flag\" \u6309\u94ae\u3002\u5f53\u7528\u6237\u6d4b\u8bd5\u60a8\u7684 `Interface` \u65f6\uff0c\u5982\u679c\u770b\u5230\u6709\u8da3\u7684\u8f93\u51fa\uff0c\u4f8b\u5982\u9519\u8bef\u6216\u610f\u5916\u7684\u6a21\u578b\u884c\u4e3a\uff0c\u4ed6\u4eec\u53ef\u4ee5\u5c06\u8f93\u5165\u6807\u8bb0\u4e3a\u60a8\u8fdb\u884c\u67e5\u770b\u3002\u5728\u7531 `Interface` \u6784\u9020\u51fd\u6570\u7684 `flagging_dir=` \u53c2\u6570\u63d0\u4f9b\u7684\u76ee\u5f55\u4e2d\uff0c\u5c06\u8bb0\u5f55\u6807\u8bb0\u7684\u8f93\u5165\u5230\u4e00\u4e2a CSV \u6587\u4ef6\u4e2d\u3002\u5982\u679c\u754c\u9762\u6d89\u53ca\u6587\u4ef6\u6570\u636e\uff0c\u4f8b\u5982\u56fe\u50cf\u548c\u97f3\u9891\u7ec4\u4ef6\uff0c\u5c06\u521b\u5efa\u6587\u4ef6\u5939\u6765\u5b58\u50a8\u8fd9\u4e9b\u6807\u8bb0\u7684\u6570\u636e\u3002\n\n\u4f8b\u5982\uff0c\u5bf9\u4e8e\u4e0a\u9762\u663e\u793a\u7684\u8ba1\u7b97\u5668\u754c\u9762\uff0c\u6211\u4eec\u5c06\u5728\u4e0b\u9762\u7684\u65d7\u6807\u76ee\u5f55\u4e2d\u5b58\u50a8\u6807\u8bb0\u7684\u6570\u636e\uff1a\n\n```directory\n+-- calculator.py\n+-- flagged/\n|   +-- logs.csv\n```\n\n_flagged/logs.csv_\n\n```csv\nnum1,operation,num2,Output\n5,add,7,12\n6,subtract,1.5,4.5\n```\n\n\u4e0e\u65e9\u671f\u663e\u793a\u7684\u51b7\u8272\u754c\u9762\u76f8\u5bf9\u5e94\uff0c\u6211\u4eec\u5c06\u5728\u4e0b\u9762\u7684\u65d7\u6807\u76ee\u5f55\u4e2d\u5b58\u50a8\u6807\u8bb0\u7684\u6570\u636e\uff1a\n\n```directory\n+-- sepia.py\n+-- flagged/\n|   +-- logs.csv\n|   +-- im/\n|   |   +-- 0.png\n|   |   +-- 1.png\n|   +-- Output/\n|   |   +-- 0.png\n|   |   +-- 1.png\n```\n\n_flagged/logs.csv_\n\n```csv\nim,Output\nim/0.png,Output/0.png\nim/1.png,Output/1.png\n```\n\n\u5982\u679c\u60a8\u5e0c\u671b\u7528\u6237\u63d0\u4f9b\u65d7\u6807\u539f\u56e0\uff0c\u53ef\u4ee5\u5c06\u5b57\u7b26\u4e32\u5217\u8868\u4f20\u9012\u7ed9 Interface \u7684 `flagging_options` \u53c2\u6570\u3002\u7528\u6237\u5728\u8fdb\u884c\u65d7\u6807\u65f6\u5fc5\u987b\u9009\u62e9\u5176\u4e2d\u4e00\u4e2a\u5b57\u7b26\u4e32\uff0c\u8fd9\u5c06\u4f5c\u4e3a\u9644\u52a0\u5217\u4fdd\u5b58\u5230 CSV \u4e2d\u3002\n\n## \u9884\u5904\u7406\u548c\u540e\u5904\u7406 (Preprocessing and Postprocessing)\n\n![annotated](/assets/img/dataflow.svg)\n\n\u5982\u60a8\u6240\u89c1\uff0cGradio \u5305\u62ec\u53ef\u4ee5\u5904\u7406\u5404\u79cd\u4e0d\u540c\u6570\u636e\u7c7b\u578b\u7684\u7ec4\u4ef6\uff0c\u4f8b\u5982\u56fe\u50cf\u3001\u97f3\u9891\u548c\u89c6\u9891\u3002\u5927\u591a\u6570\u7ec4\u4ef6\u90fd\u53ef\u4ee5\u7528\u4f5c\u8f93\u5165\u6216\u8f93\u51fa\u3002\n\n\u5f53\u7ec4\u4ef6\u7528\u4f5c\u8f93\u5165\u65f6\uff0cGradio \u81ea\u52a8\u5904\u7406*\u9884\u5904\u7406*\uff0c\u5c06\u6570\u636e\u4ece\u7528\u6237\n--New Chunk--\n[Created at: 2025-03-24 13:16:48]\n\u4e0e\u5e38\u89c4\u51fd\u6570\u76f8\u540c\u7684\u65b9\u5f0f\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio\u3002\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\uff08\u865a\u62df\u7684\uff09\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5b83\u5728\u8f93\u51fa\u56fe\u50cf\u4e4b\u524d\u751f\u6210\u6570\u4e2a\u6b65\u9aa4\u7684\u566a\u97f3\uff1a\n\n$code_fake_diffusion\n$demo_fake_diffusion\n\n\u8bf7\u6ce8\u610f\uff0c\u6211\u4eec\u5728\u8fed\u4ee3\u5668\u4e2d\u6dfb\u52a0\u4e86 `time.sleep(1)`\uff0c\u4ee5\u521b\u5efa\u6b65\u9aa4\u4e4b\u95f4\u7684\u4eba\u5de5\u6682\u505c\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u89c2\u5bdf\u8fed\u4ee3\u5668\u7684\u6b65\u9aa4\uff08\u5728\u771f\u5b9e\u7684\u56fe\u50cf\u751f\u6210\u6a21\u578b\u4e2d\uff0c\u8fd9\u53ef\u80fd\u662f\u4e0d\u5fc5\u8981\u7684\uff09\u3002\n\n\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio **\u9700\u8981**\u5728\u5e95\u5c42 Interface \u6216 Blocks \u4e2d\u542f\u7528\u961f\u5217\uff08\u8bf7\u53c2\u9605\u4e0a\u9762\u7684\u961f\u5217\u90e8\u5206\uff09\u3002\n\n## \u8fdb\u5ea6\u6761\n\nGradio \u652f\u6301\u521b\u5efa\u81ea\u5b9a\u4e49\u8fdb\u5ea6\u6761\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u81ea\u5b9a\u4e49\u548c\u63a7\u5236\u5411\u7528\u6237\u663e\u793a\u7684\u8fdb\u5ea6\u66f4\u65b0\u3002\u8981\u542f\u7528\u6b64\u529f\u80fd\uff0c\u53ea\u9700\u4e3a\u65b9\u6cd5\u6dfb\u52a0\u4e00\u4e2a\u9ed8\u8ba4\u503c\u4e3a `gr.Progress` \u5b9e\u4f8b\u7684\u53c2\u6570\u5373\u53ef\u3002\u7136\u540e\uff0c\u60a8\u53ef\u4ee5\u76f4\u63a5\u8c03\u7528\u6b64\u5b9e\u4f8b\u5e76\u4f20\u5165 0 \u5230 1 \u4e4b\u95f4\u7684\u6d6e\u70b9\u6570\u6765\u66f4\u65b0\u8fdb\u5ea6\u7ea7\u522b\uff0c\u6216\u8005 with `Progress` \u5b9e\u4f8b\u7684 `tqdm()` \u65b9\u6cd5\u6765\u8ddf\u8e2a\u53ef\u8fed\u4ee3\u5bf9\u8c61\u4e0a\u7684\u8fdb\u5ea6\uff0c\u5982\u4e0b\u6240\u793a\u3002\u5fc5\u987b\u542f\u7528\u961f\u5217\u4ee5\u8fdb\u884c\u8fdb\u5ea6\u66f4\u65b0\u3002\n\n$code_progress_simple\n$demo_progress_simple\n\n\u5982\u679c\u60a8 with `tqdm` \u5e93\uff0c\u5e76\u4e14\u5e0c\u671b\u4ece\u51fd\u6570\u5185\u90e8\u7684\u4efb\u4f55 `tqdm.tqdm` \u81ea\u52a8\u62a5\u544a\u8fdb\u5ea6\u66f4\u65b0\uff0c\u8bf7\u5c06\u9ed8\u8ba4\u53c2\u6570\u8bbe\u7f6e\u4e3a `gr.Progress(track_tqdm=True)`\uff01\n\n## \u6279\u5904\u7406\u51fd\u6570 (Batch Functions)\n\nGradio \u652f\u6301\u4f20\u9012*\u6279\u5904\u7406*\u51fd\u6570\u3002\u6279\u5904\u7406\u51fd\u6570\u53ea\u662f\u63a5\u53d7\u8f93\u5165\u5217\u8868\u5e76\u8fd4\u56de\u9884\u6d4b\u5217\u8868\u7684\u51fd\u6570\u3002\n\n\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\u6279\u5904\u7406\u51fd\u6570\uff0c\u5b83\u63a5\u53d7\u4e24\u4e2a\u8f93\u5165\u5217\u8868\uff08\u4e00\u4e2a\u5355\u8bcd\u5217\u8868\u548c\u4e00\u4e2a\u6574\u6570\u5217\u8868\uff09\uff0c\u5e76\u8fd4\u56de\u4fee\u526a\u8fc7\u7684\u5355\u8bcd\u5217\u8868\u4f5c\u4e3a\u8f93\u51fa\uff1a\n\n```python\nimport time\n\ndef trim_words(words, lens):\n    trimmed_words = []\n    time.sleep(5)\n    for w, l in zip(words, lens):\n        trimmed_words.append(w[:int(l)])\n    return [trimmed_words]\n    for w, l in zip(words, lens):\n```\n\n\u4f7f\u7528\u6279\u5904\u7406\u51fd\u6570\u7684\u4f18\u70b9\u662f\uff0c\u5982\u679c\u542f\u7528\u4e86\u961f\u5217\uff0cGradio \u670d\u52a1\u5668\u53ef\u4ee5\u81ea\u52a8*\u6279\u5904\u7406*\u4f20\u5165\u7684\u8bf7\u6c42\u5e76\u5e76\u884c\u5904\u7406\u5b83\u4eec\uff0c\u4ece\u800c\u53ef\u80fd\u52a0\u5feb\u6f14\u793a\u901f\u5ea6\u3002\u4ee5\u4e0b\u662f Gradio \u4ee3\u7801\u7684\u793a\u4f8b\uff08\u8bf7\u6ce8\u610f `batch=True` \u548c `max_batch_size=16` - \u8fd9\u4e24\u4e2a\u53c2\u6570\u90fd\u53ef\u4ee5\u4f20\u9012\u7ed9\u4e8b\u4ef6\u89e6\u53d1\u5668\u6216 `Interface` \u7c7b\uff09\n\nwith `Interface`\uff1a\n\n```python\ndemo = gr.Interface(trim_words, [\"textbox\", \"number\"], [\"output\"],\n                    batch=True, max_batch_size=16)\ndemo.queue()\ndemo.launch()\n```\n\nwith `Blocks`\uff1a\n\n```python\nimport gradio as gr\n\nwith gr.Blocks() as demo:\n    with gr.Row():\n        word = gr.Textbox(label=\"word\")\n        leng = gr.Number(label=\"leng\")\n        output = gr.Textbox(label=\"Output\")\n    with gr.Row():\n        run = gr.Button()\n\n    event = run.click(trim_words, [word, leng], output, batch=True, max_batch_size=16)\n\ndemo.queue()\ndemo.launch()\n```\n\n\u5728\u4e0a\u9762\u7684\u793a\u4f8b\u4e2d\uff0c\u53ef\u4ee5\u5e76\u884c\u5904\u7406 16 \u4e2a\u8bf7\u6c42\uff08\u603b\u63a8\u7406\u65f6\u95f4\u4e3a 5 \u79d2\uff09\uff0c\u800c\u4e0d\u662f\u5206\u522b\u5904\u7406\u6bcf\u4e2a\u8bf7\u6c42\uff08\u603b\u63a8\u7406\u65f6\u95f4\u4e3a 80 \u79d2\uff09\u3002\u8bb8\u591a Hugging Face \u7684 `transformers` \u548c `diffusers` \u6a21\u578b\u5728 Gradio \u7684\u6279\u5904\u7406\u6a21\u5f0f\u4e0b\u81ea\u7136\u5de5\u4f5c\uff1a\u8fd9\u662f[\u4f7f\u7528\u6279\u5904\u7406\u751f\u6210\u56fe\u50cf\u7684\u793a\u4f8b\u6f14\u793a](https://github.com/gradio-app/gradio/blob/main/demo/diffusers_with_batching/run.py)\n\n\u6ce8\u610f\uff1a\u4f7f\u7528 Gradio \u7684\u6279\u5904\u7406\u51fd\u6570 **requires** \u5728\u5e95\u5c42 Interface \u6216 Blocks \u4e2d\u542f\u7528\u961f\u5217\uff08\u8bf7\u53c2\u9605\u4e0a\u9762\u7684\u961f\u5217\u90e8\u5206\uff09\u3002\n\n## Gradio \u7b14\u8bb0\u672c (Colab Notebooks)\n\nGradio \u53ef\u4ee5\u5728\u4efb\u4f55\u8fd0\u884c Python \u7684\u5730\u65b9\u8fd0\u884c\uff0c\u5305\u62ec\u672c\u5730 Jupyter \u7b14\u8bb0\u672c\u548c\u534f\u4f5c\u7b14\u8bb0\u672c\uff0c\u5982[Google Colab](https://colab.research.google.com/)\u3002\u5bf9\u4e8e\u672c\u5730 Jupyter \u7b14\u8bb0\u672c\u548c Google Colab \u7b14\u8bb0\u672c\uff0cGradio \u5728\u672c\u5730\u670d\u52a1\u5668\u4e0a\u8fd0\u884c\uff0c\u60a8\u53ef\u4ee5\u5728\u6d4f\u89c8\u5668\u4e2d\u4e0e\u4e4b\u4ea4\u4e92\u3002\uff08\u6ce8\u610f\uff1a\u5bf9\u4e8e Google Colab\uff0c\u8fd9\u662f\u901a\u8fc7[\u670d\u52a1\u5de5\u4f5c\u5668\u96a7\u9053](https://github.com/tensorflow/tensorboard/blob/master/docs/design/colab_integration.md)\u5b9e\u73b0\u7684\uff0c\u60a8\u7684\u6d4f\u89c8\u5668\u9700\u8981\u542f\u7528 cookies\u3002\uff09\u5bf9\u4e8e\u5176\u4ed6\u8fdc\u7a0b\u7b14\u8bb0\u672c\uff0cGradio \u4e5f\u5c06\u5728\u670d\u52a1\u5668\u4e0a\u8fd0\u884c\uff0c\u4f46\u60a8\u9700\u8981\u4f7f\u7528[SSH \u96a7\u9053](https://coderwall.com/p/ohk6cg/remote-access-to-ipython-notebooks-via-ssh)\u5728\u672c\u5730\u6d4f\u89c8\u5668\u4e2d\u67e5\u770b\u5e94\u7528\u7a0b\u5e8f\u3002\u901a\u5e38\uff0c\u66f4\u7b80\u5355\u7684\u9009\u62e9\u662f\u4f7f\u7528 Gradio \u5185\u7f6e\u7684\u516c\u5171\u94fe\u63a5\uff0c[\u5728\u4e0b\u4e00\u7bc7\u6307\u5357\u4e2d\u8ba8\u8bba](/sharing-your-app/#sharing-demos)\u3002"
        }
    },
    {
        "sample_idx": 24,
        "question": "How can you specify the number of requests to process at once in Gradio?",
        "answer": "By using the `concurrency_count` parameter, for example: `demo.queue(concurrency_count=3)`.",
        "rag_answer": "In Gradio, you can specify the number of requests to process at once by using the `concurrency_count` parameter when queuing your interface or blocks. This parameter controls the number of concurrent requests that are processed simultaneously.\n\nHere's an example:\n```\ndemo = gr.Interface(...).queue(concurrency_count=3)\ndemo.launch()\n```\nIn this example, Gradio will process 3 requests concurrently. You can adjust this number based on your specific use case and performance requirements.\n\nNote that this parameter only applies when queuing is enabled, which is necessary for processing multiple requests concurrently.\n\nReferences:\n[KG] Gradio Knowledge Graph, Queuing\n[DC] Gradio Documentation, Queuing",
        "rag_score": 5,
        "rag_feedback": "The system's response is completely correct, accurate, and factual. It provides a detailed explanation of how to specify the number of requests to process at once in Gradio, including the use of the `concurrency_count` parameter. The response also includes relevant code examples and references to the Gradio documentation.",
        "rag_context": {
            "kg_context": "-----Entities-----\n    ```csv\n    id,\tentity,\ttype,\tdescription,\trankcreated_at\n1,\tConcurrency,concept,Concurrency refers to the ability of Gradio to process multiple requests simultaneously.,1,2025-03-24 13:17:31\n2,\tGradio,organization,Gradio is a platform that supports state in Blocks, providing features such as global state and session state.<SEP>Gradio is an interface that provides various features for demonstrating models, including adding example inputs, custom error messages, descriptive content, flagging, and more.<SEP>Gradio is an organization that provides a platform for building and deploying machine learning models.<SEP>Gradio is an organization that provides a platform for creating and deploying machine learning models.<SEP>Gradio is an organization that provides a demo for blocks_random_slider, and its library is used to create interactive interfaces.,36,2025-03-24 13:17:31\n3,\tQueuing,concept,Queuing refers to the process of managing the flow of requests to machine learning models in Gradio.,1,2025-03-24 13:17:31\n4,\tqueue,category,Queue is a component in Gradio that enables the processing of batches of inputs.,1,2025-03-24 13:17:31\n5,\tConcurrency,concept,Concurrency refers to the ability of Gradio to process multiple requests simultaneously.,1,UNKNOWN\n6,\tBatch Functions,category,Batch Functions is a category of functions in Gradio that enables the processing of batches of inputs.,1,UNKNOWN\n7,\tQueuing,concept,Queuing refers to the process of managing the flow of requests to machine learning models in Gradio.,1,UNKNOWN\n    ```\n    -----Relationships-----\n    ```csv\n    id,\tsource,\ttarget,\tdescription,\tkeywords,\tweight,\trank,\tcreated_at\n1,\tConcurrency,Gradio,Gradio supports concurrency for processing multiple requests simultaneously.,request processing, concurrency,9.0,37,2025-03-24 13:17:31\n2,\tGradio,Queuing,Gradio supports queuing for managing the flow of requests to machine learning models.,request management, machine learning,8.0,37,2025-03-24 13:17:31\n3,\tGradio,queue,Queue is a component in Gradio that enables batch processing.,component relationship, batch processing,8.0,37,2025-03-24 13:17:31\n4,\tBatch Functions,Gradio,Gradio supports batch processing of inputs using batch functions.,functionality, batch processing,18.0,37,UNKNOWN\n5,\tConcurrency,Gradio,Gradio supports concurrency for processing multiple requests simultaneously.,request processing, concurrency,9.0,37,UNKNOWN\n6,\tGradio,Queuing,Gradio supports queuing for managing the flow of requests to machine learning models.,request management, machine learning,8.0,37,UNKNOWN\n    ```\n    -----Sources-----\n    ```csv\n    id,\tcontent\n1,\t\u65f6\u5fc5\u987b\u9009\u62e9\u5176\u4e2d\u4e00\u4e2a\u5b57\u7b26\u4e32\uff0c\u8fd9\u5c06\u4f5c\u4e3a\u9644\u52a0\u5217\u4fdd\u5b58\u5230 CSV \u4e2d\u3002\n\n## \u9884\u5904\u7406\u548c\u540e\u5904\u7406 (Preprocessing and Postprocessing)\n\n![annotated](/assets/img/dataflow.svg)\n\n\u5982\u60a8\u6240\u89c1\uff0cGradio \u5305\u62ec\u53ef\u4ee5\u5904\u7406\u5404\u79cd\u4e0d\u540c\u6570\u636e\u7c7b\u578b\u7684\u7ec4\u4ef6\uff0c\u4f8b\u5982\u56fe\u50cf\u3001\u97f3\u9891\u548c\u89c6\u9891\u3002\u5927\u591a\u6570\u7ec4\u4ef6\u90fd\u53ef\u4ee5\u7528\u4f5c\u8f93\u5165\u6216\u8f93\u51fa\u3002\n\n\u5f53\u7ec4\u4ef6\u7528\u4f5c\u8f93\u5165\u65f6\uff0cGradio \u81ea\u52a8\u5904\u7406*\u9884\u5904\u7406*\uff0c\u5c06\u6570\u636e\u4ece\u7528\u6237\u6d4f\u89c8\u5668\u53d1\u9001\u7684\u7c7b\u578b\uff08\u4f8b\u5982\u7f51\u7edc\u6444\u50cf\u5934\u5feb\u7167\u7684 base64 \u8868\u793a\uff09\u8f6c\u6362\u4e3a\u60a8\u7684\u51fd\u6570\u53ef\u4ee5\u63a5\u53d7\u7684\u5f62\u5f0f\uff08\u4f8b\u5982 `numpy` \u6570\u7ec4\uff09\u3002\n\n\u540c\u6837\uff0c\u5f53\u7ec4\u4ef6\u7528\u4f5c\u8f93\u51fa\u65f6\uff0cGradio \u81ea\u52a8\u5904\u7406*\u540e\u5904\u7406*\uff0c\u5c06\u6570\u636e\u4ece\u51fd\u6570\u8fd4\u56de\u7684\u5f62\u5f0f\uff08\u4f8b\u5982\u56fe\u50cf\u8def\u5f84\u5217\u8868\uff09\u8f6c\u6362\u4e3a\u53ef\u4ee5\u5728\u7528\u6237\u6d4f\u89c8\u5668\u4e2d\u663e\u793a\u7684\u5f62\u5f0f\uff08\u4f8b\u5982\u4ee5 base64 \u683c\u5f0f\u663e\u793a\u56fe\u50cf\u7684 `Gallery`\uff09\u3002\n\n\u60a8\u53ef\u4ee5\u4f7f\u7528\u6784\u5efa\u56fe\u50cf\u7ec4\u4ef6\u65f6\u7684\u53c2\u6570\u63a7\u5236*\u9884\u5904\u7406*\u3002\u4f8b\u5982\uff0c\u5982\u679c\u60a8\u4f7f\u7528\u4ee5\u4e0b\u53c2\u6570\u5b9e\u4f8b\u5316 `Image` \u7ec4\u4ef6\uff0c\u5b83\u5c06\u5c06\u56fe\u50cf\u8f6c\u6362\u4e3a `PIL` \u7c7b\u578b\uff0c\u5e76\u5c06\u5176\u91cd\u5851\u4e3a`(100, 100)`\uff0c\u800c\u4e0d\u7ba1\u63d0\u4ea4\u65f6\u7684\u539f\u59cb\u5927\u5c0f\u5982\u4f55\uff1a\n\n```py\nimg = gr.Image(shape=(100, 100), type=\"pil\")\n```\n\n\u76f8\u53cd\uff0c\u8fd9\u91cc\u6211\u4eec\u4fdd\u7559\u56fe\u50cf\u7684\u539f\u59cb\u5927\u5c0f\uff0c\u4f46\u5728\u5c06\u5176\u8f6c\u6362\u4e3a numpy \u6570\u7ec4\u4e4b\u524d\u53cd\u8f6c\u989c\u8272\uff1a\n\n```py\nimg = gr.Image(invert_colors=True, type=\"numpy\")\n```\n\n\u540e\u5904\u7406\u8981\u5bb9\u6613\u5f97\u591a\uff01Gradio \u81ea\u52a8\u8bc6\u522b\u8fd4\u56de\u6570\u636e\u7684\u683c\u5f0f\uff08\u4f8b\u5982 `Image` \u662f `numpy` \u6570\u7ec4\u8fd8\u662f `str` \u6587\u4ef6\u8def\u5f84\uff1f\uff09\uff0c\u5e76\u5c06\u5176\u540e\u5904\u7406\u4e3a\u53ef\u4ee5\u7531\u6d4f\u89c8\u5668\u663e\u793a\u7684\u683c\u5f0f\u3002\n\n\u8bf7\u67e5\u770b[\u6587\u6863](https://gradio.app/docs)\uff0c\u4e86\u89e3\u6bcf\u4e2a\u7ec4\u4ef6\u7684\u6240\u6709\u4e0e\u9884\u5904\u7406\u76f8\u5173\u7684\u53c2\u6570\u3002\n\n## \u6837\u5f0f (Styling)\n\nGradio \u4e3b\u9898\u662f\u81ea\u5b9a\u4e49\u5e94\u7528\u7a0b\u5e8f\u5916\u89c2\u548c\u611f\u89c9\u7684\u6700\u7b80\u5355\u65b9\u6cd5\u3002\u60a8\u53ef\u4ee5\u9009\u62e9\u591a\u79cd\u4e3b\u9898\u6216\u521b\u5efa\u81ea\u5df1\u7684\u4e3b\u9898\u3002\u8981\u8fd9\u6837\u505a\uff0c\u8bf7\u5c06 `theme=` \u53c2\u6570\u4f20\u9012\u7ed9 `Interface` \u6784\u9020\u51fd\u6570\u3002\u4f8b\u5982\uff1a\n\n```python\ndemo = gr.Interface(..., theme=gr.themes.Monochrome())\n```\n\nGradio \u5e26\u6709\u4e00\u7ec4\u9884\u5148\u6784\u5efa\u7684\u4e3b\u9898\uff0c\u60a8\u53ef\u4ee5\u4ece `gr.themes.*` \u52a0\u8f7d\u3002\u60a8\u53ef\u4ee5\u6269\u5c55\u8fd9\u4e9b\u4e3b\u9898\u6216\u4ece\u5934\u5f00\u59cb\u521b\u5efa\u81ea\u5df1\u7684\u4e3b\u9898 - \u6709\u5173\u66f4\u591a\u8be6\u7ec6\u4fe1\u606f\uff0c\u8bf7\u53c2\u9605[\u4e3b\u9898\u6307\u5357](https://gradio.app/theming-guide)\u3002\n\n\u8981\u589e\u52a0\u989d\u5916\u7684\u6837\u5f0f\u80fd\u529b\uff0c\u60a8\u53ef\u4ee5 with `css=` \u5173\u952e\u5b57\u5c06\u4efb\u4f55 CSS \u4f20\u9012\u7ed9\u60a8\u7684\u5e94\u7528\u7a0b\u5e8f\u3002\nGradio \u5e94\u7528\u7a0b\u5e8f\u7684\u57fa\u7c7b\u662f `gradio-container`\uff0c\u56e0\u6b64\u4ee5\u4e0b\u662f\u4e00\u4e2a\u66f4\u6539 Gradio \u5e94\u7528\u7a0b\u5e8f\u80cc\u666f\u989c\u8272\u7684\u793a\u4f8b\uff1a\n\n```python\nwith `gr.Interface(css=\".gradio-container {background-color: red}\") as demo:\n    ...\n```\n\n## \u961f\u5217 (Queuing)\n\n\u5982\u679c\u60a8\u7684\u5e94\u7528\u7a0b\u5e8f\u9884\u8ba1\u4f1a\u6709\u5927\u91cf\u6d41\u91cf\uff0c\u8bf7 with `queue()` \u65b9\u6cd5\u6765\u63a7\u5236\u5904\u7406\u901f\u7387\u3002\u8fd9\u5c06\u6392\u961f\u5904\u7406\u8c03\u7528\uff0c\u56e0\u6b64\u4e00\u6b21\u53ea\u5904\u7406\u4e00\u5b9a\u6570\u91cf\u7684\u8bf7\u6c42\u3002\u961f\u5217\u4f7f\u7528 Websockets\uff0c\u8fd8\u53ef\u4ee5\u9632\u6b62\u7f51\u7edc\u8d85\u65f6\uff0c\u56e0\u6b64\u5982\u679c\u60a8\u7684\u51fd\u6570\u7684\u63a8\u7406\u65f6\u95f4\u5f88\u957f\uff08> 1 \u5206\u949f\uff09\uff0c\u5e94\u4f7f\u7528\u961f\u5217\u3002\n\nwith `Interface`\uff1a\n\n```python\ndemo = gr.Interface(...).queue()\ndemo.launch()\n```\n\nwith `Blocks`\uff1a\n\n```python\nwith gr.Blocks() as demo\uff1a\n    #...\ndemo.queue()\ndemo.launch()\n```\n\n\u60a8\u53ef\u4ee5\u901a\u8fc7\u4ee5\u4e0b\u65b9\u5f0f\u63a7\u5236\u4e00\u6b21\u5904\u7406\u7684\u8bf7\u6c42\u6570\u91cf\uff1a\n\n```python\ndemo.queue(concurrency_count=3)\n```\n\n\u67e5\u770b\u6709\u5173\u914d\u7f6e\u5176\u4ed6\u961f\u5217\u53c2\u6570\u7684[\u961f\u5217\u6587\u6863](/docs/#queue)\u3002\n\n\u5728 Blocks \u4e2d\u6307\u5b9a\u4ec5\u5bf9\u67d0\u4e9b\u51fd\u6570\u8fdb\u884c\u6392\u961f\uff1a\n\n```python\nwith gr.Blocks() as demo2\uff1a\n    num1 = gr.Number()\n    num2 = gr.Number()\n    output = gr.Number()\n    gr.Button(\"Add\").click(\n        lambda a, b: a + b, [num1, num2], output)\n    gr.Button(\"Multiply\").click(\n        lambda a, b: a * b, [num1, num2], output, queue=True)\ndemo2.launch()\n```\n\n## \u8fed\u4ee3\u8f93\u51fa (Iterative Outputs)\n\n\u5728\u67d0\u4e9b\u60c5\u51b5\u4e0b\uff0c\u60a8\u53ef\u80fd\u9700\u8981\u4f20\u8f93\u4e00\u7cfb\u5217\u8f93\u51fa\u800c\u4e0d\u662f\u4e00\u6b21\u663e\u793a\u5355\u4e2a\u8f93\u51fa\u3002\u4f8b\u5982\uff0c\u60a8\u53ef\u80fd\u6709\u4e00\u4e2a\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5e0c\u671b\u663e\u793a\u751f\u6210\u7684\u6bcf\u4e2a\u6b65\u9aa4\u7684\u56fe\u50cf\uff0c\u76f4\u5230\u6700\u7ec8\u56fe\u50cf\u3002\u6216\u8005\u60a8\u53ef\u80fd\u6709\u4e00\u4e2a\u804a\u5929\u673a\u5668\u4eba\uff0c\u5b83\u9010\u5b57\u9010\u53e5\u5730\u6d41\u5f0f\u4f20\u8f93\u54cd\u5e94\uff0c\u800c\u4e0d\u662f\u4e00\u6b21\u8fd4\u56de\u5168\u90e8\u54cd\u5e94\u3002\n\n\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u60a8\u53ef\u4ee5\u5c06**\u751f\u6210\u5668**\u51fd\u6570\u63d0\u4f9b\u7ed9 Gradio\uff0c\u800c\u4e0d\u662f\u5e38\u89c4\u51fd\u6570\u3002\u5728 Python \u4e2d\u521b\u5efa\u751f\u6210\u5668\u975e\u5e38\u7b80\u5355\uff1a\u51fd\u6570\u4e0d\u5e94\u8be5\u6709\u4e00\u4e2a\u5355\u72ec\u7684 `return` \u503c\uff0c\u800c\u662f\u5e94\u8be5 with `yield` \u8fde\u7eed\u8fd4\u56de\u4e00\u7cfb\u5217\u503c\u3002\u901a\u5e38\uff0c`yield` \u8bed\u53e5\u653e\u7f6e\u5728\u67d0\u79cd\u5faa\u73af\u4e2d\u3002\u4e0b\u9762\u662f\u4e00\u4e2a\u7b80\u5355\u793a\u4f8b\uff0c\u751f\u6210\u5668\u53ea\u662f\u7b80\u5355\u8ba1\u6570\u5230\u7ed9\u5b9a\u6570\u5b57\uff1a\n\n```python\ndef my_generator(x):\n    for i in range(x):\n        yield i\n```\n\n\u60a8\u4ee5\u4e0e\u5e38\u89c4\u51fd\u6570\u76f8\u540c\u7684\u65b9\u5f0f\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio\u3002\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\uff08\u865a\u62df\u7684\uff09\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5b83\u5728\u8f93\u51fa\u56fe\u50cf\u4e4b\u524d\u751f\u6210\u6570\u4e2a\u6b65\u9aa4\u7684\u566a\u97f3\uff1a\n\n$code_fake_diffusion\n$demo_fake_diffusion\n\n\u8bf7\u6ce8\u610f\uff0c\u6211\u4eec\u5728\u8fed\u4ee3\u5668\u4e2d\u6dfb\u52a0\u4e86 `time.sleep(1)`\uff0c\u4ee5\u521b\u5efa\u6b65\u9aa4\u4e4b\u95f4\u7684\u4eba\u5de5\u6682\u505c\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u89c2\u5bdf\u8fed\u4ee3\u5668\u7684\u6b65\u9aa4\uff08\u5728\u771f\u5b9e\u7684\u56fe\u50cf\u751f\u6210\u6a21\u578b\u4e2d\uff0c\u8fd9\n2,\t\u4e0e\u5e38\u89c4\u51fd\u6570\u76f8\u540c\u7684\u65b9\u5f0f\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio\u3002\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\uff08\u865a\u62df\u7684\uff09\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5b83\u5728\u8f93\u51fa\u56fe\u50cf\u4e4b\u524d\u751f\u6210\u6570\u4e2a\u6b65\u9aa4\u7684\u566a\u97f3\uff1a\n\n$code_fake_diffusion\n$demo_fake_diffusion\n\n\u8bf7\u6ce8\u610f\uff0c\u6211\u4eec\u5728\u8fed\u4ee3\u5668\u4e2d\u6dfb\u52a0\u4e86 `time.sleep(1)`\uff0c\u4ee5\u521b\u5efa\u6b65\u9aa4\u4e4b\u95f4\u7684\u4eba\u5de5\u6682\u505c\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u89c2\u5bdf\u8fed\u4ee3\u5668\u7684\u6b65\u9aa4\uff08\u5728\u771f\u5b9e\u7684\u56fe\u50cf\u751f\u6210\u6a21\u578b\u4e2d\uff0c\u8fd9\u53ef\u80fd\u662f\u4e0d\u5fc5\u8981\u7684\uff09\u3002\n\n\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio **\u9700\u8981**\u5728\u5e95\u5c42 Interface \u6216 Blocks \u4e2d\u542f\u7528\u961f\u5217\uff08\u8bf7\u53c2\u9605\u4e0a\u9762\u7684\u961f\u5217\u90e8\u5206\uff09\u3002\n\n## \u8fdb\u5ea6\u6761\n\nGradio \u652f\u6301\u521b\u5efa\u81ea\u5b9a\u4e49\u8fdb\u5ea6\u6761\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u81ea\u5b9a\u4e49\u548c\u63a7\u5236\u5411\u7528\u6237\u663e\u793a\u7684\u8fdb\u5ea6\u66f4\u65b0\u3002\u8981\u542f\u7528\u6b64\u529f\u80fd\uff0c\u53ea\u9700\u4e3a\u65b9\u6cd5\u6dfb\u52a0\u4e00\u4e2a\u9ed8\u8ba4\u503c\u4e3a `gr.Progress` \u5b9e\u4f8b\u7684\u53c2\u6570\u5373\u53ef\u3002\u7136\u540e\uff0c\u60a8\u53ef\u4ee5\u76f4\u63a5\u8c03\u7528\u6b64\u5b9e\u4f8b\u5e76\u4f20\u5165 0 \u5230 1 \u4e4b\u95f4\u7684\u6d6e\u70b9\u6570\u6765\u66f4\u65b0\u8fdb\u5ea6\u7ea7\u522b\uff0c\u6216\u8005 with `Progress` \u5b9e\u4f8b\u7684 `tqdm()` \u65b9\u6cd5\u6765\u8ddf\u8e2a\u53ef\u8fed\u4ee3\u5bf9\u8c61\u4e0a\u7684\u8fdb\u5ea6\uff0c\u5982\u4e0b\u6240\u793a\u3002\u5fc5\u987b\u542f\u7528\u961f\u5217\u4ee5\u8fdb\u884c\u8fdb\u5ea6\u66f4\u65b0\u3002\n\n$code_progress_simple\n$demo_progress_simple\n\n\u5982\u679c\u60a8 with `tqdm` \u5e93\uff0c\u5e76\u4e14\u5e0c\u671b\u4ece\u51fd\u6570\u5185\u90e8\u7684\u4efb\u4f55 `tqdm.tqdm` \u81ea\u52a8\u62a5\u544a\u8fdb\u5ea6\u66f4\u65b0\uff0c\u8bf7\u5c06\u9ed8\u8ba4\u53c2\u6570\u8bbe\u7f6e\u4e3a `gr.Progress(track_tqdm=True)`\uff01\n\n## \u6279\u5904\u7406\u51fd\u6570 (Batch Functions)\n\nGradio \u652f\u6301\u4f20\u9012*\u6279\u5904\u7406*\u51fd\u6570\u3002\u6279\u5904\u7406\u51fd\u6570\u53ea\u662f\u63a5\u53d7\u8f93\u5165\u5217\u8868\u5e76\u8fd4\u56de\u9884\u6d4b\u5217\u8868\u7684\u51fd\u6570\u3002\n\n\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\u6279\u5904\u7406\u51fd\u6570\uff0c\u5b83\u63a5\u53d7\u4e24\u4e2a\u8f93\u5165\u5217\u8868\uff08\u4e00\u4e2a\u5355\u8bcd\u5217\u8868\u548c\u4e00\u4e2a\u6574\u6570\u5217\u8868\uff09\uff0c\u5e76\u8fd4\u56de\u4fee\u526a\u8fc7\u7684\u5355\u8bcd\u5217\u8868\u4f5c\u4e3a\u8f93\u51fa\uff1a\n\n```python\nimport time\n\ndef trim_words(words, lens):\n    trimmed_words = []\n    time.sleep(5)\n    for w, l in zip(words, lens):\n        trimmed_words.append(w[:int(l)])\n    return [trimmed_words]\n    for w, l in zip(words, lens):\n```\n\n\u4f7f\u7528\u6279\u5904\u7406\u51fd\u6570\u7684\u4f18\u70b9\u662f\uff0c\u5982\u679c\u542f\u7528\u4e86\u961f\u5217\uff0cGradio \u670d\u52a1\u5668\u53ef\u4ee5\u81ea\u52a8*\u6279\u5904\u7406*\u4f20\u5165\u7684\u8bf7\u6c42\u5e76\u5e76\u884c\u5904\u7406\u5b83\u4eec\uff0c\u4ece\u800c\u53ef\u80fd\u52a0\u5feb\u6f14\u793a\u901f\u5ea6\u3002\u4ee5\u4e0b\u662f Gradio \u4ee3\u7801\u7684\u793a\u4f8b\uff08\u8bf7\u6ce8\u610f `batch=True` \u548c `max_batch_size=16` - \u8fd9\u4e24\u4e2a\u53c2\u6570\u90fd\u53ef\u4ee5\u4f20\u9012\u7ed9\u4e8b\u4ef6\u89e6\u53d1\u5668\u6216 `Interface` \u7c7b\uff09\n\nwith `Interface`\uff1a\n\n```python\ndemo = gr.Interface(trim_words, [\"textbox\", \"number\"], [\"output\"],\n                    batch=True, max_batch_size=16)\ndemo.queue()\ndemo.launch()\n```\n\nwith `Blocks`\uff1a\n\n```python\nimport gradio as gr\n\nwith gr.Blocks() as demo:\n    with gr.Row():\n        word = gr.Textbox(label=\"word\")\n        leng = gr.Number(label=\"leng\")\n        output = gr.Textbox(label=\"Output\")\n    with gr.Row():\n        run = gr.Button()\n\n    event = run.click(trim_words, [word, leng], output, batch=True, max_batch_size=16)\n\ndemo.queue()\ndemo.launch()\n```\n\n\u5728\u4e0a\u9762\u7684\u793a\u4f8b\u4e2d\uff0c\u53ef\u4ee5\u5e76\u884c\u5904\u7406 16 \u4e2a\u8bf7\u6c42\uff08\u603b\u63a8\u7406\u65f6\u95f4\u4e3a 5 \u79d2\uff09\uff0c\u800c\u4e0d\u662f\u5206\u522b\u5904\u7406\u6bcf\u4e2a\u8bf7\u6c42\uff08\u603b\u63a8\u7406\u65f6\u95f4\u4e3a 80 \u79d2\uff09\u3002\u8bb8\u591a Hugging Face \u7684 `transformers` \u548c `diffusers` \u6a21\u578b\u5728 Gradio \u7684\u6279\u5904\u7406\u6a21\u5f0f\u4e0b\u81ea\u7136\u5de5\u4f5c\uff1a\u8fd9\u662f[\u4f7f\u7528\u6279\u5904\u7406\u751f\u6210\u56fe\u50cf\u7684\u793a\u4f8b\u6f14\u793a](https://github.com/gradio-app/gradio/blob/main/demo/diffusers_with_batching/run.py)\n\n\u6ce8\u610f\uff1a\u4f7f\u7528 Gradio \u7684\u6279\u5904\u7406\u51fd\u6570 **requires** \u5728\u5e95\u5c42 Interface \u6216 Blocks \u4e2d\u542f\u7528\u961f\u5217\uff08\u8bf7\u53c2\u9605\u4e0a\u9762\u7684\u961f\u5217\u90e8\u5206\uff09\u3002\n\n## Gradio \u7b14\u8bb0\u672c (Colab Notebooks)\n\nGradio \u53ef\u4ee5\u5728\u4efb\u4f55\u8fd0\u884c Python \u7684\u5730\u65b9\u8fd0\u884c\uff0c\u5305\u62ec\u672c\u5730 Jupyter \u7b14\u8bb0\u672c\u548c\u534f\u4f5c\u7b14\u8bb0\u672c\uff0c\u5982[Google Colab](https://colab.research.google.com/)\u3002\u5bf9\u4e8e\u672c\u5730 Jupyter \u7b14\u8bb0\u672c\u548c Google Colab \u7b14\u8bb0\u672c\uff0cGradio \u5728\u672c\u5730\u670d\u52a1\u5668\u4e0a\u8fd0\u884c\uff0c\u60a8\u53ef\u4ee5\u5728\u6d4f\u89c8\u5668\u4e2d\u4e0e\u4e4b\u4ea4\u4e92\u3002\uff08\u6ce8\u610f\uff1a\u5bf9\u4e8e Google Colab\uff0c\u8fd9\u662f\u901a\u8fc7[\u670d\u52a1\u5de5\u4f5c\u5668\u96a7\u9053](https://github.com/tensorflow/tensorboard/blob/master/docs/design/colab_integration.md)\u5b9e\u73b0\u7684\uff0c\u60a8\u7684\u6d4f\u89c8\u5668\u9700\u8981\u542f\u7528 cookies\u3002\uff09\u5bf9\u4e8e\u5176\u4ed6\u8fdc\u7a0b\u7b14\u8bb0\u672c\uff0cGradio \u4e5f\u5c06\u5728\u670d\u52a1\u5668\u4e0a\u8fd0\u884c\uff0c\u4f46\u60a8\u9700\u8981\u4f7f\u7528[SSH \u96a7\u9053](https://coderwall.com/p/ohk6cg/remote-access-to-ipython-notebooks-via-ssh)\u5728\u672c\u5730\u6d4f\u89c8\u5668\u4e2d\u67e5\u770b\u5e94\u7528\u7a0b\u5e8f\u3002\u901a\u5e38\uff0c\u66f4\u7b80\u5355\u7684\u9009\u62e9\u662f\u4f7f\u7528 Gradio \u5185\u7f6e\u7684\u516c\u5171\u94fe\u63a5\uff0c[\u5728\u4e0b\u4e00\u7bc7\u6307\u5357\u4e2d\u8ba8\u8bba](/sharing-your-app/#sharing-demos)\u3002\n    ```",
            "vector_context": "[Created at: 2025-03-24 13:19:57]\nState in Blocks\n\nWe covered [State in Interfaces](https://gradio.app/interface-state), this guide takes a look at state in Blocks, which works mostly the same.\n\n## Global State\n\nGlobal state in Blocks works the same as in Interface. Any variable created outside a function call is a reference shared between all users.\n\n## Session State\n\nGradio supports session **state**, where data persists across multiple submits within a page session, in Blocks apps as well. To reiterate, session data is _not_ shared between different users of your model. To store data in a session state, you need to do three things:\n\n1. Create a `gr.State()` object. If there is a default value to this stateful object, pass that into the constructor.\n2. In the event listener, put the `State` object as an input and output.\n3. In the event listener function, add the variable to the input parameters and the return value.\n\nLet's take a look at a game of hangman.\n\n$code_hangman\n$demo_hangman\n\nLet's see how we do each of the 3 steps listed above in this game:\n\n1. We store the used letters in `used_letters_var`. In the constructor of `State`, we set the initial value of this to `[]`, an empty list.\n2. In `btn.click()`, we have a reference to `used_letters_var` in both the inputs and outputs.\n3. In `guess_letter`, we pass the value of this `State` to `used_letters`, and then return an updated value of this `State` in the return statement.\n\nWith more complex apps, you will likely have many State variables storing session state in a single Blocks app.\n\nLearn more about `State` in the [docs](https://gradio.app/docs#state).\n--New Chunk--\n[Created at: 2025-03-24 13:16:48]\n\u65f6\u5fc5\u987b\u9009\u62e9\u5176\u4e2d\u4e00\u4e2a\u5b57\u7b26\u4e32\uff0c\u8fd9\u5c06\u4f5c\u4e3a\u9644\u52a0\u5217\u4fdd\u5b58\u5230 CSV \u4e2d\u3002\n\n## \u9884\u5904\u7406\u548c\u540e\u5904\u7406 (Preprocessing and Postprocessing)\n\n![annotated](/assets/img/dataflow.svg)\n\n\u5982\u60a8\u6240\u89c1\uff0cGradio \u5305\u62ec\u53ef\u4ee5\u5904\u7406\u5404\u79cd\u4e0d\u540c\u6570\u636e\u7c7b\u578b\u7684\u7ec4\u4ef6\uff0c\u4f8b\u5982\u56fe\u50cf\u3001\u97f3\u9891\u548c\u89c6\u9891\u3002\u5927\u591a\u6570\u7ec4\u4ef6\u90fd\u53ef\u4ee5\u7528\u4f5c\u8f93\u5165\u6216\u8f93\u51fa\u3002\n\n\u5f53\u7ec4\u4ef6\u7528\u4f5c\u8f93\u5165\u65f6\uff0cGradio \u81ea\u52a8\u5904\u7406*\u9884\u5904\u7406*\uff0c\u5c06\u6570\u636e\u4ece\u7528\u6237\u6d4f\u89c8\u5668\u53d1\u9001\u7684\u7c7b\u578b\uff08\u4f8b\u5982\u7f51\u7edc\u6444\u50cf\u5934\u5feb\u7167\u7684 base64 \u8868\u793a\uff09\u8f6c\u6362\u4e3a\u60a8\u7684\u51fd\u6570\u53ef\u4ee5\u63a5\u53d7\u7684\u5f62\u5f0f\uff08\u4f8b\u5982 `numpy` \u6570\u7ec4\uff09\u3002\n\n\u540c\u6837\uff0c\u5f53\u7ec4\u4ef6\u7528\u4f5c\u8f93\u51fa\u65f6\uff0cGradio \u81ea\u52a8\u5904\u7406*\u540e\u5904\u7406*\uff0c\u5c06\u6570\u636e\u4ece\u51fd\u6570\u8fd4\u56de\u7684\u5f62\u5f0f\uff08\u4f8b\u5982\u56fe\u50cf\u8def\u5f84\u5217\u8868\uff09\u8f6c\u6362\u4e3a\u53ef\u4ee5\u5728\u7528\u6237\u6d4f\u89c8\u5668\u4e2d\u663e\u793a\u7684\u5f62\u5f0f\uff08\u4f8b\u5982\u4ee5 base64 \u683c\u5f0f\u663e\u793a\u56fe\u50cf\u7684 `Gallery`\uff09\u3002\n\n\u60a8\u53ef\u4ee5\u4f7f\u7528\u6784\u5efa\u56fe\u50cf\u7ec4\u4ef6\u65f6\u7684\u53c2\u6570\u63a7\u5236*\u9884\u5904\u7406*\u3002\u4f8b\u5982\uff0c\u5982\u679c\u60a8\u4f7f\u7528\u4ee5\u4e0b\u53c2\u6570\u5b9e\u4f8b\u5316 `Image` \u7ec4\u4ef6\uff0c\u5b83\u5c06\u5c06\u56fe\u50cf\u8f6c\u6362\u4e3a `PIL` \u7c7b\u578b\uff0c\u5e76\u5c06\u5176\u91cd\u5851\u4e3a`(100, 100)`\uff0c\u800c\u4e0d\u7ba1\u63d0\u4ea4\u65f6\u7684\u539f\u59cb\u5927\u5c0f\u5982\u4f55\uff1a\n\n```py\nimg = gr.Image(shape=(100, 100), type=\"pil\")\n```\n\n\u76f8\u53cd\uff0c\u8fd9\u91cc\u6211\u4eec\u4fdd\u7559\u56fe\u50cf\u7684\u539f\u59cb\u5927\u5c0f\uff0c\u4f46\u5728\u5c06\u5176\u8f6c\u6362\u4e3a numpy \u6570\u7ec4\u4e4b\u524d\u53cd\u8f6c\u989c\u8272\uff1a\n\n```py\nimg = gr.Image(invert_colors=True, type=\"numpy\")\n```\n\n\u540e\u5904\u7406\u8981\u5bb9\u6613\u5f97\u591a\uff01Gradio \u81ea\u52a8\u8bc6\u522b\u8fd4\u56de\u6570\u636e\u7684\u683c\u5f0f\uff08\u4f8b\u5982 `Image` \u662f `numpy` \u6570\u7ec4\u8fd8\u662f `str` \u6587\u4ef6\u8def\u5f84\uff1f\uff09\uff0c\u5e76\u5c06\u5176\u540e\u5904\u7406\u4e3a\u53ef\u4ee5\u7531\u6d4f\u89c8\u5668\u663e\u793a\u7684\u683c\u5f0f\u3002\n\n\u8bf7\u67e5\u770b[\u6587\u6863](https://gradio.app/docs)\uff0c\u4e86\u89e3\u6bcf\u4e2a\u7ec4\u4ef6\u7684\u6240\u6709\u4e0e\u9884\u5904\u7406\u76f8\u5173\u7684\u53c2\u6570\u3002\n\n## \u6837\u5f0f (Styling)\n\nGradio \u4e3b\u9898\u662f\u81ea\u5b9a\u4e49\u5e94\u7528\u7a0b\u5e8f\u5916\u89c2\u548c\u611f\u89c9\u7684\u6700\u7b80\u5355\u65b9\u6cd5\u3002\u60a8\u53ef\u4ee5\u9009\u62e9\u591a\u79cd\u4e3b\u9898\u6216\u521b\u5efa\u81ea\u5df1\u7684\u4e3b\u9898\u3002\u8981\u8fd9\u6837\u505a\uff0c\u8bf7\u5c06 `theme=` \u53c2\u6570\u4f20\u9012\u7ed9 `Interface` \u6784\u9020\u51fd\u6570\u3002\u4f8b\u5982\uff1a\n\n```python\ndemo = gr.Interface(..., theme=gr.themes.Monochrome())\n```\n\nGradio \u5e26\u6709\u4e00\u7ec4\u9884\u5148\u6784\u5efa\u7684\u4e3b\u9898\uff0c\u60a8\u53ef\u4ee5\u4ece `gr.themes.*` \u52a0\u8f7d\u3002\u60a8\u53ef\u4ee5\u6269\u5c55\u8fd9\u4e9b\u4e3b\u9898\u6216\u4ece\u5934\u5f00\u59cb\u521b\u5efa\u81ea\u5df1\u7684\u4e3b\u9898 - \u6709\u5173\u66f4\u591a\u8be6\u7ec6\u4fe1\u606f\uff0c\u8bf7\u53c2\u9605[\u4e3b\u9898\u6307\u5357](https://gradio.app/theming-guide)\u3002\n\n\u8981\u589e\u52a0\u989d\u5916\u7684\u6837\u5f0f\u80fd\u529b\uff0c\u60a8\u53ef\u4ee5 with `css=` \u5173\u952e\u5b57\u5c06\u4efb\u4f55 CSS \u4f20\u9012\u7ed9\u60a8\u7684\u5e94\u7528\u7a0b\u5e8f\u3002\nGradio \u5e94\u7528\u7a0b\u5e8f\u7684\u57fa\u7c7b\u662f `gradio-container`\uff0c\u56e0\u6b64\u4ee5\u4e0b\u662f\u4e00\u4e2a\u66f4\u6539 Gradio \u5e94\u7528\u7a0b\u5e8f\u80cc\u666f\u989c\u8272\u7684\u793a\u4f8b\uff1a\n\n```python\nwith `gr.Interface(css=\".gradio-container {background-color: red}\") as demo:\n    ...\n```\n\n## \u961f\u5217 (Queuing)\n\n\u5982\u679c\u60a8\u7684\u5e94\u7528\u7a0b\u5e8f\u9884\u8ba1\u4f1a\u6709\u5927\u91cf\u6d41\u91cf\uff0c\u8bf7 with `queue()` \u65b9\u6cd5\u6765\u63a7\u5236\u5904\u7406\u901f\u7387\u3002\u8fd9\u5c06\u6392\u961f\u5904\u7406\u8c03\u7528\uff0c\u56e0\u6b64\u4e00\u6b21\u53ea\u5904\u7406\u4e00\u5b9a\u6570\u91cf\u7684\u8bf7\u6c42\u3002\u961f\u5217\u4f7f\u7528 Websockets\uff0c\u8fd8\u53ef\u4ee5\u9632\u6b62\u7f51\u7edc\u8d85\u65f6\uff0c\u56e0\u6b64\u5982\u679c\u60a8\u7684\u51fd\u6570\u7684\u63a8\u7406\u65f6\u95f4\u5f88\u957f\uff08> 1 \u5206\u949f\uff09\uff0c\u5e94\u4f7f\u7528\u961f\u5217\u3002\n\nwith `Interface`\uff1a\n\n```python\ndemo = gr.Interface(...).queue()\ndemo.launch()\n```\n\nwith `Blocks`\uff1a\n\n```python\nwith gr.Blocks() as demo\uff1a\n    #...\ndemo.queue()\ndemo.launch()\n```\n\n\u60a8\u53ef\u4ee5\u901a\u8fc7\u4ee5\u4e0b\u65b9\u5f0f\u63a7\u5236\u4e00\u6b21\u5904\u7406\u7684\u8bf7\u6c42\u6570\u91cf\uff1a\n\n```python\ndemo.queue(concurrency_count=3)\n```\n\n\u67e5\u770b\u6709\u5173\u914d\u7f6e\u5176\u4ed6\u961f\u5217\u53c2\u6570\u7684[\u961f\u5217\u6587\u6863](/docs/#queue)\u3002\n\n\u5728 Blocks \u4e2d\u6307\u5b9a\u4ec5\u5bf9\u67d0\u4e9b\u51fd\u6570\u8fdb\u884c\u6392\u961f\uff1a\n\n```python\nwith gr.Blocks() as demo2\uff1a\n    num1 = gr.Number()\n    num2 = gr.Number()\n    output = gr.Number()\n    gr.Button(\"Add\").click(\n        lambda a, b: a + b, [num1, num2], output)\n    gr.Button(\"Multiply\").click(\n        lambda a, b: a * b, [num1, num2], output, queue=True)\ndemo2.launch()\n```\n\n## \u8fed\u4ee3\u8f93\u51fa (Iterative Outputs)\n\n\u5728\u67d0\u4e9b\u60c5\u51b5\u4e0b\uff0c\u60a8\u53ef\u80fd\u9700\u8981\u4f20\u8f93\u4e00\u7cfb\u5217\u8f93\u51fa\u800c\u4e0d\u662f\u4e00\u6b21\u663e\u793a\u5355\u4e2a\u8f93\u51fa\u3002\u4f8b\u5982\uff0c\u60a8\u53ef\u80fd\u6709\u4e00\u4e2a\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5e0c\u671b\u663e\u793a\u751f\u6210\u7684\u6bcf\u4e2a\u6b65\u9aa4\u7684\u56fe\u50cf\uff0c\u76f4\u5230\u6700\u7ec8\u56fe\u50cf\u3002\u6216\u8005\u60a8\u53ef\u80fd\u6709\u4e00\u4e2a\u804a\u5929\u673a\u5668\u4eba\uff0c\u5b83\u9010\u5b57\u9010\u53e5\u5730\u6d41\u5f0f\u4f20\u8f93\u54cd\u5e94\uff0c\u800c\u4e0d\u662f\u4e00\u6b21\u8fd4\u56de\u5168\u90e8\u54cd\u5e94\u3002\n\n\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u60a8\u53ef\u4ee5\u5c06**\u751f\u6210\u5668**\u51fd\u6570\u63d0\u4f9b\u7ed9 Gradio\uff0c\u800c\u4e0d\u662f\u5e38\u89c4\u51fd\u6570\u3002\u5728 Python \u4e2d\u521b\u5efa\u751f\u6210\u5668\u975e\u5e38\u7b80\u5355\uff1a\u51fd\u6570\u4e0d\u5e94\u8be5\u6709\u4e00\u4e2a\u5355\u72ec\u7684 `return` \u503c\uff0c\u800c\u662f\u5e94\u8be5 with `yield` \u8fde\u7eed\u8fd4\u56de\u4e00\u7cfb\u5217\u503c\u3002\u901a\u5e38\uff0c`yield` \u8bed\u53e5\u653e\u7f6e\u5728\u67d0\u79cd\u5faa\u73af\u4e2d\u3002\u4e0b\u9762\u662f\u4e00\u4e2a\u7b80\u5355\u793a\u4f8b\uff0c\u751f\u6210\u5668\u53ea\u662f\u7b80\u5355\u8ba1\u6570\u5230\u7ed9\u5b9a\u6570\u5b57\uff1a\n\n```python\ndef my_generator(x):\n    for i in range(x):\n        yield i\n```\n\n\u60a8\u4ee5\u4e0e\u5e38\u89c4\u51fd\u6570\u76f8\u540c\u7684\u65b9\u5f0f\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio\u3002\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\uff08\u865a\u62df\u7684\uff09\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5b83\u5728\u8f93\u51fa\u56fe\u50cf\u4e4b\u524d\u751f\u6210\u6570\u4e2a\u6b65\u9aa4\u7684\u566a\u97f3\uff1a\n\n$code_fake_diffusion\n$demo_fake_diffusion\n\n\u8bf7\u6ce8\u610f\uff0c\u6211\u4eec\u5728\u8fed\u4ee3\u5668\u4e2d\u6dfb\u52a0\u4e86 `time.sleep(1)`\uff0c\u4ee5\u521b\u5efa\u6b65\u9aa4\u4e4b\u95f4\u7684\u4eba\u5de5\u6682\u505c\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u89c2\u5bdf\u8fed\u4ee3\u5668\u7684\u6b65\u9aa4\uff08\u5728\u771f\u5b9e\u7684\u56fe\u50cf\u751f\u6210\u6a21\u578b\u4e2d\uff0c\u8fd9\n--New Chunk--\n[Created at: 2025-03-24 13:16:48]\n\u4e0e\u5e38\u89c4\u51fd\u6570\u76f8\u540c\u7684\u65b9\u5f0f\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio\u3002\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\uff08\u865a\u62df\u7684\uff09\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5b83\u5728\u8f93\u51fa\u56fe\u50cf\u4e4b\u524d\u751f\u6210\u6570\u4e2a\u6b65\u9aa4\u7684\u566a\u97f3\uff1a\n\n$code_fake_diffusion\n$demo_fake_diffusion\n\n\u8bf7\u6ce8\u610f\uff0c\u6211\u4eec\u5728\u8fed\u4ee3\u5668\u4e2d\u6dfb\u52a0\u4e86 `time.sleep(1)`\uff0c\u4ee5\u521b\u5efa\u6b65\u9aa4\u4e4b\u95f4\u7684\u4eba\u5de5\u6682\u505c\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u89c2\u5bdf\u8fed\u4ee3\u5668\u7684\u6b65\u9aa4\uff08\u5728\u771f\u5b9e\u7684\u56fe\u50cf\u751f\u6210\u6a21\u578b\u4e2d\uff0c\u8fd9\u53ef\u80fd\u662f\u4e0d\u5fc5\u8981\u7684\uff09\u3002\n\n\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio **\u9700\u8981**\u5728\u5e95\u5c42 Interface \u6216 Blocks \u4e2d\u542f\u7528\u961f\u5217\uff08\u8bf7\u53c2\u9605\u4e0a\u9762\u7684\u961f\u5217\u90e8\u5206\uff09\u3002\n\n## \u8fdb\u5ea6\u6761\n\nGradio \u652f\u6301\u521b\u5efa\u81ea\u5b9a\u4e49\u8fdb\u5ea6\u6761\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u81ea\u5b9a\u4e49\u548c\u63a7\u5236\u5411\u7528\u6237\u663e\u793a\u7684\u8fdb\u5ea6\u66f4\u65b0\u3002\u8981\u542f\u7528\u6b64\u529f\u80fd\uff0c\u53ea\u9700\u4e3a\u65b9\u6cd5\u6dfb\u52a0\u4e00\u4e2a\u9ed8\u8ba4\u503c\u4e3a `gr.Progress` \u5b9e\u4f8b\u7684\u53c2\u6570\u5373\u53ef\u3002\u7136\u540e\uff0c\u60a8\u53ef\u4ee5\u76f4\u63a5\u8c03\u7528\u6b64\u5b9e\u4f8b\u5e76\u4f20\u5165 0 \u5230 1 \u4e4b\u95f4\u7684\u6d6e\u70b9\u6570\u6765\u66f4\u65b0\u8fdb\u5ea6\u7ea7\u522b\uff0c\u6216\u8005 with `Progress` \u5b9e\u4f8b\u7684 `tqdm()` \u65b9\u6cd5\u6765\u8ddf\u8e2a\u53ef\u8fed\u4ee3\u5bf9\u8c61\u4e0a\u7684\u8fdb\u5ea6\uff0c\u5982\u4e0b\u6240\u793a\u3002\u5fc5\u987b\u542f\u7528\u961f\u5217\u4ee5\u8fdb\u884c\u8fdb\u5ea6\u66f4\u65b0\u3002\n\n$code_progress_simple\n$demo_progress_simple\n\n\u5982\u679c\u60a8 with `tqdm` \u5e93\uff0c\u5e76\u4e14\u5e0c\u671b\u4ece\u51fd\u6570\u5185\u90e8\u7684\u4efb\u4f55 `tqdm.tqdm` \u81ea\u52a8\u62a5\u544a\u8fdb\u5ea6\u66f4\u65b0\uff0c\u8bf7\u5c06\u9ed8\u8ba4\u53c2\u6570\u8bbe\u7f6e\u4e3a `gr.Progress(track_tqdm=True)`\uff01\n\n## \u6279\u5904\u7406\u51fd\u6570 (Batch Functions)\n\nGradio \u652f\u6301\u4f20\u9012*\u6279\u5904\u7406*\u51fd\u6570\u3002\u6279\u5904\u7406\u51fd\u6570\u53ea\u662f\u63a5\u53d7\u8f93\u5165\u5217\u8868\u5e76\u8fd4\u56de\u9884\u6d4b\u5217\u8868\u7684\u51fd\u6570\u3002\n\n\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\u6279\u5904\u7406\u51fd\u6570\uff0c\u5b83\u63a5\u53d7\u4e24\u4e2a\u8f93\u5165\u5217\u8868\uff08\u4e00\u4e2a\u5355\u8bcd\u5217\u8868\u548c\u4e00\u4e2a\u6574\u6570\u5217\u8868\uff09\uff0c\u5e76\u8fd4\u56de\u4fee\u526a\u8fc7\u7684\u5355\u8bcd\u5217\u8868\u4f5c\u4e3a\u8f93\u51fa\uff1a\n\n```python\nimport time\n\ndef trim_words(words, lens):\n    trimmed_words = []\n    time.sleep(5)\n    for w, l in zip(words, lens):\n        trimmed_words.append(w[:int(l)])\n    return [trimmed_words]\n    for w, l in zip(words, lens):\n```\n\n\u4f7f\u7528\u6279\u5904\u7406\u51fd\u6570\u7684\u4f18\u70b9\u662f\uff0c\u5982\u679c\u542f\u7528\u4e86\u961f\u5217\uff0cGradio \u670d\u52a1\u5668\u53ef\u4ee5\u81ea\u52a8*\u6279\u5904\u7406*\u4f20\u5165\u7684\u8bf7\u6c42\u5e76\u5e76\u884c\u5904\u7406\u5b83\u4eec\uff0c\u4ece\u800c\u53ef\u80fd\u52a0\u5feb\u6f14\u793a\u901f\u5ea6\u3002\u4ee5\u4e0b\u662f Gradio \u4ee3\u7801\u7684\u793a\u4f8b\uff08\u8bf7\u6ce8\u610f `batch=True` \u548c `max_batch_size=16` - \u8fd9\u4e24\u4e2a\u53c2\u6570\u90fd\u53ef\u4ee5\u4f20\u9012\u7ed9\u4e8b\u4ef6\u89e6\u53d1\u5668\u6216 `Interface` \u7c7b\uff09\n\nwith `Interface`\uff1a\n\n```python\ndemo = gr.Interface(trim_words, [\"textbox\", \"number\"], [\"output\"],\n                    batch=True, max_batch_size=16)\ndemo.queue()\ndemo.launch()\n```\n\nwith `Blocks`\uff1a\n\n```python\nimport gradio as gr\n\nwith gr.Blocks() as demo:\n    with gr.Row():\n        word = gr.Textbox(label=\"word\")\n        leng = gr.Number(label=\"leng\")\n        output = gr.Textbox(label=\"Output\")\n    with gr.Row():\n        run = gr.Button()\n\n    event = run.click(trim_words, [word, leng], output, batch=True, max_batch_size=16)\n\ndemo.queue()\ndemo.launch()\n```\n\n\u5728\u4e0a\u9762\u7684\u793a\u4f8b\u4e2d\uff0c\u53ef\u4ee5\u5e76\u884c\u5904\u7406 16 \u4e2a\u8bf7\u6c42\uff08\u603b\u63a8\u7406\u65f6\u95f4\u4e3a 5 \u79d2\uff09\uff0c\u800c\u4e0d\u662f\u5206\u522b\u5904\u7406\u6bcf\u4e2a\u8bf7\u6c42\uff08\u603b\u63a8\u7406\u65f6\u95f4\u4e3a 80 \u79d2\uff09\u3002\u8bb8\u591a Hugging Face \u7684 `transformers` \u548c `diffusers` \u6a21\u578b\u5728 Gradio \u7684\u6279\u5904\u7406\u6a21\u5f0f\u4e0b\u81ea\u7136\u5de5\u4f5c\uff1a\u8fd9\u662f[\u4f7f\u7528\u6279\u5904\u7406\u751f\u6210\u56fe\u50cf\u7684\u793a\u4f8b\u6f14\u793a](https://github.com/gradio-app/gradio/blob/main/demo/diffusers_with_batching/run.py)\n\n\u6ce8\u610f\uff1a\u4f7f\u7528 Gradio \u7684\u6279\u5904\u7406\u51fd\u6570 **requires** \u5728\u5e95\u5c42 Interface \u6216 Blocks \u4e2d\u542f\u7528\u961f\u5217\uff08\u8bf7\u53c2\u9605\u4e0a\u9762\u7684\u961f\u5217\u90e8\u5206\uff09\u3002\n\n## Gradio \u7b14\u8bb0\u672c (Colab Notebooks)\n\nGradio \u53ef\u4ee5\u5728\u4efb\u4f55\u8fd0\u884c Python \u7684\u5730\u65b9\u8fd0\u884c\uff0c\u5305\u62ec\u672c\u5730 Jupyter \u7b14\u8bb0\u672c\u548c\u534f\u4f5c\u7b14\u8bb0\u672c\uff0c\u5982[Google Colab](https://colab.research.google.com/)\u3002\u5bf9\u4e8e\u672c\u5730 Jupyter \u7b14\u8bb0\u672c\u548c Google Colab \u7b14\u8bb0\u672c\uff0cGradio \u5728\u672c\u5730\u670d\u52a1\u5668\u4e0a\u8fd0\u884c\uff0c\u60a8\u53ef\u4ee5\u5728\u6d4f\u89c8\u5668\u4e2d\u4e0e\u4e4b\u4ea4\u4e92\u3002\uff08\u6ce8\u610f\uff1a\u5bf9\u4e8e Google Colab\uff0c\u8fd9\u662f\u901a\u8fc7[\u670d\u52a1\u5de5\u4f5c\u5668\u96a7\u9053](https://github.com/tensorflow/tensorboard/blob/master/docs/design/colab_integration.md)\u5b9e\u73b0\u7684\uff0c\u60a8\u7684\u6d4f\u89c8\u5668\u9700\u8981\u542f\u7528 cookies\u3002\uff09\u5bf9\u4e8e\u5176\u4ed6\u8fdc\u7a0b\u7b14\u8bb0\u672c\uff0cGradio \u4e5f\u5c06\u5728\u670d\u52a1\u5668\u4e0a\u8fd0\u884c\uff0c\u4f46\u60a8\u9700\u8981\u4f7f\u7528[SSH \u96a7\u9053](https://coderwall.com/p/ohk6cg/remote-access-to-ipython-notebooks-via-ssh)\u5728\u672c\u5730\u6d4f\u89c8\u5668\u4e2d\u67e5\u770b\u5e94\u7528\u7a0b\u5e8f\u3002\u901a\u5e38\uff0c\u66f4\u7b80\u5355\u7684\u9009\u62e9\u662f\u4f7f\u7528 Gradio \u5185\u7f6e\u7684\u516c\u5171\u94fe\u63a5\uff0c[\u5728\u4e0b\u4e00\u7bc7\u6307\u5357\u4e2d\u8ba8\u8bba](/sharing-your-app/#sharing-demos)\u3002"
        }
    },
    {
        "context": "## \u961f\u5217 (Queuing)\n\n\u5982\u679c\u60a8\u7684\u5e94\u7528\u7a0b\u5e8f\u9884\u8ba1\u4f1a\u6709\u5927\u91cf\u6d41\u91cf\uff0c\u8bf7 with `queue()` \u65b9\u6cd5\u6765\u63a7\u5236\u5904\u7406\u901f\u7387\u3002\u8fd9\u5c06\u6392\u961f\u5904\u7406\u8c03\u7528\uff0c\u56e0\u6b64\u4e00\u6b21\u53ea\u5904\u7406\u4e00\u5b9a\u6570\u91cf\u7684\u8bf7\u6c42\u3002\u961f\u5217\u4f7f\u7528 Websockets\uff0c\u8fd8\u53ef\u4ee5\u9632\u6b62\u7f51\u7edc\u8d85\u65f6\uff0c\u56e0\u6b64\u5982\u679c\u60a8\u7684\u51fd\u6570\u7684\u63a8\u7406\u65f6\u95f4\u5f88\u957f\uff08> 1 \u5206\u949f\uff09\uff0c\u5e94\u4f7f\u7528\u961f\u5217\u3002\n\nwith `Interface`\uff1a\n\n```python\ndemo = gr.Interface(...).queue()\ndemo.launch()\n```\n\nwith `Blocks`\uff1a\n\n```python\nwith gr.Blocks() as demo\uff1a\n    #...\ndemo.queue()\ndemo.launch()\n```\n\n\u60a8\u53ef\u4ee5\u901a\u8fc7\u4ee5\u4e0b\u65b9\u5f0f\u63a7\u5236\u4e00\u6b21\u5904\u7406\u7684\u8bf7\u6c42\u6570\u91cf\uff1a\n\n```python\ndemo.queue(concurrency_count=3)\n```\n\n\u67e5\u770b\u6709\u5173\u914d\u7f6e\u5176\u4ed6\u961f\u5217\u53c2\u6570\u7684[\u961f\u5217\u6587\u6863](/docs/#queue)\u3002\n\n\u5728 Blocks \u4e2d\u6307\u5b9a\u4ec5\u5bf9\u67d0\u4e9b\u51fd\u6570\u8fdb\u884c\u6392\u961f\uff1a\n\n```python\nwith gr.Blocks() as demo2\uff1a\n    num1 = gr.Number()\n    num2 = gr.Number()\n    output = gr.Number()\n    gr.Button(\"Add\").click(\n        lambda a, b: a + b, [num1, num2], output)\n    gr.Button(\"Multiply\").click(\n        lambda a, b: a * b, [num1, num2], output, queue=True)\ndemo2.launch()\n```\n\n## \u8fed\u4ee3\u8f93\u51fa (Iterative Outputs)\n\n\u5728\u67d0\u4e9b\u60c5\u51b5\u4e0b\uff0c\u60a8\u53ef\u80fd\u9700\u8981\u4f20\u8f93\u4e00\u7cfb\u5217\u8f93\u51fa\u800c\u4e0d\u662f\u4e00\u6b21\u663e\u793a\u5355\u4e2a\u8f93\u51fa\u3002\u4f8b\u5982\uff0c\u60a8\u53ef\u80fd\u6709\u4e00\u4e2a\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5e0c\u671b\u663e\u793a\u751f\u6210\u7684\u6bcf\u4e2a\u6b65\u9aa4\u7684\u56fe\u50cf\uff0c\u76f4\u5230\u6700\u7ec8\u56fe\u50cf\u3002\u6216\u8005\u60a8\u53ef\u80fd\u6709\u4e00\u4e2a\u804a\u5929\u673a\u5668\u4eba\uff0c\u5b83\u9010\u5b57\u9010\u53e5\u5730\u6d41\u5f0f\u4f20\u8f93\u54cd\u5e94\uff0c\u800c\u4e0d\u662f\u4e00\u6b21\u8fd4\u56de\u5168\u90e8\u54cd\u5e94\u3002\n\n\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u60a8\u53ef\u4ee5\u5c06**\u751f\u6210\u5668**\u51fd\u6570\u63d0\u4f9b\u7ed9 Gradio\uff0c\u800c\u4e0d\u662f\u5e38\u89c4\u51fd\u6570\u3002\u5728 Python \u4e2d\u521b\u5efa\u751f\u6210\u5668\u975e\u5e38\u7b80\u5355\uff1a\u51fd\u6570\u4e0d\u5e94\u8be5\u6709\u4e00\u4e2a\u5355\u72ec\u7684 `return` \u503c\uff0c\u800c\u662f\u5e94\u8be5 with `yield` \u8fde\u7eed\u8fd4\u56de\u4e00\u7cfb\u5217\u503c\u3002\u901a\u5e38\uff0c`yield` \u8bed\u53e5\u653e\u7f6e\u5728\u67d0\u79cd\u5faa\u73af\u4e2d\u3002\u4e0b\u9762\u662f\u4e00\u4e2a\u7b80\u5355\u793a\u4f8b\uff0c\u751f\u6210\u5668\u53ea\u662f\u7b80\u5355\u8ba1\u6570\u5230\u7ed9\u5b9a\u6570\u5b57\uff1a\n\n```python\ndef my_generator(x):\n    for i in range(x):\n        yield i\n```\n\n\u60a8\u4ee5\u4e0e\u5e38\u89c4\u51fd\u6570\u76f8\u540c\u7684\u65b9\u5f0f\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio\u3002\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\uff08\u865a\u62df\u7684\uff09\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5b83\u5728\u8f93\u51fa\u56fe\u50cf\u4e4b\u524d\u751f\u6210\u6570\u4e2a\u6b65\u9aa4\u7684\u566a\u97f3\uff1a\n\n$code_fake_diffusion\n$demo_fake_diffusion\n\n\u8bf7\u6ce8\u610f\uff0c\u6211\u4eec\u5728\u8fed\u4ee3\u5668\u4e2d\u6dfb\u52a0\u4e86 `time.sleep(1)`\uff0c\u4ee5\u521b\u5efa\u6b65\u9aa4\u4e4b\u95f4\u7684\u4eba\u5de5\u6682\u505c\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u89c2\u5bdf\u8fed\u4ee3\u5668\u7684\u6b65\u9aa4\uff08\u5728\u771f\u5b9e\u7684\u56fe\u50cf\u751f\u6210\u6a21\u578b\u4e2d\uff0c\u8fd9\u53ef\u80fd\u662f\u4e0d\u5fc5\u8981\u7684\uff09\u3002\n\n\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio **\u9700\u8981**\u5728\u5e95\u5c42 Interface \u6216 Blocks \u4e2d\u542f\u7528\u961f\u5217\uff08\u8bf7\u53c2\u9605\u4e0a\u9762\u7684\u961f\u5217\u90e8\u5206\uff09\u3002\n\n## \u8fdb\u5ea6\u6761\n\nGradio \u652f\u6301\u521b\u5efa\u81ea\u5b9a\u4e49\u8fdb\u5ea6\u6761\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u81ea\u5b9a\u4e49\u548c\u63a7\u5236\u5411\u7528\u6237\u663e\u793a\u7684\u8fdb\u5ea6\u66f4\u65b0\u3002\u8981\u542f\u7528\u6b64\u529f\u80fd\uff0c\u53ea\u9700\u4e3a\u65b9\u6cd5\u6dfb\u52a0\u4e00\u4e2a\u9ed8\u8ba4\u503c\u4e3a `gr.Progress` \u5b9e\u4f8b\u7684\u53c2\u6570\u5373\u53ef\u3002\u7136\u540e\uff0c\u60a8\u53ef\u4ee5\u76f4\u63a5\u8c03\u7528\u6b64\u5b9e\u4f8b\u5e76\u4f20\u5165 0 \u5230 1 \u4e4b\u95f4\u7684\u6d6e\u70b9\u6570\u6765\u66f4\u65b0\u8fdb\u5ea6\u7ea7\u522b\uff0c\u6216\u8005 with `Progress` \u5b9e\u4f8b\u7684 `tqdm()` \u65b9\u6cd5\u6765\u8ddf\u8e2a\u53ef\u8fed\u4ee3\u5bf9\u8c61\u4e0a\u7684\u8fdb\u5ea6\uff0c\u5982\u4e0b\u6240\u793a\u3002\u5fc5\u987b\u542f\u7528\u961f\u5217\u4ee5\u8fdb\u884c\u8fdb\u5ea6\u66f4\u65b0\u3002\n\n$code_progress_simple\n$demo_progress_simple\n\n\u5982\u679c\u60a8 with `tqdm` \u5e93\uff0c\u5e76\u4e14\u5e0c\u671b\u4ece\u51fd\u6570\u5185\u90e8\u7684\u4efb\u4f55 `tqdm.tqdm` \u81ea\u52a8\u62a5\u544a\u8fdb\u5ea6\u66f4\u65b0\uff0c\u8bf7\u5c06\u9ed8\u8ba4\u53c2\u6570\u8bbe\u7f6e\u4e3a `gr.Progress(track_tqdm=True)`\uff01\n\n## \u6279\u5904\u7406\u51fd\u6570 (Batch Functions)\n\nGradio \u652f\u6301\u4f20\u9012*\u6279\u5904\u7406*\u51fd\u6570\u3002\u6279\u5904\u7406\u51fd\u6570\u53ea\u662f\u63a5\u53d7\u8f93\u5165\u5217\u8868\u5e76\u8fd4\u56de\u9884\u6d4b\u5217\u8868\u7684\u51fd\u6570\u3002\n\n\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\u6279\u5904\u7406\u51fd\u6570\uff0c\u5b83\u63a5\u53d7\u4e24\u4e2a\u8f93\u5165\u5217\u8868\uff08\u4e00\u4e2a\u5355\u8bcd\u5217\u8868\u548c\u4e00\u4e2a\u6574\u6570\u5217\u8868\uff09\uff0c\u5e76\u8fd4\u56de\u4fee\u526a\u8fc7\u7684\u5355\u8bcd\u5217\u8868\u4f5c\u4e3a\u8f93\u51fa\uff1a\n\n```python\nimport time",
        "question": "What is required to enable iterative outputs in Gradio?",
        "answer": "Enabling queuing in the underlying Interface or Blocks.",
        "source_doc": "gradio-app/gradio/blob/main/guides/cn/01_getting-started/02_key-features.md",
        "rag_answer": null,
        "rag_context": null,
        "rag_score": null,
        "rag_feedback": null
    },
    {
        "sample_idx": 26,
        "question": "How do you create a generator function in Python?",
        "answer": "By using the `yield` statement instead of a single `return` value, often within a loop.",
        "rag_answer": "To create a generator function in Python, you need to define a function that uses the `yield` keyword instead of `return`. The `yield` keyword is used to produce a series of results instead of computing them all at once and returning them in a list, for example.\n\nHere is a simple example of a generator function:\n```\ndef my_generator(x):\n    for i in range(x):\n        yield i\n```\nIn this example, the `my_generator` function takes an integer `x` as an argument and yields a sequence of numbers from 0 to `x-1`.\n\nYou can use a generator function in a loop, like this:\n```\nfor num in my_generator(5):\n    print(num)\n```\nThis would output:\n```\n0\n1\n2\n3\n4\n```\nGenerator functions are useful when you need to generate a sequence of values on the fly, without having to store them all in memory at once. They are also useful when you need to implement cooperative multitasking or asynchronous programming.\n\nNote that generator functions can be used with the `next()` function to retrieve the next value in the sequence, like this:\n```\ngen = my_generator(5)\nprint(next(gen))  # prints 0\nprint(next(gen))  # prints 1\nprint(next(gen))  # prints 2\n```\nReferences:\n[KG] Gradio Documentation: Iterative Outputs\n[DC] Gradio Demo: blocks_random_slider",
        "rag_score": 5,
        "rag_feedback": "The response is completely correct, accurate, and factual. It provides a detailed explanation of how to create a generator function in Python, including the use of the `yield` statement and an example of a simple generator function. The response also mentions the importance of enabling queuing in the underlying Interface or Blocks to use generator functions.",
        "rag_context": {
            "kg_context": "-----Entities-----\n    ```csv\n    id,\tentity,\ttype,\tdescription,\trankcreated_at\n1,\tROUGE,category,ROUGE is a category of evaluation metrics for text generation tasks.,1,2025-03-24 13:20:24\n2,\tText Generation,UNKNOWN,ROUGE is a metric used to evaluate text generation models.,2,2025-03-24 13:20:24\n3,\tSession State,category,Session State is a type of state in Gradio that persists across multiple submits within a page session.,2,2025-03-24 13:20:24\n4,\tgr.State()\" ,technology,gr.State() is a function that creates a stateful object in Gradio.,1,2025-03-24 13:20:24\n5,\tguess_letter,event,guess_letter is a function in the hangman game that updates the state of used letters.,2,2025-03-24 13:20:24\n6,\tused_letters_var,category,used_letters_var is a variable that stores the used letters in the hangman game.,1,2025-03-24 13:20:24\n7,\tgr.State()\" ,technology,gr.State() is a function that creates a stateful object in Gradio.,1,UNKNOWN\n8,\tIterative Outputs,concept,Iterative Outputs refers to the ability of Gradio to generate and display multiple outputs in sequence.,1,UNKNOWN\n9,\tJupyter,category,Jupyter is a platform for interactive computing and data science.,2,UNKNOWN\n    ```\n    -----Relationships-----\n    ```csv\n    id,\tsource,\ttarget,\tdescription,\tkeywords,\tweight,\trank,\tcreated_at\n1,\tROUGE,Text Generation,ROUGE is a metric used to evaluate text generation models.,evaluation metric, task,18.0,3,2025-03-24 13:16:48\n2,\tSession State,gr.State()\" ,gr.State() is used to create a Session State in Gradio.,function usage, state creation,9.0,3,2025-03-24 13:20:24\n3,\tguess_letter,used_letters_var,used_letters_var is updated by the guess_letter function.,variable update, game logic,8.0,3,2025-03-24 13:20:24\n4,\tGradio,Jupyter,Gradio can be run on Jupyter notebooks.,platform compatibility, interactive computing,7.0,38,UNKNOWN\n5,\tGradio,Iterative Outputs,Gradio supports iterative outputs for generating and displaying multiple outputs in sequence.,output generation, sequence,9.0,37,UNKNOWN\n6,\tSession State,gr.State()\" ,gr.State() is used to create a Session State in Gradio.,function usage, state creation,9.0,3,UNKNOWN\n7,\tJupyter,notebooks,Notebooks are a type of interactive document used in Jupyter.,document type, interactive computing,7.0,3,UNKNOWN\n    ```\n    -----Sources-----\n    ```csv\n    id,\tcontent\n1,\tChoosing a metric for your task\n\n**So you've trained your model and want to see how well it\u2019s doing on a dataset of your choice. Where do you start?**\n\nThere is no \u201cone size fits all\u201d approach to choosing an evaluation metric, but some good guidelines to keep in mind are:\n\n## Categories of metrics\n\nThere are 3 high-level categories of metrics:\n\n1. *Generic metrics*, which can be applied to a variety of situations and datasets, such as precision and accuracy.\n2. *Task-specific metrics*, which are limited to a given task, such as Machine Translation (often evaluated using metrics [BLEU](https://huggingface.co/metrics/bleu) or [ROUGE](https://huggingface.co/metrics/rouge)) or Named Entity Recognition (often evaluated with [seqeval](https://huggingface.co/metrics/seqeval)).\n3. *Dataset-specific metrics*, which aim to measure model performance on specific benchmarks: for instance, the [GLUE benchmark](https://huggingface.co/datasets/glue) has a dedicated [evaluation metric](https://huggingface.co/metrics/glue).\n\nLet's look at each of these three cases:\n\n### Generic metrics\n\nMany of the metrics used in the Machine Learning community are quite generic and can be applied in a variety of tasks and datasets.\n\nThis is the case for metrics like [accuracy](https://huggingface.co/metrics/accuracy) and [precision](https://huggingface.co/metrics/precision), which can be used for evaluating labeled (supervised) datasets, as well as [perplexity](https://huggingface.co/metrics/perplexity), which can be used for evaluating different kinds of (unsupervised) generative tasks.\n\nTo see the input structure of a given metric, you can look at its metric card. For example, in the case of [precision](https://huggingface.co/metrics/precision), the format is:\n```\n>>> precision_metric = evaluate.load(\"precision\")\n>>> results = precision_metric.compute(references=[0, 1], predictions=[0, 1])\n>>> print(results)\n{'precision': 1.0}\n```\n\n### Task-specific metrics\n\nPopular ML tasks like Machine Translation and Named Entity Recognition have specific metrics that can be used to compare models. For example, a series of different metrics have been proposed for text generation, ranging from [BLEU](https://huggingface.co/metrics/bleu) and its derivatives such as [GoogleBLEU](https://huggingface.co/metrics/google_bleu) and [GLEU](https://huggingface.co/metrics/gleu), but also [ROUGE](https://huggingface.co/metrics/rouge), [MAUVE](https://huggingface.co/metrics/mauve), etc.\n\nYou can find the right metric for your task by:\n\n- **Looking at the [Task pages](https://huggingface.co/tasks)** to see what metrics can be used for evaluating models for a given task.\n- **Checking out leaderboards** on sites like [Papers With Code](https://paperswithcode.com/) (you can search by task and by dataset).\n-  **Reading the metric cards** for the relevant metrics and see which ones are a good fit for your use case. For example, see the [BLEU metric card](https://github.com/huggingface/evaluate/tree/main/metrics/bleu) or [SQuaD metric card](https://github.com/huggingface/evaluate/tree/main/metrics/squad).\n- **Looking at papers and blog posts** published on the topic and see what metrics they report. This can change over time, so try to pick papers from the last couple of years!\n\n### Dataset-specific metrics\n\nSome datasets have specific metrics associated with them -- this is especially in the case of popular benchmarks like [GLUE](https://huggingface.co/metrics/glue) and [SQuAD](https://huggingface.co/metrics/squad).\n\n<Tip warning={true}>\n\ud83d\udca1\nGLUE is actually a collection of different subsets on different tasks, so first you need to choose the one that corresponds to the NLI task, such as mnli, which is described as \u201ccrowdsourced collection of sentence pairs with textual entailment annotations\u201d\n</Tip>\n\n\nIf you are evaluating your model on a benchmark dataset like the ones mentioned above, you can use its dedicated evaluation metric. Make sure you respect the format that they require. For example, to evaluate your model on the [SQuAD](https://huggingface.co/datasets/squad) dataset, you need to feed the `question` and `context` into your model and return the `prediction_text`, which should be compared with the `references` (based on matching the `id` of the question) :\n\n```\n>>> from evaluate import load\n>>> squad_metric = load(\"squad\")\n>>> predictions = [{'prediction_text': '1976', 'id': '56e10a3be3433e1400422b22'}]\n>>> references = [{'answers': {'answer_start': [97], 'text': ['1976']}, 'id': '56e10a3be3433e1400422b22'}]\n>>> results = squad_metric.compute(predictions=predictions, references=references)\n>>> results\n{'exact_match': 100.0, 'f1': 100.0}\n```\n\nYou can find examples of dataset structures by consulting the \"Dataset Preview\" function or the dataset card for a given dataset, and you can see how to use its dedicated evaluation function based on the metric card.\n2,\tState in Blocks\n\nWe covered [State in Interfaces](https://gradio.app/interface-state), this guide takes a look at state in Blocks, which works mostly the same.\n\n## Global State\n\nGlobal state in Blocks works the same as in Interface. Any variable created outside a function call is a reference shared between all users.\n\n## Session State\n\nGradio supports session **state**, where data persists across multiple submits within a page session, in Blocks apps as well. To reiterate, session data is _not_ shared between different users of your model. To store data in a session state, you need to do three things:\n\n1. Create a `gr.State()` object. If there is a default value to this stateful object, pass that into the constructor.\n2. In the event listener, put the `State` object as an input and output.\n3. In the event listener function, add the variable to the input parameters and the return value.\n\nLet's take a look at a game of hangman.\n\n$code_hangman\n$demo_hangman\n\nLet's see how we do each of the 3 steps listed above in this game:\n\n1. We store the used letters in `used_letters_var`. In the constructor of `State`, we set the initial value of this to `[]`, an empty list.\n2. In `btn.click()`, we have a reference to `used_letters_var` in both the inputs and outputs.\n3. In `guess_letter`, we pass the value of this `State` to `used_letters`, and then return an updated value of this `State` in the return statement.\n\nWith more complex apps, you will likely have many State variables storing session state in a single Blocks app.\n\nLearn more about `State` in the [docs](https://gradio.app/docs#state).\n3,\t\u65f6\u5fc5\u987b\u9009\u62e9\u5176\u4e2d\u4e00\u4e2a\u5b57\u7b26\u4e32\uff0c\u8fd9\u5c06\u4f5c\u4e3a\u9644\u52a0\u5217\u4fdd\u5b58\u5230 CSV \u4e2d\u3002\n\n## \u9884\u5904\u7406\u548c\u540e\u5904\u7406 (Preprocessing and Postprocessing)\n\n![annotated](/assets/img/dataflow.svg)\n\n\u5982\u60a8\u6240\u89c1\uff0cGradio \u5305\u62ec\u53ef\u4ee5\u5904\u7406\u5404\u79cd\u4e0d\u540c\u6570\u636e\u7c7b\u578b\u7684\u7ec4\u4ef6\uff0c\u4f8b\u5982\u56fe\u50cf\u3001\u97f3\u9891\u548c\u89c6\u9891\u3002\u5927\u591a\u6570\u7ec4\u4ef6\u90fd\u53ef\u4ee5\u7528\u4f5c\u8f93\u5165\u6216\u8f93\u51fa\u3002\n\n\u5f53\u7ec4\u4ef6\u7528\u4f5c\u8f93\u5165\u65f6\uff0cGradio \u81ea\u52a8\u5904\u7406*\u9884\u5904\u7406*\uff0c\u5c06\u6570\u636e\u4ece\u7528\u6237\u6d4f\u89c8\u5668\u53d1\u9001\u7684\u7c7b\u578b\uff08\u4f8b\u5982\u7f51\u7edc\u6444\u50cf\u5934\u5feb\u7167\u7684 base64 \u8868\u793a\uff09\u8f6c\u6362\u4e3a\u60a8\u7684\u51fd\u6570\u53ef\u4ee5\u63a5\u53d7\u7684\u5f62\u5f0f\uff08\u4f8b\u5982 `numpy` \u6570\u7ec4\uff09\u3002\n\n\u540c\u6837\uff0c\u5f53\u7ec4\u4ef6\u7528\u4f5c\u8f93\u51fa\u65f6\uff0cGradio \u81ea\u52a8\u5904\u7406*\u540e\u5904\u7406*\uff0c\u5c06\u6570\u636e\u4ece\u51fd\u6570\u8fd4\u56de\u7684\u5f62\u5f0f\uff08\u4f8b\u5982\u56fe\u50cf\u8def\u5f84\u5217\u8868\uff09\u8f6c\u6362\u4e3a\u53ef\u4ee5\u5728\u7528\u6237\u6d4f\u89c8\u5668\u4e2d\u663e\u793a\u7684\u5f62\u5f0f\uff08\u4f8b\u5982\u4ee5 base64 \u683c\u5f0f\u663e\u793a\u56fe\u50cf\u7684 `Gallery`\uff09\u3002\n\n\u60a8\u53ef\u4ee5\u4f7f\u7528\u6784\u5efa\u56fe\u50cf\u7ec4\u4ef6\u65f6\u7684\u53c2\u6570\u63a7\u5236*\u9884\u5904\u7406*\u3002\u4f8b\u5982\uff0c\u5982\u679c\u60a8\u4f7f\u7528\u4ee5\u4e0b\u53c2\u6570\u5b9e\u4f8b\u5316 `Image` \u7ec4\u4ef6\uff0c\u5b83\u5c06\u5c06\u56fe\u50cf\u8f6c\u6362\u4e3a `PIL` \u7c7b\u578b\uff0c\u5e76\u5c06\u5176\u91cd\u5851\u4e3a`(100, 100)`\uff0c\u800c\u4e0d\u7ba1\u63d0\u4ea4\u65f6\u7684\u539f\u59cb\u5927\u5c0f\u5982\u4f55\uff1a\n\n```py\nimg = gr.Image(shape=(100, 100), type=\"pil\")\n```\n\n\u76f8\u53cd\uff0c\u8fd9\u91cc\u6211\u4eec\u4fdd\u7559\u56fe\u50cf\u7684\u539f\u59cb\u5927\u5c0f\uff0c\u4f46\u5728\u5c06\u5176\u8f6c\u6362\u4e3a numpy \u6570\u7ec4\u4e4b\u524d\u53cd\u8f6c\u989c\u8272\uff1a\n\n```py\nimg = gr.Image(invert_colors=True, type=\"numpy\")\n```\n\n\u540e\u5904\u7406\u8981\u5bb9\u6613\u5f97\u591a\uff01Gradio \u81ea\u52a8\u8bc6\u522b\u8fd4\u56de\u6570\u636e\u7684\u683c\u5f0f\uff08\u4f8b\u5982 `Image` \u662f `numpy` \u6570\u7ec4\u8fd8\u662f `str` \u6587\u4ef6\u8def\u5f84\uff1f\uff09\uff0c\u5e76\u5c06\u5176\u540e\u5904\u7406\u4e3a\u53ef\u4ee5\u7531\u6d4f\u89c8\u5668\u663e\u793a\u7684\u683c\u5f0f\u3002\n\n\u8bf7\u67e5\u770b[\u6587\u6863](https://gradio.app/docs)\uff0c\u4e86\u89e3\u6bcf\u4e2a\u7ec4\u4ef6\u7684\u6240\u6709\u4e0e\u9884\u5904\u7406\u76f8\u5173\u7684\u53c2\u6570\u3002\n\n## \u6837\u5f0f (Styling)\n\nGradio \u4e3b\u9898\u662f\u81ea\u5b9a\u4e49\u5e94\u7528\u7a0b\u5e8f\u5916\u89c2\u548c\u611f\u89c9\u7684\u6700\u7b80\u5355\u65b9\u6cd5\u3002\u60a8\u53ef\u4ee5\u9009\u62e9\u591a\u79cd\u4e3b\u9898\u6216\u521b\u5efa\u81ea\u5df1\u7684\u4e3b\u9898\u3002\u8981\u8fd9\u6837\u505a\uff0c\u8bf7\u5c06 `theme=` \u53c2\u6570\u4f20\u9012\u7ed9 `Interface` \u6784\u9020\u51fd\u6570\u3002\u4f8b\u5982\uff1a\n\n```python\ndemo = gr.Interface(..., theme=gr.themes.Monochrome())\n```\n\nGradio \u5e26\u6709\u4e00\u7ec4\u9884\u5148\u6784\u5efa\u7684\u4e3b\u9898\uff0c\u60a8\u53ef\u4ee5\u4ece `gr.themes.*` \u52a0\u8f7d\u3002\u60a8\u53ef\u4ee5\u6269\u5c55\u8fd9\u4e9b\u4e3b\u9898\u6216\u4ece\u5934\u5f00\u59cb\u521b\u5efa\u81ea\u5df1\u7684\u4e3b\u9898 - \u6709\u5173\u66f4\u591a\u8be6\u7ec6\u4fe1\u606f\uff0c\u8bf7\u53c2\u9605[\u4e3b\u9898\u6307\u5357](https://gradio.app/theming-guide)\u3002\n\n\u8981\u589e\u52a0\u989d\u5916\u7684\u6837\u5f0f\u80fd\u529b\uff0c\u60a8\u53ef\u4ee5 with `css=` \u5173\u952e\u5b57\u5c06\u4efb\u4f55 CSS \u4f20\u9012\u7ed9\u60a8\u7684\u5e94\u7528\u7a0b\u5e8f\u3002\nGradio \u5e94\u7528\u7a0b\u5e8f\u7684\u57fa\u7c7b\u662f `gradio-container`\uff0c\u56e0\u6b64\u4ee5\u4e0b\u662f\u4e00\u4e2a\u66f4\u6539 Gradio \u5e94\u7528\u7a0b\u5e8f\u80cc\u666f\u989c\u8272\u7684\u793a\u4f8b\uff1a\n\n```python\nwith `gr.Interface(css=\".gradio-container {background-color: red}\") as demo:\n    ...\n```\n\n## \u961f\u5217 (Queuing)\n\n\u5982\u679c\u60a8\u7684\u5e94\u7528\u7a0b\u5e8f\u9884\u8ba1\u4f1a\u6709\u5927\u91cf\u6d41\u91cf\uff0c\u8bf7 with `queue()` \u65b9\u6cd5\u6765\u63a7\u5236\u5904\u7406\u901f\u7387\u3002\u8fd9\u5c06\u6392\u961f\u5904\u7406\u8c03\u7528\uff0c\u56e0\u6b64\u4e00\u6b21\u53ea\u5904\u7406\u4e00\u5b9a\u6570\u91cf\u7684\u8bf7\u6c42\u3002\u961f\u5217\u4f7f\u7528 Websockets\uff0c\u8fd8\u53ef\u4ee5\u9632\u6b62\u7f51\u7edc\u8d85\u65f6\uff0c\u56e0\u6b64\u5982\u679c\u60a8\u7684\u51fd\u6570\u7684\u63a8\u7406\u65f6\u95f4\u5f88\u957f\uff08> 1 \u5206\u949f\uff09\uff0c\u5e94\u4f7f\u7528\u961f\u5217\u3002\n\nwith `Interface`\uff1a\n\n```python\ndemo = gr.Interface(...).queue()\ndemo.launch()\n```\n\nwith `Blocks`\uff1a\n\n```python\nwith gr.Blocks() as demo\uff1a\n    #...\ndemo.queue()\ndemo.launch()\n```\n\n\u60a8\u53ef\u4ee5\u901a\u8fc7\u4ee5\u4e0b\u65b9\u5f0f\u63a7\u5236\u4e00\u6b21\u5904\u7406\u7684\u8bf7\u6c42\u6570\u91cf\uff1a\n\n```python\ndemo.queue(concurrency_count=3)\n```\n\n\u67e5\u770b\u6709\u5173\u914d\u7f6e\u5176\u4ed6\u961f\u5217\u53c2\u6570\u7684[\u961f\u5217\u6587\u6863](/docs/#queue)\u3002\n\n\u5728 Blocks \u4e2d\u6307\u5b9a\u4ec5\u5bf9\u67d0\u4e9b\u51fd\u6570\u8fdb\u884c\u6392\u961f\uff1a\n\n```python\nwith gr.Blocks() as demo2\uff1a\n    num1 = gr.Number()\n    num2 = gr.Number()\n    output = gr.Number()\n    gr.Button(\"Add\").click(\n        lambda a, b: a + b, [num1, num2], output)\n    gr.Button(\"Multiply\").click(\n        lambda a, b: a * b, [num1, num2], output, queue=True)\ndemo2.launch()\n```\n\n## \u8fed\u4ee3\u8f93\u51fa (Iterative Outputs)\n\n\u5728\u67d0\u4e9b\u60c5\u51b5\u4e0b\uff0c\u60a8\u53ef\u80fd\u9700\u8981\u4f20\u8f93\u4e00\u7cfb\u5217\u8f93\u51fa\u800c\u4e0d\u662f\u4e00\u6b21\u663e\u793a\u5355\u4e2a\u8f93\u51fa\u3002\u4f8b\u5982\uff0c\u60a8\u53ef\u80fd\u6709\u4e00\u4e2a\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5e0c\u671b\u663e\u793a\u751f\u6210\u7684\u6bcf\u4e2a\u6b65\u9aa4\u7684\u56fe\u50cf\uff0c\u76f4\u5230\u6700\u7ec8\u56fe\u50cf\u3002\u6216\u8005\u60a8\u53ef\u80fd\u6709\u4e00\u4e2a\u804a\u5929\u673a\u5668\u4eba\uff0c\u5b83\u9010\u5b57\u9010\u53e5\u5730\u6d41\u5f0f\u4f20\u8f93\u54cd\u5e94\uff0c\u800c\u4e0d\u662f\u4e00\u6b21\u8fd4\u56de\u5168\u90e8\u54cd\u5e94\u3002\n\n\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u60a8\u53ef\u4ee5\u5c06**\u751f\u6210\u5668**\u51fd\u6570\u63d0\u4f9b\u7ed9 Gradio\uff0c\u800c\u4e0d\u662f\u5e38\u89c4\u51fd\u6570\u3002\u5728 Python \u4e2d\u521b\u5efa\u751f\u6210\u5668\u975e\u5e38\u7b80\u5355\uff1a\u51fd\u6570\u4e0d\u5e94\u8be5\u6709\u4e00\u4e2a\u5355\u72ec\u7684 `return` \u503c\uff0c\u800c\u662f\u5e94\u8be5 with `yield` \u8fde\u7eed\u8fd4\u56de\u4e00\u7cfb\u5217\u503c\u3002\u901a\u5e38\uff0c`yield` \u8bed\u53e5\u653e\u7f6e\u5728\u67d0\u79cd\u5faa\u73af\u4e2d\u3002\u4e0b\u9762\u662f\u4e00\u4e2a\u7b80\u5355\u793a\u4f8b\uff0c\u751f\u6210\u5668\u53ea\u662f\u7b80\u5355\u8ba1\u6570\u5230\u7ed9\u5b9a\u6570\u5b57\uff1a\n\n```python\ndef my_generator(x):\n    for i in range(x):\n        yield i\n```\n\n\u60a8\u4ee5\u4e0e\u5e38\u89c4\u51fd\u6570\u76f8\u540c\u7684\u65b9\u5f0f\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio\u3002\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\uff08\u865a\u62df\u7684\uff09\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5b83\u5728\u8f93\u51fa\u56fe\u50cf\u4e4b\u524d\u751f\u6210\u6570\u4e2a\u6b65\u9aa4\u7684\u566a\u97f3\uff1a\n\n$code_fake_diffusion\n$demo_fake_diffusion\n\n\u8bf7\u6ce8\u610f\uff0c\u6211\u4eec\u5728\u8fed\u4ee3\u5668\u4e2d\u6dfb\u52a0\u4e86 `time.sleep(1)`\uff0c\u4ee5\u521b\u5efa\u6b65\u9aa4\u4e4b\u95f4\u7684\u4eba\u5de5\u6682\u505c\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u89c2\u5bdf\u8fed\u4ee3\u5668\u7684\u6b65\u9aa4\uff08\u5728\u771f\u5b9e\u7684\u56fe\u50cf\u751f\u6210\u6a21\u578b\u4e2d\uff0c\u8fd9\n4,\t\u4e0e\u5e38\u89c4\u51fd\u6570\u76f8\u540c\u7684\u65b9\u5f0f\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio\u3002\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\uff08\u865a\u62df\u7684\uff09\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5b83\u5728\u8f93\u51fa\u56fe\u50cf\u4e4b\u524d\u751f\u6210\u6570\u4e2a\u6b65\u9aa4\u7684\u566a\u97f3\uff1a\n\n$code_fake_diffusion\n$demo_fake_diffusion\n\n\u8bf7\u6ce8\u610f\uff0c\u6211\u4eec\u5728\u8fed\u4ee3\u5668\u4e2d\u6dfb\u52a0\u4e86 `time.sleep(1)`\uff0c\u4ee5\u521b\u5efa\u6b65\u9aa4\u4e4b\u95f4\u7684\u4eba\u5de5\u6682\u505c\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u89c2\u5bdf\u8fed\u4ee3\u5668\u7684\u6b65\u9aa4\uff08\u5728\u771f\u5b9e\u7684\u56fe\u50cf\u751f\u6210\u6a21\u578b\u4e2d\uff0c\u8fd9\u53ef\u80fd\u662f\u4e0d\u5fc5\u8981\u7684\uff09\u3002\n\n\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio **\u9700\u8981**\u5728\u5e95\u5c42 Interface \u6216 Blocks \u4e2d\u542f\u7528\u961f\u5217\uff08\u8bf7\u53c2\u9605\u4e0a\u9762\u7684\u961f\u5217\u90e8\u5206\uff09\u3002\n\n## \u8fdb\u5ea6\u6761\n\nGradio \u652f\u6301\u521b\u5efa\u81ea\u5b9a\u4e49\u8fdb\u5ea6\u6761\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u81ea\u5b9a\u4e49\u548c\u63a7\u5236\u5411\u7528\u6237\u663e\u793a\u7684\u8fdb\u5ea6\u66f4\u65b0\u3002\u8981\u542f\u7528\u6b64\u529f\u80fd\uff0c\u53ea\u9700\u4e3a\u65b9\u6cd5\u6dfb\u52a0\u4e00\u4e2a\u9ed8\u8ba4\u503c\u4e3a `gr.Progress` \u5b9e\u4f8b\u7684\u53c2\u6570\u5373\u53ef\u3002\u7136\u540e\uff0c\u60a8\u53ef\u4ee5\u76f4\u63a5\u8c03\u7528\u6b64\u5b9e\u4f8b\u5e76\u4f20\u5165 0 \u5230 1 \u4e4b\u95f4\u7684\u6d6e\u70b9\u6570\u6765\u66f4\u65b0\u8fdb\u5ea6\u7ea7\u522b\uff0c\u6216\u8005 with `Progress` \u5b9e\u4f8b\u7684 `tqdm()` \u65b9\u6cd5\u6765\u8ddf\u8e2a\u53ef\u8fed\u4ee3\u5bf9\u8c61\u4e0a\u7684\u8fdb\u5ea6\uff0c\u5982\u4e0b\u6240\u793a\u3002\u5fc5\u987b\u542f\u7528\u961f\u5217\u4ee5\u8fdb\u884c\u8fdb\u5ea6\u66f4\u65b0\u3002\n\n$code_progress_simple\n$demo_progress_simple\n\n\u5982\u679c\u60a8 with `tqdm` \u5e93\uff0c\u5e76\u4e14\u5e0c\u671b\u4ece\u51fd\u6570\u5185\u90e8\u7684\u4efb\u4f55 `tqdm.tqdm` \u81ea\u52a8\u62a5\u544a\u8fdb\u5ea6\u66f4\u65b0\uff0c\u8bf7\u5c06\u9ed8\u8ba4\u53c2\u6570\u8bbe\u7f6e\u4e3a `gr.Progress(track_tqdm=True)`\uff01\n\n## \u6279\u5904\u7406\u51fd\u6570 (Batch Functions)\n\nGradio \u652f\u6301\u4f20\u9012*\u6279\u5904\u7406*\u51fd\u6570\u3002\u6279\u5904\u7406\u51fd\u6570\u53ea\u662f\u63a5\u53d7\u8f93\u5165\u5217\u8868\u5e76\u8fd4\u56de\u9884\u6d4b\u5217\u8868\u7684\u51fd\u6570\u3002\n\n\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\u6279\u5904\u7406\u51fd\u6570\uff0c\u5b83\u63a5\u53d7\u4e24\u4e2a\u8f93\u5165\u5217\u8868\uff08\u4e00\u4e2a\u5355\u8bcd\u5217\u8868\u548c\u4e00\u4e2a\u6574\u6570\u5217\u8868\uff09\uff0c\u5e76\u8fd4\u56de\u4fee\u526a\u8fc7\u7684\u5355\u8bcd\u5217\u8868\u4f5c\u4e3a\u8f93\u51fa\uff1a\n\n```python\nimport time\n\ndef trim_words(words, lens):\n    trimmed_words = []\n    time.sleep(5)\n    for w, l in zip(words, lens):\n        trimmed_words.append(w[:int(l)])\n    return [trimmed_words]\n    for w, l in zip(words, lens):\n```\n\n\u4f7f\u7528\u6279\u5904\u7406\u51fd\u6570\u7684\u4f18\u70b9\u662f\uff0c\u5982\u679c\u542f\u7528\u4e86\u961f\u5217\uff0cGradio \u670d\u52a1\u5668\u53ef\u4ee5\u81ea\u52a8*\u6279\u5904\u7406*\u4f20\u5165\u7684\u8bf7\u6c42\u5e76\u5e76\u884c\u5904\u7406\u5b83\u4eec\uff0c\u4ece\u800c\u53ef\u80fd\u52a0\u5feb\u6f14\u793a\u901f\u5ea6\u3002\u4ee5\u4e0b\u662f Gradio \u4ee3\u7801\u7684\u793a\u4f8b\uff08\u8bf7\u6ce8\u610f `batch=True` \u548c `max_batch_size=16` - \u8fd9\u4e24\u4e2a\u53c2\u6570\u90fd\u53ef\u4ee5\u4f20\u9012\u7ed9\u4e8b\u4ef6\u89e6\u53d1\u5668\u6216 `Interface` \u7c7b\uff09\n\nwith `Interface`\uff1a\n\n```python\ndemo = gr.Interface(trim_words, [\"textbox\", \"number\"], [\"output\"],\n                    batch=True, max_batch_size=16)\ndemo.queue()\ndemo.launch()\n```\n\nwith `Blocks`\uff1a\n\n```python\nimport gradio as gr\n\nwith gr.Blocks() as demo:\n    with gr.Row():\n        word = gr.Textbox(label=\"word\")\n        leng = gr.Number(label=\"leng\")\n        output = gr.Textbox(label=\"Output\")\n    with gr.Row():\n        run = gr.Button()\n\n    event = run.click(trim_words, [word, leng], output, batch=True, max_batch_size=16)\n\ndemo.queue()\ndemo.launch()\n```\n\n\u5728\u4e0a\u9762\u7684\u793a\u4f8b\u4e2d\uff0c\u53ef\u4ee5\u5e76\u884c\u5904\u7406 16 \u4e2a\u8bf7\u6c42\uff08\u603b\u63a8\u7406\u65f6\u95f4\u4e3a 5 \u79d2\uff09\uff0c\u800c\u4e0d\u662f\u5206\u522b\u5904\u7406\u6bcf\u4e2a\u8bf7\u6c42\uff08\u603b\u63a8\u7406\u65f6\u95f4\u4e3a 80 \u79d2\uff09\u3002\u8bb8\u591a Hugging Face \u7684 `transformers` \u548c `diffusers` \u6a21\u578b\u5728 Gradio \u7684\u6279\u5904\u7406\u6a21\u5f0f\u4e0b\u81ea\u7136\u5de5\u4f5c\uff1a\u8fd9\u662f[\u4f7f\u7528\u6279\u5904\u7406\u751f\u6210\u56fe\u50cf\u7684\u793a\u4f8b\u6f14\u793a](https://github.com/gradio-app/gradio/blob/main/demo/diffusers_with_batching/run.py)\n\n\u6ce8\u610f\uff1a\u4f7f\u7528 Gradio \u7684\u6279\u5904\u7406\u51fd\u6570 **requires** \u5728\u5e95\u5c42 Interface \u6216 Blocks \u4e2d\u542f\u7528\u961f\u5217\uff08\u8bf7\u53c2\u9605\u4e0a\u9762\u7684\u961f\u5217\u90e8\u5206\uff09\u3002\n\n## Gradio \u7b14\u8bb0\u672c (Colab Notebooks)\n\nGradio \u53ef\u4ee5\u5728\u4efb\u4f55\u8fd0\u884c Python \u7684\u5730\u65b9\u8fd0\u884c\uff0c\u5305\u62ec\u672c\u5730 Jupyter \u7b14\u8bb0\u672c\u548c\u534f\u4f5c\u7b14\u8bb0\u672c\uff0c\u5982[Google Colab](https://colab.research.google.com/)\u3002\u5bf9\u4e8e\u672c\u5730 Jupyter \u7b14\u8bb0\u672c\u548c Google Colab \u7b14\u8bb0\u672c\uff0cGradio \u5728\u672c\u5730\u670d\u52a1\u5668\u4e0a\u8fd0\u884c\uff0c\u60a8\u53ef\u4ee5\u5728\u6d4f\u89c8\u5668\u4e2d\u4e0e\u4e4b\u4ea4\u4e92\u3002\uff08\u6ce8\u610f\uff1a\u5bf9\u4e8e Google Colab\uff0c\u8fd9\u662f\u901a\u8fc7[\u670d\u52a1\u5de5\u4f5c\u5668\u96a7\u9053](https://github.com/tensorflow/tensorboard/blob/master/docs/design/colab_integration.md)\u5b9e\u73b0\u7684\uff0c\u60a8\u7684\u6d4f\u89c8\u5668\u9700\u8981\u542f\u7528 cookies\u3002\uff09\u5bf9\u4e8e\u5176\u4ed6\u8fdc\u7a0b\u7b14\u8bb0\u672c\uff0cGradio \u4e5f\u5c06\u5728\u670d\u52a1\u5668\u4e0a\u8fd0\u884c\uff0c\u4f46\u60a8\u9700\u8981\u4f7f\u7528[SSH \u96a7\u9053](https://coderwall.com/p/ohk6cg/remote-access-to-ipython-notebooks-via-ssh)\u5728\u672c\u5730\u6d4f\u89c8\u5668\u4e2d\u67e5\u770b\u5e94\u7528\u7a0b\u5e8f\u3002\u901a\u5e38\uff0c\u66f4\u7b80\u5355\u7684\u9009\u62e9\u662f\u4f7f\u7528 Gradio \u5185\u7f6e\u7684\u516c\u5171\u94fe\u63a5\uff0c[\u5728\u4e0b\u4e00\u7bc7\u6307\u5357\u4e2d\u8ba8\u8bba](/sharing-your-app/#sharing-demos)\u3002\n    ```",
            "vector_context": "[Created at: 2025-03-24 13:18:21]\nGradio Demo: blocks_random_slider\n\n\n```\n!pip install -q gradio \n```\n\n\n```\n\nimport gradio as gr\n\n\ndef func(slider_1, slider_2):\n    return slider_1 * 5 + slider_2\n\n\nwith gr.Blocks() as demo:\n    slider = gr.Slider(minimum=-10.2, maximum=15, label=\"Random Slider (Static)\", randomize=True)\n    slider_1 = gr.Slider(minimum=100, maximum=200, label=\"Random Slider (Input 1)\", randomize=True)\n    slider_2 = gr.Slider(minimum=10, maximum=23.2, label=\"Random Slider (Input 2)\", randomize=True)\n    slider_3 = gr.Slider(value=3, label=\"Non random slider\")\n    btn = gr.Button(\"Run\")\n    btn.click(func, inputs=[slider_1, slider_2], outputs=gr.Number())\n\nif __name__ == \"__main__\":\n    demo.launch()\n\n```\n--New Chunk--\n[Created at: 2025-03-24 13:16:48]\n\u4e0e\u5e38\u89c4\u51fd\u6570\u76f8\u540c\u7684\u65b9\u5f0f\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio\u3002\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\uff08\u865a\u62df\u7684\uff09\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5b83\u5728\u8f93\u51fa\u56fe\u50cf\u4e4b\u524d\u751f\u6210\u6570\u4e2a\u6b65\u9aa4\u7684\u566a\u97f3\uff1a\n\n$code_fake_diffusion\n$demo_fake_diffusion\n\n\u8bf7\u6ce8\u610f\uff0c\u6211\u4eec\u5728\u8fed\u4ee3\u5668\u4e2d\u6dfb\u52a0\u4e86 `time.sleep(1)`\uff0c\u4ee5\u521b\u5efa\u6b65\u9aa4\u4e4b\u95f4\u7684\u4eba\u5de5\u6682\u505c\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u89c2\u5bdf\u8fed\u4ee3\u5668\u7684\u6b65\u9aa4\uff08\u5728\u771f\u5b9e\u7684\u56fe\u50cf\u751f\u6210\u6a21\u578b\u4e2d\uff0c\u8fd9\u53ef\u80fd\u662f\u4e0d\u5fc5\u8981\u7684\uff09\u3002\n\n\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio **\u9700\u8981**\u5728\u5e95\u5c42 Interface \u6216 Blocks \u4e2d\u542f\u7528\u961f\u5217\uff08\u8bf7\u53c2\u9605\u4e0a\u9762\u7684\u961f\u5217\u90e8\u5206\uff09\u3002\n\n## \u8fdb\u5ea6\u6761\n\nGradio \u652f\u6301\u521b\u5efa\u81ea\u5b9a\u4e49\u8fdb\u5ea6\u6761\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u81ea\u5b9a\u4e49\u548c\u63a7\u5236\u5411\u7528\u6237\u663e\u793a\u7684\u8fdb\u5ea6\u66f4\u65b0\u3002\u8981\u542f\u7528\u6b64\u529f\u80fd\uff0c\u53ea\u9700\u4e3a\u65b9\u6cd5\u6dfb\u52a0\u4e00\u4e2a\u9ed8\u8ba4\u503c\u4e3a `gr.Progress` \u5b9e\u4f8b\u7684\u53c2\u6570\u5373\u53ef\u3002\u7136\u540e\uff0c\u60a8\u53ef\u4ee5\u76f4\u63a5\u8c03\u7528\u6b64\u5b9e\u4f8b\u5e76\u4f20\u5165 0 \u5230 1 \u4e4b\u95f4\u7684\u6d6e\u70b9\u6570\u6765\u66f4\u65b0\u8fdb\u5ea6\u7ea7\u522b\uff0c\u6216\u8005 with `Progress` \u5b9e\u4f8b\u7684 `tqdm()` \u65b9\u6cd5\u6765\u8ddf\u8e2a\u53ef\u8fed\u4ee3\u5bf9\u8c61\u4e0a\u7684\u8fdb\u5ea6\uff0c\u5982\u4e0b\u6240\u793a\u3002\u5fc5\u987b\u542f\u7528\u961f\u5217\u4ee5\u8fdb\u884c\u8fdb\u5ea6\u66f4\u65b0\u3002\n\n$code_progress_simple\n$demo_progress_simple\n\n\u5982\u679c\u60a8 with `tqdm` \u5e93\uff0c\u5e76\u4e14\u5e0c\u671b\u4ece\u51fd\u6570\u5185\u90e8\u7684\u4efb\u4f55 `tqdm.tqdm` \u81ea\u52a8\u62a5\u544a\u8fdb\u5ea6\u66f4\u65b0\uff0c\u8bf7\u5c06\u9ed8\u8ba4\u53c2\u6570\u8bbe\u7f6e\u4e3a `gr.Progress(track_tqdm=True)`\uff01\n\n## \u6279\u5904\u7406\u51fd\u6570 (Batch Functions)\n\nGradio \u652f\u6301\u4f20\u9012*\u6279\u5904\u7406*\u51fd\u6570\u3002\u6279\u5904\u7406\u51fd\u6570\u53ea\u662f\u63a5\u53d7\u8f93\u5165\u5217\u8868\u5e76\u8fd4\u56de\u9884\u6d4b\u5217\u8868\u7684\u51fd\u6570\u3002\n\n\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\u6279\u5904\u7406\u51fd\u6570\uff0c\u5b83\u63a5\u53d7\u4e24\u4e2a\u8f93\u5165\u5217\u8868\uff08\u4e00\u4e2a\u5355\u8bcd\u5217\u8868\u548c\u4e00\u4e2a\u6574\u6570\u5217\u8868\uff09\uff0c\u5e76\u8fd4\u56de\u4fee\u526a\u8fc7\u7684\u5355\u8bcd\u5217\u8868\u4f5c\u4e3a\u8f93\u51fa\uff1a\n\n```python\nimport time\n\ndef trim_words(words, lens):\n    trimmed_words = []\n    time.sleep(5)\n    for w, l in zip(words, lens):\n        trimmed_words.append(w[:int(l)])\n    return [trimmed_words]\n    for w, l in zip(words, lens):\n```\n\n\u4f7f\u7528\u6279\u5904\u7406\u51fd\u6570\u7684\u4f18\u70b9\u662f\uff0c\u5982\u679c\u542f\u7528\u4e86\u961f\u5217\uff0cGradio \u670d\u52a1\u5668\u53ef\u4ee5\u81ea\u52a8*\u6279\u5904\u7406*\u4f20\u5165\u7684\u8bf7\u6c42\u5e76\u5e76\u884c\u5904\u7406\u5b83\u4eec\uff0c\u4ece\u800c\u53ef\u80fd\u52a0\u5feb\u6f14\u793a\u901f\u5ea6\u3002\u4ee5\u4e0b\u662f Gradio \u4ee3\u7801\u7684\u793a\u4f8b\uff08\u8bf7\u6ce8\u610f `batch=True` \u548c `max_batch_size=16` - \u8fd9\u4e24\u4e2a\u53c2\u6570\u90fd\u53ef\u4ee5\u4f20\u9012\u7ed9\u4e8b\u4ef6\u89e6\u53d1\u5668\u6216 `Interface` \u7c7b\uff09\n\nwith `Interface`\uff1a\n\n```python\ndemo = gr.Interface(trim_words, [\"textbox\", \"number\"], [\"output\"],\n                    batch=True, max_batch_size=16)\ndemo.queue()\ndemo.launch()\n```\n\nwith `Blocks`\uff1a\n\n```python\nimport gradio as gr\n\nwith gr.Blocks() as demo:\n    with gr.Row():\n        word = gr.Textbox(label=\"word\")\n        leng = gr.Number(label=\"leng\")\n        output = gr.Textbox(label=\"Output\")\n    with gr.Row():\n        run = gr.Button()\n\n    event = run.click(trim_words, [word, leng], output, batch=True, max_batch_size=16)\n\ndemo.queue()\ndemo.launch()\n```\n\n\u5728\u4e0a\u9762\u7684\u793a\u4f8b\u4e2d\uff0c\u53ef\u4ee5\u5e76\u884c\u5904\u7406 16 \u4e2a\u8bf7\u6c42\uff08\u603b\u63a8\u7406\u65f6\u95f4\u4e3a 5 \u79d2\uff09\uff0c\u800c\u4e0d\u662f\u5206\u522b\u5904\u7406\u6bcf\u4e2a\u8bf7\u6c42\uff08\u603b\u63a8\u7406\u65f6\u95f4\u4e3a 80 \u79d2\uff09\u3002\u8bb8\u591a Hugging Face \u7684 `transformers` \u548c `diffusers` \u6a21\u578b\u5728 Gradio \u7684\u6279\u5904\u7406\u6a21\u5f0f\u4e0b\u81ea\u7136\u5de5\u4f5c\uff1a\u8fd9\u662f[\u4f7f\u7528\u6279\u5904\u7406\u751f\u6210\u56fe\u50cf\u7684\u793a\u4f8b\u6f14\u793a](https://github.com/gradio-app/gradio/blob/main/demo/diffusers_with_batching/run.py)\n\n\u6ce8\u610f\uff1a\u4f7f\u7528 Gradio \u7684\u6279\u5904\u7406\u51fd\u6570 **requires** \u5728\u5e95\u5c42 Interface \u6216 Blocks \u4e2d\u542f\u7528\u961f\u5217\uff08\u8bf7\u53c2\u9605\u4e0a\u9762\u7684\u961f\u5217\u90e8\u5206\uff09\u3002\n\n## Gradio \u7b14\u8bb0\u672c (Colab Notebooks)\n\nGradio \u53ef\u4ee5\u5728\u4efb\u4f55\u8fd0\u884c Python \u7684\u5730\u65b9\u8fd0\u884c\uff0c\u5305\u62ec\u672c\u5730 Jupyter \u7b14\u8bb0\u672c\u548c\u534f\u4f5c\u7b14\u8bb0\u672c\uff0c\u5982[Google Colab](https://colab.research.google.com/)\u3002\u5bf9\u4e8e\u672c\u5730 Jupyter \u7b14\u8bb0\u672c\u548c Google Colab \u7b14\u8bb0\u672c\uff0cGradio \u5728\u672c\u5730\u670d\u52a1\u5668\u4e0a\u8fd0\u884c\uff0c\u60a8\u53ef\u4ee5\u5728\u6d4f\u89c8\u5668\u4e2d\u4e0e\u4e4b\u4ea4\u4e92\u3002\uff08\u6ce8\u610f\uff1a\u5bf9\u4e8e Google Colab\uff0c\u8fd9\u662f\u901a\u8fc7[\u670d\u52a1\u5de5\u4f5c\u5668\u96a7\u9053](https://github.com/tensorflow/tensorboard/blob/master/docs/design/colab_integration.md)\u5b9e\u73b0\u7684\uff0c\u60a8\u7684\u6d4f\u89c8\u5668\u9700\u8981\u542f\u7528 cookies\u3002\uff09\u5bf9\u4e8e\u5176\u4ed6\u8fdc\u7a0b\u7b14\u8bb0\u672c\uff0cGradio \u4e5f\u5c06\u5728\u670d\u52a1\u5668\u4e0a\u8fd0\u884c\uff0c\u4f46\u60a8\u9700\u8981\u4f7f\u7528[SSH \u96a7\u9053](https://coderwall.com/p/ohk6cg/remote-access-to-ipython-notebooks-via-ssh)\u5728\u672c\u5730\u6d4f\u89c8\u5668\u4e2d\u67e5\u770b\u5e94\u7528\u7a0b\u5e8f\u3002\u901a\u5e38\uff0c\u66f4\u7b80\u5355\u7684\u9009\u62e9\u662f\u4f7f\u7528 Gradio \u5185\u7f6e\u7684\u516c\u5171\u94fe\u63a5\uff0c[\u5728\u4e0b\u4e00\u7bc7\u6307\u5357\u4e2d\u8ba8\u8bba](/sharing-your-app/#sharing-demos)\u3002\n--New Chunk--\n[Created at: 2025-03-24 13:16:13]\n=predictions, references=references)\n>>> results\n{'exact_match': 100.0, 'f1': 100.0}\n```\n\nYou can find examples of dataset structures by consulting the \"Dataset Preview\" function or the dataset card for a given dataset, and you can see how to use its dedicated evaluation function based on the metric card."
        }
    },
    {
        "sample_idx": 27,
        "question": "What is required to enable progress updates in Gradio?",
        "answer": "Enabling queuing and adding a `gr.Progress` instance as a parameter to the method.",
        "rag_answer": "To enable progress updates in Gradio, you need to do the following:\n\n1. **Enable queueing**: You must enable queueing in the underlying Interface or Blocks. This is because progress updates require queueing to be enabled.\n\n2. **Create a `gr.Progress` instance**: You need to create a `gr.Progress` instance and pass it as a default value to a method.\n\n3. **Call the `Progress` instance**: You can then call the `Progress` instance and pass a float value between 0 and 1 to update the progress level.\n\n4. **Use `tqdm` integration (optional)**: If you are using the `tqdm` library, you can set `track_tqdm=True` when creating the `gr.Progress` instance to automatically report progress updates from `tqdm`.\n\nBy following these steps, you can enable progress updates in Gradio and provide a better user experience for your application.\n\nReferences:\n[KG] Gradio Knowledge Graph: Progress\n[DC] Document Chunk: Progress Updates",
        "rag_score": 5,
        "rag_feedback": "The system's response is completely correct, accurate, and factual. It provides a detailed explanation of how to enable progress updates in Gradio, including enabling queuing and adding a `gr.Progress` instance as a parameter to the method. The response also provides additional information on how to use the `gr.Progress` instance and integrate it with `tqdm` library.",
        "rag_context": {
            "kg_context": "-----Entities-----\n    ```csv\n    id,\tentity,\ttype,\tdescription,\trankcreated_at\n1,\tGradio,organization,Gradio is a platform that supports state in Blocks, providing features such as global state and session state.<SEP>Gradio is an interface that provides various features for demonstrating models, including adding example inputs, custom error messages, descriptive content, flagging, and more.<SEP>Gradio is an organization that provides a platform for building and deploying machine learning models.<SEP>Gradio is an organization that provides a platform for creating and deploying machine learning models.<SEP>Gradio is an organization that provides a demo for blocks_random_slider, and its library is used to create interactive interfaces.,36,2025-03-24 13:17:31\n2,\tProgress,category,Progress is a category of components in Gradio that enables the creation of custom progress bars.,1,2025-03-24 13:17:31\n3,\tgr,organization,gr is an organization that provides the Gradio library used in the demo.,1,2025-03-24 13:17:31\n4,\ttqdm,category,tqdm is a library for creating progress bars in Python.,1,2025-03-24 13:17:31\n5,\tfunc,event,func is an event that occurs when the button is clicked, executing a specific function.,1,UNKNOWN\n6,\tProgress,category,Progress is a category of components in Gradio that enables the creation of custom progress bars.,1,UNKNOWN\n7,\tHangman,event,Hangman is a game used as an example to demonstrate how to use state in Blocks.,1,UNKNOWN\n    ```\n    -----Relationships-----\n    ```csv\n    id,\tsource,\ttarget,\tdescription,\tkeywords,\tweight,\trank,\tcreated_at\n1,\tGradio,Progress,Gradio provides the Progress component for creating custom progress bars.,component relationship, progress tracking,14.0,37,2025-03-24 13:17:31\n2,\tGradio,gr,gr is the organization that provides the Gradio library used in the demo.,organization, organization,9.0,37,2025-03-24 13:18:47\n3,\tGradio,tqdm,tqdm is used in Gradio for creating progress bars.,library integration, progress tracking,7.0,37,2025-03-24 13:17:31\n4,\tGradio,Progress,Gradio provides the Progress component for creating custom progress bars.,component relationship, progress tracking,14.0,37,UNKNOWN\n5,\tGradio Demo,func,func is an event that occurs in Gradio Demo when the button is clicked.,event, event,8.0,9,UNKNOWN\n6,\tBlocks,Hangman,Hangman is an example game that uses state in Blocks.,example, game development,16.0,3,UNKNOWN\n    ```\n    -----Sources-----\n    ```csv\n    id,\tcontent\n1,\t\u4e0e\u5e38\u89c4\u51fd\u6570\u76f8\u540c\u7684\u65b9\u5f0f\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio\u3002\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\uff08\u865a\u62df\u7684\uff09\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5b83\u5728\u8f93\u51fa\u56fe\u50cf\u4e4b\u524d\u751f\u6210\u6570\u4e2a\u6b65\u9aa4\u7684\u566a\u97f3\uff1a\n\n$code_fake_diffusion\n$demo_fake_diffusion\n\n\u8bf7\u6ce8\u610f\uff0c\u6211\u4eec\u5728\u8fed\u4ee3\u5668\u4e2d\u6dfb\u52a0\u4e86 `time.sleep(1)`\uff0c\u4ee5\u521b\u5efa\u6b65\u9aa4\u4e4b\u95f4\u7684\u4eba\u5de5\u6682\u505c\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u89c2\u5bdf\u8fed\u4ee3\u5668\u7684\u6b65\u9aa4\uff08\u5728\u771f\u5b9e\u7684\u56fe\u50cf\u751f\u6210\u6a21\u578b\u4e2d\uff0c\u8fd9\u53ef\u80fd\u662f\u4e0d\u5fc5\u8981\u7684\uff09\u3002\n\n\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio **\u9700\u8981**\u5728\u5e95\u5c42 Interface \u6216 Blocks \u4e2d\u542f\u7528\u961f\u5217\uff08\u8bf7\u53c2\u9605\u4e0a\u9762\u7684\u961f\u5217\u90e8\u5206\uff09\u3002\n\n## \u8fdb\u5ea6\u6761\n\nGradio \u652f\u6301\u521b\u5efa\u81ea\u5b9a\u4e49\u8fdb\u5ea6\u6761\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u81ea\u5b9a\u4e49\u548c\u63a7\u5236\u5411\u7528\u6237\u663e\u793a\u7684\u8fdb\u5ea6\u66f4\u65b0\u3002\u8981\u542f\u7528\u6b64\u529f\u80fd\uff0c\u53ea\u9700\u4e3a\u65b9\u6cd5\u6dfb\u52a0\u4e00\u4e2a\u9ed8\u8ba4\u503c\u4e3a `gr.Progress` \u5b9e\u4f8b\u7684\u53c2\u6570\u5373\u53ef\u3002\u7136\u540e\uff0c\u60a8\u53ef\u4ee5\u76f4\u63a5\u8c03\u7528\u6b64\u5b9e\u4f8b\u5e76\u4f20\u5165 0 \u5230 1 \u4e4b\u95f4\u7684\u6d6e\u70b9\u6570\u6765\u66f4\u65b0\u8fdb\u5ea6\u7ea7\u522b\uff0c\u6216\u8005 with `Progress` \u5b9e\u4f8b\u7684 `tqdm()` \u65b9\u6cd5\u6765\u8ddf\u8e2a\u53ef\u8fed\u4ee3\u5bf9\u8c61\u4e0a\u7684\u8fdb\u5ea6\uff0c\u5982\u4e0b\u6240\u793a\u3002\u5fc5\u987b\u542f\u7528\u961f\u5217\u4ee5\u8fdb\u884c\u8fdb\u5ea6\u66f4\u65b0\u3002\n\n$code_progress_simple\n$demo_progress_simple\n\n\u5982\u679c\u60a8 with `tqdm` \u5e93\uff0c\u5e76\u4e14\u5e0c\u671b\u4ece\u51fd\u6570\u5185\u90e8\u7684\u4efb\u4f55 `tqdm.tqdm` \u81ea\u52a8\u62a5\u544a\u8fdb\u5ea6\u66f4\u65b0\uff0c\u8bf7\u5c06\u9ed8\u8ba4\u53c2\u6570\u8bbe\u7f6e\u4e3a `gr.Progress(track_tqdm=True)`\uff01\n\n## \u6279\u5904\u7406\u51fd\u6570 (Batch Functions)\n\nGradio \u652f\u6301\u4f20\u9012*\u6279\u5904\u7406*\u51fd\u6570\u3002\u6279\u5904\u7406\u51fd\u6570\u53ea\u662f\u63a5\u53d7\u8f93\u5165\u5217\u8868\u5e76\u8fd4\u56de\u9884\u6d4b\u5217\u8868\u7684\u51fd\u6570\u3002\n\n\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\u6279\u5904\u7406\u51fd\u6570\uff0c\u5b83\u63a5\u53d7\u4e24\u4e2a\u8f93\u5165\u5217\u8868\uff08\u4e00\u4e2a\u5355\u8bcd\u5217\u8868\u548c\u4e00\u4e2a\u6574\u6570\u5217\u8868\uff09\uff0c\u5e76\u8fd4\u56de\u4fee\u526a\u8fc7\u7684\u5355\u8bcd\u5217\u8868\u4f5c\u4e3a\u8f93\u51fa\uff1a\n\n```python\nimport time\n\ndef trim_words(words, lens):\n    trimmed_words = []\n    time.sleep(5)\n    for w, l in zip(words, lens):\n        trimmed_words.append(w[:int(l)])\n    return [trimmed_words]\n    for w, l in zip(words, lens):\n```\n\n\u4f7f\u7528\u6279\u5904\u7406\u51fd\u6570\u7684\u4f18\u70b9\u662f\uff0c\u5982\u679c\u542f\u7528\u4e86\u961f\u5217\uff0cGradio \u670d\u52a1\u5668\u53ef\u4ee5\u81ea\u52a8*\u6279\u5904\u7406*\u4f20\u5165\u7684\u8bf7\u6c42\u5e76\u5e76\u884c\u5904\u7406\u5b83\u4eec\uff0c\u4ece\u800c\u53ef\u80fd\u52a0\u5feb\u6f14\u793a\u901f\u5ea6\u3002\u4ee5\u4e0b\u662f Gradio \u4ee3\u7801\u7684\u793a\u4f8b\uff08\u8bf7\u6ce8\u610f `batch=True` \u548c `max_batch_size=16` - \u8fd9\u4e24\u4e2a\u53c2\u6570\u90fd\u53ef\u4ee5\u4f20\u9012\u7ed9\u4e8b\u4ef6\u89e6\u53d1\u5668\u6216 `Interface` \u7c7b\uff09\n\nwith `Interface`\uff1a\n\n```python\ndemo = gr.Interface(trim_words, [\"textbox\", \"number\"], [\"output\"],\n                    batch=True, max_batch_size=16)\ndemo.queue()\ndemo.launch()\n```\n\nwith `Blocks`\uff1a\n\n```python\nimport gradio as gr\n\nwith gr.Blocks() as demo:\n    with gr.Row():\n        word = gr.Textbox(label=\"word\")\n        leng = gr.Number(label=\"leng\")\n        output = gr.Textbox(label=\"Output\")\n    with gr.Row():\n        run = gr.Button()\n\n    event = run.click(trim_words, [word, leng], output, batch=True, max_batch_size=16)\n\ndemo.queue()\ndemo.launch()\n```\n\n\u5728\u4e0a\u9762\u7684\u793a\u4f8b\u4e2d\uff0c\u53ef\u4ee5\u5e76\u884c\u5904\u7406 16 \u4e2a\u8bf7\u6c42\uff08\u603b\u63a8\u7406\u65f6\u95f4\u4e3a 5 \u79d2\uff09\uff0c\u800c\u4e0d\u662f\u5206\u522b\u5904\u7406\u6bcf\u4e2a\u8bf7\u6c42\uff08\u603b\u63a8\u7406\u65f6\u95f4\u4e3a 80 \u79d2\uff09\u3002\u8bb8\u591a Hugging Face \u7684 `transformers` \u548c `diffusers` \u6a21\u578b\u5728 Gradio \u7684\u6279\u5904\u7406\u6a21\u5f0f\u4e0b\u81ea\u7136\u5de5\u4f5c\uff1a\u8fd9\u662f[\u4f7f\u7528\u6279\u5904\u7406\u751f\u6210\u56fe\u50cf\u7684\u793a\u4f8b\u6f14\u793a](https://github.com/gradio-app/gradio/blob/main/demo/diffusers_with_batching/run.py)\n\n\u6ce8\u610f\uff1a\u4f7f\u7528 Gradio \u7684\u6279\u5904\u7406\u51fd\u6570 **requires** \u5728\u5e95\u5c42 Interface \u6216 Blocks \u4e2d\u542f\u7528\u961f\u5217\uff08\u8bf7\u53c2\u9605\u4e0a\u9762\u7684\u961f\u5217\u90e8\u5206\uff09\u3002\n\n## Gradio \u7b14\u8bb0\u672c (Colab Notebooks)\n\nGradio \u53ef\u4ee5\u5728\u4efb\u4f55\u8fd0\u884c Python \u7684\u5730\u65b9\u8fd0\u884c\uff0c\u5305\u62ec\u672c\u5730 Jupyter \u7b14\u8bb0\u672c\u548c\u534f\u4f5c\u7b14\u8bb0\u672c\uff0c\u5982[Google Colab](https://colab.research.google.com/)\u3002\u5bf9\u4e8e\u672c\u5730 Jupyter \u7b14\u8bb0\u672c\u548c Google Colab \u7b14\u8bb0\u672c\uff0cGradio \u5728\u672c\u5730\u670d\u52a1\u5668\u4e0a\u8fd0\u884c\uff0c\u60a8\u53ef\u4ee5\u5728\u6d4f\u89c8\u5668\u4e2d\u4e0e\u4e4b\u4ea4\u4e92\u3002\uff08\u6ce8\u610f\uff1a\u5bf9\u4e8e Google Colab\uff0c\u8fd9\u662f\u901a\u8fc7[\u670d\u52a1\u5de5\u4f5c\u5668\u96a7\u9053](https://github.com/tensorflow/tensorboard/blob/master/docs/design/colab_integration.md)\u5b9e\u73b0\u7684\uff0c\u60a8\u7684\u6d4f\u89c8\u5668\u9700\u8981\u542f\u7528 cookies\u3002\uff09\u5bf9\u4e8e\u5176\u4ed6\u8fdc\u7a0b\u7b14\u8bb0\u672c\uff0cGradio \u4e5f\u5c06\u5728\u670d\u52a1\u5668\u4e0a\u8fd0\u884c\uff0c\u4f46\u60a8\u9700\u8981\u4f7f\u7528[SSH \u96a7\u9053](https://coderwall.com/p/ohk6cg/remote-access-to-ipython-notebooks-via-ssh)\u5728\u672c\u5730\u6d4f\u89c8\u5668\u4e2d\u67e5\u770b\u5e94\u7528\u7a0b\u5e8f\u3002\u901a\u5e38\uff0c\u66f4\u7b80\u5355\u7684\u9009\u62e9\u662f\u4f7f\u7528 Gradio \u5185\u7f6e\u7684\u516c\u5171\u94fe\u63a5\uff0c[\u5728\u4e0b\u4e00\u7bc7\u6307\u5357\u4e2d\u8ba8\u8bba](/sharing-your-app/#sharing-demos)\u3002\n2,\tGradio Demo: blocks_random_slider\n\n\n```\n!pip install -q gradio \n```\n\n\n```\n\nimport gradio as gr\n\n\ndef func(slider_1, slider_2):\n    return slider_1 * 5 + slider_2\n\n\nwith gr.Blocks() as demo:\n    slider = gr.Slider(minimum=-10.2, maximum=15, label=\"Random Slider (Static)\", randomize=True)\n    slider_1 = gr.Slider(minimum=100, maximum=200, label=\"Random Slider (Input 1)\", randomize=True)\n    slider_2 = gr.Slider(minimum=10, maximum=23.2, label=\"Random Slider (Input 2)\", randomize=True)\n    slider_3 = gr.Slider(value=3, label=\"Non random slider\")\n    btn = gr.Button(\"Run\")\n    btn.click(func, inputs=[slider_1, slider_2], outputs=gr.Number())\n\nif __name__ == \"__main__\":\n    demo.launch()\n\n```\n3,\tState in Blocks\n\nWe covered [State in Interfaces](https://gradio.app/interface-state), this guide takes a look at state in Blocks, which works mostly the same.\n\n## Global State\n\nGlobal state in Blocks works the same as in Interface. Any variable created outside a function call is a reference shared between all users.\n\n## Session State\n\nGradio supports session **state**, where data persists across multiple submits within a page session, in Blocks apps as well. To reiterate, session data is _not_ shared between different users of your model. To store data in a session state, you need to do three things:\n\n1. Create a `gr.State()` object. If there is a default value to this stateful object, pass that into the constructor.\n2. In the event listener, put the `State` object as an input and output.\n3. In the event listener function, add the variable to the input parameters and the return value.\n\nLet's take a look at a game of hangman.\n\n$code_hangman\n$demo_hangman\n\nLet's see how we do each of the 3 steps listed above in this game:\n\n1. We store the used letters in `used_letters_var`. In the constructor of `State`, we set the initial value of this to `[]`, an empty list.\n2. In `btn.click()`, we have a reference to `used_letters_var` in both the inputs and outputs.\n3. In `guess_letter`, we pass the value of this `State` to `used_letters`, and then return an updated value of this `State` in the return statement.\n\nWith more complex apps, you will likely have many State variables storing session state in a single Blocks app.\n\nLearn more about `State` in the [docs](https://gradio.app/docs#state).\n    ```",
            "vector_context": "[Created at: 2025-03-24 13:16:48]\n\u4e0e\u5e38\u89c4\u51fd\u6570\u76f8\u540c\u7684\u65b9\u5f0f\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio\u3002\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\uff08\u865a\u62df\u7684\uff09\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5b83\u5728\u8f93\u51fa\u56fe\u50cf\u4e4b\u524d\u751f\u6210\u6570\u4e2a\u6b65\u9aa4\u7684\u566a\u97f3\uff1a\n\n$code_fake_diffusion\n$demo_fake_diffusion\n\n\u8bf7\u6ce8\u610f\uff0c\u6211\u4eec\u5728\u8fed\u4ee3\u5668\u4e2d\u6dfb\u52a0\u4e86 `time.sleep(1)`\uff0c\u4ee5\u521b\u5efa\u6b65\u9aa4\u4e4b\u95f4\u7684\u4eba\u5de5\u6682\u505c\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u89c2\u5bdf\u8fed\u4ee3\u5668\u7684\u6b65\u9aa4\uff08\u5728\u771f\u5b9e\u7684\u56fe\u50cf\u751f\u6210\u6a21\u578b\u4e2d\uff0c\u8fd9\u53ef\u80fd\u662f\u4e0d\u5fc5\u8981\u7684\uff09\u3002\n\n\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio **\u9700\u8981**\u5728\u5e95\u5c42 Interface \u6216 Blocks \u4e2d\u542f\u7528\u961f\u5217\uff08\u8bf7\u53c2\u9605\u4e0a\u9762\u7684\u961f\u5217\u90e8\u5206\uff09\u3002\n\n## \u8fdb\u5ea6\u6761\n\nGradio \u652f\u6301\u521b\u5efa\u81ea\u5b9a\u4e49\u8fdb\u5ea6\u6761\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u81ea\u5b9a\u4e49\u548c\u63a7\u5236\u5411\u7528\u6237\u663e\u793a\u7684\u8fdb\u5ea6\u66f4\u65b0\u3002\u8981\u542f\u7528\u6b64\u529f\u80fd\uff0c\u53ea\u9700\u4e3a\u65b9\u6cd5\u6dfb\u52a0\u4e00\u4e2a\u9ed8\u8ba4\u503c\u4e3a `gr.Progress` \u5b9e\u4f8b\u7684\u53c2\u6570\u5373\u53ef\u3002\u7136\u540e\uff0c\u60a8\u53ef\u4ee5\u76f4\u63a5\u8c03\u7528\u6b64\u5b9e\u4f8b\u5e76\u4f20\u5165 0 \u5230 1 \u4e4b\u95f4\u7684\u6d6e\u70b9\u6570\u6765\u66f4\u65b0\u8fdb\u5ea6\u7ea7\u522b\uff0c\u6216\u8005 with `Progress` \u5b9e\u4f8b\u7684 `tqdm()` \u65b9\u6cd5\u6765\u8ddf\u8e2a\u53ef\u8fed\u4ee3\u5bf9\u8c61\u4e0a\u7684\u8fdb\u5ea6\uff0c\u5982\u4e0b\u6240\u793a\u3002\u5fc5\u987b\u542f\u7528\u961f\u5217\u4ee5\u8fdb\u884c\u8fdb\u5ea6\u66f4\u65b0\u3002\n\n$code_progress_simple\n$demo_progress_simple\n\n\u5982\u679c\u60a8 with `tqdm` \u5e93\uff0c\u5e76\u4e14\u5e0c\u671b\u4ece\u51fd\u6570\u5185\u90e8\u7684\u4efb\u4f55 `tqdm.tqdm` \u81ea\u52a8\u62a5\u544a\u8fdb\u5ea6\u66f4\u65b0\uff0c\u8bf7\u5c06\u9ed8\u8ba4\u53c2\u6570\u8bbe\u7f6e\u4e3a `gr.Progress(track_tqdm=True)`\uff01\n\n## \u6279\u5904\u7406\u51fd\u6570 (Batch Functions)\n\nGradio \u652f\u6301\u4f20\u9012*\u6279\u5904\u7406*\u51fd\u6570\u3002\u6279\u5904\u7406\u51fd\u6570\u53ea\u662f\u63a5\u53d7\u8f93\u5165\u5217\u8868\u5e76\u8fd4\u56de\u9884\u6d4b\u5217\u8868\u7684\u51fd\u6570\u3002\n\n\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\u6279\u5904\u7406\u51fd\u6570\uff0c\u5b83\u63a5\u53d7\u4e24\u4e2a\u8f93\u5165\u5217\u8868\uff08\u4e00\u4e2a\u5355\u8bcd\u5217\u8868\u548c\u4e00\u4e2a\u6574\u6570\u5217\u8868\uff09\uff0c\u5e76\u8fd4\u56de\u4fee\u526a\u8fc7\u7684\u5355\u8bcd\u5217\u8868\u4f5c\u4e3a\u8f93\u51fa\uff1a\n\n```python\nimport time\n\ndef trim_words(words, lens):\n    trimmed_words = []\n    time.sleep(5)\n    for w, l in zip(words, lens):\n        trimmed_words.append(w[:int(l)])\n    return [trimmed_words]\n    for w, l in zip(words, lens):\n```\n\n\u4f7f\u7528\u6279\u5904\u7406\u51fd\u6570\u7684\u4f18\u70b9\u662f\uff0c\u5982\u679c\u542f\u7528\u4e86\u961f\u5217\uff0cGradio \u670d\u52a1\u5668\u53ef\u4ee5\u81ea\u52a8*\u6279\u5904\u7406*\u4f20\u5165\u7684\u8bf7\u6c42\u5e76\u5e76\u884c\u5904\u7406\u5b83\u4eec\uff0c\u4ece\u800c\u53ef\u80fd\u52a0\u5feb\u6f14\u793a\u901f\u5ea6\u3002\u4ee5\u4e0b\u662f Gradio \u4ee3\u7801\u7684\u793a\u4f8b\uff08\u8bf7\u6ce8\u610f `batch=True` \u548c `max_batch_size=16` - \u8fd9\u4e24\u4e2a\u53c2\u6570\u90fd\u53ef\u4ee5\u4f20\u9012\u7ed9\u4e8b\u4ef6\u89e6\u53d1\u5668\u6216 `Interface` \u7c7b\uff09\n\nwith `Interface`\uff1a\n\n```python\ndemo = gr.Interface(trim_words, [\"textbox\", \"number\"], [\"output\"],\n                    batch=True, max_batch_size=16)\ndemo.queue()\ndemo.launch()\n```\n\nwith `Blocks`\uff1a\n\n```python\nimport gradio as gr\n\nwith gr.Blocks() as demo:\n    with gr.Row():\n        word = gr.Textbox(label=\"word\")\n        leng = gr.Number(label=\"leng\")\n        output = gr.Textbox(label=\"Output\")\n    with gr.Row():\n        run = gr.Button()\n\n    event = run.click(trim_words, [word, leng], output, batch=True, max_batch_size=16)\n\ndemo.queue()\ndemo.launch()\n```\n\n\u5728\u4e0a\u9762\u7684\u793a\u4f8b\u4e2d\uff0c\u53ef\u4ee5\u5e76\u884c\u5904\u7406 16 \u4e2a\u8bf7\u6c42\uff08\u603b\u63a8\u7406\u65f6\u95f4\u4e3a 5 \u79d2\uff09\uff0c\u800c\u4e0d\u662f\u5206\u522b\u5904\u7406\u6bcf\u4e2a\u8bf7\u6c42\uff08\u603b\u63a8\u7406\u65f6\u95f4\u4e3a 80 \u79d2\uff09\u3002\u8bb8\u591a Hugging Face \u7684 `transformers` \u548c `diffusers` \u6a21\u578b\u5728 Gradio \u7684\u6279\u5904\u7406\u6a21\u5f0f\u4e0b\u81ea\u7136\u5de5\u4f5c\uff1a\u8fd9\u662f[\u4f7f\u7528\u6279\u5904\u7406\u751f\u6210\u56fe\u50cf\u7684\u793a\u4f8b\u6f14\u793a](https://github.com/gradio-app/gradio/blob/main/demo/diffusers_with_batching/run.py)\n\n\u6ce8\u610f\uff1a\u4f7f\u7528 Gradio \u7684\u6279\u5904\u7406\u51fd\u6570 **requires** \u5728\u5e95\u5c42 Interface \u6216 Blocks \u4e2d\u542f\u7528\u961f\u5217\uff08\u8bf7\u53c2\u9605\u4e0a\u9762\u7684\u961f\u5217\u90e8\u5206\uff09\u3002\n\n## Gradio \u7b14\u8bb0\u672c (Colab Notebooks)\n\nGradio \u53ef\u4ee5\u5728\u4efb\u4f55\u8fd0\u884c Python \u7684\u5730\u65b9\u8fd0\u884c\uff0c\u5305\u62ec\u672c\u5730 Jupyter \u7b14\u8bb0\u672c\u548c\u534f\u4f5c\u7b14\u8bb0\u672c\uff0c\u5982[Google Colab](https://colab.research.google.com/)\u3002\u5bf9\u4e8e\u672c\u5730 Jupyter \u7b14\u8bb0\u672c\u548c Google Colab \u7b14\u8bb0\u672c\uff0cGradio \u5728\u672c\u5730\u670d\u52a1\u5668\u4e0a\u8fd0\u884c\uff0c\u60a8\u53ef\u4ee5\u5728\u6d4f\u89c8\u5668\u4e2d\u4e0e\u4e4b\u4ea4\u4e92\u3002\uff08\u6ce8\u610f\uff1a\u5bf9\u4e8e Google Colab\uff0c\u8fd9\u662f\u901a\u8fc7[\u670d\u52a1\u5de5\u4f5c\u5668\u96a7\u9053](https://github.com/tensorflow/tensorboard/blob/master/docs/design/colab_integration.md)\u5b9e\u73b0\u7684\uff0c\u60a8\u7684\u6d4f\u89c8\u5668\u9700\u8981\u542f\u7528 cookies\u3002\uff09\u5bf9\u4e8e\u5176\u4ed6\u8fdc\u7a0b\u7b14\u8bb0\u672c\uff0cGradio \u4e5f\u5c06\u5728\u670d\u52a1\u5668\u4e0a\u8fd0\u884c\uff0c\u4f46\u60a8\u9700\u8981\u4f7f\u7528[SSH \u96a7\u9053](https://coderwall.com/p/ohk6cg/remote-access-to-ipython-notebooks-via-ssh)\u5728\u672c\u5730\u6d4f\u89c8\u5668\u4e2d\u67e5\u770b\u5e94\u7528\u7a0b\u5e8f\u3002\u901a\u5e38\uff0c\u66f4\u7b80\u5355\u7684\u9009\u62e9\u662f\u4f7f\u7528 Gradio \u5185\u7f6e\u7684\u516c\u5171\u94fe\u63a5\uff0c[\u5728\u4e0b\u4e00\u7bc7\u6307\u5357\u4e2d\u8ba8\u8bba](/sharing-your-app/#sharing-demos)\u3002\n--New Chunk--\n[Created at: 2025-03-24 13:19:57]\nState in Blocks\n\nWe covered [State in Interfaces](https://gradio.app/interface-state), this guide takes a look at state in Blocks, which works mostly the same.\n\n## Global State\n\nGlobal state in Blocks works the same as in Interface. Any variable created outside a function call is a reference shared between all users.\n\n## Session State\n\nGradio supports session **state**, where data persists across multiple submits within a page session, in Blocks apps as well. To reiterate, session data is _not_ shared between different users of your model. To store data in a session state, you need to do three things:\n\n1. Create a `gr.State()` object. If there is a default value to this stateful object, pass that into the constructor.\n2. In the event listener, put the `State` object as an input and output.\n3. In the event listener function, add the variable to the input parameters and the return value.\n\nLet's take a look at a game of hangman.\n\n$code_hangman\n$demo_hangman\n\nLet's see how we do each of the 3 steps listed above in this game:\n\n1. We store the used letters in `used_letters_var`. In the constructor of `State`, we set the initial value of this to `[]`, an empty list.\n2. In `btn.click()`, we have a reference to `used_letters_var` in both the inputs and outputs.\n3. In `guess_letter`, we pass the value of this `State` to `used_letters`, and then return an updated value of this `State` in the return statement.\n\nWith more complex apps, you will likely have many State variables storing session state in a single Blocks app.\n\nLearn more about `State` in the [docs](https://gradio.app/docs#state).\n--New Chunk--\n[Created at: 2025-03-24 13:16:48]\n\u4e3b\u8981\u7279\u70b9\n\n\u8ba9\u6211\u4eec\u6765\u4ecb\u7ecd\u4e00\u4e0b Gradio \u6700\u53d7\u6b22\u8fce\u7684\u4e00\u4e9b\u529f\u80fd\uff01\u8fd9\u91cc\u662f Gradio \u7684\u4e3b\u8981\u7279\u70b9\uff1a\n\n1. [\u6dfb\u52a0\u793a\u4f8b\u8f93\u5165](#example-inputs)\n2. [\u4f20\u9012\u81ea\u5b9a\u4e49\u9519\u8bef\u6d88\u606f](#errors)\n3. [\u6dfb\u52a0\u63cf\u8ff0\u5185\u5bb9](#descriptive-content)\n4. [\u8bbe\u7f6e\u65d7\u6807](#flagging)\n5. [\u9884\u5904\u7406\u548c\u540e\u5904\u7406](#preprocessing-and-postprocessing)\n6. [\u6837\u5f0f\u5316\u6f14\u793a](#styling)\n7. [\u6392\u961f\u7528\u6237](#queuing)\n8. [\u8fed\u4ee3\u8f93\u51fa](#iterative-outputs)\n9. [\u8fdb\u5ea6\u6761](#progress-bars)\n10. [\u6279\u5904\u7406\u51fd\u6570](#batch-functions)\n11. [\u5728\u534f\u4f5c\u7b14\u8bb0\u672c\u4e0a\u8fd0\u884c](#colab-notebooks)\n\n## \u793a\u4f8b\u8f93\u5165\n\n\u60a8\u53ef\u4ee5\u63d0\u4f9b\u7528\u6237\u53ef\u4ee5\u8f7b\u677e\u52a0\u8f7d\u5230 \"Interface\" \u4e2d\u7684\u793a\u4f8b\u6570\u636e\u3002\u8fd9\u5bf9\u4e8e\u6f14\u793a\u6a21\u578b\u671f\u671b\u7684\u8f93\u5165\u7c7b\u578b\u4ee5\u53ca\u6f14\u793a\u6570\u636e\u96c6\u548c\u6a21\u578b\u4e00\u8d77\u63a2\u7d22\u7684\u65b9\u5f0f\u975e\u5e38\u6709\u5e2e\u52a9\u3002\u8981\u52a0\u8f7d\u793a\u4f8b\u6570\u636e\uff0c\u60a8\u53ef\u4ee5\u5c06\u5d4c\u5957\u5217\u8868\u63d0\u4f9b\u7ed9 Interface \u6784\u9020\u51fd\u6570\u7684 `examples=` \u5173\u952e\u5b57\u53c2\u6570\u3002\u5916\u90e8\u5217\u8868\u4e2d\u7684\u6bcf\u4e2a\u5b50\u5217\u8868\u8868\u793a\u4e00\u4e2a\u6570\u636e\u6837\u672c\uff0c\u5b50\u5217\u8868\u4e2d\u7684\u6bcf\u4e2a\u5143\u7d20\u8868\u793a\u6bcf\u4e2a\u8f93\u5165\u7ec4\u4ef6\u7684\u8f93\u5165\u3002\u6709\u5173\u6bcf\u4e2a\u7ec4\u4ef6\u7684\u793a\u4f8b\u6570\u636e\u683c\u5f0f\u5728[Docs](https://gradio.app/docs#components)\u4e2d\u6709\u8bf4\u660e\u3002\n\n$code_calculator\n$demo_calculator\n\n\u60a8\u53ef\u4ee5\u5c06\u5927\u578b\u6570\u636e\u96c6\u52a0\u8f7d\u5230\u793a\u4f8b\u4e2d\uff0c\u901a\u8fc7 Gradio \u6d4f\u89c8\u548c\u4e0e\u6570\u636e\u96c6\u8fdb\u884c\u4ea4\u4e92\u3002\u793a\u4f8b\u5c06\u81ea\u52a8\u5206\u9875\uff08\u53ef\u4ee5\u901a\u8fc7 Interface \u7684 `examples_per_page` \u53c2\u6570\u8fdb\u884c\u914d\u7f6e\uff09\u3002\n\n\u7ee7\u7eed\u4e86\u89e3\u793a\u4f8b\uff0c\u8bf7\u53c2\u9605[\u66f4\u591a\u793a\u4f8b](https://gradio.app/more-on-examples)\u6307\u5357\u3002\n\n## \u9519\u8bef\n\n\u60a8\u5e0c\u671b\u5411\u7528\u6237\u4f20\u9012\u81ea\u5b9a\u4e49\u9519\u8bef\u6d88\u606f\u3002\u4e3a\u6b64\uff0cwith `gr.Error(\"custom message\")` \u6765\u663e\u793a\u9519\u8bef\u6d88\u606f\u3002\u5982\u679c\u5728\u4e0a\u9762\u7684\u8ba1\u7b97\u5668\u793a\u4f8b\u4e2d\u5c1d\u8bd5\u9664\u4ee5\u96f6\uff0c\u5c06\u663e\u793a\u81ea\u5b9a\u4e49\u9519\u8bef\u6d88\u606f\u7684\u5f39\u51fa\u6a21\u6001\u7a97\u53e3\u3002\u4e86\u89e3\u6709\u5173\u9519\u8bef\u7684\u66f4\u591a\u4fe1\u606f\uff0c\u8bf7\u53c2\u9605[\u6587\u6863](https://gradio.app/docs#error)\u3002\n\n## \u63cf\u8ff0\u6027\u5185\u5bb9\n\n\u5728\u524d\u9762\u7684\u793a\u4f8b\u4e2d\uff0c\u60a8\u53ef\u80fd\u5df2\u7ecf\u6ce8\u610f\u5230 Interface \u6784\u9020\u51fd\u6570\u4e2d\u7684 `title=` \u548c `description=` \u5173\u952e\u5b57\u53c2\u6570\uff0c\u5e2e\u52a9\u7528\u6237\u4e86\u89e3\u60a8\u7684\u5e94\u7528\u7a0b\u5e8f\u3002\n\nInterface \u6784\u9020\u51fd\u6570\u4e2d\u6709\u4e09\u4e2a\u53c2\u6570\u7528\u4e8e\u6307\u5b9a\u6b64\u5185\u5bb9\u5e94\u653e\u7f6e\u5728\u54ea\u91cc\uff1a\n\n- `title`\uff1a\u63a5\u53d7\u6587\u672c\uff0c\u5e76\u53ef\u4ee5\u5c06\u5176\u663e\u793a\u5728\u754c\u9762\u7684\u9876\u90e8\uff0c\u4e5f\u5c06\u6210\u4e3a\u9875\u9762\u6807\u9898\u3002\n- `description`\uff1a\u63a5\u53d7\u6587\u672c\u3001Markdown \u6216 HTML\uff0c\u5e76\u5c06\u5176\u653e\u7f6e\u5728\u6807\u9898\u6b63\u4e0b\u65b9\u3002\n- `article`\uff1a\u4e5f\u63a5\u53d7\u6587\u672c\u3001Markdown \u6216 HTML\uff0c\u5e76\u5c06\u5176\u653e\u7f6e\u5728\u754c\u9762\u4e0b\u65b9\u3002\n\n![annotated](/assets/guides/annotated.png)\n\n\u5982\u679c\u60a8\u4f7f\u7528\u7684\u662f `Blocks` API\uff0c\u5219\u53ef\u4ee5 with `gr.Markdown(...)` \u6216 `gr.HTML(...)` \u7ec4\u4ef6\u5728\u4efb\u4f55\u4f4d\u7f6e\u63d2\u5165\u6587\u672c\u3001Markdown \u6216 HTML\uff0c\u5176\u4e2d\u63cf\u8ff0\u6027\u5185\u5bb9\u4f4d\u4e8e `Component` \u6784\u9020\u51fd\u6570\u5185\u90e8\u3002\n\n\u53e6\u4e00\u4e2a\u6709\u7528\u7684\u5173\u952e\u5b57\u53c2\u6570\u662f `label=`\uff0c\u5b83\u5b58\u5728\u4e8e\u6bcf\u4e2a `Component` \u4e2d\u3002\u8fd9\u4fee\u6539\u4e86\u6bcf\u4e2a `Component` \u9876\u90e8\u7684\u6807\u7b7e\u6587\u672c\u3002\u8fd8\u53ef\u4ee5\u4e3a\u8bf8\u5982 `Textbox` \u6216 `Radio` \u4e4b\u7c7b\u7684\u8868\u5355\u5143\u7d20\u6dfb\u52a0 `info=` \u5173\u952e\u5b57\u53c2\u6570\uff0c\u4ee5\u63d0\u4f9b\u6709\u5173\u5176\u7528\u6cd5\u7684\u8fdb\u4e00\u6b65\u4fe1\u606f\u3002\n\n```python\ngr.Number(label='\u5e74\u9f84', info='\u4ee5\u5e74\u4e3a\u5355\u4f4d\uff0c\u5fc5\u987b\u5927\u4e8e0')\n```\n\n## \u65d7\u6807\n\n\u9ed8\u8ba4\u60c5\u51b5\u4e0b\uff0c\"Interface\" \u5c06\u6709\u4e00\u4e2a \"Flag\" \u6309\u94ae\u3002\u5f53\u7528\u6237\u6d4b\u8bd5\u60a8\u7684 `Interface` \u65f6\uff0c\u5982\u679c\u770b\u5230\u6709\u8da3\u7684\u8f93\u51fa\uff0c\u4f8b\u5982\u9519\u8bef\u6216\u610f\u5916\u7684\u6a21\u578b\u884c\u4e3a\uff0c\u4ed6\u4eec\u53ef\u4ee5\u5c06\u8f93\u5165\u6807\u8bb0\u4e3a\u60a8\u8fdb\u884c\u67e5\u770b\u3002\u5728\u7531 `Interface` \u6784\u9020\u51fd\u6570\u7684 `flagging_dir=` \u53c2\u6570\u63d0\u4f9b\u7684\u76ee\u5f55\u4e2d\uff0c\u5c06\u8bb0\u5f55\u6807\u8bb0\u7684\u8f93\u5165\u5230\u4e00\u4e2a CSV \u6587\u4ef6\u4e2d\u3002\u5982\u679c\u754c\u9762\u6d89\u53ca\u6587\u4ef6\u6570\u636e\uff0c\u4f8b\u5982\u56fe\u50cf\u548c\u97f3\u9891\u7ec4\u4ef6\uff0c\u5c06\u521b\u5efa\u6587\u4ef6\u5939\u6765\u5b58\u50a8\u8fd9\u4e9b\u6807\u8bb0\u7684\u6570\u636e\u3002\n\n\u4f8b\u5982\uff0c\u5bf9\u4e8e\u4e0a\u9762\u663e\u793a\u7684\u8ba1\u7b97\u5668\u754c\u9762\uff0c\u6211\u4eec\u5c06\u5728\u4e0b\u9762\u7684\u65d7\u6807\u76ee\u5f55\u4e2d\u5b58\u50a8\u6807\u8bb0\u7684\u6570\u636e\uff1a\n\n```directory\n+-- calculator.py\n+-- flagged/\n|   +-- logs.csv\n```\n\n_flagged/logs.csv_\n\n```csv\nnum1,operation,num2,Output\n5,add,7,12\n6,subtract,1.5,4.5\n```\n\n\u4e0e\u65e9\u671f\u663e\u793a\u7684\u51b7\u8272\u754c\u9762\u76f8\u5bf9\u5e94\uff0c\u6211\u4eec\u5c06\u5728\u4e0b\u9762\u7684\u65d7\u6807\u76ee\u5f55\u4e2d\u5b58\u50a8\u6807\u8bb0\u7684\u6570\u636e\uff1a\n\n```directory\n+-- sepia.py\n+-- flagged/\n|   +-- logs.csv\n|   +-- im/\n|   |   +-- 0.png\n|   |   +-- 1.png\n|   +-- Output/\n|   |   +-- 0.png\n|   |   +-- 1.png\n```\n\n_flagged/logs.csv_\n\n```csv\nim,Output\nim/0.png,Output/0.png\nim/1.png,Output/1.png\n```\n\n\u5982\u679c\u60a8\u5e0c\u671b\u7528\u6237\u63d0\u4f9b\u65d7\u6807\u539f\u56e0\uff0c\u53ef\u4ee5\u5c06\u5b57\u7b26\u4e32\u5217\u8868\u4f20\u9012\u7ed9 Interface \u7684 `flagging_options` \u53c2\u6570\u3002\u7528\u6237\u5728\u8fdb\u884c\u65d7\u6807\u65f6\u5fc5\u987b\u9009\u62e9\u5176\u4e2d\u4e00\u4e2a\u5b57\u7b26\u4e32\uff0c\u8fd9\u5c06\u4f5c\u4e3a\u9644\u52a0\u5217\u4fdd\u5b58\u5230 CSV \u4e2d\u3002\n\n## \u9884\u5904\u7406\u548c\u540e\u5904\u7406 (Preprocessing and Postprocessing)\n\n![annotated](/assets/img/dataflow.svg)\n\n\u5982\u60a8\u6240\u89c1\uff0cGradio \u5305\u62ec\u53ef\u4ee5\u5904\u7406\u5404\u79cd\u4e0d\u540c\u6570\u636e\u7c7b\u578b\u7684\u7ec4\u4ef6\uff0c\u4f8b\u5982\u56fe\u50cf\u3001\u97f3\u9891\u548c\u89c6\u9891\u3002\u5927\u591a\u6570\u7ec4\u4ef6\u90fd\u53ef\u4ee5\u7528\u4f5c\u8f93\u5165\u6216\u8f93\u51fa\u3002\n\n\u5f53\u7ec4\u4ef6\u7528\u4f5c\u8f93\u5165\u65f6\uff0cGradio \u81ea\u52a8\u5904\u7406*\u9884\u5904\u7406*\uff0c\u5c06\u6570\u636e\u4ece\u7528\u6237"
        }
    },
    {
        "sample_idx": 28,
        "question": "What is a batch function in Gradio?",
        "answer": "A function that accepts input lists and returns prediction lists.",
        "rag_answer": "In Gradio, a batch function is a function that accepts a list of inputs and returns a list of outputs. It is a special type of function that allows Gradio to process multiple inputs at once, which can be useful for improving the performance and efficiency of your application.\n\nA batch function is typically used when you want to process a large number of inputs simultaneously, such as when you need to make predictions on a batch of data or perform some other type of computation on a large dataset.\n\nHere is an example of a batch function in Gradio:\n\n```\ndef trim_words(words, lens):\n    trimmed_words = []\n    for w, l in zip(words, lens):\n        trimmed_words.append(w[:int(l)])\n    return [trimmed_words]\n```\n\nIn this example, the `trim_words` function takes two lists as input: `words` and `lens`. It then processes each pair of inputs in parallel, trimming each word to the specified length, and returns a list of trimmed words.\n\nTo use a batch function in Gradio, you need to specify the `batch=True` parameter when creating the interface or blocks. You can also specify the `max_batch_size` parameter to control the maximum number of inputs that are processed in parallel.\n\nFor example:\n\n```\ndemo = gr.Interface(trim_words, [\"textbox\", \"number\"], [\"output\"], batch=True, max_batch_size=16)\ndemo.queue()\ndemo.launch()\n```\n\nIn this example, the `trim_words` function is called with a batch of up to 16 inputs at a time, and the results are processed in parallel.\n\nBatch functions are a powerful feature in Gradio that can help you build more efficient and scalable applications. However, they do require some careful consideration of how to design and implement the function to take advantage of batch processing.\n\nReferences:\n\n* [KG] Gradio documentation: Batch Functions\n* [DC] Gradio tutorial: Batch Processing with Gradio",
        "rag_score": null,
        "rag_feedback": null,
        "rag_context": {
            "kg_context": "-----Entities-----\n    ```csv\n    id,\tentity,\ttype,\tdescription,\trankcreated_at\n1,\tGradio,organization,Gradio is a platform that supports state in Blocks, providing features such as global state and session state.<SEP>Gradio is an interface that provides various features for demonstrating models, including adding example inputs, custom error messages, descriptive content, flagging, and more.<SEP>Gradio is an organization that provides a platform for building and deploying machine learning models.<SEP>Gradio is an organization that provides a platform for creating and deploying machine learning models.<SEP>Gradio is an organization that provides a demo for blocks_random_slider, and its library is used to create interactive interfaces.,36,2025-03-24 13:17:31\n2,\tState,category,State is a concept in Gradio that refers to the storage of data, including global state and session state.,2,2025-03-24 13:17:31\n3,\tgr,organization,gr is an organization that provides the Gradio library used in the demo.,1,2025-03-24 13:17:31\n4,\tExample Inputs,category,Example Inputs are a feature in Gradio that allows users to load sample data into an interface.,1,2025-03-24 13:17:31\n5,\tBatch Functions,category,Batch Functions is a category of functions in Gradio that enables the processing of batches of inputs.,1,UNKNOWN\n6,\tqueue,category,Queue is a component in Gradio that enables the processing of batches of inputs.,1,UNKNOWN\n7,\tPreprocessing and Postprocessing,category,Preprocessing and Postprocessing are features in Gradio that allow users to process data before and after it is input into a model.,1,UNKNOWN\n    ```\n    -----Relationships-----\n    ```csv\n    id,\tsource,\ttarget,\tdescription,\tkeywords,\tweight,\trank,\tcreated_at\n1,\tGradio,State,Gradio supports state in Blocks, including global state and session state.,platform feature, data storage,18.0,38,2025-03-24 13:20:24\n2,\tGradio,gr,gr is the organization that provides the Gradio library used in the demo.,organization, organization,9.0,37,2025-03-24 13:18:47\n3,\tExample Inputs,Gradio,Gradio allows users to add example inputs to an interface.,example inputs, interface feature,8.0,37,2025-03-24 13:17:31\n4,\tBatch Functions,Gradio,Gradio supports batch processing of inputs using batch functions.,functionality, batch processing,18.0,37,UNKNOWN\n5,\tGradio,queue,Queue is a component in Gradio that enables batch processing.,component relationship, batch processing,8.0,37,UNKNOWN\n6,\tGradio,Preprocessing and Postprocessing,Gradio provides features for preprocessing and postprocessing data.,data processing, interface feature,8.0,37,UNKNOWN\n    ```\n    -----Sources-----\n    ```csv\n    id,\tcontent\n1,\tState in Blocks\n\nWe covered [State in Interfaces](https://gradio.app/interface-state), this guide takes a look at state in Blocks, which works mostly the same.\n\n## Global State\n\nGlobal state in Blocks works the same as in Interface. Any variable created outside a function call is a reference shared between all users.\n\n## Session State\n\nGradio supports session **state**, where data persists across multiple submits within a page session, in Blocks apps as well. To reiterate, session data is _not_ shared between different users of your model. To store data in a session state, you need to do three things:\n\n1. Create a `gr.State()` object. If there is a default value to this stateful object, pass that into the constructor.\n2. In the event listener, put the `State` object as an input and output.\n3. In the event listener function, add the variable to the input parameters and the return value.\n\nLet's take a look at a game of hangman.\n\n$code_hangman\n$demo_hangman\n\nLet's see how we do each of the 3 steps listed above in this game:\n\n1. We store the used letters in `used_letters_var`. In the constructor of `State`, we set the initial value of this to `[]`, an empty list.\n2. In `btn.click()`, we have a reference to `used_letters_var` in both the inputs and outputs.\n3. In `guess_letter`, we pass the value of this `State` to `used_letters`, and then return an updated value of this `State` in the return statement.\n\nWith more complex apps, you will likely have many State variables storing session state in a single Blocks app.\n\nLearn more about `State` in the [docs](https://gradio.app/docs#state).\n2,\tGradio Demo: blocks_random_slider\n\n\n```\n!pip install -q gradio \n```\n\n\n```\n\nimport gradio as gr\n\n\ndef func(slider_1, slider_2):\n    return slider_1 * 5 + slider_2\n\n\nwith gr.Blocks() as demo:\n    slider = gr.Slider(minimum=-10.2, maximum=15, label=\"Random Slider (Static)\", randomize=True)\n    slider_1 = gr.Slider(minimum=100, maximum=200, label=\"Random Slider (Input 1)\", randomize=True)\n    slider_2 = gr.Slider(minimum=10, maximum=23.2, label=\"Random Slider (Input 2)\", randomize=True)\n    slider_3 = gr.Slider(value=3, label=\"Non random slider\")\n    btn = gr.Button(\"Run\")\n    btn.click(func, inputs=[slider_1, slider_2], outputs=gr.Number())\n\nif __name__ == \"__main__\":\n    demo.launch()\n\n```\n3,\t\u4e3b\u8981\u7279\u70b9\n\n\u8ba9\u6211\u4eec\u6765\u4ecb\u7ecd\u4e00\u4e0b Gradio \u6700\u53d7\u6b22\u8fce\u7684\u4e00\u4e9b\u529f\u80fd\uff01\u8fd9\u91cc\u662f Gradio \u7684\u4e3b\u8981\u7279\u70b9\uff1a\n\n1. [\u6dfb\u52a0\u793a\u4f8b\u8f93\u5165](#example-inputs)\n2. [\u4f20\u9012\u81ea\u5b9a\u4e49\u9519\u8bef\u6d88\u606f](#errors)\n3. [\u6dfb\u52a0\u63cf\u8ff0\u5185\u5bb9](#descriptive-content)\n4. [\u8bbe\u7f6e\u65d7\u6807](#flagging)\n5. [\u9884\u5904\u7406\u548c\u540e\u5904\u7406](#preprocessing-and-postprocessing)\n6. [\u6837\u5f0f\u5316\u6f14\u793a](#styling)\n7. [\u6392\u961f\u7528\u6237](#queuing)\n8. [\u8fed\u4ee3\u8f93\u51fa](#iterative-outputs)\n9. [\u8fdb\u5ea6\u6761](#progress-bars)\n10. [\u6279\u5904\u7406\u51fd\u6570](#batch-functions)\n11. [\u5728\u534f\u4f5c\u7b14\u8bb0\u672c\u4e0a\u8fd0\u884c](#colab-notebooks)\n\n## \u793a\u4f8b\u8f93\u5165\n\n\u60a8\u53ef\u4ee5\u63d0\u4f9b\u7528\u6237\u53ef\u4ee5\u8f7b\u677e\u52a0\u8f7d\u5230 \"Interface\" \u4e2d\u7684\u793a\u4f8b\u6570\u636e\u3002\u8fd9\u5bf9\u4e8e\u6f14\u793a\u6a21\u578b\u671f\u671b\u7684\u8f93\u5165\u7c7b\u578b\u4ee5\u53ca\u6f14\u793a\u6570\u636e\u96c6\u548c\u6a21\u578b\u4e00\u8d77\u63a2\u7d22\u7684\u65b9\u5f0f\u975e\u5e38\u6709\u5e2e\u52a9\u3002\u8981\u52a0\u8f7d\u793a\u4f8b\u6570\u636e\uff0c\u60a8\u53ef\u4ee5\u5c06\u5d4c\u5957\u5217\u8868\u63d0\u4f9b\u7ed9 Interface \u6784\u9020\u51fd\u6570\u7684 `examples=` \u5173\u952e\u5b57\u53c2\u6570\u3002\u5916\u90e8\u5217\u8868\u4e2d\u7684\u6bcf\u4e2a\u5b50\u5217\u8868\u8868\u793a\u4e00\u4e2a\u6570\u636e\u6837\u672c\uff0c\u5b50\u5217\u8868\u4e2d\u7684\u6bcf\u4e2a\u5143\u7d20\u8868\u793a\u6bcf\u4e2a\u8f93\u5165\u7ec4\u4ef6\u7684\u8f93\u5165\u3002\u6709\u5173\u6bcf\u4e2a\u7ec4\u4ef6\u7684\u793a\u4f8b\u6570\u636e\u683c\u5f0f\u5728[Docs](https://gradio.app/docs#components)\u4e2d\u6709\u8bf4\u660e\u3002\n\n$code_calculator\n$demo_calculator\n\n\u60a8\u53ef\u4ee5\u5c06\u5927\u578b\u6570\u636e\u96c6\u52a0\u8f7d\u5230\u793a\u4f8b\u4e2d\uff0c\u901a\u8fc7 Gradio \u6d4f\u89c8\u548c\u4e0e\u6570\u636e\u96c6\u8fdb\u884c\u4ea4\u4e92\u3002\u793a\u4f8b\u5c06\u81ea\u52a8\u5206\u9875\uff08\u53ef\u4ee5\u901a\u8fc7 Interface \u7684 `examples_per_page` \u53c2\u6570\u8fdb\u884c\u914d\u7f6e\uff09\u3002\n\n\u7ee7\u7eed\u4e86\u89e3\u793a\u4f8b\uff0c\u8bf7\u53c2\u9605[\u66f4\u591a\u793a\u4f8b](https://gradio.app/more-on-examples)\u6307\u5357\u3002\n\n## \u9519\u8bef\n\n\u60a8\u5e0c\u671b\u5411\u7528\u6237\u4f20\u9012\u81ea\u5b9a\u4e49\u9519\u8bef\u6d88\u606f\u3002\u4e3a\u6b64\uff0cwith `gr.Error(\"custom message\")` \u6765\u663e\u793a\u9519\u8bef\u6d88\u606f\u3002\u5982\u679c\u5728\u4e0a\u9762\u7684\u8ba1\u7b97\u5668\u793a\u4f8b\u4e2d\u5c1d\u8bd5\u9664\u4ee5\u96f6\uff0c\u5c06\u663e\u793a\u81ea\u5b9a\u4e49\u9519\u8bef\u6d88\u606f\u7684\u5f39\u51fa\u6a21\u6001\u7a97\u53e3\u3002\u4e86\u89e3\u6709\u5173\u9519\u8bef\u7684\u66f4\u591a\u4fe1\u606f\uff0c\u8bf7\u53c2\u9605[\u6587\u6863](https://gradio.app/docs#error)\u3002\n\n## \u63cf\u8ff0\u6027\u5185\u5bb9\n\n\u5728\u524d\u9762\u7684\u793a\u4f8b\u4e2d\uff0c\u60a8\u53ef\u80fd\u5df2\u7ecf\u6ce8\u610f\u5230 Interface \u6784\u9020\u51fd\u6570\u4e2d\u7684 `title=` \u548c `description=` \u5173\u952e\u5b57\u53c2\u6570\uff0c\u5e2e\u52a9\u7528\u6237\u4e86\u89e3\u60a8\u7684\u5e94\u7528\u7a0b\u5e8f\u3002\n\nInterface \u6784\u9020\u51fd\u6570\u4e2d\u6709\u4e09\u4e2a\u53c2\u6570\u7528\u4e8e\u6307\u5b9a\u6b64\u5185\u5bb9\u5e94\u653e\u7f6e\u5728\u54ea\u91cc\uff1a\n\n- `title`\uff1a\u63a5\u53d7\u6587\u672c\uff0c\u5e76\u53ef\u4ee5\u5c06\u5176\u663e\u793a\u5728\u754c\u9762\u7684\u9876\u90e8\uff0c\u4e5f\u5c06\u6210\u4e3a\u9875\u9762\u6807\u9898\u3002\n- `description`\uff1a\u63a5\u53d7\u6587\u672c\u3001Markdown \u6216 HTML\uff0c\u5e76\u5c06\u5176\u653e\u7f6e\u5728\u6807\u9898\u6b63\u4e0b\u65b9\u3002\n- `article`\uff1a\u4e5f\u63a5\u53d7\u6587\u672c\u3001Markdown \u6216 HTML\uff0c\u5e76\u5c06\u5176\u653e\u7f6e\u5728\u754c\u9762\u4e0b\u65b9\u3002\n\n![annotated](/assets/guides/annotated.png)\n\n\u5982\u679c\u60a8\u4f7f\u7528\u7684\u662f `Blocks` API\uff0c\u5219\u53ef\u4ee5 with `gr.Markdown(...)` \u6216 `gr.HTML(...)` \u7ec4\u4ef6\u5728\u4efb\u4f55\u4f4d\u7f6e\u63d2\u5165\u6587\u672c\u3001Markdown \u6216 HTML\uff0c\u5176\u4e2d\u63cf\u8ff0\u6027\u5185\u5bb9\u4f4d\u4e8e `Component` \u6784\u9020\u51fd\u6570\u5185\u90e8\u3002\n\n\u53e6\u4e00\u4e2a\u6709\u7528\u7684\u5173\u952e\u5b57\u53c2\u6570\u662f `label=`\uff0c\u5b83\u5b58\u5728\u4e8e\u6bcf\u4e2a `Component` \u4e2d\u3002\u8fd9\u4fee\u6539\u4e86\u6bcf\u4e2a `Component` \u9876\u90e8\u7684\u6807\u7b7e\u6587\u672c\u3002\u8fd8\u53ef\u4ee5\u4e3a\u8bf8\u5982 `Textbox` \u6216 `Radio` \u4e4b\u7c7b\u7684\u8868\u5355\u5143\u7d20\u6dfb\u52a0 `info=` \u5173\u952e\u5b57\u53c2\u6570\uff0c\u4ee5\u63d0\u4f9b\u6709\u5173\u5176\u7528\u6cd5\u7684\u8fdb\u4e00\u6b65\u4fe1\u606f\u3002\n\n```python\ngr.Number(label='\u5e74\u9f84', info='\u4ee5\u5e74\u4e3a\u5355\u4f4d\uff0c\u5fc5\u987b\u5927\u4e8e0')\n```\n\n## \u65d7\u6807\n\n\u9ed8\u8ba4\u60c5\u51b5\u4e0b\uff0c\"Interface\" \u5c06\u6709\u4e00\u4e2a \"Flag\" \u6309\u94ae\u3002\u5f53\u7528\u6237\u6d4b\u8bd5\u60a8\u7684 `Interface` \u65f6\uff0c\u5982\u679c\u770b\u5230\u6709\u8da3\u7684\u8f93\u51fa\uff0c\u4f8b\u5982\u9519\u8bef\u6216\u610f\u5916\u7684\u6a21\u578b\u884c\u4e3a\uff0c\u4ed6\u4eec\u53ef\u4ee5\u5c06\u8f93\u5165\u6807\u8bb0\u4e3a\u60a8\u8fdb\u884c\u67e5\u770b\u3002\u5728\u7531 `Interface` \u6784\u9020\u51fd\u6570\u7684 `flagging_dir=` \u53c2\u6570\u63d0\u4f9b\u7684\u76ee\u5f55\u4e2d\uff0c\u5c06\u8bb0\u5f55\u6807\u8bb0\u7684\u8f93\u5165\u5230\u4e00\u4e2a CSV \u6587\u4ef6\u4e2d\u3002\u5982\u679c\u754c\u9762\u6d89\u53ca\u6587\u4ef6\u6570\u636e\uff0c\u4f8b\u5982\u56fe\u50cf\u548c\u97f3\u9891\u7ec4\u4ef6\uff0c\u5c06\u521b\u5efa\u6587\u4ef6\u5939\u6765\u5b58\u50a8\u8fd9\u4e9b\u6807\u8bb0\u7684\u6570\u636e\u3002\n\n\u4f8b\u5982\uff0c\u5bf9\u4e8e\u4e0a\u9762\u663e\u793a\u7684\u8ba1\u7b97\u5668\u754c\u9762\uff0c\u6211\u4eec\u5c06\u5728\u4e0b\u9762\u7684\u65d7\u6807\u76ee\u5f55\u4e2d\u5b58\u50a8\u6807\u8bb0\u7684\u6570\u636e\uff1a\n\n```directory\n+-- calculator.py\n+-- flagged/\n|   +-- logs.csv\n```\n\n_flagged/logs.csv_\n\n```csv\nnum1,operation,num2,Output\n5,add,7,12\n6,subtract,1.5,4.5\n```\n\n\u4e0e\u65e9\u671f\u663e\u793a\u7684\u51b7\u8272\u754c\u9762\u76f8\u5bf9\u5e94\uff0c\u6211\u4eec\u5c06\u5728\u4e0b\u9762\u7684\u65d7\u6807\u76ee\u5f55\u4e2d\u5b58\u50a8\u6807\u8bb0\u7684\u6570\u636e\uff1a\n\n```directory\n+-- sepia.py\n+-- flagged/\n|   +-- logs.csv\n|   +-- im/\n|   |   +-- 0.png\n|   |   +-- 1.png\n|   +-- Output/\n|   |   +-- 0.png\n|   |   +-- 1.png\n```\n\n_flagged/logs.csv_\n\n```csv\nim,Output\nim/0.png,Output/0.png\nim/1.png,Output/1.png\n```\n\n\u5982\u679c\u60a8\u5e0c\u671b\u7528\u6237\u63d0\u4f9b\u65d7\u6807\u539f\u56e0\uff0c\u53ef\u4ee5\u5c06\u5b57\u7b26\u4e32\u5217\u8868\u4f20\u9012\u7ed9 Interface \u7684 `flagging_options` \u53c2\u6570\u3002\u7528\u6237\u5728\u8fdb\u884c\u65d7\u6807\u65f6\u5fc5\u987b\u9009\u62e9\u5176\u4e2d\u4e00\u4e2a\u5b57\u7b26\u4e32\uff0c\u8fd9\u5c06\u4f5c\u4e3a\u9644\u52a0\u5217\u4fdd\u5b58\u5230 CSV \u4e2d\u3002\n\n## \u9884\u5904\u7406\u548c\u540e\u5904\u7406 (Preprocessing and Postprocessing)\n\n![annotated](/assets/img/dataflow.svg)\n\n\u5982\u60a8\u6240\u89c1\uff0cGradio \u5305\u62ec\u53ef\u4ee5\u5904\u7406\u5404\u79cd\u4e0d\u540c\u6570\u636e\u7c7b\u578b\u7684\u7ec4\u4ef6\uff0c\u4f8b\u5982\u56fe\u50cf\u3001\u97f3\u9891\u548c\u89c6\u9891\u3002\u5927\u591a\u6570\u7ec4\u4ef6\u90fd\u53ef\u4ee5\u7528\u4f5c\u8f93\u5165\u6216\u8f93\u51fa\u3002\n\n\u5f53\u7ec4\u4ef6\u7528\u4f5c\u8f93\u5165\u65f6\uff0cGradio \u81ea\u52a8\u5904\u7406*\u9884\u5904\u7406*\uff0c\u5c06\u6570\u636e\u4ece\u7528\u6237\n4,\t\u4e0e\u5e38\u89c4\u51fd\u6570\u76f8\u540c\u7684\u65b9\u5f0f\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio\u3002\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\uff08\u865a\u62df\u7684\uff09\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5b83\u5728\u8f93\u51fa\u56fe\u50cf\u4e4b\u524d\u751f\u6210\u6570\u4e2a\u6b65\u9aa4\u7684\u566a\u97f3\uff1a\n\n$code_fake_diffusion\n$demo_fake_diffusion\n\n\u8bf7\u6ce8\u610f\uff0c\u6211\u4eec\u5728\u8fed\u4ee3\u5668\u4e2d\u6dfb\u52a0\u4e86 `time.sleep(1)`\uff0c\u4ee5\u521b\u5efa\u6b65\u9aa4\u4e4b\u95f4\u7684\u4eba\u5de5\u6682\u505c\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u89c2\u5bdf\u8fed\u4ee3\u5668\u7684\u6b65\u9aa4\uff08\u5728\u771f\u5b9e\u7684\u56fe\u50cf\u751f\u6210\u6a21\u578b\u4e2d\uff0c\u8fd9\u53ef\u80fd\u662f\u4e0d\u5fc5\u8981\u7684\uff09\u3002\n\n\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio **\u9700\u8981**\u5728\u5e95\u5c42 Interface \u6216 Blocks \u4e2d\u542f\u7528\u961f\u5217\uff08\u8bf7\u53c2\u9605\u4e0a\u9762\u7684\u961f\u5217\u90e8\u5206\uff09\u3002\n\n## \u8fdb\u5ea6\u6761\n\nGradio \u652f\u6301\u521b\u5efa\u81ea\u5b9a\u4e49\u8fdb\u5ea6\u6761\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u81ea\u5b9a\u4e49\u548c\u63a7\u5236\u5411\u7528\u6237\u663e\u793a\u7684\u8fdb\u5ea6\u66f4\u65b0\u3002\u8981\u542f\u7528\u6b64\u529f\u80fd\uff0c\u53ea\u9700\u4e3a\u65b9\u6cd5\u6dfb\u52a0\u4e00\u4e2a\u9ed8\u8ba4\u503c\u4e3a `gr.Progress` \u5b9e\u4f8b\u7684\u53c2\u6570\u5373\u53ef\u3002\u7136\u540e\uff0c\u60a8\u53ef\u4ee5\u76f4\u63a5\u8c03\u7528\u6b64\u5b9e\u4f8b\u5e76\u4f20\u5165 0 \u5230 1 \u4e4b\u95f4\u7684\u6d6e\u70b9\u6570\u6765\u66f4\u65b0\u8fdb\u5ea6\u7ea7\u522b\uff0c\u6216\u8005 with `Progress` \u5b9e\u4f8b\u7684 `tqdm()` \u65b9\u6cd5\u6765\u8ddf\u8e2a\u53ef\u8fed\u4ee3\u5bf9\u8c61\u4e0a\u7684\u8fdb\u5ea6\uff0c\u5982\u4e0b\u6240\u793a\u3002\u5fc5\u987b\u542f\u7528\u961f\u5217\u4ee5\u8fdb\u884c\u8fdb\u5ea6\u66f4\u65b0\u3002\n\n$code_progress_simple\n$demo_progress_simple\n\n\u5982\u679c\u60a8 with `tqdm` \u5e93\uff0c\u5e76\u4e14\u5e0c\u671b\u4ece\u51fd\u6570\u5185\u90e8\u7684\u4efb\u4f55 `tqdm.tqdm` \u81ea\u52a8\u62a5\u544a\u8fdb\u5ea6\u66f4\u65b0\uff0c\u8bf7\u5c06\u9ed8\u8ba4\u53c2\u6570\u8bbe\u7f6e\u4e3a `gr.Progress(track_tqdm=True)`\uff01\n\n## \u6279\u5904\u7406\u51fd\u6570 (Batch Functions)\n\nGradio \u652f\u6301\u4f20\u9012*\u6279\u5904\u7406*\u51fd\u6570\u3002\u6279\u5904\u7406\u51fd\u6570\u53ea\u662f\u63a5\u53d7\u8f93\u5165\u5217\u8868\u5e76\u8fd4\u56de\u9884\u6d4b\u5217\u8868\u7684\u51fd\u6570\u3002\n\n\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\u6279\u5904\u7406\u51fd\u6570\uff0c\u5b83\u63a5\u53d7\u4e24\u4e2a\u8f93\u5165\u5217\u8868\uff08\u4e00\u4e2a\u5355\u8bcd\u5217\u8868\u548c\u4e00\u4e2a\u6574\u6570\u5217\u8868\uff09\uff0c\u5e76\u8fd4\u56de\u4fee\u526a\u8fc7\u7684\u5355\u8bcd\u5217\u8868\u4f5c\u4e3a\u8f93\u51fa\uff1a\n\n```python\nimport time\n\ndef trim_words(words, lens):\n    trimmed_words = []\n    time.sleep(5)\n    for w, l in zip(words, lens):\n        trimmed_words.append(w[:int(l)])\n    return [trimmed_words]\n    for w, l in zip(words, lens):\n```\n\n\u4f7f\u7528\u6279\u5904\u7406\u51fd\u6570\u7684\u4f18\u70b9\u662f\uff0c\u5982\u679c\u542f\u7528\u4e86\u961f\u5217\uff0cGradio \u670d\u52a1\u5668\u53ef\u4ee5\u81ea\u52a8*\u6279\u5904\u7406*\u4f20\u5165\u7684\u8bf7\u6c42\u5e76\u5e76\u884c\u5904\u7406\u5b83\u4eec\uff0c\u4ece\u800c\u53ef\u80fd\u52a0\u5feb\u6f14\u793a\u901f\u5ea6\u3002\u4ee5\u4e0b\u662f Gradio \u4ee3\u7801\u7684\u793a\u4f8b\uff08\u8bf7\u6ce8\u610f `batch=True` \u548c `max_batch_size=16` - \u8fd9\u4e24\u4e2a\u53c2\u6570\u90fd\u53ef\u4ee5\u4f20\u9012\u7ed9\u4e8b\u4ef6\u89e6\u53d1\u5668\u6216 `Interface` \u7c7b\uff09\n\nwith `Interface`\uff1a\n\n```python\ndemo = gr.Interface(trim_words, [\"textbox\", \"number\"], [\"output\"],\n                    batch=True, max_batch_size=16)\ndemo.queue()\ndemo.launch()\n```\n\nwith `Blocks`\uff1a\n\n```python\nimport gradio as gr\n\nwith gr.Blocks() as demo:\n    with gr.Row():\n        word = gr.Textbox(label=\"word\")\n        leng = gr.Number(label=\"leng\")\n        output = gr.Textbox(label=\"Output\")\n    with gr.Row():\n        run = gr.Button()\n\n    event = run.click(trim_words, [word, leng], output, batch=True, max_batch_size=16)\n\ndemo.queue()\ndemo.launch()\n```\n\n\u5728\u4e0a\u9762\u7684\u793a\u4f8b\u4e2d\uff0c\u53ef\u4ee5\u5e76\u884c\u5904\u7406 16 \u4e2a\u8bf7\u6c42\uff08\u603b\u63a8\u7406\u65f6\u95f4\u4e3a 5 \u79d2\uff09\uff0c\u800c\u4e0d\u662f\u5206\u522b\u5904\u7406\u6bcf\u4e2a\u8bf7\u6c42\uff08\u603b\u63a8\u7406\u65f6\u95f4\u4e3a 80 \u79d2\uff09\u3002\u8bb8\u591a Hugging Face \u7684 `transformers` \u548c `diffusers` \u6a21\u578b\u5728 Gradio \u7684\u6279\u5904\u7406\u6a21\u5f0f\u4e0b\u81ea\u7136\u5de5\u4f5c\uff1a\u8fd9\u662f[\u4f7f\u7528\u6279\u5904\u7406\u751f\u6210\u56fe\u50cf\u7684\u793a\u4f8b\u6f14\u793a](https://github.com/gradio-app/gradio/blob/main/demo/diffusers_with_batching/run.py)\n\n\u6ce8\u610f\uff1a\u4f7f\u7528 Gradio \u7684\u6279\u5904\u7406\u51fd\u6570 **requires** \u5728\u5e95\u5c42 Interface \u6216 Blocks \u4e2d\u542f\u7528\u961f\u5217\uff08\u8bf7\u53c2\u9605\u4e0a\u9762\u7684\u961f\u5217\u90e8\u5206\uff09\u3002\n\n## Gradio \u7b14\u8bb0\u672c (Colab Notebooks)\n\nGradio \u53ef\u4ee5\u5728\u4efb\u4f55\u8fd0\u884c Python \u7684\u5730\u65b9\u8fd0\u884c\uff0c\u5305\u62ec\u672c\u5730 Jupyter \u7b14\u8bb0\u672c\u548c\u534f\u4f5c\u7b14\u8bb0\u672c\uff0c\u5982[Google Colab](https://colab.research.google.com/)\u3002\u5bf9\u4e8e\u672c\u5730 Jupyter \u7b14\u8bb0\u672c\u548c Google Colab \u7b14\u8bb0\u672c\uff0cGradio \u5728\u672c\u5730\u670d\u52a1\u5668\u4e0a\u8fd0\u884c\uff0c\u60a8\u53ef\u4ee5\u5728\u6d4f\u89c8\u5668\u4e2d\u4e0e\u4e4b\u4ea4\u4e92\u3002\uff08\u6ce8\u610f\uff1a\u5bf9\u4e8e Google Colab\uff0c\u8fd9\u662f\u901a\u8fc7[\u670d\u52a1\u5de5\u4f5c\u5668\u96a7\u9053](https://github.com/tensorflow/tensorboard/blob/master/docs/design/colab_integration.md)\u5b9e\u73b0\u7684\uff0c\u60a8\u7684\u6d4f\u89c8\u5668\u9700\u8981\u542f\u7528 cookies\u3002\uff09\u5bf9\u4e8e\u5176\u4ed6\u8fdc\u7a0b\u7b14\u8bb0\u672c\uff0cGradio \u4e5f\u5c06\u5728\u670d\u52a1\u5668\u4e0a\u8fd0\u884c\uff0c\u4f46\u60a8\u9700\u8981\u4f7f\u7528[SSH \u96a7\u9053](https://coderwall.com/p/ohk6cg/remote-access-to-ipython-notebooks-via-ssh)\u5728\u672c\u5730\u6d4f\u89c8\u5668\u4e2d\u67e5\u770b\u5e94\u7528\u7a0b\u5e8f\u3002\u901a\u5e38\uff0c\u66f4\u7b80\u5355\u7684\u9009\u62e9\u662f\u4f7f\u7528 Gradio \u5185\u7f6e\u7684\u516c\u5171\u94fe\u63a5\uff0c[\u5728\u4e0b\u4e00\u7bc7\u6307\u5357\u4e2d\u8ba8\u8bba](/sharing-your-app/#sharing-demos)\u3002\n    ```",
            "vector_context": "[Created at: 2025-03-24 13:16:48]\n\u4e3b\u8981\u7279\u70b9\n\n\u8ba9\u6211\u4eec\u6765\u4ecb\u7ecd\u4e00\u4e0b Gradio \u6700\u53d7\u6b22\u8fce\u7684\u4e00\u4e9b\u529f\u80fd\uff01\u8fd9\u91cc\u662f Gradio \u7684\u4e3b\u8981\u7279\u70b9\uff1a\n\n1. [\u6dfb\u52a0\u793a\u4f8b\u8f93\u5165](#example-inputs)\n2. [\u4f20\u9012\u81ea\u5b9a\u4e49\u9519\u8bef\u6d88\u606f](#errors)\n3. [\u6dfb\u52a0\u63cf\u8ff0\u5185\u5bb9](#descriptive-content)\n4. [\u8bbe\u7f6e\u65d7\u6807](#flagging)\n5. [\u9884\u5904\u7406\u548c\u540e\u5904\u7406](#preprocessing-and-postprocessing)\n6. [\u6837\u5f0f\u5316\u6f14\u793a](#styling)\n7. [\u6392\u961f\u7528\u6237](#queuing)\n8. [\u8fed\u4ee3\u8f93\u51fa](#iterative-outputs)\n9. [\u8fdb\u5ea6\u6761](#progress-bars)\n10. [\u6279\u5904\u7406\u51fd\u6570](#batch-functions)\n11. [\u5728\u534f\u4f5c\u7b14\u8bb0\u672c\u4e0a\u8fd0\u884c](#colab-notebooks)\n\n## \u793a\u4f8b\u8f93\u5165\n\n\u60a8\u53ef\u4ee5\u63d0\u4f9b\u7528\u6237\u53ef\u4ee5\u8f7b\u677e\u52a0\u8f7d\u5230 \"Interface\" \u4e2d\u7684\u793a\u4f8b\u6570\u636e\u3002\u8fd9\u5bf9\u4e8e\u6f14\u793a\u6a21\u578b\u671f\u671b\u7684\u8f93\u5165\u7c7b\u578b\u4ee5\u53ca\u6f14\u793a\u6570\u636e\u96c6\u548c\u6a21\u578b\u4e00\u8d77\u63a2\u7d22\u7684\u65b9\u5f0f\u975e\u5e38\u6709\u5e2e\u52a9\u3002\u8981\u52a0\u8f7d\u793a\u4f8b\u6570\u636e\uff0c\u60a8\u53ef\u4ee5\u5c06\u5d4c\u5957\u5217\u8868\u63d0\u4f9b\u7ed9 Interface \u6784\u9020\u51fd\u6570\u7684 `examples=` \u5173\u952e\u5b57\u53c2\u6570\u3002\u5916\u90e8\u5217\u8868\u4e2d\u7684\u6bcf\u4e2a\u5b50\u5217\u8868\u8868\u793a\u4e00\u4e2a\u6570\u636e\u6837\u672c\uff0c\u5b50\u5217\u8868\u4e2d\u7684\u6bcf\u4e2a\u5143\u7d20\u8868\u793a\u6bcf\u4e2a\u8f93\u5165\u7ec4\u4ef6\u7684\u8f93\u5165\u3002\u6709\u5173\u6bcf\u4e2a\u7ec4\u4ef6\u7684\u793a\u4f8b\u6570\u636e\u683c\u5f0f\u5728[Docs](https://gradio.app/docs#components)\u4e2d\u6709\u8bf4\u660e\u3002\n\n$code_calculator\n$demo_calculator\n\n\u60a8\u53ef\u4ee5\u5c06\u5927\u578b\u6570\u636e\u96c6\u52a0\u8f7d\u5230\u793a\u4f8b\u4e2d\uff0c\u901a\u8fc7 Gradio \u6d4f\u89c8\u548c\u4e0e\u6570\u636e\u96c6\u8fdb\u884c\u4ea4\u4e92\u3002\u793a\u4f8b\u5c06\u81ea\u52a8\u5206\u9875\uff08\u53ef\u4ee5\u901a\u8fc7 Interface \u7684 `examples_per_page` \u53c2\u6570\u8fdb\u884c\u914d\u7f6e\uff09\u3002\n\n\u7ee7\u7eed\u4e86\u89e3\u793a\u4f8b\uff0c\u8bf7\u53c2\u9605[\u66f4\u591a\u793a\u4f8b](https://gradio.app/more-on-examples)\u6307\u5357\u3002\n\n## \u9519\u8bef\n\n\u60a8\u5e0c\u671b\u5411\u7528\u6237\u4f20\u9012\u81ea\u5b9a\u4e49\u9519\u8bef\u6d88\u606f\u3002\u4e3a\u6b64\uff0cwith `gr.Error(\"custom message\")` \u6765\u663e\u793a\u9519\u8bef\u6d88\u606f\u3002\u5982\u679c\u5728\u4e0a\u9762\u7684\u8ba1\u7b97\u5668\u793a\u4f8b\u4e2d\u5c1d\u8bd5\u9664\u4ee5\u96f6\uff0c\u5c06\u663e\u793a\u81ea\u5b9a\u4e49\u9519\u8bef\u6d88\u606f\u7684\u5f39\u51fa\u6a21\u6001\u7a97\u53e3\u3002\u4e86\u89e3\u6709\u5173\u9519\u8bef\u7684\u66f4\u591a\u4fe1\u606f\uff0c\u8bf7\u53c2\u9605[\u6587\u6863](https://gradio.app/docs#error)\u3002\n\n## \u63cf\u8ff0\u6027\u5185\u5bb9\n\n\u5728\u524d\u9762\u7684\u793a\u4f8b\u4e2d\uff0c\u60a8\u53ef\u80fd\u5df2\u7ecf\u6ce8\u610f\u5230 Interface \u6784\u9020\u51fd\u6570\u4e2d\u7684 `title=` \u548c `description=` \u5173\u952e\u5b57\u53c2\u6570\uff0c\u5e2e\u52a9\u7528\u6237\u4e86\u89e3\u60a8\u7684\u5e94\u7528\u7a0b\u5e8f\u3002\n\nInterface \u6784\u9020\u51fd\u6570\u4e2d\u6709\u4e09\u4e2a\u53c2\u6570\u7528\u4e8e\u6307\u5b9a\u6b64\u5185\u5bb9\u5e94\u653e\u7f6e\u5728\u54ea\u91cc\uff1a\n\n- `title`\uff1a\u63a5\u53d7\u6587\u672c\uff0c\u5e76\u53ef\u4ee5\u5c06\u5176\u663e\u793a\u5728\u754c\u9762\u7684\u9876\u90e8\uff0c\u4e5f\u5c06\u6210\u4e3a\u9875\u9762\u6807\u9898\u3002\n- `description`\uff1a\u63a5\u53d7\u6587\u672c\u3001Markdown \u6216 HTML\uff0c\u5e76\u5c06\u5176\u653e\u7f6e\u5728\u6807\u9898\u6b63\u4e0b\u65b9\u3002\n- `article`\uff1a\u4e5f\u63a5\u53d7\u6587\u672c\u3001Markdown \u6216 HTML\uff0c\u5e76\u5c06\u5176\u653e\u7f6e\u5728\u754c\u9762\u4e0b\u65b9\u3002\n\n![annotated](/assets/guides/annotated.png)\n\n\u5982\u679c\u60a8\u4f7f\u7528\u7684\u662f `Blocks` API\uff0c\u5219\u53ef\u4ee5 with `gr.Markdown(...)` \u6216 `gr.HTML(...)` \u7ec4\u4ef6\u5728\u4efb\u4f55\u4f4d\u7f6e\u63d2\u5165\u6587\u672c\u3001Markdown \u6216 HTML\uff0c\u5176\u4e2d\u63cf\u8ff0\u6027\u5185\u5bb9\u4f4d\u4e8e `Component` \u6784\u9020\u51fd\u6570\u5185\u90e8\u3002\n\n\u53e6\u4e00\u4e2a\u6709\u7528\u7684\u5173\u952e\u5b57\u53c2\u6570\u662f `label=`\uff0c\u5b83\u5b58\u5728\u4e8e\u6bcf\u4e2a `Component` \u4e2d\u3002\u8fd9\u4fee\u6539\u4e86\u6bcf\u4e2a `Component` \u9876\u90e8\u7684\u6807\u7b7e\u6587\u672c\u3002\u8fd8\u53ef\u4ee5\u4e3a\u8bf8\u5982 `Textbox` \u6216 `Radio` \u4e4b\u7c7b\u7684\u8868\u5355\u5143\u7d20\u6dfb\u52a0 `info=` \u5173\u952e\u5b57\u53c2\u6570\uff0c\u4ee5\u63d0\u4f9b\u6709\u5173\u5176\u7528\u6cd5\u7684\u8fdb\u4e00\u6b65\u4fe1\u606f\u3002\n\n```python\ngr.Number(label='\u5e74\u9f84', info='\u4ee5\u5e74\u4e3a\u5355\u4f4d\uff0c\u5fc5\u987b\u5927\u4e8e0')\n```\n\n## \u65d7\u6807\n\n\u9ed8\u8ba4\u60c5\u51b5\u4e0b\uff0c\"Interface\" \u5c06\u6709\u4e00\u4e2a \"Flag\" \u6309\u94ae\u3002\u5f53\u7528\u6237\u6d4b\u8bd5\u60a8\u7684 `Interface` \u65f6\uff0c\u5982\u679c\u770b\u5230\u6709\u8da3\u7684\u8f93\u51fa\uff0c\u4f8b\u5982\u9519\u8bef\u6216\u610f\u5916\u7684\u6a21\u578b\u884c\u4e3a\uff0c\u4ed6\u4eec\u53ef\u4ee5\u5c06\u8f93\u5165\u6807\u8bb0\u4e3a\u60a8\u8fdb\u884c\u67e5\u770b\u3002\u5728\u7531 `Interface` \u6784\u9020\u51fd\u6570\u7684 `flagging_dir=` \u53c2\u6570\u63d0\u4f9b\u7684\u76ee\u5f55\u4e2d\uff0c\u5c06\u8bb0\u5f55\u6807\u8bb0\u7684\u8f93\u5165\u5230\u4e00\u4e2a CSV \u6587\u4ef6\u4e2d\u3002\u5982\u679c\u754c\u9762\u6d89\u53ca\u6587\u4ef6\u6570\u636e\uff0c\u4f8b\u5982\u56fe\u50cf\u548c\u97f3\u9891\u7ec4\u4ef6\uff0c\u5c06\u521b\u5efa\u6587\u4ef6\u5939\u6765\u5b58\u50a8\u8fd9\u4e9b\u6807\u8bb0\u7684\u6570\u636e\u3002\n\n\u4f8b\u5982\uff0c\u5bf9\u4e8e\u4e0a\u9762\u663e\u793a\u7684\u8ba1\u7b97\u5668\u754c\u9762\uff0c\u6211\u4eec\u5c06\u5728\u4e0b\u9762\u7684\u65d7\u6807\u76ee\u5f55\u4e2d\u5b58\u50a8\u6807\u8bb0\u7684\u6570\u636e\uff1a\n\n```directory\n+-- calculator.py\n+-- flagged/\n|   +-- logs.csv\n```\n\n_flagged/logs.csv_\n\n```csv\nnum1,operation,num2,Output\n5,add,7,12\n6,subtract,1.5,4.5\n```\n\n\u4e0e\u65e9\u671f\u663e\u793a\u7684\u51b7\u8272\u754c\u9762\u76f8\u5bf9\u5e94\uff0c\u6211\u4eec\u5c06\u5728\u4e0b\u9762\u7684\u65d7\u6807\u76ee\u5f55\u4e2d\u5b58\u50a8\u6807\u8bb0\u7684\u6570\u636e\uff1a\n\n```directory\n+-- sepia.py\n+-- flagged/\n|   +-- logs.csv\n|   +-- im/\n|   |   +-- 0.png\n|   |   +-- 1.png\n|   +-- Output/\n|   |   +-- 0.png\n|   |   +-- 1.png\n```\n\n_flagged/logs.csv_\n\n```csv\nim,Output\nim/0.png,Output/0.png\nim/1.png,Output/1.png\n```\n\n\u5982\u679c\u60a8\u5e0c\u671b\u7528\u6237\u63d0\u4f9b\u65d7\u6807\u539f\u56e0\uff0c\u53ef\u4ee5\u5c06\u5b57\u7b26\u4e32\u5217\u8868\u4f20\u9012\u7ed9 Interface \u7684 `flagging_options` \u53c2\u6570\u3002\u7528\u6237\u5728\u8fdb\u884c\u65d7\u6807\u65f6\u5fc5\u987b\u9009\u62e9\u5176\u4e2d\u4e00\u4e2a\u5b57\u7b26\u4e32\uff0c\u8fd9\u5c06\u4f5c\u4e3a\u9644\u52a0\u5217\u4fdd\u5b58\u5230 CSV \u4e2d\u3002\n\n## \u9884\u5904\u7406\u548c\u540e\u5904\u7406 (Preprocessing and Postprocessing)\n\n![annotated](/assets/img/dataflow.svg)\n\n\u5982\u60a8\u6240\u89c1\uff0cGradio \u5305\u62ec\u53ef\u4ee5\u5904\u7406\u5404\u79cd\u4e0d\u540c\u6570\u636e\u7c7b\u578b\u7684\u7ec4\u4ef6\uff0c\u4f8b\u5982\u56fe\u50cf\u3001\u97f3\u9891\u548c\u89c6\u9891\u3002\u5927\u591a\u6570\u7ec4\u4ef6\u90fd\u53ef\u4ee5\u7528\u4f5c\u8f93\u5165\u6216\u8f93\u51fa\u3002\n\n\u5f53\u7ec4\u4ef6\u7528\u4f5c\u8f93\u5165\u65f6\uff0cGradio \u81ea\u52a8\u5904\u7406*\u9884\u5904\u7406*\uff0c\u5c06\u6570\u636e\u4ece\u7528\u6237\n--New Chunk--\n[Created at: 2025-03-24 13:16:48]\n\u4e0e\u5e38\u89c4\u51fd\u6570\u76f8\u540c\u7684\u65b9\u5f0f\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio\u3002\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\uff08\u865a\u62df\u7684\uff09\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5b83\u5728\u8f93\u51fa\u56fe\u50cf\u4e4b\u524d\u751f\u6210\u6570\u4e2a\u6b65\u9aa4\u7684\u566a\u97f3\uff1a\n\n$code_fake_diffusion\n$demo_fake_diffusion\n\n\u8bf7\u6ce8\u610f\uff0c\u6211\u4eec\u5728\u8fed\u4ee3\u5668\u4e2d\u6dfb\u52a0\u4e86 `time.sleep(1)`\uff0c\u4ee5\u521b\u5efa\u6b65\u9aa4\u4e4b\u95f4\u7684\u4eba\u5de5\u6682\u505c\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u89c2\u5bdf\u8fed\u4ee3\u5668\u7684\u6b65\u9aa4\uff08\u5728\u771f\u5b9e\u7684\u56fe\u50cf\u751f\u6210\u6a21\u578b\u4e2d\uff0c\u8fd9\u53ef\u80fd\u662f\u4e0d\u5fc5\u8981\u7684\uff09\u3002\n\n\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio **\u9700\u8981**\u5728\u5e95\u5c42 Interface \u6216 Blocks \u4e2d\u542f\u7528\u961f\u5217\uff08\u8bf7\u53c2\u9605\u4e0a\u9762\u7684\u961f\u5217\u90e8\u5206\uff09\u3002\n\n## \u8fdb\u5ea6\u6761\n\nGradio \u652f\u6301\u521b\u5efa\u81ea\u5b9a\u4e49\u8fdb\u5ea6\u6761\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u81ea\u5b9a\u4e49\u548c\u63a7\u5236\u5411\u7528\u6237\u663e\u793a\u7684\u8fdb\u5ea6\u66f4\u65b0\u3002\u8981\u542f\u7528\u6b64\u529f\u80fd\uff0c\u53ea\u9700\u4e3a\u65b9\u6cd5\u6dfb\u52a0\u4e00\u4e2a\u9ed8\u8ba4\u503c\u4e3a `gr.Progress` \u5b9e\u4f8b\u7684\u53c2\u6570\u5373\u53ef\u3002\u7136\u540e\uff0c\u60a8\u53ef\u4ee5\u76f4\u63a5\u8c03\u7528\u6b64\u5b9e\u4f8b\u5e76\u4f20\u5165 0 \u5230 1 \u4e4b\u95f4\u7684\u6d6e\u70b9\u6570\u6765\u66f4\u65b0\u8fdb\u5ea6\u7ea7\u522b\uff0c\u6216\u8005 with `Progress` \u5b9e\u4f8b\u7684 `tqdm()` \u65b9\u6cd5\u6765\u8ddf\u8e2a\u53ef\u8fed\u4ee3\u5bf9\u8c61\u4e0a\u7684\u8fdb\u5ea6\uff0c\u5982\u4e0b\u6240\u793a\u3002\u5fc5\u987b\u542f\u7528\u961f\u5217\u4ee5\u8fdb\u884c\u8fdb\u5ea6\u66f4\u65b0\u3002\n\n$code_progress_simple\n$demo_progress_simple\n\n\u5982\u679c\u60a8 with `tqdm` \u5e93\uff0c\u5e76\u4e14\u5e0c\u671b\u4ece\u51fd\u6570\u5185\u90e8\u7684\u4efb\u4f55 `tqdm.tqdm` \u81ea\u52a8\u62a5\u544a\u8fdb\u5ea6\u66f4\u65b0\uff0c\u8bf7\u5c06\u9ed8\u8ba4\u53c2\u6570\u8bbe\u7f6e\u4e3a `gr.Progress(track_tqdm=True)`\uff01\n\n## \u6279\u5904\u7406\u51fd\u6570 (Batch Functions)\n\nGradio \u652f\u6301\u4f20\u9012*\u6279\u5904\u7406*\u51fd\u6570\u3002\u6279\u5904\u7406\u51fd\u6570\u53ea\u662f\u63a5\u53d7\u8f93\u5165\u5217\u8868\u5e76\u8fd4\u56de\u9884\u6d4b\u5217\u8868\u7684\u51fd\u6570\u3002\n\n\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\u6279\u5904\u7406\u51fd\u6570\uff0c\u5b83\u63a5\u53d7\u4e24\u4e2a\u8f93\u5165\u5217\u8868\uff08\u4e00\u4e2a\u5355\u8bcd\u5217\u8868\u548c\u4e00\u4e2a\u6574\u6570\u5217\u8868\uff09\uff0c\u5e76\u8fd4\u56de\u4fee\u526a\u8fc7\u7684\u5355\u8bcd\u5217\u8868\u4f5c\u4e3a\u8f93\u51fa\uff1a\n\n```python\nimport time\n\ndef trim_words(words, lens):\n    trimmed_words = []\n    time.sleep(5)\n    for w, l in zip(words, lens):\n        trimmed_words.append(w[:int(l)])\n    return [trimmed_words]\n    for w, l in zip(words, lens):\n```\n\n\u4f7f\u7528\u6279\u5904\u7406\u51fd\u6570\u7684\u4f18\u70b9\u662f\uff0c\u5982\u679c\u542f\u7528\u4e86\u961f\u5217\uff0cGradio \u670d\u52a1\u5668\u53ef\u4ee5\u81ea\u52a8*\u6279\u5904\u7406*\u4f20\u5165\u7684\u8bf7\u6c42\u5e76\u5e76\u884c\u5904\u7406\u5b83\u4eec\uff0c\u4ece\u800c\u53ef\u80fd\u52a0\u5feb\u6f14\u793a\u901f\u5ea6\u3002\u4ee5\u4e0b\u662f Gradio \u4ee3\u7801\u7684\u793a\u4f8b\uff08\u8bf7\u6ce8\u610f `batch=True` \u548c `max_batch_size=16` - \u8fd9\u4e24\u4e2a\u53c2\u6570\u90fd\u53ef\u4ee5\u4f20\u9012\u7ed9\u4e8b\u4ef6\u89e6\u53d1\u5668\u6216 `Interface` \u7c7b\uff09\n\nwith `Interface`\uff1a\n\n```python\ndemo = gr.Interface(trim_words, [\"textbox\", \"number\"], [\"output\"],\n                    batch=True, max_batch_size=16)\ndemo.queue()\ndemo.launch()\n```\n\nwith `Blocks`\uff1a\n\n```python\nimport gradio as gr\n\nwith gr.Blocks() as demo:\n    with gr.Row():\n        word = gr.Textbox(label=\"word\")\n        leng = gr.Number(label=\"leng\")\n        output = gr.Textbox(label=\"Output\")\n    with gr.Row():\n        run = gr.Button()\n\n    event = run.click(trim_words, [word, leng], output, batch=True, max_batch_size=16)\n\ndemo.queue()\ndemo.launch()\n```\n\n\u5728\u4e0a\u9762\u7684\u793a\u4f8b\u4e2d\uff0c\u53ef\u4ee5\u5e76\u884c\u5904\u7406 16 \u4e2a\u8bf7\u6c42\uff08\u603b\u63a8\u7406\u65f6\u95f4\u4e3a 5 \u79d2\uff09\uff0c\u800c\u4e0d\u662f\u5206\u522b\u5904\u7406\u6bcf\u4e2a\u8bf7\u6c42\uff08\u603b\u63a8\u7406\u65f6\u95f4\u4e3a 80 \u79d2\uff09\u3002\u8bb8\u591a Hugging Face \u7684 `transformers` \u548c `diffusers` \u6a21\u578b\u5728 Gradio \u7684\u6279\u5904\u7406\u6a21\u5f0f\u4e0b\u81ea\u7136\u5de5\u4f5c\uff1a\u8fd9\u662f[\u4f7f\u7528\u6279\u5904\u7406\u751f\u6210\u56fe\u50cf\u7684\u793a\u4f8b\u6f14\u793a](https://github.com/gradio-app/gradio/blob/main/demo/diffusers_with_batching/run.py)\n\n\u6ce8\u610f\uff1a\u4f7f\u7528 Gradio \u7684\u6279\u5904\u7406\u51fd\u6570 **requires** \u5728\u5e95\u5c42 Interface \u6216 Blocks \u4e2d\u542f\u7528\u961f\u5217\uff08\u8bf7\u53c2\u9605\u4e0a\u9762\u7684\u961f\u5217\u90e8\u5206\uff09\u3002\n\n## Gradio \u7b14\u8bb0\u672c (Colab Notebooks)\n\nGradio \u53ef\u4ee5\u5728\u4efb\u4f55\u8fd0\u884c Python \u7684\u5730\u65b9\u8fd0\u884c\uff0c\u5305\u62ec\u672c\u5730 Jupyter \u7b14\u8bb0\u672c\u548c\u534f\u4f5c\u7b14\u8bb0\u672c\uff0c\u5982[Google Colab](https://colab.research.google.com/)\u3002\u5bf9\u4e8e\u672c\u5730 Jupyter \u7b14\u8bb0\u672c\u548c Google Colab \u7b14\u8bb0\u672c\uff0cGradio \u5728\u672c\u5730\u670d\u52a1\u5668\u4e0a\u8fd0\u884c\uff0c\u60a8\u53ef\u4ee5\u5728\u6d4f\u89c8\u5668\u4e2d\u4e0e\u4e4b\u4ea4\u4e92\u3002\uff08\u6ce8\u610f\uff1a\u5bf9\u4e8e Google Colab\uff0c\u8fd9\u662f\u901a\u8fc7[\u670d\u52a1\u5de5\u4f5c\u5668\u96a7\u9053](https://github.com/tensorflow/tensorboard/blob/master/docs/design/colab_integration.md)\u5b9e\u73b0\u7684\uff0c\u60a8\u7684\u6d4f\u89c8\u5668\u9700\u8981\u542f\u7528 cookies\u3002\uff09\u5bf9\u4e8e\u5176\u4ed6\u8fdc\u7a0b\u7b14\u8bb0\u672c\uff0cGradio \u4e5f\u5c06\u5728\u670d\u52a1\u5668\u4e0a\u8fd0\u884c\uff0c\u4f46\u60a8\u9700\u8981\u4f7f\u7528[SSH \u96a7\u9053](https://coderwall.com/p/ohk6cg/remote-access-to-ipython-notebooks-via-ssh)\u5728\u672c\u5730\u6d4f\u89c8\u5668\u4e2d\u67e5\u770b\u5e94\u7528\u7a0b\u5e8f\u3002\u901a\u5e38\uff0c\u66f4\u7b80\u5355\u7684\u9009\u62e9\u662f\u4f7f\u7528 Gradio \u5185\u7f6e\u7684\u516c\u5171\u94fe\u63a5\uff0c[\u5728\u4e0b\u4e00\u7bc7\u6307\u5357\u4e2d\u8ba8\u8bba](/sharing-your-app/#sharing-demos)\u3002\n--New Chunk--\n[Created at: 2025-03-24 13:16:48]\n\u65f6\u5fc5\u987b\u9009\u62e9\u5176\u4e2d\u4e00\u4e2a\u5b57\u7b26\u4e32\uff0c\u8fd9\u5c06\u4f5c\u4e3a\u9644\u52a0\u5217\u4fdd\u5b58\u5230 CSV \u4e2d\u3002\n\n## \u9884\u5904\u7406\u548c\u540e\u5904\u7406 (Preprocessing and Postprocessing)\n\n![annotated](/assets/img/dataflow.svg)\n\n\u5982\u60a8\u6240\u89c1\uff0cGradio \u5305\u62ec\u53ef\u4ee5\u5904\u7406\u5404\u79cd\u4e0d\u540c\u6570\u636e\u7c7b\u578b\u7684\u7ec4\u4ef6\uff0c\u4f8b\u5982\u56fe\u50cf\u3001\u97f3\u9891\u548c\u89c6\u9891\u3002\u5927\u591a\u6570\u7ec4\u4ef6\u90fd\u53ef\u4ee5\u7528\u4f5c\u8f93\u5165\u6216\u8f93\u51fa\u3002\n\n\u5f53\u7ec4\u4ef6\u7528\u4f5c\u8f93\u5165\u65f6\uff0cGradio \u81ea\u52a8\u5904\u7406*\u9884\u5904\u7406*\uff0c\u5c06\u6570\u636e\u4ece\u7528\u6237\u6d4f\u89c8\u5668\u53d1\u9001\u7684\u7c7b\u578b\uff08\u4f8b\u5982\u7f51\u7edc\u6444\u50cf\u5934\u5feb\u7167\u7684 base64 \u8868\u793a\uff09\u8f6c\u6362\u4e3a\u60a8\u7684\u51fd\u6570\u53ef\u4ee5\u63a5\u53d7\u7684\u5f62\u5f0f\uff08\u4f8b\u5982 `numpy` \u6570\u7ec4\uff09\u3002\n\n\u540c\u6837\uff0c\u5f53\u7ec4\u4ef6\u7528\u4f5c\u8f93\u51fa\u65f6\uff0cGradio \u81ea\u52a8\u5904\u7406*\u540e\u5904\u7406*\uff0c\u5c06\u6570\u636e\u4ece\u51fd\u6570\u8fd4\u56de\u7684\u5f62\u5f0f\uff08\u4f8b\u5982\u56fe\u50cf\u8def\u5f84\u5217\u8868\uff09\u8f6c\u6362\u4e3a\u53ef\u4ee5\u5728\u7528\u6237\u6d4f\u89c8\u5668\u4e2d\u663e\u793a\u7684\u5f62\u5f0f\uff08\u4f8b\u5982\u4ee5 base64 \u683c\u5f0f\u663e\u793a\u56fe\u50cf\u7684 `Gallery`\uff09\u3002\n\n\u60a8\u53ef\u4ee5\u4f7f\u7528\u6784\u5efa\u56fe\u50cf\u7ec4\u4ef6\u65f6\u7684\u53c2\u6570\u63a7\u5236*\u9884\u5904\u7406*\u3002\u4f8b\u5982\uff0c\u5982\u679c\u60a8\u4f7f\u7528\u4ee5\u4e0b\u53c2\u6570\u5b9e\u4f8b\u5316 `Image` \u7ec4\u4ef6\uff0c\u5b83\u5c06\u5c06\u56fe\u50cf\u8f6c\u6362\u4e3a `PIL` \u7c7b\u578b\uff0c\u5e76\u5c06\u5176\u91cd\u5851\u4e3a`(100, 100)`\uff0c\u800c\u4e0d\u7ba1\u63d0\u4ea4\u65f6\u7684\u539f\u59cb\u5927\u5c0f\u5982\u4f55\uff1a\n\n```py\nimg = gr.Image(shape=(100, 100), type=\"pil\")\n```\n\n\u76f8\u53cd\uff0c\u8fd9\u91cc\u6211\u4eec\u4fdd\u7559\u56fe\u50cf\u7684\u539f\u59cb\u5927\u5c0f\uff0c\u4f46\u5728\u5c06\u5176\u8f6c\u6362\u4e3a numpy \u6570\u7ec4\u4e4b\u524d\u53cd\u8f6c\u989c\u8272\uff1a\n\n```py\nimg = gr.Image(invert_colors=True, type=\"numpy\")\n```\n\n\u540e\u5904\u7406\u8981\u5bb9\u6613\u5f97\u591a\uff01Gradio \u81ea\u52a8\u8bc6\u522b\u8fd4\u56de\u6570\u636e\u7684\u683c\u5f0f\uff08\u4f8b\u5982 `Image` \u662f `numpy` \u6570\u7ec4\u8fd8\u662f `str` \u6587\u4ef6\u8def\u5f84\uff1f\uff09\uff0c\u5e76\u5c06\u5176\u540e\u5904\u7406\u4e3a\u53ef\u4ee5\u7531\u6d4f\u89c8\u5668\u663e\u793a\u7684\u683c\u5f0f\u3002\n\n\u8bf7\u67e5\u770b[\u6587\u6863](https://gradio.app/docs)\uff0c\u4e86\u89e3\u6bcf\u4e2a\u7ec4\u4ef6\u7684\u6240\u6709\u4e0e\u9884\u5904\u7406\u76f8\u5173\u7684\u53c2\u6570\u3002\n\n## \u6837\u5f0f (Styling)\n\nGradio \u4e3b\u9898\u662f\u81ea\u5b9a\u4e49\u5e94\u7528\u7a0b\u5e8f\u5916\u89c2\u548c\u611f\u89c9\u7684\u6700\u7b80\u5355\u65b9\u6cd5\u3002\u60a8\u53ef\u4ee5\u9009\u62e9\u591a\u79cd\u4e3b\u9898\u6216\u521b\u5efa\u81ea\u5df1\u7684\u4e3b\u9898\u3002\u8981\u8fd9\u6837\u505a\uff0c\u8bf7\u5c06 `theme=` \u53c2\u6570\u4f20\u9012\u7ed9 `Interface` \u6784\u9020\u51fd\u6570\u3002\u4f8b\u5982\uff1a\n\n```python\ndemo = gr.Interface(..., theme=gr.themes.Monochrome())\n```\n\nGradio \u5e26\u6709\u4e00\u7ec4\u9884\u5148\u6784\u5efa\u7684\u4e3b\u9898\uff0c\u60a8\u53ef\u4ee5\u4ece `gr.themes.*` \u52a0\u8f7d\u3002\u60a8\u53ef\u4ee5\u6269\u5c55\u8fd9\u4e9b\u4e3b\u9898\u6216\u4ece\u5934\u5f00\u59cb\u521b\u5efa\u81ea\u5df1\u7684\u4e3b\u9898 - \u6709\u5173\u66f4\u591a\u8be6\u7ec6\u4fe1\u606f\uff0c\u8bf7\u53c2\u9605[\u4e3b\u9898\u6307\u5357](https://gradio.app/theming-guide)\u3002\n\n\u8981\u589e\u52a0\u989d\u5916\u7684\u6837\u5f0f\u80fd\u529b\uff0c\u60a8\u53ef\u4ee5 with `css=` \u5173\u952e\u5b57\u5c06\u4efb\u4f55 CSS \u4f20\u9012\u7ed9\u60a8\u7684\u5e94\u7528\u7a0b\u5e8f\u3002\nGradio \u5e94\u7528\u7a0b\u5e8f\u7684\u57fa\u7c7b\u662f `gradio-container`\uff0c\u56e0\u6b64\u4ee5\u4e0b\u662f\u4e00\u4e2a\u66f4\u6539 Gradio \u5e94\u7528\u7a0b\u5e8f\u80cc\u666f\u989c\u8272\u7684\u793a\u4f8b\uff1a\n\n```python\nwith `gr.Interface(css=\".gradio-container {background-color: red}\") as demo:\n    ...\n```\n\n## \u961f\u5217 (Queuing)\n\n\u5982\u679c\u60a8\u7684\u5e94\u7528\u7a0b\u5e8f\u9884\u8ba1\u4f1a\u6709\u5927\u91cf\u6d41\u91cf\uff0c\u8bf7 with `queue()` \u65b9\u6cd5\u6765\u63a7\u5236\u5904\u7406\u901f\u7387\u3002\u8fd9\u5c06\u6392\u961f\u5904\u7406\u8c03\u7528\uff0c\u56e0\u6b64\u4e00\u6b21\u53ea\u5904\u7406\u4e00\u5b9a\u6570\u91cf\u7684\u8bf7\u6c42\u3002\u961f\u5217\u4f7f\u7528 Websockets\uff0c\u8fd8\u53ef\u4ee5\u9632\u6b62\u7f51\u7edc\u8d85\u65f6\uff0c\u56e0\u6b64\u5982\u679c\u60a8\u7684\u51fd\u6570\u7684\u63a8\u7406\u65f6\u95f4\u5f88\u957f\uff08> 1 \u5206\u949f\uff09\uff0c\u5e94\u4f7f\u7528\u961f\u5217\u3002\n\nwith `Interface`\uff1a\n\n```python\ndemo = gr.Interface(...).queue()\ndemo.launch()\n```\n\nwith `Blocks`\uff1a\n\n```python\nwith gr.Blocks() as demo\uff1a\n    #...\ndemo.queue()\ndemo.launch()\n```\n\n\u60a8\u53ef\u4ee5\u901a\u8fc7\u4ee5\u4e0b\u65b9\u5f0f\u63a7\u5236\u4e00\u6b21\u5904\u7406\u7684\u8bf7\u6c42\u6570\u91cf\uff1a\n\n```python\ndemo.queue(concurrency_count=3)\n```\n\n\u67e5\u770b\u6709\u5173\u914d\u7f6e\u5176\u4ed6\u961f\u5217\u53c2\u6570\u7684[\u961f\u5217\u6587\u6863](/docs/#queue)\u3002\n\n\u5728 Blocks \u4e2d\u6307\u5b9a\u4ec5\u5bf9\u67d0\u4e9b\u51fd\u6570\u8fdb\u884c\u6392\u961f\uff1a\n\n```python\nwith gr.Blocks() as demo2\uff1a\n    num1 = gr.Number()\n    num2 = gr.Number()\n    output = gr.Number()\n    gr.Button(\"Add\").click(\n        lambda a, b: a + b, [num1, num2], output)\n    gr.Button(\"Multiply\").click(\n        lambda a, b: a * b, [num1, num2], output, queue=True)\ndemo2.launch()\n```\n\n## \u8fed\u4ee3\u8f93\u51fa (Iterative Outputs)\n\n\u5728\u67d0\u4e9b\u60c5\u51b5\u4e0b\uff0c\u60a8\u53ef\u80fd\u9700\u8981\u4f20\u8f93\u4e00\u7cfb\u5217\u8f93\u51fa\u800c\u4e0d\u662f\u4e00\u6b21\u663e\u793a\u5355\u4e2a\u8f93\u51fa\u3002\u4f8b\u5982\uff0c\u60a8\u53ef\u80fd\u6709\u4e00\u4e2a\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5e0c\u671b\u663e\u793a\u751f\u6210\u7684\u6bcf\u4e2a\u6b65\u9aa4\u7684\u56fe\u50cf\uff0c\u76f4\u5230\u6700\u7ec8\u56fe\u50cf\u3002\u6216\u8005\u60a8\u53ef\u80fd\u6709\u4e00\u4e2a\u804a\u5929\u673a\u5668\u4eba\uff0c\u5b83\u9010\u5b57\u9010\u53e5\u5730\u6d41\u5f0f\u4f20\u8f93\u54cd\u5e94\uff0c\u800c\u4e0d\u662f\u4e00\u6b21\u8fd4\u56de\u5168\u90e8\u54cd\u5e94\u3002\n\n\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u60a8\u53ef\u4ee5\u5c06**\u751f\u6210\u5668**\u51fd\u6570\u63d0\u4f9b\u7ed9 Gradio\uff0c\u800c\u4e0d\u662f\u5e38\u89c4\u51fd\u6570\u3002\u5728 Python \u4e2d\u521b\u5efa\u751f\u6210\u5668\u975e\u5e38\u7b80\u5355\uff1a\u51fd\u6570\u4e0d\u5e94\u8be5\u6709\u4e00\u4e2a\u5355\u72ec\u7684 `return` \u503c\uff0c\u800c\u662f\u5e94\u8be5 with `yield` \u8fde\u7eed\u8fd4\u56de\u4e00\u7cfb\u5217\u503c\u3002\u901a\u5e38\uff0c`yield` \u8bed\u53e5\u653e\u7f6e\u5728\u67d0\u79cd\u5faa\u73af\u4e2d\u3002\u4e0b\u9762\u662f\u4e00\u4e2a\u7b80\u5355\u793a\u4f8b\uff0c\u751f\u6210\u5668\u53ea\u662f\u7b80\u5355\u8ba1\u6570\u5230\u7ed9\u5b9a\u6570\u5b57\uff1a\n\n```python\ndef my_generator(x):\n    for i in range(x):\n        yield i\n```\n\n\u60a8\u4ee5\u4e0e\u5e38\u89c4\u51fd\u6570\u76f8\u540c\u7684\u65b9\u5f0f\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio\u3002\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\uff08\u865a\u62df\u7684\uff09\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5b83\u5728\u8f93\u51fa\u56fe\u50cf\u4e4b\u524d\u751f\u6210\u6570\u4e2a\u6b65\u9aa4\u7684\u566a\u97f3\uff1a\n\n$code_fake_diffusion\n$demo_fake_diffusion\n\n\u8bf7\u6ce8\u610f\uff0c\u6211\u4eec\u5728\u8fed\u4ee3\u5668\u4e2d\u6dfb\u52a0\u4e86 `time.sleep(1)`\uff0c\u4ee5\u521b\u5efa\u6b65\u9aa4\u4e4b\u95f4\u7684\u4eba\u5de5\u6682\u505c\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u89c2\u5bdf\u8fed\u4ee3\u5668\u7684\u6b65\u9aa4\uff08\u5728\u771f\u5b9e\u7684\u56fe\u50cf\u751f\u6210\u6a21\u578b\u4e2d\uff0c\u8fd9"
        }
    },
    {
        "sample_idx": 29,
        "question": "What is a batch function in Gradio?",
        "answer": "A batch function is a function that accepts input lists and returns prediction lists.",
        "rag_answer": "**Batch Functions in Gradio**\n\nIn Gradio, a batch function is a function that accepts a list of inputs and returns a list of outputs. Batch functions are useful when you want to process multiple inputs at once, which can improve the performance and efficiency of your application.\n\nA batch function in Gradio is simply a function that takes a list of inputs and returns a list of outputs. For example, if you have a function that trims words to a certain length, you can create a batch function that takes a list of words and lengths, and returns a list of trimmed words.\n\nHere's an example of a batch function in Gradio:\n```python\ndef trim_words(words, lens):\n    trimmed_words = []\n    for w, l in zip(words, lens):\n        trimmed_words.append(w[:int(l)])\n    return [trimmed_words]\n```\nIn this example, the `trim_words` function takes two lists as input: `words` and `lens`. It then processes each word and length pair, trims the word to the specified length, and returns a list of trimmed words.\n\n**Benefits of Batch Functions**\n\nUsing batch functions in Gradio provides several benefits:\n\n1. **Improved Performance**: By processing multiple inputs at once, batch functions can significantly improve the performance of your application.\n2. **Efficient Use of Resources**: Batch functions can reduce the number of requests made to your model or function, which can lead to more efficient use of resources.\n3. **Enhanced User Experience**: By processing multiple inputs at once, batch functions can provide a more seamless and responsive user experience.\n\n**Configuring Batch Functions in Gradio**\n\nTo use a batch function in Gradio, you need to specify the `batch=True` parameter when creating an interface or event. You can also specify the `max_batch_size` parameter to control the maximum number of inputs processed in each batch.\n\nHere's an example of configuring a batch function in Gradio:\n```python\ndemo = gr.Interface(trim_words, [\"textbox\", \"number\"], [\"output\"], batch=True, max_batch_size=16)\n```\nIn this example, the `trim_words` function is configured as a batch function with a maximum batch size of 16.\n\nReferences:\n[KG] Gradio Documentation: Batch Functions\n[DC] Gradio Tutorial: Batch Functions",
        "rag_score": null,
        "rag_feedback": null,
        "rag_context": {
            "kg_context": "-----Entities-----\n    ```csv\n    id,\tentity,\ttype,\tdescription,\trankcreated_at\n1,\tGradio,organization,Gradio is a platform that supports state in Blocks, providing features such as global state and session state.<SEP>Gradio is an interface that provides various features for demonstrating models, including adding example inputs, custom error messages, descriptive content, flagging, and more.<SEP>Gradio is an organization that provides a platform for building and deploying machine learning models.<SEP>Gradio is an organization that provides a platform for creating and deploying machine learning models.<SEP>Gradio is an organization that provides a demo for blocks_random_slider, and its library is used to create interactive interfaces.,36,2025-03-24 13:17:31\n2,\tState,category,State is a concept in Gradio that refers to the storage of data, including global state and session state.,2,2025-03-24 13:17:31\n3,\tgr,organization,gr is an organization that provides the Gradio library used in the demo.,1,2025-03-24 13:17:31\n4,\tExample Inputs,category,Example Inputs are a feature in Gradio that allows users to load sample data into an interface.,1,2025-03-24 13:17:31\n5,\tBatch Functions,category,Batch Functions is a category of functions in Gradio that enables the processing of batches of inputs.,1,UNKNOWN\n6,\tqueue,category,Queue is a component in Gradio that enables the processing of batches of inputs.,1,UNKNOWN\n7,\tPreprocessing and Postprocessing,category,Preprocessing and Postprocessing are features in Gradio that allow users to process data before and after it is input into a model.,1,UNKNOWN\n    ```\n    -----Relationships-----\n    ```csv\n    id,\tsource,\ttarget,\tdescription,\tkeywords,\tweight,\trank,\tcreated_at\n1,\tGradio,State,Gradio supports state in Blocks, including global state and session state.,platform feature, data storage,18.0,38,2025-03-24 13:20:24\n2,\tGradio,gr,gr is the organization that provides the Gradio library used in the demo.,organization, organization,9.0,37,2025-03-24 13:18:47\n3,\tExample Inputs,Gradio,Gradio allows users to add example inputs to an interface.,example inputs, interface feature,8.0,37,2025-03-24 13:17:31\n4,\tBatch Functions,Gradio,Gradio supports batch processing of inputs using batch functions.,functionality, batch processing,18.0,37,UNKNOWN\n5,\tGradio,queue,Queue is a component in Gradio that enables batch processing.,component relationship, batch processing,8.0,37,UNKNOWN\n6,\tGradio,Preprocessing and Postprocessing,Gradio provides features for preprocessing and postprocessing data.,data processing, interface feature,8.0,37,UNKNOWN\n    ```\n    -----Sources-----\n    ```csv\n    id,\tcontent\n1,\tState in Blocks\n\nWe covered [State in Interfaces](https://gradio.app/interface-state), this guide takes a look at state in Blocks, which works mostly the same.\n\n## Global State\n\nGlobal state in Blocks works the same as in Interface. Any variable created outside a function call is a reference shared between all users.\n\n## Session State\n\nGradio supports session **state**, where data persists across multiple submits within a page session, in Blocks apps as well. To reiterate, session data is _not_ shared between different users of your model. To store data in a session state, you need to do three things:\n\n1. Create a `gr.State()` object. If there is a default value to this stateful object, pass that into the constructor.\n2. In the event listener, put the `State` object as an input and output.\n3. In the event listener function, add the variable to the input parameters and the return value.\n\nLet's take a look at a game of hangman.\n\n$code_hangman\n$demo_hangman\n\nLet's see how we do each of the 3 steps listed above in this game:\n\n1. We store the used letters in `used_letters_var`. In the constructor of `State`, we set the initial value of this to `[]`, an empty list.\n2. In `btn.click()`, we have a reference to `used_letters_var` in both the inputs and outputs.\n3. In `guess_letter`, we pass the value of this `State` to `used_letters`, and then return an updated value of this `State` in the return statement.\n\nWith more complex apps, you will likely have many State variables storing session state in a single Blocks app.\n\nLearn more about `State` in the [docs](https://gradio.app/docs#state).\n2,\tGradio Demo: blocks_random_slider\n\n\n```\n!pip install -q gradio \n```\n\n\n```\n\nimport gradio as gr\n\n\ndef func(slider_1, slider_2):\n    return slider_1 * 5 + slider_2\n\n\nwith gr.Blocks() as demo:\n    slider = gr.Slider(minimum=-10.2, maximum=15, label=\"Random Slider (Static)\", randomize=True)\n    slider_1 = gr.Slider(minimum=100, maximum=200, label=\"Random Slider (Input 1)\", randomize=True)\n    slider_2 = gr.Slider(minimum=10, maximum=23.2, label=\"Random Slider (Input 2)\", randomize=True)\n    slider_3 = gr.Slider(value=3, label=\"Non random slider\")\n    btn = gr.Button(\"Run\")\n    btn.click(func, inputs=[slider_1, slider_2], outputs=gr.Number())\n\nif __name__ == \"__main__\":\n    demo.launch()\n\n```\n3,\t\u4e3b\u8981\u7279\u70b9\n\n\u8ba9\u6211\u4eec\u6765\u4ecb\u7ecd\u4e00\u4e0b Gradio \u6700\u53d7\u6b22\u8fce\u7684\u4e00\u4e9b\u529f\u80fd\uff01\u8fd9\u91cc\u662f Gradio \u7684\u4e3b\u8981\u7279\u70b9\uff1a\n\n1. [\u6dfb\u52a0\u793a\u4f8b\u8f93\u5165](#example-inputs)\n2. [\u4f20\u9012\u81ea\u5b9a\u4e49\u9519\u8bef\u6d88\u606f](#errors)\n3. [\u6dfb\u52a0\u63cf\u8ff0\u5185\u5bb9](#descriptive-content)\n4. [\u8bbe\u7f6e\u65d7\u6807](#flagging)\n5. [\u9884\u5904\u7406\u548c\u540e\u5904\u7406](#preprocessing-and-postprocessing)\n6. [\u6837\u5f0f\u5316\u6f14\u793a](#styling)\n7. [\u6392\u961f\u7528\u6237](#queuing)\n8. [\u8fed\u4ee3\u8f93\u51fa](#iterative-outputs)\n9. [\u8fdb\u5ea6\u6761](#progress-bars)\n10. [\u6279\u5904\u7406\u51fd\u6570](#batch-functions)\n11. [\u5728\u534f\u4f5c\u7b14\u8bb0\u672c\u4e0a\u8fd0\u884c](#colab-notebooks)\n\n## \u793a\u4f8b\u8f93\u5165\n\n\u60a8\u53ef\u4ee5\u63d0\u4f9b\u7528\u6237\u53ef\u4ee5\u8f7b\u677e\u52a0\u8f7d\u5230 \"Interface\" \u4e2d\u7684\u793a\u4f8b\u6570\u636e\u3002\u8fd9\u5bf9\u4e8e\u6f14\u793a\u6a21\u578b\u671f\u671b\u7684\u8f93\u5165\u7c7b\u578b\u4ee5\u53ca\u6f14\u793a\u6570\u636e\u96c6\u548c\u6a21\u578b\u4e00\u8d77\u63a2\u7d22\u7684\u65b9\u5f0f\u975e\u5e38\u6709\u5e2e\u52a9\u3002\u8981\u52a0\u8f7d\u793a\u4f8b\u6570\u636e\uff0c\u60a8\u53ef\u4ee5\u5c06\u5d4c\u5957\u5217\u8868\u63d0\u4f9b\u7ed9 Interface \u6784\u9020\u51fd\u6570\u7684 `examples=` \u5173\u952e\u5b57\u53c2\u6570\u3002\u5916\u90e8\u5217\u8868\u4e2d\u7684\u6bcf\u4e2a\u5b50\u5217\u8868\u8868\u793a\u4e00\u4e2a\u6570\u636e\u6837\u672c\uff0c\u5b50\u5217\u8868\u4e2d\u7684\u6bcf\u4e2a\u5143\u7d20\u8868\u793a\u6bcf\u4e2a\u8f93\u5165\u7ec4\u4ef6\u7684\u8f93\u5165\u3002\u6709\u5173\u6bcf\u4e2a\u7ec4\u4ef6\u7684\u793a\u4f8b\u6570\u636e\u683c\u5f0f\u5728[Docs](https://gradio.app/docs#components)\u4e2d\u6709\u8bf4\u660e\u3002\n\n$code_calculator\n$demo_calculator\n\n\u60a8\u53ef\u4ee5\u5c06\u5927\u578b\u6570\u636e\u96c6\u52a0\u8f7d\u5230\u793a\u4f8b\u4e2d\uff0c\u901a\u8fc7 Gradio \u6d4f\u89c8\u548c\u4e0e\u6570\u636e\u96c6\u8fdb\u884c\u4ea4\u4e92\u3002\u793a\u4f8b\u5c06\u81ea\u52a8\u5206\u9875\uff08\u53ef\u4ee5\u901a\u8fc7 Interface \u7684 `examples_per_page` \u53c2\u6570\u8fdb\u884c\u914d\u7f6e\uff09\u3002\n\n\u7ee7\u7eed\u4e86\u89e3\u793a\u4f8b\uff0c\u8bf7\u53c2\u9605[\u66f4\u591a\u793a\u4f8b](https://gradio.app/more-on-examples)\u6307\u5357\u3002\n\n## \u9519\u8bef\n\n\u60a8\u5e0c\u671b\u5411\u7528\u6237\u4f20\u9012\u81ea\u5b9a\u4e49\u9519\u8bef\u6d88\u606f\u3002\u4e3a\u6b64\uff0cwith `gr.Error(\"custom message\")` \u6765\u663e\u793a\u9519\u8bef\u6d88\u606f\u3002\u5982\u679c\u5728\u4e0a\u9762\u7684\u8ba1\u7b97\u5668\u793a\u4f8b\u4e2d\u5c1d\u8bd5\u9664\u4ee5\u96f6\uff0c\u5c06\u663e\u793a\u81ea\u5b9a\u4e49\u9519\u8bef\u6d88\u606f\u7684\u5f39\u51fa\u6a21\u6001\u7a97\u53e3\u3002\u4e86\u89e3\u6709\u5173\u9519\u8bef\u7684\u66f4\u591a\u4fe1\u606f\uff0c\u8bf7\u53c2\u9605[\u6587\u6863](https://gradio.app/docs#error)\u3002\n\n## \u63cf\u8ff0\u6027\u5185\u5bb9\n\n\u5728\u524d\u9762\u7684\u793a\u4f8b\u4e2d\uff0c\u60a8\u53ef\u80fd\u5df2\u7ecf\u6ce8\u610f\u5230 Interface \u6784\u9020\u51fd\u6570\u4e2d\u7684 `title=` \u548c `description=` \u5173\u952e\u5b57\u53c2\u6570\uff0c\u5e2e\u52a9\u7528\u6237\u4e86\u89e3\u60a8\u7684\u5e94\u7528\u7a0b\u5e8f\u3002\n\nInterface \u6784\u9020\u51fd\u6570\u4e2d\u6709\u4e09\u4e2a\u53c2\u6570\u7528\u4e8e\u6307\u5b9a\u6b64\u5185\u5bb9\u5e94\u653e\u7f6e\u5728\u54ea\u91cc\uff1a\n\n- `title`\uff1a\u63a5\u53d7\u6587\u672c\uff0c\u5e76\u53ef\u4ee5\u5c06\u5176\u663e\u793a\u5728\u754c\u9762\u7684\u9876\u90e8\uff0c\u4e5f\u5c06\u6210\u4e3a\u9875\u9762\u6807\u9898\u3002\n- `description`\uff1a\u63a5\u53d7\u6587\u672c\u3001Markdown \u6216 HTML\uff0c\u5e76\u5c06\u5176\u653e\u7f6e\u5728\u6807\u9898\u6b63\u4e0b\u65b9\u3002\n- `article`\uff1a\u4e5f\u63a5\u53d7\u6587\u672c\u3001Markdown \u6216 HTML\uff0c\u5e76\u5c06\u5176\u653e\u7f6e\u5728\u754c\u9762\u4e0b\u65b9\u3002\n\n![annotated](/assets/guides/annotated.png)\n\n\u5982\u679c\u60a8\u4f7f\u7528\u7684\u662f `Blocks` API\uff0c\u5219\u53ef\u4ee5 with `gr.Markdown(...)` \u6216 `gr.HTML(...)` \u7ec4\u4ef6\u5728\u4efb\u4f55\u4f4d\u7f6e\u63d2\u5165\u6587\u672c\u3001Markdown \u6216 HTML\uff0c\u5176\u4e2d\u63cf\u8ff0\u6027\u5185\u5bb9\u4f4d\u4e8e `Component` \u6784\u9020\u51fd\u6570\u5185\u90e8\u3002\n\n\u53e6\u4e00\u4e2a\u6709\u7528\u7684\u5173\u952e\u5b57\u53c2\u6570\u662f `label=`\uff0c\u5b83\u5b58\u5728\u4e8e\u6bcf\u4e2a `Component` \u4e2d\u3002\u8fd9\u4fee\u6539\u4e86\u6bcf\u4e2a `Component` \u9876\u90e8\u7684\u6807\u7b7e\u6587\u672c\u3002\u8fd8\u53ef\u4ee5\u4e3a\u8bf8\u5982 `Textbox` \u6216 `Radio` \u4e4b\u7c7b\u7684\u8868\u5355\u5143\u7d20\u6dfb\u52a0 `info=` \u5173\u952e\u5b57\u53c2\u6570\uff0c\u4ee5\u63d0\u4f9b\u6709\u5173\u5176\u7528\u6cd5\u7684\u8fdb\u4e00\u6b65\u4fe1\u606f\u3002\n\n```python\ngr.Number(label='\u5e74\u9f84', info='\u4ee5\u5e74\u4e3a\u5355\u4f4d\uff0c\u5fc5\u987b\u5927\u4e8e0')\n```\n\n## \u65d7\u6807\n\n\u9ed8\u8ba4\u60c5\u51b5\u4e0b\uff0c\"Interface\" \u5c06\u6709\u4e00\u4e2a \"Flag\" \u6309\u94ae\u3002\u5f53\u7528\u6237\u6d4b\u8bd5\u60a8\u7684 `Interface` \u65f6\uff0c\u5982\u679c\u770b\u5230\u6709\u8da3\u7684\u8f93\u51fa\uff0c\u4f8b\u5982\u9519\u8bef\u6216\u610f\u5916\u7684\u6a21\u578b\u884c\u4e3a\uff0c\u4ed6\u4eec\u53ef\u4ee5\u5c06\u8f93\u5165\u6807\u8bb0\u4e3a\u60a8\u8fdb\u884c\u67e5\u770b\u3002\u5728\u7531 `Interface` \u6784\u9020\u51fd\u6570\u7684 `flagging_dir=` \u53c2\u6570\u63d0\u4f9b\u7684\u76ee\u5f55\u4e2d\uff0c\u5c06\u8bb0\u5f55\u6807\u8bb0\u7684\u8f93\u5165\u5230\u4e00\u4e2a CSV \u6587\u4ef6\u4e2d\u3002\u5982\u679c\u754c\u9762\u6d89\u53ca\u6587\u4ef6\u6570\u636e\uff0c\u4f8b\u5982\u56fe\u50cf\u548c\u97f3\u9891\u7ec4\u4ef6\uff0c\u5c06\u521b\u5efa\u6587\u4ef6\u5939\u6765\u5b58\u50a8\u8fd9\u4e9b\u6807\u8bb0\u7684\u6570\u636e\u3002\n\n\u4f8b\u5982\uff0c\u5bf9\u4e8e\u4e0a\u9762\u663e\u793a\u7684\u8ba1\u7b97\u5668\u754c\u9762\uff0c\u6211\u4eec\u5c06\u5728\u4e0b\u9762\u7684\u65d7\u6807\u76ee\u5f55\u4e2d\u5b58\u50a8\u6807\u8bb0\u7684\u6570\u636e\uff1a\n\n```directory\n+-- calculator.py\n+-- flagged/\n|   +-- logs.csv\n```\n\n_flagged/logs.csv_\n\n```csv\nnum1,operation,num2,Output\n5,add,7,12\n6,subtract,1.5,4.5\n```\n\n\u4e0e\u65e9\u671f\u663e\u793a\u7684\u51b7\u8272\u754c\u9762\u76f8\u5bf9\u5e94\uff0c\u6211\u4eec\u5c06\u5728\u4e0b\u9762\u7684\u65d7\u6807\u76ee\u5f55\u4e2d\u5b58\u50a8\u6807\u8bb0\u7684\u6570\u636e\uff1a\n\n```directory\n+-- sepia.py\n+-- flagged/\n|   +-- logs.csv\n|   +-- im/\n|   |   +-- 0.png\n|   |   +-- 1.png\n|   +-- Output/\n|   |   +-- 0.png\n|   |   +-- 1.png\n```\n\n_flagged/logs.csv_\n\n```csv\nim,Output\nim/0.png,Output/0.png\nim/1.png,Output/1.png\n```\n\n\u5982\u679c\u60a8\u5e0c\u671b\u7528\u6237\u63d0\u4f9b\u65d7\u6807\u539f\u56e0\uff0c\u53ef\u4ee5\u5c06\u5b57\u7b26\u4e32\u5217\u8868\u4f20\u9012\u7ed9 Interface \u7684 `flagging_options` \u53c2\u6570\u3002\u7528\u6237\u5728\u8fdb\u884c\u65d7\u6807\u65f6\u5fc5\u987b\u9009\u62e9\u5176\u4e2d\u4e00\u4e2a\u5b57\u7b26\u4e32\uff0c\u8fd9\u5c06\u4f5c\u4e3a\u9644\u52a0\u5217\u4fdd\u5b58\u5230 CSV \u4e2d\u3002\n\n## \u9884\u5904\u7406\u548c\u540e\u5904\u7406 (Preprocessing and Postprocessing)\n\n![annotated](/assets/img/dataflow.svg)\n\n\u5982\u60a8\u6240\u89c1\uff0cGradio \u5305\u62ec\u53ef\u4ee5\u5904\u7406\u5404\u79cd\u4e0d\u540c\u6570\u636e\u7c7b\u578b\u7684\u7ec4\u4ef6\uff0c\u4f8b\u5982\u56fe\u50cf\u3001\u97f3\u9891\u548c\u89c6\u9891\u3002\u5927\u591a\u6570\u7ec4\u4ef6\u90fd\u53ef\u4ee5\u7528\u4f5c\u8f93\u5165\u6216\u8f93\u51fa\u3002\n\n\u5f53\u7ec4\u4ef6\u7528\u4f5c\u8f93\u5165\u65f6\uff0cGradio \u81ea\u52a8\u5904\u7406*\u9884\u5904\u7406*\uff0c\u5c06\u6570\u636e\u4ece\u7528\u6237\n4,\t\u4e0e\u5e38\u89c4\u51fd\u6570\u76f8\u540c\u7684\u65b9\u5f0f\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio\u3002\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\uff08\u865a\u62df\u7684\uff09\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5b83\u5728\u8f93\u51fa\u56fe\u50cf\u4e4b\u524d\u751f\u6210\u6570\u4e2a\u6b65\u9aa4\u7684\u566a\u97f3\uff1a\n\n$code_fake_diffusion\n$demo_fake_diffusion\n\n\u8bf7\u6ce8\u610f\uff0c\u6211\u4eec\u5728\u8fed\u4ee3\u5668\u4e2d\u6dfb\u52a0\u4e86 `time.sleep(1)`\uff0c\u4ee5\u521b\u5efa\u6b65\u9aa4\u4e4b\u95f4\u7684\u4eba\u5de5\u6682\u505c\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u89c2\u5bdf\u8fed\u4ee3\u5668\u7684\u6b65\u9aa4\uff08\u5728\u771f\u5b9e\u7684\u56fe\u50cf\u751f\u6210\u6a21\u578b\u4e2d\uff0c\u8fd9\u53ef\u80fd\u662f\u4e0d\u5fc5\u8981\u7684\uff09\u3002\n\n\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio **\u9700\u8981**\u5728\u5e95\u5c42 Interface \u6216 Blocks \u4e2d\u542f\u7528\u961f\u5217\uff08\u8bf7\u53c2\u9605\u4e0a\u9762\u7684\u961f\u5217\u90e8\u5206\uff09\u3002\n\n## \u8fdb\u5ea6\u6761\n\nGradio \u652f\u6301\u521b\u5efa\u81ea\u5b9a\u4e49\u8fdb\u5ea6\u6761\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u81ea\u5b9a\u4e49\u548c\u63a7\u5236\u5411\u7528\u6237\u663e\u793a\u7684\u8fdb\u5ea6\u66f4\u65b0\u3002\u8981\u542f\u7528\u6b64\u529f\u80fd\uff0c\u53ea\u9700\u4e3a\u65b9\u6cd5\u6dfb\u52a0\u4e00\u4e2a\u9ed8\u8ba4\u503c\u4e3a `gr.Progress` \u5b9e\u4f8b\u7684\u53c2\u6570\u5373\u53ef\u3002\u7136\u540e\uff0c\u60a8\u53ef\u4ee5\u76f4\u63a5\u8c03\u7528\u6b64\u5b9e\u4f8b\u5e76\u4f20\u5165 0 \u5230 1 \u4e4b\u95f4\u7684\u6d6e\u70b9\u6570\u6765\u66f4\u65b0\u8fdb\u5ea6\u7ea7\u522b\uff0c\u6216\u8005 with `Progress` \u5b9e\u4f8b\u7684 `tqdm()` \u65b9\u6cd5\u6765\u8ddf\u8e2a\u53ef\u8fed\u4ee3\u5bf9\u8c61\u4e0a\u7684\u8fdb\u5ea6\uff0c\u5982\u4e0b\u6240\u793a\u3002\u5fc5\u987b\u542f\u7528\u961f\u5217\u4ee5\u8fdb\u884c\u8fdb\u5ea6\u66f4\u65b0\u3002\n\n$code_progress_simple\n$demo_progress_simple\n\n\u5982\u679c\u60a8 with `tqdm` \u5e93\uff0c\u5e76\u4e14\u5e0c\u671b\u4ece\u51fd\u6570\u5185\u90e8\u7684\u4efb\u4f55 `tqdm.tqdm` \u81ea\u52a8\u62a5\u544a\u8fdb\u5ea6\u66f4\u65b0\uff0c\u8bf7\u5c06\u9ed8\u8ba4\u53c2\u6570\u8bbe\u7f6e\u4e3a `gr.Progress(track_tqdm=True)`\uff01\n\n## \u6279\u5904\u7406\u51fd\u6570 (Batch Functions)\n\nGradio \u652f\u6301\u4f20\u9012*\u6279\u5904\u7406*\u51fd\u6570\u3002\u6279\u5904\u7406\u51fd\u6570\u53ea\u662f\u63a5\u53d7\u8f93\u5165\u5217\u8868\u5e76\u8fd4\u56de\u9884\u6d4b\u5217\u8868\u7684\u51fd\u6570\u3002\n\n\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\u6279\u5904\u7406\u51fd\u6570\uff0c\u5b83\u63a5\u53d7\u4e24\u4e2a\u8f93\u5165\u5217\u8868\uff08\u4e00\u4e2a\u5355\u8bcd\u5217\u8868\u548c\u4e00\u4e2a\u6574\u6570\u5217\u8868\uff09\uff0c\u5e76\u8fd4\u56de\u4fee\u526a\u8fc7\u7684\u5355\u8bcd\u5217\u8868\u4f5c\u4e3a\u8f93\u51fa\uff1a\n\n```python\nimport time\n\ndef trim_words(words, lens):\n    trimmed_words = []\n    time.sleep(5)\n    for w, l in zip(words, lens):\n        trimmed_words.append(w[:int(l)])\n    return [trimmed_words]\n    for w, l in zip(words, lens):\n```\n\n\u4f7f\u7528\u6279\u5904\u7406\u51fd\u6570\u7684\u4f18\u70b9\u662f\uff0c\u5982\u679c\u542f\u7528\u4e86\u961f\u5217\uff0cGradio \u670d\u52a1\u5668\u53ef\u4ee5\u81ea\u52a8*\u6279\u5904\u7406*\u4f20\u5165\u7684\u8bf7\u6c42\u5e76\u5e76\u884c\u5904\u7406\u5b83\u4eec\uff0c\u4ece\u800c\u53ef\u80fd\u52a0\u5feb\u6f14\u793a\u901f\u5ea6\u3002\u4ee5\u4e0b\u662f Gradio \u4ee3\u7801\u7684\u793a\u4f8b\uff08\u8bf7\u6ce8\u610f `batch=True` \u548c `max_batch_size=16` - \u8fd9\u4e24\u4e2a\u53c2\u6570\u90fd\u53ef\u4ee5\u4f20\u9012\u7ed9\u4e8b\u4ef6\u89e6\u53d1\u5668\u6216 `Interface` \u7c7b\uff09\n\nwith `Interface`\uff1a\n\n```python\ndemo = gr.Interface(trim_words, [\"textbox\", \"number\"], [\"output\"],\n                    batch=True, max_batch_size=16)\ndemo.queue()\ndemo.launch()\n```\n\nwith `Blocks`\uff1a\n\n```python\nimport gradio as gr\n\nwith gr.Blocks() as demo:\n    with gr.Row():\n        word = gr.Textbox(label=\"word\")\n        leng = gr.Number(label=\"leng\")\n        output = gr.Textbox(label=\"Output\")\n    with gr.Row():\n        run = gr.Button()\n\n    event = run.click(trim_words, [word, leng], output, batch=True, max_batch_size=16)\n\ndemo.queue()\ndemo.launch()\n```\n\n\u5728\u4e0a\u9762\u7684\u793a\u4f8b\u4e2d\uff0c\u53ef\u4ee5\u5e76\u884c\u5904\u7406 16 \u4e2a\u8bf7\u6c42\uff08\u603b\u63a8\u7406\u65f6\u95f4\u4e3a 5 \u79d2\uff09\uff0c\u800c\u4e0d\u662f\u5206\u522b\u5904\u7406\u6bcf\u4e2a\u8bf7\u6c42\uff08\u603b\u63a8\u7406\u65f6\u95f4\u4e3a 80 \u79d2\uff09\u3002\u8bb8\u591a Hugging Face \u7684 `transformers` \u548c `diffusers` \u6a21\u578b\u5728 Gradio \u7684\u6279\u5904\u7406\u6a21\u5f0f\u4e0b\u81ea\u7136\u5de5\u4f5c\uff1a\u8fd9\u662f[\u4f7f\u7528\u6279\u5904\u7406\u751f\u6210\u56fe\u50cf\u7684\u793a\u4f8b\u6f14\u793a](https://github.com/gradio-app/gradio/blob/main/demo/diffusers_with_batching/run.py)\n\n\u6ce8\u610f\uff1a\u4f7f\u7528 Gradio \u7684\u6279\u5904\u7406\u51fd\u6570 **requires** \u5728\u5e95\u5c42 Interface \u6216 Blocks \u4e2d\u542f\u7528\u961f\u5217\uff08\u8bf7\u53c2\u9605\u4e0a\u9762\u7684\u961f\u5217\u90e8\u5206\uff09\u3002\n\n## Gradio \u7b14\u8bb0\u672c (Colab Notebooks)\n\nGradio \u53ef\u4ee5\u5728\u4efb\u4f55\u8fd0\u884c Python \u7684\u5730\u65b9\u8fd0\u884c\uff0c\u5305\u62ec\u672c\u5730 Jupyter \u7b14\u8bb0\u672c\u548c\u534f\u4f5c\u7b14\u8bb0\u672c\uff0c\u5982[Google Colab](https://colab.research.google.com/)\u3002\u5bf9\u4e8e\u672c\u5730 Jupyter \u7b14\u8bb0\u672c\u548c Google Colab \u7b14\u8bb0\u672c\uff0cGradio \u5728\u672c\u5730\u670d\u52a1\u5668\u4e0a\u8fd0\u884c\uff0c\u60a8\u53ef\u4ee5\u5728\u6d4f\u89c8\u5668\u4e2d\u4e0e\u4e4b\u4ea4\u4e92\u3002\uff08\u6ce8\u610f\uff1a\u5bf9\u4e8e Google Colab\uff0c\u8fd9\u662f\u901a\u8fc7[\u670d\u52a1\u5de5\u4f5c\u5668\u96a7\u9053](https://github.com/tensorflow/tensorboard/blob/master/docs/design/colab_integration.md)\u5b9e\u73b0\u7684\uff0c\u60a8\u7684\u6d4f\u89c8\u5668\u9700\u8981\u542f\u7528 cookies\u3002\uff09\u5bf9\u4e8e\u5176\u4ed6\u8fdc\u7a0b\u7b14\u8bb0\u672c\uff0cGradio \u4e5f\u5c06\u5728\u670d\u52a1\u5668\u4e0a\u8fd0\u884c\uff0c\u4f46\u60a8\u9700\u8981\u4f7f\u7528[SSH \u96a7\u9053](https://coderwall.com/p/ohk6cg/remote-access-to-ipython-notebooks-via-ssh)\u5728\u672c\u5730\u6d4f\u89c8\u5668\u4e2d\u67e5\u770b\u5e94\u7528\u7a0b\u5e8f\u3002\u901a\u5e38\uff0c\u66f4\u7b80\u5355\u7684\u9009\u62e9\u662f\u4f7f\u7528 Gradio \u5185\u7f6e\u7684\u516c\u5171\u94fe\u63a5\uff0c[\u5728\u4e0b\u4e00\u7bc7\u6307\u5357\u4e2d\u8ba8\u8bba](/sharing-your-app/#sharing-demos)\u3002\n    ```",
            "vector_context": "[Created at: 2025-03-24 13:16:48]\n\u4e3b\u8981\u7279\u70b9\n\n\u8ba9\u6211\u4eec\u6765\u4ecb\u7ecd\u4e00\u4e0b Gradio \u6700\u53d7\u6b22\u8fce\u7684\u4e00\u4e9b\u529f\u80fd\uff01\u8fd9\u91cc\u662f Gradio \u7684\u4e3b\u8981\u7279\u70b9\uff1a\n\n1. [\u6dfb\u52a0\u793a\u4f8b\u8f93\u5165](#example-inputs)\n2. [\u4f20\u9012\u81ea\u5b9a\u4e49\u9519\u8bef\u6d88\u606f](#errors)\n3. [\u6dfb\u52a0\u63cf\u8ff0\u5185\u5bb9](#descriptive-content)\n4. [\u8bbe\u7f6e\u65d7\u6807](#flagging)\n5. [\u9884\u5904\u7406\u548c\u540e\u5904\u7406](#preprocessing-and-postprocessing)\n6. [\u6837\u5f0f\u5316\u6f14\u793a](#styling)\n7. [\u6392\u961f\u7528\u6237](#queuing)\n8. [\u8fed\u4ee3\u8f93\u51fa](#iterative-outputs)\n9. [\u8fdb\u5ea6\u6761](#progress-bars)\n10. [\u6279\u5904\u7406\u51fd\u6570](#batch-functions)\n11. [\u5728\u534f\u4f5c\u7b14\u8bb0\u672c\u4e0a\u8fd0\u884c](#colab-notebooks)\n\n## \u793a\u4f8b\u8f93\u5165\n\n\u60a8\u53ef\u4ee5\u63d0\u4f9b\u7528\u6237\u53ef\u4ee5\u8f7b\u677e\u52a0\u8f7d\u5230 \"Interface\" \u4e2d\u7684\u793a\u4f8b\u6570\u636e\u3002\u8fd9\u5bf9\u4e8e\u6f14\u793a\u6a21\u578b\u671f\u671b\u7684\u8f93\u5165\u7c7b\u578b\u4ee5\u53ca\u6f14\u793a\u6570\u636e\u96c6\u548c\u6a21\u578b\u4e00\u8d77\u63a2\u7d22\u7684\u65b9\u5f0f\u975e\u5e38\u6709\u5e2e\u52a9\u3002\u8981\u52a0\u8f7d\u793a\u4f8b\u6570\u636e\uff0c\u60a8\u53ef\u4ee5\u5c06\u5d4c\u5957\u5217\u8868\u63d0\u4f9b\u7ed9 Interface \u6784\u9020\u51fd\u6570\u7684 `examples=` \u5173\u952e\u5b57\u53c2\u6570\u3002\u5916\u90e8\u5217\u8868\u4e2d\u7684\u6bcf\u4e2a\u5b50\u5217\u8868\u8868\u793a\u4e00\u4e2a\u6570\u636e\u6837\u672c\uff0c\u5b50\u5217\u8868\u4e2d\u7684\u6bcf\u4e2a\u5143\u7d20\u8868\u793a\u6bcf\u4e2a\u8f93\u5165\u7ec4\u4ef6\u7684\u8f93\u5165\u3002\u6709\u5173\u6bcf\u4e2a\u7ec4\u4ef6\u7684\u793a\u4f8b\u6570\u636e\u683c\u5f0f\u5728[Docs](https://gradio.app/docs#components)\u4e2d\u6709\u8bf4\u660e\u3002\n\n$code_calculator\n$demo_calculator\n\n\u60a8\u53ef\u4ee5\u5c06\u5927\u578b\u6570\u636e\u96c6\u52a0\u8f7d\u5230\u793a\u4f8b\u4e2d\uff0c\u901a\u8fc7 Gradio \u6d4f\u89c8\u548c\u4e0e\u6570\u636e\u96c6\u8fdb\u884c\u4ea4\u4e92\u3002\u793a\u4f8b\u5c06\u81ea\u52a8\u5206\u9875\uff08\u53ef\u4ee5\u901a\u8fc7 Interface \u7684 `examples_per_page` \u53c2\u6570\u8fdb\u884c\u914d\u7f6e\uff09\u3002\n\n\u7ee7\u7eed\u4e86\u89e3\u793a\u4f8b\uff0c\u8bf7\u53c2\u9605[\u66f4\u591a\u793a\u4f8b](https://gradio.app/more-on-examples)\u6307\u5357\u3002\n\n## \u9519\u8bef\n\n\u60a8\u5e0c\u671b\u5411\u7528\u6237\u4f20\u9012\u81ea\u5b9a\u4e49\u9519\u8bef\u6d88\u606f\u3002\u4e3a\u6b64\uff0cwith `gr.Error(\"custom message\")` \u6765\u663e\u793a\u9519\u8bef\u6d88\u606f\u3002\u5982\u679c\u5728\u4e0a\u9762\u7684\u8ba1\u7b97\u5668\u793a\u4f8b\u4e2d\u5c1d\u8bd5\u9664\u4ee5\u96f6\uff0c\u5c06\u663e\u793a\u81ea\u5b9a\u4e49\u9519\u8bef\u6d88\u606f\u7684\u5f39\u51fa\u6a21\u6001\u7a97\u53e3\u3002\u4e86\u89e3\u6709\u5173\u9519\u8bef\u7684\u66f4\u591a\u4fe1\u606f\uff0c\u8bf7\u53c2\u9605[\u6587\u6863](https://gradio.app/docs#error)\u3002\n\n## \u63cf\u8ff0\u6027\u5185\u5bb9\n\n\u5728\u524d\u9762\u7684\u793a\u4f8b\u4e2d\uff0c\u60a8\u53ef\u80fd\u5df2\u7ecf\u6ce8\u610f\u5230 Interface \u6784\u9020\u51fd\u6570\u4e2d\u7684 `title=` \u548c `description=` \u5173\u952e\u5b57\u53c2\u6570\uff0c\u5e2e\u52a9\u7528\u6237\u4e86\u89e3\u60a8\u7684\u5e94\u7528\u7a0b\u5e8f\u3002\n\nInterface \u6784\u9020\u51fd\u6570\u4e2d\u6709\u4e09\u4e2a\u53c2\u6570\u7528\u4e8e\u6307\u5b9a\u6b64\u5185\u5bb9\u5e94\u653e\u7f6e\u5728\u54ea\u91cc\uff1a\n\n- `title`\uff1a\u63a5\u53d7\u6587\u672c\uff0c\u5e76\u53ef\u4ee5\u5c06\u5176\u663e\u793a\u5728\u754c\u9762\u7684\u9876\u90e8\uff0c\u4e5f\u5c06\u6210\u4e3a\u9875\u9762\u6807\u9898\u3002\n- `description`\uff1a\u63a5\u53d7\u6587\u672c\u3001Markdown \u6216 HTML\uff0c\u5e76\u5c06\u5176\u653e\u7f6e\u5728\u6807\u9898\u6b63\u4e0b\u65b9\u3002\n- `article`\uff1a\u4e5f\u63a5\u53d7\u6587\u672c\u3001Markdown \u6216 HTML\uff0c\u5e76\u5c06\u5176\u653e\u7f6e\u5728\u754c\u9762\u4e0b\u65b9\u3002\n\n![annotated](/assets/guides/annotated.png)\n\n\u5982\u679c\u60a8\u4f7f\u7528\u7684\u662f `Blocks` API\uff0c\u5219\u53ef\u4ee5 with `gr.Markdown(...)` \u6216 `gr.HTML(...)` \u7ec4\u4ef6\u5728\u4efb\u4f55\u4f4d\u7f6e\u63d2\u5165\u6587\u672c\u3001Markdown \u6216 HTML\uff0c\u5176\u4e2d\u63cf\u8ff0\u6027\u5185\u5bb9\u4f4d\u4e8e `Component` \u6784\u9020\u51fd\u6570\u5185\u90e8\u3002\n\n\u53e6\u4e00\u4e2a\u6709\u7528\u7684\u5173\u952e\u5b57\u53c2\u6570\u662f `label=`\uff0c\u5b83\u5b58\u5728\u4e8e\u6bcf\u4e2a `Component` \u4e2d\u3002\u8fd9\u4fee\u6539\u4e86\u6bcf\u4e2a `Component` \u9876\u90e8\u7684\u6807\u7b7e\u6587\u672c\u3002\u8fd8\u53ef\u4ee5\u4e3a\u8bf8\u5982 `Textbox` \u6216 `Radio` \u4e4b\u7c7b\u7684\u8868\u5355\u5143\u7d20\u6dfb\u52a0 `info=` \u5173\u952e\u5b57\u53c2\u6570\uff0c\u4ee5\u63d0\u4f9b\u6709\u5173\u5176\u7528\u6cd5\u7684\u8fdb\u4e00\u6b65\u4fe1\u606f\u3002\n\n```python\ngr.Number(label='\u5e74\u9f84', info='\u4ee5\u5e74\u4e3a\u5355\u4f4d\uff0c\u5fc5\u987b\u5927\u4e8e0')\n```\n\n## \u65d7\u6807\n\n\u9ed8\u8ba4\u60c5\u51b5\u4e0b\uff0c\"Interface\" \u5c06\u6709\u4e00\u4e2a \"Flag\" \u6309\u94ae\u3002\u5f53\u7528\u6237\u6d4b\u8bd5\u60a8\u7684 `Interface` \u65f6\uff0c\u5982\u679c\u770b\u5230\u6709\u8da3\u7684\u8f93\u51fa\uff0c\u4f8b\u5982\u9519\u8bef\u6216\u610f\u5916\u7684\u6a21\u578b\u884c\u4e3a\uff0c\u4ed6\u4eec\u53ef\u4ee5\u5c06\u8f93\u5165\u6807\u8bb0\u4e3a\u60a8\u8fdb\u884c\u67e5\u770b\u3002\u5728\u7531 `Interface` \u6784\u9020\u51fd\u6570\u7684 `flagging_dir=` \u53c2\u6570\u63d0\u4f9b\u7684\u76ee\u5f55\u4e2d\uff0c\u5c06\u8bb0\u5f55\u6807\u8bb0\u7684\u8f93\u5165\u5230\u4e00\u4e2a CSV \u6587\u4ef6\u4e2d\u3002\u5982\u679c\u754c\u9762\u6d89\u53ca\u6587\u4ef6\u6570\u636e\uff0c\u4f8b\u5982\u56fe\u50cf\u548c\u97f3\u9891\u7ec4\u4ef6\uff0c\u5c06\u521b\u5efa\u6587\u4ef6\u5939\u6765\u5b58\u50a8\u8fd9\u4e9b\u6807\u8bb0\u7684\u6570\u636e\u3002\n\n\u4f8b\u5982\uff0c\u5bf9\u4e8e\u4e0a\u9762\u663e\u793a\u7684\u8ba1\u7b97\u5668\u754c\u9762\uff0c\u6211\u4eec\u5c06\u5728\u4e0b\u9762\u7684\u65d7\u6807\u76ee\u5f55\u4e2d\u5b58\u50a8\u6807\u8bb0\u7684\u6570\u636e\uff1a\n\n```directory\n+-- calculator.py\n+-- flagged/\n|   +-- logs.csv\n```\n\n_flagged/logs.csv_\n\n```csv\nnum1,operation,num2,Output\n5,add,7,12\n6,subtract,1.5,4.5\n```\n\n\u4e0e\u65e9\u671f\u663e\u793a\u7684\u51b7\u8272\u754c\u9762\u76f8\u5bf9\u5e94\uff0c\u6211\u4eec\u5c06\u5728\u4e0b\u9762\u7684\u65d7\u6807\u76ee\u5f55\u4e2d\u5b58\u50a8\u6807\u8bb0\u7684\u6570\u636e\uff1a\n\n```directory\n+-- sepia.py\n+-- flagged/\n|   +-- logs.csv\n|   +-- im/\n|   |   +-- 0.png\n|   |   +-- 1.png\n|   +-- Output/\n|   |   +-- 0.png\n|   |   +-- 1.png\n```\n\n_flagged/logs.csv_\n\n```csv\nim,Output\nim/0.png,Output/0.png\nim/1.png,Output/1.png\n```\n\n\u5982\u679c\u60a8\u5e0c\u671b\u7528\u6237\u63d0\u4f9b\u65d7\u6807\u539f\u56e0\uff0c\u53ef\u4ee5\u5c06\u5b57\u7b26\u4e32\u5217\u8868\u4f20\u9012\u7ed9 Interface \u7684 `flagging_options` \u53c2\u6570\u3002\u7528\u6237\u5728\u8fdb\u884c\u65d7\u6807\u65f6\u5fc5\u987b\u9009\u62e9\u5176\u4e2d\u4e00\u4e2a\u5b57\u7b26\u4e32\uff0c\u8fd9\u5c06\u4f5c\u4e3a\u9644\u52a0\u5217\u4fdd\u5b58\u5230 CSV \u4e2d\u3002\n\n## \u9884\u5904\u7406\u548c\u540e\u5904\u7406 (Preprocessing and Postprocessing)\n\n![annotated](/assets/img/dataflow.svg)\n\n\u5982\u60a8\u6240\u89c1\uff0cGradio \u5305\u62ec\u53ef\u4ee5\u5904\u7406\u5404\u79cd\u4e0d\u540c\u6570\u636e\u7c7b\u578b\u7684\u7ec4\u4ef6\uff0c\u4f8b\u5982\u56fe\u50cf\u3001\u97f3\u9891\u548c\u89c6\u9891\u3002\u5927\u591a\u6570\u7ec4\u4ef6\u90fd\u53ef\u4ee5\u7528\u4f5c\u8f93\u5165\u6216\u8f93\u51fa\u3002\n\n\u5f53\u7ec4\u4ef6\u7528\u4f5c\u8f93\u5165\u65f6\uff0cGradio \u81ea\u52a8\u5904\u7406*\u9884\u5904\u7406*\uff0c\u5c06\u6570\u636e\u4ece\u7528\u6237\n--New Chunk--\n[Created at: 2025-03-24 13:16:48]\n\u4e0e\u5e38\u89c4\u51fd\u6570\u76f8\u540c\u7684\u65b9\u5f0f\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio\u3002\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\uff08\u865a\u62df\u7684\uff09\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5b83\u5728\u8f93\u51fa\u56fe\u50cf\u4e4b\u524d\u751f\u6210\u6570\u4e2a\u6b65\u9aa4\u7684\u566a\u97f3\uff1a\n\n$code_fake_diffusion\n$demo_fake_diffusion\n\n\u8bf7\u6ce8\u610f\uff0c\u6211\u4eec\u5728\u8fed\u4ee3\u5668\u4e2d\u6dfb\u52a0\u4e86 `time.sleep(1)`\uff0c\u4ee5\u521b\u5efa\u6b65\u9aa4\u4e4b\u95f4\u7684\u4eba\u5de5\u6682\u505c\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u89c2\u5bdf\u8fed\u4ee3\u5668\u7684\u6b65\u9aa4\uff08\u5728\u771f\u5b9e\u7684\u56fe\u50cf\u751f\u6210\u6a21\u578b\u4e2d\uff0c\u8fd9\u53ef\u80fd\u662f\u4e0d\u5fc5\u8981\u7684\uff09\u3002\n\n\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio **\u9700\u8981**\u5728\u5e95\u5c42 Interface \u6216 Blocks \u4e2d\u542f\u7528\u961f\u5217\uff08\u8bf7\u53c2\u9605\u4e0a\u9762\u7684\u961f\u5217\u90e8\u5206\uff09\u3002\n\n## \u8fdb\u5ea6\u6761\n\nGradio \u652f\u6301\u521b\u5efa\u81ea\u5b9a\u4e49\u8fdb\u5ea6\u6761\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u81ea\u5b9a\u4e49\u548c\u63a7\u5236\u5411\u7528\u6237\u663e\u793a\u7684\u8fdb\u5ea6\u66f4\u65b0\u3002\u8981\u542f\u7528\u6b64\u529f\u80fd\uff0c\u53ea\u9700\u4e3a\u65b9\u6cd5\u6dfb\u52a0\u4e00\u4e2a\u9ed8\u8ba4\u503c\u4e3a `gr.Progress` \u5b9e\u4f8b\u7684\u53c2\u6570\u5373\u53ef\u3002\u7136\u540e\uff0c\u60a8\u53ef\u4ee5\u76f4\u63a5\u8c03\u7528\u6b64\u5b9e\u4f8b\u5e76\u4f20\u5165 0 \u5230 1 \u4e4b\u95f4\u7684\u6d6e\u70b9\u6570\u6765\u66f4\u65b0\u8fdb\u5ea6\u7ea7\u522b\uff0c\u6216\u8005 with `Progress` \u5b9e\u4f8b\u7684 `tqdm()` \u65b9\u6cd5\u6765\u8ddf\u8e2a\u53ef\u8fed\u4ee3\u5bf9\u8c61\u4e0a\u7684\u8fdb\u5ea6\uff0c\u5982\u4e0b\u6240\u793a\u3002\u5fc5\u987b\u542f\u7528\u961f\u5217\u4ee5\u8fdb\u884c\u8fdb\u5ea6\u66f4\u65b0\u3002\n\n$code_progress_simple\n$demo_progress_simple\n\n\u5982\u679c\u60a8 with `tqdm` \u5e93\uff0c\u5e76\u4e14\u5e0c\u671b\u4ece\u51fd\u6570\u5185\u90e8\u7684\u4efb\u4f55 `tqdm.tqdm` \u81ea\u52a8\u62a5\u544a\u8fdb\u5ea6\u66f4\u65b0\uff0c\u8bf7\u5c06\u9ed8\u8ba4\u53c2\u6570\u8bbe\u7f6e\u4e3a `gr.Progress(track_tqdm=True)`\uff01\n\n## \u6279\u5904\u7406\u51fd\u6570 (Batch Functions)\n\nGradio \u652f\u6301\u4f20\u9012*\u6279\u5904\u7406*\u51fd\u6570\u3002\u6279\u5904\u7406\u51fd\u6570\u53ea\u662f\u63a5\u53d7\u8f93\u5165\u5217\u8868\u5e76\u8fd4\u56de\u9884\u6d4b\u5217\u8868\u7684\u51fd\u6570\u3002\n\n\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\u6279\u5904\u7406\u51fd\u6570\uff0c\u5b83\u63a5\u53d7\u4e24\u4e2a\u8f93\u5165\u5217\u8868\uff08\u4e00\u4e2a\u5355\u8bcd\u5217\u8868\u548c\u4e00\u4e2a\u6574\u6570\u5217\u8868\uff09\uff0c\u5e76\u8fd4\u56de\u4fee\u526a\u8fc7\u7684\u5355\u8bcd\u5217\u8868\u4f5c\u4e3a\u8f93\u51fa\uff1a\n\n```python\nimport time\n\ndef trim_words(words, lens):\n    trimmed_words = []\n    time.sleep(5)\n    for w, l in zip(words, lens):\n        trimmed_words.append(w[:int(l)])\n    return [trimmed_words]\n    for w, l in zip(words, lens):\n```\n\n\u4f7f\u7528\u6279\u5904\u7406\u51fd\u6570\u7684\u4f18\u70b9\u662f\uff0c\u5982\u679c\u542f\u7528\u4e86\u961f\u5217\uff0cGradio \u670d\u52a1\u5668\u53ef\u4ee5\u81ea\u52a8*\u6279\u5904\u7406*\u4f20\u5165\u7684\u8bf7\u6c42\u5e76\u5e76\u884c\u5904\u7406\u5b83\u4eec\uff0c\u4ece\u800c\u53ef\u80fd\u52a0\u5feb\u6f14\u793a\u901f\u5ea6\u3002\u4ee5\u4e0b\u662f Gradio \u4ee3\u7801\u7684\u793a\u4f8b\uff08\u8bf7\u6ce8\u610f `batch=True` \u548c `max_batch_size=16` - \u8fd9\u4e24\u4e2a\u53c2\u6570\u90fd\u53ef\u4ee5\u4f20\u9012\u7ed9\u4e8b\u4ef6\u89e6\u53d1\u5668\u6216 `Interface` \u7c7b\uff09\n\nwith `Interface`\uff1a\n\n```python\ndemo = gr.Interface(trim_words, [\"textbox\", \"number\"], [\"output\"],\n                    batch=True, max_batch_size=16)\ndemo.queue()\ndemo.launch()\n```\n\nwith `Blocks`\uff1a\n\n```python\nimport gradio as gr\n\nwith gr.Blocks() as demo:\n    with gr.Row():\n        word = gr.Textbox(label=\"word\")\n        leng = gr.Number(label=\"leng\")\n        output = gr.Textbox(label=\"Output\")\n    with gr.Row():\n        run = gr.Button()\n\n    event = run.click(trim_words, [word, leng], output, batch=True, max_batch_size=16)\n\ndemo.queue()\ndemo.launch()\n```\n\n\u5728\u4e0a\u9762\u7684\u793a\u4f8b\u4e2d\uff0c\u53ef\u4ee5\u5e76\u884c\u5904\u7406 16 \u4e2a\u8bf7\u6c42\uff08\u603b\u63a8\u7406\u65f6\u95f4\u4e3a 5 \u79d2\uff09\uff0c\u800c\u4e0d\u662f\u5206\u522b\u5904\u7406\u6bcf\u4e2a\u8bf7\u6c42\uff08\u603b\u63a8\u7406\u65f6\u95f4\u4e3a 80 \u79d2\uff09\u3002\u8bb8\u591a Hugging Face \u7684 `transformers` \u548c `diffusers` \u6a21\u578b\u5728 Gradio \u7684\u6279\u5904\u7406\u6a21\u5f0f\u4e0b\u81ea\u7136\u5de5\u4f5c\uff1a\u8fd9\u662f[\u4f7f\u7528\u6279\u5904\u7406\u751f\u6210\u56fe\u50cf\u7684\u793a\u4f8b\u6f14\u793a](https://github.com/gradio-app/gradio/blob/main/demo/diffusers_with_batching/run.py)\n\n\u6ce8\u610f\uff1a\u4f7f\u7528 Gradio \u7684\u6279\u5904\u7406\u51fd\u6570 **requires** \u5728\u5e95\u5c42 Interface \u6216 Blocks \u4e2d\u542f\u7528\u961f\u5217\uff08\u8bf7\u53c2\u9605\u4e0a\u9762\u7684\u961f\u5217\u90e8\u5206\uff09\u3002\n\n## Gradio \u7b14\u8bb0\u672c (Colab Notebooks)\n\nGradio \u53ef\u4ee5\u5728\u4efb\u4f55\u8fd0\u884c Python \u7684\u5730\u65b9\u8fd0\u884c\uff0c\u5305\u62ec\u672c\u5730 Jupyter \u7b14\u8bb0\u672c\u548c\u534f\u4f5c\u7b14\u8bb0\u672c\uff0c\u5982[Google Colab](https://colab.research.google.com/)\u3002\u5bf9\u4e8e\u672c\u5730 Jupyter \u7b14\u8bb0\u672c\u548c Google Colab \u7b14\u8bb0\u672c\uff0cGradio \u5728\u672c\u5730\u670d\u52a1\u5668\u4e0a\u8fd0\u884c\uff0c\u60a8\u53ef\u4ee5\u5728\u6d4f\u89c8\u5668\u4e2d\u4e0e\u4e4b\u4ea4\u4e92\u3002\uff08\u6ce8\u610f\uff1a\u5bf9\u4e8e Google Colab\uff0c\u8fd9\u662f\u901a\u8fc7[\u670d\u52a1\u5de5\u4f5c\u5668\u96a7\u9053](https://github.com/tensorflow/tensorboard/blob/master/docs/design/colab_integration.md)\u5b9e\u73b0\u7684\uff0c\u60a8\u7684\u6d4f\u89c8\u5668\u9700\u8981\u542f\u7528 cookies\u3002\uff09\u5bf9\u4e8e\u5176\u4ed6\u8fdc\u7a0b\u7b14\u8bb0\u672c\uff0cGradio \u4e5f\u5c06\u5728\u670d\u52a1\u5668\u4e0a\u8fd0\u884c\uff0c\u4f46\u60a8\u9700\u8981\u4f7f\u7528[SSH \u96a7\u9053](https://coderwall.com/p/ohk6cg/remote-access-to-ipython-notebooks-via-ssh)\u5728\u672c\u5730\u6d4f\u89c8\u5668\u4e2d\u67e5\u770b\u5e94\u7528\u7a0b\u5e8f\u3002\u901a\u5e38\uff0c\u66f4\u7b80\u5355\u7684\u9009\u62e9\u662f\u4f7f\u7528 Gradio \u5185\u7f6e\u7684\u516c\u5171\u94fe\u63a5\uff0c[\u5728\u4e0b\u4e00\u7bc7\u6307\u5357\u4e2d\u8ba8\u8bba](/sharing-your-app/#sharing-demos)\u3002\n--New Chunk--\n[Created at: 2025-03-24 13:16:48]\n\u65f6\u5fc5\u987b\u9009\u62e9\u5176\u4e2d\u4e00\u4e2a\u5b57\u7b26\u4e32\uff0c\u8fd9\u5c06\u4f5c\u4e3a\u9644\u52a0\u5217\u4fdd\u5b58\u5230 CSV \u4e2d\u3002\n\n## \u9884\u5904\u7406\u548c\u540e\u5904\u7406 (Preprocessing and Postprocessing)\n\n![annotated](/assets/img/dataflow.svg)\n\n\u5982\u60a8\u6240\u89c1\uff0cGradio \u5305\u62ec\u53ef\u4ee5\u5904\u7406\u5404\u79cd\u4e0d\u540c\u6570\u636e\u7c7b\u578b\u7684\u7ec4\u4ef6\uff0c\u4f8b\u5982\u56fe\u50cf\u3001\u97f3\u9891\u548c\u89c6\u9891\u3002\u5927\u591a\u6570\u7ec4\u4ef6\u90fd\u53ef\u4ee5\u7528\u4f5c\u8f93\u5165\u6216\u8f93\u51fa\u3002\n\n\u5f53\u7ec4\u4ef6\u7528\u4f5c\u8f93\u5165\u65f6\uff0cGradio \u81ea\u52a8\u5904\u7406*\u9884\u5904\u7406*\uff0c\u5c06\u6570\u636e\u4ece\u7528\u6237\u6d4f\u89c8\u5668\u53d1\u9001\u7684\u7c7b\u578b\uff08\u4f8b\u5982\u7f51\u7edc\u6444\u50cf\u5934\u5feb\u7167\u7684 base64 \u8868\u793a\uff09\u8f6c\u6362\u4e3a\u60a8\u7684\u51fd\u6570\u53ef\u4ee5\u63a5\u53d7\u7684\u5f62\u5f0f\uff08\u4f8b\u5982 `numpy` \u6570\u7ec4\uff09\u3002\n\n\u540c\u6837\uff0c\u5f53\u7ec4\u4ef6\u7528\u4f5c\u8f93\u51fa\u65f6\uff0cGradio \u81ea\u52a8\u5904\u7406*\u540e\u5904\u7406*\uff0c\u5c06\u6570\u636e\u4ece\u51fd\u6570\u8fd4\u56de\u7684\u5f62\u5f0f\uff08\u4f8b\u5982\u56fe\u50cf\u8def\u5f84\u5217\u8868\uff09\u8f6c\u6362\u4e3a\u53ef\u4ee5\u5728\u7528\u6237\u6d4f\u89c8\u5668\u4e2d\u663e\u793a\u7684\u5f62\u5f0f\uff08\u4f8b\u5982\u4ee5 base64 \u683c\u5f0f\u663e\u793a\u56fe\u50cf\u7684 `Gallery`\uff09\u3002\n\n\u60a8\u53ef\u4ee5\u4f7f\u7528\u6784\u5efa\u56fe\u50cf\u7ec4\u4ef6\u65f6\u7684\u53c2\u6570\u63a7\u5236*\u9884\u5904\u7406*\u3002\u4f8b\u5982\uff0c\u5982\u679c\u60a8\u4f7f\u7528\u4ee5\u4e0b\u53c2\u6570\u5b9e\u4f8b\u5316 `Image` \u7ec4\u4ef6\uff0c\u5b83\u5c06\u5c06\u56fe\u50cf\u8f6c\u6362\u4e3a `PIL` \u7c7b\u578b\uff0c\u5e76\u5c06\u5176\u91cd\u5851\u4e3a`(100, 100)`\uff0c\u800c\u4e0d\u7ba1\u63d0\u4ea4\u65f6\u7684\u539f\u59cb\u5927\u5c0f\u5982\u4f55\uff1a\n\n```py\nimg = gr.Image(shape=(100, 100), type=\"pil\")\n```\n\n\u76f8\u53cd\uff0c\u8fd9\u91cc\u6211\u4eec\u4fdd\u7559\u56fe\u50cf\u7684\u539f\u59cb\u5927\u5c0f\uff0c\u4f46\u5728\u5c06\u5176\u8f6c\u6362\u4e3a numpy \u6570\u7ec4\u4e4b\u524d\u53cd\u8f6c\u989c\u8272\uff1a\n\n```py\nimg = gr.Image(invert_colors=True, type=\"numpy\")\n```\n\n\u540e\u5904\u7406\u8981\u5bb9\u6613\u5f97\u591a\uff01Gradio \u81ea\u52a8\u8bc6\u522b\u8fd4\u56de\u6570\u636e\u7684\u683c\u5f0f\uff08\u4f8b\u5982 `Image` \u662f `numpy` \u6570\u7ec4\u8fd8\u662f `str` \u6587\u4ef6\u8def\u5f84\uff1f\uff09\uff0c\u5e76\u5c06\u5176\u540e\u5904\u7406\u4e3a\u53ef\u4ee5\u7531\u6d4f\u89c8\u5668\u663e\u793a\u7684\u683c\u5f0f\u3002\n\n\u8bf7\u67e5\u770b[\u6587\u6863](https://gradio.app/docs)\uff0c\u4e86\u89e3\u6bcf\u4e2a\u7ec4\u4ef6\u7684\u6240\u6709\u4e0e\u9884\u5904\u7406\u76f8\u5173\u7684\u53c2\u6570\u3002\n\n## \u6837\u5f0f (Styling)\n\nGradio \u4e3b\u9898\u662f\u81ea\u5b9a\u4e49\u5e94\u7528\u7a0b\u5e8f\u5916\u89c2\u548c\u611f\u89c9\u7684\u6700\u7b80\u5355\u65b9\u6cd5\u3002\u60a8\u53ef\u4ee5\u9009\u62e9\u591a\u79cd\u4e3b\u9898\u6216\u521b\u5efa\u81ea\u5df1\u7684\u4e3b\u9898\u3002\u8981\u8fd9\u6837\u505a\uff0c\u8bf7\u5c06 `theme=` \u53c2\u6570\u4f20\u9012\u7ed9 `Interface` \u6784\u9020\u51fd\u6570\u3002\u4f8b\u5982\uff1a\n\n```python\ndemo = gr.Interface(..., theme=gr.themes.Monochrome())\n```\n\nGradio \u5e26\u6709\u4e00\u7ec4\u9884\u5148\u6784\u5efa\u7684\u4e3b\u9898\uff0c\u60a8\u53ef\u4ee5\u4ece `gr.themes.*` \u52a0\u8f7d\u3002\u60a8\u53ef\u4ee5\u6269\u5c55\u8fd9\u4e9b\u4e3b\u9898\u6216\u4ece\u5934\u5f00\u59cb\u521b\u5efa\u81ea\u5df1\u7684\u4e3b\u9898 - \u6709\u5173\u66f4\u591a\u8be6\u7ec6\u4fe1\u606f\uff0c\u8bf7\u53c2\u9605[\u4e3b\u9898\u6307\u5357](https://gradio.app/theming-guide)\u3002\n\n\u8981\u589e\u52a0\u989d\u5916\u7684\u6837\u5f0f\u80fd\u529b\uff0c\u60a8\u53ef\u4ee5 with `css=` \u5173\u952e\u5b57\u5c06\u4efb\u4f55 CSS \u4f20\u9012\u7ed9\u60a8\u7684\u5e94\u7528\u7a0b\u5e8f\u3002\nGradio \u5e94\u7528\u7a0b\u5e8f\u7684\u57fa\u7c7b\u662f `gradio-container`\uff0c\u56e0\u6b64\u4ee5\u4e0b\u662f\u4e00\u4e2a\u66f4\u6539 Gradio \u5e94\u7528\u7a0b\u5e8f\u80cc\u666f\u989c\u8272\u7684\u793a\u4f8b\uff1a\n\n```python\nwith `gr.Interface(css=\".gradio-container {background-color: red}\") as demo:\n    ...\n```\n\n## \u961f\u5217 (Queuing)\n\n\u5982\u679c\u60a8\u7684\u5e94\u7528\u7a0b\u5e8f\u9884\u8ba1\u4f1a\u6709\u5927\u91cf\u6d41\u91cf\uff0c\u8bf7 with `queue()` \u65b9\u6cd5\u6765\u63a7\u5236\u5904\u7406\u901f\u7387\u3002\u8fd9\u5c06\u6392\u961f\u5904\u7406\u8c03\u7528\uff0c\u56e0\u6b64\u4e00\u6b21\u53ea\u5904\u7406\u4e00\u5b9a\u6570\u91cf\u7684\u8bf7\u6c42\u3002\u961f\u5217\u4f7f\u7528 Websockets\uff0c\u8fd8\u53ef\u4ee5\u9632\u6b62\u7f51\u7edc\u8d85\u65f6\uff0c\u56e0\u6b64\u5982\u679c\u60a8\u7684\u51fd\u6570\u7684\u63a8\u7406\u65f6\u95f4\u5f88\u957f\uff08> 1 \u5206\u949f\uff09\uff0c\u5e94\u4f7f\u7528\u961f\u5217\u3002\n\nwith `Interface`\uff1a\n\n```python\ndemo = gr.Interface(...).queue()\ndemo.launch()\n```\n\nwith `Blocks`\uff1a\n\n```python\nwith gr.Blocks() as demo\uff1a\n    #...\ndemo.queue()\ndemo.launch()\n```\n\n\u60a8\u53ef\u4ee5\u901a\u8fc7\u4ee5\u4e0b\u65b9\u5f0f\u63a7\u5236\u4e00\u6b21\u5904\u7406\u7684\u8bf7\u6c42\u6570\u91cf\uff1a\n\n```python\ndemo.queue(concurrency_count=3)\n```\n\n\u67e5\u770b\u6709\u5173\u914d\u7f6e\u5176\u4ed6\u961f\u5217\u53c2\u6570\u7684[\u961f\u5217\u6587\u6863](/docs/#queue)\u3002\n\n\u5728 Blocks \u4e2d\u6307\u5b9a\u4ec5\u5bf9\u67d0\u4e9b\u51fd\u6570\u8fdb\u884c\u6392\u961f\uff1a\n\n```python\nwith gr.Blocks() as demo2\uff1a\n    num1 = gr.Number()\n    num2 = gr.Number()\n    output = gr.Number()\n    gr.Button(\"Add\").click(\n        lambda a, b: a + b, [num1, num2], output)\n    gr.Button(\"Multiply\").click(\n        lambda a, b: a * b, [num1, num2], output, queue=True)\ndemo2.launch()\n```\n\n## \u8fed\u4ee3\u8f93\u51fa (Iterative Outputs)\n\n\u5728\u67d0\u4e9b\u60c5\u51b5\u4e0b\uff0c\u60a8\u53ef\u80fd\u9700\u8981\u4f20\u8f93\u4e00\u7cfb\u5217\u8f93\u51fa\u800c\u4e0d\u662f\u4e00\u6b21\u663e\u793a\u5355\u4e2a\u8f93\u51fa\u3002\u4f8b\u5982\uff0c\u60a8\u53ef\u80fd\u6709\u4e00\u4e2a\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5e0c\u671b\u663e\u793a\u751f\u6210\u7684\u6bcf\u4e2a\u6b65\u9aa4\u7684\u56fe\u50cf\uff0c\u76f4\u5230\u6700\u7ec8\u56fe\u50cf\u3002\u6216\u8005\u60a8\u53ef\u80fd\u6709\u4e00\u4e2a\u804a\u5929\u673a\u5668\u4eba\uff0c\u5b83\u9010\u5b57\u9010\u53e5\u5730\u6d41\u5f0f\u4f20\u8f93\u54cd\u5e94\uff0c\u800c\u4e0d\u662f\u4e00\u6b21\u8fd4\u56de\u5168\u90e8\u54cd\u5e94\u3002\n\n\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u60a8\u53ef\u4ee5\u5c06**\u751f\u6210\u5668**\u51fd\u6570\u63d0\u4f9b\u7ed9 Gradio\uff0c\u800c\u4e0d\u662f\u5e38\u89c4\u51fd\u6570\u3002\u5728 Python \u4e2d\u521b\u5efa\u751f\u6210\u5668\u975e\u5e38\u7b80\u5355\uff1a\u51fd\u6570\u4e0d\u5e94\u8be5\u6709\u4e00\u4e2a\u5355\u72ec\u7684 `return` \u503c\uff0c\u800c\u662f\u5e94\u8be5 with `yield` \u8fde\u7eed\u8fd4\u56de\u4e00\u7cfb\u5217\u503c\u3002\u901a\u5e38\uff0c`yield` \u8bed\u53e5\u653e\u7f6e\u5728\u67d0\u79cd\u5faa\u73af\u4e2d\u3002\u4e0b\u9762\u662f\u4e00\u4e2a\u7b80\u5355\u793a\u4f8b\uff0c\u751f\u6210\u5668\u53ea\u662f\u7b80\u5355\u8ba1\u6570\u5230\u7ed9\u5b9a\u6570\u5b57\uff1a\n\n```python\ndef my_generator(x):\n    for i in range(x):\n        yield i\n```\n\n\u60a8\u4ee5\u4e0e\u5e38\u89c4\u51fd\u6570\u76f8\u540c\u7684\u65b9\u5f0f\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio\u3002\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\uff08\u865a\u62df\u7684\uff09\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5b83\u5728\u8f93\u51fa\u56fe\u50cf\u4e4b\u524d\u751f\u6210\u6570\u4e2a\u6b65\u9aa4\u7684\u566a\u97f3\uff1a\n\n$code_fake_diffusion\n$demo_fake_diffusion\n\n\u8bf7\u6ce8\u610f\uff0c\u6211\u4eec\u5728\u8fed\u4ee3\u5668\u4e2d\u6dfb\u52a0\u4e86 `time.sleep(1)`\uff0c\u4ee5\u521b\u5efa\u6b65\u9aa4\u4e4b\u95f4\u7684\u4eba\u5de5\u6682\u505c\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u89c2\u5bdf\u8fed\u4ee3\u5668\u7684\u6b65\u9aa4\uff08\u5728\u771f\u5b9e\u7684\u56fe\u50cf\u751f\u6210\u6a21\u578b\u4e2d\uff0c\u8fd9"
        }
    },
    {
        "sample_idx": 30,
        "question": "What is the advantage of using batch functions in Gradio?",
        "answer": "Using batch functions allows Gradio servers to automatically batch incoming requests and process them in parallel, potentially speeding up demo speed.",
        "rag_answer": "**Advantages of Batch Functions in Gradio**\n\nBatch functions in Gradio offer several advantages, particularly when it comes to handling multiple requests efficiently. The primary benefits of using batch functions include:\n\n### **Faster Processing**\n\nBy processing batches of requests simultaneously, batch functions can significantly reduce the overall processing time. This is especially important when dealing with computationally expensive models or large datasets.\n\n### **Improved Throughput**\n\nBatch functions enable Gradio to handle multiple requests in parallel, increasing the throughput of your application. This means you can serve more users and requests without sacrificing performance.\n\n### **Enhanced Scalability**\n\nBatch functions make it easier to scale your Gradio application to handle large volumes of traffic. By processing requests in batches, you can efficiently utilize system resources, reducing the likelihood of bottlenecks and performance degradation.\n\n### **Simplified Queue Management**\n\nWhen using batch functions, Gradio automatically manages the queue of incoming requests. This simplifies the process of handling concurrent requests and reduces the complexity of implementing custom queuing mechanisms.\n\nIn summary, batch functions in Gradio provide a powerful way to optimize the performance, scalability, and throughput of your application, making it an ideal choice for handling large volumes of requests efficiently.\n\nReferences:\n[KG] Batch Functions (Gradio Documentation)\n[DC] Gradio Demo: Batch Functions",
        "rag_score": 4,
        "rag_feedback": "The system's response is mostly correct, accurate, and factual. It provides a detailed explanation of the advantages of using batch functions in Gradio, including faster demo speed, improved throughput, and enhanced scalability. The response also mentions the requirement of enabling queuing in the underlying Interface or Blocks to use batch functions. However, the response is overly lengthy and includes unnecessary information, making it difficult to focus on the main point.",
        "rag_context": {
            "kg_context": "-----Entities-----\n    ```csv\n    id,\tentity,\ttype,\tdescription,\trankcreated_at\n1,\tBatch Functions,category,Batch Functions is a category of functions in Gradio that enables the processing of batches of inputs.,1,2025-03-24 13:17:31\n2,\tGradio,organization,Gradio is a platform that supports state in Blocks, providing features such as global state and session state.<SEP>Gradio is an interface that provides various features for demonstrating models, including adding example inputs, custom error messages, descriptive content, flagging, and more.<SEP>Gradio is an organization that provides a platform for building and deploying machine learning models.<SEP>Gradio is an organization that provides a platform for creating and deploying machine learning models.<SEP>Gradio is an organization that provides a demo for blocks_random_slider, and its library is used to create interactive interfaces.,36,2025-03-24 13:17:31\n3,\tqueue,category,Queue is a component in Gradio that enables the processing of batches of inputs.,1,2025-03-24 13:17:31\n4,\tPreprocessing and Postprocessing,category,Preprocessing and Postprocessing are features in Gradio that allow users to process data before and after it is input into a model.,1,2025-03-24 13:17:31\n5,\tBatch Functions,category,Batch Functions is a category of functions in Gradio that enables the processing of batches of inputs.,1,UNKNOWN\n6,\tfunc,event,func is an event that occurs when the button is clicked, executing a specific function.,1,UNKNOWN\n7,\tqueue,category,Queue is a component in Gradio that enables the processing of batches of inputs.,1,UNKNOWN\n    ```\n    -----Relationships-----\n    ```csv\n    id,\tsource,\ttarget,\tdescription,\tkeywords,\tweight,\trank,\tcreated_at\n1,\tBatch Functions,Gradio,Gradio supports batch processing of inputs using batch functions.,functionality, batch processing,18.0,37,2025-03-24 13:17:31\n2,\tGradio,queue,Queue is a component in Gradio that enables batch processing.,component relationship, batch processing,8.0,37,2025-03-24 13:17:31\n3,\tGradio,Preprocessing and Postprocessing,Gradio provides features for preprocessing and postprocessing data.,data processing, interface feature,8.0,37,2025-03-24 13:17:31\n4,\tBatch Functions,Gradio,Gradio supports batch processing of inputs using batch functions.,functionality, batch processing,18.0,37,UNKNOWN\n5,\tGradio,queue,Queue is a component in Gradio that enables batch processing.,component relationship, batch processing,8.0,37,UNKNOWN\n6,\tGradio Demo,func,func is an event that occurs in Gradio Demo when the button is clicked.,event, event,8.0,9,UNKNOWN\n    ```\n    -----Sources-----\n    ```csv\n    id,\tcontent\n1,\t\u4e0e\u5e38\u89c4\u51fd\u6570\u76f8\u540c\u7684\u65b9\u5f0f\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio\u3002\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\uff08\u865a\u62df\u7684\uff09\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5b83\u5728\u8f93\u51fa\u56fe\u50cf\u4e4b\u524d\u751f\u6210\u6570\u4e2a\u6b65\u9aa4\u7684\u566a\u97f3\uff1a\n\n$code_fake_diffusion\n$demo_fake_diffusion\n\n\u8bf7\u6ce8\u610f\uff0c\u6211\u4eec\u5728\u8fed\u4ee3\u5668\u4e2d\u6dfb\u52a0\u4e86 `time.sleep(1)`\uff0c\u4ee5\u521b\u5efa\u6b65\u9aa4\u4e4b\u95f4\u7684\u4eba\u5de5\u6682\u505c\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u89c2\u5bdf\u8fed\u4ee3\u5668\u7684\u6b65\u9aa4\uff08\u5728\u771f\u5b9e\u7684\u56fe\u50cf\u751f\u6210\u6a21\u578b\u4e2d\uff0c\u8fd9\u53ef\u80fd\u662f\u4e0d\u5fc5\u8981\u7684\uff09\u3002\n\n\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio **\u9700\u8981**\u5728\u5e95\u5c42 Interface \u6216 Blocks \u4e2d\u542f\u7528\u961f\u5217\uff08\u8bf7\u53c2\u9605\u4e0a\u9762\u7684\u961f\u5217\u90e8\u5206\uff09\u3002\n\n## \u8fdb\u5ea6\u6761\n\nGradio \u652f\u6301\u521b\u5efa\u81ea\u5b9a\u4e49\u8fdb\u5ea6\u6761\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u81ea\u5b9a\u4e49\u548c\u63a7\u5236\u5411\u7528\u6237\u663e\u793a\u7684\u8fdb\u5ea6\u66f4\u65b0\u3002\u8981\u542f\u7528\u6b64\u529f\u80fd\uff0c\u53ea\u9700\u4e3a\u65b9\u6cd5\u6dfb\u52a0\u4e00\u4e2a\u9ed8\u8ba4\u503c\u4e3a `gr.Progress` \u5b9e\u4f8b\u7684\u53c2\u6570\u5373\u53ef\u3002\u7136\u540e\uff0c\u60a8\u53ef\u4ee5\u76f4\u63a5\u8c03\u7528\u6b64\u5b9e\u4f8b\u5e76\u4f20\u5165 0 \u5230 1 \u4e4b\u95f4\u7684\u6d6e\u70b9\u6570\u6765\u66f4\u65b0\u8fdb\u5ea6\u7ea7\u522b\uff0c\u6216\u8005 with `Progress` \u5b9e\u4f8b\u7684 `tqdm()` \u65b9\u6cd5\u6765\u8ddf\u8e2a\u53ef\u8fed\u4ee3\u5bf9\u8c61\u4e0a\u7684\u8fdb\u5ea6\uff0c\u5982\u4e0b\u6240\u793a\u3002\u5fc5\u987b\u542f\u7528\u961f\u5217\u4ee5\u8fdb\u884c\u8fdb\u5ea6\u66f4\u65b0\u3002\n\n$code_progress_simple\n$demo_progress_simple\n\n\u5982\u679c\u60a8 with `tqdm` \u5e93\uff0c\u5e76\u4e14\u5e0c\u671b\u4ece\u51fd\u6570\u5185\u90e8\u7684\u4efb\u4f55 `tqdm.tqdm` \u81ea\u52a8\u62a5\u544a\u8fdb\u5ea6\u66f4\u65b0\uff0c\u8bf7\u5c06\u9ed8\u8ba4\u53c2\u6570\u8bbe\u7f6e\u4e3a `gr.Progress(track_tqdm=True)`\uff01\n\n## \u6279\u5904\u7406\u51fd\u6570 (Batch Functions)\n\nGradio \u652f\u6301\u4f20\u9012*\u6279\u5904\u7406*\u51fd\u6570\u3002\u6279\u5904\u7406\u51fd\u6570\u53ea\u662f\u63a5\u53d7\u8f93\u5165\u5217\u8868\u5e76\u8fd4\u56de\u9884\u6d4b\u5217\u8868\u7684\u51fd\u6570\u3002\n\n\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\u6279\u5904\u7406\u51fd\u6570\uff0c\u5b83\u63a5\u53d7\u4e24\u4e2a\u8f93\u5165\u5217\u8868\uff08\u4e00\u4e2a\u5355\u8bcd\u5217\u8868\u548c\u4e00\u4e2a\u6574\u6570\u5217\u8868\uff09\uff0c\u5e76\u8fd4\u56de\u4fee\u526a\u8fc7\u7684\u5355\u8bcd\u5217\u8868\u4f5c\u4e3a\u8f93\u51fa\uff1a\n\n```python\nimport time\n\ndef trim_words(words, lens):\n    trimmed_words = []\n    time.sleep(5)\n    for w, l in zip(words, lens):\n        trimmed_words.append(w[:int(l)])\n    return [trimmed_words]\n    for w, l in zip(words, lens):\n```\n\n\u4f7f\u7528\u6279\u5904\u7406\u51fd\u6570\u7684\u4f18\u70b9\u662f\uff0c\u5982\u679c\u542f\u7528\u4e86\u961f\u5217\uff0cGradio \u670d\u52a1\u5668\u53ef\u4ee5\u81ea\u52a8*\u6279\u5904\u7406*\u4f20\u5165\u7684\u8bf7\u6c42\u5e76\u5e76\u884c\u5904\u7406\u5b83\u4eec\uff0c\u4ece\u800c\u53ef\u80fd\u52a0\u5feb\u6f14\u793a\u901f\u5ea6\u3002\u4ee5\u4e0b\u662f Gradio \u4ee3\u7801\u7684\u793a\u4f8b\uff08\u8bf7\u6ce8\u610f `batch=True` \u548c `max_batch_size=16` - \u8fd9\u4e24\u4e2a\u53c2\u6570\u90fd\u53ef\u4ee5\u4f20\u9012\u7ed9\u4e8b\u4ef6\u89e6\u53d1\u5668\u6216 `Interface` \u7c7b\uff09\n\nwith `Interface`\uff1a\n\n```python\ndemo = gr.Interface(trim_words, [\"textbox\", \"number\"], [\"output\"],\n                    batch=True, max_batch_size=16)\ndemo.queue()\ndemo.launch()\n```\n\nwith `Blocks`\uff1a\n\n```python\nimport gradio as gr\n\nwith gr.Blocks() as demo:\n    with gr.Row():\n        word = gr.Textbox(label=\"word\")\n        leng = gr.Number(label=\"leng\")\n        output = gr.Textbox(label=\"Output\")\n    with gr.Row():\n        run = gr.Button()\n\n    event = run.click(trim_words, [word, leng], output, batch=True, max_batch_size=16)\n\ndemo.queue()\ndemo.launch()\n```\n\n\u5728\u4e0a\u9762\u7684\u793a\u4f8b\u4e2d\uff0c\u53ef\u4ee5\u5e76\u884c\u5904\u7406 16 \u4e2a\u8bf7\u6c42\uff08\u603b\u63a8\u7406\u65f6\u95f4\u4e3a 5 \u79d2\uff09\uff0c\u800c\u4e0d\u662f\u5206\u522b\u5904\u7406\u6bcf\u4e2a\u8bf7\u6c42\uff08\u603b\u63a8\u7406\u65f6\u95f4\u4e3a 80 \u79d2\uff09\u3002\u8bb8\u591a Hugging Face \u7684 `transformers` \u548c `diffusers` \u6a21\u578b\u5728 Gradio \u7684\u6279\u5904\u7406\u6a21\u5f0f\u4e0b\u81ea\u7136\u5de5\u4f5c\uff1a\u8fd9\u662f[\u4f7f\u7528\u6279\u5904\u7406\u751f\u6210\u56fe\u50cf\u7684\u793a\u4f8b\u6f14\u793a](https://github.com/gradio-app/gradio/blob/main/demo/diffusers_with_batching/run.py)\n\n\u6ce8\u610f\uff1a\u4f7f\u7528 Gradio \u7684\u6279\u5904\u7406\u51fd\u6570 **requires** \u5728\u5e95\u5c42 Interface \u6216 Blocks \u4e2d\u542f\u7528\u961f\u5217\uff08\u8bf7\u53c2\u9605\u4e0a\u9762\u7684\u961f\u5217\u90e8\u5206\uff09\u3002\n\n## Gradio \u7b14\u8bb0\u672c (Colab Notebooks)\n\nGradio \u53ef\u4ee5\u5728\u4efb\u4f55\u8fd0\u884c Python \u7684\u5730\u65b9\u8fd0\u884c\uff0c\u5305\u62ec\u672c\u5730 Jupyter \u7b14\u8bb0\u672c\u548c\u534f\u4f5c\u7b14\u8bb0\u672c\uff0c\u5982[Google Colab](https://colab.research.google.com/)\u3002\u5bf9\u4e8e\u672c\u5730 Jupyter \u7b14\u8bb0\u672c\u548c Google Colab \u7b14\u8bb0\u672c\uff0cGradio \u5728\u672c\u5730\u670d\u52a1\u5668\u4e0a\u8fd0\u884c\uff0c\u60a8\u53ef\u4ee5\u5728\u6d4f\u89c8\u5668\u4e2d\u4e0e\u4e4b\u4ea4\u4e92\u3002\uff08\u6ce8\u610f\uff1a\u5bf9\u4e8e Google Colab\uff0c\u8fd9\u662f\u901a\u8fc7[\u670d\u52a1\u5de5\u4f5c\u5668\u96a7\u9053](https://github.com/tensorflow/tensorboard/blob/master/docs/design/colab_integration.md)\u5b9e\u73b0\u7684\uff0c\u60a8\u7684\u6d4f\u89c8\u5668\u9700\u8981\u542f\u7528 cookies\u3002\uff09\u5bf9\u4e8e\u5176\u4ed6\u8fdc\u7a0b\u7b14\u8bb0\u672c\uff0cGradio \u4e5f\u5c06\u5728\u670d\u52a1\u5668\u4e0a\u8fd0\u884c\uff0c\u4f46\u60a8\u9700\u8981\u4f7f\u7528[SSH \u96a7\u9053](https://coderwall.com/p/ohk6cg/remote-access-to-ipython-notebooks-via-ssh)\u5728\u672c\u5730\u6d4f\u89c8\u5668\u4e2d\u67e5\u770b\u5e94\u7528\u7a0b\u5e8f\u3002\u901a\u5e38\uff0c\u66f4\u7b80\u5355\u7684\u9009\u62e9\u662f\u4f7f\u7528 Gradio \u5185\u7f6e\u7684\u516c\u5171\u94fe\u63a5\uff0c[\u5728\u4e0b\u4e00\u7bc7\u6307\u5357\u4e2d\u8ba8\u8bba](/sharing-your-app/#sharing-demos)\u3002\n2,\t\u4e3b\u8981\u7279\u70b9\n\n\u8ba9\u6211\u4eec\u6765\u4ecb\u7ecd\u4e00\u4e0b Gradio \u6700\u53d7\u6b22\u8fce\u7684\u4e00\u4e9b\u529f\u80fd\uff01\u8fd9\u91cc\u662f Gradio \u7684\u4e3b\u8981\u7279\u70b9\uff1a\n\n1. [\u6dfb\u52a0\u793a\u4f8b\u8f93\u5165](#example-inputs)\n2. [\u4f20\u9012\u81ea\u5b9a\u4e49\u9519\u8bef\u6d88\u606f](#errors)\n3. [\u6dfb\u52a0\u63cf\u8ff0\u5185\u5bb9](#descriptive-content)\n4. [\u8bbe\u7f6e\u65d7\u6807](#flagging)\n5. [\u9884\u5904\u7406\u548c\u540e\u5904\u7406](#preprocessing-and-postprocessing)\n6. [\u6837\u5f0f\u5316\u6f14\u793a](#styling)\n7. [\u6392\u961f\u7528\u6237](#queuing)\n8. [\u8fed\u4ee3\u8f93\u51fa](#iterative-outputs)\n9. [\u8fdb\u5ea6\u6761](#progress-bars)\n10. [\u6279\u5904\u7406\u51fd\u6570](#batch-functions)\n11. [\u5728\u534f\u4f5c\u7b14\u8bb0\u672c\u4e0a\u8fd0\u884c](#colab-notebooks)\n\n## \u793a\u4f8b\u8f93\u5165\n\n\u60a8\u53ef\u4ee5\u63d0\u4f9b\u7528\u6237\u53ef\u4ee5\u8f7b\u677e\u52a0\u8f7d\u5230 \"Interface\" \u4e2d\u7684\u793a\u4f8b\u6570\u636e\u3002\u8fd9\u5bf9\u4e8e\u6f14\u793a\u6a21\u578b\u671f\u671b\u7684\u8f93\u5165\u7c7b\u578b\u4ee5\u53ca\u6f14\u793a\u6570\u636e\u96c6\u548c\u6a21\u578b\u4e00\u8d77\u63a2\u7d22\u7684\u65b9\u5f0f\u975e\u5e38\u6709\u5e2e\u52a9\u3002\u8981\u52a0\u8f7d\u793a\u4f8b\u6570\u636e\uff0c\u60a8\u53ef\u4ee5\u5c06\u5d4c\u5957\u5217\u8868\u63d0\u4f9b\u7ed9 Interface \u6784\u9020\u51fd\u6570\u7684 `examples=` \u5173\u952e\u5b57\u53c2\u6570\u3002\u5916\u90e8\u5217\u8868\u4e2d\u7684\u6bcf\u4e2a\u5b50\u5217\u8868\u8868\u793a\u4e00\u4e2a\u6570\u636e\u6837\u672c\uff0c\u5b50\u5217\u8868\u4e2d\u7684\u6bcf\u4e2a\u5143\u7d20\u8868\u793a\u6bcf\u4e2a\u8f93\u5165\u7ec4\u4ef6\u7684\u8f93\u5165\u3002\u6709\u5173\u6bcf\u4e2a\u7ec4\u4ef6\u7684\u793a\u4f8b\u6570\u636e\u683c\u5f0f\u5728[Docs](https://gradio.app/docs#components)\u4e2d\u6709\u8bf4\u660e\u3002\n\n$code_calculator\n$demo_calculator\n\n\u60a8\u53ef\u4ee5\u5c06\u5927\u578b\u6570\u636e\u96c6\u52a0\u8f7d\u5230\u793a\u4f8b\u4e2d\uff0c\u901a\u8fc7 Gradio \u6d4f\u89c8\u548c\u4e0e\u6570\u636e\u96c6\u8fdb\u884c\u4ea4\u4e92\u3002\u793a\u4f8b\u5c06\u81ea\u52a8\u5206\u9875\uff08\u53ef\u4ee5\u901a\u8fc7 Interface \u7684 `examples_per_page` \u53c2\u6570\u8fdb\u884c\u914d\u7f6e\uff09\u3002\n\n\u7ee7\u7eed\u4e86\u89e3\u793a\u4f8b\uff0c\u8bf7\u53c2\u9605[\u66f4\u591a\u793a\u4f8b](https://gradio.app/more-on-examples)\u6307\u5357\u3002\n\n## \u9519\u8bef\n\n\u60a8\u5e0c\u671b\u5411\u7528\u6237\u4f20\u9012\u81ea\u5b9a\u4e49\u9519\u8bef\u6d88\u606f\u3002\u4e3a\u6b64\uff0cwith `gr.Error(\"custom message\")` \u6765\u663e\u793a\u9519\u8bef\u6d88\u606f\u3002\u5982\u679c\u5728\u4e0a\u9762\u7684\u8ba1\u7b97\u5668\u793a\u4f8b\u4e2d\u5c1d\u8bd5\u9664\u4ee5\u96f6\uff0c\u5c06\u663e\u793a\u81ea\u5b9a\u4e49\u9519\u8bef\u6d88\u606f\u7684\u5f39\u51fa\u6a21\u6001\u7a97\u53e3\u3002\u4e86\u89e3\u6709\u5173\u9519\u8bef\u7684\u66f4\u591a\u4fe1\u606f\uff0c\u8bf7\u53c2\u9605[\u6587\u6863](https://gradio.app/docs#error)\u3002\n\n## \u63cf\u8ff0\u6027\u5185\u5bb9\n\n\u5728\u524d\u9762\u7684\u793a\u4f8b\u4e2d\uff0c\u60a8\u53ef\u80fd\u5df2\u7ecf\u6ce8\u610f\u5230 Interface \u6784\u9020\u51fd\u6570\u4e2d\u7684 `title=` \u548c `description=` \u5173\u952e\u5b57\u53c2\u6570\uff0c\u5e2e\u52a9\u7528\u6237\u4e86\u89e3\u60a8\u7684\u5e94\u7528\u7a0b\u5e8f\u3002\n\nInterface \u6784\u9020\u51fd\u6570\u4e2d\u6709\u4e09\u4e2a\u53c2\u6570\u7528\u4e8e\u6307\u5b9a\u6b64\u5185\u5bb9\u5e94\u653e\u7f6e\u5728\u54ea\u91cc\uff1a\n\n- `title`\uff1a\u63a5\u53d7\u6587\u672c\uff0c\u5e76\u53ef\u4ee5\u5c06\u5176\u663e\u793a\u5728\u754c\u9762\u7684\u9876\u90e8\uff0c\u4e5f\u5c06\u6210\u4e3a\u9875\u9762\u6807\u9898\u3002\n- `description`\uff1a\u63a5\u53d7\u6587\u672c\u3001Markdown \u6216 HTML\uff0c\u5e76\u5c06\u5176\u653e\u7f6e\u5728\u6807\u9898\u6b63\u4e0b\u65b9\u3002\n- `article`\uff1a\u4e5f\u63a5\u53d7\u6587\u672c\u3001Markdown \u6216 HTML\uff0c\u5e76\u5c06\u5176\u653e\u7f6e\u5728\u754c\u9762\u4e0b\u65b9\u3002\n\n![annotated](/assets/guides/annotated.png)\n\n\u5982\u679c\u60a8\u4f7f\u7528\u7684\u662f `Blocks` API\uff0c\u5219\u53ef\u4ee5 with `gr.Markdown(...)` \u6216 `gr.HTML(...)` \u7ec4\u4ef6\u5728\u4efb\u4f55\u4f4d\u7f6e\u63d2\u5165\u6587\u672c\u3001Markdown \u6216 HTML\uff0c\u5176\u4e2d\u63cf\u8ff0\u6027\u5185\u5bb9\u4f4d\u4e8e `Component` \u6784\u9020\u51fd\u6570\u5185\u90e8\u3002\n\n\u53e6\u4e00\u4e2a\u6709\u7528\u7684\u5173\u952e\u5b57\u53c2\u6570\u662f `label=`\uff0c\u5b83\u5b58\u5728\u4e8e\u6bcf\u4e2a `Component` \u4e2d\u3002\u8fd9\u4fee\u6539\u4e86\u6bcf\u4e2a `Component` \u9876\u90e8\u7684\u6807\u7b7e\u6587\u672c\u3002\u8fd8\u53ef\u4ee5\u4e3a\u8bf8\u5982 `Textbox` \u6216 `Radio` \u4e4b\u7c7b\u7684\u8868\u5355\u5143\u7d20\u6dfb\u52a0 `info=` \u5173\u952e\u5b57\u53c2\u6570\uff0c\u4ee5\u63d0\u4f9b\u6709\u5173\u5176\u7528\u6cd5\u7684\u8fdb\u4e00\u6b65\u4fe1\u606f\u3002\n\n```python\ngr.Number(label='\u5e74\u9f84', info='\u4ee5\u5e74\u4e3a\u5355\u4f4d\uff0c\u5fc5\u987b\u5927\u4e8e0')\n```\n\n## \u65d7\u6807\n\n\u9ed8\u8ba4\u60c5\u51b5\u4e0b\uff0c\"Interface\" \u5c06\u6709\u4e00\u4e2a \"Flag\" \u6309\u94ae\u3002\u5f53\u7528\u6237\u6d4b\u8bd5\u60a8\u7684 `Interface` \u65f6\uff0c\u5982\u679c\u770b\u5230\u6709\u8da3\u7684\u8f93\u51fa\uff0c\u4f8b\u5982\u9519\u8bef\u6216\u610f\u5916\u7684\u6a21\u578b\u884c\u4e3a\uff0c\u4ed6\u4eec\u53ef\u4ee5\u5c06\u8f93\u5165\u6807\u8bb0\u4e3a\u60a8\u8fdb\u884c\u67e5\u770b\u3002\u5728\u7531 `Interface` \u6784\u9020\u51fd\u6570\u7684 `flagging_dir=` \u53c2\u6570\u63d0\u4f9b\u7684\u76ee\u5f55\u4e2d\uff0c\u5c06\u8bb0\u5f55\u6807\u8bb0\u7684\u8f93\u5165\u5230\u4e00\u4e2a CSV \u6587\u4ef6\u4e2d\u3002\u5982\u679c\u754c\u9762\u6d89\u53ca\u6587\u4ef6\u6570\u636e\uff0c\u4f8b\u5982\u56fe\u50cf\u548c\u97f3\u9891\u7ec4\u4ef6\uff0c\u5c06\u521b\u5efa\u6587\u4ef6\u5939\u6765\u5b58\u50a8\u8fd9\u4e9b\u6807\u8bb0\u7684\u6570\u636e\u3002\n\n\u4f8b\u5982\uff0c\u5bf9\u4e8e\u4e0a\u9762\u663e\u793a\u7684\u8ba1\u7b97\u5668\u754c\u9762\uff0c\u6211\u4eec\u5c06\u5728\u4e0b\u9762\u7684\u65d7\u6807\u76ee\u5f55\u4e2d\u5b58\u50a8\u6807\u8bb0\u7684\u6570\u636e\uff1a\n\n```directory\n+-- calculator.py\n+-- flagged/\n|   +-- logs.csv\n```\n\n_flagged/logs.csv_\n\n```csv\nnum1,operation,num2,Output\n5,add,7,12\n6,subtract,1.5,4.5\n```\n\n\u4e0e\u65e9\u671f\u663e\u793a\u7684\u51b7\u8272\u754c\u9762\u76f8\u5bf9\u5e94\uff0c\u6211\u4eec\u5c06\u5728\u4e0b\u9762\u7684\u65d7\u6807\u76ee\u5f55\u4e2d\u5b58\u50a8\u6807\u8bb0\u7684\u6570\u636e\uff1a\n\n```directory\n+-- sepia.py\n+-- flagged/\n|   +-- logs.csv\n|   +-- im/\n|   |   +-- 0.png\n|   |   +-- 1.png\n|   +-- Output/\n|   |   +-- 0.png\n|   |   +-- 1.png\n```\n\n_flagged/logs.csv_\n\n```csv\nim,Output\nim/0.png,Output/0.png\nim/1.png,Output/1.png\n```\n\n\u5982\u679c\u60a8\u5e0c\u671b\u7528\u6237\u63d0\u4f9b\u65d7\u6807\u539f\u56e0\uff0c\u53ef\u4ee5\u5c06\u5b57\u7b26\u4e32\u5217\u8868\u4f20\u9012\u7ed9 Interface \u7684 `flagging_options` \u53c2\u6570\u3002\u7528\u6237\u5728\u8fdb\u884c\u65d7\u6807\u65f6\u5fc5\u987b\u9009\u62e9\u5176\u4e2d\u4e00\u4e2a\u5b57\u7b26\u4e32\uff0c\u8fd9\u5c06\u4f5c\u4e3a\u9644\u52a0\u5217\u4fdd\u5b58\u5230 CSV \u4e2d\u3002\n\n## \u9884\u5904\u7406\u548c\u540e\u5904\u7406 (Preprocessing and Postprocessing)\n\n![annotated](/assets/img/dataflow.svg)\n\n\u5982\u60a8\u6240\u89c1\uff0cGradio \u5305\u62ec\u53ef\u4ee5\u5904\u7406\u5404\u79cd\u4e0d\u540c\u6570\u636e\u7c7b\u578b\u7684\u7ec4\u4ef6\uff0c\u4f8b\u5982\u56fe\u50cf\u3001\u97f3\u9891\u548c\u89c6\u9891\u3002\u5927\u591a\u6570\u7ec4\u4ef6\u90fd\u53ef\u4ee5\u7528\u4f5c\u8f93\u5165\u6216\u8f93\u51fa\u3002\n\n\u5f53\u7ec4\u4ef6\u7528\u4f5c\u8f93\u5165\u65f6\uff0cGradio \u81ea\u52a8\u5904\u7406*\u9884\u5904\u7406*\uff0c\u5c06\u6570\u636e\u4ece\u7528\u6237\n3,\tGradio Demo: blocks_random_slider\n\n\n```\n!pip install -q gradio \n```\n\n\n```\n\nimport gradio as gr\n\n\ndef func(slider_1, slider_2):\n    return slider_1 * 5 + slider_2\n\n\nwith gr.Blocks() as demo:\n    slider = gr.Slider(minimum=-10.2, maximum=15, label=\"Random Slider (Static)\", randomize=True)\n    slider_1 = gr.Slider(minimum=100, maximum=200, label=\"Random Slider (Input 1)\", randomize=True)\n    slider_2 = gr.Slider(minimum=10, maximum=23.2, label=\"Random Slider (Input 2)\", randomize=True)\n    slider_3 = gr.Slider(value=3, label=\"Non random slider\")\n    btn = gr.Button(\"Run\")\n    btn.click(func, inputs=[slider_1, slider_2], outputs=gr.Number())\n\nif __name__ == \"__main__\":\n    demo.launch()\n\n```\n    ```",
            "vector_context": "[Created at: 2025-03-24 13:16:48]\n\u4e3b\u8981\u7279\u70b9\n\n\u8ba9\u6211\u4eec\u6765\u4ecb\u7ecd\u4e00\u4e0b Gradio \u6700\u53d7\u6b22\u8fce\u7684\u4e00\u4e9b\u529f\u80fd\uff01\u8fd9\u91cc\u662f Gradio \u7684\u4e3b\u8981\u7279\u70b9\uff1a\n\n1. [\u6dfb\u52a0\u793a\u4f8b\u8f93\u5165](#example-inputs)\n2. [\u4f20\u9012\u81ea\u5b9a\u4e49\u9519\u8bef\u6d88\u606f](#errors)\n3. [\u6dfb\u52a0\u63cf\u8ff0\u5185\u5bb9](#descriptive-content)\n4. [\u8bbe\u7f6e\u65d7\u6807](#flagging)\n5. [\u9884\u5904\u7406\u548c\u540e\u5904\u7406](#preprocessing-and-postprocessing)\n6. [\u6837\u5f0f\u5316\u6f14\u793a](#styling)\n7. [\u6392\u961f\u7528\u6237](#queuing)\n8. [\u8fed\u4ee3\u8f93\u51fa](#iterative-outputs)\n9. [\u8fdb\u5ea6\u6761](#progress-bars)\n10. [\u6279\u5904\u7406\u51fd\u6570](#batch-functions)\n11. [\u5728\u534f\u4f5c\u7b14\u8bb0\u672c\u4e0a\u8fd0\u884c](#colab-notebooks)\n\n## \u793a\u4f8b\u8f93\u5165\n\n\u60a8\u53ef\u4ee5\u63d0\u4f9b\u7528\u6237\u53ef\u4ee5\u8f7b\u677e\u52a0\u8f7d\u5230 \"Interface\" \u4e2d\u7684\u793a\u4f8b\u6570\u636e\u3002\u8fd9\u5bf9\u4e8e\u6f14\u793a\u6a21\u578b\u671f\u671b\u7684\u8f93\u5165\u7c7b\u578b\u4ee5\u53ca\u6f14\u793a\u6570\u636e\u96c6\u548c\u6a21\u578b\u4e00\u8d77\u63a2\u7d22\u7684\u65b9\u5f0f\u975e\u5e38\u6709\u5e2e\u52a9\u3002\u8981\u52a0\u8f7d\u793a\u4f8b\u6570\u636e\uff0c\u60a8\u53ef\u4ee5\u5c06\u5d4c\u5957\u5217\u8868\u63d0\u4f9b\u7ed9 Interface \u6784\u9020\u51fd\u6570\u7684 `examples=` \u5173\u952e\u5b57\u53c2\u6570\u3002\u5916\u90e8\u5217\u8868\u4e2d\u7684\u6bcf\u4e2a\u5b50\u5217\u8868\u8868\u793a\u4e00\u4e2a\u6570\u636e\u6837\u672c\uff0c\u5b50\u5217\u8868\u4e2d\u7684\u6bcf\u4e2a\u5143\u7d20\u8868\u793a\u6bcf\u4e2a\u8f93\u5165\u7ec4\u4ef6\u7684\u8f93\u5165\u3002\u6709\u5173\u6bcf\u4e2a\u7ec4\u4ef6\u7684\u793a\u4f8b\u6570\u636e\u683c\u5f0f\u5728[Docs](https://gradio.app/docs#components)\u4e2d\u6709\u8bf4\u660e\u3002\n\n$code_calculator\n$demo_calculator\n\n\u60a8\u53ef\u4ee5\u5c06\u5927\u578b\u6570\u636e\u96c6\u52a0\u8f7d\u5230\u793a\u4f8b\u4e2d\uff0c\u901a\u8fc7 Gradio \u6d4f\u89c8\u548c\u4e0e\u6570\u636e\u96c6\u8fdb\u884c\u4ea4\u4e92\u3002\u793a\u4f8b\u5c06\u81ea\u52a8\u5206\u9875\uff08\u53ef\u4ee5\u901a\u8fc7 Interface \u7684 `examples_per_page` \u53c2\u6570\u8fdb\u884c\u914d\u7f6e\uff09\u3002\n\n\u7ee7\u7eed\u4e86\u89e3\u793a\u4f8b\uff0c\u8bf7\u53c2\u9605[\u66f4\u591a\u793a\u4f8b](https://gradio.app/more-on-examples)\u6307\u5357\u3002\n\n## \u9519\u8bef\n\n\u60a8\u5e0c\u671b\u5411\u7528\u6237\u4f20\u9012\u81ea\u5b9a\u4e49\u9519\u8bef\u6d88\u606f\u3002\u4e3a\u6b64\uff0cwith `gr.Error(\"custom message\")` \u6765\u663e\u793a\u9519\u8bef\u6d88\u606f\u3002\u5982\u679c\u5728\u4e0a\u9762\u7684\u8ba1\u7b97\u5668\u793a\u4f8b\u4e2d\u5c1d\u8bd5\u9664\u4ee5\u96f6\uff0c\u5c06\u663e\u793a\u81ea\u5b9a\u4e49\u9519\u8bef\u6d88\u606f\u7684\u5f39\u51fa\u6a21\u6001\u7a97\u53e3\u3002\u4e86\u89e3\u6709\u5173\u9519\u8bef\u7684\u66f4\u591a\u4fe1\u606f\uff0c\u8bf7\u53c2\u9605[\u6587\u6863](https://gradio.app/docs#error)\u3002\n\n## \u63cf\u8ff0\u6027\u5185\u5bb9\n\n\u5728\u524d\u9762\u7684\u793a\u4f8b\u4e2d\uff0c\u60a8\u53ef\u80fd\u5df2\u7ecf\u6ce8\u610f\u5230 Interface \u6784\u9020\u51fd\u6570\u4e2d\u7684 `title=` \u548c `description=` \u5173\u952e\u5b57\u53c2\u6570\uff0c\u5e2e\u52a9\u7528\u6237\u4e86\u89e3\u60a8\u7684\u5e94\u7528\u7a0b\u5e8f\u3002\n\nInterface \u6784\u9020\u51fd\u6570\u4e2d\u6709\u4e09\u4e2a\u53c2\u6570\u7528\u4e8e\u6307\u5b9a\u6b64\u5185\u5bb9\u5e94\u653e\u7f6e\u5728\u54ea\u91cc\uff1a\n\n- `title`\uff1a\u63a5\u53d7\u6587\u672c\uff0c\u5e76\u53ef\u4ee5\u5c06\u5176\u663e\u793a\u5728\u754c\u9762\u7684\u9876\u90e8\uff0c\u4e5f\u5c06\u6210\u4e3a\u9875\u9762\u6807\u9898\u3002\n- `description`\uff1a\u63a5\u53d7\u6587\u672c\u3001Markdown \u6216 HTML\uff0c\u5e76\u5c06\u5176\u653e\u7f6e\u5728\u6807\u9898\u6b63\u4e0b\u65b9\u3002\n- `article`\uff1a\u4e5f\u63a5\u53d7\u6587\u672c\u3001Markdown \u6216 HTML\uff0c\u5e76\u5c06\u5176\u653e\u7f6e\u5728\u754c\u9762\u4e0b\u65b9\u3002\n\n![annotated](/assets/guides/annotated.png)\n\n\u5982\u679c\u60a8\u4f7f\u7528\u7684\u662f `Blocks` API\uff0c\u5219\u53ef\u4ee5 with `gr.Markdown(...)` \u6216 `gr.HTML(...)` \u7ec4\u4ef6\u5728\u4efb\u4f55\u4f4d\u7f6e\u63d2\u5165\u6587\u672c\u3001Markdown \u6216 HTML\uff0c\u5176\u4e2d\u63cf\u8ff0\u6027\u5185\u5bb9\u4f4d\u4e8e `Component` \u6784\u9020\u51fd\u6570\u5185\u90e8\u3002\n\n\u53e6\u4e00\u4e2a\u6709\u7528\u7684\u5173\u952e\u5b57\u53c2\u6570\u662f `label=`\uff0c\u5b83\u5b58\u5728\u4e8e\u6bcf\u4e2a `Component` \u4e2d\u3002\u8fd9\u4fee\u6539\u4e86\u6bcf\u4e2a `Component` \u9876\u90e8\u7684\u6807\u7b7e\u6587\u672c\u3002\u8fd8\u53ef\u4ee5\u4e3a\u8bf8\u5982 `Textbox` \u6216 `Radio` \u4e4b\u7c7b\u7684\u8868\u5355\u5143\u7d20\u6dfb\u52a0 `info=` \u5173\u952e\u5b57\u53c2\u6570\uff0c\u4ee5\u63d0\u4f9b\u6709\u5173\u5176\u7528\u6cd5\u7684\u8fdb\u4e00\u6b65\u4fe1\u606f\u3002\n\n```python\ngr.Number(label='\u5e74\u9f84', info='\u4ee5\u5e74\u4e3a\u5355\u4f4d\uff0c\u5fc5\u987b\u5927\u4e8e0')\n```\n\n## \u65d7\u6807\n\n\u9ed8\u8ba4\u60c5\u51b5\u4e0b\uff0c\"Interface\" \u5c06\u6709\u4e00\u4e2a \"Flag\" \u6309\u94ae\u3002\u5f53\u7528\u6237\u6d4b\u8bd5\u60a8\u7684 `Interface` \u65f6\uff0c\u5982\u679c\u770b\u5230\u6709\u8da3\u7684\u8f93\u51fa\uff0c\u4f8b\u5982\u9519\u8bef\u6216\u610f\u5916\u7684\u6a21\u578b\u884c\u4e3a\uff0c\u4ed6\u4eec\u53ef\u4ee5\u5c06\u8f93\u5165\u6807\u8bb0\u4e3a\u60a8\u8fdb\u884c\u67e5\u770b\u3002\u5728\u7531 `Interface` \u6784\u9020\u51fd\u6570\u7684 `flagging_dir=` \u53c2\u6570\u63d0\u4f9b\u7684\u76ee\u5f55\u4e2d\uff0c\u5c06\u8bb0\u5f55\u6807\u8bb0\u7684\u8f93\u5165\u5230\u4e00\u4e2a CSV \u6587\u4ef6\u4e2d\u3002\u5982\u679c\u754c\u9762\u6d89\u53ca\u6587\u4ef6\u6570\u636e\uff0c\u4f8b\u5982\u56fe\u50cf\u548c\u97f3\u9891\u7ec4\u4ef6\uff0c\u5c06\u521b\u5efa\u6587\u4ef6\u5939\u6765\u5b58\u50a8\u8fd9\u4e9b\u6807\u8bb0\u7684\u6570\u636e\u3002\n\n\u4f8b\u5982\uff0c\u5bf9\u4e8e\u4e0a\u9762\u663e\u793a\u7684\u8ba1\u7b97\u5668\u754c\u9762\uff0c\u6211\u4eec\u5c06\u5728\u4e0b\u9762\u7684\u65d7\u6807\u76ee\u5f55\u4e2d\u5b58\u50a8\u6807\u8bb0\u7684\u6570\u636e\uff1a\n\n```directory\n+-- calculator.py\n+-- flagged/\n|   +-- logs.csv\n```\n\n_flagged/logs.csv_\n\n```csv\nnum1,operation,num2,Output\n5,add,7,12\n6,subtract,1.5,4.5\n```\n\n\u4e0e\u65e9\u671f\u663e\u793a\u7684\u51b7\u8272\u754c\u9762\u76f8\u5bf9\u5e94\uff0c\u6211\u4eec\u5c06\u5728\u4e0b\u9762\u7684\u65d7\u6807\u76ee\u5f55\u4e2d\u5b58\u50a8\u6807\u8bb0\u7684\u6570\u636e\uff1a\n\n```directory\n+-- sepia.py\n+-- flagged/\n|   +-- logs.csv\n|   +-- im/\n|   |   +-- 0.png\n|   |   +-- 1.png\n|   +-- Output/\n|   |   +-- 0.png\n|   |   +-- 1.png\n```\n\n_flagged/logs.csv_\n\n```csv\nim,Output\nim/0.png,Output/0.png\nim/1.png,Output/1.png\n```\n\n\u5982\u679c\u60a8\u5e0c\u671b\u7528\u6237\u63d0\u4f9b\u65d7\u6807\u539f\u56e0\uff0c\u53ef\u4ee5\u5c06\u5b57\u7b26\u4e32\u5217\u8868\u4f20\u9012\u7ed9 Interface \u7684 `flagging_options` \u53c2\u6570\u3002\u7528\u6237\u5728\u8fdb\u884c\u65d7\u6807\u65f6\u5fc5\u987b\u9009\u62e9\u5176\u4e2d\u4e00\u4e2a\u5b57\u7b26\u4e32\uff0c\u8fd9\u5c06\u4f5c\u4e3a\u9644\u52a0\u5217\u4fdd\u5b58\u5230 CSV \u4e2d\u3002\n\n## \u9884\u5904\u7406\u548c\u540e\u5904\u7406 (Preprocessing and Postprocessing)\n\n![annotated](/assets/img/dataflow.svg)\n\n\u5982\u60a8\u6240\u89c1\uff0cGradio \u5305\u62ec\u53ef\u4ee5\u5904\u7406\u5404\u79cd\u4e0d\u540c\u6570\u636e\u7c7b\u578b\u7684\u7ec4\u4ef6\uff0c\u4f8b\u5982\u56fe\u50cf\u3001\u97f3\u9891\u548c\u89c6\u9891\u3002\u5927\u591a\u6570\u7ec4\u4ef6\u90fd\u53ef\u4ee5\u7528\u4f5c\u8f93\u5165\u6216\u8f93\u51fa\u3002\n\n\u5f53\u7ec4\u4ef6\u7528\u4f5c\u8f93\u5165\u65f6\uff0cGradio \u81ea\u52a8\u5904\u7406*\u9884\u5904\u7406*\uff0c\u5c06\u6570\u636e\u4ece\u7528\u6237\n--New Chunk--\n[Created at: 2025-03-24 13:16:48]\n\u4e0e\u5e38\u89c4\u51fd\u6570\u76f8\u540c\u7684\u65b9\u5f0f\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio\u3002\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\uff08\u865a\u62df\u7684\uff09\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5b83\u5728\u8f93\u51fa\u56fe\u50cf\u4e4b\u524d\u751f\u6210\u6570\u4e2a\u6b65\u9aa4\u7684\u566a\u97f3\uff1a\n\n$code_fake_diffusion\n$demo_fake_diffusion\n\n\u8bf7\u6ce8\u610f\uff0c\u6211\u4eec\u5728\u8fed\u4ee3\u5668\u4e2d\u6dfb\u52a0\u4e86 `time.sleep(1)`\uff0c\u4ee5\u521b\u5efa\u6b65\u9aa4\u4e4b\u95f4\u7684\u4eba\u5de5\u6682\u505c\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u89c2\u5bdf\u8fed\u4ee3\u5668\u7684\u6b65\u9aa4\uff08\u5728\u771f\u5b9e\u7684\u56fe\u50cf\u751f\u6210\u6a21\u578b\u4e2d\uff0c\u8fd9\u53ef\u80fd\u662f\u4e0d\u5fc5\u8981\u7684\uff09\u3002\n\n\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio **\u9700\u8981**\u5728\u5e95\u5c42 Interface \u6216 Blocks \u4e2d\u542f\u7528\u961f\u5217\uff08\u8bf7\u53c2\u9605\u4e0a\u9762\u7684\u961f\u5217\u90e8\u5206\uff09\u3002\n\n## \u8fdb\u5ea6\u6761\n\nGradio \u652f\u6301\u521b\u5efa\u81ea\u5b9a\u4e49\u8fdb\u5ea6\u6761\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u81ea\u5b9a\u4e49\u548c\u63a7\u5236\u5411\u7528\u6237\u663e\u793a\u7684\u8fdb\u5ea6\u66f4\u65b0\u3002\u8981\u542f\u7528\u6b64\u529f\u80fd\uff0c\u53ea\u9700\u4e3a\u65b9\u6cd5\u6dfb\u52a0\u4e00\u4e2a\u9ed8\u8ba4\u503c\u4e3a `gr.Progress` \u5b9e\u4f8b\u7684\u53c2\u6570\u5373\u53ef\u3002\u7136\u540e\uff0c\u60a8\u53ef\u4ee5\u76f4\u63a5\u8c03\u7528\u6b64\u5b9e\u4f8b\u5e76\u4f20\u5165 0 \u5230 1 \u4e4b\u95f4\u7684\u6d6e\u70b9\u6570\u6765\u66f4\u65b0\u8fdb\u5ea6\u7ea7\u522b\uff0c\u6216\u8005 with `Progress` \u5b9e\u4f8b\u7684 `tqdm()` \u65b9\u6cd5\u6765\u8ddf\u8e2a\u53ef\u8fed\u4ee3\u5bf9\u8c61\u4e0a\u7684\u8fdb\u5ea6\uff0c\u5982\u4e0b\u6240\u793a\u3002\u5fc5\u987b\u542f\u7528\u961f\u5217\u4ee5\u8fdb\u884c\u8fdb\u5ea6\u66f4\u65b0\u3002\n\n$code_progress_simple\n$demo_progress_simple\n\n\u5982\u679c\u60a8 with `tqdm` \u5e93\uff0c\u5e76\u4e14\u5e0c\u671b\u4ece\u51fd\u6570\u5185\u90e8\u7684\u4efb\u4f55 `tqdm.tqdm` \u81ea\u52a8\u62a5\u544a\u8fdb\u5ea6\u66f4\u65b0\uff0c\u8bf7\u5c06\u9ed8\u8ba4\u53c2\u6570\u8bbe\u7f6e\u4e3a `gr.Progress(track_tqdm=True)`\uff01\n\n## \u6279\u5904\u7406\u51fd\u6570 (Batch Functions)\n\nGradio \u652f\u6301\u4f20\u9012*\u6279\u5904\u7406*\u51fd\u6570\u3002\u6279\u5904\u7406\u51fd\u6570\u53ea\u662f\u63a5\u53d7\u8f93\u5165\u5217\u8868\u5e76\u8fd4\u56de\u9884\u6d4b\u5217\u8868\u7684\u51fd\u6570\u3002\n\n\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\u6279\u5904\u7406\u51fd\u6570\uff0c\u5b83\u63a5\u53d7\u4e24\u4e2a\u8f93\u5165\u5217\u8868\uff08\u4e00\u4e2a\u5355\u8bcd\u5217\u8868\u548c\u4e00\u4e2a\u6574\u6570\u5217\u8868\uff09\uff0c\u5e76\u8fd4\u56de\u4fee\u526a\u8fc7\u7684\u5355\u8bcd\u5217\u8868\u4f5c\u4e3a\u8f93\u51fa\uff1a\n\n```python\nimport time\n\ndef trim_words(words, lens):\n    trimmed_words = []\n    time.sleep(5)\n    for w, l in zip(words, lens):\n        trimmed_words.append(w[:int(l)])\n    return [trimmed_words]\n    for w, l in zip(words, lens):\n```\n\n\u4f7f\u7528\u6279\u5904\u7406\u51fd\u6570\u7684\u4f18\u70b9\u662f\uff0c\u5982\u679c\u542f\u7528\u4e86\u961f\u5217\uff0cGradio \u670d\u52a1\u5668\u53ef\u4ee5\u81ea\u52a8*\u6279\u5904\u7406*\u4f20\u5165\u7684\u8bf7\u6c42\u5e76\u5e76\u884c\u5904\u7406\u5b83\u4eec\uff0c\u4ece\u800c\u53ef\u80fd\u52a0\u5feb\u6f14\u793a\u901f\u5ea6\u3002\u4ee5\u4e0b\u662f Gradio \u4ee3\u7801\u7684\u793a\u4f8b\uff08\u8bf7\u6ce8\u610f `batch=True` \u548c `max_batch_size=16` - \u8fd9\u4e24\u4e2a\u53c2\u6570\u90fd\u53ef\u4ee5\u4f20\u9012\u7ed9\u4e8b\u4ef6\u89e6\u53d1\u5668\u6216 `Interface` \u7c7b\uff09\n\nwith `Interface`\uff1a\n\n```python\ndemo = gr.Interface(trim_words, [\"textbox\", \"number\"], [\"output\"],\n                    batch=True, max_batch_size=16)\ndemo.queue()\ndemo.launch()\n```\n\nwith `Blocks`\uff1a\n\n```python\nimport gradio as gr\n\nwith gr.Blocks() as demo:\n    with gr.Row():\n        word = gr.Textbox(label=\"word\")\n        leng = gr.Number(label=\"leng\")\n        output = gr.Textbox(label=\"Output\")\n    with gr.Row():\n        run = gr.Button()\n\n    event = run.click(trim_words, [word, leng], output, batch=True, max_batch_size=16)\n\ndemo.queue()\ndemo.launch()\n```\n\n\u5728\u4e0a\u9762\u7684\u793a\u4f8b\u4e2d\uff0c\u53ef\u4ee5\u5e76\u884c\u5904\u7406 16 \u4e2a\u8bf7\u6c42\uff08\u603b\u63a8\u7406\u65f6\u95f4\u4e3a 5 \u79d2\uff09\uff0c\u800c\u4e0d\u662f\u5206\u522b\u5904\u7406\u6bcf\u4e2a\u8bf7\u6c42\uff08\u603b\u63a8\u7406\u65f6\u95f4\u4e3a 80 \u79d2\uff09\u3002\u8bb8\u591a Hugging Face \u7684 `transformers` \u548c `diffusers` \u6a21\u578b\u5728 Gradio \u7684\u6279\u5904\u7406\u6a21\u5f0f\u4e0b\u81ea\u7136\u5de5\u4f5c\uff1a\u8fd9\u662f[\u4f7f\u7528\u6279\u5904\u7406\u751f\u6210\u56fe\u50cf\u7684\u793a\u4f8b\u6f14\u793a](https://github.com/gradio-app/gradio/blob/main/demo/diffusers_with_batching/run.py)\n\n\u6ce8\u610f\uff1a\u4f7f\u7528 Gradio \u7684\u6279\u5904\u7406\u51fd\u6570 **requires** \u5728\u5e95\u5c42 Interface \u6216 Blocks \u4e2d\u542f\u7528\u961f\u5217\uff08\u8bf7\u53c2\u9605\u4e0a\u9762\u7684\u961f\u5217\u90e8\u5206\uff09\u3002\n\n## Gradio \u7b14\u8bb0\u672c (Colab Notebooks)\n\nGradio \u53ef\u4ee5\u5728\u4efb\u4f55\u8fd0\u884c Python \u7684\u5730\u65b9\u8fd0\u884c\uff0c\u5305\u62ec\u672c\u5730 Jupyter \u7b14\u8bb0\u672c\u548c\u534f\u4f5c\u7b14\u8bb0\u672c\uff0c\u5982[Google Colab](https://colab.research.google.com/)\u3002\u5bf9\u4e8e\u672c\u5730 Jupyter \u7b14\u8bb0\u672c\u548c Google Colab \u7b14\u8bb0\u672c\uff0cGradio \u5728\u672c\u5730\u670d\u52a1\u5668\u4e0a\u8fd0\u884c\uff0c\u60a8\u53ef\u4ee5\u5728\u6d4f\u89c8\u5668\u4e2d\u4e0e\u4e4b\u4ea4\u4e92\u3002\uff08\u6ce8\u610f\uff1a\u5bf9\u4e8e Google Colab\uff0c\u8fd9\u662f\u901a\u8fc7[\u670d\u52a1\u5de5\u4f5c\u5668\u96a7\u9053](https://github.com/tensorflow/tensorboard/blob/master/docs/design/colab_integration.md)\u5b9e\u73b0\u7684\uff0c\u60a8\u7684\u6d4f\u89c8\u5668\u9700\u8981\u542f\u7528 cookies\u3002\uff09\u5bf9\u4e8e\u5176\u4ed6\u8fdc\u7a0b\u7b14\u8bb0\u672c\uff0cGradio \u4e5f\u5c06\u5728\u670d\u52a1\u5668\u4e0a\u8fd0\u884c\uff0c\u4f46\u60a8\u9700\u8981\u4f7f\u7528[SSH \u96a7\u9053](https://coderwall.com/p/ohk6cg/remote-access-to-ipython-notebooks-via-ssh)\u5728\u672c\u5730\u6d4f\u89c8\u5668\u4e2d\u67e5\u770b\u5e94\u7528\u7a0b\u5e8f\u3002\u901a\u5e38\uff0c\u66f4\u7b80\u5355\u7684\u9009\u62e9\u662f\u4f7f\u7528 Gradio \u5185\u7f6e\u7684\u516c\u5171\u94fe\u63a5\uff0c[\u5728\u4e0b\u4e00\u7bc7\u6307\u5357\u4e2d\u8ba8\u8bba](/sharing-your-app/#sharing-demos)\u3002\n--New Chunk--\n[Created at: 2025-03-24 13:16:48]\n\u65f6\u5fc5\u987b\u9009\u62e9\u5176\u4e2d\u4e00\u4e2a\u5b57\u7b26\u4e32\uff0c\u8fd9\u5c06\u4f5c\u4e3a\u9644\u52a0\u5217\u4fdd\u5b58\u5230 CSV \u4e2d\u3002\n\n## \u9884\u5904\u7406\u548c\u540e\u5904\u7406 (Preprocessing and Postprocessing)\n\n![annotated](/assets/img/dataflow.svg)\n\n\u5982\u60a8\u6240\u89c1\uff0cGradio \u5305\u62ec\u53ef\u4ee5\u5904\u7406\u5404\u79cd\u4e0d\u540c\u6570\u636e\u7c7b\u578b\u7684\u7ec4\u4ef6\uff0c\u4f8b\u5982\u56fe\u50cf\u3001\u97f3\u9891\u548c\u89c6\u9891\u3002\u5927\u591a\u6570\u7ec4\u4ef6\u90fd\u53ef\u4ee5\u7528\u4f5c\u8f93\u5165\u6216\u8f93\u51fa\u3002\n\n\u5f53\u7ec4\u4ef6\u7528\u4f5c\u8f93\u5165\u65f6\uff0cGradio \u81ea\u52a8\u5904\u7406*\u9884\u5904\u7406*\uff0c\u5c06\u6570\u636e\u4ece\u7528\u6237\u6d4f\u89c8\u5668\u53d1\u9001\u7684\u7c7b\u578b\uff08\u4f8b\u5982\u7f51\u7edc\u6444\u50cf\u5934\u5feb\u7167\u7684 base64 \u8868\u793a\uff09\u8f6c\u6362\u4e3a\u60a8\u7684\u51fd\u6570\u53ef\u4ee5\u63a5\u53d7\u7684\u5f62\u5f0f\uff08\u4f8b\u5982 `numpy` \u6570\u7ec4\uff09\u3002\n\n\u540c\u6837\uff0c\u5f53\u7ec4\u4ef6\u7528\u4f5c\u8f93\u51fa\u65f6\uff0cGradio \u81ea\u52a8\u5904\u7406*\u540e\u5904\u7406*\uff0c\u5c06\u6570\u636e\u4ece\u51fd\u6570\u8fd4\u56de\u7684\u5f62\u5f0f\uff08\u4f8b\u5982\u56fe\u50cf\u8def\u5f84\u5217\u8868\uff09\u8f6c\u6362\u4e3a\u53ef\u4ee5\u5728\u7528\u6237\u6d4f\u89c8\u5668\u4e2d\u663e\u793a\u7684\u5f62\u5f0f\uff08\u4f8b\u5982\u4ee5 base64 \u683c\u5f0f\u663e\u793a\u56fe\u50cf\u7684 `Gallery`\uff09\u3002\n\n\u60a8\u53ef\u4ee5\u4f7f\u7528\u6784\u5efa\u56fe\u50cf\u7ec4\u4ef6\u65f6\u7684\u53c2\u6570\u63a7\u5236*\u9884\u5904\u7406*\u3002\u4f8b\u5982\uff0c\u5982\u679c\u60a8\u4f7f\u7528\u4ee5\u4e0b\u53c2\u6570\u5b9e\u4f8b\u5316 `Image` \u7ec4\u4ef6\uff0c\u5b83\u5c06\u5c06\u56fe\u50cf\u8f6c\u6362\u4e3a `PIL` \u7c7b\u578b\uff0c\u5e76\u5c06\u5176\u91cd\u5851\u4e3a`(100, 100)`\uff0c\u800c\u4e0d\u7ba1\u63d0\u4ea4\u65f6\u7684\u539f\u59cb\u5927\u5c0f\u5982\u4f55\uff1a\n\n```py\nimg = gr.Image(shape=(100, 100), type=\"pil\")\n```\n\n\u76f8\u53cd\uff0c\u8fd9\u91cc\u6211\u4eec\u4fdd\u7559\u56fe\u50cf\u7684\u539f\u59cb\u5927\u5c0f\uff0c\u4f46\u5728\u5c06\u5176\u8f6c\u6362\u4e3a numpy \u6570\u7ec4\u4e4b\u524d\u53cd\u8f6c\u989c\u8272\uff1a\n\n```py\nimg = gr.Image(invert_colors=True, type=\"numpy\")\n```\n\n\u540e\u5904\u7406\u8981\u5bb9\u6613\u5f97\u591a\uff01Gradio \u81ea\u52a8\u8bc6\u522b\u8fd4\u56de\u6570\u636e\u7684\u683c\u5f0f\uff08\u4f8b\u5982 `Image` \u662f `numpy` \u6570\u7ec4\u8fd8\u662f `str` \u6587\u4ef6\u8def\u5f84\uff1f\uff09\uff0c\u5e76\u5c06\u5176\u540e\u5904\u7406\u4e3a\u53ef\u4ee5\u7531\u6d4f\u89c8\u5668\u663e\u793a\u7684\u683c\u5f0f\u3002\n\n\u8bf7\u67e5\u770b[\u6587\u6863](https://gradio.app/docs)\uff0c\u4e86\u89e3\u6bcf\u4e2a\u7ec4\u4ef6\u7684\u6240\u6709\u4e0e\u9884\u5904\u7406\u76f8\u5173\u7684\u53c2\u6570\u3002\n\n## \u6837\u5f0f (Styling)\n\nGradio \u4e3b\u9898\u662f\u81ea\u5b9a\u4e49\u5e94\u7528\u7a0b\u5e8f\u5916\u89c2\u548c\u611f\u89c9\u7684\u6700\u7b80\u5355\u65b9\u6cd5\u3002\u60a8\u53ef\u4ee5\u9009\u62e9\u591a\u79cd\u4e3b\u9898\u6216\u521b\u5efa\u81ea\u5df1\u7684\u4e3b\u9898\u3002\u8981\u8fd9\u6837\u505a\uff0c\u8bf7\u5c06 `theme=` \u53c2\u6570\u4f20\u9012\u7ed9 `Interface` \u6784\u9020\u51fd\u6570\u3002\u4f8b\u5982\uff1a\n\n```python\ndemo = gr.Interface(..., theme=gr.themes.Monochrome())\n```\n\nGradio \u5e26\u6709\u4e00\u7ec4\u9884\u5148\u6784\u5efa\u7684\u4e3b\u9898\uff0c\u60a8\u53ef\u4ee5\u4ece `gr.themes.*` \u52a0\u8f7d\u3002\u60a8\u53ef\u4ee5\u6269\u5c55\u8fd9\u4e9b\u4e3b\u9898\u6216\u4ece\u5934\u5f00\u59cb\u521b\u5efa\u81ea\u5df1\u7684\u4e3b\u9898 - \u6709\u5173\u66f4\u591a\u8be6\u7ec6\u4fe1\u606f\uff0c\u8bf7\u53c2\u9605[\u4e3b\u9898\u6307\u5357](https://gradio.app/theming-guide)\u3002\n\n\u8981\u589e\u52a0\u989d\u5916\u7684\u6837\u5f0f\u80fd\u529b\uff0c\u60a8\u53ef\u4ee5 with `css=` \u5173\u952e\u5b57\u5c06\u4efb\u4f55 CSS \u4f20\u9012\u7ed9\u60a8\u7684\u5e94\u7528\u7a0b\u5e8f\u3002\nGradio \u5e94\u7528\u7a0b\u5e8f\u7684\u57fa\u7c7b\u662f `gradio-container`\uff0c\u56e0\u6b64\u4ee5\u4e0b\u662f\u4e00\u4e2a\u66f4\u6539 Gradio \u5e94\u7528\u7a0b\u5e8f\u80cc\u666f\u989c\u8272\u7684\u793a\u4f8b\uff1a\n\n```python\nwith `gr.Interface(css=\".gradio-container {background-color: red}\") as demo:\n    ...\n```\n\n## \u961f\u5217 (Queuing)\n\n\u5982\u679c\u60a8\u7684\u5e94\u7528\u7a0b\u5e8f\u9884\u8ba1\u4f1a\u6709\u5927\u91cf\u6d41\u91cf\uff0c\u8bf7 with `queue()` \u65b9\u6cd5\u6765\u63a7\u5236\u5904\u7406\u901f\u7387\u3002\u8fd9\u5c06\u6392\u961f\u5904\u7406\u8c03\u7528\uff0c\u56e0\u6b64\u4e00\u6b21\u53ea\u5904\u7406\u4e00\u5b9a\u6570\u91cf\u7684\u8bf7\u6c42\u3002\u961f\u5217\u4f7f\u7528 Websockets\uff0c\u8fd8\u53ef\u4ee5\u9632\u6b62\u7f51\u7edc\u8d85\u65f6\uff0c\u56e0\u6b64\u5982\u679c\u60a8\u7684\u51fd\u6570\u7684\u63a8\u7406\u65f6\u95f4\u5f88\u957f\uff08> 1 \u5206\u949f\uff09\uff0c\u5e94\u4f7f\u7528\u961f\u5217\u3002\n\nwith `Interface`\uff1a\n\n```python\ndemo = gr.Interface(...).queue()\ndemo.launch()\n```\n\nwith `Blocks`\uff1a\n\n```python\nwith gr.Blocks() as demo\uff1a\n    #...\ndemo.queue()\ndemo.launch()\n```\n\n\u60a8\u53ef\u4ee5\u901a\u8fc7\u4ee5\u4e0b\u65b9\u5f0f\u63a7\u5236\u4e00\u6b21\u5904\u7406\u7684\u8bf7\u6c42\u6570\u91cf\uff1a\n\n```python\ndemo.queue(concurrency_count=3)\n```\n\n\u67e5\u770b\u6709\u5173\u914d\u7f6e\u5176\u4ed6\u961f\u5217\u53c2\u6570\u7684[\u961f\u5217\u6587\u6863](/docs/#queue)\u3002\n\n\u5728 Blocks \u4e2d\u6307\u5b9a\u4ec5\u5bf9\u67d0\u4e9b\u51fd\u6570\u8fdb\u884c\u6392\u961f\uff1a\n\n```python\nwith gr.Blocks() as demo2\uff1a\n    num1 = gr.Number()\n    num2 = gr.Number()\n    output = gr.Number()\n    gr.Button(\"Add\").click(\n        lambda a, b: a + b, [num1, num2], output)\n    gr.Button(\"Multiply\").click(\n        lambda a, b: a * b, [num1, num2], output, queue=True)\ndemo2.launch()\n```\n\n## \u8fed\u4ee3\u8f93\u51fa (Iterative Outputs)\n\n\u5728\u67d0\u4e9b\u60c5\u51b5\u4e0b\uff0c\u60a8\u53ef\u80fd\u9700\u8981\u4f20\u8f93\u4e00\u7cfb\u5217\u8f93\u51fa\u800c\u4e0d\u662f\u4e00\u6b21\u663e\u793a\u5355\u4e2a\u8f93\u51fa\u3002\u4f8b\u5982\uff0c\u60a8\u53ef\u80fd\u6709\u4e00\u4e2a\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5e0c\u671b\u663e\u793a\u751f\u6210\u7684\u6bcf\u4e2a\u6b65\u9aa4\u7684\u56fe\u50cf\uff0c\u76f4\u5230\u6700\u7ec8\u56fe\u50cf\u3002\u6216\u8005\u60a8\u53ef\u80fd\u6709\u4e00\u4e2a\u804a\u5929\u673a\u5668\u4eba\uff0c\u5b83\u9010\u5b57\u9010\u53e5\u5730\u6d41\u5f0f\u4f20\u8f93\u54cd\u5e94\uff0c\u800c\u4e0d\u662f\u4e00\u6b21\u8fd4\u56de\u5168\u90e8\u54cd\u5e94\u3002\n\n\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u60a8\u53ef\u4ee5\u5c06**\u751f\u6210\u5668**\u51fd\u6570\u63d0\u4f9b\u7ed9 Gradio\uff0c\u800c\u4e0d\u662f\u5e38\u89c4\u51fd\u6570\u3002\u5728 Python \u4e2d\u521b\u5efa\u751f\u6210\u5668\u975e\u5e38\u7b80\u5355\uff1a\u51fd\u6570\u4e0d\u5e94\u8be5\u6709\u4e00\u4e2a\u5355\u72ec\u7684 `return` \u503c\uff0c\u800c\u662f\u5e94\u8be5 with `yield` \u8fde\u7eed\u8fd4\u56de\u4e00\u7cfb\u5217\u503c\u3002\u901a\u5e38\uff0c`yield` \u8bed\u53e5\u653e\u7f6e\u5728\u67d0\u79cd\u5faa\u73af\u4e2d\u3002\u4e0b\u9762\u662f\u4e00\u4e2a\u7b80\u5355\u793a\u4f8b\uff0c\u751f\u6210\u5668\u53ea\u662f\u7b80\u5355\u8ba1\u6570\u5230\u7ed9\u5b9a\u6570\u5b57\uff1a\n\n```python\ndef my_generator(x):\n    for i in range(x):\n        yield i\n```\n\n\u60a8\u4ee5\u4e0e\u5e38\u89c4\u51fd\u6570\u76f8\u540c\u7684\u65b9\u5f0f\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio\u3002\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\uff08\u865a\u62df\u7684\uff09\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5b83\u5728\u8f93\u51fa\u56fe\u50cf\u4e4b\u524d\u751f\u6210\u6570\u4e2a\u6b65\u9aa4\u7684\u566a\u97f3\uff1a\n\n$code_fake_diffusion\n$demo_fake_diffusion\n\n\u8bf7\u6ce8\u610f\uff0c\u6211\u4eec\u5728\u8fed\u4ee3\u5668\u4e2d\u6dfb\u52a0\u4e86 `time.sleep(1)`\uff0c\u4ee5\u521b\u5efa\u6b65\u9aa4\u4e4b\u95f4\u7684\u4eba\u5de5\u6682\u505c\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u89c2\u5bdf\u8fed\u4ee3\u5668\u7684\u6b65\u9aa4\uff08\u5728\u771f\u5b9e\u7684\u56fe\u50cf\u751f\u6210\u6a21\u578b\u4e2d\uff0c\u8fd9"
        }
    },
    {
        "sample_idx": 31,
        "question": "What are the two parameters that can be passed to event triggers or the Interface class in Gradio?",
        "answer": "The two parameters are batch=True and max_batch_size=16.",
        "rag_answer": "The two parameters that can be passed to event triggers or the Interface class in Gradio are `batch=True` and `max_batch_size=16`. These parameters enable batch processing, allowing the Gradio server to automatically batch incoming requests and process them in parallel, potentially speeding up the demo.",
        "rag_score": 5,
        "rag_feedback": "The response is completely correct, accurate, and factual. It provides a detailed explanation of the two parameters that can be passed to event triggers or the Interface class in Gradio, which are batch=True and max_batch_size=16. These parameters enable batch processing, allowing the Gradio server to automatically batch incoming requests and process them in parallel, potentially speeding up the demo.",
        "rag_context": {
            "kg_context": "-----Entities-----\n    ```csv\n    id,\tentity,\ttype,\tdescription,\trankcreated_at\n1,\tBlocks API,category,Blocks API is an API in Gradio that allows users to create interfaces using a block-based structure.,1,2025-03-24 13:18:47\n2,\tGradio,organization,Gradio is a platform that supports state in Blocks, providing features such as global state and session state.<SEP>Gradio is an interface that provides various features for demonstrating models, including adding example inputs, custom error messages, descriptive content, flagging, and more.<SEP>Gradio is an organization that provides a platform for building and deploying machine learning models.<SEP>Gradio is an organization that provides a platform for creating and deploying machine learning models.<SEP>Gradio is an organization that provides a demo for blocks_random_slider, and its library is used to create interactive interfaces.,36,2025-03-24 13:18:47\n3,\tevent,event,Event refers to a specific occurrence or trigger in Gradio.,1,2025-03-24 13:18:47\n4,\tGradio Demo,event,Gradio Demo is an event that showcases the functionality of Gradio's blocks_random_slider.,8,2025-03-24 13:18:47\n5,\tfunc,event,func is an event that occurs when the button is clicked, executing a specific function.,1,2025-03-24 13:18:47\n6,\tfunc,event,func is an event that occurs when the button is clicked, executing a specific function.,1,UNKNOWN\n7,\tTextbox,category,Textbox is a component in Gradio that allows users to input text.,2,UNKNOWN\n8,\tNumber,category,Number is a component in Gradio that allows users to input numbers.,1,UNKNOWN\n    ```\n    -----Relationships-----\n    ```csv\n    id,\tsource,\ttarget,\tdescription,\tkeywords,\tweight,\trank,\tcreated_at\n1,\tBlocks API,Gradio,Gradio provides the Blocks API for creating interfaces.,interface creation, API,9.0,37,2025-03-24 13:17:31\n2,\tGradio,event,Events are used in Gradio to trigger specific actions.,event handling, functionality,7.0,37,2025-03-24 13:17:31\n3,\tGradio Demo,func,func is an event that occurs in Gradio Demo when the button is clicked.,event, event,8.0,9,2025-03-24 13:18:47\n4,\tGradio Demo,func,func is an event that occurs in Gradio Demo when the button is clicked.,event, event,8.0,9,UNKNOWN\n5,\tRadio,Textbox,Textbox and Radio are components in Gradio that allow users to input data.,input components, interface features,7.0,3,UNKNOWN\n6,\tNumber,Textbox,Number is a type of input component in Gradio, similar to Textbox.,input components, interface features,7.0,3,UNKNOWN\n    ```\n    -----Sources-----\n    ```csv\n    id,\tcontent\n1,\t\u4e3b\u8981\u7279\u70b9\n\n\u8ba9\u6211\u4eec\u6765\u4ecb\u7ecd\u4e00\u4e0b Gradio \u6700\u53d7\u6b22\u8fce\u7684\u4e00\u4e9b\u529f\u80fd\uff01\u8fd9\u91cc\u662f Gradio \u7684\u4e3b\u8981\u7279\u70b9\uff1a\n\n1. [\u6dfb\u52a0\u793a\u4f8b\u8f93\u5165](#example-inputs)\n2. [\u4f20\u9012\u81ea\u5b9a\u4e49\u9519\u8bef\u6d88\u606f](#errors)\n3. [\u6dfb\u52a0\u63cf\u8ff0\u5185\u5bb9](#descriptive-content)\n4. [\u8bbe\u7f6e\u65d7\u6807](#flagging)\n5. [\u9884\u5904\u7406\u548c\u540e\u5904\u7406](#preprocessing-and-postprocessing)\n6. [\u6837\u5f0f\u5316\u6f14\u793a](#styling)\n7. [\u6392\u961f\u7528\u6237](#queuing)\n8. [\u8fed\u4ee3\u8f93\u51fa](#iterative-outputs)\n9. [\u8fdb\u5ea6\u6761](#progress-bars)\n10. [\u6279\u5904\u7406\u51fd\u6570](#batch-functions)\n11. [\u5728\u534f\u4f5c\u7b14\u8bb0\u672c\u4e0a\u8fd0\u884c](#colab-notebooks)\n\n## \u793a\u4f8b\u8f93\u5165\n\n\u60a8\u53ef\u4ee5\u63d0\u4f9b\u7528\u6237\u53ef\u4ee5\u8f7b\u677e\u52a0\u8f7d\u5230 \"Interface\" \u4e2d\u7684\u793a\u4f8b\u6570\u636e\u3002\u8fd9\u5bf9\u4e8e\u6f14\u793a\u6a21\u578b\u671f\u671b\u7684\u8f93\u5165\u7c7b\u578b\u4ee5\u53ca\u6f14\u793a\u6570\u636e\u96c6\u548c\u6a21\u578b\u4e00\u8d77\u63a2\u7d22\u7684\u65b9\u5f0f\u975e\u5e38\u6709\u5e2e\u52a9\u3002\u8981\u52a0\u8f7d\u793a\u4f8b\u6570\u636e\uff0c\u60a8\u53ef\u4ee5\u5c06\u5d4c\u5957\u5217\u8868\u63d0\u4f9b\u7ed9 Interface \u6784\u9020\u51fd\u6570\u7684 `examples=` \u5173\u952e\u5b57\u53c2\u6570\u3002\u5916\u90e8\u5217\u8868\u4e2d\u7684\u6bcf\u4e2a\u5b50\u5217\u8868\u8868\u793a\u4e00\u4e2a\u6570\u636e\u6837\u672c\uff0c\u5b50\u5217\u8868\u4e2d\u7684\u6bcf\u4e2a\u5143\u7d20\u8868\u793a\u6bcf\u4e2a\u8f93\u5165\u7ec4\u4ef6\u7684\u8f93\u5165\u3002\u6709\u5173\u6bcf\u4e2a\u7ec4\u4ef6\u7684\u793a\u4f8b\u6570\u636e\u683c\u5f0f\u5728[Docs](https://gradio.app/docs#components)\u4e2d\u6709\u8bf4\u660e\u3002\n\n$code_calculator\n$demo_calculator\n\n\u60a8\u53ef\u4ee5\u5c06\u5927\u578b\u6570\u636e\u96c6\u52a0\u8f7d\u5230\u793a\u4f8b\u4e2d\uff0c\u901a\u8fc7 Gradio \u6d4f\u89c8\u548c\u4e0e\u6570\u636e\u96c6\u8fdb\u884c\u4ea4\u4e92\u3002\u793a\u4f8b\u5c06\u81ea\u52a8\u5206\u9875\uff08\u53ef\u4ee5\u901a\u8fc7 Interface \u7684 `examples_per_page` \u53c2\u6570\u8fdb\u884c\u914d\u7f6e\uff09\u3002\n\n\u7ee7\u7eed\u4e86\u89e3\u793a\u4f8b\uff0c\u8bf7\u53c2\u9605[\u66f4\u591a\u793a\u4f8b](https://gradio.app/more-on-examples)\u6307\u5357\u3002\n\n## \u9519\u8bef\n\n\u60a8\u5e0c\u671b\u5411\u7528\u6237\u4f20\u9012\u81ea\u5b9a\u4e49\u9519\u8bef\u6d88\u606f\u3002\u4e3a\u6b64\uff0cwith `gr.Error(\"custom message\")` \u6765\u663e\u793a\u9519\u8bef\u6d88\u606f\u3002\u5982\u679c\u5728\u4e0a\u9762\u7684\u8ba1\u7b97\u5668\u793a\u4f8b\u4e2d\u5c1d\u8bd5\u9664\u4ee5\u96f6\uff0c\u5c06\u663e\u793a\u81ea\u5b9a\u4e49\u9519\u8bef\u6d88\u606f\u7684\u5f39\u51fa\u6a21\u6001\u7a97\u53e3\u3002\u4e86\u89e3\u6709\u5173\u9519\u8bef\u7684\u66f4\u591a\u4fe1\u606f\uff0c\u8bf7\u53c2\u9605[\u6587\u6863](https://gradio.app/docs#error)\u3002\n\n## \u63cf\u8ff0\u6027\u5185\u5bb9\n\n\u5728\u524d\u9762\u7684\u793a\u4f8b\u4e2d\uff0c\u60a8\u53ef\u80fd\u5df2\u7ecf\u6ce8\u610f\u5230 Interface \u6784\u9020\u51fd\u6570\u4e2d\u7684 `title=` \u548c `description=` \u5173\u952e\u5b57\u53c2\u6570\uff0c\u5e2e\u52a9\u7528\u6237\u4e86\u89e3\u60a8\u7684\u5e94\u7528\u7a0b\u5e8f\u3002\n\nInterface \u6784\u9020\u51fd\u6570\u4e2d\u6709\u4e09\u4e2a\u53c2\u6570\u7528\u4e8e\u6307\u5b9a\u6b64\u5185\u5bb9\u5e94\u653e\u7f6e\u5728\u54ea\u91cc\uff1a\n\n- `title`\uff1a\u63a5\u53d7\u6587\u672c\uff0c\u5e76\u53ef\u4ee5\u5c06\u5176\u663e\u793a\u5728\u754c\u9762\u7684\u9876\u90e8\uff0c\u4e5f\u5c06\u6210\u4e3a\u9875\u9762\u6807\u9898\u3002\n- `description`\uff1a\u63a5\u53d7\u6587\u672c\u3001Markdown \u6216 HTML\uff0c\u5e76\u5c06\u5176\u653e\u7f6e\u5728\u6807\u9898\u6b63\u4e0b\u65b9\u3002\n- `article`\uff1a\u4e5f\u63a5\u53d7\u6587\u672c\u3001Markdown \u6216 HTML\uff0c\u5e76\u5c06\u5176\u653e\u7f6e\u5728\u754c\u9762\u4e0b\u65b9\u3002\n\n![annotated](/assets/guides/annotated.png)\n\n\u5982\u679c\u60a8\u4f7f\u7528\u7684\u662f `Blocks` API\uff0c\u5219\u53ef\u4ee5 with `gr.Markdown(...)` \u6216 `gr.HTML(...)` \u7ec4\u4ef6\u5728\u4efb\u4f55\u4f4d\u7f6e\u63d2\u5165\u6587\u672c\u3001Markdown \u6216 HTML\uff0c\u5176\u4e2d\u63cf\u8ff0\u6027\u5185\u5bb9\u4f4d\u4e8e `Component` \u6784\u9020\u51fd\u6570\u5185\u90e8\u3002\n\n\u53e6\u4e00\u4e2a\u6709\u7528\u7684\u5173\u952e\u5b57\u53c2\u6570\u662f `label=`\uff0c\u5b83\u5b58\u5728\u4e8e\u6bcf\u4e2a `Component` \u4e2d\u3002\u8fd9\u4fee\u6539\u4e86\u6bcf\u4e2a `Component` \u9876\u90e8\u7684\u6807\u7b7e\u6587\u672c\u3002\u8fd8\u53ef\u4ee5\u4e3a\u8bf8\u5982 `Textbox` \u6216 `Radio` \u4e4b\u7c7b\u7684\u8868\u5355\u5143\u7d20\u6dfb\u52a0 `info=` \u5173\u952e\u5b57\u53c2\u6570\uff0c\u4ee5\u63d0\u4f9b\u6709\u5173\u5176\u7528\u6cd5\u7684\u8fdb\u4e00\u6b65\u4fe1\u606f\u3002\n\n```python\ngr.Number(label='\u5e74\u9f84', info='\u4ee5\u5e74\u4e3a\u5355\u4f4d\uff0c\u5fc5\u987b\u5927\u4e8e0')\n```\n\n## \u65d7\u6807\n\n\u9ed8\u8ba4\u60c5\u51b5\u4e0b\uff0c\"Interface\" \u5c06\u6709\u4e00\u4e2a \"Flag\" \u6309\u94ae\u3002\u5f53\u7528\u6237\u6d4b\u8bd5\u60a8\u7684 `Interface` \u65f6\uff0c\u5982\u679c\u770b\u5230\u6709\u8da3\u7684\u8f93\u51fa\uff0c\u4f8b\u5982\u9519\u8bef\u6216\u610f\u5916\u7684\u6a21\u578b\u884c\u4e3a\uff0c\u4ed6\u4eec\u53ef\u4ee5\u5c06\u8f93\u5165\u6807\u8bb0\u4e3a\u60a8\u8fdb\u884c\u67e5\u770b\u3002\u5728\u7531 `Interface` \u6784\u9020\u51fd\u6570\u7684 `flagging_dir=` \u53c2\u6570\u63d0\u4f9b\u7684\u76ee\u5f55\u4e2d\uff0c\u5c06\u8bb0\u5f55\u6807\u8bb0\u7684\u8f93\u5165\u5230\u4e00\u4e2a CSV \u6587\u4ef6\u4e2d\u3002\u5982\u679c\u754c\u9762\u6d89\u53ca\u6587\u4ef6\u6570\u636e\uff0c\u4f8b\u5982\u56fe\u50cf\u548c\u97f3\u9891\u7ec4\u4ef6\uff0c\u5c06\u521b\u5efa\u6587\u4ef6\u5939\u6765\u5b58\u50a8\u8fd9\u4e9b\u6807\u8bb0\u7684\u6570\u636e\u3002\n\n\u4f8b\u5982\uff0c\u5bf9\u4e8e\u4e0a\u9762\u663e\u793a\u7684\u8ba1\u7b97\u5668\u754c\u9762\uff0c\u6211\u4eec\u5c06\u5728\u4e0b\u9762\u7684\u65d7\u6807\u76ee\u5f55\u4e2d\u5b58\u50a8\u6807\u8bb0\u7684\u6570\u636e\uff1a\n\n```directory\n+-- calculator.py\n+-- flagged/\n|   +-- logs.csv\n```\n\n_flagged/logs.csv_\n\n```csv\nnum1,operation,num2,Output\n5,add,7,12\n6,subtract,1.5,4.5\n```\n\n\u4e0e\u65e9\u671f\u663e\u793a\u7684\u51b7\u8272\u754c\u9762\u76f8\u5bf9\u5e94\uff0c\u6211\u4eec\u5c06\u5728\u4e0b\u9762\u7684\u65d7\u6807\u76ee\u5f55\u4e2d\u5b58\u50a8\u6807\u8bb0\u7684\u6570\u636e\uff1a\n\n```directory\n+-- sepia.py\n+-- flagged/\n|   +-- logs.csv\n|   +-- im/\n|   |   +-- 0.png\n|   |   +-- 1.png\n|   +-- Output/\n|   |   +-- 0.png\n|   |   +-- 1.png\n```\n\n_flagged/logs.csv_\n\n```csv\nim,Output\nim/0.png,Output/0.png\nim/1.png,Output/1.png\n```\n\n\u5982\u679c\u60a8\u5e0c\u671b\u7528\u6237\u63d0\u4f9b\u65d7\u6807\u539f\u56e0\uff0c\u53ef\u4ee5\u5c06\u5b57\u7b26\u4e32\u5217\u8868\u4f20\u9012\u7ed9 Interface \u7684 `flagging_options` \u53c2\u6570\u3002\u7528\u6237\u5728\u8fdb\u884c\u65d7\u6807\u65f6\u5fc5\u987b\u9009\u62e9\u5176\u4e2d\u4e00\u4e2a\u5b57\u7b26\u4e32\uff0c\u8fd9\u5c06\u4f5c\u4e3a\u9644\u52a0\u5217\u4fdd\u5b58\u5230 CSV \u4e2d\u3002\n\n## \u9884\u5904\u7406\u548c\u540e\u5904\u7406 (Preprocessing and Postprocessing)\n\n![annotated](/assets/img/dataflow.svg)\n\n\u5982\u60a8\u6240\u89c1\uff0cGradio \u5305\u62ec\u53ef\u4ee5\u5904\u7406\u5404\u79cd\u4e0d\u540c\u6570\u636e\u7c7b\u578b\u7684\u7ec4\u4ef6\uff0c\u4f8b\u5982\u56fe\u50cf\u3001\u97f3\u9891\u548c\u89c6\u9891\u3002\u5927\u591a\u6570\u7ec4\u4ef6\u90fd\u53ef\u4ee5\u7528\u4f5c\u8f93\u5165\u6216\u8f93\u51fa\u3002\n\n\u5f53\u7ec4\u4ef6\u7528\u4f5c\u8f93\u5165\u65f6\uff0cGradio \u81ea\u52a8\u5904\u7406*\u9884\u5904\u7406*\uff0c\u5c06\u6570\u636e\u4ece\u7528\u6237\n2,\t\u4e0e\u5e38\u89c4\u51fd\u6570\u76f8\u540c\u7684\u65b9\u5f0f\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio\u3002\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\uff08\u865a\u62df\u7684\uff09\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5b83\u5728\u8f93\u51fa\u56fe\u50cf\u4e4b\u524d\u751f\u6210\u6570\u4e2a\u6b65\u9aa4\u7684\u566a\u97f3\uff1a\n\n$code_fake_diffusion\n$demo_fake_diffusion\n\n\u8bf7\u6ce8\u610f\uff0c\u6211\u4eec\u5728\u8fed\u4ee3\u5668\u4e2d\u6dfb\u52a0\u4e86 `time.sleep(1)`\uff0c\u4ee5\u521b\u5efa\u6b65\u9aa4\u4e4b\u95f4\u7684\u4eba\u5de5\u6682\u505c\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u89c2\u5bdf\u8fed\u4ee3\u5668\u7684\u6b65\u9aa4\uff08\u5728\u771f\u5b9e\u7684\u56fe\u50cf\u751f\u6210\u6a21\u578b\u4e2d\uff0c\u8fd9\u53ef\u80fd\u662f\u4e0d\u5fc5\u8981\u7684\uff09\u3002\n\n\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio **\u9700\u8981**\u5728\u5e95\u5c42 Interface \u6216 Blocks \u4e2d\u542f\u7528\u961f\u5217\uff08\u8bf7\u53c2\u9605\u4e0a\u9762\u7684\u961f\u5217\u90e8\u5206\uff09\u3002\n\n## \u8fdb\u5ea6\u6761\n\nGradio \u652f\u6301\u521b\u5efa\u81ea\u5b9a\u4e49\u8fdb\u5ea6\u6761\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u81ea\u5b9a\u4e49\u548c\u63a7\u5236\u5411\u7528\u6237\u663e\u793a\u7684\u8fdb\u5ea6\u66f4\u65b0\u3002\u8981\u542f\u7528\u6b64\u529f\u80fd\uff0c\u53ea\u9700\u4e3a\u65b9\u6cd5\u6dfb\u52a0\u4e00\u4e2a\u9ed8\u8ba4\u503c\u4e3a `gr.Progress` \u5b9e\u4f8b\u7684\u53c2\u6570\u5373\u53ef\u3002\u7136\u540e\uff0c\u60a8\u53ef\u4ee5\u76f4\u63a5\u8c03\u7528\u6b64\u5b9e\u4f8b\u5e76\u4f20\u5165 0 \u5230 1 \u4e4b\u95f4\u7684\u6d6e\u70b9\u6570\u6765\u66f4\u65b0\u8fdb\u5ea6\u7ea7\u522b\uff0c\u6216\u8005 with `Progress` \u5b9e\u4f8b\u7684 `tqdm()` \u65b9\u6cd5\u6765\u8ddf\u8e2a\u53ef\u8fed\u4ee3\u5bf9\u8c61\u4e0a\u7684\u8fdb\u5ea6\uff0c\u5982\u4e0b\u6240\u793a\u3002\u5fc5\u987b\u542f\u7528\u961f\u5217\u4ee5\u8fdb\u884c\u8fdb\u5ea6\u66f4\u65b0\u3002\n\n$code_progress_simple\n$demo_progress_simple\n\n\u5982\u679c\u60a8 with `tqdm` \u5e93\uff0c\u5e76\u4e14\u5e0c\u671b\u4ece\u51fd\u6570\u5185\u90e8\u7684\u4efb\u4f55 `tqdm.tqdm` \u81ea\u52a8\u62a5\u544a\u8fdb\u5ea6\u66f4\u65b0\uff0c\u8bf7\u5c06\u9ed8\u8ba4\u53c2\u6570\u8bbe\u7f6e\u4e3a `gr.Progress(track_tqdm=True)`\uff01\n\n## \u6279\u5904\u7406\u51fd\u6570 (Batch Functions)\n\nGradio \u652f\u6301\u4f20\u9012*\u6279\u5904\u7406*\u51fd\u6570\u3002\u6279\u5904\u7406\u51fd\u6570\u53ea\u662f\u63a5\u53d7\u8f93\u5165\u5217\u8868\u5e76\u8fd4\u56de\u9884\u6d4b\u5217\u8868\u7684\u51fd\u6570\u3002\n\n\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\u6279\u5904\u7406\u51fd\u6570\uff0c\u5b83\u63a5\u53d7\u4e24\u4e2a\u8f93\u5165\u5217\u8868\uff08\u4e00\u4e2a\u5355\u8bcd\u5217\u8868\u548c\u4e00\u4e2a\u6574\u6570\u5217\u8868\uff09\uff0c\u5e76\u8fd4\u56de\u4fee\u526a\u8fc7\u7684\u5355\u8bcd\u5217\u8868\u4f5c\u4e3a\u8f93\u51fa\uff1a\n\n```python\nimport time\n\ndef trim_words(words, lens):\n    trimmed_words = []\n    time.sleep(5)\n    for w, l in zip(words, lens):\n        trimmed_words.append(w[:int(l)])\n    return [trimmed_words]\n    for w, l in zip(words, lens):\n```\n\n\u4f7f\u7528\u6279\u5904\u7406\u51fd\u6570\u7684\u4f18\u70b9\u662f\uff0c\u5982\u679c\u542f\u7528\u4e86\u961f\u5217\uff0cGradio \u670d\u52a1\u5668\u53ef\u4ee5\u81ea\u52a8*\u6279\u5904\u7406*\u4f20\u5165\u7684\u8bf7\u6c42\u5e76\u5e76\u884c\u5904\u7406\u5b83\u4eec\uff0c\u4ece\u800c\u53ef\u80fd\u52a0\u5feb\u6f14\u793a\u901f\u5ea6\u3002\u4ee5\u4e0b\u662f Gradio \u4ee3\u7801\u7684\u793a\u4f8b\uff08\u8bf7\u6ce8\u610f `batch=True` \u548c `max_batch_size=16` - \u8fd9\u4e24\u4e2a\u53c2\u6570\u90fd\u53ef\u4ee5\u4f20\u9012\u7ed9\u4e8b\u4ef6\u89e6\u53d1\u5668\u6216 `Interface` \u7c7b\uff09\n\nwith `Interface`\uff1a\n\n```python\ndemo = gr.Interface(trim_words, [\"textbox\", \"number\"], [\"output\"],\n                    batch=True, max_batch_size=16)\ndemo.queue()\ndemo.launch()\n```\n\nwith `Blocks`\uff1a\n\n```python\nimport gradio as gr\n\nwith gr.Blocks() as demo:\n    with gr.Row():\n        word = gr.Textbox(label=\"word\")\n        leng = gr.Number(label=\"leng\")\n        output = gr.Textbox(label=\"Output\")\n    with gr.Row():\n        run = gr.Button()\n\n    event = run.click(trim_words, [word, leng], output, batch=True, max_batch_size=16)\n\ndemo.queue()\ndemo.launch()\n```\n\n\u5728\u4e0a\u9762\u7684\u793a\u4f8b\u4e2d\uff0c\u53ef\u4ee5\u5e76\u884c\u5904\u7406 16 \u4e2a\u8bf7\u6c42\uff08\u603b\u63a8\u7406\u65f6\u95f4\u4e3a 5 \u79d2\uff09\uff0c\u800c\u4e0d\u662f\u5206\u522b\u5904\u7406\u6bcf\u4e2a\u8bf7\u6c42\uff08\u603b\u63a8\u7406\u65f6\u95f4\u4e3a 80 \u79d2\uff09\u3002\u8bb8\u591a Hugging Face \u7684 `transformers` \u548c `diffusers` \u6a21\u578b\u5728 Gradio \u7684\u6279\u5904\u7406\u6a21\u5f0f\u4e0b\u81ea\u7136\u5de5\u4f5c\uff1a\u8fd9\u662f[\u4f7f\u7528\u6279\u5904\u7406\u751f\u6210\u56fe\u50cf\u7684\u793a\u4f8b\u6f14\u793a](https://github.com/gradio-app/gradio/blob/main/demo/diffusers_with_batching/run.py)\n\n\u6ce8\u610f\uff1a\u4f7f\u7528 Gradio \u7684\u6279\u5904\u7406\u51fd\u6570 **requires** \u5728\u5e95\u5c42 Interface \u6216 Blocks \u4e2d\u542f\u7528\u961f\u5217\uff08\u8bf7\u53c2\u9605\u4e0a\u9762\u7684\u961f\u5217\u90e8\u5206\uff09\u3002\n\n## Gradio \u7b14\u8bb0\u672c (Colab Notebooks)\n\nGradio \u53ef\u4ee5\u5728\u4efb\u4f55\u8fd0\u884c Python \u7684\u5730\u65b9\u8fd0\u884c\uff0c\u5305\u62ec\u672c\u5730 Jupyter \u7b14\u8bb0\u672c\u548c\u534f\u4f5c\u7b14\u8bb0\u672c\uff0c\u5982[Google Colab](https://colab.research.google.com/)\u3002\u5bf9\u4e8e\u672c\u5730 Jupyter \u7b14\u8bb0\u672c\u548c Google Colab \u7b14\u8bb0\u672c\uff0cGradio \u5728\u672c\u5730\u670d\u52a1\u5668\u4e0a\u8fd0\u884c\uff0c\u60a8\u53ef\u4ee5\u5728\u6d4f\u89c8\u5668\u4e2d\u4e0e\u4e4b\u4ea4\u4e92\u3002\uff08\u6ce8\u610f\uff1a\u5bf9\u4e8e Google Colab\uff0c\u8fd9\u662f\u901a\u8fc7[\u670d\u52a1\u5de5\u4f5c\u5668\u96a7\u9053](https://github.com/tensorflow/tensorboard/blob/master/docs/design/colab_integration.md)\u5b9e\u73b0\u7684\uff0c\u60a8\u7684\u6d4f\u89c8\u5668\u9700\u8981\u542f\u7528 cookies\u3002\uff09\u5bf9\u4e8e\u5176\u4ed6\u8fdc\u7a0b\u7b14\u8bb0\u672c\uff0cGradio \u4e5f\u5c06\u5728\u670d\u52a1\u5668\u4e0a\u8fd0\u884c\uff0c\u4f46\u60a8\u9700\u8981\u4f7f\u7528[SSH \u96a7\u9053](https://coderwall.com/p/ohk6cg/remote-access-to-ipython-notebooks-via-ssh)\u5728\u672c\u5730\u6d4f\u89c8\u5668\u4e2d\u67e5\u770b\u5e94\u7528\u7a0b\u5e8f\u3002\u901a\u5e38\uff0c\u66f4\u7b80\u5355\u7684\u9009\u62e9\u662f\u4f7f\u7528 Gradio \u5185\u7f6e\u7684\u516c\u5171\u94fe\u63a5\uff0c[\u5728\u4e0b\u4e00\u7bc7\u6307\u5357\u4e2d\u8ba8\u8bba](/sharing-your-app/#sharing-demos)\u3002\n3,\tGradio Demo: blocks_random_slider\n\n\n```\n!pip install -q gradio \n```\n\n\n```\n\nimport gradio as gr\n\n\ndef func(slider_1, slider_2):\n    return slider_1 * 5 + slider_2\n\n\nwith gr.Blocks() as demo:\n    slider = gr.Slider(minimum=-10.2, maximum=15, label=\"Random Slider (Static)\", randomize=True)\n    slider_1 = gr.Slider(minimum=100, maximum=200, label=\"Random Slider (Input 1)\", randomize=True)\n    slider_2 = gr.Slider(minimum=10, maximum=23.2, label=\"Random Slider (Input 2)\", randomize=True)\n    slider_3 = gr.Slider(value=3, label=\"Non random slider\")\n    btn = gr.Button(\"Run\")\n    btn.click(func, inputs=[slider_1, slider_2], outputs=gr.Number())\n\nif __name__ == \"__main__\":\n    demo.launch()\n\n```\n    ```",
            "vector_context": "[Created at: 2025-03-24 13:19:57]\nState in Blocks\n\nWe covered [State in Interfaces](https://gradio.app/interface-state), this guide takes a look at state in Blocks, which works mostly the same.\n\n## Global State\n\nGlobal state in Blocks works the same as in Interface. Any variable created outside a function call is a reference shared between all users.\n\n## Session State\n\nGradio supports session **state**, where data persists across multiple submits within a page session, in Blocks apps as well. To reiterate, session data is _not_ shared between different users of your model. To store data in a session state, you need to do three things:\n\n1. Create a `gr.State()` object. If there is a default value to this stateful object, pass that into the constructor.\n2. In the event listener, put the `State` object as an input and output.\n3. In the event listener function, add the variable to the input parameters and the return value.\n\nLet's take a look at a game of hangman.\n\n$code_hangman\n$demo_hangman\n\nLet's see how we do each of the 3 steps listed above in this game:\n\n1. We store the used letters in `used_letters_var`. In the constructor of `State`, we set the initial value of this to `[]`, an empty list.\n2. In `btn.click()`, we have a reference to `used_letters_var` in both the inputs and outputs.\n3. In `guess_letter`, we pass the value of this `State` to `used_letters`, and then return an updated value of this `State` in the return statement.\n\nWith more complex apps, you will likely have many State variables storing session state in a single Blocks app.\n\nLearn more about `State` in the [docs](https://gradio.app/docs#state).\n--New Chunk--\n[Created at: 2025-03-24 13:16:48]\n\u4e3b\u8981\u7279\u70b9\n\n\u8ba9\u6211\u4eec\u6765\u4ecb\u7ecd\u4e00\u4e0b Gradio \u6700\u53d7\u6b22\u8fce\u7684\u4e00\u4e9b\u529f\u80fd\uff01\u8fd9\u91cc\u662f Gradio \u7684\u4e3b\u8981\u7279\u70b9\uff1a\n\n1. [\u6dfb\u52a0\u793a\u4f8b\u8f93\u5165](#example-inputs)\n2. [\u4f20\u9012\u81ea\u5b9a\u4e49\u9519\u8bef\u6d88\u606f](#errors)\n3. [\u6dfb\u52a0\u63cf\u8ff0\u5185\u5bb9](#descriptive-content)\n4. [\u8bbe\u7f6e\u65d7\u6807](#flagging)\n5. [\u9884\u5904\u7406\u548c\u540e\u5904\u7406](#preprocessing-and-postprocessing)\n6. [\u6837\u5f0f\u5316\u6f14\u793a](#styling)\n7. [\u6392\u961f\u7528\u6237](#queuing)\n8. [\u8fed\u4ee3\u8f93\u51fa](#iterative-outputs)\n9. [\u8fdb\u5ea6\u6761](#progress-bars)\n10. [\u6279\u5904\u7406\u51fd\u6570](#batch-functions)\n11. [\u5728\u534f\u4f5c\u7b14\u8bb0\u672c\u4e0a\u8fd0\u884c](#colab-notebooks)\n\n## \u793a\u4f8b\u8f93\u5165\n\n\u60a8\u53ef\u4ee5\u63d0\u4f9b\u7528\u6237\u53ef\u4ee5\u8f7b\u677e\u52a0\u8f7d\u5230 \"Interface\" \u4e2d\u7684\u793a\u4f8b\u6570\u636e\u3002\u8fd9\u5bf9\u4e8e\u6f14\u793a\u6a21\u578b\u671f\u671b\u7684\u8f93\u5165\u7c7b\u578b\u4ee5\u53ca\u6f14\u793a\u6570\u636e\u96c6\u548c\u6a21\u578b\u4e00\u8d77\u63a2\u7d22\u7684\u65b9\u5f0f\u975e\u5e38\u6709\u5e2e\u52a9\u3002\u8981\u52a0\u8f7d\u793a\u4f8b\u6570\u636e\uff0c\u60a8\u53ef\u4ee5\u5c06\u5d4c\u5957\u5217\u8868\u63d0\u4f9b\u7ed9 Interface \u6784\u9020\u51fd\u6570\u7684 `examples=` \u5173\u952e\u5b57\u53c2\u6570\u3002\u5916\u90e8\u5217\u8868\u4e2d\u7684\u6bcf\u4e2a\u5b50\u5217\u8868\u8868\u793a\u4e00\u4e2a\u6570\u636e\u6837\u672c\uff0c\u5b50\u5217\u8868\u4e2d\u7684\u6bcf\u4e2a\u5143\u7d20\u8868\u793a\u6bcf\u4e2a\u8f93\u5165\u7ec4\u4ef6\u7684\u8f93\u5165\u3002\u6709\u5173\u6bcf\u4e2a\u7ec4\u4ef6\u7684\u793a\u4f8b\u6570\u636e\u683c\u5f0f\u5728[Docs](https://gradio.app/docs#components)\u4e2d\u6709\u8bf4\u660e\u3002\n\n$code_calculator\n$demo_calculator\n\n\u60a8\u53ef\u4ee5\u5c06\u5927\u578b\u6570\u636e\u96c6\u52a0\u8f7d\u5230\u793a\u4f8b\u4e2d\uff0c\u901a\u8fc7 Gradio \u6d4f\u89c8\u548c\u4e0e\u6570\u636e\u96c6\u8fdb\u884c\u4ea4\u4e92\u3002\u793a\u4f8b\u5c06\u81ea\u52a8\u5206\u9875\uff08\u53ef\u4ee5\u901a\u8fc7 Interface \u7684 `examples_per_page` \u53c2\u6570\u8fdb\u884c\u914d\u7f6e\uff09\u3002\n\n\u7ee7\u7eed\u4e86\u89e3\u793a\u4f8b\uff0c\u8bf7\u53c2\u9605[\u66f4\u591a\u793a\u4f8b](https://gradio.app/more-on-examples)\u6307\u5357\u3002\n\n## \u9519\u8bef\n\n\u60a8\u5e0c\u671b\u5411\u7528\u6237\u4f20\u9012\u81ea\u5b9a\u4e49\u9519\u8bef\u6d88\u606f\u3002\u4e3a\u6b64\uff0cwith `gr.Error(\"custom message\")` \u6765\u663e\u793a\u9519\u8bef\u6d88\u606f\u3002\u5982\u679c\u5728\u4e0a\u9762\u7684\u8ba1\u7b97\u5668\u793a\u4f8b\u4e2d\u5c1d\u8bd5\u9664\u4ee5\u96f6\uff0c\u5c06\u663e\u793a\u81ea\u5b9a\u4e49\u9519\u8bef\u6d88\u606f\u7684\u5f39\u51fa\u6a21\u6001\u7a97\u53e3\u3002\u4e86\u89e3\u6709\u5173\u9519\u8bef\u7684\u66f4\u591a\u4fe1\u606f\uff0c\u8bf7\u53c2\u9605[\u6587\u6863](https://gradio.app/docs#error)\u3002\n\n## \u63cf\u8ff0\u6027\u5185\u5bb9\n\n\u5728\u524d\u9762\u7684\u793a\u4f8b\u4e2d\uff0c\u60a8\u53ef\u80fd\u5df2\u7ecf\u6ce8\u610f\u5230 Interface \u6784\u9020\u51fd\u6570\u4e2d\u7684 `title=` \u548c `description=` \u5173\u952e\u5b57\u53c2\u6570\uff0c\u5e2e\u52a9\u7528\u6237\u4e86\u89e3\u60a8\u7684\u5e94\u7528\u7a0b\u5e8f\u3002\n\nInterface \u6784\u9020\u51fd\u6570\u4e2d\u6709\u4e09\u4e2a\u53c2\u6570\u7528\u4e8e\u6307\u5b9a\u6b64\u5185\u5bb9\u5e94\u653e\u7f6e\u5728\u54ea\u91cc\uff1a\n\n- `title`\uff1a\u63a5\u53d7\u6587\u672c\uff0c\u5e76\u53ef\u4ee5\u5c06\u5176\u663e\u793a\u5728\u754c\u9762\u7684\u9876\u90e8\uff0c\u4e5f\u5c06\u6210\u4e3a\u9875\u9762\u6807\u9898\u3002\n- `description`\uff1a\u63a5\u53d7\u6587\u672c\u3001Markdown \u6216 HTML\uff0c\u5e76\u5c06\u5176\u653e\u7f6e\u5728\u6807\u9898\u6b63\u4e0b\u65b9\u3002\n- `article`\uff1a\u4e5f\u63a5\u53d7\u6587\u672c\u3001Markdown \u6216 HTML\uff0c\u5e76\u5c06\u5176\u653e\u7f6e\u5728\u754c\u9762\u4e0b\u65b9\u3002\n\n![annotated](/assets/guides/annotated.png)\n\n\u5982\u679c\u60a8\u4f7f\u7528\u7684\u662f `Blocks` API\uff0c\u5219\u53ef\u4ee5 with `gr.Markdown(...)` \u6216 `gr.HTML(...)` \u7ec4\u4ef6\u5728\u4efb\u4f55\u4f4d\u7f6e\u63d2\u5165\u6587\u672c\u3001Markdown \u6216 HTML\uff0c\u5176\u4e2d\u63cf\u8ff0\u6027\u5185\u5bb9\u4f4d\u4e8e `Component` \u6784\u9020\u51fd\u6570\u5185\u90e8\u3002\n\n\u53e6\u4e00\u4e2a\u6709\u7528\u7684\u5173\u952e\u5b57\u53c2\u6570\u662f `label=`\uff0c\u5b83\u5b58\u5728\u4e8e\u6bcf\u4e2a `Component` \u4e2d\u3002\u8fd9\u4fee\u6539\u4e86\u6bcf\u4e2a `Component` \u9876\u90e8\u7684\u6807\u7b7e\u6587\u672c\u3002\u8fd8\u53ef\u4ee5\u4e3a\u8bf8\u5982 `Textbox` \u6216 `Radio` \u4e4b\u7c7b\u7684\u8868\u5355\u5143\u7d20\u6dfb\u52a0 `info=` \u5173\u952e\u5b57\u53c2\u6570\uff0c\u4ee5\u63d0\u4f9b\u6709\u5173\u5176\u7528\u6cd5\u7684\u8fdb\u4e00\u6b65\u4fe1\u606f\u3002\n\n```python\ngr.Number(label='\u5e74\u9f84', info='\u4ee5\u5e74\u4e3a\u5355\u4f4d\uff0c\u5fc5\u987b\u5927\u4e8e0')\n```\n\n## \u65d7\u6807\n\n\u9ed8\u8ba4\u60c5\u51b5\u4e0b\uff0c\"Interface\" \u5c06\u6709\u4e00\u4e2a \"Flag\" \u6309\u94ae\u3002\u5f53\u7528\u6237\u6d4b\u8bd5\u60a8\u7684 `Interface` \u65f6\uff0c\u5982\u679c\u770b\u5230\u6709\u8da3\u7684\u8f93\u51fa\uff0c\u4f8b\u5982\u9519\u8bef\u6216\u610f\u5916\u7684\u6a21\u578b\u884c\u4e3a\uff0c\u4ed6\u4eec\u53ef\u4ee5\u5c06\u8f93\u5165\u6807\u8bb0\u4e3a\u60a8\u8fdb\u884c\u67e5\u770b\u3002\u5728\u7531 `Interface` \u6784\u9020\u51fd\u6570\u7684 `flagging_dir=` \u53c2\u6570\u63d0\u4f9b\u7684\u76ee\u5f55\u4e2d\uff0c\u5c06\u8bb0\u5f55\u6807\u8bb0\u7684\u8f93\u5165\u5230\u4e00\u4e2a CSV \u6587\u4ef6\u4e2d\u3002\u5982\u679c\u754c\u9762\u6d89\u53ca\u6587\u4ef6\u6570\u636e\uff0c\u4f8b\u5982\u56fe\u50cf\u548c\u97f3\u9891\u7ec4\u4ef6\uff0c\u5c06\u521b\u5efa\u6587\u4ef6\u5939\u6765\u5b58\u50a8\u8fd9\u4e9b\u6807\u8bb0\u7684\u6570\u636e\u3002\n\n\u4f8b\u5982\uff0c\u5bf9\u4e8e\u4e0a\u9762\u663e\u793a\u7684\u8ba1\u7b97\u5668\u754c\u9762\uff0c\u6211\u4eec\u5c06\u5728\u4e0b\u9762\u7684\u65d7\u6807\u76ee\u5f55\u4e2d\u5b58\u50a8\u6807\u8bb0\u7684\u6570\u636e\uff1a\n\n```directory\n+-- calculator.py\n+-- flagged/\n|   +-- logs.csv\n```\n\n_flagged/logs.csv_\n\n```csv\nnum1,operation,num2,Output\n5,add,7,12\n6,subtract,1.5,4.5\n```\n\n\u4e0e\u65e9\u671f\u663e\u793a\u7684\u51b7\u8272\u754c\u9762\u76f8\u5bf9\u5e94\uff0c\u6211\u4eec\u5c06\u5728\u4e0b\u9762\u7684\u65d7\u6807\u76ee\u5f55\u4e2d\u5b58\u50a8\u6807\u8bb0\u7684\u6570\u636e\uff1a\n\n```directory\n+-- sepia.py\n+-- flagged/\n|   +-- logs.csv\n|   +-- im/\n|   |   +-- 0.png\n|   |   +-- 1.png\n|   +-- Output/\n|   |   +-- 0.png\n|   |   +-- 1.png\n```\n\n_flagged/logs.csv_\n\n```csv\nim,Output\nim/0.png,Output/0.png\nim/1.png,Output/1.png\n```\n\n\u5982\u679c\u60a8\u5e0c\u671b\u7528\u6237\u63d0\u4f9b\u65d7\u6807\u539f\u56e0\uff0c\u53ef\u4ee5\u5c06\u5b57\u7b26\u4e32\u5217\u8868\u4f20\u9012\u7ed9 Interface \u7684 `flagging_options` \u53c2\u6570\u3002\u7528\u6237\u5728\u8fdb\u884c\u65d7\u6807\u65f6\u5fc5\u987b\u9009\u62e9\u5176\u4e2d\u4e00\u4e2a\u5b57\u7b26\u4e32\uff0c\u8fd9\u5c06\u4f5c\u4e3a\u9644\u52a0\u5217\u4fdd\u5b58\u5230 CSV \u4e2d\u3002\n\n## \u9884\u5904\u7406\u548c\u540e\u5904\u7406 (Preprocessing and Postprocessing)\n\n![annotated](/assets/img/dataflow.svg)\n\n\u5982\u60a8\u6240\u89c1\uff0cGradio \u5305\u62ec\u53ef\u4ee5\u5904\u7406\u5404\u79cd\u4e0d\u540c\u6570\u636e\u7c7b\u578b\u7684\u7ec4\u4ef6\uff0c\u4f8b\u5982\u56fe\u50cf\u3001\u97f3\u9891\u548c\u89c6\u9891\u3002\u5927\u591a\u6570\u7ec4\u4ef6\u90fd\u53ef\u4ee5\u7528\u4f5c\u8f93\u5165\u6216\u8f93\u51fa\u3002\n\n\u5f53\u7ec4\u4ef6\u7528\u4f5c\u8f93\u5165\u65f6\uff0cGradio \u81ea\u52a8\u5904\u7406*\u9884\u5904\u7406*\uff0c\u5c06\u6570\u636e\u4ece\u7528\u6237\n--New Chunk--\n[Created at: 2025-03-24 13:16:48]\n\u4e0e\u5e38\u89c4\u51fd\u6570\u76f8\u540c\u7684\u65b9\u5f0f\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio\u3002\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\uff08\u865a\u62df\u7684\uff09\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5b83\u5728\u8f93\u51fa\u56fe\u50cf\u4e4b\u524d\u751f\u6210\u6570\u4e2a\u6b65\u9aa4\u7684\u566a\u97f3\uff1a\n\n$code_fake_diffusion\n$demo_fake_diffusion\n\n\u8bf7\u6ce8\u610f\uff0c\u6211\u4eec\u5728\u8fed\u4ee3\u5668\u4e2d\u6dfb\u52a0\u4e86 `time.sleep(1)`\uff0c\u4ee5\u521b\u5efa\u6b65\u9aa4\u4e4b\u95f4\u7684\u4eba\u5de5\u6682\u505c\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u89c2\u5bdf\u8fed\u4ee3\u5668\u7684\u6b65\u9aa4\uff08\u5728\u771f\u5b9e\u7684\u56fe\u50cf\u751f\u6210\u6a21\u578b\u4e2d\uff0c\u8fd9\u53ef\u80fd\u662f\u4e0d\u5fc5\u8981\u7684\uff09\u3002\n\n\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio **\u9700\u8981**\u5728\u5e95\u5c42 Interface \u6216 Blocks \u4e2d\u542f\u7528\u961f\u5217\uff08\u8bf7\u53c2\u9605\u4e0a\u9762\u7684\u961f\u5217\u90e8\u5206\uff09\u3002\n\n## \u8fdb\u5ea6\u6761\n\nGradio \u652f\u6301\u521b\u5efa\u81ea\u5b9a\u4e49\u8fdb\u5ea6\u6761\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u81ea\u5b9a\u4e49\u548c\u63a7\u5236\u5411\u7528\u6237\u663e\u793a\u7684\u8fdb\u5ea6\u66f4\u65b0\u3002\u8981\u542f\u7528\u6b64\u529f\u80fd\uff0c\u53ea\u9700\u4e3a\u65b9\u6cd5\u6dfb\u52a0\u4e00\u4e2a\u9ed8\u8ba4\u503c\u4e3a `gr.Progress` \u5b9e\u4f8b\u7684\u53c2\u6570\u5373\u53ef\u3002\u7136\u540e\uff0c\u60a8\u53ef\u4ee5\u76f4\u63a5\u8c03\u7528\u6b64\u5b9e\u4f8b\u5e76\u4f20\u5165 0 \u5230 1 \u4e4b\u95f4\u7684\u6d6e\u70b9\u6570\u6765\u66f4\u65b0\u8fdb\u5ea6\u7ea7\u522b\uff0c\u6216\u8005 with `Progress` \u5b9e\u4f8b\u7684 `tqdm()` \u65b9\u6cd5\u6765\u8ddf\u8e2a\u53ef\u8fed\u4ee3\u5bf9\u8c61\u4e0a\u7684\u8fdb\u5ea6\uff0c\u5982\u4e0b\u6240\u793a\u3002\u5fc5\u987b\u542f\u7528\u961f\u5217\u4ee5\u8fdb\u884c\u8fdb\u5ea6\u66f4\u65b0\u3002\n\n$code_progress_simple\n$demo_progress_simple\n\n\u5982\u679c\u60a8 with `tqdm` \u5e93\uff0c\u5e76\u4e14\u5e0c\u671b\u4ece\u51fd\u6570\u5185\u90e8\u7684\u4efb\u4f55 `tqdm.tqdm` \u81ea\u52a8\u62a5\u544a\u8fdb\u5ea6\u66f4\u65b0\uff0c\u8bf7\u5c06\u9ed8\u8ba4\u53c2\u6570\u8bbe\u7f6e\u4e3a `gr.Progress(track_tqdm=True)`\uff01\n\n## \u6279\u5904\u7406\u51fd\u6570 (Batch Functions)\n\nGradio \u652f\u6301\u4f20\u9012*\u6279\u5904\u7406*\u51fd\u6570\u3002\u6279\u5904\u7406\u51fd\u6570\u53ea\u662f\u63a5\u53d7\u8f93\u5165\u5217\u8868\u5e76\u8fd4\u56de\u9884\u6d4b\u5217\u8868\u7684\u51fd\u6570\u3002\n\n\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\u6279\u5904\u7406\u51fd\u6570\uff0c\u5b83\u63a5\u53d7\u4e24\u4e2a\u8f93\u5165\u5217\u8868\uff08\u4e00\u4e2a\u5355\u8bcd\u5217\u8868\u548c\u4e00\u4e2a\u6574\u6570\u5217\u8868\uff09\uff0c\u5e76\u8fd4\u56de\u4fee\u526a\u8fc7\u7684\u5355\u8bcd\u5217\u8868\u4f5c\u4e3a\u8f93\u51fa\uff1a\n\n```python\nimport time\n\ndef trim_words(words, lens):\n    trimmed_words = []\n    time.sleep(5)\n    for w, l in zip(words, lens):\n        trimmed_words.append(w[:int(l)])\n    return [trimmed_words]\n    for w, l in zip(words, lens):\n```\n\n\u4f7f\u7528\u6279\u5904\u7406\u51fd\u6570\u7684\u4f18\u70b9\u662f\uff0c\u5982\u679c\u542f\u7528\u4e86\u961f\u5217\uff0cGradio \u670d\u52a1\u5668\u53ef\u4ee5\u81ea\u52a8*\u6279\u5904\u7406*\u4f20\u5165\u7684\u8bf7\u6c42\u5e76\u5e76\u884c\u5904\u7406\u5b83\u4eec\uff0c\u4ece\u800c\u53ef\u80fd\u52a0\u5feb\u6f14\u793a\u901f\u5ea6\u3002\u4ee5\u4e0b\u662f Gradio \u4ee3\u7801\u7684\u793a\u4f8b\uff08\u8bf7\u6ce8\u610f `batch=True` \u548c `max_batch_size=16` - \u8fd9\u4e24\u4e2a\u53c2\u6570\u90fd\u53ef\u4ee5\u4f20\u9012\u7ed9\u4e8b\u4ef6\u89e6\u53d1\u5668\u6216 `Interface` \u7c7b\uff09\n\nwith `Interface`\uff1a\n\n```python\ndemo = gr.Interface(trim_words, [\"textbox\", \"number\"], [\"output\"],\n                    batch=True, max_batch_size=16)\ndemo.queue()\ndemo.launch()\n```\n\nwith `Blocks`\uff1a\n\n```python\nimport gradio as gr\n\nwith gr.Blocks() as demo:\n    with gr.Row():\n        word = gr.Textbox(label=\"word\")\n        leng = gr.Number(label=\"leng\")\n        output = gr.Textbox(label=\"Output\")\n    with gr.Row():\n        run = gr.Button()\n\n    event = run.click(trim_words, [word, leng], output, batch=True, max_batch_size=16)\n\ndemo.queue()\ndemo.launch()\n```\n\n\u5728\u4e0a\u9762\u7684\u793a\u4f8b\u4e2d\uff0c\u53ef\u4ee5\u5e76\u884c\u5904\u7406 16 \u4e2a\u8bf7\u6c42\uff08\u603b\u63a8\u7406\u65f6\u95f4\u4e3a 5 \u79d2\uff09\uff0c\u800c\u4e0d\u662f\u5206\u522b\u5904\u7406\u6bcf\u4e2a\u8bf7\u6c42\uff08\u603b\u63a8\u7406\u65f6\u95f4\u4e3a 80 \u79d2\uff09\u3002\u8bb8\u591a Hugging Face \u7684 `transformers` \u548c `diffusers` \u6a21\u578b\u5728 Gradio \u7684\u6279\u5904\u7406\u6a21\u5f0f\u4e0b\u81ea\u7136\u5de5\u4f5c\uff1a\u8fd9\u662f[\u4f7f\u7528\u6279\u5904\u7406\u751f\u6210\u56fe\u50cf\u7684\u793a\u4f8b\u6f14\u793a](https://github.com/gradio-app/gradio/blob/main/demo/diffusers_with_batching/run.py)\n\n\u6ce8\u610f\uff1a\u4f7f\u7528 Gradio \u7684\u6279\u5904\u7406\u51fd\u6570 **requires** \u5728\u5e95\u5c42 Interface \u6216 Blocks \u4e2d\u542f\u7528\u961f\u5217\uff08\u8bf7\u53c2\u9605\u4e0a\u9762\u7684\u961f\u5217\u90e8\u5206\uff09\u3002\n\n## Gradio \u7b14\u8bb0\u672c (Colab Notebooks)\n\nGradio \u53ef\u4ee5\u5728\u4efb\u4f55\u8fd0\u884c Python \u7684\u5730\u65b9\u8fd0\u884c\uff0c\u5305\u62ec\u672c\u5730 Jupyter \u7b14\u8bb0\u672c\u548c\u534f\u4f5c\u7b14\u8bb0\u672c\uff0c\u5982[Google Colab](https://colab.research.google.com/)\u3002\u5bf9\u4e8e\u672c\u5730 Jupyter \u7b14\u8bb0\u672c\u548c Google Colab \u7b14\u8bb0\u672c\uff0cGradio \u5728\u672c\u5730\u670d\u52a1\u5668\u4e0a\u8fd0\u884c\uff0c\u60a8\u53ef\u4ee5\u5728\u6d4f\u89c8\u5668\u4e2d\u4e0e\u4e4b\u4ea4\u4e92\u3002\uff08\u6ce8\u610f\uff1a\u5bf9\u4e8e Google Colab\uff0c\u8fd9\u662f\u901a\u8fc7[\u670d\u52a1\u5de5\u4f5c\u5668\u96a7\u9053](https://github.com/tensorflow/tensorboard/blob/master/docs/design/colab_integration.md)\u5b9e\u73b0\u7684\uff0c\u60a8\u7684\u6d4f\u89c8\u5668\u9700\u8981\u542f\u7528 cookies\u3002\uff09\u5bf9\u4e8e\u5176\u4ed6\u8fdc\u7a0b\u7b14\u8bb0\u672c\uff0cGradio \u4e5f\u5c06\u5728\u670d\u52a1\u5668\u4e0a\u8fd0\u884c\uff0c\u4f46\u60a8\u9700\u8981\u4f7f\u7528[SSH \u96a7\u9053](https://coderwall.com/p/ohk6cg/remote-access-to-ipython-notebooks-via-ssh)\u5728\u672c\u5730\u6d4f\u89c8\u5668\u4e2d\u67e5\u770b\u5e94\u7528\u7a0b\u5e8f\u3002\u901a\u5e38\uff0c\u66f4\u7b80\u5355\u7684\u9009\u62e9\u662f\u4f7f\u7528 Gradio \u5185\u7f6e\u7684\u516c\u5171\u94fe\u63a5\uff0c[\u5728\u4e0b\u4e00\u7bc7\u6307\u5357\u4e2d\u8ba8\u8bba](/sharing-your-app/#sharing-demos)\u3002"
        }
    },
    {
        "context": "## \u6279\u5904\u7406\u51fd\u6570 (Batch Functions)\n\nGradio \u652f\u6301\u4f20\u9012*\u6279\u5904\u7406*\u51fd\u6570\u3002\u6279\u5904\u7406\u51fd\u6570\u53ea\u662f\u63a5\u53d7\u8f93\u5165\u5217\u8868\u5e76\u8fd4\u56de\u9884\u6d4b\u5217\u8868\u7684\u51fd\u6570\u3002\n\n\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\u6279\u5904\u7406\u51fd\u6570\uff0c\u5b83\u63a5\u53d7\u4e24\u4e2a\u8f93\u5165\u5217\u8868\uff08\u4e00\u4e2a\u5355\u8bcd\u5217\u8868\u548c\u4e00\u4e2a\u6574\u6570\u5217\u8868\uff09\uff0c\u5e76\u8fd4\u56de\u4fee\u526a\u8fc7\u7684\u5355\u8bcd\u5217\u8868\u4f5c\u4e3a\u8f93\u51fa\uff1a\n\n```python\nimport time\n\ndef trim_words(words, lens):\n    trimmed_words = []\n    time.sleep(5)\n    for w, l in zip(words, lens):\n        trimmed_words.append(w[:int(l)])\n    return [trimmed_words]\n    for w, l in zip(words, lens):\n```\n\n\u4f7f\u7528\u6279\u5904\u7406\u51fd\u6570\u7684\u4f18\u70b9\u662f\uff0c\u5982\u679c\u542f\u7528\u4e86\u961f\u5217\uff0cGradio \u670d\u52a1\u5668\u53ef\u4ee5\u81ea\u52a8*\u6279\u5904\u7406*\u4f20\u5165\u7684\u8bf7\u6c42\u5e76\u5e76\u884c\u5904\u7406\u5b83\u4eec\uff0c\u4ece\u800c\u53ef\u80fd\u52a0\u5feb\u6f14\u793a\u901f\u5ea6\u3002\u4ee5\u4e0b\u662f Gradio \u4ee3\u7801\u7684\u793a\u4f8b\uff08\u8bf7\u6ce8\u610f `batch=True` \u548c `max_batch_size=16` - \u8fd9\u4e24\u4e2a\u53c2\u6570\u90fd\u53ef\u4ee5\u4f20\u9012\u7ed9\u4e8b\u4ef6\u89e6\u53d1\u5668\u6216 `Interface` \u7c7b\uff09\n\nwith `Interface`\uff1a\n\n```python\ndemo = gr.Interface(trim_words, [\"textbox\", \"number\"], [\"output\"],\n                    batch=True, max_batch_size=16)\ndemo.queue()\ndemo.launch()\n```\n\nwith `Blocks`\uff1a\n\n```python\nimport gradio as gr\n\nwith gr.Blocks() as demo:\n    with gr.Row():\n        word = gr.Textbox(label=\"word\")\n        leng = gr.Number(label=\"leng\")\n        output = gr.Textbox(label=\"Output\")\n    with gr.Row():\n        run = gr.Button()\n\n    event = run.click(trim_words, [word, leng], output, batch=True, max_batch_size=16)\n\ndemo.queue()\ndemo.launch()\n```\n\n\u5728\u4e0a\u9762\u7684\u793a\u4f8b\u4e2d\uff0c\u53ef\u4ee5\u5e76\u884c\u5904\u7406 16 \u4e2a\u8bf7\u6c42\uff08\u603b\u63a8\u7406\u65f6\u95f4\u4e3a 5 \u79d2\uff09\uff0c\u800c\u4e0d\u662f\u5206\u522b\u5904\u7406\u6bcf\u4e2a\u8bf7\u6c42\uff08\u603b\u63a8\u7406\u65f6\u95f4\u4e3a 80 \u79d2\uff09\u3002\u8bb8\u591a Hugging Face \u7684 `transformers` \u548c `diffusers` \u6a21\u578b\u5728 Gradio \u7684\u6279\u5904\u7406\u6a21\u5f0f\u4e0b\u81ea\u7136\u5de5\u4f5c\uff1a\u8fd9\u662f[\u4f7f\u7528\u6279\u5904\u7406\u751f\u6210\u56fe\u50cf\u7684\u793a\u4f8b\u6f14\u793a](https://github.com/gradio-app/gradio/blob/main/demo/diffusers_with_batching/run.py)\n\n\u6ce8\u610f\uff1a\u4f7f\u7528 Gradio \u7684\u6279\u5904\u7406\u51fd\u6570 **requires** \u5728\u5e95\u5c42 Interface \u6216 Blocks \u4e2d\u542f\u7528\u961f\u5217\uff08\u8bf7\u53c2\u9605\u4e0a\u9762\u7684\u961f\u5217\u90e8\u5206\uff09\u3002\n\n## Gradio \u7b14\u8bb0\u672c (Colab Notebooks)\n\nGradio \u53ef\u4ee5\u5728\u4efb\u4f55\u8fd0\u884c Python \u7684\u5730\u65b9\u8fd0\u884c\uff0c\u5305\u62ec\u672c\u5730 Jupyter \u7b14\u8bb0\u672c\u548c\u534f\u4f5c\u7b14\u8bb0\u672c\uff0c\u5982[Google Colab](https://colab.research.google.com/)\u3002\u5bf9\u4e8e\u672c\u5730 Jupyter \u7b14\u8bb0\u672c\u548c Google Colab \u7b14\u8bb0\u672c\uff0cGradio \u5728\u672c\u5730\u670d\u52a1\u5668\u4e0a\u8fd0\u884c\uff0c\u60a8\u53ef\u4ee5\u5728\u6d4f\u89c8\u5668\u4e2d\u4e0e\u4e4b\u4ea4\u4e92\u3002\uff08\u6ce8\u610f\uff1a\u5bf9\u4e8e Google Colab\uff0c\u8fd9\u662f\u901a\u8fc7[\u670d\u52a1\u5de5\u4f5c\u5668\u96a7\u9053](https://github.com/tensorflow/tensorboard/blob/master/docs/design/colab_integration.md)\u5b9e\u73b0\u7684\uff0c\u60a8\u7684\u6d4f\u89c8\u5668\u9700\u8981\u542f\u7528 cookies\u3002\uff09\u5bf9\u4e8e\u5176\u4ed6\u8fdc\u7a0b\u7b14\u8bb0\u672c\uff0cGradio \u4e5f\u5c06\u5728\u670d\u52a1\u5668\u4e0a\u8fd0\u884c\uff0c\u4f46\u60a8\u9700\u8981\u4f7f\u7528[SSH \u96a7\u9053](https://coderwall.com/p/ohk6cg/remote-access-to-ipython-notebooks-via-ssh)\u5728\u672c\u5730\u6d4f\u89c8\u5668\u4e2d\u67e5\u770b\u5e94\u7528\u7a0b\u5e8f\u3002\u901a\u5e38\uff0c\u66f4\u7b80\u5355\u7684\u9009\u62e9\u662f\u4f7f\u7528 Gradio \u5185\u7f6e\u7684\u516c\u5171\u94fe\u63a5\uff0c[\u5728\u4e0b\u4e00\u7bc7\u6307\u5357\u4e2d\u8ba8\u8bba](/sharing-your-app/#sharing-demos)\u3002",
        "question": "How many requests can be processed in parallel in the example code?",
        "answer": "16 requests can be processed in parallel.",
        "source_doc": "gradio-app/gradio/blob/main/guides/cn/01_getting-started/02_key-features.md",
        "rag_answer": null,
        "rag_context": null,
        "rag_score": null,
        "rag_feedback": null
    },
    {
        "sample_idx": 33,
        "question": "What is the total inference time for processing 16 requests separately in the example code?",
        "answer": "The total inference time is 80 seconds.",
        "rag_answer": "According to the example code, each request takes 5 seconds to process, and we are processing 16 requests separately. Therefore, the total inference time would be:\n\n16 requests \\* 5 seconds/request = 80 seconds\n\nSo, the total inference time for processing 16 requests separately would be 80 seconds.",
        "rag_score": null,
        "rag_feedback": null,
        "rag_context": {
            "kg_context": "-----Entities-----\n    ```csv\n    id,\tentity,\ttype,\tdescription,\trankcreated_at\n1,\tTensorFlow,category,TensorFlow is a machine learning framework that uses XLA as an optimizing compiler.<SEP>TensorFlow is a software framework used for building and training neural networks.<SEP>TensorFlow is an open-source machine learning framework.,3,2025-03-24 13:20:24\n2,\tXLA,technology,XLA is a technology that compiles TensorFlow graphs into executable code for various platforms.<SEP>XLA is an optimizing compiler used by TensorFlow and JAX to improve performance.<SEP>XLA is an optimizing compiler, used by both TensorFlow and JAX to optimize computations.,6,2025-03-24 13:20:24\n3,\tEndpoint creation page,event,The Endpoint creation page is a webpage where users can create new endpoints.,5,2025-03-24 13:20:24\n4,\tInference widget,category,Inference widget is a tool used for testing endpoints.,1,2025-03-24 13:20:24\n5,\tguess_letter,event,guess_letter is a function in the hangman game that updates the state of used letters.,2,2025-03-24 13:20:24\n6,\tused_letters_var,category,used_letters_var is a variable that stores the used letters in the hangman game.,1,2025-03-24 13:20:24\n7,\tInference widget,category,Inference widget is a tool used for testing endpoints.,1,UNKNOWN\n8,\tmnli,dataset,mnli is a dataset for evaluating natural language inference models.,0,UNKNOWN\n9,\tjit_compile,concept,jit_compile is a technique for compiling TensorFlow graphs into executable code.,1,UNKNOWN\n    ```\n    -----Relationships-----\n    ```csv\n    id,\tsource,\ttarget,\tdescription,\tkeywords,\tweight,\trank,\tcreated_at\n1,\tTensorFlow,XLA,TensorFlow graphs can be compiled into executable code using XLA.<SEP>TensorFlow uses XLA as an optimizing compiler to improve performance.,compilation, framework support<SEP>compiler, performance optimization,23.0,9,2025-03-24 13:18:20\n2,\tEndpoint creation page,Inference widget,The Endpoint creation page provides an Inference widget for testing endpoints.,testing, endpoint creation,7.0,6,2025-03-24 13:16:13\n3,\tguess_letter,used_letters_var,used_letters_var is updated by the guess_letter function.,variable update, game logic,8.0,3,2025-03-24 13:20:24\n4,\tXLA,jit_compile,jit_compile is a technique used in XLA to compile TensorFlow graphs into executable code.,compilation technique, XLA support,3.0,7,UNKNOWN\n5,\tEndpoint creation page,Inference widget,The Endpoint creation page provides an Inference widget for testing endpoints.,testing, endpoint creation,7.0,6,UNKNOWN\n    ```\n    -----Sources-----\n    ```csv\n    id,\tcontent\n1,\t(for example, a v3-32), your TPU fleet is referred to as a **pod slice.**\n\nWhen you access a free TPU via Colab, you generally get a single v2-8 TPU.\n\n### I keep hearing about this XLA thing. What\u2019s XLA, and how does it relate to TPUs?\n\nXLA is an optimizing compiler, used by both TensorFlow and JAX. In JAX it is the only compiler, whereas in TensorFlow it is optional (but mandatory on TPU!). The easiest way to enable it when training a Keras model is to pass the argument `jit_compile=True` to `model.compile()`. If you don\u2019t get any errors and performance is good, that\u2019s a great sign that you\u2019re ready to move to TPU!\n\nDebugging on TPU is generally a bit harder than on CPU/GPU, so we recommend getting your code running on CPU/GPU with XLA first before trying it on TPU. You don\u2019t have to train for long, of course - just for a few steps to make sure that your model and data pipeline are working like you expect them to.\n\n<Tip>\n\nXLA compiled code is usually faster - so even if you\u2019re not planning to run on TPU, adding `jit_compile=True` can improve your performance. Be sure to note the caveats below about XLA compatibility, though!\n\n</Tip>\n\n<Tip warning={true}>\n\n**Tip born of painful experience:** Although using `jit_compile=True` is a good way to get a speed boost and test if your CPU/GPU code is XLA-compatible, it can actually cause a lot of problems if you leave it in when actually training on TPU. XLA compilation will happen implicitly on TPU, so remember to remove that line before actually running your code on a TPU!\n\n</Tip>\n\n### How do I make my model XLA compatible?\n\nIn many cases, your code is probably XLA-compatible already! However, there are a few things that work in normal TensorFlow that don\u2019t work in XLA. We\u2019ve distilled them into three core rules below:\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** We\u2019ve put a lot of effort into rewriting our TensorFlow models and loss functions to be XLA-compatible. Our models and loss functions generally obey rule #1 and #2 by default, so you can skip over them if you\u2019re using `transformers` models. Don\u2019t forget about these rules when writing your own models and loss functions, though!\n\n</Tip>\n\n#### XLA Rule #1: Your code cannot have \u201cdata-dependent conditionals\u201d\n\nWhat that means is that any `if` statement cannot depend on values inside a `tf.Tensor`. For example, this code block cannot be compiled with XLA!\n\n```python\nif tf.reduce_sum(tensor) > 10:\n    tensor = tensor / 2.0\n```\n\nThis might seem very restrictive at first, but most neural net code doesn\u2019t need to do this. You can often get around this restriction by using `tf.cond` (see the documentation [here](https://www.tensorflow.org/api_docs/python/tf/cond)) or by removing the conditional and finding a clever math trick with indicator variables instead, like so:\n\n```python\nsum_over_10 = tf.cast(tf.reduce_sum(tensor) > 10, tf.float32)\ntensor = tensor / (1.0 + sum_over_10)\n```\n\nThis code has exactly the same effect as the code above, but by avoiding a conditional, we ensure it will compile with XLA without problems!\n\n#### XLA Rule #2: Your code cannot have \u201cdata-dependent shapes\u201d\n\nWhat this means is that the shape of all of the `tf.Tensor` objects in your code cannot depend on their values. For example, the function `tf.unique` cannot be compiled with XLA, because it returns a `tensor` containing one instance of each unique value in the input. The shape of this output will obviously be different depending on how repetitive the input `Tensor` was, and so XLA refuses to handle it!\n\nIn general, most neural network code obeys rule #2 by default. However, there are a few common cases where it becomes a problem. One very common one is when you use **label masking**, setting your labels to a negative value to indicate that those positions should be ignored when computing the loss. If you look at NumPy or PyTorch loss functions that support label masking, you will often see code like this that uses [boolean indexing](https://numpy.org/doc/stable/user/basics.indexing.html#boolean-array-indexing):\n\n```python\nlabel_mask = labels >= 0\nmasked_outputs = outputs[label_mask]\nmasked_labels = labels[label_mask]\nloss = compute_loss(masked_outputs, masked_labels)\nmean_loss = torch.mean(loss)\n```\n\nThis code is totally fine in NumPy or PyTorch, but it breaks in XLA! Why? Because the shape of `masked_outputs` and `masked_labels` depends on how many positions are masked - that makes it a **data-dependent shape.** However, just like for rule #1, we can often rewrite this code to yield exactly the same output without any data-dependent shapes.\n\n```python\nlabel_mask = tf.cast(labels >= 0, tf.float32)\nloss = compute_loss(outputs, labels)\nloss = loss * label_mask  # Set negative label positions to 0\nmean_loss = tf.reduce_sum(loss) / tf.reduce_sum(label_mask)\n```\n\nHere, we avoid data-dependent shapes by computing the loss for every position, but zeroing out the masked positions in both the numerator and denominator when we calculate the mean, which yields exactly the same result as the first block while maintaining XLA compatibility. Note that we use the same trick as in rule #1 - converting a `tf.bool` to `\n2,\tlabel_mask  # Set negative label positions to 0\nmean_loss = tf.reduce_sum(loss) / tf.reduce_sum(label_mask)\n```\n\nHere, we avoid data-dependent shapes by computing the loss for every position, but zeroing out the masked positions in both the numerator and denominator when we calculate the mean, which yields exactly the same result as the first block while maintaining XLA compatibility. Note that we use the same trick as in rule #1 - converting a `tf.bool` to `tf.float32` and using it as an indicator variable. This is a really useful trick, so remember it if you need to convert your own code to XLA!\n\n#### XLA Rule #3: XLA will need to recompile your model for every different input shape it sees\n\nThis is the big one. What this means is that if your input shapes are very variable, XLA will have to recompile your model over and over, which will create huge performance problems. This commonly arises in NLP models, where input texts have variable lengths after tokenization. In other modalities, static shapes are more common and this rule is much less of a problem.\n\nHow can you get around rule #3? The key is **padding** - if you pad all your inputs to the same length, and then use an `attention_mask`, you can get the same results as you\u2019d get from variable shapes, but without any XLA issues. However, excessive padding can cause severe slowdown too - if you pad all your samples to the maximum length in the whole dataset, you might end up with batches consisting endless padding tokens, which will waste a lot of compute and memory!\n\nThere isn\u2019t a perfect solution to this problem. However, you can try some tricks. One very useful trick is to **pad batches of samples up to a multiple of a number like 32 or 64 tokens.** This often only increases the number of tokens by a small amount, but it hugely reduces the number of unique input shapes, because every input shape now has to be a multiple of 32 or 64. Fewer unique input shapes means fewer XLA compilations!\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** Our tokenizers and data collators have methods that can help you here. You can use `padding=\"max_length\"` or `padding=\"longest\"` when calling tokenizers to get them to output padded data. Our tokenizers and data collators also have a `pad_to_multiple_of` argument that you can use to reduce the number of unique input shapes you see!\n\n</Tip>\n\n### How do I actually train my model on TPU?\n\nOnce your training is XLA-compatible and (if you\u2019re using TPU Node / Colab) your dataset has been prepared appropriately, running on TPU is surprisingly easy! All you really need to change in your code is to add a few lines to initialize your TPU, and to ensure that your model and dataset are created inside a `TPUStrategy` scope. Take a look at [our TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) to see this in action!\n\n### Summary\n\nThere was a lot in here, so let\u2019s summarize with a quick checklist you can follow when you want to get your model ready for TPU training:\n\n- Make sure your code follows the three rules of XLA\n- Compile your model with `jit_compile=True` on CPU/GPU and confirm that you can train it with XLA\n- Either load your dataset into memory or use a TPU-compatible dataset loading approach (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Migrate your code either to Colab (with accelerator set to \u201cTPU\u201d) or a TPU VM on Google Cloud\n- Add TPU initializer code (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Create your `TPUStrategy` and make sure dataset loading and model creation are inside the `strategy.scope()` (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Don\u2019t forget to take `jit_compile=True` out again when you move to TPU!\n- \ud83d\ude4f\ud83d\ude4f\ud83d\ude4f\ud83e\udd7a\ud83e\udd7a\ud83e\udd7a\n- Call model.fit()\n- You did it!\n3,\tCreate an Endpoint\n\nAfter your first login, you will be directed to the [Endpoint creation page](https://ui.endpoints.huggingface.co/new). As an example, this guide will go through the steps to deploy [distilbert-base-uncased-finetuned-sst-2-english](https://huggingface.co/distilbert-base-uncased-finetuned-sst-2-english) for text classification. \n\n## 1. Enter the Hugging Face Repository ID and your desired endpoint name:\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_repository.png\" alt=\"select repository\" />\n\n## 2. Select your Cloud Provider and region. Initially, only AWS will be available as a Cloud Provider with the `us-east-1` and `eu-west-1` regions. We will add Azure soon, and if you need to test Endpoints with other Cloud Providers or regions, please let us know.\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_region.png\" alt=\"select region\" />\n\n## 3. Define the [Security Level](security) for the Endpoint:\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_security.png\" alt=\"define security\" />\n\n## 4. Create your Endpoint by clicking **Create Endpoint**. By default, your Endpoint is created with a medium CPU (2 x 4GB vCPUs with Intel Xeon Ice Lake) The cost estimate assumes the Endpoint will be up for an entire month, and does not take autoscaling into account.\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_create_cost.png\" alt=\"create endpoint\" />\n\n## 5. Wait for the Endpoint to build, initialize and run which can take between 1 to 5 minutes.\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/overview.png\" alt=\"overview\" />\n\n## 6. Test your Endpoint in the overview with the Inference widget \ud83c\udfc1 \ud83c\udf89!\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_inference.png\" alt=\"run inference\" />\n4,\tState in Blocks\n\nWe covered [State in Interfaces](https://gradio.app/interface-state), this guide takes a look at state in Blocks, which works mostly the same.\n\n## Global State\n\nGlobal state in Blocks works the same as in Interface. Any variable created outside a function call is a reference shared between all users.\n\n## Session State\n\nGradio supports session **state**, where data persists across multiple submits within a page session, in Blocks apps as well. To reiterate, session data is _not_ shared between different users of your model. To store data in a session state, you need to do three things:\n\n1. Create a `gr.State()` object. If there is a default value to this stateful object, pass that into the constructor.\n2. In the event listener, put the `State` object as an input and output.\n3. In the event listener function, add the variable to the input parameters and the return value.\n\nLet's take a look at a game of hangman.\n\n$code_hangman\n$demo_hangman\n\nLet's see how we do each of the 3 steps listed above in this game:\n\n1. We store the used letters in `used_letters_var`. In the constructor of `State`, we set the initial value of this to `[]`, an empty list.\n2. In `btn.click()`, we have a reference to `used_letters_var` in both the inputs and outputs.\n3. In `guess_letter`, we pass the value of this `State` to `used_letters`, and then return an updated value of this `State` in the return statement.\n\nWith more complex apps, you will likely have many State variables storing session state in a single Blocks app.\n\nLearn more about `State` in the [docs](https://gradio.app/docs#state).\n5,\tChoosing a metric for your task\n\n**So you've trained your model and want to see how well it\u2019s doing on a dataset of your choice. Where do you start?**\n\nThere is no \u201cone size fits all\u201d approach to choosing an evaluation metric, but some good guidelines to keep in mind are:\n\n## Categories of metrics\n\nThere are 3 high-level categories of metrics:\n\n1. *Generic metrics*, which can be applied to a variety of situations and datasets, such as precision and accuracy.\n2. *Task-specific metrics*, which are limited to a given task, such as Machine Translation (often evaluated using metrics [BLEU](https://huggingface.co/metrics/bleu) or [ROUGE](https://huggingface.co/metrics/rouge)) or Named Entity Recognition (often evaluated with [seqeval](https://huggingface.co/metrics/seqeval)).\n3. *Dataset-specific metrics*, which aim to measure model performance on specific benchmarks: for instance, the [GLUE benchmark](https://huggingface.co/datasets/glue) has a dedicated [evaluation metric](https://huggingface.co/metrics/glue).\n\nLet's look at each of these three cases:\n\n### Generic metrics\n\nMany of the metrics used in the Machine Learning community are quite generic and can be applied in a variety of tasks and datasets.\n\nThis is the case for metrics like [accuracy](https://huggingface.co/metrics/accuracy) and [precision](https://huggingface.co/metrics/precision), which can be used for evaluating labeled (supervised) datasets, as well as [perplexity](https://huggingface.co/metrics/perplexity), which can be used for evaluating different kinds of (unsupervised) generative tasks.\n\nTo see the input structure of a given metric, you can look at its metric card. For example, in the case of [precision](https://huggingface.co/metrics/precision), the format is:\n```\n>>> precision_metric = evaluate.load(\"precision\")\n>>> results = precision_metric.compute(references=[0, 1], predictions=[0, 1])\n>>> print(results)\n{'precision': 1.0}\n```\n\n### Task-specific metrics\n\nPopular ML tasks like Machine Translation and Named Entity Recognition have specific metrics that can be used to compare models. For example, a series of different metrics have been proposed for text generation, ranging from [BLEU](https://huggingface.co/metrics/bleu) and its derivatives such as [GoogleBLEU](https://huggingface.co/metrics/google_bleu) and [GLEU](https://huggingface.co/metrics/gleu), but also [ROUGE](https://huggingface.co/metrics/rouge), [MAUVE](https://huggingface.co/metrics/mauve), etc.\n\nYou can find the right metric for your task by:\n\n- **Looking at the [Task pages](https://huggingface.co/tasks)** to see what metrics can be used for evaluating models for a given task.\n- **Checking out leaderboards** on sites like [Papers With Code](https://paperswithcode.com/) (you can search by task and by dataset).\n-  **Reading the metric cards** for the relevant metrics and see which ones are a good fit for your use case. For example, see the [BLEU metric card](https://github.com/huggingface/evaluate/tree/main/metrics/bleu) or [SQuaD metric card](https://github.com/huggingface/evaluate/tree/main/metrics/squad).\n- **Looking at papers and blog posts** published on the topic and see what metrics they report. This can change over time, so try to pick papers from the last couple of years!\n\n### Dataset-specific metrics\n\nSome datasets have specific metrics associated with them -- this is especially in the case of popular benchmarks like [GLUE](https://huggingface.co/metrics/glue) and [SQuAD](https://huggingface.co/metrics/squad).\n\n<Tip warning={true}>\n\ud83d\udca1\nGLUE is actually a collection of different subsets on different tasks, so first you need to choose the one that corresponds to the NLI task, such as mnli, which is described as \u201ccrowdsourced collection of sentence pairs with textual entailment annotations\u201d\n</Tip>\n\n\nIf you are evaluating your model on a benchmark dataset like the ones mentioned above, you can use its dedicated evaluation metric. Make sure you respect the format that they require. For example, to evaluate your model on the [SQuAD](https://huggingface.co/datasets/squad) dataset, you need to feed the `question` and `context` into your model and return the `prediction_text`, which should be compared with the `references` (based on matching the `id` of the question) :\n\n```\n>>> from evaluate import load\n>>> squad_metric = load(\"squad\")\n>>> predictions = [{'prediction_text': '1976', 'id': '56e10a3be3433e1400422b22'}]\n>>> references = [{'answers': {'answer_start': [97], 'text': ['1976']}, 'id': '56e10a3be3433e1400422b22'}]\n>>> results = squad_metric.compute(predictions=predictions, references=references)\n>>> results\n{'exact_match': 100.0, 'f1': 100.0}\n```\n\nYou can find examples of dataset structures by consulting the \"Dataset Preview\" function or the dataset card for a given dataset, and you can see how to use its dedicated evaluation function based on the metric card.\n    ```",
            "vector_context": "[Created at: 2025-03-24 13:16:48]\n\u4e0e\u5e38\u89c4\u51fd\u6570\u76f8\u540c\u7684\u65b9\u5f0f\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio\u3002\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\uff08\u865a\u62df\u7684\uff09\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5b83\u5728\u8f93\u51fa\u56fe\u50cf\u4e4b\u524d\u751f\u6210\u6570\u4e2a\u6b65\u9aa4\u7684\u566a\u97f3\uff1a\n\n$code_fake_diffusion\n$demo_fake_diffusion\n\n\u8bf7\u6ce8\u610f\uff0c\u6211\u4eec\u5728\u8fed\u4ee3\u5668\u4e2d\u6dfb\u52a0\u4e86 `time.sleep(1)`\uff0c\u4ee5\u521b\u5efa\u6b65\u9aa4\u4e4b\u95f4\u7684\u4eba\u5de5\u6682\u505c\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u89c2\u5bdf\u8fed\u4ee3\u5668\u7684\u6b65\u9aa4\uff08\u5728\u771f\u5b9e\u7684\u56fe\u50cf\u751f\u6210\u6a21\u578b\u4e2d\uff0c\u8fd9\u53ef\u80fd\u662f\u4e0d\u5fc5\u8981\u7684\uff09\u3002\n\n\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio **\u9700\u8981**\u5728\u5e95\u5c42 Interface \u6216 Blocks \u4e2d\u542f\u7528\u961f\u5217\uff08\u8bf7\u53c2\u9605\u4e0a\u9762\u7684\u961f\u5217\u90e8\u5206\uff09\u3002\n\n## \u8fdb\u5ea6\u6761\n\nGradio \u652f\u6301\u521b\u5efa\u81ea\u5b9a\u4e49\u8fdb\u5ea6\u6761\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u81ea\u5b9a\u4e49\u548c\u63a7\u5236\u5411\u7528\u6237\u663e\u793a\u7684\u8fdb\u5ea6\u66f4\u65b0\u3002\u8981\u542f\u7528\u6b64\u529f\u80fd\uff0c\u53ea\u9700\u4e3a\u65b9\u6cd5\u6dfb\u52a0\u4e00\u4e2a\u9ed8\u8ba4\u503c\u4e3a `gr.Progress` \u5b9e\u4f8b\u7684\u53c2\u6570\u5373\u53ef\u3002\u7136\u540e\uff0c\u60a8\u53ef\u4ee5\u76f4\u63a5\u8c03\u7528\u6b64\u5b9e\u4f8b\u5e76\u4f20\u5165 0 \u5230 1 \u4e4b\u95f4\u7684\u6d6e\u70b9\u6570\u6765\u66f4\u65b0\u8fdb\u5ea6\u7ea7\u522b\uff0c\u6216\u8005 with `Progress` \u5b9e\u4f8b\u7684 `tqdm()` \u65b9\u6cd5\u6765\u8ddf\u8e2a\u53ef\u8fed\u4ee3\u5bf9\u8c61\u4e0a\u7684\u8fdb\u5ea6\uff0c\u5982\u4e0b\u6240\u793a\u3002\u5fc5\u987b\u542f\u7528\u961f\u5217\u4ee5\u8fdb\u884c\u8fdb\u5ea6\u66f4\u65b0\u3002\n\n$code_progress_simple\n$demo_progress_simple\n\n\u5982\u679c\u60a8 with `tqdm` \u5e93\uff0c\u5e76\u4e14\u5e0c\u671b\u4ece\u51fd\u6570\u5185\u90e8\u7684\u4efb\u4f55 `tqdm.tqdm` \u81ea\u52a8\u62a5\u544a\u8fdb\u5ea6\u66f4\u65b0\uff0c\u8bf7\u5c06\u9ed8\u8ba4\u53c2\u6570\u8bbe\u7f6e\u4e3a `gr.Progress(track_tqdm=True)`\uff01\n\n## \u6279\u5904\u7406\u51fd\u6570 (Batch Functions)\n\nGradio \u652f\u6301\u4f20\u9012*\u6279\u5904\u7406*\u51fd\u6570\u3002\u6279\u5904\u7406\u51fd\u6570\u53ea\u662f\u63a5\u53d7\u8f93\u5165\u5217\u8868\u5e76\u8fd4\u56de\u9884\u6d4b\u5217\u8868\u7684\u51fd\u6570\u3002\n\n\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\u6279\u5904\u7406\u51fd\u6570\uff0c\u5b83\u63a5\u53d7\u4e24\u4e2a\u8f93\u5165\u5217\u8868\uff08\u4e00\u4e2a\u5355\u8bcd\u5217\u8868\u548c\u4e00\u4e2a\u6574\u6570\u5217\u8868\uff09\uff0c\u5e76\u8fd4\u56de\u4fee\u526a\u8fc7\u7684\u5355\u8bcd\u5217\u8868\u4f5c\u4e3a\u8f93\u51fa\uff1a\n\n```python\nimport time\n\ndef trim_words(words, lens):\n    trimmed_words = []\n    time.sleep(5)\n    for w, l in zip(words, lens):\n        trimmed_words.append(w[:int(l)])\n    return [trimmed_words]\n    for w, l in zip(words, lens):\n```\n\n\u4f7f\u7528\u6279\u5904\u7406\u51fd\u6570\u7684\u4f18\u70b9\u662f\uff0c\u5982\u679c\u542f\u7528\u4e86\u961f\u5217\uff0cGradio \u670d\u52a1\u5668\u53ef\u4ee5\u81ea\u52a8*\u6279\u5904\u7406*\u4f20\u5165\u7684\u8bf7\u6c42\u5e76\u5e76\u884c\u5904\u7406\u5b83\u4eec\uff0c\u4ece\u800c\u53ef\u80fd\u52a0\u5feb\u6f14\u793a\u901f\u5ea6\u3002\u4ee5\u4e0b\u662f Gradio \u4ee3\u7801\u7684\u793a\u4f8b\uff08\u8bf7\u6ce8\u610f `batch=True` \u548c `max_batch_size=16` - \u8fd9\u4e24\u4e2a\u53c2\u6570\u90fd\u53ef\u4ee5\u4f20\u9012\u7ed9\u4e8b\u4ef6\u89e6\u53d1\u5668\u6216 `Interface` \u7c7b\uff09\n\nwith `Interface`\uff1a\n\n```python\ndemo = gr.Interface(trim_words, [\"textbox\", \"number\"], [\"output\"],\n                    batch=True, max_batch_size=16)\ndemo.queue()\ndemo.launch()\n```\n\nwith `Blocks`\uff1a\n\n```python\nimport gradio as gr\n\nwith gr.Blocks() as demo:\n    with gr.Row():\n        word = gr.Textbox(label=\"word\")\n        leng = gr.Number(label=\"leng\")\n        output = gr.Textbox(label=\"Output\")\n    with gr.Row():\n        run = gr.Button()\n\n    event = run.click(trim_words, [word, leng], output, batch=True, max_batch_size=16)\n\ndemo.queue()\ndemo.launch()\n```\n\n\u5728\u4e0a\u9762\u7684\u793a\u4f8b\u4e2d\uff0c\u53ef\u4ee5\u5e76\u884c\u5904\u7406 16 \u4e2a\u8bf7\u6c42\uff08\u603b\u63a8\u7406\u65f6\u95f4\u4e3a 5 \u79d2\uff09\uff0c\u800c\u4e0d\u662f\u5206\u522b\u5904\u7406\u6bcf\u4e2a\u8bf7\u6c42\uff08\u603b\u63a8\u7406\u65f6\u95f4\u4e3a 80 \u79d2\uff09\u3002\u8bb8\u591a Hugging Face \u7684 `transformers` \u548c `diffusers` \u6a21\u578b\u5728 Gradio \u7684\u6279\u5904\u7406\u6a21\u5f0f\u4e0b\u81ea\u7136\u5de5\u4f5c\uff1a\u8fd9\u662f[\u4f7f\u7528\u6279\u5904\u7406\u751f\u6210\u56fe\u50cf\u7684\u793a\u4f8b\u6f14\u793a](https://github.com/gradio-app/gradio/blob/main/demo/diffusers_with_batching/run.py)\n\n\u6ce8\u610f\uff1a\u4f7f\u7528 Gradio \u7684\u6279\u5904\u7406\u51fd\u6570 **requires** \u5728\u5e95\u5c42 Interface \u6216 Blocks \u4e2d\u542f\u7528\u961f\u5217\uff08\u8bf7\u53c2\u9605\u4e0a\u9762\u7684\u961f\u5217\u90e8\u5206\uff09\u3002\n\n## Gradio \u7b14\u8bb0\u672c (Colab Notebooks)\n\nGradio \u53ef\u4ee5\u5728\u4efb\u4f55\u8fd0\u884c Python \u7684\u5730\u65b9\u8fd0\u884c\uff0c\u5305\u62ec\u672c\u5730 Jupyter \u7b14\u8bb0\u672c\u548c\u534f\u4f5c\u7b14\u8bb0\u672c\uff0c\u5982[Google Colab](https://colab.research.google.com/)\u3002\u5bf9\u4e8e\u672c\u5730 Jupyter \u7b14\u8bb0\u672c\u548c Google Colab \u7b14\u8bb0\u672c\uff0cGradio \u5728\u672c\u5730\u670d\u52a1\u5668\u4e0a\u8fd0\u884c\uff0c\u60a8\u53ef\u4ee5\u5728\u6d4f\u89c8\u5668\u4e2d\u4e0e\u4e4b\u4ea4\u4e92\u3002\uff08\u6ce8\u610f\uff1a\u5bf9\u4e8e Google Colab\uff0c\u8fd9\u662f\u901a\u8fc7[\u670d\u52a1\u5de5\u4f5c\u5668\u96a7\u9053](https://github.com/tensorflow/tensorboard/blob/master/docs/design/colab_integration.md)\u5b9e\u73b0\u7684\uff0c\u60a8\u7684\u6d4f\u89c8\u5668\u9700\u8981\u542f\u7528 cookies\u3002\uff09\u5bf9\u4e8e\u5176\u4ed6\u8fdc\u7a0b\u7b14\u8bb0\u672c\uff0cGradio \u4e5f\u5c06\u5728\u670d\u52a1\u5668\u4e0a\u8fd0\u884c\uff0c\u4f46\u60a8\u9700\u8981\u4f7f\u7528[SSH \u96a7\u9053](https://coderwall.com/p/ohk6cg/remote-access-to-ipython-notebooks-via-ssh)\u5728\u672c\u5730\u6d4f\u89c8\u5668\u4e2d\u67e5\u770b\u5e94\u7528\u7a0b\u5e8f\u3002\u901a\u5e38\uff0c\u66f4\u7b80\u5355\u7684\u9009\u62e9\u662f\u4f7f\u7528 Gradio \u5185\u7f6e\u7684\u516c\u5171\u94fe\u63a5\uff0c[\u5728\u4e0b\u4e00\u7bc7\u6307\u5357\u4e2d\u8ba8\u8bba](/sharing-your-app/#sharing-demos)\u3002\n--New Chunk--\n[Created at: 2025-03-24 13:15:42]\nCreate an Endpoint\n\nAfter your first login, you will be directed to the [Endpoint creation page](https://ui.endpoints.huggingface.co/new). As an example, this guide will go through the steps to deploy [distilbert-base-uncased-finetuned-sst-2-english](https://huggingface.co/distilbert-base-uncased-finetuned-sst-2-english) for text classification. \n\n## 1. Enter the Hugging Face Repository ID and your desired endpoint name:\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_repository.png\" alt=\"select repository\" />\n\n## 2. Select your Cloud Provider and region. Initially, only AWS will be available as a Cloud Provider with the `us-east-1` and `eu-west-1` regions. We will add Azure soon, and if you need to test Endpoints with other Cloud Providers or regions, please let us know.\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_region.png\" alt=\"select region\" />\n\n## 3. Define the [Security Level](security) for the Endpoint:\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_security.png\" alt=\"define security\" />\n\n## 4. Create your Endpoint by clicking **Create Endpoint**. By default, your Endpoint is created with a medium CPU (2 x 4GB vCPUs with Intel Xeon Ice Lake) The cost estimate assumes the Endpoint will be up for an entire month, and does not take autoscaling into account.\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_create_cost.png\" alt=\"create endpoint\" />\n\n## 5. Wait for the Endpoint to build, initialize and run which can take between 1 to 5 minutes.\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/overview.png\" alt=\"overview\" />\n\n## 6. Test your Endpoint in the overview with the Inference widget \ud83c\udfc1 \ud83c\udf89!\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_inference.png\" alt=\"run inference\" />\n--New Chunk--\n[Created at: 2025-03-24 13:19:17]\n!---\nCopyright 2022 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n-->\n\n# Token classification with LayoutLMv3 (PyTorch version)\n\nThis directory contains a script, `run_funsd_cord.py`, that can be used to fine-tune (or evaluate) LayoutLMv3 on form understanding datasets, such as [FUNSD](https://guillaumejaume.github.io/FUNSD/) and [CORD](https://github.com/clovaai/cord).\n\nThe script `run_funsd_cord.py` leverages the \ud83e\udd17 Datasets library and the Trainer API. You can easily customize it to your needs.\n\n## Fine-tuning on FUNSD\n\nFine-tuning LayoutLMv3 for token classification on [FUNSD](https://guillaumejaume.github.io/FUNSD/) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name funsd \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 1e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-funsd\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd. By specifying the `push_to_hub` flag, the model gets uploaded automatically to the hub (regularly), together with a model card, which includes metrics such as precision, recall and F1. Note that you can easily update the model card, as it's just a README file of the respective repo on the hub.\n\nThere's also the \"Training metrics\" [tab](https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd/tensorboard), which shows Tensorboard logs over the course of training. Pretty neat, huh?\n\n## Fine-tuning on CORD\n\nFine-tuning LayoutLMv3 for token classification on [CORD](https://github.com/clovaai/cord) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name cord \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 5e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-cord\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-cord. Note that a model card gets generated automatically in case you specify the `push_to_hub` flag."
        }
    },
    {
        "sample_idx": 34,
        "question": "What is required to use Gradio's batch function?",
        "answer": "Enabling the queue in the underlying Interface or Blocks is required.",
        "rag_answer": "To use Gradio's batch function, it is **required** to enable queueing in the underlying Interface or Blocks. This is because Gradio's batch function relies on the queueing mechanism to process batches of inputs in parallel.\n\nHere is an example of how to use Gradio's batch function with Interface:\n```python\ndemo = gr.Interface(trim_words, [\"textbox\", \"number\"], [\"output\"], batch=True, max_batch_size=16)\ndemo.queue()\ndemo.launch()\n```\nAnd here is an example with Blocks:\n```python\nwith gr.Blocks() as demo:\n    with gr.Row():\n        word = gr.Textbox(label=\"word\")\n        leng = gr.Number(label=\"leng\")\n        output = gr.Textbox(label=\"Output\")\n    with gr.Row():\n        run = gr.Button()\n\n    event = run.click(trim_words, [word, leng], output, batch=True, max_batch_size=16)\n\ndemo.queue()\ndemo.launch()\n```\nIn both cases, `batch=True` and `max_batch_size=16` are used to specify that the function should be executed in batch mode, with a maximum batch size of 16.\n\nReferences:\n[KG] Batch Functions\n[DC] Batch Functions",
        "rag_score": 5,
        "rag_feedback": "The system's response is completely correct, accurate, and factual. It provides a detailed explanation of how to use Gradio's batch function, including the requirements for enabling the queue in the underlying Interface or Blocks. The response also includes examples of how to use the batch function with Interface and Blocks, and provides additional information about Gradio's features, such as preprocessing and postprocessing, styling, queuing, and iterative outputs.",
        "rag_context": {
            "kg_context": "-----Entities-----\n    ```csv\n    id,\tentity,\ttype,\tdescription,\trankcreated_at\n1,\tBatch Functions,category,Batch Functions is a category of functions in Gradio that enables the processing of batches of inputs.,1,2025-03-24 13:17:31\n2,\tGradio,organization,Gradio is a platform that supports state in Blocks, providing features such as global state and session state.<SEP>Gradio is an interface that provides various features for demonstrating models, including adding example inputs, custom error messages, descriptive content, flagging, and more.<SEP>Gradio is an organization that provides a platform for building and deploying machine learning models.<SEP>Gradio is an organization that provides a platform for creating and deploying machine learning models.<SEP>Gradio is an organization that provides a demo for blocks_random_slider, and its library is used to create interactive interfaces.,36,2025-03-24 13:17:31\n3,\tqueue,category,Queue is a component in Gradio that enables the processing of batches of inputs.,1,2025-03-24 13:17:31\n4,\tPreprocessing and Postprocessing,category,Preprocessing and Postprocessing are features in Gradio that allow users to process data before and after it is input into a model.,1,2025-03-24 13:17:31\n5,\tBatch Functions,category,Batch Functions is a category of functions in Gradio that enables the processing of batches of inputs.,1,UNKNOWN\n6,\tExample Inputs,category,Example Inputs are a feature in Gradio that allows users to load sample data into an interface.,1,UNKNOWN\n7,\tqueue,category,Queue is a component in Gradio that enables the processing of batches of inputs.,1,UNKNOWN\n    ```\n    -----Relationships-----\n    ```csv\n    id,\tsource,\ttarget,\tdescription,\tkeywords,\tweight,\trank,\tcreated_at\n1,\tBatch Functions,Gradio,Gradio supports batch processing of inputs using batch functions.,functionality, batch processing,18.0,37,2025-03-24 13:17:31\n2,\tGradio,queue,Queue is a component in Gradio that enables batch processing.,component relationship, batch processing,8.0,37,2025-03-24 13:17:31\n3,\tGradio,Preprocessing and Postprocessing,Gradio provides features for preprocessing and postprocessing data.,data processing, interface feature,8.0,37,2025-03-24 13:17:31\n4,\tBatch Functions,Gradio,Gradio supports batch processing of inputs using batch functions.,functionality, batch processing,18.0,37,UNKNOWN\n5,\tExample Inputs,Gradio,Gradio allows users to add example inputs to an interface.,example inputs, interface feature,8.0,37,UNKNOWN\n6,\tGradio,queue,Queue is a component in Gradio that enables batch processing.,component relationship, batch processing,8.0,37,UNKNOWN\n    ```\n    -----Sources-----\n    ```csv\n    id,\tcontent\n1,\t\u4e0e\u5e38\u89c4\u51fd\u6570\u76f8\u540c\u7684\u65b9\u5f0f\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio\u3002\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\uff08\u865a\u62df\u7684\uff09\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5b83\u5728\u8f93\u51fa\u56fe\u50cf\u4e4b\u524d\u751f\u6210\u6570\u4e2a\u6b65\u9aa4\u7684\u566a\u97f3\uff1a\n\n$code_fake_diffusion\n$demo_fake_diffusion\n\n\u8bf7\u6ce8\u610f\uff0c\u6211\u4eec\u5728\u8fed\u4ee3\u5668\u4e2d\u6dfb\u52a0\u4e86 `time.sleep(1)`\uff0c\u4ee5\u521b\u5efa\u6b65\u9aa4\u4e4b\u95f4\u7684\u4eba\u5de5\u6682\u505c\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u89c2\u5bdf\u8fed\u4ee3\u5668\u7684\u6b65\u9aa4\uff08\u5728\u771f\u5b9e\u7684\u56fe\u50cf\u751f\u6210\u6a21\u578b\u4e2d\uff0c\u8fd9\u53ef\u80fd\u662f\u4e0d\u5fc5\u8981\u7684\uff09\u3002\n\n\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio **\u9700\u8981**\u5728\u5e95\u5c42 Interface \u6216 Blocks \u4e2d\u542f\u7528\u961f\u5217\uff08\u8bf7\u53c2\u9605\u4e0a\u9762\u7684\u961f\u5217\u90e8\u5206\uff09\u3002\n\n## \u8fdb\u5ea6\u6761\n\nGradio \u652f\u6301\u521b\u5efa\u81ea\u5b9a\u4e49\u8fdb\u5ea6\u6761\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u81ea\u5b9a\u4e49\u548c\u63a7\u5236\u5411\u7528\u6237\u663e\u793a\u7684\u8fdb\u5ea6\u66f4\u65b0\u3002\u8981\u542f\u7528\u6b64\u529f\u80fd\uff0c\u53ea\u9700\u4e3a\u65b9\u6cd5\u6dfb\u52a0\u4e00\u4e2a\u9ed8\u8ba4\u503c\u4e3a `gr.Progress` \u5b9e\u4f8b\u7684\u53c2\u6570\u5373\u53ef\u3002\u7136\u540e\uff0c\u60a8\u53ef\u4ee5\u76f4\u63a5\u8c03\u7528\u6b64\u5b9e\u4f8b\u5e76\u4f20\u5165 0 \u5230 1 \u4e4b\u95f4\u7684\u6d6e\u70b9\u6570\u6765\u66f4\u65b0\u8fdb\u5ea6\u7ea7\u522b\uff0c\u6216\u8005 with `Progress` \u5b9e\u4f8b\u7684 `tqdm()` \u65b9\u6cd5\u6765\u8ddf\u8e2a\u53ef\u8fed\u4ee3\u5bf9\u8c61\u4e0a\u7684\u8fdb\u5ea6\uff0c\u5982\u4e0b\u6240\u793a\u3002\u5fc5\u987b\u542f\u7528\u961f\u5217\u4ee5\u8fdb\u884c\u8fdb\u5ea6\u66f4\u65b0\u3002\n\n$code_progress_simple\n$demo_progress_simple\n\n\u5982\u679c\u60a8 with `tqdm` \u5e93\uff0c\u5e76\u4e14\u5e0c\u671b\u4ece\u51fd\u6570\u5185\u90e8\u7684\u4efb\u4f55 `tqdm.tqdm` \u81ea\u52a8\u62a5\u544a\u8fdb\u5ea6\u66f4\u65b0\uff0c\u8bf7\u5c06\u9ed8\u8ba4\u53c2\u6570\u8bbe\u7f6e\u4e3a `gr.Progress(track_tqdm=True)`\uff01\n\n## \u6279\u5904\u7406\u51fd\u6570 (Batch Functions)\n\nGradio \u652f\u6301\u4f20\u9012*\u6279\u5904\u7406*\u51fd\u6570\u3002\u6279\u5904\u7406\u51fd\u6570\u53ea\u662f\u63a5\u53d7\u8f93\u5165\u5217\u8868\u5e76\u8fd4\u56de\u9884\u6d4b\u5217\u8868\u7684\u51fd\u6570\u3002\n\n\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\u6279\u5904\u7406\u51fd\u6570\uff0c\u5b83\u63a5\u53d7\u4e24\u4e2a\u8f93\u5165\u5217\u8868\uff08\u4e00\u4e2a\u5355\u8bcd\u5217\u8868\u548c\u4e00\u4e2a\u6574\u6570\u5217\u8868\uff09\uff0c\u5e76\u8fd4\u56de\u4fee\u526a\u8fc7\u7684\u5355\u8bcd\u5217\u8868\u4f5c\u4e3a\u8f93\u51fa\uff1a\n\n```python\nimport time\n\ndef trim_words(words, lens):\n    trimmed_words = []\n    time.sleep(5)\n    for w, l in zip(words, lens):\n        trimmed_words.append(w[:int(l)])\n    return [trimmed_words]\n    for w, l in zip(words, lens):\n```\n\n\u4f7f\u7528\u6279\u5904\u7406\u51fd\u6570\u7684\u4f18\u70b9\u662f\uff0c\u5982\u679c\u542f\u7528\u4e86\u961f\u5217\uff0cGradio \u670d\u52a1\u5668\u53ef\u4ee5\u81ea\u52a8*\u6279\u5904\u7406*\u4f20\u5165\u7684\u8bf7\u6c42\u5e76\u5e76\u884c\u5904\u7406\u5b83\u4eec\uff0c\u4ece\u800c\u53ef\u80fd\u52a0\u5feb\u6f14\u793a\u901f\u5ea6\u3002\u4ee5\u4e0b\u662f Gradio \u4ee3\u7801\u7684\u793a\u4f8b\uff08\u8bf7\u6ce8\u610f `batch=True` \u548c `max_batch_size=16` - \u8fd9\u4e24\u4e2a\u53c2\u6570\u90fd\u53ef\u4ee5\u4f20\u9012\u7ed9\u4e8b\u4ef6\u89e6\u53d1\u5668\u6216 `Interface` \u7c7b\uff09\n\nwith `Interface`\uff1a\n\n```python\ndemo = gr.Interface(trim_words, [\"textbox\", \"number\"], [\"output\"],\n                    batch=True, max_batch_size=16)\ndemo.queue()\ndemo.launch()\n```\n\nwith `Blocks`\uff1a\n\n```python\nimport gradio as gr\n\nwith gr.Blocks() as demo:\n    with gr.Row():\n        word = gr.Textbox(label=\"word\")\n        leng = gr.Number(label=\"leng\")\n        output = gr.Textbox(label=\"Output\")\n    with gr.Row():\n        run = gr.Button()\n\n    event = run.click(trim_words, [word, leng], output, batch=True, max_batch_size=16)\n\ndemo.queue()\ndemo.launch()\n```\n\n\u5728\u4e0a\u9762\u7684\u793a\u4f8b\u4e2d\uff0c\u53ef\u4ee5\u5e76\u884c\u5904\u7406 16 \u4e2a\u8bf7\u6c42\uff08\u603b\u63a8\u7406\u65f6\u95f4\u4e3a 5 \u79d2\uff09\uff0c\u800c\u4e0d\u662f\u5206\u522b\u5904\u7406\u6bcf\u4e2a\u8bf7\u6c42\uff08\u603b\u63a8\u7406\u65f6\u95f4\u4e3a 80 \u79d2\uff09\u3002\u8bb8\u591a Hugging Face \u7684 `transformers` \u548c `diffusers` \u6a21\u578b\u5728 Gradio \u7684\u6279\u5904\u7406\u6a21\u5f0f\u4e0b\u81ea\u7136\u5de5\u4f5c\uff1a\u8fd9\u662f[\u4f7f\u7528\u6279\u5904\u7406\u751f\u6210\u56fe\u50cf\u7684\u793a\u4f8b\u6f14\u793a](https://github.com/gradio-app/gradio/blob/main/demo/diffusers_with_batching/run.py)\n\n\u6ce8\u610f\uff1a\u4f7f\u7528 Gradio \u7684\u6279\u5904\u7406\u51fd\u6570 **requires** \u5728\u5e95\u5c42 Interface \u6216 Blocks \u4e2d\u542f\u7528\u961f\u5217\uff08\u8bf7\u53c2\u9605\u4e0a\u9762\u7684\u961f\u5217\u90e8\u5206\uff09\u3002\n\n## Gradio \u7b14\u8bb0\u672c (Colab Notebooks)\n\nGradio \u53ef\u4ee5\u5728\u4efb\u4f55\u8fd0\u884c Python \u7684\u5730\u65b9\u8fd0\u884c\uff0c\u5305\u62ec\u672c\u5730 Jupyter \u7b14\u8bb0\u672c\u548c\u534f\u4f5c\u7b14\u8bb0\u672c\uff0c\u5982[Google Colab](https://colab.research.google.com/)\u3002\u5bf9\u4e8e\u672c\u5730 Jupyter \u7b14\u8bb0\u672c\u548c Google Colab \u7b14\u8bb0\u672c\uff0cGradio \u5728\u672c\u5730\u670d\u52a1\u5668\u4e0a\u8fd0\u884c\uff0c\u60a8\u53ef\u4ee5\u5728\u6d4f\u89c8\u5668\u4e2d\u4e0e\u4e4b\u4ea4\u4e92\u3002\uff08\u6ce8\u610f\uff1a\u5bf9\u4e8e Google Colab\uff0c\u8fd9\u662f\u901a\u8fc7[\u670d\u52a1\u5de5\u4f5c\u5668\u96a7\u9053](https://github.com/tensorflow/tensorboard/blob/master/docs/design/colab_integration.md)\u5b9e\u73b0\u7684\uff0c\u60a8\u7684\u6d4f\u89c8\u5668\u9700\u8981\u542f\u7528 cookies\u3002\uff09\u5bf9\u4e8e\u5176\u4ed6\u8fdc\u7a0b\u7b14\u8bb0\u672c\uff0cGradio \u4e5f\u5c06\u5728\u670d\u52a1\u5668\u4e0a\u8fd0\u884c\uff0c\u4f46\u60a8\u9700\u8981\u4f7f\u7528[SSH \u96a7\u9053](https://coderwall.com/p/ohk6cg/remote-access-to-ipython-notebooks-via-ssh)\u5728\u672c\u5730\u6d4f\u89c8\u5668\u4e2d\u67e5\u770b\u5e94\u7528\u7a0b\u5e8f\u3002\u901a\u5e38\uff0c\u66f4\u7b80\u5355\u7684\u9009\u62e9\u662f\u4f7f\u7528 Gradio \u5185\u7f6e\u7684\u516c\u5171\u94fe\u63a5\uff0c[\u5728\u4e0b\u4e00\u7bc7\u6307\u5357\u4e2d\u8ba8\u8bba](/sharing-your-app/#sharing-demos)\u3002\n2,\t\u4e3b\u8981\u7279\u70b9\n\n\u8ba9\u6211\u4eec\u6765\u4ecb\u7ecd\u4e00\u4e0b Gradio \u6700\u53d7\u6b22\u8fce\u7684\u4e00\u4e9b\u529f\u80fd\uff01\u8fd9\u91cc\u662f Gradio \u7684\u4e3b\u8981\u7279\u70b9\uff1a\n\n1. [\u6dfb\u52a0\u793a\u4f8b\u8f93\u5165](#example-inputs)\n2. [\u4f20\u9012\u81ea\u5b9a\u4e49\u9519\u8bef\u6d88\u606f](#errors)\n3. [\u6dfb\u52a0\u63cf\u8ff0\u5185\u5bb9](#descriptive-content)\n4. [\u8bbe\u7f6e\u65d7\u6807](#flagging)\n5. [\u9884\u5904\u7406\u548c\u540e\u5904\u7406](#preprocessing-and-postprocessing)\n6. [\u6837\u5f0f\u5316\u6f14\u793a](#styling)\n7. [\u6392\u961f\u7528\u6237](#queuing)\n8. [\u8fed\u4ee3\u8f93\u51fa](#iterative-outputs)\n9. [\u8fdb\u5ea6\u6761](#progress-bars)\n10. [\u6279\u5904\u7406\u51fd\u6570](#batch-functions)\n11. [\u5728\u534f\u4f5c\u7b14\u8bb0\u672c\u4e0a\u8fd0\u884c](#colab-notebooks)\n\n## \u793a\u4f8b\u8f93\u5165\n\n\u60a8\u53ef\u4ee5\u63d0\u4f9b\u7528\u6237\u53ef\u4ee5\u8f7b\u677e\u52a0\u8f7d\u5230 \"Interface\" \u4e2d\u7684\u793a\u4f8b\u6570\u636e\u3002\u8fd9\u5bf9\u4e8e\u6f14\u793a\u6a21\u578b\u671f\u671b\u7684\u8f93\u5165\u7c7b\u578b\u4ee5\u53ca\u6f14\u793a\u6570\u636e\u96c6\u548c\u6a21\u578b\u4e00\u8d77\u63a2\u7d22\u7684\u65b9\u5f0f\u975e\u5e38\u6709\u5e2e\u52a9\u3002\u8981\u52a0\u8f7d\u793a\u4f8b\u6570\u636e\uff0c\u60a8\u53ef\u4ee5\u5c06\u5d4c\u5957\u5217\u8868\u63d0\u4f9b\u7ed9 Interface \u6784\u9020\u51fd\u6570\u7684 `examples=` \u5173\u952e\u5b57\u53c2\u6570\u3002\u5916\u90e8\u5217\u8868\u4e2d\u7684\u6bcf\u4e2a\u5b50\u5217\u8868\u8868\u793a\u4e00\u4e2a\u6570\u636e\u6837\u672c\uff0c\u5b50\u5217\u8868\u4e2d\u7684\u6bcf\u4e2a\u5143\u7d20\u8868\u793a\u6bcf\u4e2a\u8f93\u5165\u7ec4\u4ef6\u7684\u8f93\u5165\u3002\u6709\u5173\u6bcf\u4e2a\u7ec4\u4ef6\u7684\u793a\u4f8b\u6570\u636e\u683c\u5f0f\u5728[Docs](https://gradio.app/docs#components)\u4e2d\u6709\u8bf4\u660e\u3002\n\n$code_calculator\n$demo_calculator\n\n\u60a8\u53ef\u4ee5\u5c06\u5927\u578b\u6570\u636e\u96c6\u52a0\u8f7d\u5230\u793a\u4f8b\u4e2d\uff0c\u901a\u8fc7 Gradio \u6d4f\u89c8\u548c\u4e0e\u6570\u636e\u96c6\u8fdb\u884c\u4ea4\u4e92\u3002\u793a\u4f8b\u5c06\u81ea\u52a8\u5206\u9875\uff08\u53ef\u4ee5\u901a\u8fc7 Interface \u7684 `examples_per_page` \u53c2\u6570\u8fdb\u884c\u914d\u7f6e\uff09\u3002\n\n\u7ee7\u7eed\u4e86\u89e3\u793a\u4f8b\uff0c\u8bf7\u53c2\u9605[\u66f4\u591a\u793a\u4f8b](https://gradio.app/more-on-examples)\u6307\u5357\u3002\n\n## \u9519\u8bef\n\n\u60a8\u5e0c\u671b\u5411\u7528\u6237\u4f20\u9012\u81ea\u5b9a\u4e49\u9519\u8bef\u6d88\u606f\u3002\u4e3a\u6b64\uff0cwith `gr.Error(\"custom message\")` \u6765\u663e\u793a\u9519\u8bef\u6d88\u606f\u3002\u5982\u679c\u5728\u4e0a\u9762\u7684\u8ba1\u7b97\u5668\u793a\u4f8b\u4e2d\u5c1d\u8bd5\u9664\u4ee5\u96f6\uff0c\u5c06\u663e\u793a\u81ea\u5b9a\u4e49\u9519\u8bef\u6d88\u606f\u7684\u5f39\u51fa\u6a21\u6001\u7a97\u53e3\u3002\u4e86\u89e3\u6709\u5173\u9519\u8bef\u7684\u66f4\u591a\u4fe1\u606f\uff0c\u8bf7\u53c2\u9605[\u6587\u6863](https://gradio.app/docs#error)\u3002\n\n## \u63cf\u8ff0\u6027\u5185\u5bb9\n\n\u5728\u524d\u9762\u7684\u793a\u4f8b\u4e2d\uff0c\u60a8\u53ef\u80fd\u5df2\u7ecf\u6ce8\u610f\u5230 Interface \u6784\u9020\u51fd\u6570\u4e2d\u7684 `title=` \u548c `description=` \u5173\u952e\u5b57\u53c2\u6570\uff0c\u5e2e\u52a9\u7528\u6237\u4e86\u89e3\u60a8\u7684\u5e94\u7528\u7a0b\u5e8f\u3002\n\nInterface \u6784\u9020\u51fd\u6570\u4e2d\u6709\u4e09\u4e2a\u53c2\u6570\u7528\u4e8e\u6307\u5b9a\u6b64\u5185\u5bb9\u5e94\u653e\u7f6e\u5728\u54ea\u91cc\uff1a\n\n- `title`\uff1a\u63a5\u53d7\u6587\u672c\uff0c\u5e76\u53ef\u4ee5\u5c06\u5176\u663e\u793a\u5728\u754c\u9762\u7684\u9876\u90e8\uff0c\u4e5f\u5c06\u6210\u4e3a\u9875\u9762\u6807\u9898\u3002\n- `description`\uff1a\u63a5\u53d7\u6587\u672c\u3001Markdown \u6216 HTML\uff0c\u5e76\u5c06\u5176\u653e\u7f6e\u5728\u6807\u9898\u6b63\u4e0b\u65b9\u3002\n- `article`\uff1a\u4e5f\u63a5\u53d7\u6587\u672c\u3001Markdown \u6216 HTML\uff0c\u5e76\u5c06\u5176\u653e\u7f6e\u5728\u754c\u9762\u4e0b\u65b9\u3002\n\n![annotated](/assets/guides/annotated.png)\n\n\u5982\u679c\u60a8\u4f7f\u7528\u7684\u662f `Blocks` API\uff0c\u5219\u53ef\u4ee5 with `gr.Markdown(...)` \u6216 `gr.HTML(...)` \u7ec4\u4ef6\u5728\u4efb\u4f55\u4f4d\u7f6e\u63d2\u5165\u6587\u672c\u3001Markdown \u6216 HTML\uff0c\u5176\u4e2d\u63cf\u8ff0\u6027\u5185\u5bb9\u4f4d\u4e8e `Component` \u6784\u9020\u51fd\u6570\u5185\u90e8\u3002\n\n\u53e6\u4e00\u4e2a\u6709\u7528\u7684\u5173\u952e\u5b57\u53c2\u6570\u662f `label=`\uff0c\u5b83\u5b58\u5728\u4e8e\u6bcf\u4e2a `Component` \u4e2d\u3002\u8fd9\u4fee\u6539\u4e86\u6bcf\u4e2a `Component` \u9876\u90e8\u7684\u6807\u7b7e\u6587\u672c\u3002\u8fd8\u53ef\u4ee5\u4e3a\u8bf8\u5982 `Textbox` \u6216 `Radio` \u4e4b\u7c7b\u7684\u8868\u5355\u5143\u7d20\u6dfb\u52a0 `info=` \u5173\u952e\u5b57\u53c2\u6570\uff0c\u4ee5\u63d0\u4f9b\u6709\u5173\u5176\u7528\u6cd5\u7684\u8fdb\u4e00\u6b65\u4fe1\u606f\u3002\n\n```python\ngr.Number(label='\u5e74\u9f84', info='\u4ee5\u5e74\u4e3a\u5355\u4f4d\uff0c\u5fc5\u987b\u5927\u4e8e0')\n```\n\n## \u65d7\u6807\n\n\u9ed8\u8ba4\u60c5\u51b5\u4e0b\uff0c\"Interface\" \u5c06\u6709\u4e00\u4e2a \"Flag\" \u6309\u94ae\u3002\u5f53\u7528\u6237\u6d4b\u8bd5\u60a8\u7684 `Interface` \u65f6\uff0c\u5982\u679c\u770b\u5230\u6709\u8da3\u7684\u8f93\u51fa\uff0c\u4f8b\u5982\u9519\u8bef\u6216\u610f\u5916\u7684\u6a21\u578b\u884c\u4e3a\uff0c\u4ed6\u4eec\u53ef\u4ee5\u5c06\u8f93\u5165\u6807\u8bb0\u4e3a\u60a8\u8fdb\u884c\u67e5\u770b\u3002\u5728\u7531 `Interface` \u6784\u9020\u51fd\u6570\u7684 `flagging_dir=` \u53c2\u6570\u63d0\u4f9b\u7684\u76ee\u5f55\u4e2d\uff0c\u5c06\u8bb0\u5f55\u6807\u8bb0\u7684\u8f93\u5165\u5230\u4e00\u4e2a CSV \u6587\u4ef6\u4e2d\u3002\u5982\u679c\u754c\u9762\u6d89\u53ca\u6587\u4ef6\u6570\u636e\uff0c\u4f8b\u5982\u56fe\u50cf\u548c\u97f3\u9891\u7ec4\u4ef6\uff0c\u5c06\u521b\u5efa\u6587\u4ef6\u5939\u6765\u5b58\u50a8\u8fd9\u4e9b\u6807\u8bb0\u7684\u6570\u636e\u3002\n\n\u4f8b\u5982\uff0c\u5bf9\u4e8e\u4e0a\u9762\u663e\u793a\u7684\u8ba1\u7b97\u5668\u754c\u9762\uff0c\u6211\u4eec\u5c06\u5728\u4e0b\u9762\u7684\u65d7\u6807\u76ee\u5f55\u4e2d\u5b58\u50a8\u6807\u8bb0\u7684\u6570\u636e\uff1a\n\n```directory\n+-- calculator.py\n+-- flagged/\n|   +-- logs.csv\n```\n\n_flagged/logs.csv_\n\n```csv\nnum1,operation,num2,Output\n5,add,7,12\n6,subtract,1.5,4.5\n```\n\n\u4e0e\u65e9\u671f\u663e\u793a\u7684\u51b7\u8272\u754c\u9762\u76f8\u5bf9\u5e94\uff0c\u6211\u4eec\u5c06\u5728\u4e0b\u9762\u7684\u65d7\u6807\u76ee\u5f55\u4e2d\u5b58\u50a8\u6807\u8bb0\u7684\u6570\u636e\uff1a\n\n```directory\n+-- sepia.py\n+-- flagged/\n|   +-- logs.csv\n|   +-- im/\n|   |   +-- 0.png\n|   |   +-- 1.png\n|   +-- Output/\n|   |   +-- 0.png\n|   |   +-- 1.png\n```\n\n_flagged/logs.csv_\n\n```csv\nim,Output\nim/0.png,Output/0.png\nim/1.png,Output/1.png\n```\n\n\u5982\u679c\u60a8\u5e0c\u671b\u7528\u6237\u63d0\u4f9b\u65d7\u6807\u539f\u56e0\uff0c\u53ef\u4ee5\u5c06\u5b57\u7b26\u4e32\u5217\u8868\u4f20\u9012\u7ed9 Interface \u7684 `flagging_options` \u53c2\u6570\u3002\u7528\u6237\u5728\u8fdb\u884c\u65d7\u6807\u65f6\u5fc5\u987b\u9009\u62e9\u5176\u4e2d\u4e00\u4e2a\u5b57\u7b26\u4e32\uff0c\u8fd9\u5c06\u4f5c\u4e3a\u9644\u52a0\u5217\u4fdd\u5b58\u5230 CSV \u4e2d\u3002\n\n## \u9884\u5904\u7406\u548c\u540e\u5904\u7406 (Preprocessing and Postprocessing)\n\n![annotated](/assets/img/dataflow.svg)\n\n\u5982\u60a8\u6240\u89c1\uff0cGradio \u5305\u62ec\u53ef\u4ee5\u5904\u7406\u5404\u79cd\u4e0d\u540c\u6570\u636e\u7c7b\u578b\u7684\u7ec4\u4ef6\uff0c\u4f8b\u5982\u56fe\u50cf\u3001\u97f3\u9891\u548c\u89c6\u9891\u3002\u5927\u591a\u6570\u7ec4\u4ef6\u90fd\u53ef\u4ee5\u7528\u4f5c\u8f93\u5165\u6216\u8f93\u51fa\u3002\n\n\u5f53\u7ec4\u4ef6\u7528\u4f5c\u8f93\u5165\u65f6\uff0cGradio \u81ea\u52a8\u5904\u7406*\u9884\u5904\u7406*\uff0c\u5c06\u6570\u636e\u4ece\u7528\u6237\n    ```",
            "vector_context": "[Created at: 2025-03-24 13:16:48]\n\u4e3b\u8981\u7279\u70b9\n\n\u8ba9\u6211\u4eec\u6765\u4ecb\u7ecd\u4e00\u4e0b Gradio \u6700\u53d7\u6b22\u8fce\u7684\u4e00\u4e9b\u529f\u80fd\uff01\u8fd9\u91cc\u662f Gradio \u7684\u4e3b\u8981\u7279\u70b9\uff1a\n\n1. [\u6dfb\u52a0\u793a\u4f8b\u8f93\u5165](#example-inputs)\n2. [\u4f20\u9012\u81ea\u5b9a\u4e49\u9519\u8bef\u6d88\u606f](#errors)\n3. [\u6dfb\u52a0\u63cf\u8ff0\u5185\u5bb9](#descriptive-content)\n4. [\u8bbe\u7f6e\u65d7\u6807](#flagging)\n5. [\u9884\u5904\u7406\u548c\u540e\u5904\u7406](#preprocessing-and-postprocessing)\n6. [\u6837\u5f0f\u5316\u6f14\u793a](#styling)\n7. [\u6392\u961f\u7528\u6237](#queuing)\n8. [\u8fed\u4ee3\u8f93\u51fa](#iterative-outputs)\n9. [\u8fdb\u5ea6\u6761](#progress-bars)\n10. [\u6279\u5904\u7406\u51fd\u6570](#batch-functions)\n11. [\u5728\u534f\u4f5c\u7b14\u8bb0\u672c\u4e0a\u8fd0\u884c](#colab-notebooks)\n\n## \u793a\u4f8b\u8f93\u5165\n\n\u60a8\u53ef\u4ee5\u63d0\u4f9b\u7528\u6237\u53ef\u4ee5\u8f7b\u677e\u52a0\u8f7d\u5230 \"Interface\" \u4e2d\u7684\u793a\u4f8b\u6570\u636e\u3002\u8fd9\u5bf9\u4e8e\u6f14\u793a\u6a21\u578b\u671f\u671b\u7684\u8f93\u5165\u7c7b\u578b\u4ee5\u53ca\u6f14\u793a\u6570\u636e\u96c6\u548c\u6a21\u578b\u4e00\u8d77\u63a2\u7d22\u7684\u65b9\u5f0f\u975e\u5e38\u6709\u5e2e\u52a9\u3002\u8981\u52a0\u8f7d\u793a\u4f8b\u6570\u636e\uff0c\u60a8\u53ef\u4ee5\u5c06\u5d4c\u5957\u5217\u8868\u63d0\u4f9b\u7ed9 Interface \u6784\u9020\u51fd\u6570\u7684 `examples=` \u5173\u952e\u5b57\u53c2\u6570\u3002\u5916\u90e8\u5217\u8868\u4e2d\u7684\u6bcf\u4e2a\u5b50\u5217\u8868\u8868\u793a\u4e00\u4e2a\u6570\u636e\u6837\u672c\uff0c\u5b50\u5217\u8868\u4e2d\u7684\u6bcf\u4e2a\u5143\u7d20\u8868\u793a\u6bcf\u4e2a\u8f93\u5165\u7ec4\u4ef6\u7684\u8f93\u5165\u3002\u6709\u5173\u6bcf\u4e2a\u7ec4\u4ef6\u7684\u793a\u4f8b\u6570\u636e\u683c\u5f0f\u5728[Docs](https://gradio.app/docs#components)\u4e2d\u6709\u8bf4\u660e\u3002\n\n$code_calculator\n$demo_calculator\n\n\u60a8\u53ef\u4ee5\u5c06\u5927\u578b\u6570\u636e\u96c6\u52a0\u8f7d\u5230\u793a\u4f8b\u4e2d\uff0c\u901a\u8fc7 Gradio \u6d4f\u89c8\u548c\u4e0e\u6570\u636e\u96c6\u8fdb\u884c\u4ea4\u4e92\u3002\u793a\u4f8b\u5c06\u81ea\u52a8\u5206\u9875\uff08\u53ef\u4ee5\u901a\u8fc7 Interface \u7684 `examples_per_page` \u53c2\u6570\u8fdb\u884c\u914d\u7f6e\uff09\u3002\n\n\u7ee7\u7eed\u4e86\u89e3\u793a\u4f8b\uff0c\u8bf7\u53c2\u9605[\u66f4\u591a\u793a\u4f8b](https://gradio.app/more-on-examples)\u6307\u5357\u3002\n\n## \u9519\u8bef\n\n\u60a8\u5e0c\u671b\u5411\u7528\u6237\u4f20\u9012\u81ea\u5b9a\u4e49\u9519\u8bef\u6d88\u606f\u3002\u4e3a\u6b64\uff0cwith `gr.Error(\"custom message\")` \u6765\u663e\u793a\u9519\u8bef\u6d88\u606f\u3002\u5982\u679c\u5728\u4e0a\u9762\u7684\u8ba1\u7b97\u5668\u793a\u4f8b\u4e2d\u5c1d\u8bd5\u9664\u4ee5\u96f6\uff0c\u5c06\u663e\u793a\u81ea\u5b9a\u4e49\u9519\u8bef\u6d88\u606f\u7684\u5f39\u51fa\u6a21\u6001\u7a97\u53e3\u3002\u4e86\u89e3\u6709\u5173\u9519\u8bef\u7684\u66f4\u591a\u4fe1\u606f\uff0c\u8bf7\u53c2\u9605[\u6587\u6863](https://gradio.app/docs#error)\u3002\n\n## \u63cf\u8ff0\u6027\u5185\u5bb9\n\n\u5728\u524d\u9762\u7684\u793a\u4f8b\u4e2d\uff0c\u60a8\u53ef\u80fd\u5df2\u7ecf\u6ce8\u610f\u5230 Interface \u6784\u9020\u51fd\u6570\u4e2d\u7684 `title=` \u548c `description=` \u5173\u952e\u5b57\u53c2\u6570\uff0c\u5e2e\u52a9\u7528\u6237\u4e86\u89e3\u60a8\u7684\u5e94\u7528\u7a0b\u5e8f\u3002\n\nInterface \u6784\u9020\u51fd\u6570\u4e2d\u6709\u4e09\u4e2a\u53c2\u6570\u7528\u4e8e\u6307\u5b9a\u6b64\u5185\u5bb9\u5e94\u653e\u7f6e\u5728\u54ea\u91cc\uff1a\n\n- `title`\uff1a\u63a5\u53d7\u6587\u672c\uff0c\u5e76\u53ef\u4ee5\u5c06\u5176\u663e\u793a\u5728\u754c\u9762\u7684\u9876\u90e8\uff0c\u4e5f\u5c06\u6210\u4e3a\u9875\u9762\u6807\u9898\u3002\n- `description`\uff1a\u63a5\u53d7\u6587\u672c\u3001Markdown \u6216 HTML\uff0c\u5e76\u5c06\u5176\u653e\u7f6e\u5728\u6807\u9898\u6b63\u4e0b\u65b9\u3002\n- `article`\uff1a\u4e5f\u63a5\u53d7\u6587\u672c\u3001Markdown \u6216 HTML\uff0c\u5e76\u5c06\u5176\u653e\u7f6e\u5728\u754c\u9762\u4e0b\u65b9\u3002\n\n![annotated](/assets/guides/annotated.png)\n\n\u5982\u679c\u60a8\u4f7f\u7528\u7684\u662f `Blocks` API\uff0c\u5219\u53ef\u4ee5 with `gr.Markdown(...)` \u6216 `gr.HTML(...)` \u7ec4\u4ef6\u5728\u4efb\u4f55\u4f4d\u7f6e\u63d2\u5165\u6587\u672c\u3001Markdown \u6216 HTML\uff0c\u5176\u4e2d\u63cf\u8ff0\u6027\u5185\u5bb9\u4f4d\u4e8e `Component` \u6784\u9020\u51fd\u6570\u5185\u90e8\u3002\n\n\u53e6\u4e00\u4e2a\u6709\u7528\u7684\u5173\u952e\u5b57\u53c2\u6570\u662f `label=`\uff0c\u5b83\u5b58\u5728\u4e8e\u6bcf\u4e2a `Component` \u4e2d\u3002\u8fd9\u4fee\u6539\u4e86\u6bcf\u4e2a `Component` \u9876\u90e8\u7684\u6807\u7b7e\u6587\u672c\u3002\u8fd8\u53ef\u4ee5\u4e3a\u8bf8\u5982 `Textbox` \u6216 `Radio` \u4e4b\u7c7b\u7684\u8868\u5355\u5143\u7d20\u6dfb\u52a0 `info=` \u5173\u952e\u5b57\u53c2\u6570\uff0c\u4ee5\u63d0\u4f9b\u6709\u5173\u5176\u7528\u6cd5\u7684\u8fdb\u4e00\u6b65\u4fe1\u606f\u3002\n\n```python\ngr.Number(label='\u5e74\u9f84', info='\u4ee5\u5e74\u4e3a\u5355\u4f4d\uff0c\u5fc5\u987b\u5927\u4e8e0')\n```\n\n## \u65d7\u6807\n\n\u9ed8\u8ba4\u60c5\u51b5\u4e0b\uff0c\"Interface\" \u5c06\u6709\u4e00\u4e2a \"Flag\" \u6309\u94ae\u3002\u5f53\u7528\u6237\u6d4b\u8bd5\u60a8\u7684 `Interface` \u65f6\uff0c\u5982\u679c\u770b\u5230\u6709\u8da3\u7684\u8f93\u51fa\uff0c\u4f8b\u5982\u9519\u8bef\u6216\u610f\u5916\u7684\u6a21\u578b\u884c\u4e3a\uff0c\u4ed6\u4eec\u53ef\u4ee5\u5c06\u8f93\u5165\u6807\u8bb0\u4e3a\u60a8\u8fdb\u884c\u67e5\u770b\u3002\u5728\u7531 `Interface` \u6784\u9020\u51fd\u6570\u7684 `flagging_dir=` \u53c2\u6570\u63d0\u4f9b\u7684\u76ee\u5f55\u4e2d\uff0c\u5c06\u8bb0\u5f55\u6807\u8bb0\u7684\u8f93\u5165\u5230\u4e00\u4e2a CSV \u6587\u4ef6\u4e2d\u3002\u5982\u679c\u754c\u9762\u6d89\u53ca\u6587\u4ef6\u6570\u636e\uff0c\u4f8b\u5982\u56fe\u50cf\u548c\u97f3\u9891\u7ec4\u4ef6\uff0c\u5c06\u521b\u5efa\u6587\u4ef6\u5939\u6765\u5b58\u50a8\u8fd9\u4e9b\u6807\u8bb0\u7684\u6570\u636e\u3002\n\n\u4f8b\u5982\uff0c\u5bf9\u4e8e\u4e0a\u9762\u663e\u793a\u7684\u8ba1\u7b97\u5668\u754c\u9762\uff0c\u6211\u4eec\u5c06\u5728\u4e0b\u9762\u7684\u65d7\u6807\u76ee\u5f55\u4e2d\u5b58\u50a8\u6807\u8bb0\u7684\u6570\u636e\uff1a\n\n```directory\n+-- calculator.py\n+-- flagged/\n|   +-- logs.csv\n```\n\n_flagged/logs.csv_\n\n```csv\nnum1,operation,num2,Output\n5,add,7,12\n6,subtract,1.5,4.5\n```\n\n\u4e0e\u65e9\u671f\u663e\u793a\u7684\u51b7\u8272\u754c\u9762\u76f8\u5bf9\u5e94\uff0c\u6211\u4eec\u5c06\u5728\u4e0b\u9762\u7684\u65d7\u6807\u76ee\u5f55\u4e2d\u5b58\u50a8\u6807\u8bb0\u7684\u6570\u636e\uff1a\n\n```directory\n+-- sepia.py\n+-- flagged/\n|   +-- logs.csv\n|   +-- im/\n|   |   +-- 0.png\n|   |   +-- 1.png\n|   +-- Output/\n|   |   +-- 0.png\n|   |   +-- 1.png\n```\n\n_flagged/logs.csv_\n\n```csv\nim,Output\nim/0.png,Output/0.png\nim/1.png,Output/1.png\n```\n\n\u5982\u679c\u60a8\u5e0c\u671b\u7528\u6237\u63d0\u4f9b\u65d7\u6807\u539f\u56e0\uff0c\u53ef\u4ee5\u5c06\u5b57\u7b26\u4e32\u5217\u8868\u4f20\u9012\u7ed9 Interface \u7684 `flagging_options` \u53c2\u6570\u3002\u7528\u6237\u5728\u8fdb\u884c\u65d7\u6807\u65f6\u5fc5\u987b\u9009\u62e9\u5176\u4e2d\u4e00\u4e2a\u5b57\u7b26\u4e32\uff0c\u8fd9\u5c06\u4f5c\u4e3a\u9644\u52a0\u5217\u4fdd\u5b58\u5230 CSV \u4e2d\u3002\n\n## \u9884\u5904\u7406\u548c\u540e\u5904\u7406 (Preprocessing and Postprocessing)\n\n![annotated](/assets/img/dataflow.svg)\n\n\u5982\u60a8\u6240\u89c1\uff0cGradio \u5305\u62ec\u53ef\u4ee5\u5904\u7406\u5404\u79cd\u4e0d\u540c\u6570\u636e\u7c7b\u578b\u7684\u7ec4\u4ef6\uff0c\u4f8b\u5982\u56fe\u50cf\u3001\u97f3\u9891\u548c\u89c6\u9891\u3002\u5927\u591a\u6570\u7ec4\u4ef6\u90fd\u53ef\u4ee5\u7528\u4f5c\u8f93\u5165\u6216\u8f93\u51fa\u3002\n\n\u5f53\u7ec4\u4ef6\u7528\u4f5c\u8f93\u5165\u65f6\uff0cGradio \u81ea\u52a8\u5904\u7406*\u9884\u5904\u7406*\uff0c\u5c06\u6570\u636e\u4ece\u7528\u6237\n--New Chunk--\n[Created at: 2025-03-24 13:16:48]\n\u4e0e\u5e38\u89c4\u51fd\u6570\u76f8\u540c\u7684\u65b9\u5f0f\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio\u3002\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\uff08\u865a\u62df\u7684\uff09\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5b83\u5728\u8f93\u51fa\u56fe\u50cf\u4e4b\u524d\u751f\u6210\u6570\u4e2a\u6b65\u9aa4\u7684\u566a\u97f3\uff1a\n\n$code_fake_diffusion\n$demo_fake_diffusion\n\n\u8bf7\u6ce8\u610f\uff0c\u6211\u4eec\u5728\u8fed\u4ee3\u5668\u4e2d\u6dfb\u52a0\u4e86 `time.sleep(1)`\uff0c\u4ee5\u521b\u5efa\u6b65\u9aa4\u4e4b\u95f4\u7684\u4eba\u5de5\u6682\u505c\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u89c2\u5bdf\u8fed\u4ee3\u5668\u7684\u6b65\u9aa4\uff08\u5728\u771f\u5b9e\u7684\u56fe\u50cf\u751f\u6210\u6a21\u578b\u4e2d\uff0c\u8fd9\u53ef\u80fd\u662f\u4e0d\u5fc5\u8981\u7684\uff09\u3002\n\n\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio **\u9700\u8981**\u5728\u5e95\u5c42 Interface \u6216 Blocks \u4e2d\u542f\u7528\u961f\u5217\uff08\u8bf7\u53c2\u9605\u4e0a\u9762\u7684\u961f\u5217\u90e8\u5206\uff09\u3002\n\n## \u8fdb\u5ea6\u6761\n\nGradio \u652f\u6301\u521b\u5efa\u81ea\u5b9a\u4e49\u8fdb\u5ea6\u6761\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u81ea\u5b9a\u4e49\u548c\u63a7\u5236\u5411\u7528\u6237\u663e\u793a\u7684\u8fdb\u5ea6\u66f4\u65b0\u3002\u8981\u542f\u7528\u6b64\u529f\u80fd\uff0c\u53ea\u9700\u4e3a\u65b9\u6cd5\u6dfb\u52a0\u4e00\u4e2a\u9ed8\u8ba4\u503c\u4e3a `gr.Progress` \u5b9e\u4f8b\u7684\u53c2\u6570\u5373\u53ef\u3002\u7136\u540e\uff0c\u60a8\u53ef\u4ee5\u76f4\u63a5\u8c03\u7528\u6b64\u5b9e\u4f8b\u5e76\u4f20\u5165 0 \u5230 1 \u4e4b\u95f4\u7684\u6d6e\u70b9\u6570\u6765\u66f4\u65b0\u8fdb\u5ea6\u7ea7\u522b\uff0c\u6216\u8005 with `Progress` \u5b9e\u4f8b\u7684 `tqdm()` \u65b9\u6cd5\u6765\u8ddf\u8e2a\u53ef\u8fed\u4ee3\u5bf9\u8c61\u4e0a\u7684\u8fdb\u5ea6\uff0c\u5982\u4e0b\u6240\u793a\u3002\u5fc5\u987b\u542f\u7528\u961f\u5217\u4ee5\u8fdb\u884c\u8fdb\u5ea6\u66f4\u65b0\u3002\n\n$code_progress_simple\n$demo_progress_simple\n\n\u5982\u679c\u60a8 with `tqdm` \u5e93\uff0c\u5e76\u4e14\u5e0c\u671b\u4ece\u51fd\u6570\u5185\u90e8\u7684\u4efb\u4f55 `tqdm.tqdm` \u81ea\u52a8\u62a5\u544a\u8fdb\u5ea6\u66f4\u65b0\uff0c\u8bf7\u5c06\u9ed8\u8ba4\u53c2\u6570\u8bbe\u7f6e\u4e3a `gr.Progress(track_tqdm=True)`\uff01\n\n## \u6279\u5904\u7406\u51fd\u6570 (Batch Functions)\n\nGradio \u652f\u6301\u4f20\u9012*\u6279\u5904\u7406*\u51fd\u6570\u3002\u6279\u5904\u7406\u51fd\u6570\u53ea\u662f\u63a5\u53d7\u8f93\u5165\u5217\u8868\u5e76\u8fd4\u56de\u9884\u6d4b\u5217\u8868\u7684\u51fd\u6570\u3002\n\n\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\u6279\u5904\u7406\u51fd\u6570\uff0c\u5b83\u63a5\u53d7\u4e24\u4e2a\u8f93\u5165\u5217\u8868\uff08\u4e00\u4e2a\u5355\u8bcd\u5217\u8868\u548c\u4e00\u4e2a\u6574\u6570\u5217\u8868\uff09\uff0c\u5e76\u8fd4\u56de\u4fee\u526a\u8fc7\u7684\u5355\u8bcd\u5217\u8868\u4f5c\u4e3a\u8f93\u51fa\uff1a\n\n```python\nimport time\n\ndef trim_words(words, lens):\n    trimmed_words = []\n    time.sleep(5)\n    for w, l in zip(words, lens):\n        trimmed_words.append(w[:int(l)])\n    return [trimmed_words]\n    for w, l in zip(words, lens):\n```\n\n\u4f7f\u7528\u6279\u5904\u7406\u51fd\u6570\u7684\u4f18\u70b9\u662f\uff0c\u5982\u679c\u542f\u7528\u4e86\u961f\u5217\uff0cGradio \u670d\u52a1\u5668\u53ef\u4ee5\u81ea\u52a8*\u6279\u5904\u7406*\u4f20\u5165\u7684\u8bf7\u6c42\u5e76\u5e76\u884c\u5904\u7406\u5b83\u4eec\uff0c\u4ece\u800c\u53ef\u80fd\u52a0\u5feb\u6f14\u793a\u901f\u5ea6\u3002\u4ee5\u4e0b\u662f Gradio \u4ee3\u7801\u7684\u793a\u4f8b\uff08\u8bf7\u6ce8\u610f `batch=True` \u548c `max_batch_size=16` - \u8fd9\u4e24\u4e2a\u53c2\u6570\u90fd\u53ef\u4ee5\u4f20\u9012\u7ed9\u4e8b\u4ef6\u89e6\u53d1\u5668\u6216 `Interface` \u7c7b\uff09\n\nwith `Interface`\uff1a\n\n```python\ndemo = gr.Interface(trim_words, [\"textbox\", \"number\"], [\"output\"],\n                    batch=True, max_batch_size=16)\ndemo.queue()\ndemo.launch()\n```\n\nwith `Blocks`\uff1a\n\n```python\nimport gradio as gr\n\nwith gr.Blocks() as demo:\n    with gr.Row():\n        word = gr.Textbox(label=\"word\")\n        leng = gr.Number(label=\"leng\")\n        output = gr.Textbox(label=\"Output\")\n    with gr.Row():\n        run = gr.Button()\n\n    event = run.click(trim_words, [word, leng], output, batch=True, max_batch_size=16)\n\ndemo.queue()\ndemo.launch()\n```\n\n\u5728\u4e0a\u9762\u7684\u793a\u4f8b\u4e2d\uff0c\u53ef\u4ee5\u5e76\u884c\u5904\u7406 16 \u4e2a\u8bf7\u6c42\uff08\u603b\u63a8\u7406\u65f6\u95f4\u4e3a 5 \u79d2\uff09\uff0c\u800c\u4e0d\u662f\u5206\u522b\u5904\u7406\u6bcf\u4e2a\u8bf7\u6c42\uff08\u603b\u63a8\u7406\u65f6\u95f4\u4e3a 80 \u79d2\uff09\u3002\u8bb8\u591a Hugging Face \u7684 `transformers` \u548c `diffusers` \u6a21\u578b\u5728 Gradio \u7684\u6279\u5904\u7406\u6a21\u5f0f\u4e0b\u81ea\u7136\u5de5\u4f5c\uff1a\u8fd9\u662f[\u4f7f\u7528\u6279\u5904\u7406\u751f\u6210\u56fe\u50cf\u7684\u793a\u4f8b\u6f14\u793a](https://github.com/gradio-app/gradio/blob/main/demo/diffusers_with_batching/run.py)\n\n\u6ce8\u610f\uff1a\u4f7f\u7528 Gradio \u7684\u6279\u5904\u7406\u51fd\u6570 **requires** \u5728\u5e95\u5c42 Interface \u6216 Blocks \u4e2d\u542f\u7528\u961f\u5217\uff08\u8bf7\u53c2\u9605\u4e0a\u9762\u7684\u961f\u5217\u90e8\u5206\uff09\u3002\n\n## Gradio \u7b14\u8bb0\u672c (Colab Notebooks)\n\nGradio \u53ef\u4ee5\u5728\u4efb\u4f55\u8fd0\u884c Python \u7684\u5730\u65b9\u8fd0\u884c\uff0c\u5305\u62ec\u672c\u5730 Jupyter \u7b14\u8bb0\u672c\u548c\u534f\u4f5c\u7b14\u8bb0\u672c\uff0c\u5982[Google Colab](https://colab.research.google.com/)\u3002\u5bf9\u4e8e\u672c\u5730 Jupyter \u7b14\u8bb0\u672c\u548c Google Colab \u7b14\u8bb0\u672c\uff0cGradio \u5728\u672c\u5730\u670d\u52a1\u5668\u4e0a\u8fd0\u884c\uff0c\u60a8\u53ef\u4ee5\u5728\u6d4f\u89c8\u5668\u4e2d\u4e0e\u4e4b\u4ea4\u4e92\u3002\uff08\u6ce8\u610f\uff1a\u5bf9\u4e8e Google Colab\uff0c\u8fd9\u662f\u901a\u8fc7[\u670d\u52a1\u5de5\u4f5c\u5668\u96a7\u9053](https://github.com/tensorflow/tensorboard/blob/master/docs/design/colab_integration.md)\u5b9e\u73b0\u7684\uff0c\u60a8\u7684\u6d4f\u89c8\u5668\u9700\u8981\u542f\u7528 cookies\u3002\uff09\u5bf9\u4e8e\u5176\u4ed6\u8fdc\u7a0b\u7b14\u8bb0\u672c\uff0cGradio \u4e5f\u5c06\u5728\u670d\u52a1\u5668\u4e0a\u8fd0\u884c\uff0c\u4f46\u60a8\u9700\u8981\u4f7f\u7528[SSH \u96a7\u9053](https://coderwall.com/p/ohk6cg/remote-access-to-ipython-notebooks-via-ssh)\u5728\u672c\u5730\u6d4f\u89c8\u5668\u4e2d\u67e5\u770b\u5e94\u7528\u7a0b\u5e8f\u3002\u901a\u5e38\uff0c\u66f4\u7b80\u5355\u7684\u9009\u62e9\u662f\u4f7f\u7528 Gradio \u5185\u7f6e\u7684\u516c\u5171\u94fe\u63a5\uff0c[\u5728\u4e0b\u4e00\u7bc7\u6307\u5357\u4e2d\u8ba8\u8bba](/sharing-your-app/#sharing-demos)\u3002\n--New Chunk--\n[Created at: 2025-03-24 13:16:48]\n\u65f6\u5fc5\u987b\u9009\u62e9\u5176\u4e2d\u4e00\u4e2a\u5b57\u7b26\u4e32\uff0c\u8fd9\u5c06\u4f5c\u4e3a\u9644\u52a0\u5217\u4fdd\u5b58\u5230 CSV \u4e2d\u3002\n\n## \u9884\u5904\u7406\u548c\u540e\u5904\u7406 (Preprocessing and Postprocessing)\n\n![annotated](/assets/img/dataflow.svg)\n\n\u5982\u60a8\u6240\u89c1\uff0cGradio \u5305\u62ec\u53ef\u4ee5\u5904\u7406\u5404\u79cd\u4e0d\u540c\u6570\u636e\u7c7b\u578b\u7684\u7ec4\u4ef6\uff0c\u4f8b\u5982\u56fe\u50cf\u3001\u97f3\u9891\u548c\u89c6\u9891\u3002\u5927\u591a\u6570\u7ec4\u4ef6\u90fd\u53ef\u4ee5\u7528\u4f5c\u8f93\u5165\u6216\u8f93\u51fa\u3002\n\n\u5f53\u7ec4\u4ef6\u7528\u4f5c\u8f93\u5165\u65f6\uff0cGradio \u81ea\u52a8\u5904\u7406*\u9884\u5904\u7406*\uff0c\u5c06\u6570\u636e\u4ece\u7528\u6237\u6d4f\u89c8\u5668\u53d1\u9001\u7684\u7c7b\u578b\uff08\u4f8b\u5982\u7f51\u7edc\u6444\u50cf\u5934\u5feb\u7167\u7684 base64 \u8868\u793a\uff09\u8f6c\u6362\u4e3a\u60a8\u7684\u51fd\u6570\u53ef\u4ee5\u63a5\u53d7\u7684\u5f62\u5f0f\uff08\u4f8b\u5982 `numpy` \u6570\u7ec4\uff09\u3002\n\n\u540c\u6837\uff0c\u5f53\u7ec4\u4ef6\u7528\u4f5c\u8f93\u51fa\u65f6\uff0cGradio \u81ea\u52a8\u5904\u7406*\u540e\u5904\u7406*\uff0c\u5c06\u6570\u636e\u4ece\u51fd\u6570\u8fd4\u56de\u7684\u5f62\u5f0f\uff08\u4f8b\u5982\u56fe\u50cf\u8def\u5f84\u5217\u8868\uff09\u8f6c\u6362\u4e3a\u53ef\u4ee5\u5728\u7528\u6237\u6d4f\u89c8\u5668\u4e2d\u663e\u793a\u7684\u5f62\u5f0f\uff08\u4f8b\u5982\u4ee5 base64 \u683c\u5f0f\u663e\u793a\u56fe\u50cf\u7684 `Gallery`\uff09\u3002\n\n\u60a8\u53ef\u4ee5\u4f7f\u7528\u6784\u5efa\u56fe\u50cf\u7ec4\u4ef6\u65f6\u7684\u53c2\u6570\u63a7\u5236*\u9884\u5904\u7406*\u3002\u4f8b\u5982\uff0c\u5982\u679c\u60a8\u4f7f\u7528\u4ee5\u4e0b\u53c2\u6570\u5b9e\u4f8b\u5316 `Image` \u7ec4\u4ef6\uff0c\u5b83\u5c06\u5c06\u56fe\u50cf\u8f6c\u6362\u4e3a `PIL` \u7c7b\u578b\uff0c\u5e76\u5c06\u5176\u91cd\u5851\u4e3a`(100, 100)`\uff0c\u800c\u4e0d\u7ba1\u63d0\u4ea4\u65f6\u7684\u539f\u59cb\u5927\u5c0f\u5982\u4f55\uff1a\n\n```py\nimg = gr.Image(shape=(100, 100), type=\"pil\")\n```\n\n\u76f8\u53cd\uff0c\u8fd9\u91cc\u6211\u4eec\u4fdd\u7559\u56fe\u50cf\u7684\u539f\u59cb\u5927\u5c0f\uff0c\u4f46\u5728\u5c06\u5176\u8f6c\u6362\u4e3a numpy \u6570\u7ec4\u4e4b\u524d\u53cd\u8f6c\u989c\u8272\uff1a\n\n```py\nimg = gr.Image(invert_colors=True, type=\"numpy\")\n```\n\n\u540e\u5904\u7406\u8981\u5bb9\u6613\u5f97\u591a\uff01Gradio \u81ea\u52a8\u8bc6\u522b\u8fd4\u56de\u6570\u636e\u7684\u683c\u5f0f\uff08\u4f8b\u5982 `Image` \u662f `numpy` \u6570\u7ec4\u8fd8\u662f `str` \u6587\u4ef6\u8def\u5f84\uff1f\uff09\uff0c\u5e76\u5c06\u5176\u540e\u5904\u7406\u4e3a\u53ef\u4ee5\u7531\u6d4f\u89c8\u5668\u663e\u793a\u7684\u683c\u5f0f\u3002\n\n\u8bf7\u67e5\u770b[\u6587\u6863](https://gradio.app/docs)\uff0c\u4e86\u89e3\u6bcf\u4e2a\u7ec4\u4ef6\u7684\u6240\u6709\u4e0e\u9884\u5904\u7406\u76f8\u5173\u7684\u53c2\u6570\u3002\n\n## \u6837\u5f0f (Styling)\n\nGradio \u4e3b\u9898\u662f\u81ea\u5b9a\u4e49\u5e94\u7528\u7a0b\u5e8f\u5916\u89c2\u548c\u611f\u89c9\u7684\u6700\u7b80\u5355\u65b9\u6cd5\u3002\u60a8\u53ef\u4ee5\u9009\u62e9\u591a\u79cd\u4e3b\u9898\u6216\u521b\u5efa\u81ea\u5df1\u7684\u4e3b\u9898\u3002\u8981\u8fd9\u6837\u505a\uff0c\u8bf7\u5c06 `theme=` \u53c2\u6570\u4f20\u9012\u7ed9 `Interface` \u6784\u9020\u51fd\u6570\u3002\u4f8b\u5982\uff1a\n\n```python\ndemo = gr.Interface(..., theme=gr.themes.Monochrome())\n```\n\nGradio \u5e26\u6709\u4e00\u7ec4\u9884\u5148\u6784\u5efa\u7684\u4e3b\u9898\uff0c\u60a8\u53ef\u4ee5\u4ece `gr.themes.*` \u52a0\u8f7d\u3002\u60a8\u53ef\u4ee5\u6269\u5c55\u8fd9\u4e9b\u4e3b\u9898\u6216\u4ece\u5934\u5f00\u59cb\u521b\u5efa\u81ea\u5df1\u7684\u4e3b\u9898 - \u6709\u5173\u66f4\u591a\u8be6\u7ec6\u4fe1\u606f\uff0c\u8bf7\u53c2\u9605[\u4e3b\u9898\u6307\u5357](https://gradio.app/theming-guide)\u3002\n\n\u8981\u589e\u52a0\u989d\u5916\u7684\u6837\u5f0f\u80fd\u529b\uff0c\u60a8\u53ef\u4ee5 with `css=` \u5173\u952e\u5b57\u5c06\u4efb\u4f55 CSS \u4f20\u9012\u7ed9\u60a8\u7684\u5e94\u7528\u7a0b\u5e8f\u3002\nGradio \u5e94\u7528\u7a0b\u5e8f\u7684\u57fa\u7c7b\u662f `gradio-container`\uff0c\u56e0\u6b64\u4ee5\u4e0b\u662f\u4e00\u4e2a\u66f4\u6539 Gradio \u5e94\u7528\u7a0b\u5e8f\u80cc\u666f\u989c\u8272\u7684\u793a\u4f8b\uff1a\n\n```python\nwith `gr.Interface(css=\".gradio-container {background-color: red}\") as demo:\n    ...\n```\n\n## \u961f\u5217 (Queuing)\n\n\u5982\u679c\u60a8\u7684\u5e94\u7528\u7a0b\u5e8f\u9884\u8ba1\u4f1a\u6709\u5927\u91cf\u6d41\u91cf\uff0c\u8bf7 with `queue()` \u65b9\u6cd5\u6765\u63a7\u5236\u5904\u7406\u901f\u7387\u3002\u8fd9\u5c06\u6392\u961f\u5904\u7406\u8c03\u7528\uff0c\u56e0\u6b64\u4e00\u6b21\u53ea\u5904\u7406\u4e00\u5b9a\u6570\u91cf\u7684\u8bf7\u6c42\u3002\u961f\u5217\u4f7f\u7528 Websockets\uff0c\u8fd8\u53ef\u4ee5\u9632\u6b62\u7f51\u7edc\u8d85\u65f6\uff0c\u56e0\u6b64\u5982\u679c\u60a8\u7684\u51fd\u6570\u7684\u63a8\u7406\u65f6\u95f4\u5f88\u957f\uff08> 1 \u5206\u949f\uff09\uff0c\u5e94\u4f7f\u7528\u961f\u5217\u3002\n\nwith `Interface`\uff1a\n\n```python\ndemo = gr.Interface(...).queue()\ndemo.launch()\n```\n\nwith `Blocks`\uff1a\n\n```python\nwith gr.Blocks() as demo\uff1a\n    #...\ndemo.queue()\ndemo.launch()\n```\n\n\u60a8\u53ef\u4ee5\u901a\u8fc7\u4ee5\u4e0b\u65b9\u5f0f\u63a7\u5236\u4e00\u6b21\u5904\u7406\u7684\u8bf7\u6c42\u6570\u91cf\uff1a\n\n```python\ndemo.queue(concurrency_count=3)\n```\n\n\u67e5\u770b\u6709\u5173\u914d\u7f6e\u5176\u4ed6\u961f\u5217\u53c2\u6570\u7684[\u961f\u5217\u6587\u6863](/docs/#queue)\u3002\n\n\u5728 Blocks \u4e2d\u6307\u5b9a\u4ec5\u5bf9\u67d0\u4e9b\u51fd\u6570\u8fdb\u884c\u6392\u961f\uff1a\n\n```python\nwith gr.Blocks() as demo2\uff1a\n    num1 = gr.Number()\n    num2 = gr.Number()\n    output = gr.Number()\n    gr.Button(\"Add\").click(\n        lambda a, b: a + b, [num1, num2], output)\n    gr.Button(\"Multiply\").click(\n        lambda a, b: a * b, [num1, num2], output, queue=True)\ndemo2.launch()\n```\n\n## \u8fed\u4ee3\u8f93\u51fa (Iterative Outputs)\n\n\u5728\u67d0\u4e9b\u60c5\u51b5\u4e0b\uff0c\u60a8\u53ef\u80fd\u9700\u8981\u4f20\u8f93\u4e00\u7cfb\u5217\u8f93\u51fa\u800c\u4e0d\u662f\u4e00\u6b21\u663e\u793a\u5355\u4e2a\u8f93\u51fa\u3002\u4f8b\u5982\uff0c\u60a8\u53ef\u80fd\u6709\u4e00\u4e2a\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5e0c\u671b\u663e\u793a\u751f\u6210\u7684\u6bcf\u4e2a\u6b65\u9aa4\u7684\u56fe\u50cf\uff0c\u76f4\u5230\u6700\u7ec8\u56fe\u50cf\u3002\u6216\u8005\u60a8\u53ef\u80fd\u6709\u4e00\u4e2a\u804a\u5929\u673a\u5668\u4eba\uff0c\u5b83\u9010\u5b57\u9010\u53e5\u5730\u6d41\u5f0f\u4f20\u8f93\u54cd\u5e94\uff0c\u800c\u4e0d\u662f\u4e00\u6b21\u8fd4\u56de\u5168\u90e8\u54cd\u5e94\u3002\n\n\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u60a8\u53ef\u4ee5\u5c06**\u751f\u6210\u5668**\u51fd\u6570\u63d0\u4f9b\u7ed9 Gradio\uff0c\u800c\u4e0d\u662f\u5e38\u89c4\u51fd\u6570\u3002\u5728 Python \u4e2d\u521b\u5efa\u751f\u6210\u5668\u975e\u5e38\u7b80\u5355\uff1a\u51fd\u6570\u4e0d\u5e94\u8be5\u6709\u4e00\u4e2a\u5355\u72ec\u7684 `return` \u503c\uff0c\u800c\u662f\u5e94\u8be5 with `yield` \u8fde\u7eed\u8fd4\u56de\u4e00\u7cfb\u5217\u503c\u3002\u901a\u5e38\uff0c`yield` \u8bed\u53e5\u653e\u7f6e\u5728\u67d0\u79cd\u5faa\u73af\u4e2d\u3002\u4e0b\u9762\u662f\u4e00\u4e2a\u7b80\u5355\u793a\u4f8b\uff0c\u751f\u6210\u5668\u53ea\u662f\u7b80\u5355\u8ba1\u6570\u5230\u7ed9\u5b9a\u6570\u5b57\uff1a\n\n```python\ndef my_generator(x):\n    for i in range(x):\n        yield i\n```\n\n\u60a8\u4ee5\u4e0e\u5e38\u89c4\u51fd\u6570\u76f8\u540c\u7684\u65b9\u5f0f\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio\u3002\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\uff08\u865a\u62df\u7684\uff09\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5b83\u5728\u8f93\u51fa\u56fe\u50cf\u4e4b\u524d\u751f\u6210\u6570\u4e2a\u6b65\u9aa4\u7684\u566a\u97f3\uff1a\n\n$code_fake_diffusion\n$demo_fake_diffusion\n\n\u8bf7\u6ce8\u610f\uff0c\u6211\u4eec\u5728\u8fed\u4ee3\u5668\u4e2d\u6dfb\u52a0\u4e86 `time.sleep(1)`\uff0c\u4ee5\u521b\u5efa\u6b65\u9aa4\u4e4b\u95f4\u7684\u4eba\u5de5\u6682\u505c\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u89c2\u5bdf\u8fed\u4ee3\u5668\u7684\u6b65\u9aa4\uff08\u5728\u771f\u5b9e\u7684\u56fe\u50cf\u751f\u6210\u6a21\u578b\u4e2d\uff0c\u8fd9"
        }
    },
    {
        "context": "## \u6279\u5904\u7406\u51fd\u6570 (Batch Functions)\n\nGradio \u652f\u6301\u4f20\u9012*\u6279\u5904\u7406*\u51fd\u6570\u3002\u6279\u5904\u7406\u51fd\u6570\u53ea\u662f\u63a5\u53d7\u8f93\u5165\u5217\u8868\u5e76\u8fd4\u56de\u9884\u6d4b\u5217\u8868\u7684\u51fd\u6570\u3002\n\n\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\u6279\u5904\u7406\u51fd\u6570\uff0c\u5b83\u63a5\u53d7\u4e24\u4e2a\u8f93\u5165\u5217\u8868\uff08\u4e00\u4e2a\u5355\u8bcd\u5217\u8868\u548c\u4e00\u4e2a\u6574\u6570\u5217\u8868\uff09\uff0c\u5e76\u8fd4\u56de\u4fee\u526a\u8fc7\u7684\u5355\u8bcd\u5217\u8868\u4f5c\u4e3a\u8f93\u51fa\uff1a\n\n```python\nimport time\n\ndef trim_words(words, lens):\n    trimmed_words = []\n    time.sleep(5)\n    for w, l in zip(words, lens):\n        trimmed_words.append(w[:int(l)])\n    return [trimmed_words]\n    for w, l in zip(words, lens):\n```\n\n\u4f7f\u7528\u6279\u5904\u7406\u51fd\u6570\u7684\u4f18\u70b9\u662f\uff0c\u5982\u679c\u542f\u7528\u4e86\u961f\u5217\uff0cGradio \u670d\u52a1\u5668\u53ef\u4ee5\u81ea\u52a8*\u6279\u5904\u7406*\u4f20\u5165\u7684\u8bf7\u6c42\u5e76\u5e76\u884c\u5904\u7406\u5b83\u4eec\uff0c\u4ece\u800c\u53ef\u80fd\u52a0\u5feb\u6f14\u793a\u901f\u5ea6\u3002\u4ee5\u4e0b\u662f Gradio \u4ee3\u7801\u7684\u793a\u4f8b\uff08\u8bf7\u6ce8\u610f `batch=True` \u548c `max_batch_size=16` - \u8fd9\u4e24\u4e2a\u53c2\u6570\u90fd\u53ef\u4ee5\u4f20\u9012\u7ed9\u4e8b\u4ef6\u89e6\u53d1\u5668\u6216 `Interface` \u7c7b\uff09\n\nwith `Interface`\uff1a\n\n```python\ndemo = gr.Interface(trim_words, [\"textbox\", \"number\"], [\"output\"],\n                    batch=True, max_batch_size=16)\ndemo.queue()\ndemo.launch()\n```\n\nwith `Blocks`\uff1a\n\n```python\nimport gradio as gr\n\nwith gr.Blocks() as demo:\n    with gr.Row():\n        word = gr.Textbox(label=\"word\")\n        leng = gr.Number(label=\"leng\")\n        output = gr.Textbox(label=\"Output\")\n    with gr.Row():\n        run = gr.Button()\n\n    event = run.click(trim_words, [word, leng], output, batch=True, max_batch_size=16)\n\ndemo.queue()\ndemo.launch()\n```\n\n\u5728\u4e0a\u9762\u7684\u793a\u4f8b\u4e2d\uff0c\u53ef\u4ee5\u5e76\u884c\u5904\u7406 16 \u4e2a\u8bf7\u6c42\uff08\u603b\u63a8\u7406\u65f6\u95f4\u4e3a 5 \u79d2\uff09\uff0c\u800c\u4e0d\u662f\u5206\u522b\u5904\u7406\u6bcf\u4e2a\u8bf7\u6c42\uff08\u603b\u63a8\u7406\u65f6\u95f4\u4e3a 80 \u79d2\uff09\u3002\u8bb8\u591a Hugging Face \u7684 `transformers` \u548c `diffusers` \u6a21\u578b\u5728 Gradio \u7684\u6279\u5904\u7406\u6a21\u5f0f\u4e0b\u81ea\u7136\u5de5\u4f5c\uff1a\u8fd9\u662f[\u4f7f\u7528\u6279\u5904\u7406\u751f\u6210\u56fe\u50cf\u7684\u793a\u4f8b\u6f14\u793a](https://github.com/gradio-app/gradio/blob/main/demo/diffusers_with_batching/run.py)\n\n\u6ce8\u610f\uff1a\u4f7f\u7528 Gradio \u7684\u6279\u5904\u7406\u51fd\u6570 **requires** \u5728\u5e95\u5c42 Interface \u6216 Blocks \u4e2d\u542f\u7528\u961f\u5217\uff08\u8bf7\u53c2\u9605\u4e0a\u9762\u7684\u961f\u5217\u90e8\u5206\uff09\u3002\n\n## Gradio \u7b14\u8bb0\u672c (Colab Notebooks)\n\nGradio \u53ef\u4ee5\u5728\u4efb\u4f55\u8fd0\u884c Python \u7684\u5730\u65b9\u8fd0\u884c\uff0c\u5305\u62ec\u672c\u5730 Jupyter \u7b14\u8bb0\u672c\u548c\u534f\u4f5c\u7b14\u8bb0\u672c\uff0c\u5982[Google Colab](https://colab.research.google.com/)\u3002\u5bf9\u4e8e\u672c\u5730 Jupyter \u7b14\u8bb0\u672c\u548c Google Colab \u7b14\u8bb0\u672c\uff0cGradio \u5728\u672c\u5730\u670d\u52a1\u5668\u4e0a\u8fd0\u884c\uff0c\u60a8\u53ef\u4ee5\u5728\u6d4f\u89c8\u5668\u4e2d\u4e0e\u4e4b\u4ea4\u4e92\u3002\uff08\u6ce8\u610f\uff1a\u5bf9\u4e8e Google Colab\uff0c\u8fd9\u662f\u901a\u8fc7[\u670d\u52a1\u5de5\u4f5c\u5668\u96a7\u9053](https://github.com/tensorflow/tensorboard/blob/master/docs/design/colab_integration.md)\u5b9e\u73b0\u7684\uff0c\u60a8\u7684\u6d4f\u89c8\u5668\u9700\u8981\u542f\u7528 cookies\u3002\uff09\u5bf9\u4e8e\u5176\u4ed6\u8fdc\u7a0b\u7b14\u8bb0\u672c\uff0cGradio \u4e5f\u5c06\u5728\u670d\u52a1\u5668\u4e0a\u8fd0\u884c\uff0c\u4f46\u60a8\u9700\u8981\u4f7f\u7528[SSH \u96a7\u9053](https://coderwall.com/p/ohk6cg/remote-access-to-ipython-notebooks-via-ssh)\u5728\u672c\u5730\u6d4f\u89c8\u5668\u4e2d\u67e5\u770b\u5e94\u7528\u7a0b\u5e8f\u3002\u901a\u5e38\uff0c\u66f4\u7b80\u5355\u7684\u9009\u62e9\u662f\u4f7f\u7528 Gradio \u5185\u7f6e\u7684\u516c\u5171\u94fe\u63a5\uff0c[\u5728\u4e0b\u4e00\u7bc7\u6307\u5357\u4e2d\u8ba8\u8bba](/sharing-your-app/#sharing-demos)\u3002",
        "question": "Where can Gradio run?",
        "answer": "Gradio can run anywhere Python can run, including local Jupyter notebooks and collaborative notebooks like Google Colab.",
        "source_doc": "gradio-app/gradio/blob/main/guides/cn/01_getting-started/02_key-features.md",
        "rag_answer": null,
        "rag_context": null,
        "rag_score": null,
        "rag_feedback": null
    },
    {
        "context": "## \u6279\u5904\u7406\u51fd\u6570 (Batch Functions)\n\nGradio \u652f\u6301\u4f20\u9012*\u6279\u5904\u7406*\u51fd\u6570\u3002\u6279\u5904\u7406\u51fd\u6570\u53ea\u662f\u63a5\u53d7\u8f93\u5165\u5217\u8868\u5e76\u8fd4\u56de\u9884\u6d4b\u5217\u8868\u7684\u51fd\u6570\u3002\n\n\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\u6279\u5904\u7406\u51fd\u6570\uff0c\u5b83\u63a5\u53d7\u4e24\u4e2a\u8f93\u5165\u5217\u8868\uff08\u4e00\u4e2a\u5355\u8bcd\u5217\u8868\u548c\u4e00\u4e2a\u6574\u6570\u5217\u8868\uff09\uff0c\u5e76\u8fd4\u56de\u4fee\u526a\u8fc7\u7684\u5355\u8bcd\u5217\u8868\u4f5c\u4e3a\u8f93\u51fa\uff1a\n\n```python\nimport time\n\ndef trim_words(words, lens):\n    trimmed_words = []\n    time.sleep(5)\n    for w, l in zip(words, lens):\n        trimmed_words.append(w[:int(l)])\n    return [trimmed_words]\n    for w, l in zip(words, lens):\n```\n\n\u4f7f\u7528\u6279\u5904\u7406\u51fd\u6570\u7684\u4f18\u70b9\u662f\uff0c\u5982\u679c\u542f\u7528\u4e86\u961f\u5217\uff0cGradio \u670d\u52a1\u5668\u53ef\u4ee5\u81ea\u52a8*\u6279\u5904\u7406*\u4f20\u5165\u7684\u8bf7\u6c42\u5e76\u5e76\u884c\u5904\u7406\u5b83\u4eec\uff0c\u4ece\u800c\u53ef\u80fd\u52a0\u5feb\u6f14\u793a\u901f\u5ea6\u3002\u4ee5\u4e0b\u662f Gradio \u4ee3\u7801\u7684\u793a\u4f8b\uff08\u8bf7\u6ce8\u610f `batch=True` \u548c `max_batch_size=16` - \u8fd9\u4e24\u4e2a\u53c2\u6570\u90fd\u53ef\u4ee5\u4f20\u9012\u7ed9\u4e8b\u4ef6\u89e6\u53d1\u5668\u6216 `Interface` \u7c7b\uff09\n\nwith `Interface`\uff1a\n\n```python\ndemo = gr.Interface(trim_words, [\"textbox\", \"number\"], [\"output\"],\n                    batch=True, max_batch_size=16)\ndemo.queue()\ndemo.launch()\n```\n\nwith `Blocks`\uff1a\n\n```python\nimport gradio as gr\n\nwith gr.Blocks() as demo:\n    with gr.Row():\n        word = gr.Textbox(label=\"word\")\n        leng = gr.Number(label=\"leng\")\n        output = gr.Textbox(label=\"Output\")\n    with gr.Row():\n        run = gr.Button()\n\n    event = run.click(trim_words, [word, leng], output, batch=True, max_batch_size=16)\n\ndemo.queue()\ndemo.launch()\n```\n\n\u5728\u4e0a\u9762\u7684\u793a\u4f8b\u4e2d\uff0c\u53ef\u4ee5\u5e76\u884c\u5904\u7406 16 \u4e2a\u8bf7\u6c42\uff08\u603b\u63a8\u7406\u65f6\u95f4\u4e3a 5 \u79d2\uff09\uff0c\u800c\u4e0d\u662f\u5206\u522b\u5904\u7406\u6bcf\u4e2a\u8bf7\u6c42\uff08\u603b\u63a8\u7406\u65f6\u95f4\u4e3a 80 \u79d2\uff09\u3002\u8bb8\u591a Hugging Face \u7684 `transformers` \u548c `diffusers` \u6a21\u578b\u5728 Gradio \u7684\u6279\u5904\u7406\u6a21\u5f0f\u4e0b\u81ea\u7136\u5de5\u4f5c\uff1a\u8fd9\u662f[\u4f7f\u7528\u6279\u5904\u7406\u751f\u6210\u56fe\u50cf\u7684\u793a\u4f8b\u6f14\u793a](https://github.com/gradio-app/gradio/blob/main/demo/diffusers_with_batching/run.py)\n\n\u6ce8\u610f\uff1a\u4f7f\u7528 Gradio \u7684\u6279\u5904\u7406\u51fd\u6570 **requires** \u5728\u5e95\u5c42 Interface \u6216 Blocks \u4e2d\u542f\u7528\u961f\u5217\uff08\u8bf7\u53c2\u9605\u4e0a\u9762\u7684\u961f\u5217\u90e8\u5206\uff09\u3002\n\n## Gradio \u7b14\u8bb0\u672c (Colab Notebooks)\n\nGradio \u53ef\u4ee5\u5728\u4efb\u4f55\u8fd0\u884c Python \u7684\u5730\u65b9\u8fd0\u884c\uff0c\u5305\u62ec\u672c\u5730 Jupyter \u7b14\u8bb0\u672c\u548c\u534f\u4f5c\u7b14\u8bb0\u672c\uff0c\u5982[Google Colab](https://colab.research.google.com/)\u3002\u5bf9\u4e8e\u672c\u5730 Jupyter \u7b14\u8bb0\u672c\u548c Google Colab \u7b14\u8bb0\u672c\uff0cGradio \u5728\u672c\u5730\u670d\u52a1\u5668\u4e0a\u8fd0\u884c\uff0c\u60a8\u53ef\u4ee5\u5728\u6d4f\u89c8\u5668\u4e2d\u4e0e\u4e4b\u4ea4\u4e92\u3002\uff08\u6ce8\u610f\uff1a\u5bf9\u4e8e Google Colab\uff0c\u8fd9\u662f\u901a\u8fc7[\u670d\u52a1\u5de5\u4f5c\u5668\u96a7\u9053](https://github.com/tensorflow/tensorboard/blob/master/docs/design/colab_integration.md)\u5b9e\u73b0\u7684\uff0c\u60a8\u7684\u6d4f\u89c8\u5668\u9700\u8981\u542f\u7528 cookies\u3002\uff09\u5bf9\u4e8e\u5176\u4ed6\u8fdc\u7a0b\u7b14\u8bb0\u672c\uff0cGradio \u4e5f\u5c06\u5728\u670d\u52a1\u5668\u4e0a\u8fd0\u884c\uff0c\u4f46\u60a8\u9700\u8981\u4f7f\u7528[SSH \u96a7\u9053](https://coderwall.com/p/ohk6cg/remote-access-to-ipython-notebooks-via-ssh)\u5728\u672c\u5730\u6d4f\u89c8\u5668\u4e2d\u67e5\u770b\u5e94\u7528\u7a0b\u5e8f\u3002\u901a\u5e38\uff0c\u66f4\u7b80\u5355\u7684\u9009\u62e9\u662f\u4f7f\u7528 Gradio \u5185\u7f6e\u7684\u516c\u5171\u94fe\u63a5\uff0c[\u5728\u4e0b\u4e00\u7bc7\u6307\u5357\u4e2d\u8ba8\u8bba](/sharing-your-app/#sharing-demos)\u3002",
        "question": "How does Gradio run in Google Colab?",
        "answer": "Gradio runs on a local server in Google Colab through a service worker tunnel, and the browser needs to have cookies enabled.",
        "source_doc": "gradio-app/gradio/blob/main/guides/cn/01_getting-started/02_key-features.md",
        "rag_answer": null,
        "rag_context": null,
        "rag_score": null,
        "rag_feedback": null
    },
    {
        "context": "!--Copyright 2023 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\nthe License. You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under the License is distributed on\nan \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n\n\u26a0\ufe0f Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be\nrendered properly in your Markdown viewer.\n\n-->\n\n# Training on TPU with TensorFlow\n\n<Tip>\n\nIf you don't need long explanations and just want TPU code samples to get started with, check out [our TPU example notebook!](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb)\n\n</Tip>\n\n### What is a TPU?\n\nA TPU is a **Tensor Processing Unit.** They are hardware designed by Google, which are used to greatly speed up the tensor computations within neural networks, much like GPUs. They can be used for both network training and inference. They are generally accessed through Google\u2019s cloud services, but small TPUs can also be accessed directly for free through Google Colab and Kaggle Kernels.\n\nBecause [all TensorFlow models in \ud83e\udd17 Transformers are Keras models](https://huggingface.co/blog/tensorflow-philosophy), most of the methods in this document are generally applicable to TPU training for any Keras model! However, there are a few points that are specific to the HuggingFace ecosystem (hug-o-system?) of Transformers and Datasets, and we\u2019ll make sure to flag them up when we get to them.\n\n### What kinds of TPU are available?\n\nNew users are often very confused by the range of TPUs, and the different ways to access them. The first key distinction to understand is the difference between **TPU Nodes** and **TPU VMs.**",
        "question": "What does TPU stand for?",
        "answer": "TPU stands for Tensor Processing Unit.",
        "source_doc": "huggingface/transformers/blob/main/docs/source/en/perf_train_tpu_tf.md",
        "rag_answer": null,
        "rag_context": null,
        "rag_score": null,
        "rag_feedback": null
    },
    {
        "sample_idx": 38,
        "question": "What is the purpose of a TPU?",
        "answer": "TPUs are used to greatly speed up the tensor computations within neural networks.",
        "rag_answer": "**What is a TPU?**\n\nA TPU (Tensor Processing Unit) is a **hardware designed by Google** to greatly speed up the tensor computations within neural networks, much like GPUs (Graphics Processing Units). They can be used for both network training and inference.\n\n",
        "rag_score": null,
        "rag_feedback": null,
        "rag_context": {
            "kg_context": "-----Entities-----\n    ```csv\n    id,\tentity,\ttype,\tdescription,\trankcreated_at\n1,\tGoogle,organization,Google is the company that designs and provides TPUs, which are used to speed up tensor computations within neural networks.,3,2025-03-24 13:18:20\n2,\tTPU,technology,TPU is a Tensor Processing Unit, a hardware designed by Google to speed up tensor computations within neural networks.<SEP>TPU is a type of hardware accelerator designed for machine learning workloads.<SEP>TPU is a type of hardware accelerator used for machine learning computations.,4,2025-03-24 13:18:20\n3,\tGoogle Cloud,organization,Google Cloud is a cloud computing platform that provides infrastructure and services for building and deploying machine learning models.,1,2025-03-24 13:18:20\n4,\tCPU,technology,CPU is a type of computer processor.<SEP>CPU is a type of hardware processor used for general-purpose computations.,1,2025-03-24 13:18:20\n5,\tGPU,technology,GPU is a type of computer processor.<SEP>GPU is a type of hardware accelerator used for graphics processing.,1,2025-03-24 13:18:20\n6,\tTensor Processing Unit,category,Tensor Processing Unit is a hardware designed by Google to speed up tensor computations within neural networks.,0,UNKNOWN\n7,\tGoogle,organization,Google is the company that designs and provides TPUs, which are used to speed up tensor computations within neural networks.,3,UNKNOWN\n8,\tTPU,technology,TPU is a Tensor Processing Unit, a hardware designed by Google to speed up tensor computations within neural networks.<SEP>TPU is a type of hardware accelerator designed for machine learning workloads.<SEP>TPU is a type of hardware accelerator used for machine learning computations.,4,UNKNOWN\n    ```\n    -----Relationships-----\n    ```csv\n    id,\tsource,\ttarget,\tdescription,\tkeywords,\tweight,\trank,\tcreated_at\n1,\tGoogle,TPU,Google designs and provides TPUs, which are used to speed up tensor computations within neural networks.,hardware design, acceleration,18.0,7,2025-03-24 13:18:20\n2,\tGoogle Cloud,TPU,Google Cloud provides infrastructure and services for building and deploying machine learning models, including TPU hardware.,infrastructure provision, hardware acceleration,14.0,5,2025-03-24 13:18:20\n3,\tCPU,GPU,CPU and GPU are types of computer processors that can be used for machine learning workloads.,hardware comparison, processing power,4.0,2,2025-03-24 13:18:20\n4,\tTPU,XLA,XLA compiles TensorFlow graphs into executable code for TPU hardware.<SEP>XLA is used to optimize code for TPU hardware.,compilation, hardware acceleration<SEP>compiler, hardware optimization,36.0,10,UNKNOWN\n5,\tGoogle,TPU,Google designs and provides TPUs, which are used to speed up tensor computations within neural networks.,hardware design, acceleration,18.0,7,UNKNOWN\n6,\tColab,TPU,Colab provides access to a free TPU for users.,platform, hardware acceleration,16.0,7,UNKNOWN\n7,\tColab,Google,Colab is a cloud-based platform provided by Google for data science and machine learning.,platform provision, cloud computing,16.0,6,UNKNOWN\n8,\tGoogle Cloud,TPU,Google Cloud provides infrastructure and services for building and deploying machine learning models, including TPU hardware.,infrastructure provision, hardware acceleration,14.0,5,UNKNOWN\n9,\tGoogle,Kaggle Kernels,Kaggle Kernels is a cloud-based platform provided by Google for data science and machine learning competitions.,platform provision, cloud computing,16.0,4,UNKNOWN\n    ```\n    -----Sources-----\n    ```csv\n    id,\tcontent\n1,\t!--Copyright 2023 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\nthe License. You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under the License is distributed on\nan \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n\n\u26a0\ufe0f Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be\nrendered properly in your Markdown viewer.\n\n-->\n\n# Training on TPU with TensorFlow\n\n<Tip>\n\nIf you don't need long explanations and just want TPU code samples to get started with, check out [our TPU example notebook!](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb)\n\n</Tip>\n\n### What is a TPU?\n\nA TPU is a **Tensor Processing Unit.** They are hardware designed by Google, which are used to greatly speed up the tensor computations within neural networks, much like GPUs. They can be used for both network training and inference. They are generally accessed through Google\u2019s cloud services, but small TPUs can also be accessed directly for free through Google Colab and Kaggle Kernels.\n\nBecause [all TensorFlow models in \ud83e\udd17 Transformers are Keras models](https://huggingface.co/blog/tensorflow-philosophy), most of the methods in this document are generally applicable to TPU training for any Keras model! However, there are a few points that are specific to the HuggingFace ecosystem (hug-o-system?) of Transformers and Datasets, and we\u2019ll make sure to flag them up when we get to them.\n\n### What kinds of TPU are available?\n\nNew users are often very confused by the range of TPUs, and the different ways to access them. The first key distinction to understand is the difference between **TPU Nodes** and **TPU VMs.**\n\nWhen you use a **TPU Node**, you are effectively indirectly accessing a remote TPU. You will need a separate VM, which will initialize your network and data pipeline and then forward them to the remote node. When you use a TPU on Google Colab, you are accessing it in the **TPU Node** style.\n\nUsing TPU Nodes can have some quite unexpected behaviour for people who aren\u2019t used to them! In particular, because the TPU is located on a physically different system to the machine you\u2019re running your Python code on, your data cannot be local to your machine - any data pipeline that loads from your machine\u2019s internal storage will totally fail! Instead, data must be stored in Google Cloud Storage where your data pipeline can still access it, even when the pipeline is running on the remote TPU node.\n\n<Tip>\n\nIf you can fit all your data in memory as `np.ndarray` or `tf.Tensor`, then you can `fit()` on that data even when using Colab or a TPU Node, without needing to upload it to Google Cloud Storage.\n\n</Tip>\n\n<Tip>\n\n**\ud83e\udd17Specific Hugging Face Tip\ud83e\udd17:** The methods `Dataset.to_tf_dataset()` and its higher-level wrapper `model.prepare_tf_dataset()` , which you will see throughout our TF code examples, will both fail on a TPU Node. The reason for this is that even though they create a `tf.data.Dataset` it is not a \u201cpure\u201d `tf.data` pipeline and uses `tf.numpy_function` or `Dataset.from_generator()` to stream data from the underlying HuggingFace `Dataset`. This HuggingFace `Dataset` is backed by data that is on a local disc and which the remote TPU Node will not be able to read.\n\n</Tip>\n\nThe second way to access a TPU is via a **TPU VM.** When using a TPU VM, you connect directly to the machine that the TPU is attached to, much like training on a GPU VM. TPU VMs are generally easier to work with, particularly when it comes to your data pipeline. All of the above warnings do not apply to TPU VMs!\n\nThis is an opinionated document, so here\u2019s our opinion: **Avoid using TPU Node if possible.** It is more confusing and more difficult to debug than TPU VMs. It is also likely to be unsupported in future - Google\u2019s latest TPU, TPUv4, can only be accessed as a TPU VM, which suggests that TPU Nodes are increasingly going to become a \u201clegacy\u201d access method. However, we understand that the only free TPU access is on Colab and Kaggle Kernels, which uses TPU Node - so we\u2019ll try to explain how to handle it if you have to! Check the [TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) for code samples that explain this in more detail.\n\n### What sizes of TPU are available?\n\nA single TPU (a v2-8/v3-8/v4-8) runs 8 replicas. TPUs exist in **pods** that can run hundreds or thousands of replicas simultaneously. When you use more than a single TPU but less than a whole pod (for example, a v3-32), your TPU fleet is referred to as a **pod slice.**\n\nWhen you access a free TPU via Colab, you generally get a single v2-8 TPU.\n\n### I keep hearing about this XLA thing. What\u2019s XLA, and how does it relate to TPUs?\n\nXLA is an optimizing compiler, used by both TensorFlow and JAX. In JAX it is the only compiler, whereas in TensorFlow it is optional\n2,\tlabel_mask  # Set negative label positions to 0\nmean_loss = tf.reduce_sum(loss) / tf.reduce_sum(label_mask)\n```\n\nHere, we avoid data-dependent shapes by computing the loss for every position, but zeroing out the masked positions in both the numerator and denominator when we calculate the mean, which yields exactly the same result as the first block while maintaining XLA compatibility. Note that we use the same trick as in rule #1 - converting a `tf.bool` to `tf.float32` and using it as an indicator variable. This is a really useful trick, so remember it if you need to convert your own code to XLA!\n\n#### XLA Rule #3: XLA will need to recompile your model for every different input shape it sees\n\nThis is the big one. What this means is that if your input shapes are very variable, XLA will have to recompile your model over and over, which will create huge performance problems. This commonly arises in NLP models, where input texts have variable lengths after tokenization. In other modalities, static shapes are more common and this rule is much less of a problem.\n\nHow can you get around rule #3? The key is **padding** - if you pad all your inputs to the same length, and then use an `attention_mask`, you can get the same results as you\u2019d get from variable shapes, but without any XLA issues. However, excessive padding can cause severe slowdown too - if you pad all your samples to the maximum length in the whole dataset, you might end up with batches consisting endless padding tokens, which will waste a lot of compute and memory!\n\nThere isn\u2019t a perfect solution to this problem. However, you can try some tricks. One very useful trick is to **pad batches of samples up to a multiple of a number like 32 or 64 tokens.** This often only increases the number of tokens by a small amount, but it hugely reduces the number of unique input shapes, because every input shape now has to be a multiple of 32 or 64. Fewer unique input shapes means fewer XLA compilations!\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** Our tokenizers and data collators have methods that can help you here. You can use `padding=\"max_length\"` or `padding=\"longest\"` when calling tokenizers to get them to output padded data. Our tokenizers and data collators also have a `pad_to_multiple_of` argument that you can use to reduce the number of unique input shapes you see!\n\n</Tip>\n\n### How do I actually train my model on TPU?\n\nOnce your training is XLA-compatible and (if you\u2019re using TPU Node / Colab) your dataset has been prepared appropriately, running on TPU is surprisingly easy! All you really need to change in your code is to add a few lines to initialize your TPU, and to ensure that your model and dataset are created inside a `TPUStrategy` scope. Take a look at [our TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) to see this in action!\n\n### Summary\n\nThere was a lot in here, so let\u2019s summarize with a quick checklist you can follow when you want to get your model ready for TPU training:\n\n- Make sure your code follows the three rules of XLA\n- Compile your model with `jit_compile=True` on CPU/GPU and confirm that you can train it with XLA\n- Either load your dataset into memory or use a TPU-compatible dataset loading approach (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Migrate your code either to Colab (with accelerator set to \u201cTPU\u201d) or a TPU VM on Google Cloud\n- Add TPU initializer code (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Create your `TPUStrategy` and make sure dataset loading and model creation are inside the `strategy.scope()` (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Don\u2019t forget to take `jit_compile=True` out again when you move to TPU!\n- \ud83d\ude4f\ud83d\ude4f\ud83d\ude4f\ud83e\udd7a\ud83e\udd7a\ud83e\udd7a\n- Call model.fit()\n- You did it!\n3,\t(for example, a v3-32), your TPU fleet is referred to as a **pod slice.**\n\nWhen you access a free TPU via Colab, you generally get a single v2-8 TPU.\n\n### I keep hearing about this XLA thing. What\u2019s XLA, and how does it relate to TPUs?\n\nXLA is an optimizing compiler, used by both TensorFlow and JAX. In JAX it is the only compiler, whereas in TensorFlow it is optional (but mandatory on TPU!). The easiest way to enable it when training a Keras model is to pass the argument `jit_compile=True` to `model.compile()`. If you don\u2019t get any errors and performance is good, that\u2019s a great sign that you\u2019re ready to move to TPU!\n\nDebugging on TPU is generally a bit harder than on CPU/GPU, so we recommend getting your code running on CPU/GPU with XLA first before trying it on TPU. You don\u2019t have to train for long, of course - just for a few steps to make sure that your model and data pipeline are working like you expect them to.\n\n<Tip>\n\nXLA compiled code is usually faster - so even if you\u2019re not planning to run on TPU, adding `jit_compile=True` can improve your performance. Be sure to note the caveats below about XLA compatibility, though!\n\n</Tip>\n\n<Tip warning={true}>\n\n**Tip born of painful experience:** Although using `jit_compile=True` is a good way to get a speed boost and test if your CPU/GPU code is XLA-compatible, it can actually cause a lot of problems if you leave it in when actually training on TPU. XLA compilation will happen implicitly on TPU, so remember to remove that line before actually running your code on a TPU!\n\n</Tip>\n\n### How do I make my model XLA compatible?\n\nIn many cases, your code is probably XLA-compatible already! However, there are a few things that work in normal TensorFlow that don\u2019t work in XLA. We\u2019ve distilled them into three core rules below:\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** We\u2019ve put a lot of effort into rewriting our TensorFlow models and loss functions to be XLA-compatible. Our models and loss functions generally obey rule #1 and #2 by default, so you can skip over them if you\u2019re using `transformers` models. Don\u2019t forget about these rules when writing your own models and loss functions, though!\n\n</Tip>\n\n#### XLA Rule #1: Your code cannot have \u201cdata-dependent conditionals\u201d\n\nWhat that means is that any `if` statement cannot depend on values inside a `tf.Tensor`. For example, this code block cannot be compiled with XLA!\n\n```python\nif tf.reduce_sum(tensor) > 10:\n    tensor = tensor / 2.0\n```\n\nThis might seem very restrictive at first, but most neural net code doesn\u2019t need to do this. You can often get around this restriction by using `tf.cond` (see the documentation [here](https://www.tensorflow.org/api_docs/python/tf/cond)) or by removing the conditional and finding a clever math trick with indicator variables instead, like so:\n\n```python\nsum_over_10 = tf.cast(tf.reduce_sum(tensor) > 10, tf.float32)\ntensor = tensor / (1.0 + sum_over_10)\n```\n\nThis code has exactly the same effect as the code above, but by avoiding a conditional, we ensure it will compile with XLA without problems!\n\n#### XLA Rule #2: Your code cannot have \u201cdata-dependent shapes\u201d\n\nWhat this means is that the shape of all of the `tf.Tensor` objects in your code cannot depend on their values. For example, the function `tf.unique` cannot be compiled with XLA, because it returns a `tensor` containing one instance of each unique value in the input. The shape of this output will obviously be different depending on how repetitive the input `Tensor` was, and so XLA refuses to handle it!\n\nIn general, most neural network code obeys rule #2 by default. However, there are a few common cases where it becomes a problem. One very common one is when you use **label masking**, setting your labels to a negative value to indicate that those positions should be ignored when computing the loss. If you look at NumPy or PyTorch loss functions that support label masking, you will often see code like this that uses [boolean indexing](https://numpy.org/doc/stable/user/basics.indexing.html#boolean-array-indexing):\n\n```python\nlabel_mask = labels >= 0\nmasked_outputs = outputs[label_mask]\nmasked_labels = labels[label_mask]\nloss = compute_loss(masked_outputs, masked_labels)\nmean_loss = torch.mean(loss)\n```\n\nThis code is totally fine in NumPy or PyTorch, but it breaks in XLA! Why? Because the shape of `masked_outputs` and `masked_labels` depends on how many positions are masked - that makes it a **data-dependent shape.** However, just like for rule #1, we can often rewrite this code to yield exactly the same output without any data-dependent shapes.\n\n```python\nlabel_mask = tf.cast(labels >= 0, tf.float32)\nloss = compute_loss(outputs, labels)\nloss = loss * label_mask  # Set negative label positions to 0\nmean_loss = tf.reduce_sum(loss) / tf.reduce_sum(label_mask)\n```\n\nHere, we avoid data-dependent shapes by computing the loss for every position, but zeroing out the masked positions in both the numerator and denominator when we calculate the mean, which yields exactly the same result as the first block while maintaining XLA compatibility. Note that we use the same trick as in rule #1 - converting a `tf.bool` to `\n    ```",
            "vector_context": "[Created at: 2025-03-24 13:17:32]\n!--Copyright 2023 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\nthe License. You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under the License is distributed on\nan \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n\n\u26a0\ufe0f Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be\nrendered properly in your Markdown viewer.\n\n-->\n\n# Training on TPU with TensorFlow\n\n<Tip>\n\nIf you don't need long explanations and just want TPU code samples to get started with, check out [our TPU example notebook!](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb)\n\n</Tip>\n\n### What is a TPU?\n\nA TPU is a **Tensor Processing Unit.** They are hardware designed by Google, which are used to greatly speed up the tensor computations within neural networks, much like GPUs. They can be used for both network training and inference. They are generally accessed through Google\u2019s cloud services, but small TPUs can also be accessed directly for free through Google Colab and Kaggle Kernels.\n\nBecause [all TensorFlow models in \ud83e\udd17 Transformers are Keras models](https://huggingface.co/blog/tensorflow-philosophy), most of the methods in this document are generally applicable to TPU training for any Keras model! However, there are a few points that are specific to the HuggingFace ecosystem (hug-o-system?) of Transformers and Datasets, and we\u2019ll make sure to flag them up when we get to them.\n\n### What kinds of TPU are available?\n\nNew users are often very confused by the range of TPUs, and the different ways to access them. The first key distinction to understand is the difference between **TPU Nodes** and **TPU VMs.**\n\nWhen you use a **TPU Node**, you are effectively indirectly accessing a remote TPU. You will need a separate VM, which will initialize your network and data pipeline and then forward them to the remote node. When you use a TPU on Google Colab, you are accessing it in the **TPU Node** style.\n\nUsing TPU Nodes can have some quite unexpected behaviour for people who aren\u2019t used to them! In particular, because the TPU is located on a physically different system to the machine you\u2019re running your Python code on, your data cannot be local to your machine - any data pipeline that loads from your machine\u2019s internal storage will totally fail! Instead, data must be stored in Google Cloud Storage where your data pipeline can still access it, even when the pipeline is running on the remote TPU node.\n\n<Tip>\n\nIf you can fit all your data in memory as `np.ndarray` or `tf.Tensor`, then you can `fit()` on that data even when using Colab or a TPU Node, without needing to upload it to Google Cloud Storage.\n\n</Tip>\n\n<Tip>\n\n**\ud83e\udd17Specific Hugging Face Tip\ud83e\udd17:** The methods `Dataset.to_tf_dataset()` and its higher-level wrapper `model.prepare_tf_dataset()` , which you will see throughout our TF code examples, will both fail on a TPU Node. The reason for this is that even though they create a `tf.data.Dataset` it is not a \u201cpure\u201d `tf.data` pipeline and uses `tf.numpy_function` or `Dataset.from_generator()` to stream data from the underlying HuggingFace `Dataset`. This HuggingFace `Dataset` is backed by data that is on a local disc and which the remote TPU Node will not be able to read.\n\n</Tip>\n\nThe second way to access a TPU is via a **TPU VM.** When using a TPU VM, you connect directly to the machine that the TPU is attached to, much like training on a GPU VM. TPU VMs are generally easier to work with, particularly when it comes to your data pipeline. All of the above warnings do not apply to TPU VMs!\n\nThis is an opinionated document, so here\u2019s our opinion: **Avoid using TPU Node if possible.** It is more confusing and more difficult to debug than TPU VMs. It is also likely to be unsupported in future - Google\u2019s latest TPU, TPUv4, can only be accessed as a TPU VM, which suggests that TPU Nodes are increasingly going to become a \u201clegacy\u201d access method. However, we understand that the only free TPU access is on Colab and Kaggle Kernels, which uses TPU Node - so we\u2019ll try to explain how to handle it if you have to! Check the [TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) for code samples that explain this in more detail.\n\n### What sizes of TPU are available?\n\nA single TPU (a v2-8/v3-8/v4-8) runs 8 replicas. TPUs exist in **pods** that can run hundreds or thousands of replicas simultaneously. When you use more than a single TPU but less than a whole pod (for example, a v3-32), your TPU fleet is referred to as a **pod slice.**\n\nWhen you access a free TPU via Colab, you generally get a single v2-8 TPU.\n\n### I keep hearing about this XLA thing. What\u2019s XLA, and how does it relate to TPUs?\n\nXLA is an optimizing compiler, used by both TensorFlow and JAX. In JAX it is the only compiler, whereas in TensorFlow it is optional\n--New Chunk--\n[Created at: 2025-03-24 13:17:32]\nlabel_mask  # Set negative label positions to 0\nmean_loss = tf.reduce_sum(loss) / tf.reduce_sum(label_mask)\n```\n\nHere, we avoid data-dependent shapes by computing the loss for every position, but zeroing out the masked positions in both the numerator and denominator when we calculate the mean, which yields exactly the same result as the first block while maintaining XLA compatibility. Note that we use the same trick as in rule #1 - converting a `tf.bool` to `tf.float32` and using it as an indicator variable. This is a really useful trick, so remember it if you need to convert your own code to XLA!\n\n#### XLA Rule #3: XLA will need to recompile your model for every different input shape it sees\n\nThis is the big one. What this means is that if your input shapes are very variable, XLA will have to recompile your model over and over, which will create huge performance problems. This commonly arises in NLP models, where input texts have variable lengths after tokenization. In other modalities, static shapes are more common and this rule is much less of a problem.\n\nHow can you get around rule #3? The key is **padding** - if you pad all your inputs to the same length, and then use an `attention_mask`, you can get the same results as you\u2019d get from variable shapes, but without any XLA issues. However, excessive padding can cause severe slowdown too - if you pad all your samples to the maximum length in the whole dataset, you might end up with batches consisting endless padding tokens, which will waste a lot of compute and memory!\n\nThere isn\u2019t a perfect solution to this problem. However, you can try some tricks. One very useful trick is to **pad batches of samples up to a multiple of a number like 32 or 64 tokens.** This often only increases the number of tokens by a small amount, but it hugely reduces the number of unique input shapes, because every input shape now has to be a multiple of 32 or 64. Fewer unique input shapes means fewer XLA compilations!\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** Our tokenizers and data collators have methods that can help you here. You can use `padding=\"max_length\"` or `padding=\"longest\"` when calling tokenizers to get them to output padded data. Our tokenizers and data collators also have a `pad_to_multiple_of` argument that you can use to reduce the number of unique input shapes you see!\n\n</Tip>\n\n### How do I actually train my model on TPU?\n\nOnce your training is XLA-compatible and (if you\u2019re using TPU Node / Colab) your dataset has been prepared appropriately, running on TPU is surprisingly easy! All you really need to change in your code is to add a few lines to initialize your TPU, and to ensure that your model and dataset are created inside a `TPUStrategy` scope. Take a look at [our TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) to see this in action!\n\n### Summary\n\nThere was a lot in here, so let\u2019s summarize with a quick checklist you can follow when you want to get your model ready for TPU training:\n\n- Make sure your code follows the three rules of XLA\n- Compile your model with `jit_compile=True` on CPU/GPU and confirm that you can train it with XLA\n- Either load your dataset into memory or use a TPU-compatible dataset loading approach (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Migrate your code either to Colab (with accelerator set to \u201cTPU\u201d) or a TPU VM on Google Cloud\n- Add TPU initializer code (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Create your `TPUStrategy` and make sure dataset loading and model creation are inside the `strategy.scope()` (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Don\u2019t forget to take `jit_compile=True` out again when you move to TPU!\n- \ud83d\ude4f\ud83d\ude4f\ud83d\ude4f\ud83e\udd7a\ud83e\udd7a\ud83e\udd7a\n- Call model.fit()\n- You did it!\n--New Chunk--\n[Created at: 2025-03-24 13:17:32]\n(for example, a v3-32), your TPU fleet is referred to as a **pod slice.**\n\nWhen you access a free TPU via Colab, you generally get a single v2-8 TPU.\n\n### I keep hearing about this XLA thing. What\u2019s XLA, and how does it relate to TPUs?\n\nXLA is an optimizing compiler, used by both TensorFlow and JAX. In JAX it is the only compiler, whereas in TensorFlow it is optional (but mandatory on TPU!). The easiest way to enable it when training a Keras model is to pass the argument `jit_compile=True` to `model.compile()`. If you don\u2019t get any errors and performance is good, that\u2019s a great sign that you\u2019re ready to move to TPU!\n\nDebugging on TPU is generally a bit harder than on CPU/GPU, so we recommend getting your code running on CPU/GPU with XLA first before trying it on TPU. You don\u2019t have to train for long, of course - just for a few steps to make sure that your model and data pipeline are working like you expect them to.\n\n<Tip>\n\nXLA compiled code is usually faster - so even if you\u2019re not planning to run on TPU, adding `jit_compile=True` can improve your performance. Be sure to note the caveats below about XLA compatibility, though!\n\n</Tip>\n\n<Tip warning={true}>\n\n**Tip born of painful experience:** Although using `jit_compile=True` is a good way to get a speed boost and test if your CPU/GPU code is XLA-compatible, it can actually cause a lot of problems if you leave it in when actually training on TPU. XLA compilation will happen implicitly on TPU, so remember to remove that line before actually running your code on a TPU!\n\n</Tip>\n\n### How do I make my model XLA compatible?\n\nIn many cases, your code is probably XLA-compatible already! However, there are a few things that work in normal TensorFlow that don\u2019t work in XLA. We\u2019ve distilled them into three core rules below:\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** We\u2019ve put a lot of effort into rewriting our TensorFlow models and loss functions to be XLA-compatible. Our models and loss functions generally obey rule #1 and #2 by default, so you can skip over them if you\u2019re using `transformers` models. Don\u2019t forget about these rules when writing your own models and loss functions, though!\n\n</Tip>\n\n#### XLA Rule #1: Your code cannot have \u201cdata-dependent conditionals\u201d\n\nWhat that means is that any `if` statement cannot depend on values inside a `tf.Tensor`. For example, this code block cannot be compiled with XLA!\n\n```python\nif tf.reduce_sum(tensor) > 10:\n    tensor = tensor / 2.0\n```\n\nThis might seem very restrictive at first, but most neural net code doesn\u2019t need to do this. You can often get around this restriction by using `tf.cond` (see the documentation [here](https://www.tensorflow.org/api_docs/python/tf/cond)) or by removing the conditional and finding a clever math trick with indicator variables instead, like so:\n\n```python\nsum_over_10 = tf.cast(tf.reduce_sum(tensor) > 10, tf.float32)\ntensor = tensor / (1.0 + sum_over_10)\n```\n\nThis code has exactly the same effect as the code above, but by avoiding a conditional, we ensure it will compile with XLA without problems!\n\n#### XLA Rule #2: Your code cannot have \u201cdata-dependent shapes\u201d\n\nWhat this means is that the shape of all of the `tf.Tensor` objects in your code cannot depend on their values. For example, the function `tf.unique` cannot be compiled with XLA, because it returns a `tensor` containing one instance of each unique value in the input. The shape of this output will obviously be different depending on how repetitive the input `Tensor` was, and so XLA refuses to handle it!\n\nIn general, most neural network code obeys rule #2 by default. However, there are a few common cases where it becomes a problem. One very common one is when you use **label masking**, setting your labels to a negative value to indicate that those positions should be ignored when computing the loss. If you look at NumPy or PyTorch loss functions that support label masking, you will often see code like this that uses [boolean indexing](https://numpy.org/doc/stable/user/basics.indexing.html#boolean-array-indexing):\n\n```python\nlabel_mask = labels >= 0\nmasked_outputs = outputs[label_mask]\nmasked_labels = labels[label_mask]\nloss = compute_loss(masked_outputs, masked_labels)\nmean_loss = torch.mean(loss)\n```\n\nThis code is totally fine in NumPy or PyTorch, but it breaks in XLA! Why? Because the shape of `masked_outputs` and `masked_labels` depends on how many positions are masked - that makes it a **data-dependent shape.** However, just like for rule #1, we can often rewrite this code to yield exactly the same output without any data-dependent shapes.\n\n```python\nlabel_mask = tf.cast(labels >= 0, tf.float32)\nloss = compute_loss(outputs, labels)\nloss = loss * label_mask  # Set negative label positions to 0\nmean_loss = tf.reduce_sum(loss) / tf.reduce_sum(label_mask)\n```\n\nHere, we avoid data-dependent shapes by computing the loss for every position, but zeroing out the masked positions in both the numerator and denominator when we calculate the mean, which yields exactly the same result as the first block while maintaining XLA compatibility. Note that we use the same trick as in rule #1 - converting a `tf.bool` to `"
        }
    },
    {
        "sample_idx": 39,
        "question": "What are TPUs generally accessed through?",
        "answer": "TPUs are generally accessed through Google\u2019s cloud services.",
        "rag_answer": "TPUs (Tensor Processing Units) are generally accessed through Google's cloud services, but small TPUs can also be accessed directly for free through Google Colab and Kaggle Kernels.",
        "rag_score": null,
        "rag_feedback": null,
        "rag_context": {
            "kg_context": "-----Entities-----\n    ```csv\n    id,\tentity,\ttype,\tdescription,\trankcreated_at\n1,\tGoogle,organization,Google is the company that designs and provides TPUs, which are used to speed up tensor computations within neural networks.,3,2025-03-24 13:18:20\n2,\tTPU,technology,TPU is a Tensor Processing Unit, a hardware designed by Google to speed up tensor computations within neural networks.<SEP>TPU is a type of hardware accelerator designed for machine learning workloads.<SEP>TPU is a type of hardware accelerator used for machine learning computations.,4,2025-03-24 13:18:20\n3,\tColab,geo,Colab is a cloud-based platform for data science and machine learning, provided by Google.<SEP>Colab is a platform where users can access a free TPU.,3,2025-03-24 13:18:20\n4,\tGoogle Cloud,organization,Google Cloud is a cloud computing platform that provides infrastructure and services for building and deploying machine learning models.,1,2025-03-24 13:18:20\n5,\tTensorFlow,category,TensorFlow is a machine learning framework that uses XLA as an optimizing compiler.<SEP>TensorFlow is a software framework used for building and training neural networks.<SEP>TensorFlow is an open-source machine learning framework.,3,UNKNOWN\n6,\tGoogle,organization,Google is the company that designs and provides TPUs, which are used to speed up tensor computations within neural networks.,3,UNKNOWN\n7,\tTensor Processing Unit,category,Tensor Processing Unit is a hardware designed by Google to speed up tensor computations within neural networks.,0,UNKNOWN\n    ```\n    -----Relationships-----\n    ```csv\n    id,\tsource,\ttarget,\tdescription,\tkeywords,\tweight,\trank,\tcreated_at\n1,\tGoogle,TPU,Google designs and provides TPUs, which are used to speed up tensor computations within neural networks.,hardware design, acceleration,18.0,7,2025-03-24 13:18:20\n2,\tColab,TPU,Colab provides access to a free TPU for users.,platform, hardware acceleration,16.0,7,2025-03-24 13:18:20\n3,\tGoogle Cloud,TPU,Google Cloud provides infrastructure and services for building and deploying machine learning models, including TPU hardware.,infrastructure provision, hardware acceleration,14.0,5,2025-03-24 13:18:20\n4,\tTensorFlow,XLA,TensorFlow graphs can be compiled into executable code using XLA.<SEP>TensorFlow uses XLA as an optimizing compiler to improve performance.,compilation, framework support<SEP>compiler, performance optimization,23.0,9,UNKNOWN\n5,\tHuggingFace,TensorFlow,HuggingFace provides a range of AI models and tools, including the Transformers and Datasets ecosystem, which are built on top of TensorFlow.,ecosystem integration, AI models,18.0,8,UNKNOWN\n6,\tGoogle,TPU,Google designs and provides TPUs, which are used to speed up tensor computations within neural networks.,hardware design, acceleration,18.0,7,UNKNOWN\n7,\tColab,Google,Colab is a cloud-based platform provided by Google for data science and machine learning.,platform provision, cloud computing,16.0,6,UNKNOWN\n8,\tKeras,TensorFlow,TensorFlow uses Keras as a high-level neural networks API.,API integration, neural networks,16.0,5,UNKNOWN\n9,\tGoogle,Kaggle Kernels,Kaggle Kernels is a cloud-based platform provided by Google for data science and machine learning competitions.,platform provision, cloud computing,16.0,4,UNKNOWN\n    ```\n    -----Sources-----\n    ```csv\n    id,\tcontent\n1,\t!--Copyright 2023 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\nthe License. You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under the License is distributed on\nan \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n\n\u26a0\ufe0f Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be\nrendered properly in your Markdown viewer.\n\n-->\n\n# Training on TPU with TensorFlow\n\n<Tip>\n\nIf you don't need long explanations and just want TPU code samples to get started with, check out [our TPU example notebook!](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb)\n\n</Tip>\n\n### What is a TPU?\n\nA TPU is a **Tensor Processing Unit.** They are hardware designed by Google, which are used to greatly speed up the tensor computations within neural networks, much like GPUs. They can be used for both network training and inference. They are generally accessed through Google\u2019s cloud services, but small TPUs can also be accessed directly for free through Google Colab and Kaggle Kernels.\n\nBecause [all TensorFlow models in \ud83e\udd17 Transformers are Keras models](https://huggingface.co/blog/tensorflow-philosophy), most of the methods in this document are generally applicable to TPU training for any Keras model! However, there are a few points that are specific to the HuggingFace ecosystem (hug-o-system?) of Transformers and Datasets, and we\u2019ll make sure to flag them up when we get to them.\n\n### What kinds of TPU are available?\n\nNew users are often very confused by the range of TPUs, and the different ways to access them. The first key distinction to understand is the difference between **TPU Nodes** and **TPU VMs.**\n\nWhen you use a **TPU Node**, you are effectively indirectly accessing a remote TPU. You will need a separate VM, which will initialize your network and data pipeline and then forward them to the remote node. When you use a TPU on Google Colab, you are accessing it in the **TPU Node** style.\n\nUsing TPU Nodes can have some quite unexpected behaviour for people who aren\u2019t used to them! In particular, because the TPU is located on a physically different system to the machine you\u2019re running your Python code on, your data cannot be local to your machine - any data pipeline that loads from your machine\u2019s internal storage will totally fail! Instead, data must be stored in Google Cloud Storage where your data pipeline can still access it, even when the pipeline is running on the remote TPU node.\n\n<Tip>\n\nIf you can fit all your data in memory as `np.ndarray` or `tf.Tensor`, then you can `fit()` on that data even when using Colab or a TPU Node, without needing to upload it to Google Cloud Storage.\n\n</Tip>\n\n<Tip>\n\n**\ud83e\udd17Specific Hugging Face Tip\ud83e\udd17:** The methods `Dataset.to_tf_dataset()` and its higher-level wrapper `model.prepare_tf_dataset()` , which you will see throughout our TF code examples, will both fail on a TPU Node. The reason for this is that even though they create a `tf.data.Dataset` it is not a \u201cpure\u201d `tf.data` pipeline and uses `tf.numpy_function` or `Dataset.from_generator()` to stream data from the underlying HuggingFace `Dataset`. This HuggingFace `Dataset` is backed by data that is on a local disc and which the remote TPU Node will not be able to read.\n\n</Tip>\n\nThe second way to access a TPU is via a **TPU VM.** When using a TPU VM, you connect directly to the machine that the TPU is attached to, much like training on a GPU VM. TPU VMs are generally easier to work with, particularly when it comes to your data pipeline. All of the above warnings do not apply to TPU VMs!\n\nThis is an opinionated document, so here\u2019s our opinion: **Avoid using TPU Node if possible.** It is more confusing and more difficult to debug than TPU VMs. It is also likely to be unsupported in future - Google\u2019s latest TPU, TPUv4, can only be accessed as a TPU VM, which suggests that TPU Nodes are increasingly going to become a \u201clegacy\u201d access method. However, we understand that the only free TPU access is on Colab and Kaggle Kernels, which uses TPU Node - so we\u2019ll try to explain how to handle it if you have to! Check the [TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) for code samples that explain this in more detail.\n\n### What sizes of TPU are available?\n\nA single TPU (a v2-8/v3-8/v4-8) runs 8 replicas. TPUs exist in **pods** that can run hundreds or thousands of replicas simultaneously. When you use more than a single TPU but less than a whole pod (for example, a v3-32), your TPU fleet is referred to as a **pod slice.**\n\nWhen you access a free TPU via Colab, you generally get a single v2-8 TPU.\n\n### I keep hearing about this XLA thing. What\u2019s XLA, and how does it relate to TPUs?\n\nXLA is an optimizing compiler, used by both TensorFlow and JAX. In JAX it is the only compiler, whereas in TensorFlow it is optional\n2,\t(for example, a v3-32), your TPU fleet is referred to as a **pod slice.**\n\nWhen you access a free TPU via Colab, you generally get a single v2-8 TPU.\n\n### I keep hearing about this XLA thing. What\u2019s XLA, and how does it relate to TPUs?\n\nXLA is an optimizing compiler, used by both TensorFlow and JAX. In JAX it is the only compiler, whereas in TensorFlow it is optional (but mandatory on TPU!). The easiest way to enable it when training a Keras model is to pass the argument `jit_compile=True` to `model.compile()`. If you don\u2019t get any errors and performance is good, that\u2019s a great sign that you\u2019re ready to move to TPU!\n\nDebugging on TPU is generally a bit harder than on CPU/GPU, so we recommend getting your code running on CPU/GPU with XLA first before trying it on TPU. You don\u2019t have to train for long, of course - just for a few steps to make sure that your model and data pipeline are working like you expect them to.\n\n<Tip>\n\nXLA compiled code is usually faster - so even if you\u2019re not planning to run on TPU, adding `jit_compile=True` can improve your performance. Be sure to note the caveats below about XLA compatibility, though!\n\n</Tip>\n\n<Tip warning={true}>\n\n**Tip born of painful experience:** Although using `jit_compile=True` is a good way to get a speed boost and test if your CPU/GPU code is XLA-compatible, it can actually cause a lot of problems if you leave it in when actually training on TPU. XLA compilation will happen implicitly on TPU, so remember to remove that line before actually running your code on a TPU!\n\n</Tip>\n\n### How do I make my model XLA compatible?\n\nIn many cases, your code is probably XLA-compatible already! However, there are a few things that work in normal TensorFlow that don\u2019t work in XLA. We\u2019ve distilled them into three core rules below:\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** We\u2019ve put a lot of effort into rewriting our TensorFlow models and loss functions to be XLA-compatible. Our models and loss functions generally obey rule #1 and #2 by default, so you can skip over them if you\u2019re using `transformers` models. Don\u2019t forget about these rules when writing your own models and loss functions, though!\n\n</Tip>\n\n#### XLA Rule #1: Your code cannot have \u201cdata-dependent conditionals\u201d\n\nWhat that means is that any `if` statement cannot depend on values inside a `tf.Tensor`. For example, this code block cannot be compiled with XLA!\n\n```python\nif tf.reduce_sum(tensor) > 10:\n    tensor = tensor / 2.0\n```\n\nThis might seem very restrictive at first, but most neural net code doesn\u2019t need to do this. You can often get around this restriction by using `tf.cond` (see the documentation [here](https://www.tensorflow.org/api_docs/python/tf/cond)) or by removing the conditional and finding a clever math trick with indicator variables instead, like so:\n\n```python\nsum_over_10 = tf.cast(tf.reduce_sum(tensor) > 10, tf.float32)\ntensor = tensor / (1.0 + sum_over_10)\n```\n\nThis code has exactly the same effect as the code above, but by avoiding a conditional, we ensure it will compile with XLA without problems!\n\n#### XLA Rule #2: Your code cannot have \u201cdata-dependent shapes\u201d\n\nWhat this means is that the shape of all of the `tf.Tensor` objects in your code cannot depend on their values. For example, the function `tf.unique` cannot be compiled with XLA, because it returns a `tensor` containing one instance of each unique value in the input. The shape of this output will obviously be different depending on how repetitive the input `Tensor` was, and so XLA refuses to handle it!\n\nIn general, most neural network code obeys rule #2 by default. However, there are a few common cases where it becomes a problem. One very common one is when you use **label masking**, setting your labels to a negative value to indicate that those positions should be ignored when computing the loss. If you look at NumPy or PyTorch loss functions that support label masking, you will often see code like this that uses [boolean indexing](https://numpy.org/doc/stable/user/basics.indexing.html#boolean-array-indexing):\n\n```python\nlabel_mask = labels >= 0\nmasked_outputs = outputs[label_mask]\nmasked_labels = labels[label_mask]\nloss = compute_loss(masked_outputs, masked_labels)\nmean_loss = torch.mean(loss)\n```\n\nThis code is totally fine in NumPy or PyTorch, but it breaks in XLA! Why? Because the shape of `masked_outputs` and `masked_labels` depends on how many positions are masked - that makes it a **data-dependent shape.** However, just like for rule #1, we can often rewrite this code to yield exactly the same output without any data-dependent shapes.\n\n```python\nlabel_mask = tf.cast(labels >= 0, tf.float32)\nloss = compute_loss(outputs, labels)\nloss = loss * label_mask  # Set negative label positions to 0\nmean_loss = tf.reduce_sum(loss) / tf.reduce_sum(label_mask)\n```\n\nHere, we avoid data-dependent shapes by computing the loss for every position, but zeroing out the masked positions in both the numerator and denominator when we calculate the mean, which yields exactly the same result as the first block while maintaining XLA compatibility. Note that we use the same trick as in rule #1 - converting a `tf.bool` to `\n3,\tlabel_mask  # Set negative label positions to 0\nmean_loss = tf.reduce_sum(loss) / tf.reduce_sum(label_mask)\n```\n\nHere, we avoid data-dependent shapes by computing the loss for every position, but zeroing out the masked positions in both the numerator and denominator when we calculate the mean, which yields exactly the same result as the first block while maintaining XLA compatibility. Note that we use the same trick as in rule #1 - converting a `tf.bool` to `tf.float32` and using it as an indicator variable. This is a really useful trick, so remember it if you need to convert your own code to XLA!\n\n#### XLA Rule #3: XLA will need to recompile your model for every different input shape it sees\n\nThis is the big one. What this means is that if your input shapes are very variable, XLA will have to recompile your model over and over, which will create huge performance problems. This commonly arises in NLP models, where input texts have variable lengths after tokenization. In other modalities, static shapes are more common and this rule is much less of a problem.\n\nHow can you get around rule #3? The key is **padding** - if you pad all your inputs to the same length, and then use an `attention_mask`, you can get the same results as you\u2019d get from variable shapes, but without any XLA issues. However, excessive padding can cause severe slowdown too - if you pad all your samples to the maximum length in the whole dataset, you might end up with batches consisting endless padding tokens, which will waste a lot of compute and memory!\n\nThere isn\u2019t a perfect solution to this problem. However, you can try some tricks. One very useful trick is to **pad batches of samples up to a multiple of a number like 32 or 64 tokens.** This often only increases the number of tokens by a small amount, but it hugely reduces the number of unique input shapes, because every input shape now has to be a multiple of 32 or 64. Fewer unique input shapes means fewer XLA compilations!\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** Our tokenizers and data collators have methods that can help you here. You can use `padding=\"max_length\"` or `padding=\"longest\"` when calling tokenizers to get them to output padded data. Our tokenizers and data collators also have a `pad_to_multiple_of` argument that you can use to reduce the number of unique input shapes you see!\n\n</Tip>\n\n### How do I actually train my model on TPU?\n\nOnce your training is XLA-compatible and (if you\u2019re using TPU Node / Colab) your dataset has been prepared appropriately, running on TPU is surprisingly easy! All you really need to change in your code is to add a few lines to initialize your TPU, and to ensure that your model and dataset are created inside a `TPUStrategy` scope. Take a look at [our TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) to see this in action!\n\n### Summary\n\nThere was a lot in here, so let\u2019s summarize with a quick checklist you can follow when you want to get your model ready for TPU training:\n\n- Make sure your code follows the three rules of XLA\n- Compile your model with `jit_compile=True` on CPU/GPU and confirm that you can train it with XLA\n- Either load your dataset into memory or use a TPU-compatible dataset loading approach (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Migrate your code either to Colab (with accelerator set to \u201cTPU\u201d) or a TPU VM on Google Cloud\n- Add TPU initializer code (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Create your `TPUStrategy` and make sure dataset loading and model creation are inside the `strategy.scope()` (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Don\u2019t forget to take `jit_compile=True` out again when you move to TPU!\n- \ud83d\ude4f\ud83d\ude4f\ud83d\ude4f\ud83e\udd7a\ud83e\udd7a\ud83e\udd7a\n- Call model.fit()\n- You did it!\n    ```",
            "vector_context": "[Created at: 2025-03-24 13:17:32]\n!--Copyright 2023 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\nthe License. You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under the License is distributed on\nan \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n\n\u26a0\ufe0f Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be\nrendered properly in your Markdown viewer.\n\n-->\n\n# Training on TPU with TensorFlow\n\n<Tip>\n\nIf you don't need long explanations and just want TPU code samples to get started with, check out [our TPU example notebook!](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb)\n\n</Tip>\n\n### What is a TPU?\n\nA TPU is a **Tensor Processing Unit.** They are hardware designed by Google, which are used to greatly speed up the tensor computations within neural networks, much like GPUs. They can be used for both network training and inference. They are generally accessed through Google\u2019s cloud services, but small TPUs can also be accessed directly for free through Google Colab and Kaggle Kernels.\n\nBecause [all TensorFlow models in \ud83e\udd17 Transformers are Keras models](https://huggingface.co/blog/tensorflow-philosophy), most of the methods in this document are generally applicable to TPU training for any Keras model! However, there are a few points that are specific to the HuggingFace ecosystem (hug-o-system?) of Transformers and Datasets, and we\u2019ll make sure to flag them up when we get to them.\n\n### What kinds of TPU are available?\n\nNew users are often very confused by the range of TPUs, and the different ways to access them. The first key distinction to understand is the difference between **TPU Nodes** and **TPU VMs.**\n\nWhen you use a **TPU Node**, you are effectively indirectly accessing a remote TPU. You will need a separate VM, which will initialize your network and data pipeline and then forward them to the remote node. When you use a TPU on Google Colab, you are accessing it in the **TPU Node** style.\n\nUsing TPU Nodes can have some quite unexpected behaviour for people who aren\u2019t used to them! In particular, because the TPU is located on a physically different system to the machine you\u2019re running your Python code on, your data cannot be local to your machine - any data pipeline that loads from your machine\u2019s internal storage will totally fail! Instead, data must be stored in Google Cloud Storage where your data pipeline can still access it, even when the pipeline is running on the remote TPU node.\n\n<Tip>\n\nIf you can fit all your data in memory as `np.ndarray` or `tf.Tensor`, then you can `fit()` on that data even when using Colab or a TPU Node, without needing to upload it to Google Cloud Storage.\n\n</Tip>\n\n<Tip>\n\n**\ud83e\udd17Specific Hugging Face Tip\ud83e\udd17:** The methods `Dataset.to_tf_dataset()` and its higher-level wrapper `model.prepare_tf_dataset()` , which you will see throughout our TF code examples, will both fail on a TPU Node. The reason for this is that even though they create a `tf.data.Dataset` it is not a \u201cpure\u201d `tf.data` pipeline and uses `tf.numpy_function` or `Dataset.from_generator()` to stream data from the underlying HuggingFace `Dataset`. This HuggingFace `Dataset` is backed by data that is on a local disc and which the remote TPU Node will not be able to read.\n\n</Tip>\n\nThe second way to access a TPU is via a **TPU VM.** When using a TPU VM, you connect directly to the machine that the TPU is attached to, much like training on a GPU VM. TPU VMs are generally easier to work with, particularly when it comes to your data pipeline. All of the above warnings do not apply to TPU VMs!\n\nThis is an opinionated document, so here\u2019s our opinion: **Avoid using TPU Node if possible.** It is more confusing and more difficult to debug than TPU VMs. It is also likely to be unsupported in future - Google\u2019s latest TPU, TPUv4, can only be accessed as a TPU VM, which suggests that TPU Nodes are increasingly going to become a \u201clegacy\u201d access method. However, we understand that the only free TPU access is on Colab and Kaggle Kernels, which uses TPU Node - so we\u2019ll try to explain how to handle it if you have to! Check the [TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) for code samples that explain this in more detail.\n\n### What sizes of TPU are available?\n\nA single TPU (a v2-8/v3-8/v4-8) runs 8 replicas. TPUs exist in **pods** that can run hundreds or thousands of replicas simultaneously. When you use more than a single TPU but less than a whole pod (for example, a v3-32), your TPU fleet is referred to as a **pod slice.**\n\nWhen you access a free TPU via Colab, you generally get a single v2-8 TPU.\n\n### I keep hearing about this XLA thing. What\u2019s XLA, and how does it relate to TPUs?\n\nXLA is an optimizing compiler, used by both TensorFlow and JAX. In JAX it is the only compiler, whereas in TensorFlow it is optional\n--New Chunk--\n[Created at: 2025-03-24 13:17:32]\n(for example, a v3-32), your TPU fleet is referred to as a **pod slice.**\n\nWhen you access a free TPU via Colab, you generally get a single v2-8 TPU.\n\n### I keep hearing about this XLA thing. What\u2019s XLA, and how does it relate to TPUs?\n\nXLA is an optimizing compiler, used by both TensorFlow and JAX. In JAX it is the only compiler, whereas in TensorFlow it is optional (but mandatory on TPU!). The easiest way to enable it when training a Keras model is to pass the argument `jit_compile=True` to `model.compile()`. If you don\u2019t get any errors and performance is good, that\u2019s a great sign that you\u2019re ready to move to TPU!\n\nDebugging on TPU is generally a bit harder than on CPU/GPU, so we recommend getting your code running on CPU/GPU with XLA first before trying it on TPU. You don\u2019t have to train for long, of course - just for a few steps to make sure that your model and data pipeline are working like you expect them to.\n\n<Tip>\n\nXLA compiled code is usually faster - so even if you\u2019re not planning to run on TPU, adding `jit_compile=True` can improve your performance. Be sure to note the caveats below about XLA compatibility, though!\n\n</Tip>\n\n<Tip warning={true}>\n\n**Tip born of painful experience:** Although using `jit_compile=True` is a good way to get a speed boost and test if your CPU/GPU code is XLA-compatible, it can actually cause a lot of problems if you leave it in when actually training on TPU. XLA compilation will happen implicitly on TPU, so remember to remove that line before actually running your code on a TPU!\n\n</Tip>\n\n### How do I make my model XLA compatible?\n\nIn many cases, your code is probably XLA-compatible already! However, there are a few things that work in normal TensorFlow that don\u2019t work in XLA. We\u2019ve distilled them into three core rules below:\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** We\u2019ve put a lot of effort into rewriting our TensorFlow models and loss functions to be XLA-compatible. Our models and loss functions generally obey rule #1 and #2 by default, so you can skip over them if you\u2019re using `transformers` models. Don\u2019t forget about these rules when writing your own models and loss functions, though!\n\n</Tip>\n\n#### XLA Rule #1: Your code cannot have \u201cdata-dependent conditionals\u201d\n\nWhat that means is that any `if` statement cannot depend on values inside a `tf.Tensor`. For example, this code block cannot be compiled with XLA!\n\n```python\nif tf.reduce_sum(tensor) > 10:\n    tensor = tensor / 2.0\n```\n\nThis might seem very restrictive at first, but most neural net code doesn\u2019t need to do this. You can often get around this restriction by using `tf.cond` (see the documentation [here](https://www.tensorflow.org/api_docs/python/tf/cond)) or by removing the conditional and finding a clever math trick with indicator variables instead, like so:\n\n```python\nsum_over_10 = tf.cast(tf.reduce_sum(tensor) > 10, tf.float32)\ntensor = tensor / (1.0 + sum_over_10)\n```\n\nThis code has exactly the same effect as the code above, but by avoiding a conditional, we ensure it will compile with XLA without problems!\n\n#### XLA Rule #2: Your code cannot have \u201cdata-dependent shapes\u201d\n\nWhat this means is that the shape of all of the `tf.Tensor` objects in your code cannot depend on their values. For example, the function `tf.unique` cannot be compiled with XLA, because it returns a `tensor` containing one instance of each unique value in the input. The shape of this output will obviously be different depending on how repetitive the input `Tensor` was, and so XLA refuses to handle it!\n\nIn general, most neural network code obeys rule #2 by default. However, there are a few common cases where it becomes a problem. One very common one is when you use **label masking**, setting your labels to a negative value to indicate that those positions should be ignored when computing the loss. If you look at NumPy or PyTorch loss functions that support label masking, you will often see code like this that uses [boolean indexing](https://numpy.org/doc/stable/user/basics.indexing.html#boolean-array-indexing):\n\n```python\nlabel_mask = labels >= 0\nmasked_outputs = outputs[label_mask]\nmasked_labels = labels[label_mask]\nloss = compute_loss(masked_outputs, masked_labels)\nmean_loss = torch.mean(loss)\n```\n\nThis code is totally fine in NumPy or PyTorch, but it breaks in XLA! Why? Because the shape of `masked_outputs` and `masked_labels` depends on how many positions are masked - that makes it a **data-dependent shape.** However, just like for rule #1, we can often rewrite this code to yield exactly the same output without any data-dependent shapes.\n\n```python\nlabel_mask = tf.cast(labels >= 0, tf.float32)\nloss = compute_loss(outputs, labels)\nloss = loss * label_mask  # Set negative label positions to 0\nmean_loss = tf.reduce_sum(loss) / tf.reduce_sum(label_mask)\n```\n\nHere, we avoid data-dependent shapes by computing the loss for every position, but zeroing out the masked positions in both the numerator and denominator when we calculate the mean, which yields exactly the same result as the first block while maintaining XLA compatibility. Note that we use the same trick as in rule #1 - converting a `tf.bool` to `\n--New Chunk--\n[Created at: 2025-03-24 13:17:32]\nlabel_mask  # Set negative label positions to 0\nmean_loss = tf.reduce_sum(loss) / tf.reduce_sum(label_mask)\n```\n\nHere, we avoid data-dependent shapes by computing the loss for every position, but zeroing out the masked positions in both the numerator and denominator when we calculate the mean, which yields exactly the same result as the first block while maintaining XLA compatibility. Note that we use the same trick as in rule #1 - converting a `tf.bool` to `tf.float32` and using it as an indicator variable. This is a really useful trick, so remember it if you need to convert your own code to XLA!\n\n#### XLA Rule #3: XLA will need to recompile your model for every different input shape it sees\n\nThis is the big one. What this means is that if your input shapes are very variable, XLA will have to recompile your model over and over, which will create huge performance problems. This commonly arises in NLP models, where input texts have variable lengths after tokenization. In other modalities, static shapes are more common and this rule is much less of a problem.\n\nHow can you get around rule #3? The key is **padding** - if you pad all your inputs to the same length, and then use an `attention_mask`, you can get the same results as you\u2019d get from variable shapes, but without any XLA issues. However, excessive padding can cause severe slowdown too - if you pad all your samples to the maximum length in the whole dataset, you might end up with batches consisting endless padding tokens, which will waste a lot of compute and memory!\n\nThere isn\u2019t a perfect solution to this problem. However, you can try some tricks. One very useful trick is to **pad batches of samples up to a multiple of a number like 32 or 64 tokens.** This often only increases the number of tokens by a small amount, but it hugely reduces the number of unique input shapes, because every input shape now has to be a multiple of 32 or 64. Fewer unique input shapes means fewer XLA compilations!\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** Our tokenizers and data collators have methods that can help you here. You can use `padding=\"max_length\"` or `padding=\"longest\"` when calling tokenizers to get them to output padded data. Our tokenizers and data collators also have a `pad_to_multiple_of` argument that you can use to reduce the number of unique input shapes you see!\n\n</Tip>\n\n### How do I actually train my model on TPU?\n\nOnce your training is XLA-compatible and (if you\u2019re using TPU Node / Colab) your dataset has been prepared appropriately, running on TPU is surprisingly easy! All you really need to change in your code is to add a few lines to initialize your TPU, and to ensure that your model and dataset are created inside a `TPUStrategy` scope. Take a look at [our TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) to see this in action!\n\n### Summary\n\nThere was a lot in here, so let\u2019s summarize with a quick checklist you can follow when you want to get your model ready for TPU training:\n\n- Make sure your code follows the three rules of XLA\n- Compile your model with `jit_compile=True` on CPU/GPU and confirm that you can train it with XLA\n- Either load your dataset into memory or use a TPU-compatible dataset loading approach (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Migrate your code either to Colab (with accelerator set to \u201cTPU\u201d) or a TPU VM on Google Cloud\n- Add TPU initializer code (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Create your `TPUStrategy` and make sure dataset loading and model creation are inside the `strategy.scope()` (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Don\u2019t forget to take `jit_compile=True` out again when you move to TPU!\n- \ud83d\ude4f\ud83d\ude4f\ud83d\ude4f\ud83e\udd7a\ud83e\udd7a\ud83e\udd7a\n- Call model.fit()\n- You did it!"
        }
    },
    {
        "sample_idx": 40,
        "question": "Where can small TPUs be accessed directly for free?",
        "answer": "Small TPUs can also be accessed directly for free through Google Colab and Kaggle Kernels.",
        "rag_answer": "According to the provided Data Sources, small TPUs can be accessed directly for free through Google Colab and Kaggle Kernels.",
        "rag_score": null,
        "rag_feedback": null,
        "rag_context": {
            "kg_context": "-----Entities-----\n    ```csv\n    id,\tentity,\ttype,\tdescription,\trankcreated_at\n1,\tGoogle,organization,Google is the company that designs and provides TPUs, which are used to speed up tensor computations within neural networks.,3,2025-03-24 13:18:20\n2,\tTPU,technology,TPU is a Tensor Processing Unit, a hardware designed by Google to speed up tensor computations within neural networks.<SEP>TPU is a type of hardware accelerator designed for machine learning workloads.<SEP>TPU is a type of hardware accelerator used for machine learning computations.,4,2025-03-24 13:18:20\n3,\tColab,geo,Colab is a cloud-based platform for data science and machine learning, provided by Google.<SEP>Colab is a platform where users can access a free TPU.,3,2025-03-24 13:18:20\n4,\tGoogle Cloud,organization,Google Cloud is a cloud computing platform that provides infrastructure and services for building and deploying machine learning models.,1,2025-03-24 13:18:20\n5,\tTPU,technology,TPU is a Tensor Processing Unit, a hardware designed by Google to speed up tensor computations within neural networks.<SEP>TPU is a type of hardware accelerator designed for machine learning workloads.<SEP>TPU is a type of hardware accelerator used for machine learning computations.,4,UNKNOWN\n6,\tGoogle,organization,Google is the company that designs and provides TPUs, which are used to speed up tensor computations within neural networks.,3,UNKNOWN\n7,\tTPU Node,category,TPU Node is a type of hardware accelerator designed for machine learning workloads.<SEP>TPU Node is a way to access a TPU, where the user indirectly accesses a remote TPU.,0,UNKNOWN\n    ```\n    -----Relationships-----\n    ```csv\n    id,\tsource,\ttarget,\tdescription,\tkeywords,\tweight,\trank,\tcreated_at\n1,\tGoogle,TPU,Google designs and provides TPUs, which are used to speed up tensor computations within neural networks.,hardware design, acceleration,18.0,7,2025-03-24 13:18:20\n2,\tColab,TPU,Colab provides access to a free TPU for users.,platform, hardware acceleration,16.0,7,2025-03-24 13:18:20\n3,\tGoogle Cloud,TPU,Google Cloud provides infrastructure and services for building and deploying machine learning models, including TPU hardware.,infrastructure provision, hardware acceleration,14.0,5,2025-03-24 13:18:20\n4,\tTPU,XLA,XLA compiles TensorFlow graphs into executable code for TPU hardware.<SEP>XLA is used to optimize code for TPU hardware.,compilation, hardware acceleration<SEP>compiler, hardware optimization,36.0,10,UNKNOWN\n5,\tGoogle,TPU,Google designs and provides TPUs, which are used to speed up tensor computations within neural networks.,hardware design, acceleration,18.0,7,UNKNOWN\n6,\tColab,TPU,Colab provides access to a free TPU for users.,platform, hardware acceleration,16.0,7,UNKNOWN\n7,\tColab,Google,Colab is a cloud-based platform provided by Google for data science and machine learning.,platform provision, cloud computing,16.0,6,UNKNOWN\n8,\tGoogle Cloud,TPU,Google Cloud provides infrastructure and services for building and deploying machine learning models, including TPU hardware.,infrastructure provision, hardware acceleration,14.0,5,UNKNOWN\n9,\tGoogle,Kaggle Kernels,Kaggle Kernels is a cloud-based platform provided by Google for data science and machine learning competitions.,platform provision, cloud computing,16.0,4,UNKNOWN\n    ```\n    -----Sources-----\n    ```csv\n    id,\tcontent\n1,\t!--Copyright 2023 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\nthe License. You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under the License is distributed on\nan \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n\n\u26a0\ufe0f Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be\nrendered properly in your Markdown viewer.\n\n-->\n\n# Training on TPU with TensorFlow\n\n<Tip>\n\nIf you don't need long explanations and just want TPU code samples to get started with, check out [our TPU example notebook!](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb)\n\n</Tip>\n\n### What is a TPU?\n\nA TPU is a **Tensor Processing Unit.** They are hardware designed by Google, which are used to greatly speed up the tensor computations within neural networks, much like GPUs. They can be used for both network training and inference. They are generally accessed through Google\u2019s cloud services, but small TPUs can also be accessed directly for free through Google Colab and Kaggle Kernels.\n\nBecause [all TensorFlow models in \ud83e\udd17 Transformers are Keras models](https://huggingface.co/blog/tensorflow-philosophy), most of the methods in this document are generally applicable to TPU training for any Keras model! However, there are a few points that are specific to the HuggingFace ecosystem (hug-o-system?) of Transformers and Datasets, and we\u2019ll make sure to flag them up when we get to them.\n\n### What kinds of TPU are available?\n\nNew users are often very confused by the range of TPUs, and the different ways to access them. The first key distinction to understand is the difference between **TPU Nodes** and **TPU VMs.**\n\nWhen you use a **TPU Node**, you are effectively indirectly accessing a remote TPU. You will need a separate VM, which will initialize your network and data pipeline and then forward them to the remote node. When you use a TPU on Google Colab, you are accessing it in the **TPU Node** style.\n\nUsing TPU Nodes can have some quite unexpected behaviour for people who aren\u2019t used to them! In particular, because the TPU is located on a physically different system to the machine you\u2019re running your Python code on, your data cannot be local to your machine - any data pipeline that loads from your machine\u2019s internal storage will totally fail! Instead, data must be stored in Google Cloud Storage where your data pipeline can still access it, even when the pipeline is running on the remote TPU node.\n\n<Tip>\n\nIf you can fit all your data in memory as `np.ndarray` or `tf.Tensor`, then you can `fit()` on that data even when using Colab or a TPU Node, without needing to upload it to Google Cloud Storage.\n\n</Tip>\n\n<Tip>\n\n**\ud83e\udd17Specific Hugging Face Tip\ud83e\udd17:** The methods `Dataset.to_tf_dataset()` and its higher-level wrapper `model.prepare_tf_dataset()` , which you will see throughout our TF code examples, will both fail on a TPU Node. The reason for this is that even though they create a `tf.data.Dataset` it is not a \u201cpure\u201d `tf.data` pipeline and uses `tf.numpy_function` or `Dataset.from_generator()` to stream data from the underlying HuggingFace `Dataset`. This HuggingFace `Dataset` is backed by data that is on a local disc and which the remote TPU Node will not be able to read.\n\n</Tip>\n\nThe second way to access a TPU is via a **TPU VM.** When using a TPU VM, you connect directly to the machine that the TPU is attached to, much like training on a GPU VM. TPU VMs are generally easier to work with, particularly when it comes to your data pipeline. All of the above warnings do not apply to TPU VMs!\n\nThis is an opinionated document, so here\u2019s our opinion: **Avoid using TPU Node if possible.** It is more confusing and more difficult to debug than TPU VMs. It is also likely to be unsupported in future - Google\u2019s latest TPU, TPUv4, can only be accessed as a TPU VM, which suggests that TPU Nodes are increasingly going to become a \u201clegacy\u201d access method. However, we understand that the only free TPU access is on Colab and Kaggle Kernels, which uses TPU Node - so we\u2019ll try to explain how to handle it if you have to! Check the [TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) for code samples that explain this in more detail.\n\n### What sizes of TPU are available?\n\nA single TPU (a v2-8/v3-8/v4-8) runs 8 replicas. TPUs exist in **pods** that can run hundreds or thousands of replicas simultaneously. When you use more than a single TPU but less than a whole pod (for example, a v3-32), your TPU fleet is referred to as a **pod slice.**\n\nWhen you access a free TPU via Colab, you generally get a single v2-8 TPU.\n\n### I keep hearing about this XLA thing. What\u2019s XLA, and how does it relate to TPUs?\n\nXLA is an optimizing compiler, used by both TensorFlow and JAX. In JAX it is the only compiler, whereas in TensorFlow it is optional\n2,\t(for example, a v3-32), your TPU fleet is referred to as a **pod slice.**\n\nWhen you access a free TPU via Colab, you generally get a single v2-8 TPU.\n\n### I keep hearing about this XLA thing. What\u2019s XLA, and how does it relate to TPUs?\n\nXLA is an optimizing compiler, used by both TensorFlow and JAX. In JAX it is the only compiler, whereas in TensorFlow it is optional (but mandatory on TPU!). The easiest way to enable it when training a Keras model is to pass the argument `jit_compile=True` to `model.compile()`. If you don\u2019t get any errors and performance is good, that\u2019s a great sign that you\u2019re ready to move to TPU!\n\nDebugging on TPU is generally a bit harder than on CPU/GPU, so we recommend getting your code running on CPU/GPU with XLA first before trying it on TPU. You don\u2019t have to train for long, of course - just for a few steps to make sure that your model and data pipeline are working like you expect them to.\n\n<Tip>\n\nXLA compiled code is usually faster - so even if you\u2019re not planning to run on TPU, adding `jit_compile=True` can improve your performance. Be sure to note the caveats below about XLA compatibility, though!\n\n</Tip>\n\n<Tip warning={true}>\n\n**Tip born of painful experience:** Although using `jit_compile=True` is a good way to get a speed boost and test if your CPU/GPU code is XLA-compatible, it can actually cause a lot of problems if you leave it in when actually training on TPU. XLA compilation will happen implicitly on TPU, so remember to remove that line before actually running your code on a TPU!\n\n</Tip>\n\n### How do I make my model XLA compatible?\n\nIn many cases, your code is probably XLA-compatible already! However, there are a few things that work in normal TensorFlow that don\u2019t work in XLA. We\u2019ve distilled them into three core rules below:\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** We\u2019ve put a lot of effort into rewriting our TensorFlow models and loss functions to be XLA-compatible. Our models and loss functions generally obey rule #1 and #2 by default, so you can skip over them if you\u2019re using `transformers` models. Don\u2019t forget about these rules when writing your own models and loss functions, though!\n\n</Tip>\n\n#### XLA Rule #1: Your code cannot have \u201cdata-dependent conditionals\u201d\n\nWhat that means is that any `if` statement cannot depend on values inside a `tf.Tensor`. For example, this code block cannot be compiled with XLA!\n\n```python\nif tf.reduce_sum(tensor) > 10:\n    tensor = tensor / 2.0\n```\n\nThis might seem very restrictive at first, but most neural net code doesn\u2019t need to do this. You can often get around this restriction by using `tf.cond` (see the documentation [here](https://www.tensorflow.org/api_docs/python/tf/cond)) or by removing the conditional and finding a clever math trick with indicator variables instead, like so:\n\n```python\nsum_over_10 = tf.cast(tf.reduce_sum(tensor) > 10, tf.float32)\ntensor = tensor / (1.0 + sum_over_10)\n```\n\nThis code has exactly the same effect as the code above, but by avoiding a conditional, we ensure it will compile with XLA without problems!\n\n#### XLA Rule #2: Your code cannot have \u201cdata-dependent shapes\u201d\n\nWhat this means is that the shape of all of the `tf.Tensor` objects in your code cannot depend on their values. For example, the function `tf.unique` cannot be compiled with XLA, because it returns a `tensor` containing one instance of each unique value in the input. The shape of this output will obviously be different depending on how repetitive the input `Tensor` was, and so XLA refuses to handle it!\n\nIn general, most neural network code obeys rule #2 by default. However, there are a few common cases where it becomes a problem. One very common one is when you use **label masking**, setting your labels to a negative value to indicate that those positions should be ignored when computing the loss. If you look at NumPy or PyTorch loss functions that support label masking, you will often see code like this that uses [boolean indexing](https://numpy.org/doc/stable/user/basics.indexing.html#boolean-array-indexing):\n\n```python\nlabel_mask = labels >= 0\nmasked_outputs = outputs[label_mask]\nmasked_labels = labels[label_mask]\nloss = compute_loss(masked_outputs, masked_labels)\nmean_loss = torch.mean(loss)\n```\n\nThis code is totally fine in NumPy or PyTorch, but it breaks in XLA! Why? Because the shape of `masked_outputs` and `masked_labels` depends on how many positions are masked - that makes it a **data-dependent shape.** However, just like for rule #1, we can often rewrite this code to yield exactly the same output without any data-dependent shapes.\n\n```python\nlabel_mask = tf.cast(labels >= 0, tf.float32)\nloss = compute_loss(outputs, labels)\nloss = loss * label_mask  # Set negative label positions to 0\nmean_loss = tf.reduce_sum(loss) / tf.reduce_sum(label_mask)\n```\n\nHere, we avoid data-dependent shapes by computing the loss for every position, but zeroing out the masked positions in both the numerator and denominator when we calculate the mean, which yields exactly the same result as the first block while maintaining XLA compatibility. Note that we use the same trick as in rule #1 - converting a `tf.bool` to `\n3,\tlabel_mask  # Set negative label positions to 0\nmean_loss = tf.reduce_sum(loss) / tf.reduce_sum(label_mask)\n```\n\nHere, we avoid data-dependent shapes by computing the loss for every position, but zeroing out the masked positions in both the numerator and denominator when we calculate the mean, which yields exactly the same result as the first block while maintaining XLA compatibility. Note that we use the same trick as in rule #1 - converting a `tf.bool` to `tf.float32` and using it as an indicator variable. This is a really useful trick, so remember it if you need to convert your own code to XLA!\n\n#### XLA Rule #3: XLA will need to recompile your model for every different input shape it sees\n\nThis is the big one. What this means is that if your input shapes are very variable, XLA will have to recompile your model over and over, which will create huge performance problems. This commonly arises in NLP models, where input texts have variable lengths after tokenization. In other modalities, static shapes are more common and this rule is much less of a problem.\n\nHow can you get around rule #3? The key is **padding** - if you pad all your inputs to the same length, and then use an `attention_mask`, you can get the same results as you\u2019d get from variable shapes, but without any XLA issues. However, excessive padding can cause severe slowdown too - if you pad all your samples to the maximum length in the whole dataset, you might end up with batches consisting endless padding tokens, which will waste a lot of compute and memory!\n\nThere isn\u2019t a perfect solution to this problem. However, you can try some tricks. One very useful trick is to **pad batches of samples up to a multiple of a number like 32 or 64 tokens.** This often only increases the number of tokens by a small amount, but it hugely reduces the number of unique input shapes, because every input shape now has to be a multiple of 32 or 64. Fewer unique input shapes means fewer XLA compilations!\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** Our tokenizers and data collators have methods that can help you here. You can use `padding=\"max_length\"` or `padding=\"longest\"` when calling tokenizers to get them to output padded data. Our tokenizers and data collators also have a `pad_to_multiple_of` argument that you can use to reduce the number of unique input shapes you see!\n\n</Tip>\n\n### How do I actually train my model on TPU?\n\nOnce your training is XLA-compatible and (if you\u2019re using TPU Node / Colab) your dataset has been prepared appropriately, running on TPU is surprisingly easy! All you really need to change in your code is to add a few lines to initialize your TPU, and to ensure that your model and dataset are created inside a `TPUStrategy` scope. Take a look at [our TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) to see this in action!\n\n### Summary\n\nThere was a lot in here, so let\u2019s summarize with a quick checklist you can follow when you want to get your model ready for TPU training:\n\n- Make sure your code follows the three rules of XLA\n- Compile your model with `jit_compile=True` on CPU/GPU and confirm that you can train it with XLA\n- Either load your dataset into memory or use a TPU-compatible dataset loading approach (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Migrate your code either to Colab (with accelerator set to \u201cTPU\u201d) or a TPU VM on Google Cloud\n- Add TPU initializer code (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Create your `TPUStrategy` and make sure dataset loading and model creation are inside the `strategy.scope()` (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Don\u2019t forget to take `jit_compile=True` out again when you move to TPU!\n- \ud83d\ude4f\ud83d\ude4f\ud83d\ude4f\ud83e\udd7a\ud83e\udd7a\ud83e\udd7a\n- Call model.fit()\n- You did it!\n    ```",
            "vector_context": "[Created at: 2025-03-24 13:17:32]\n!--Copyright 2023 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\nthe License. You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under the License is distributed on\nan \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n\n\u26a0\ufe0f Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be\nrendered properly in your Markdown viewer.\n\n-->\n\n# Training on TPU with TensorFlow\n\n<Tip>\n\nIf you don't need long explanations and just want TPU code samples to get started with, check out [our TPU example notebook!](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb)\n\n</Tip>\n\n### What is a TPU?\n\nA TPU is a **Tensor Processing Unit.** They are hardware designed by Google, which are used to greatly speed up the tensor computations within neural networks, much like GPUs. They can be used for both network training and inference. They are generally accessed through Google\u2019s cloud services, but small TPUs can also be accessed directly for free through Google Colab and Kaggle Kernels.\n\nBecause [all TensorFlow models in \ud83e\udd17 Transformers are Keras models](https://huggingface.co/blog/tensorflow-philosophy), most of the methods in this document are generally applicable to TPU training for any Keras model! However, there are a few points that are specific to the HuggingFace ecosystem (hug-o-system?) of Transformers and Datasets, and we\u2019ll make sure to flag them up when we get to them.\n\n### What kinds of TPU are available?\n\nNew users are often very confused by the range of TPUs, and the different ways to access them. The first key distinction to understand is the difference between **TPU Nodes** and **TPU VMs.**\n\nWhen you use a **TPU Node**, you are effectively indirectly accessing a remote TPU. You will need a separate VM, which will initialize your network and data pipeline and then forward them to the remote node. When you use a TPU on Google Colab, you are accessing it in the **TPU Node** style.\n\nUsing TPU Nodes can have some quite unexpected behaviour for people who aren\u2019t used to them! In particular, because the TPU is located on a physically different system to the machine you\u2019re running your Python code on, your data cannot be local to your machine - any data pipeline that loads from your machine\u2019s internal storage will totally fail! Instead, data must be stored in Google Cloud Storage where your data pipeline can still access it, even when the pipeline is running on the remote TPU node.\n\n<Tip>\n\nIf you can fit all your data in memory as `np.ndarray` or `tf.Tensor`, then you can `fit()` on that data even when using Colab or a TPU Node, without needing to upload it to Google Cloud Storage.\n\n</Tip>\n\n<Tip>\n\n**\ud83e\udd17Specific Hugging Face Tip\ud83e\udd17:** The methods `Dataset.to_tf_dataset()` and its higher-level wrapper `model.prepare_tf_dataset()` , which you will see throughout our TF code examples, will both fail on a TPU Node. The reason for this is that even though they create a `tf.data.Dataset` it is not a \u201cpure\u201d `tf.data` pipeline and uses `tf.numpy_function` or `Dataset.from_generator()` to stream data from the underlying HuggingFace `Dataset`. This HuggingFace `Dataset` is backed by data that is on a local disc and which the remote TPU Node will not be able to read.\n\n</Tip>\n\nThe second way to access a TPU is via a **TPU VM.** When using a TPU VM, you connect directly to the machine that the TPU is attached to, much like training on a GPU VM. TPU VMs are generally easier to work with, particularly when it comes to your data pipeline. All of the above warnings do not apply to TPU VMs!\n\nThis is an opinionated document, so here\u2019s our opinion: **Avoid using TPU Node if possible.** It is more confusing and more difficult to debug than TPU VMs. It is also likely to be unsupported in future - Google\u2019s latest TPU, TPUv4, can only be accessed as a TPU VM, which suggests that TPU Nodes are increasingly going to become a \u201clegacy\u201d access method. However, we understand that the only free TPU access is on Colab and Kaggle Kernels, which uses TPU Node - so we\u2019ll try to explain how to handle it if you have to! Check the [TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) for code samples that explain this in more detail.\n\n### What sizes of TPU are available?\n\nA single TPU (a v2-8/v3-8/v4-8) runs 8 replicas. TPUs exist in **pods** that can run hundreds or thousands of replicas simultaneously. When you use more than a single TPU but less than a whole pod (for example, a v3-32), your TPU fleet is referred to as a **pod slice.**\n\nWhen you access a free TPU via Colab, you generally get a single v2-8 TPU.\n\n### I keep hearing about this XLA thing. What\u2019s XLA, and how does it relate to TPUs?\n\nXLA is an optimizing compiler, used by both TensorFlow and JAX. In JAX it is the only compiler, whereas in TensorFlow it is optional\n--New Chunk--\n[Created at: 2025-03-24 13:17:32]\n(for example, a v3-32), your TPU fleet is referred to as a **pod slice.**\n\nWhen you access a free TPU via Colab, you generally get a single v2-8 TPU.\n\n### I keep hearing about this XLA thing. What\u2019s XLA, and how does it relate to TPUs?\n\nXLA is an optimizing compiler, used by both TensorFlow and JAX. In JAX it is the only compiler, whereas in TensorFlow it is optional (but mandatory on TPU!). The easiest way to enable it when training a Keras model is to pass the argument `jit_compile=True` to `model.compile()`. If you don\u2019t get any errors and performance is good, that\u2019s a great sign that you\u2019re ready to move to TPU!\n\nDebugging on TPU is generally a bit harder than on CPU/GPU, so we recommend getting your code running on CPU/GPU with XLA first before trying it on TPU. You don\u2019t have to train for long, of course - just for a few steps to make sure that your model and data pipeline are working like you expect them to.\n\n<Tip>\n\nXLA compiled code is usually faster - so even if you\u2019re not planning to run on TPU, adding `jit_compile=True` can improve your performance. Be sure to note the caveats below about XLA compatibility, though!\n\n</Tip>\n\n<Tip warning={true}>\n\n**Tip born of painful experience:** Although using `jit_compile=True` is a good way to get a speed boost and test if your CPU/GPU code is XLA-compatible, it can actually cause a lot of problems if you leave it in when actually training on TPU. XLA compilation will happen implicitly on TPU, so remember to remove that line before actually running your code on a TPU!\n\n</Tip>\n\n### How do I make my model XLA compatible?\n\nIn many cases, your code is probably XLA-compatible already! However, there are a few things that work in normal TensorFlow that don\u2019t work in XLA. We\u2019ve distilled them into three core rules below:\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** We\u2019ve put a lot of effort into rewriting our TensorFlow models and loss functions to be XLA-compatible. Our models and loss functions generally obey rule #1 and #2 by default, so you can skip over them if you\u2019re using `transformers` models. Don\u2019t forget about these rules when writing your own models and loss functions, though!\n\n</Tip>\n\n#### XLA Rule #1: Your code cannot have \u201cdata-dependent conditionals\u201d\n\nWhat that means is that any `if` statement cannot depend on values inside a `tf.Tensor`. For example, this code block cannot be compiled with XLA!\n\n```python\nif tf.reduce_sum(tensor) > 10:\n    tensor = tensor / 2.0\n```\n\nThis might seem very restrictive at first, but most neural net code doesn\u2019t need to do this. You can often get around this restriction by using `tf.cond` (see the documentation [here](https://www.tensorflow.org/api_docs/python/tf/cond)) or by removing the conditional and finding a clever math trick with indicator variables instead, like so:\n\n```python\nsum_over_10 = tf.cast(tf.reduce_sum(tensor) > 10, tf.float32)\ntensor = tensor / (1.0 + sum_over_10)\n```\n\nThis code has exactly the same effect as the code above, but by avoiding a conditional, we ensure it will compile with XLA without problems!\n\n#### XLA Rule #2: Your code cannot have \u201cdata-dependent shapes\u201d\n\nWhat this means is that the shape of all of the `tf.Tensor` objects in your code cannot depend on their values. For example, the function `tf.unique` cannot be compiled with XLA, because it returns a `tensor` containing one instance of each unique value in the input. The shape of this output will obviously be different depending on how repetitive the input `Tensor` was, and so XLA refuses to handle it!\n\nIn general, most neural network code obeys rule #2 by default. However, there are a few common cases where it becomes a problem. One very common one is when you use **label masking**, setting your labels to a negative value to indicate that those positions should be ignored when computing the loss. If you look at NumPy or PyTorch loss functions that support label masking, you will often see code like this that uses [boolean indexing](https://numpy.org/doc/stable/user/basics.indexing.html#boolean-array-indexing):\n\n```python\nlabel_mask = labels >= 0\nmasked_outputs = outputs[label_mask]\nmasked_labels = labels[label_mask]\nloss = compute_loss(masked_outputs, masked_labels)\nmean_loss = torch.mean(loss)\n```\n\nThis code is totally fine in NumPy or PyTorch, but it breaks in XLA! Why? Because the shape of `masked_outputs` and `masked_labels` depends on how many positions are masked - that makes it a **data-dependent shape.** However, just like for rule #1, we can often rewrite this code to yield exactly the same output without any data-dependent shapes.\n\n```python\nlabel_mask = tf.cast(labels >= 0, tf.float32)\nloss = compute_loss(outputs, labels)\nloss = loss * label_mask  # Set negative label positions to 0\nmean_loss = tf.reduce_sum(loss) / tf.reduce_sum(label_mask)\n```\n\nHere, we avoid data-dependent shapes by computing the loss for every position, but zeroing out the masked positions in both the numerator and denominator when we calculate the mean, which yields exactly the same result as the first block while maintaining XLA compatibility. Note that we use the same trick as in rule #1 - converting a `tf.bool` to `\n--New Chunk--\n[Created at: 2025-03-24 13:17:32]\nlabel_mask  # Set negative label positions to 0\nmean_loss = tf.reduce_sum(loss) / tf.reduce_sum(label_mask)\n```\n\nHere, we avoid data-dependent shapes by computing the loss for every position, but zeroing out the masked positions in both the numerator and denominator when we calculate the mean, which yields exactly the same result as the first block while maintaining XLA compatibility. Note that we use the same trick as in rule #1 - converting a `tf.bool` to `tf.float32` and using it as an indicator variable. This is a really useful trick, so remember it if you need to convert your own code to XLA!\n\n#### XLA Rule #3: XLA will need to recompile your model for every different input shape it sees\n\nThis is the big one. What this means is that if your input shapes are very variable, XLA will have to recompile your model over and over, which will create huge performance problems. This commonly arises in NLP models, where input texts have variable lengths after tokenization. In other modalities, static shapes are more common and this rule is much less of a problem.\n\nHow can you get around rule #3? The key is **padding** - if you pad all your inputs to the same length, and then use an `attention_mask`, you can get the same results as you\u2019d get from variable shapes, but without any XLA issues. However, excessive padding can cause severe slowdown too - if you pad all your samples to the maximum length in the whole dataset, you might end up with batches consisting endless padding tokens, which will waste a lot of compute and memory!\n\nThere isn\u2019t a perfect solution to this problem. However, you can try some tricks. One very useful trick is to **pad batches of samples up to a multiple of a number like 32 or 64 tokens.** This often only increases the number of tokens by a small amount, but it hugely reduces the number of unique input shapes, because every input shape now has to be a multiple of 32 or 64. Fewer unique input shapes means fewer XLA compilations!\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** Our tokenizers and data collators have methods that can help you here. You can use `padding=\"max_length\"` or `padding=\"longest\"` when calling tokenizers to get them to output padded data. Our tokenizers and data collators also have a `pad_to_multiple_of` argument that you can use to reduce the number of unique input shapes you see!\n\n</Tip>\n\n### How do I actually train my model on TPU?\n\nOnce your training is XLA-compatible and (if you\u2019re using TPU Node / Colab) your dataset has been prepared appropriately, running on TPU is surprisingly easy! All you really need to change in your code is to add a few lines to initialize your TPU, and to ensure that your model and dataset are created inside a `TPUStrategy` scope. Take a look at [our TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) to see this in action!\n\n### Summary\n\nThere was a lot in here, so let\u2019s summarize with a quick checklist you can follow when you want to get your model ready for TPU training:\n\n- Make sure your code follows the three rules of XLA\n- Compile your model with `jit_compile=True` on CPU/GPU and confirm that you can train it with XLA\n- Either load your dataset into memory or use a TPU-compatible dataset loading approach (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Migrate your code either to Colab (with accelerator set to \u201cTPU\u201d) or a TPU VM on Google Cloud\n- Add TPU initializer code (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Create your `TPUStrategy` and make sure dataset loading and model creation are inside the `strategy.scope()` (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Don\u2019t forget to take `jit_compile=True` out again when you move to TPU!\n- \ud83d\ude4f\ud83d\ude4f\ud83d\ude4f\ud83e\udd7a\ud83e\udd7a\ud83e\udd7a\n- Call model.fit()\n- You did it!"
        }
    },
    {
        "context": "!--Copyright 2023 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\nthe License. You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under the License is distributed on\nan \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n\n\u26a0\ufe0f Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be\nrendered properly in your Markdown viewer.\n\n-->\n\n# Training on TPU with TensorFlow\n\n<Tip>\n\nIf you don't need long explanations and just want TPU code samples to get started with, check out [our TPU example notebook!](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb)\n\n</Tip>\n\n### What is a TPU?\n\nA TPU is a **Tensor Processing Unit.** They are hardware designed by Google, which are used to greatly speed up the tensor computations within neural networks, much like GPUs. They can be used for both network training and inference. They are generally accessed through Google\u2019s cloud services, but small TPUs can also be accessed directly for free through Google Colab and Kaggle Kernels.\n\nBecause [all TensorFlow models in \ud83e\udd17 Transformers are Keras models](https://huggingface.co/blog/tensorflow-philosophy), most of the methods in this document are generally applicable to TPU training for any Keras model! However, there are a few points that are specific to the HuggingFace ecosystem (hug-o-system?) of Transformers and Datasets, and we\u2019ll make sure to flag them up when we get to them.\n\n### What kinds of TPU are available?\n\nNew users are often very confused by the range of TPUs, and the different ways to access them. The first key distinction to understand is the difference between **TPU Nodes** and **TPU VMs.**",
        "question": "What kind of models are all TensorFlow models in \ud83e\udd17 Transformers?",
        "answer": "All TensorFlow models in \ud83e\udd17 Transformers are Keras models.",
        "source_doc": "huggingface/transformers/blob/main/docs/source/en/perf_train_tpu_tf.md",
        "rag_answer": null,
        "rag_context": null,
        "rag_score": null,
        "rag_feedback": null
    },
    {
        "sample_idx": 42,
        "question": "What is the distinction between TPU Nodes and TPU VMs?",
        "answer": "The first key distinction to understand is the difference between TPU Nodes and TPU VMs.",
        "rag_answer": "According to the provided text, the distinction between TPU Nodes and TPU VMs is as follows:\n\n**TPU Nodes:**\n\n* You are effectively indirectly accessing a remote TPU.\n* You need a separate VM, which will initialize your network and data pipeline and then forward them to the remote node.\n* When you use a TPU on Google Colab, you are accessing it in the TPU Node style.\n* Your data cannot be local to your machine; it must be stored in Google Cloud Storage where your data pipeline can still access it, even when the pipeline is running on the remote TPU node.\n\n**TPU VMs:**\n\n* You connect directly to the machine that the TPU is attached to, much like training on a GPU VM.\n",
        "rag_score": null,
        "rag_feedback": null,
        "rag_context": {
            "kg_context": "-----Entities-----\n    ```csv\n    id,\tentity,\ttype,\tdescription,\trankcreated_at\n1,\tGoogle,organization,Google is the company that designs and provides TPUs, which are used to speed up tensor computations within neural networks.,3,2025-03-24 13:18:20\n2,\tTPU,technology,TPU is a Tensor Processing Unit, a hardware designed by Google to speed up tensor computations within neural networks.<SEP>TPU is a type of hardware accelerator designed for machine learning workloads.<SEP>TPU is a type of hardware accelerator used for machine learning computations.,4,2025-03-24 13:18:20\n3,\tColab,geo,Colab is a cloud-based platform for data science and machine learning, provided by Google.<SEP>Colab is a platform where users can access a free TPU.,3,2025-03-24 13:18:20\n4,\tGoogle Cloud,organization,Google Cloud is a cloud computing platform that provides infrastructure and services for building and deploying machine learning models.,1,2025-03-24 13:18:20\n5,\tTPU,technology,TPU is a Tensor Processing Unit, a hardware designed by Google to speed up tensor computations within neural networks.<SEP>TPU is a type of hardware accelerator designed for machine learning workloads.<SEP>TPU is a type of hardware accelerator used for machine learning computations.,4,UNKNOWN\n6,\tv3-32 TPU,category,v3-32 TPU is a type of TPU, a hardware designed by Google to speed up tensor computations within neural networks.,0,UNKNOWN\n7,\tTPUv4,category,TPUv4 is a type of TPU, a hardware designed by Google to speed up tensor computations within neural networks.,0,UNKNOWN\n    ```\n    -----Relationships-----\n    ```csv\n    id,\tsource,\ttarget,\tdescription,\tkeywords,\tweight,\trank,\tcreated_at\n1,\tGoogle,TPU,Google designs and provides TPUs, which are used to speed up tensor computations within neural networks.,hardware design, acceleration,18.0,7,2025-03-24 13:18:20\n2,\tColab,TPU,Colab provides access to a free TPU for users.,platform, hardware acceleration,16.0,7,2025-03-24 13:18:20\n3,\tGoogle Cloud,TPU,Google Cloud provides infrastructure and services for building and deploying machine learning models, including TPU hardware.,infrastructure provision, hardware acceleration,14.0,5,2025-03-24 13:18:20\n4,\tTPU,XLA,XLA compiles TensorFlow graphs into executable code for TPU hardware.<SEP>XLA is used to optimize code for TPU hardware.,compilation, hardware acceleration<SEP>compiler, hardware optimization,36.0,10,UNKNOWN\n5,\tGoogle,TPU,Google designs and provides TPUs, which are used to speed up tensor computations within neural networks.,hardware design, acceleration,18.0,7,UNKNOWN\n6,\tColab,TPU,Colab provides access to a free TPU for users.,platform, hardware acceleration,16.0,7,UNKNOWN\n7,\tGoogle Cloud,TPU,Google Cloud provides infrastructure and services for building and deploying machine learning models, including TPU hardware.,infrastructure provision, hardware acceleration,14.0,5,UNKNOWN\n    ```\n    -----Sources-----\n    ```csv\n    id,\tcontent\n1,\t!--Copyright 2023 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\nthe License. You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under the License is distributed on\nan \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n\n\u26a0\ufe0f Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be\nrendered properly in your Markdown viewer.\n\n-->\n\n# Training on TPU with TensorFlow\n\n<Tip>\n\nIf you don't need long explanations and just want TPU code samples to get started with, check out [our TPU example notebook!](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb)\n\n</Tip>\n\n### What is a TPU?\n\nA TPU is a **Tensor Processing Unit.** They are hardware designed by Google, which are used to greatly speed up the tensor computations within neural networks, much like GPUs. They can be used for both network training and inference. They are generally accessed through Google\u2019s cloud services, but small TPUs can also be accessed directly for free through Google Colab and Kaggle Kernels.\n\nBecause [all TensorFlow models in \ud83e\udd17 Transformers are Keras models](https://huggingface.co/blog/tensorflow-philosophy), most of the methods in this document are generally applicable to TPU training for any Keras model! However, there are a few points that are specific to the HuggingFace ecosystem (hug-o-system?) of Transformers and Datasets, and we\u2019ll make sure to flag them up when we get to them.\n\n### What kinds of TPU are available?\n\nNew users are often very confused by the range of TPUs, and the different ways to access them. The first key distinction to understand is the difference between **TPU Nodes** and **TPU VMs.**\n\nWhen you use a **TPU Node**, you are effectively indirectly accessing a remote TPU. You will need a separate VM, which will initialize your network and data pipeline and then forward them to the remote node. When you use a TPU on Google Colab, you are accessing it in the **TPU Node** style.\n\nUsing TPU Nodes can have some quite unexpected behaviour for people who aren\u2019t used to them! In particular, because the TPU is located on a physically different system to the machine you\u2019re running your Python code on, your data cannot be local to your machine - any data pipeline that loads from your machine\u2019s internal storage will totally fail! Instead, data must be stored in Google Cloud Storage where your data pipeline can still access it, even when the pipeline is running on the remote TPU node.\n\n<Tip>\n\nIf you can fit all your data in memory as `np.ndarray` or `tf.Tensor`, then you can `fit()` on that data even when using Colab or a TPU Node, without needing to upload it to Google Cloud Storage.\n\n</Tip>\n\n<Tip>\n\n**\ud83e\udd17Specific Hugging Face Tip\ud83e\udd17:** The methods `Dataset.to_tf_dataset()` and its higher-level wrapper `model.prepare_tf_dataset()` , which you will see throughout our TF code examples, will both fail on a TPU Node. The reason for this is that even though they create a `tf.data.Dataset` it is not a \u201cpure\u201d `tf.data` pipeline and uses `tf.numpy_function` or `Dataset.from_generator()` to stream data from the underlying HuggingFace `Dataset`. This HuggingFace `Dataset` is backed by data that is on a local disc and which the remote TPU Node will not be able to read.\n\n</Tip>\n\nThe second way to access a TPU is via a **TPU VM.** When using a TPU VM, you connect directly to the machine that the TPU is attached to, much like training on a GPU VM. TPU VMs are generally easier to work with, particularly when it comes to your data pipeline. All of the above warnings do not apply to TPU VMs!\n\nThis is an opinionated document, so here\u2019s our opinion: **Avoid using TPU Node if possible.** It is more confusing and more difficult to debug than TPU VMs. It is also likely to be unsupported in future - Google\u2019s latest TPU, TPUv4, can only be accessed as a TPU VM, which suggests that TPU Nodes are increasingly going to become a \u201clegacy\u201d access method. However, we understand that the only free TPU access is on Colab and Kaggle Kernels, which uses TPU Node - so we\u2019ll try to explain how to handle it if you have to! Check the [TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) for code samples that explain this in more detail.\n\n### What sizes of TPU are available?\n\nA single TPU (a v2-8/v3-8/v4-8) runs 8 replicas. TPUs exist in **pods** that can run hundreds or thousands of replicas simultaneously. When you use more than a single TPU but less than a whole pod (for example, a v3-32), your TPU fleet is referred to as a **pod slice.**\n\nWhen you access a free TPU via Colab, you generally get a single v2-8 TPU.\n\n### I keep hearing about this XLA thing. What\u2019s XLA, and how does it relate to TPUs?\n\nXLA is an optimizing compiler, used by both TensorFlow and JAX. In JAX it is the only compiler, whereas in TensorFlow it is optional\n2,\t(for example, a v3-32), your TPU fleet is referred to as a **pod slice.**\n\nWhen you access a free TPU via Colab, you generally get a single v2-8 TPU.\n\n### I keep hearing about this XLA thing. What\u2019s XLA, and how does it relate to TPUs?\n\nXLA is an optimizing compiler, used by both TensorFlow and JAX. In JAX it is the only compiler, whereas in TensorFlow it is optional (but mandatory on TPU!). The easiest way to enable it when training a Keras model is to pass the argument `jit_compile=True` to `model.compile()`. If you don\u2019t get any errors and performance is good, that\u2019s a great sign that you\u2019re ready to move to TPU!\n\nDebugging on TPU is generally a bit harder than on CPU/GPU, so we recommend getting your code running on CPU/GPU with XLA first before trying it on TPU. You don\u2019t have to train for long, of course - just for a few steps to make sure that your model and data pipeline are working like you expect them to.\n\n<Tip>\n\nXLA compiled code is usually faster - so even if you\u2019re not planning to run on TPU, adding `jit_compile=True` can improve your performance. Be sure to note the caveats below about XLA compatibility, though!\n\n</Tip>\n\n<Tip warning={true}>\n\n**Tip born of painful experience:** Although using `jit_compile=True` is a good way to get a speed boost and test if your CPU/GPU code is XLA-compatible, it can actually cause a lot of problems if you leave it in when actually training on TPU. XLA compilation will happen implicitly on TPU, so remember to remove that line before actually running your code on a TPU!\n\n</Tip>\n\n### How do I make my model XLA compatible?\n\nIn many cases, your code is probably XLA-compatible already! However, there are a few things that work in normal TensorFlow that don\u2019t work in XLA. We\u2019ve distilled them into three core rules below:\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** We\u2019ve put a lot of effort into rewriting our TensorFlow models and loss functions to be XLA-compatible. Our models and loss functions generally obey rule #1 and #2 by default, so you can skip over them if you\u2019re using `transformers` models. Don\u2019t forget about these rules when writing your own models and loss functions, though!\n\n</Tip>\n\n#### XLA Rule #1: Your code cannot have \u201cdata-dependent conditionals\u201d\n\nWhat that means is that any `if` statement cannot depend on values inside a `tf.Tensor`. For example, this code block cannot be compiled with XLA!\n\n```python\nif tf.reduce_sum(tensor) > 10:\n    tensor = tensor / 2.0\n```\n\nThis might seem very restrictive at first, but most neural net code doesn\u2019t need to do this. You can often get around this restriction by using `tf.cond` (see the documentation [here](https://www.tensorflow.org/api_docs/python/tf/cond)) or by removing the conditional and finding a clever math trick with indicator variables instead, like so:\n\n```python\nsum_over_10 = tf.cast(tf.reduce_sum(tensor) > 10, tf.float32)\ntensor = tensor / (1.0 + sum_over_10)\n```\n\nThis code has exactly the same effect as the code above, but by avoiding a conditional, we ensure it will compile with XLA without problems!\n\n#### XLA Rule #2: Your code cannot have \u201cdata-dependent shapes\u201d\n\nWhat this means is that the shape of all of the `tf.Tensor` objects in your code cannot depend on their values. For example, the function `tf.unique` cannot be compiled with XLA, because it returns a `tensor` containing one instance of each unique value in the input. The shape of this output will obviously be different depending on how repetitive the input `Tensor` was, and so XLA refuses to handle it!\n\nIn general, most neural network code obeys rule #2 by default. However, there are a few common cases where it becomes a problem. One very common one is when you use **label masking**, setting your labels to a negative value to indicate that those positions should be ignored when computing the loss. If you look at NumPy or PyTorch loss functions that support label masking, you will often see code like this that uses [boolean indexing](https://numpy.org/doc/stable/user/basics.indexing.html#boolean-array-indexing):\n\n```python\nlabel_mask = labels >= 0\nmasked_outputs = outputs[label_mask]\nmasked_labels = labels[label_mask]\nloss = compute_loss(masked_outputs, masked_labels)\nmean_loss = torch.mean(loss)\n```\n\nThis code is totally fine in NumPy or PyTorch, but it breaks in XLA! Why? Because the shape of `masked_outputs` and `masked_labels` depends on how many positions are masked - that makes it a **data-dependent shape.** However, just like for rule #1, we can often rewrite this code to yield exactly the same output without any data-dependent shapes.\n\n```python\nlabel_mask = tf.cast(labels >= 0, tf.float32)\nloss = compute_loss(outputs, labels)\nloss = loss * label_mask  # Set negative label positions to 0\nmean_loss = tf.reduce_sum(loss) / tf.reduce_sum(label_mask)\n```\n\nHere, we avoid data-dependent shapes by computing the loss for every position, but zeroing out the masked positions in both the numerator and denominator when we calculate the mean, which yields exactly the same result as the first block while maintaining XLA compatibility. Note that we use the same trick as in rule #1 - converting a `tf.bool` to `\n3,\tlabel_mask  # Set negative label positions to 0\nmean_loss = tf.reduce_sum(loss) / tf.reduce_sum(label_mask)\n```\n\nHere, we avoid data-dependent shapes by computing the loss for every position, but zeroing out the masked positions in both the numerator and denominator when we calculate the mean, which yields exactly the same result as the first block while maintaining XLA compatibility. Note that we use the same trick as in rule #1 - converting a `tf.bool` to `tf.float32` and using it as an indicator variable. This is a really useful trick, so remember it if you need to convert your own code to XLA!\n\n#### XLA Rule #3: XLA will need to recompile your model for every different input shape it sees\n\nThis is the big one. What this means is that if your input shapes are very variable, XLA will have to recompile your model over and over, which will create huge performance problems. This commonly arises in NLP models, where input texts have variable lengths after tokenization. In other modalities, static shapes are more common and this rule is much less of a problem.\n\nHow can you get around rule #3? The key is **padding** - if you pad all your inputs to the same length, and then use an `attention_mask`, you can get the same results as you\u2019d get from variable shapes, but without any XLA issues. However, excessive padding can cause severe slowdown too - if you pad all your samples to the maximum length in the whole dataset, you might end up with batches consisting endless padding tokens, which will waste a lot of compute and memory!\n\nThere isn\u2019t a perfect solution to this problem. However, you can try some tricks. One very useful trick is to **pad batches of samples up to a multiple of a number like 32 or 64 tokens.** This often only increases the number of tokens by a small amount, but it hugely reduces the number of unique input shapes, because every input shape now has to be a multiple of 32 or 64. Fewer unique input shapes means fewer XLA compilations!\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** Our tokenizers and data collators have methods that can help you here. You can use `padding=\"max_length\"` or `padding=\"longest\"` when calling tokenizers to get them to output padded data. Our tokenizers and data collators also have a `pad_to_multiple_of` argument that you can use to reduce the number of unique input shapes you see!\n\n</Tip>\n\n### How do I actually train my model on TPU?\n\nOnce your training is XLA-compatible and (if you\u2019re using TPU Node / Colab) your dataset has been prepared appropriately, running on TPU is surprisingly easy! All you really need to change in your code is to add a few lines to initialize your TPU, and to ensure that your model and dataset are created inside a `TPUStrategy` scope. Take a look at [our TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) to see this in action!\n\n### Summary\n\nThere was a lot in here, so let\u2019s summarize with a quick checklist you can follow when you want to get your model ready for TPU training:\n\n- Make sure your code follows the three rules of XLA\n- Compile your model with `jit_compile=True` on CPU/GPU and confirm that you can train it with XLA\n- Either load your dataset into memory or use a TPU-compatible dataset loading approach (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Migrate your code either to Colab (with accelerator set to \u201cTPU\u201d) or a TPU VM on Google Cloud\n- Add TPU initializer code (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Create your `TPUStrategy` and make sure dataset loading and model creation are inside the `strategy.scope()` (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Don\u2019t forget to take `jit_compile=True` out again when you move to TPU!\n- \ud83d\ude4f\ud83d\ude4f\ud83d\ude4f\ud83e\udd7a\ud83e\udd7a\ud83e\udd7a\n- Call model.fit()\n- You did it!\n    ```",
            "vector_context": "[Created at: 2025-03-24 13:17:32]\n!--Copyright 2023 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\nthe License. You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under the License is distributed on\nan \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n\n\u26a0\ufe0f Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be\nrendered properly in your Markdown viewer.\n\n-->\n\n# Training on TPU with TensorFlow\n\n<Tip>\n\nIf you don't need long explanations and just want TPU code samples to get started with, check out [our TPU example notebook!](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb)\n\n</Tip>\n\n### What is a TPU?\n\nA TPU is a **Tensor Processing Unit.** They are hardware designed by Google, which are used to greatly speed up the tensor computations within neural networks, much like GPUs. They can be used for both network training and inference. They are generally accessed through Google\u2019s cloud services, but small TPUs can also be accessed directly for free through Google Colab and Kaggle Kernels.\n\nBecause [all TensorFlow models in \ud83e\udd17 Transformers are Keras models](https://huggingface.co/blog/tensorflow-philosophy), most of the methods in this document are generally applicable to TPU training for any Keras model! However, there are a few points that are specific to the HuggingFace ecosystem (hug-o-system?) of Transformers and Datasets, and we\u2019ll make sure to flag them up when we get to them.\n\n### What kinds of TPU are available?\n\nNew users are often very confused by the range of TPUs, and the different ways to access them. The first key distinction to understand is the difference between **TPU Nodes** and **TPU VMs.**\n\nWhen you use a **TPU Node**, you are effectively indirectly accessing a remote TPU. You will need a separate VM, which will initialize your network and data pipeline and then forward them to the remote node. When you use a TPU on Google Colab, you are accessing it in the **TPU Node** style.\n\nUsing TPU Nodes can have some quite unexpected behaviour for people who aren\u2019t used to them! In particular, because the TPU is located on a physically different system to the machine you\u2019re running your Python code on, your data cannot be local to your machine - any data pipeline that loads from your machine\u2019s internal storage will totally fail! Instead, data must be stored in Google Cloud Storage where your data pipeline can still access it, even when the pipeline is running on the remote TPU node.\n\n<Tip>\n\nIf you can fit all your data in memory as `np.ndarray` or `tf.Tensor`, then you can `fit()` on that data even when using Colab or a TPU Node, without needing to upload it to Google Cloud Storage.\n\n</Tip>\n\n<Tip>\n\n**\ud83e\udd17Specific Hugging Face Tip\ud83e\udd17:** The methods `Dataset.to_tf_dataset()` and its higher-level wrapper `model.prepare_tf_dataset()` , which you will see throughout our TF code examples, will both fail on a TPU Node. The reason for this is that even though they create a `tf.data.Dataset` it is not a \u201cpure\u201d `tf.data` pipeline and uses `tf.numpy_function` or `Dataset.from_generator()` to stream data from the underlying HuggingFace `Dataset`. This HuggingFace `Dataset` is backed by data that is on a local disc and which the remote TPU Node will not be able to read.\n\n</Tip>\n\nThe second way to access a TPU is via a **TPU VM.** When using a TPU VM, you connect directly to the machine that the TPU is attached to, much like training on a GPU VM. TPU VMs are generally easier to work with, particularly when it comes to your data pipeline. All of the above warnings do not apply to TPU VMs!\n\nThis is an opinionated document, so here\u2019s our opinion: **Avoid using TPU Node if possible.** It is more confusing and more difficult to debug than TPU VMs. It is also likely to be unsupported in future - Google\u2019s latest TPU, TPUv4, can only be accessed as a TPU VM, which suggests that TPU Nodes are increasingly going to become a \u201clegacy\u201d access method. However, we understand that the only free TPU access is on Colab and Kaggle Kernels, which uses TPU Node - so we\u2019ll try to explain how to handle it if you have to! Check the [TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) for code samples that explain this in more detail.\n\n### What sizes of TPU are available?\n\nA single TPU (a v2-8/v3-8/v4-8) runs 8 replicas. TPUs exist in **pods** that can run hundreds or thousands of replicas simultaneously. When you use more than a single TPU but less than a whole pod (for example, a v3-32), your TPU fleet is referred to as a **pod slice.**\n\nWhen you access a free TPU via Colab, you generally get a single v2-8 TPU.\n\n### I keep hearing about this XLA thing. What\u2019s XLA, and how does it relate to TPUs?\n\nXLA is an optimizing compiler, used by both TensorFlow and JAX. In JAX it is the only compiler, whereas in TensorFlow it is optional\n--New Chunk--\n[Created at: 2025-03-24 13:17:32]\n(for example, a v3-32), your TPU fleet is referred to as a **pod slice.**\n\nWhen you access a free TPU via Colab, you generally get a single v2-8 TPU.\n\n### I keep hearing about this XLA thing. What\u2019s XLA, and how does it relate to TPUs?\n\nXLA is an optimizing compiler, used by both TensorFlow and JAX. In JAX it is the only compiler, whereas in TensorFlow it is optional (but mandatory on TPU!). The easiest way to enable it when training a Keras model is to pass the argument `jit_compile=True` to `model.compile()`. If you don\u2019t get any errors and performance is good, that\u2019s a great sign that you\u2019re ready to move to TPU!\n\nDebugging on TPU is generally a bit harder than on CPU/GPU, so we recommend getting your code running on CPU/GPU with XLA first before trying it on TPU. You don\u2019t have to train for long, of course - just for a few steps to make sure that your model and data pipeline are working like you expect them to.\n\n<Tip>\n\nXLA compiled code is usually faster - so even if you\u2019re not planning to run on TPU, adding `jit_compile=True` can improve your performance. Be sure to note the caveats below about XLA compatibility, though!\n\n</Tip>\n\n<Tip warning={true}>\n\n**Tip born of painful experience:** Although using `jit_compile=True` is a good way to get a speed boost and test if your CPU/GPU code is XLA-compatible, it can actually cause a lot of problems if you leave it in when actually training on TPU. XLA compilation will happen implicitly on TPU, so remember to remove that line before actually running your code on a TPU!\n\n</Tip>\n\n### How do I make my model XLA compatible?\n\nIn many cases, your code is probably XLA-compatible already! However, there are a few things that work in normal TensorFlow that don\u2019t work in XLA. We\u2019ve distilled them into three core rules below:\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** We\u2019ve put a lot of effort into rewriting our TensorFlow models and loss functions to be XLA-compatible. Our models and loss functions generally obey rule #1 and #2 by default, so you can skip over them if you\u2019re using `transformers` models. Don\u2019t forget about these rules when writing your own models and loss functions, though!\n\n</Tip>\n\n#### XLA Rule #1: Your code cannot have \u201cdata-dependent conditionals\u201d\n\nWhat that means is that any `if` statement cannot depend on values inside a `tf.Tensor`. For example, this code block cannot be compiled with XLA!\n\n```python\nif tf.reduce_sum(tensor) > 10:\n    tensor = tensor / 2.0\n```\n\nThis might seem very restrictive at first, but most neural net code doesn\u2019t need to do this. You can often get around this restriction by using `tf.cond` (see the documentation [here](https://www.tensorflow.org/api_docs/python/tf/cond)) or by removing the conditional and finding a clever math trick with indicator variables instead, like so:\n\n```python\nsum_over_10 = tf.cast(tf.reduce_sum(tensor) > 10, tf.float32)\ntensor = tensor / (1.0 + sum_over_10)\n```\n\nThis code has exactly the same effect as the code above, but by avoiding a conditional, we ensure it will compile with XLA without problems!\n\n#### XLA Rule #2: Your code cannot have \u201cdata-dependent shapes\u201d\n\nWhat this means is that the shape of all of the `tf.Tensor` objects in your code cannot depend on their values. For example, the function `tf.unique` cannot be compiled with XLA, because it returns a `tensor` containing one instance of each unique value in the input. The shape of this output will obviously be different depending on how repetitive the input `Tensor` was, and so XLA refuses to handle it!\n\nIn general, most neural network code obeys rule #2 by default. However, there are a few common cases where it becomes a problem. One very common one is when you use **label masking**, setting your labels to a negative value to indicate that those positions should be ignored when computing the loss. If you look at NumPy or PyTorch loss functions that support label masking, you will often see code like this that uses [boolean indexing](https://numpy.org/doc/stable/user/basics.indexing.html#boolean-array-indexing):\n\n```python\nlabel_mask = labels >= 0\nmasked_outputs = outputs[label_mask]\nmasked_labels = labels[label_mask]\nloss = compute_loss(masked_outputs, masked_labels)\nmean_loss = torch.mean(loss)\n```\n\nThis code is totally fine in NumPy or PyTorch, but it breaks in XLA! Why? Because the shape of `masked_outputs` and `masked_labels` depends on how many positions are masked - that makes it a **data-dependent shape.** However, just like for rule #1, we can often rewrite this code to yield exactly the same output without any data-dependent shapes.\n\n```python\nlabel_mask = tf.cast(labels >= 0, tf.float32)\nloss = compute_loss(outputs, labels)\nloss = loss * label_mask  # Set negative label positions to 0\nmean_loss = tf.reduce_sum(loss) / tf.reduce_sum(label_mask)\n```\n\nHere, we avoid data-dependent shapes by computing the loss for every position, but zeroing out the masked positions in both the numerator and denominator when we calculate the mean, which yields exactly the same result as the first block while maintaining XLA compatibility. Note that we use the same trick as in rule #1 - converting a `tf.bool` to `\n--New Chunk--\n[Created at: 2025-03-24 13:17:32]\nlabel_mask  # Set negative label positions to 0\nmean_loss = tf.reduce_sum(loss) / tf.reduce_sum(label_mask)\n```\n\nHere, we avoid data-dependent shapes by computing the loss for every position, but zeroing out the masked positions in both the numerator and denominator when we calculate the mean, which yields exactly the same result as the first block while maintaining XLA compatibility. Note that we use the same trick as in rule #1 - converting a `tf.bool` to `tf.float32` and using it as an indicator variable. This is a really useful trick, so remember it if you need to convert your own code to XLA!\n\n#### XLA Rule #3: XLA will need to recompile your model for every different input shape it sees\n\nThis is the big one. What this means is that if your input shapes are very variable, XLA will have to recompile your model over and over, which will create huge performance problems. This commonly arises in NLP models, where input texts have variable lengths after tokenization. In other modalities, static shapes are more common and this rule is much less of a problem.\n\nHow can you get around rule #3? The key is **padding** - if you pad all your inputs to the same length, and then use an `attention_mask`, you can get the same results as you\u2019d get from variable shapes, but without any XLA issues. However, excessive padding can cause severe slowdown too - if you pad all your samples to the maximum length in the whole dataset, you might end up with batches consisting endless padding tokens, which will waste a lot of compute and memory!\n\nThere isn\u2019t a perfect solution to this problem. However, you can try some tricks. One very useful trick is to **pad batches of samples up to a multiple of a number like 32 or 64 tokens.** This often only increases the number of tokens by a small amount, but it hugely reduces the number of unique input shapes, because every input shape now has to be a multiple of 32 or 64. Fewer unique input shapes means fewer XLA compilations!\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** Our tokenizers and data collators have methods that can help you here. You can use `padding=\"max_length\"` or `padding=\"longest\"` when calling tokenizers to get them to output padded data. Our tokenizers and data collators also have a `pad_to_multiple_of` argument that you can use to reduce the number of unique input shapes you see!\n\n</Tip>\n\n### How do I actually train my model on TPU?\n\nOnce your training is XLA-compatible and (if you\u2019re using TPU Node / Colab) your dataset has been prepared appropriately, running on TPU is surprisingly easy! All you really need to change in your code is to add a few lines to initialize your TPU, and to ensure that your model and dataset are created inside a `TPUStrategy` scope. Take a look at [our TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) to see this in action!\n\n### Summary\n\nThere was a lot in here, so let\u2019s summarize with a quick checklist you can follow when you want to get your model ready for TPU training:\n\n- Make sure your code follows the three rules of XLA\n- Compile your model with `jit_compile=True` on CPU/GPU and confirm that you can train it with XLA\n- Either load your dataset into memory or use a TPU-compatible dataset loading approach (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Migrate your code either to Colab (with accelerator set to \u201cTPU\u201d) or a TPU VM on Google Cloud\n- Add TPU initializer code (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Create your `TPUStrategy` and make sure dataset loading and model creation are inside the `strategy.scope()` (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Don\u2019t forget to take `jit_compile=True` out again when you move to TPU!\n- \ud83d\ude4f\ud83d\ude4f\ud83d\ude4f\ud83e\udd7a\ud83e\udd7a\ud83e\udd7a\n- Call model.fit()\n- You did it!"
        }
    },
    {
        "sample_idx": 43,
        "question": "What is the difference between TPU Nodes and TPU VMs?",
        "answer": "TPU Nodes allow indirect access to a remote TPU, requiring a separate VM to initialize the network and data pipeline, whereas TPU VMs are not explained in the passage.",
        "rag_answer": "According to the provided Data Sources, the main difference between TPU Nodes and TPU VMs is how they access the TPU hardware.\n\n**TPU Nodes**: When you use a TPU Node, you are effectively indirectly accessing a remote TPU. You will need a separate VM, which will initialize your network and data pipeline and then forward them to the remote node. For example, when you use a TPU on Google Colab, you are accessing it in the TPU Node style.\n\n**TPU VMs**: When using a TPU VM, you connect directly to the machine that the TPU is attached to, much like training on a GPU VM. TPU VMs are generally easier to work with, particularly when it comes to your data pipeline.",
        "rag_score": null,
        "rag_feedback": null,
        "rag_context": {
            "kg_context": "-----Entities-----\n    ```csv\n    id,\tentity,\ttype,\tdescription,\trankcreated_at\n1,\tGoogle,organization,Google is the company that designs and provides TPUs, which are used to speed up tensor computations within neural networks.,3,2025-03-24 13:18:20\n2,\tTPU,technology,TPU is a Tensor Processing Unit, a hardware designed by Google to speed up tensor computations within neural networks.<SEP>TPU is a type of hardware accelerator designed for machine learning workloads.<SEP>TPU is a type of hardware accelerator used for machine learning computations.,4,2025-03-24 13:18:20\n3,\tColab,geo,Colab is a cloud-based platform for data science and machine learning, provided by Google.<SEP>Colab is a platform where users can access a free TPU.,3,2025-03-24 13:18:20\n4,\tGoogle Cloud,organization,Google Cloud is a cloud computing platform that provides infrastructure and services for building and deploying machine learning models.,1,2025-03-24 13:18:20\n5,\tTPU,technology,TPU is a Tensor Processing Unit, a hardware designed by Google to speed up tensor computations within neural networks.<SEP>TPU is a type of hardware accelerator designed for machine learning workloads.<SEP>TPU is a type of hardware accelerator used for machine learning computations.,4,UNKNOWN\n6,\tTPUv4,category,TPUv4 is a type of TPU, a hardware designed by Google to speed up tensor computations within neural networks.,0,UNKNOWN\n7,\tv3-32 TPU,category,v3-32 TPU is a type of TPU, a hardware designed by Google to speed up tensor computations within neural networks.,0,UNKNOWN\n    ```\n    -----Relationships-----\n    ```csv\n    id,\tsource,\ttarget,\tdescription,\tkeywords,\tweight,\trank,\tcreated_at\n1,\tGoogle,TPU,Google designs and provides TPUs, which are used to speed up tensor computations within neural networks.,hardware design, acceleration,18.0,7,2025-03-24 13:18:20\n2,\tColab,TPU,Colab provides access to a free TPU for users.,platform, hardware acceleration,16.0,7,2025-03-24 13:18:20\n3,\tGoogle Cloud,TPU,Google Cloud provides infrastructure and services for building and deploying machine learning models, including TPU hardware.,infrastructure provision, hardware acceleration,14.0,5,2025-03-24 13:18:20\n4,\tTPU,XLA,XLA compiles TensorFlow graphs into executable code for TPU hardware.<SEP>XLA is used to optimize code for TPU hardware.,compilation, hardware acceleration<SEP>compiler, hardware optimization,36.0,10,UNKNOWN\n5,\tGoogle,TPU,Google designs and provides TPUs, which are used to speed up tensor computations within neural networks.,hardware design, acceleration,18.0,7,UNKNOWN\n6,\tColab,TPU,Colab provides access to a free TPU for users.,platform, hardware acceleration,16.0,7,UNKNOWN\n7,\tGoogle Cloud,TPU,Google Cloud provides infrastructure and services for building and deploying machine learning models, including TPU hardware.,infrastructure provision, hardware acceleration,14.0,5,UNKNOWN\n    ```\n    -----Sources-----\n    ```csv\n    id,\tcontent\n1,\t!--Copyright 2023 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\nthe License. You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under the License is distributed on\nan \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n\n\u26a0\ufe0f Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be\nrendered properly in your Markdown viewer.\n\n-->\n\n# Training on TPU with TensorFlow\n\n<Tip>\n\nIf you don't need long explanations and just want TPU code samples to get started with, check out [our TPU example notebook!](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb)\n\n</Tip>\n\n### What is a TPU?\n\nA TPU is a **Tensor Processing Unit.** They are hardware designed by Google, which are used to greatly speed up the tensor computations within neural networks, much like GPUs. They can be used for both network training and inference. They are generally accessed through Google\u2019s cloud services, but small TPUs can also be accessed directly for free through Google Colab and Kaggle Kernels.\n\nBecause [all TensorFlow models in \ud83e\udd17 Transformers are Keras models](https://huggingface.co/blog/tensorflow-philosophy), most of the methods in this document are generally applicable to TPU training for any Keras model! However, there are a few points that are specific to the HuggingFace ecosystem (hug-o-system?) of Transformers and Datasets, and we\u2019ll make sure to flag them up when we get to them.\n\n### What kinds of TPU are available?\n\nNew users are often very confused by the range of TPUs, and the different ways to access them. The first key distinction to understand is the difference between **TPU Nodes** and **TPU VMs.**\n\nWhen you use a **TPU Node**, you are effectively indirectly accessing a remote TPU. You will need a separate VM, which will initialize your network and data pipeline and then forward them to the remote node. When you use a TPU on Google Colab, you are accessing it in the **TPU Node** style.\n\nUsing TPU Nodes can have some quite unexpected behaviour for people who aren\u2019t used to them! In particular, because the TPU is located on a physically different system to the machine you\u2019re running your Python code on, your data cannot be local to your machine - any data pipeline that loads from your machine\u2019s internal storage will totally fail! Instead, data must be stored in Google Cloud Storage where your data pipeline can still access it, even when the pipeline is running on the remote TPU node.\n\n<Tip>\n\nIf you can fit all your data in memory as `np.ndarray` or `tf.Tensor`, then you can `fit()` on that data even when using Colab or a TPU Node, without needing to upload it to Google Cloud Storage.\n\n</Tip>\n\n<Tip>\n\n**\ud83e\udd17Specific Hugging Face Tip\ud83e\udd17:** The methods `Dataset.to_tf_dataset()` and its higher-level wrapper `model.prepare_tf_dataset()` , which you will see throughout our TF code examples, will both fail on a TPU Node. The reason for this is that even though they create a `tf.data.Dataset` it is not a \u201cpure\u201d `tf.data` pipeline and uses `tf.numpy_function` or `Dataset.from_generator()` to stream data from the underlying HuggingFace `Dataset`. This HuggingFace `Dataset` is backed by data that is on a local disc and which the remote TPU Node will not be able to read.\n\n</Tip>\n\nThe second way to access a TPU is via a **TPU VM.** When using a TPU VM, you connect directly to the machine that the TPU is attached to, much like training on a GPU VM. TPU VMs are generally easier to work with, particularly when it comes to your data pipeline. All of the above warnings do not apply to TPU VMs!\n\nThis is an opinionated document, so here\u2019s our opinion: **Avoid using TPU Node if possible.** It is more confusing and more difficult to debug than TPU VMs. It is also likely to be unsupported in future - Google\u2019s latest TPU, TPUv4, can only be accessed as a TPU VM, which suggests that TPU Nodes are increasingly going to become a \u201clegacy\u201d access method. However, we understand that the only free TPU access is on Colab and Kaggle Kernels, which uses TPU Node - so we\u2019ll try to explain how to handle it if you have to! Check the [TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) for code samples that explain this in more detail.\n\n### What sizes of TPU are available?\n\nA single TPU (a v2-8/v3-8/v4-8) runs 8 replicas. TPUs exist in **pods** that can run hundreds or thousands of replicas simultaneously. When you use more than a single TPU but less than a whole pod (for example, a v3-32), your TPU fleet is referred to as a **pod slice.**\n\nWhen you access a free TPU via Colab, you generally get a single v2-8 TPU.\n\n### I keep hearing about this XLA thing. What\u2019s XLA, and how does it relate to TPUs?\n\nXLA is an optimizing compiler, used by both TensorFlow and JAX. In JAX it is the only compiler, whereas in TensorFlow it is optional\n2,\t(for example, a v3-32), your TPU fleet is referred to as a **pod slice.**\n\nWhen you access a free TPU via Colab, you generally get a single v2-8 TPU.\n\n### I keep hearing about this XLA thing. What\u2019s XLA, and how does it relate to TPUs?\n\nXLA is an optimizing compiler, used by both TensorFlow and JAX. In JAX it is the only compiler, whereas in TensorFlow it is optional (but mandatory on TPU!). The easiest way to enable it when training a Keras model is to pass the argument `jit_compile=True` to `model.compile()`. If you don\u2019t get any errors and performance is good, that\u2019s a great sign that you\u2019re ready to move to TPU!\n\nDebugging on TPU is generally a bit harder than on CPU/GPU, so we recommend getting your code running on CPU/GPU with XLA first before trying it on TPU. You don\u2019t have to train for long, of course - just for a few steps to make sure that your model and data pipeline are working like you expect them to.\n\n<Tip>\n\nXLA compiled code is usually faster - so even if you\u2019re not planning to run on TPU, adding `jit_compile=True` can improve your performance. Be sure to note the caveats below about XLA compatibility, though!\n\n</Tip>\n\n<Tip warning={true}>\n\n**Tip born of painful experience:** Although using `jit_compile=True` is a good way to get a speed boost and test if your CPU/GPU code is XLA-compatible, it can actually cause a lot of problems if you leave it in when actually training on TPU. XLA compilation will happen implicitly on TPU, so remember to remove that line before actually running your code on a TPU!\n\n</Tip>\n\n### How do I make my model XLA compatible?\n\nIn many cases, your code is probably XLA-compatible already! However, there are a few things that work in normal TensorFlow that don\u2019t work in XLA. We\u2019ve distilled them into three core rules below:\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** We\u2019ve put a lot of effort into rewriting our TensorFlow models and loss functions to be XLA-compatible. Our models and loss functions generally obey rule #1 and #2 by default, so you can skip over them if you\u2019re using `transformers` models. Don\u2019t forget about these rules when writing your own models and loss functions, though!\n\n</Tip>\n\n#### XLA Rule #1: Your code cannot have \u201cdata-dependent conditionals\u201d\n\nWhat that means is that any `if` statement cannot depend on values inside a `tf.Tensor`. For example, this code block cannot be compiled with XLA!\n\n```python\nif tf.reduce_sum(tensor) > 10:\n    tensor = tensor / 2.0\n```\n\nThis might seem very restrictive at first, but most neural net code doesn\u2019t need to do this. You can often get around this restriction by using `tf.cond` (see the documentation [here](https://www.tensorflow.org/api_docs/python/tf/cond)) or by removing the conditional and finding a clever math trick with indicator variables instead, like so:\n\n```python\nsum_over_10 = tf.cast(tf.reduce_sum(tensor) > 10, tf.float32)\ntensor = tensor / (1.0 + sum_over_10)\n```\n\nThis code has exactly the same effect as the code above, but by avoiding a conditional, we ensure it will compile with XLA without problems!\n\n#### XLA Rule #2: Your code cannot have \u201cdata-dependent shapes\u201d\n\nWhat this means is that the shape of all of the `tf.Tensor` objects in your code cannot depend on their values. For example, the function `tf.unique` cannot be compiled with XLA, because it returns a `tensor` containing one instance of each unique value in the input. The shape of this output will obviously be different depending on how repetitive the input `Tensor` was, and so XLA refuses to handle it!\n\nIn general, most neural network code obeys rule #2 by default. However, there are a few common cases where it becomes a problem. One very common one is when you use **label masking**, setting your labels to a negative value to indicate that those positions should be ignored when computing the loss. If you look at NumPy or PyTorch loss functions that support label masking, you will often see code like this that uses [boolean indexing](https://numpy.org/doc/stable/user/basics.indexing.html#boolean-array-indexing):\n\n```python\nlabel_mask = labels >= 0\nmasked_outputs = outputs[label_mask]\nmasked_labels = labels[label_mask]\nloss = compute_loss(masked_outputs, masked_labels)\nmean_loss = torch.mean(loss)\n```\n\nThis code is totally fine in NumPy or PyTorch, but it breaks in XLA! Why? Because the shape of `masked_outputs` and `masked_labels` depends on how many positions are masked - that makes it a **data-dependent shape.** However, just like for rule #1, we can often rewrite this code to yield exactly the same output without any data-dependent shapes.\n\n```python\nlabel_mask = tf.cast(labels >= 0, tf.float32)\nloss = compute_loss(outputs, labels)\nloss = loss * label_mask  # Set negative label positions to 0\nmean_loss = tf.reduce_sum(loss) / tf.reduce_sum(label_mask)\n```\n\nHere, we avoid data-dependent shapes by computing the loss for every position, but zeroing out the masked positions in both the numerator and denominator when we calculate the mean, which yields exactly the same result as the first block while maintaining XLA compatibility. Note that we use the same trick as in rule #1 - converting a `tf.bool` to `\n3,\tlabel_mask  # Set negative label positions to 0\nmean_loss = tf.reduce_sum(loss) / tf.reduce_sum(label_mask)\n```\n\nHere, we avoid data-dependent shapes by computing the loss for every position, but zeroing out the masked positions in both the numerator and denominator when we calculate the mean, which yields exactly the same result as the first block while maintaining XLA compatibility. Note that we use the same trick as in rule #1 - converting a `tf.bool` to `tf.float32` and using it as an indicator variable. This is a really useful trick, so remember it if you need to convert your own code to XLA!\n\n#### XLA Rule #3: XLA will need to recompile your model for every different input shape it sees\n\nThis is the big one. What this means is that if your input shapes are very variable, XLA will have to recompile your model over and over, which will create huge performance problems. This commonly arises in NLP models, where input texts have variable lengths after tokenization. In other modalities, static shapes are more common and this rule is much less of a problem.\n\nHow can you get around rule #3? The key is **padding** - if you pad all your inputs to the same length, and then use an `attention_mask`, you can get the same results as you\u2019d get from variable shapes, but without any XLA issues. However, excessive padding can cause severe slowdown too - if you pad all your samples to the maximum length in the whole dataset, you might end up with batches consisting endless padding tokens, which will waste a lot of compute and memory!\n\nThere isn\u2019t a perfect solution to this problem. However, you can try some tricks. One very useful trick is to **pad batches of samples up to a multiple of a number like 32 or 64 tokens.** This often only increases the number of tokens by a small amount, but it hugely reduces the number of unique input shapes, because every input shape now has to be a multiple of 32 or 64. Fewer unique input shapes means fewer XLA compilations!\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** Our tokenizers and data collators have methods that can help you here. You can use `padding=\"max_length\"` or `padding=\"longest\"` when calling tokenizers to get them to output padded data. Our tokenizers and data collators also have a `pad_to_multiple_of` argument that you can use to reduce the number of unique input shapes you see!\n\n</Tip>\n\n### How do I actually train my model on TPU?\n\nOnce your training is XLA-compatible and (if you\u2019re using TPU Node / Colab) your dataset has been prepared appropriately, running on TPU is surprisingly easy! All you really need to change in your code is to add a few lines to initialize your TPU, and to ensure that your model and dataset are created inside a `TPUStrategy` scope. Take a look at [our TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) to see this in action!\n\n### Summary\n\nThere was a lot in here, so let\u2019s summarize with a quick checklist you can follow when you want to get your model ready for TPU training:\n\n- Make sure your code follows the three rules of XLA\n- Compile your model with `jit_compile=True` on CPU/GPU and confirm that you can train it with XLA\n- Either load your dataset into memory or use a TPU-compatible dataset loading approach (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Migrate your code either to Colab (with accelerator set to \u201cTPU\u201d) or a TPU VM on Google Cloud\n- Add TPU initializer code (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Create your `TPUStrategy` and make sure dataset loading and model creation are inside the `strategy.scope()` (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Don\u2019t forget to take `jit_compile=True` out again when you move to TPU!\n- \ud83d\ude4f\ud83d\ude4f\ud83d\ude4f\ud83e\udd7a\ud83e\udd7a\ud83e\udd7a\n- Call model.fit()\n- You did it!\n    ```",
            "vector_context": "[Created at: 2025-03-24 13:17:32]\n!--Copyright 2023 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\nthe License. You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under the License is distributed on\nan \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n\n\u26a0\ufe0f Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be\nrendered properly in your Markdown viewer.\n\n-->\n\n# Training on TPU with TensorFlow\n\n<Tip>\n\nIf you don't need long explanations and just want TPU code samples to get started with, check out [our TPU example notebook!](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb)\n\n</Tip>\n\n### What is a TPU?\n\nA TPU is a **Tensor Processing Unit.** They are hardware designed by Google, which are used to greatly speed up the tensor computations within neural networks, much like GPUs. They can be used for both network training and inference. They are generally accessed through Google\u2019s cloud services, but small TPUs can also be accessed directly for free through Google Colab and Kaggle Kernels.\n\nBecause [all TensorFlow models in \ud83e\udd17 Transformers are Keras models](https://huggingface.co/blog/tensorflow-philosophy), most of the methods in this document are generally applicable to TPU training for any Keras model! However, there are a few points that are specific to the HuggingFace ecosystem (hug-o-system?) of Transformers and Datasets, and we\u2019ll make sure to flag them up when we get to them.\n\n### What kinds of TPU are available?\n\nNew users are often very confused by the range of TPUs, and the different ways to access them. The first key distinction to understand is the difference between **TPU Nodes** and **TPU VMs.**\n\nWhen you use a **TPU Node**, you are effectively indirectly accessing a remote TPU. You will need a separate VM, which will initialize your network and data pipeline and then forward them to the remote node. When you use a TPU on Google Colab, you are accessing it in the **TPU Node** style.\n\nUsing TPU Nodes can have some quite unexpected behaviour for people who aren\u2019t used to them! In particular, because the TPU is located on a physically different system to the machine you\u2019re running your Python code on, your data cannot be local to your machine - any data pipeline that loads from your machine\u2019s internal storage will totally fail! Instead, data must be stored in Google Cloud Storage where your data pipeline can still access it, even when the pipeline is running on the remote TPU node.\n\n<Tip>\n\nIf you can fit all your data in memory as `np.ndarray` or `tf.Tensor`, then you can `fit()` on that data even when using Colab or a TPU Node, without needing to upload it to Google Cloud Storage.\n\n</Tip>\n\n<Tip>\n\n**\ud83e\udd17Specific Hugging Face Tip\ud83e\udd17:** The methods `Dataset.to_tf_dataset()` and its higher-level wrapper `model.prepare_tf_dataset()` , which you will see throughout our TF code examples, will both fail on a TPU Node. The reason for this is that even though they create a `tf.data.Dataset` it is not a \u201cpure\u201d `tf.data` pipeline and uses `tf.numpy_function` or `Dataset.from_generator()` to stream data from the underlying HuggingFace `Dataset`. This HuggingFace `Dataset` is backed by data that is on a local disc and which the remote TPU Node will not be able to read.\n\n</Tip>\n\nThe second way to access a TPU is via a **TPU VM.** When using a TPU VM, you connect directly to the machine that the TPU is attached to, much like training on a GPU VM. TPU VMs are generally easier to work with, particularly when it comes to your data pipeline. All of the above warnings do not apply to TPU VMs!\n\nThis is an opinionated document, so here\u2019s our opinion: **Avoid using TPU Node if possible.** It is more confusing and more difficult to debug than TPU VMs. It is also likely to be unsupported in future - Google\u2019s latest TPU, TPUv4, can only be accessed as a TPU VM, which suggests that TPU Nodes are increasingly going to become a \u201clegacy\u201d access method. However, we understand that the only free TPU access is on Colab and Kaggle Kernels, which uses TPU Node - so we\u2019ll try to explain how to handle it if you have to! Check the [TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) for code samples that explain this in more detail.\n\n### What sizes of TPU are available?\n\nA single TPU (a v2-8/v3-8/v4-8) runs 8 replicas. TPUs exist in **pods** that can run hundreds or thousands of replicas simultaneously. When you use more than a single TPU but less than a whole pod (for example, a v3-32), your TPU fleet is referred to as a **pod slice.**\n\nWhen you access a free TPU via Colab, you generally get a single v2-8 TPU.\n\n### I keep hearing about this XLA thing. What\u2019s XLA, and how does it relate to TPUs?\n\nXLA is an optimizing compiler, used by both TensorFlow and JAX. In JAX it is the only compiler, whereas in TensorFlow it is optional\n--New Chunk--\n[Created at: 2025-03-24 13:17:32]\n(for example, a v3-32), your TPU fleet is referred to as a **pod slice.**\n\nWhen you access a free TPU via Colab, you generally get a single v2-8 TPU.\n\n### I keep hearing about this XLA thing. What\u2019s XLA, and how does it relate to TPUs?\n\nXLA is an optimizing compiler, used by both TensorFlow and JAX. In JAX it is the only compiler, whereas in TensorFlow it is optional (but mandatory on TPU!). The easiest way to enable it when training a Keras model is to pass the argument `jit_compile=True` to `model.compile()`. If you don\u2019t get any errors and performance is good, that\u2019s a great sign that you\u2019re ready to move to TPU!\n\nDebugging on TPU is generally a bit harder than on CPU/GPU, so we recommend getting your code running on CPU/GPU with XLA first before trying it on TPU. You don\u2019t have to train for long, of course - just for a few steps to make sure that your model and data pipeline are working like you expect them to.\n\n<Tip>\n\nXLA compiled code is usually faster - so even if you\u2019re not planning to run on TPU, adding `jit_compile=True` can improve your performance. Be sure to note the caveats below about XLA compatibility, though!\n\n</Tip>\n\n<Tip warning={true}>\n\n**Tip born of painful experience:** Although using `jit_compile=True` is a good way to get a speed boost and test if your CPU/GPU code is XLA-compatible, it can actually cause a lot of problems if you leave it in when actually training on TPU. XLA compilation will happen implicitly on TPU, so remember to remove that line before actually running your code on a TPU!\n\n</Tip>\n\n### How do I make my model XLA compatible?\n\nIn many cases, your code is probably XLA-compatible already! However, there are a few things that work in normal TensorFlow that don\u2019t work in XLA. We\u2019ve distilled them into three core rules below:\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** We\u2019ve put a lot of effort into rewriting our TensorFlow models and loss functions to be XLA-compatible. Our models and loss functions generally obey rule #1 and #2 by default, so you can skip over them if you\u2019re using `transformers` models. Don\u2019t forget about these rules when writing your own models and loss functions, though!\n\n</Tip>\n\n#### XLA Rule #1: Your code cannot have \u201cdata-dependent conditionals\u201d\n\nWhat that means is that any `if` statement cannot depend on values inside a `tf.Tensor`. For example, this code block cannot be compiled with XLA!\n\n```python\nif tf.reduce_sum(tensor) > 10:\n    tensor = tensor / 2.0\n```\n\nThis might seem very restrictive at first, but most neural net code doesn\u2019t need to do this. You can often get around this restriction by using `tf.cond` (see the documentation [here](https://www.tensorflow.org/api_docs/python/tf/cond)) or by removing the conditional and finding a clever math trick with indicator variables instead, like so:\n\n```python\nsum_over_10 = tf.cast(tf.reduce_sum(tensor) > 10, tf.float32)\ntensor = tensor / (1.0 + sum_over_10)\n```\n\nThis code has exactly the same effect as the code above, but by avoiding a conditional, we ensure it will compile with XLA without problems!\n\n#### XLA Rule #2: Your code cannot have \u201cdata-dependent shapes\u201d\n\nWhat this means is that the shape of all of the `tf.Tensor` objects in your code cannot depend on their values. For example, the function `tf.unique` cannot be compiled with XLA, because it returns a `tensor` containing one instance of each unique value in the input. The shape of this output will obviously be different depending on how repetitive the input `Tensor` was, and so XLA refuses to handle it!\n\nIn general, most neural network code obeys rule #2 by default. However, there are a few common cases where it becomes a problem. One very common one is when you use **label masking**, setting your labels to a negative value to indicate that those positions should be ignored when computing the loss. If you look at NumPy or PyTorch loss functions that support label masking, you will often see code like this that uses [boolean indexing](https://numpy.org/doc/stable/user/basics.indexing.html#boolean-array-indexing):\n\n```python\nlabel_mask = labels >= 0\nmasked_outputs = outputs[label_mask]\nmasked_labels = labels[label_mask]\nloss = compute_loss(masked_outputs, masked_labels)\nmean_loss = torch.mean(loss)\n```\n\nThis code is totally fine in NumPy or PyTorch, but it breaks in XLA! Why? Because the shape of `masked_outputs` and `masked_labels` depends on how many positions are masked - that makes it a **data-dependent shape.** However, just like for rule #1, we can often rewrite this code to yield exactly the same output without any data-dependent shapes.\n\n```python\nlabel_mask = tf.cast(labels >= 0, tf.float32)\nloss = compute_loss(outputs, labels)\nloss = loss * label_mask  # Set negative label positions to 0\nmean_loss = tf.reduce_sum(loss) / tf.reduce_sum(label_mask)\n```\n\nHere, we avoid data-dependent shapes by computing the loss for every position, but zeroing out the masked positions in both the numerator and denominator when we calculate the mean, which yields exactly the same result as the first block while maintaining XLA compatibility. Note that we use the same trick as in rule #1 - converting a `tf.bool` to `\n--New Chunk--\n[Created at: 2025-03-24 13:17:32]\nlabel_mask  # Set negative label positions to 0\nmean_loss = tf.reduce_sum(loss) / tf.reduce_sum(label_mask)\n```\n\nHere, we avoid data-dependent shapes by computing the loss for every position, but zeroing out the masked positions in both the numerator and denominator when we calculate the mean, which yields exactly the same result as the first block while maintaining XLA compatibility. Note that we use the same trick as in rule #1 - converting a `tf.bool` to `tf.float32` and using it as an indicator variable. This is a really useful trick, so remember it if you need to convert your own code to XLA!\n\n#### XLA Rule #3: XLA will need to recompile your model for every different input shape it sees\n\nThis is the big one. What this means is that if your input shapes are very variable, XLA will have to recompile your model over and over, which will create huge performance problems. This commonly arises in NLP models, where input texts have variable lengths after tokenization. In other modalities, static shapes are more common and this rule is much less of a problem.\n\nHow can you get around rule #3? The key is **padding** - if you pad all your inputs to the same length, and then use an `attention_mask`, you can get the same results as you\u2019d get from variable shapes, but without any XLA issues. However, excessive padding can cause severe slowdown too - if you pad all your samples to the maximum length in the whole dataset, you might end up with batches consisting endless padding tokens, which will waste a lot of compute and memory!\n\nThere isn\u2019t a perfect solution to this problem. However, you can try some tricks. One very useful trick is to **pad batches of samples up to a multiple of a number like 32 or 64 tokens.** This often only increases the number of tokens by a small amount, but it hugely reduces the number of unique input shapes, because every input shape now has to be a multiple of 32 or 64. Fewer unique input shapes means fewer XLA compilations!\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** Our tokenizers and data collators have methods that can help you here. You can use `padding=\"max_length\"` or `padding=\"longest\"` when calling tokenizers to get them to output padded data. Our tokenizers and data collators also have a `pad_to_multiple_of` argument that you can use to reduce the number of unique input shapes you see!\n\n</Tip>\n\n### How do I actually train my model on TPU?\n\nOnce your training is XLA-compatible and (if you\u2019re using TPU Node / Colab) your dataset has been prepared appropriately, running on TPU is surprisingly easy! All you really need to change in your code is to add a few lines to initialize your TPU, and to ensure that your model and dataset are created inside a `TPUStrategy` scope. Take a look at [our TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) to see this in action!\n\n### Summary\n\nThere was a lot in here, so let\u2019s summarize with a quick checklist you can follow when you want to get your model ready for TPU training:\n\n- Make sure your code follows the three rules of XLA\n- Compile your model with `jit_compile=True` on CPU/GPU and confirm that you can train it with XLA\n- Either load your dataset into memory or use a TPU-compatible dataset loading approach (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Migrate your code either to Colab (with accelerator set to \u201cTPU\u201d) or a TPU VM on Google Cloud\n- Add TPU initializer code (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Create your `TPUStrategy` and make sure dataset loading and model creation are inside the `strategy.scope()` (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Don\u2019t forget to take `jit_compile=True` out again when you move to TPU!\n- \ud83d\ude4f\ud83d\ude4f\ud83d\ude4f\ud83e\udd7a\ud83e\udd7a\ud83e\udd7a\n- Call model.fit()\n- You did it!"
        }
    },
    {
        "context": "New users are often very confused by the range of TPUs, and the different ways to access them. The first key distinction to understand is the difference between **TPU Nodes** and **TPU VMs.**\n\nWhen you use a **TPU Node**, you are effectively indirectly accessing a remote TPU. You will need a separate VM, which will initialize your network and data pipeline and then forward them to the remote node. When you use a TPU on Google Colab, you are accessing it in the **TPU Node** style.\n\nUsing TPU Nodes can have some quite unexpected behaviour for people who aren\u2019t used to them! In particular, because the TPU is located on a physically different system to the machine you\u2019re running your Python code on, your data cannot be local to your machine - any data pipeline that loads from your machine\u2019s internal storage will totally fail! Instead, data must be stored in Google Cloud Storage where your data pipeline can still access it, even when the pipeline is running on the remote TPU node.\n\n<Tip>\n\nIf you can fit all your data in memory as `np.ndarray` or `tf.Tensor`, then you can `fit()` on that data even when using Colab or a TPU Node, without needing to upload it to Google Cloud Storage.\n\n</Tip>\n\n<Tip>\n\n**\ud83e\udd17Specific Hugging Face Tip\ud83e\udd17:** The methods `Dataset.to_tf_dataset()` and its higher-level wrapper `model.prepare_tf_dataset()` , which you will see throughout our TF code examples, will both fail on a TPU Node. The reason for this is that even though they create a `tf.data.Dataset` it is not a \u201cpure\u201d `tf.data` pipeline and uses `tf.numpy_function` or `Dataset.from_generator()` to stream data from the underlying HuggingFace `Dataset`. This HuggingFace `Dataset` is backed by data that is on a local disc and which the remote TPU Node will not be able to read.\n\n</Tip>",
        "question": "How do you access a TPU on Google Colab?",
        "answer": "You access a TPU on Google Colab in the TPU Node style.",
        "source_doc": "huggingface/transformers/blob/main/docs/source/en/perf_train_tpu_tf.md",
        "rag_answer": null,
        "rag_context": null,
        "rag_score": null,
        "rag_feedback": null
    },
    {
        "sample_idx": 45,
        "question": "Why do data pipelines that load from a machine's internal storage fail when using a TPU Node?",
        "answer": "Data pipelines that load from a machine's internal storage fail when using a TPU Node because the TPU is located on a physically different system to the machine running the Python code.",
        "rag_answer": "When using a TPU Node, data pipelines that load from a machine's internal storage fail because the TPU is located on a physically different system from the machine running the Python code. As a result, the TPU Node cannot access the local storage of the machine. To overcome this issue, data must be stored in Google Cloud Storage, where the data pipeline can access it even when running on the remote TPU Node.",
        "rag_score": null,
        "rag_feedback": null,
        "rag_context": {
            "kg_context": "-----Entities-----\n    ```csv\n    id,\tentity,\ttype,\tdescription,\trankcreated_at\n1,\tGoogle,organization,Google is the company that designs and provides TPUs, which are used to speed up tensor computations within neural networks.,3,2025-03-24 13:18:20\n2,\tTPU,technology,TPU is a Tensor Processing Unit, a hardware designed by Google to speed up tensor computations within neural networks.<SEP>TPU is a type of hardware accelerator designed for machine learning workloads.<SEP>TPU is a type of hardware accelerator used for machine learning computations.,4,2025-03-24 13:18:20\n3,\tColab,geo,Colab is a cloud-based platform for data science and machine learning, provided by Google.<SEP>Colab is a platform where users can access a free TPU.,3,2025-03-24 13:18:20\n4,\tGoogle Cloud,organization,Google Cloud is a cloud computing platform that provides infrastructure and services for building and deploying machine learning models.,1,2025-03-24 13:18:20\n5,\tTPU Node,category,TPU Node is a type of hardware accelerator designed for machine learning workloads.<SEP>TPU Node is a way to access a TPU, where the user indirectly accesses a remote TPU.,0,UNKNOWN\n6,\tTPU,technology,TPU is a Tensor Processing Unit, a hardware designed by Google to speed up tensor computations within neural networks.<SEP>TPU is a type of hardware accelerator designed for machine learning workloads.<SEP>TPU is a type of hardware accelerator used for machine learning computations.,4,UNKNOWN\n7,\tv3-32 TPU,category,v3-32 TPU is a type of TPU, a hardware designed by Google to speed up tensor computations within neural networks.,0,UNKNOWN\n    ```\n    -----Relationships-----\n    ```csv\n    id,\tsource,\ttarget,\tdescription,\tkeywords,\tweight,\trank,\tcreated_at\n1,\tGoogle,TPU,Google designs and provides TPUs, which are used to speed up tensor computations within neural networks.,hardware design, acceleration,18.0,7,2025-03-24 13:18:20\n2,\tColab,TPU,Colab provides access to a free TPU for users.,platform, hardware acceleration,16.0,7,2025-03-24 13:18:20\n3,\tGoogle Cloud,TPU,Google Cloud provides infrastructure and services for building and deploying machine learning models, including TPU hardware.,infrastructure provision, hardware acceleration,14.0,5,2025-03-24 13:18:20\n4,\tTPU,XLA,XLA compiles TensorFlow graphs into executable code for TPU hardware.<SEP>XLA is used to optimize code for TPU hardware.,compilation, hardware acceleration<SEP>compiler, hardware optimization,36.0,10,UNKNOWN\n5,\tGoogle,TPU,Google designs and provides TPUs, which are used to speed up tensor computations within neural networks.,hardware design, acceleration,18.0,7,UNKNOWN\n6,\tColab,TPU,Colab provides access to a free TPU for users.,platform, hardware acceleration,16.0,7,UNKNOWN\n7,\tGoogle Cloud,TPU,Google Cloud provides infrastructure and services for building and deploying machine learning models, including TPU hardware.,infrastructure provision, hardware acceleration,14.0,5,UNKNOWN\n    ```\n    -----Sources-----\n    ```csv\n    id,\tcontent\n1,\t!--Copyright 2023 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\nthe License. You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under the License is distributed on\nan \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n\n\u26a0\ufe0f Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be\nrendered properly in your Markdown viewer.\n\n-->\n\n# Training on TPU with TensorFlow\n\n<Tip>\n\nIf you don't need long explanations and just want TPU code samples to get started with, check out [our TPU example notebook!](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb)\n\n</Tip>\n\n### What is a TPU?\n\nA TPU is a **Tensor Processing Unit.** They are hardware designed by Google, which are used to greatly speed up the tensor computations within neural networks, much like GPUs. They can be used for both network training and inference. They are generally accessed through Google\u2019s cloud services, but small TPUs can also be accessed directly for free through Google Colab and Kaggle Kernels.\n\nBecause [all TensorFlow models in \ud83e\udd17 Transformers are Keras models](https://huggingface.co/blog/tensorflow-philosophy), most of the methods in this document are generally applicable to TPU training for any Keras model! However, there are a few points that are specific to the HuggingFace ecosystem (hug-o-system?) of Transformers and Datasets, and we\u2019ll make sure to flag them up when we get to them.\n\n### What kinds of TPU are available?\n\nNew users are often very confused by the range of TPUs, and the different ways to access them. The first key distinction to understand is the difference between **TPU Nodes** and **TPU VMs.**\n\nWhen you use a **TPU Node**, you are effectively indirectly accessing a remote TPU. You will need a separate VM, which will initialize your network and data pipeline and then forward them to the remote node. When you use a TPU on Google Colab, you are accessing it in the **TPU Node** style.\n\nUsing TPU Nodes can have some quite unexpected behaviour for people who aren\u2019t used to them! In particular, because the TPU is located on a physically different system to the machine you\u2019re running your Python code on, your data cannot be local to your machine - any data pipeline that loads from your machine\u2019s internal storage will totally fail! Instead, data must be stored in Google Cloud Storage where your data pipeline can still access it, even when the pipeline is running on the remote TPU node.\n\n<Tip>\n\nIf you can fit all your data in memory as `np.ndarray` or `tf.Tensor`, then you can `fit()` on that data even when using Colab or a TPU Node, without needing to upload it to Google Cloud Storage.\n\n</Tip>\n\n<Tip>\n\n**\ud83e\udd17Specific Hugging Face Tip\ud83e\udd17:** The methods `Dataset.to_tf_dataset()` and its higher-level wrapper `model.prepare_tf_dataset()` , which you will see throughout our TF code examples, will both fail on a TPU Node. The reason for this is that even though they create a `tf.data.Dataset` it is not a \u201cpure\u201d `tf.data` pipeline and uses `tf.numpy_function` or `Dataset.from_generator()` to stream data from the underlying HuggingFace `Dataset`. This HuggingFace `Dataset` is backed by data that is on a local disc and which the remote TPU Node will not be able to read.\n\n</Tip>\n\nThe second way to access a TPU is via a **TPU VM.** When using a TPU VM, you connect directly to the machine that the TPU is attached to, much like training on a GPU VM. TPU VMs are generally easier to work with, particularly when it comes to your data pipeline. All of the above warnings do not apply to TPU VMs!\n\nThis is an opinionated document, so here\u2019s our opinion: **Avoid using TPU Node if possible.** It is more confusing and more difficult to debug than TPU VMs. It is also likely to be unsupported in future - Google\u2019s latest TPU, TPUv4, can only be accessed as a TPU VM, which suggests that TPU Nodes are increasingly going to become a \u201clegacy\u201d access method. However, we understand that the only free TPU access is on Colab and Kaggle Kernels, which uses TPU Node - so we\u2019ll try to explain how to handle it if you have to! Check the [TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) for code samples that explain this in more detail.\n\n### What sizes of TPU are available?\n\nA single TPU (a v2-8/v3-8/v4-8) runs 8 replicas. TPUs exist in **pods** that can run hundreds or thousands of replicas simultaneously. When you use more than a single TPU but less than a whole pod (for example, a v3-32), your TPU fleet is referred to as a **pod slice.**\n\nWhen you access a free TPU via Colab, you generally get a single v2-8 TPU.\n\n### I keep hearing about this XLA thing. What\u2019s XLA, and how does it relate to TPUs?\n\nXLA is an optimizing compiler, used by both TensorFlow and JAX. In JAX it is the only compiler, whereas in TensorFlow it is optional\n2,\t(for example, a v3-32), your TPU fleet is referred to as a **pod slice.**\n\nWhen you access a free TPU via Colab, you generally get a single v2-8 TPU.\n\n### I keep hearing about this XLA thing. What\u2019s XLA, and how does it relate to TPUs?\n\nXLA is an optimizing compiler, used by both TensorFlow and JAX. In JAX it is the only compiler, whereas in TensorFlow it is optional (but mandatory on TPU!). The easiest way to enable it when training a Keras model is to pass the argument `jit_compile=True` to `model.compile()`. If you don\u2019t get any errors and performance is good, that\u2019s a great sign that you\u2019re ready to move to TPU!\n\nDebugging on TPU is generally a bit harder than on CPU/GPU, so we recommend getting your code running on CPU/GPU with XLA first before trying it on TPU. You don\u2019t have to train for long, of course - just for a few steps to make sure that your model and data pipeline are working like you expect them to.\n\n<Tip>\n\nXLA compiled code is usually faster - so even if you\u2019re not planning to run on TPU, adding `jit_compile=True` can improve your performance. Be sure to note the caveats below about XLA compatibility, though!\n\n</Tip>\n\n<Tip warning={true}>\n\n**Tip born of painful experience:** Although using `jit_compile=True` is a good way to get a speed boost and test if your CPU/GPU code is XLA-compatible, it can actually cause a lot of problems if you leave it in when actually training on TPU. XLA compilation will happen implicitly on TPU, so remember to remove that line before actually running your code on a TPU!\n\n</Tip>\n\n### How do I make my model XLA compatible?\n\nIn many cases, your code is probably XLA-compatible already! However, there are a few things that work in normal TensorFlow that don\u2019t work in XLA. We\u2019ve distilled them into three core rules below:\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** We\u2019ve put a lot of effort into rewriting our TensorFlow models and loss functions to be XLA-compatible. Our models and loss functions generally obey rule #1 and #2 by default, so you can skip over them if you\u2019re using `transformers` models. Don\u2019t forget about these rules when writing your own models and loss functions, though!\n\n</Tip>\n\n#### XLA Rule #1: Your code cannot have \u201cdata-dependent conditionals\u201d\n\nWhat that means is that any `if` statement cannot depend on values inside a `tf.Tensor`. For example, this code block cannot be compiled with XLA!\n\n```python\nif tf.reduce_sum(tensor) > 10:\n    tensor = tensor / 2.0\n```\n\nThis might seem very restrictive at first, but most neural net code doesn\u2019t need to do this. You can often get around this restriction by using `tf.cond` (see the documentation [here](https://www.tensorflow.org/api_docs/python/tf/cond)) or by removing the conditional and finding a clever math trick with indicator variables instead, like so:\n\n```python\nsum_over_10 = tf.cast(tf.reduce_sum(tensor) > 10, tf.float32)\ntensor = tensor / (1.0 + sum_over_10)\n```\n\nThis code has exactly the same effect as the code above, but by avoiding a conditional, we ensure it will compile with XLA without problems!\n\n#### XLA Rule #2: Your code cannot have \u201cdata-dependent shapes\u201d\n\nWhat this means is that the shape of all of the `tf.Tensor` objects in your code cannot depend on their values. For example, the function `tf.unique` cannot be compiled with XLA, because it returns a `tensor` containing one instance of each unique value in the input. The shape of this output will obviously be different depending on how repetitive the input `Tensor` was, and so XLA refuses to handle it!\n\nIn general, most neural network code obeys rule #2 by default. However, there are a few common cases where it becomes a problem. One very common one is when you use **label masking**, setting your labels to a negative value to indicate that those positions should be ignored when computing the loss. If you look at NumPy or PyTorch loss functions that support label masking, you will often see code like this that uses [boolean indexing](https://numpy.org/doc/stable/user/basics.indexing.html#boolean-array-indexing):\n\n```python\nlabel_mask = labels >= 0\nmasked_outputs = outputs[label_mask]\nmasked_labels = labels[label_mask]\nloss = compute_loss(masked_outputs, masked_labels)\nmean_loss = torch.mean(loss)\n```\n\nThis code is totally fine in NumPy or PyTorch, but it breaks in XLA! Why? Because the shape of `masked_outputs` and `masked_labels` depends on how many positions are masked - that makes it a **data-dependent shape.** However, just like for rule #1, we can often rewrite this code to yield exactly the same output without any data-dependent shapes.\n\n```python\nlabel_mask = tf.cast(labels >= 0, tf.float32)\nloss = compute_loss(outputs, labels)\nloss = loss * label_mask  # Set negative label positions to 0\nmean_loss = tf.reduce_sum(loss) / tf.reduce_sum(label_mask)\n```\n\nHere, we avoid data-dependent shapes by computing the loss for every position, but zeroing out the masked positions in both the numerator and denominator when we calculate the mean, which yields exactly the same result as the first block while maintaining XLA compatibility. Note that we use the same trick as in rule #1 - converting a `tf.bool` to `\n3,\tlabel_mask  # Set negative label positions to 0\nmean_loss = tf.reduce_sum(loss) / tf.reduce_sum(label_mask)\n```\n\nHere, we avoid data-dependent shapes by computing the loss for every position, but zeroing out the masked positions in both the numerator and denominator when we calculate the mean, which yields exactly the same result as the first block while maintaining XLA compatibility. Note that we use the same trick as in rule #1 - converting a `tf.bool` to `tf.float32` and using it as an indicator variable. This is a really useful trick, so remember it if you need to convert your own code to XLA!\n\n#### XLA Rule #3: XLA will need to recompile your model for every different input shape it sees\n\nThis is the big one. What this means is that if your input shapes are very variable, XLA will have to recompile your model over and over, which will create huge performance problems. This commonly arises in NLP models, where input texts have variable lengths after tokenization. In other modalities, static shapes are more common and this rule is much less of a problem.\n\nHow can you get around rule #3? The key is **padding** - if you pad all your inputs to the same length, and then use an `attention_mask`, you can get the same results as you\u2019d get from variable shapes, but without any XLA issues. However, excessive padding can cause severe slowdown too - if you pad all your samples to the maximum length in the whole dataset, you might end up with batches consisting endless padding tokens, which will waste a lot of compute and memory!\n\nThere isn\u2019t a perfect solution to this problem. However, you can try some tricks. One very useful trick is to **pad batches of samples up to a multiple of a number like 32 or 64 tokens.** This often only increases the number of tokens by a small amount, but it hugely reduces the number of unique input shapes, because every input shape now has to be a multiple of 32 or 64. Fewer unique input shapes means fewer XLA compilations!\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** Our tokenizers and data collators have methods that can help you here. You can use `padding=\"max_length\"` or `padding=\"longest\"` when calling tokenizers to get them to output padded data. Our tokenizers and data collators also have a `pad_to_multiple_of` argument that you can use to reduce the number of unique input shapes you see!\n\n</Tip>\n\n### How do I actually train my model on TPU?\n\nOnce your training is XLA-compatible and (if you\u2019re using TPU Node / Colab) your dataset has been prepared appropriately, running on TPU is surprisingly easy! All you really need to change in your code is to add a few lines to initialize your TPU, and to ensure that your model and dataset are created inside a `TPUStrategy` scope. Take a look at [our TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) to see this in action!\n\n### Summary\n\nThere was a lot in here, so let\u2019s summarize with a quick checklist you can follow when you want to get your model ready for TPU training:\n\n- Make sure your code follows the three rules of XLA\n- Compile your model with `jit_compile=True` on CPU/GPU and confirm that you can train it with XLA\n- Either load your dataset into memory or use a TPU-compatible dataset loading approach (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Migrate your code either to Colab (with accelerator set to \u201cTPU\u201d) or a TPU VM on Google Cloud\n- Add TPU initializer code (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Create your `TPUStrategy` and make sure dataset loading and model creation are inside the `strategy.scope()` (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Don\u2019t forget to take `jit_compile=True` out again when you move to TPU!\n- \ud83d\ude4f\ud83d\ude4f\ud83d\ude4f\ud83e\udd7a\ud83e\udd7a\ud83e\udd7a\n- Call model.fit()\n- You did it!\n    ```",
            "vector_context": "[Created at: 2025-03-24 13:17:32]\n!--Copyright 2023 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\nthe License. You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under the License is distributed on\nan \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n\n\u26a0\ufe0f Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be\nrendered properly in your Markdown viewer.\n\n-->\n\n# Training on TPU with TensorFlow\n\n<Tip>\n\nIf you don't need long explanations and just want TPU code samples to get started with, check out [our TPU example notebook!](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb)\n\n</Tip>\n\n### What is a TPU?\n\nA TPU is a **Tensor Processing Unit.** They are hardware designed by Google, which are used to greatly speed up the tensor computations within neural networks, much like GPUs. They can be used for both network training and inference. They are generally accessed through Google\u2019s cloud services, but small TPUs can also be accessed directly for free through Google Colab and Kaggle Kernels.\n\nBecause [all TensorFlow models in \ud83e\udd17 Transformers are Keras models](https://huggingface.co/blog/tensorflow-philosophy), most of the methods in this document are generally applicable to TPU training for any Keras model! However, there are a few points that are specific to the HuggingFace ecosystem (hug-o-system?) of Transformers and Datasets, and we\u2019ll make sure to flag them up when we get to them.\n\n### What kinds of TPU are available?\n\nNew users are often very confused by the range of TPUs, and the different ways to access them. The first key distinction to understand is the difference between **TPU Nodes** and **TPU VMs.**\n\nWhen you use a **TPU Node**, you are effectively indirectly accessing a remote TPU. You will need a separate VM, which will initialize your network and data pipeline and then forward them to the remote node. When you use a TPU on Google Colab, you are accessing it in the **TPU Node** style.\n\nUsing TPU Nodes can have some quite unexpected behaviour for people who aren\u2019t used to them! In particular, because the TPU is located on a physically different system to the machine you\u2019re running your Python code on, your data cannot be local to your machine - any data pipeline that loads from your machine\u2019s internal storage will totally fail! Instead, data must be stored in Google Cloud Storage where your data pipeline can still access it, even when the pipeline is running on the remote TPU node.\n\n<Tip>\n\nIf you can fit all your data in memory as `np.ndarray` or `tf.Tensor`, then you can `fit()` on that data even when using Colab or a TPU Node, without needing to upload it to Google Cloud Storage.\n\n</Tip>\n\n<Tip>\n\n**\ud83e\udd17Specific Hugging Face Tip\ud83e\udd17:** The methods `Dataset.to_tf_dataset()` and its higher-level wrapper `model.prepare_tf_dataset()` , which you will see throughout our TF code examples, will both fail on a TPU Node. The reason for this is that even though they create a `tf.data.Dataset` it is not a \u201cpure\u201d `tf.data` pipeline and uses `tf.numpy_function` or `Dataset.from_generator()` to stream data from the underlying HuggingFace `Dataset`. This HuggingFace `Dataset` is backed by data that is on a local disc and which the remote TPU Node will not be able to read.\n\n</Tip>\n\nThe second way to access a TPU is via a **TPU VM.** When using a TPU VM, you connect directly to the machine that the TPU is attached to, much like training on a GPU VM. TPU VMs are generally easier to work with, particularly when it comes to your data pipeline. All of the above warnings do not apply to TPU VMs!\n\nThis is an opinionated document, so here\u2019s our opinion: **Avoid using TPU Node if possible.** It is more confusing and more difficult to debug than TPU VMs. It is also likely to be unsupported in future - Google\u2019s latest TPU, TPUv4, can only be accessed as a TPU VM, which suggests that TPU Nodes are increasingly going to become a \u201clegacy\u201d access method. However, we understand that the only free TPU access is on Colab and Kaggle Kernels, which uses TPU Node - so we\u2019ll try to explain how to handle it if you have to! Check the [TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) for code samples that explain this in more detail.\n\n### What sizes of TPU are available?\n\nA single TPU (a v2-8/v3-8/v4-8) runs 8 replicas. TPUs exist in **pods** that can run hundreds or thousands of replicas simultaneously. When you use more than a single TPU but less than a whole pod (for example, a v3-32), your TPU fleet is referred to as a **pod slice.**\n\nWhen you access a free TPU via Colab, you generally get a single v2-8 TPU.\n\n### I keep hearing about this XLA thing. What\u2019s XLA, and how does it relate to TPUs?\n\nXLA is an optimizing compiler, used by both TensorFlow and JAX. In JAX it is the only compiler, whereas in TensorFlow it is optional\n--New Chunk--\n[Created at: 2025-03-24 13:17:32]\n(for example, a v3-32), your TPU fleet is referred to as a **pod slice.**\n\nWhen you access a free TPU via Colab, you generally get a single v2-8 TPU.\n\n### I keep hearing about this XLA thing. What\u2019s XLA, and how does it relate to TPUs?\n\nXLA is an optimizing compiler, used by both TensorFlow and JAX. In JAX it is the only compiler, whereas in TensorFlow it is optional (but mandatory on TPU!). The easiest way to enable it when training a Keras model is to pass the argument `jit_compile=True` to `model.compile()`. If you don\u2019t get any errors and performance is good, that\u2019s a great sign that you\u2019re ready to move to TPU!\n\nDebugging on TPU is generally a bit harder than on CPU/GPU, so we recommend getting your code running on CPU/GPU with XLA first before trying it on TPU. You don\u2019t have to train for long, of course - just for a few steps to make sure that your model and data pipeline are working like you expect them to.\n\n<Tip>\n\nXLA compiled code is usually faster - so even if you\u2019re not planning to run on TPU, adding `jit_compile=True` can improve your performance. Be sure to note the caveats below about XLA compatibility, though!\n\n</Tip>\n\n<Tip warning={true}>\n\n**Tip born of painful experience:** Although using `jit_compile=True` is a good way to get a speed boost and test if your CPU/GPU code is XLA-compatible, it can actually cause a lot of problems if you leave it in when actually training on TPU. XLA compilation will happen implicitly on TPU, so remember to remove that line before actually running your code on a TPU!\n\n</Tip>\n\n### How do I make my model XLA compatible?\n\nIn many cases, your code is probably XLA-compatible already! However, there are a few things that work in normal TensorFlow that don\u2019t work in XLA. We\u2019ve distilled them into three core rules below:\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** We\u2019ve put a lot of effort into rewriting our TensorFlow models and loss functions to be XLA-compatible. Our models and loss functions generally obey rule #1 and #2 by default, so you can skip over them if you\u2019re using `transformers` models. Don\u2019t forget about these rules when writing your own models and loss functions, though!\n\n</Tip>\n\n#### XLA Rule #1: Your code cannot have \u201cdata-dependent conditionals\u201d\n\nWhat that means is that any `if` statement cannot depend on values inside a `tf.Tensor`. For example, this code block cannot be compiled with XLA!\n\n```python\nif tf.reduce_sum(tensor) > 10:\n    tensor = tensor / 2.0\n```\n\nThis might seem very restrictive at first, but most neural net code doesn\u2019t need to do this. You can often get around this restriction by using `tf.cond` (see the documentation [here](https://www.tensorflow.org/api_docs/python/tf/cond)) or by removing the conditional and finding a clever math trick with indicator variables instead, like so:\n\n```python\nsum_over_10 = tf.cast(tf.reduce_sum(tensor) > 10, tf.float32)\ntensor = tensor / (1.0 + sum_over_10)\n```\n\nThis code has exactly the same effect as the code above, but by avoiding a conditional, we ensure it will compile with XLA without problems!\n\n#### XLA Rule #2: Your code cannot have \u201cdata-dependent shapes\u201d\n\nWhat this means is that the shape of all of the `tf.Tensor` objects in your code cannot depend on their values. For example, the function `tf.unique` cannot be compiled with XLA, because it returns a `tensor` containing one instance of each unique value in the input. The shape of this output will obviously be different depending on how repetitive the input `Tensor` was, and so XLA refuses to handle it!\n\nIn general, most neural network code obeys rule #2 by default. However, there are a few common cases where it becomes a problem. One very common one is when you use **label masking**, setting your labels to a negative value to indicate that those positions should be ignored when computing the loss. If you look at NumPy or PyTorch loss functions that support label masking, you will often see code like this that uses [boolean indexing](https://numpy.org/doc/stable/user/basics.indexing.html#boolean-array-indexing):\n\n```python\nlabel_mask = labels >= 0\nmasked_outputs = outputs[label_mask]\nmasked_labels = labels[label_mask]\nloss = compute_loss(masked_outputs, masked_labels)\nmean_loss = torch.mean(loss)\n```\n\nThis code is totally fine in NumPy or PyTorch, but it breaks in XLA! Why? Because the shape of `masked_outputs` and `masked_labels` depends on how many positions are masked - that makes it a **data-dependent shape.** However, just like for rule #1, we can often rewrite this code to yield exactly the same output without any data-dependent shapes.\n\n```python\nlabel_mask = tf.cast(labels >= 0, tf.float32)\nloss = compute_loss(outputs, labels)\nloss = loss * label_mask  # Set negative label positions to 0\nmean_loss = tf.reduce_sum(loss) / tf.reduce_sum(label_mask)\n```\n\nHere, we avoid data-dependent shapes by computing the loss for every position, but zeroing out the masked positions in both the numerator and denominator when we calculate the mean, which yields exactly the same result as the first block while maintaining XLA compatibility. Note that we use the same trick as in rule #1 - converting a `tf.bool` to `\n--New Chunk--\n[Created at: 2025-03-24 13:17:32]\nlabel_mask  # Set negative label positions to 0\nmean_loss = tf.reduce_sum(loss) / tf.reduce_sum(label_mask)\n```\n\nHere, we avoid data-dependent shapes by computing the loss for every position, but zeroing out the masked positions in both the numerator and denominator when we calculate the mean, which yields exactly the same result as the first block while maintaining XLA compatibility. Note that we use the same trick as in rule #1 - converting a `tf.bool` to `tf.float32` and using it as an indicator variable. This is a really useful trick, so remember it if you need to convert your own code to XLA!\n\n#### XLA Rule #3: XLA will need to recompile your model for every different input shape it sees\n\nThis is the big one. What this means is that if your input shapes are very variable, XLA will have to recompile your model over and over, which will create huge performance problems. This commonly arises in NLP models, where input texts have variable lengths after tokenization. In other modalities, static shapes are more common and this rule is much less of a problem.\n\nHow can you get around rule #3? The key is **padding** - if you pad all your inputs to the same length, and then use an `attention_mask`, you can get the same results as you\u2019d get from variable shapes, but without any XLA issues. However, excessive padding can cause severe slowdown too - if you pad all your samples to the maximum length in the whole dataset, you might end up with batches consisting endless padding tokens, which will waste a lot of compute and memory!\n\nThere isn\u2019t a perfect solution to this problem. However, you can try some tricks. One very useful trick is to **pad batches of samples up to a multiple of a number like 32 or 64 tokens.** This often only increases the number of tokens by a small amount, but it hugely reduces the number of unique input shapes, because every input shape now has to be a multiple of 32 or 64. Fewer unique input shapes means fewer XLA compilations!\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** Our tokenizers and data collators have methods that can help you here. You can use `padding=\"max_length\"` or `padding=\"longest\"` when calling tokenizers to get them to output padded data. Our tokenizers and data collators also have a `pad_to_multiple_of` argument that you can use to reduce the number of unique input shapes you see!\n\n</Tip>\n\n### How do I actually train my model on TPU?\n\nOnce your training is XLA-compatible and (if you\u2019re using TPU Node / Colab) your dataset has been prepared appropriately, running on TPU is surprisingly easy! All you really need to change in your code is to add a few lines to initialize your TPU, and to ensure that your model and dataset are created inside a `TPUStrategy` scope. Take a look at [our TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) to see this in action!\n\n### Summary\n\nThere was a lot in here, so let\u2019s summarize with a quick checklist you can follow when you want to get your model ready for TPU training:\n\n- Make sure your code follows the three rules of XLA\n- Compile your model with `jit_compile=True` on CPU/GPU and confirm that you can train it with XLA\n- Either load your dataset into memory or use a TPU-compatible dataset loading approach (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Migrate your code either to Colab (with accelerator set to \u201cTPU\u201d) or a TPU VM on Google Cloud\n- Add TPU initializer code (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Create your `TPUStrategy` and make sure dataset loading and model creation are inside the `strategy.scope()` (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Don\u2019t forget to take `jit_compile=True` out again when you move to TPU!\n- \ud83d\ude4f\ud83d\ude4f\ud83d\ude4f\ud83e\udd7a\ud83e\udd7a\ud83e\udd7a\n- Call model.fit()\n- You did it!"
        }
    },
    {
        "context": "New users are often very confused by the range of TPUs, and the different ways to access them. The first key distinction to understand is the difference between **TPU Nodes** and **TPU VMs.**\n\nWhen you use a **TPU Node**, you are effectively indirectly accessing a remote TPU. You will need a separate VM, which will initialize your network and data pipeline and then forward them to the remote node. When you use a TPU on Google Colab, you are accessing it in the **TPU Node** style.\n\nUsing TPU Nodes can have some quite unexpected behaviour for people who aren\u2019t used to them! In particular, because the TPU is located on a physically different system to the machine you\u2019re running your Python code on, your data cannot be local to your machine - any data pipeline that loads from your machine\u2019s internal storage will totally fail! Instead, data must be stored in Google Cloud Storage where your data pipeline can still access it, even when the pipeline is running on the remote TPU node.\n\n<Tip>\n\nIf you can fit all your data in memory as `np.ndarray` or `tf.Tensor`, then you can `fit()` on that data even when using Colab or a TPU Node, without needing to upload it to Google Cloud Storage.\n\n</Tip>\n\n<Tip>\n\n**\ud83e\udd17Specific Hugging Face Tip\ud83e\udd17:** The methods `Dataset.to_tf_dataset()` and its higher-level wrapper `model.prepare_tf_dataset()` , which you will see throughout our TF code examples, will both fail on a TPU Node. The reason for this is that even though they create a `tf.data.Dataset` it is not a \u201cpure\u201d `tf.data` pipeline and uses `tf.numpy_function` or `Dataset.from_generator()` to stream data from the underlying HuggingFace `Dataset`. This HuggingFace `Dataset` is backed by data that is on a local disc and which the remote TPU Node will not be able to read.\n\n</Tip>",
        "question": "Where must data be stored when using a TPU Node?",
        "answer": "Data must be stored in Google Cloud Storage when using a TPU Node.",
        "source_doc": "huggingface/transformers/blob/main/docs/source/en/perf_train_tpu_tf.md",
        "rag_answer": null,
        "rag_context": null,
        "rag_score": null,
        "rag_feedback": null
    },
    {
        "sample_idx": 47,
        "question": "Can you fit data in memory as np.ndarray or tf.Tensor when using Colab or a TPU Node?",
        "answer": "Yes, you can fit data in memory as np.ndarray or tf.Tensor when using Colab or a TPU Node, without needing to upload it to Google Cloud Storage.",
        "rag_answer": "When using Colab or a TPU Node, you can fit all your data in memory as `np.ndarray` or `tf.Tensor`, and then you can `fit()` on that data even when using Colab or a TPU Node, without needing to upload it to Google Cloud Storage.",
        "rag_score": null,
        "rag_feedback": null,
        "rag_context": {
            "kg_context": "-----Entities-----\n    ```csv\n    id,\tentity,\ttype,\tdescription,\trankcreated_at\n1,\tGoogle,organization,Google is the company that designs and provides TPUs, which are used to speed up tensor computations within neural networks.,3,2025-03-24 13:18:20\n2,\tTPU,technology,TPU is a Tensor Processing Unit, a hardware designed by Google to speed up tensor computations within neural networks.<SEP>TPU is a type of hardware accelerator designed for machine learning workloads.<SEP>TPU is a type of hardware accelerator used for machine learning computations.,4,2025-03-24 13:18:20\n3,\tGoogle Cloud,organization,Google Cloud is a cloud computing platform that provides infrastructure and services for building and deploying machine learning models.,1,2025-03-24 13:18:20\n4,\tKaggle Kernels,geo,Kaggle Kernels is a cloud-based platform for data science and machine learning competitions.,1,2025-03-24 13:18:20\n5,\tGoogle,organization,Google is the company that designs and provides TPUs, which are used to speed up tensor computations within neural networks.,3,UNKNOWN\n6,\tTPU,technology,TPU is a Tensor Processing Unit, a hardware designed by Google to speed up tensor computations within neural networks.<SEP>TPU is a type of hardware accelerator designed for machine learning workloads.<SEP>TPU is a type of hardware accelerator used for machine learning computations.,4,UNKNOWN\n7,\tv3-32 TPU,category,v3-32 TPU is a type of TPU, a hardware designed by Google to speed up tensor computations within neural networks.,0,UNKNOWN\n    ```\n    -----Relationships-----\n    ```csv\n    id,\tsource,\ttarget,\tdescription,\tkeywords,\tweight,\trank,\tcreated_at\n1,\tGoogle,TPU,Google designs and provides TPUs, which are used to speed up tensor computations within neural networks.,hardware design, acceleration,18.0,7,2025-03-24 13:18:20\n2,\tGoogle Cloud,TPU,Google Cloud provides infrastructure and services for building and deploying machine learning models, including TPU hardware.,infrastructure provision, hardware acceleration,14.0,5,2025-03-24 13:18:20\n3,\tGoogle,Kaggle Kernels,Kaggle Kernels is a cloud-based platform provided by Google for data science and machine learning competitions.,platform provision, cloud computing,16.0,4,2025-03-24 13:18:20\n4,\tTPU,XLA,XLA compiles TensorFlow graphs into executable code for TPU hardware.<SEP>XLA is used to optimize code for TPU hardware.,compilation, hardware acceleration<SEP>compiler, hardware optimization,36.0,10,UNKNOWN\n5,\tGoogle,TPU,Google designs and provides TPUs, which are used to speed up tensor computations within neural networks.,hardware design, acceleration,18.0,7,UNKNOWN\n6,\tColab,TPU,Colab provides access to a free TPU for users.,platform, hardware acceleration,16.0,7,UNKNOWN\n7,\tColab,Google,Colab is a cloud-based platform provided by Google for data science and machine learning.,platform provision, cloud computing,16.0,6,UNKNOWN\n8,\tGoogle Cloud,TPU,Google Cloud provides infrastructure and services for building and deploying machine learning models, including TPU hardware.,infrastructure provision, hardware acceleration,14.0,5,UNKNOWN\n9,\tGoogle,Kaggle Kernels,Kaggle Kernels is a cloud-based platform provided by Google for data science and machine learning competitions.,platform provision, cloud computing,16.0,4,UNKNOWN\n    ```\n    -----Sources-----\n    ```csv\n    id,\tcontent\n1,\t!--Copyright 2023 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\nthe License. You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under the License is distributed on\nan \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n\n\u26a0\ufe0f Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be\nrendered properly in your Markdown viewer.\n\n-->\n\n# Training on TPU with TensorFlow\n\n<Tip>\n\nIf you don't need long explanations and just want TPU code samples to get started with, check out [our TPU example notebook!](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb)\n\n</Tip>\n\n### What is a TPU?\n\nA TPU is a **Tensor Processing Unit.** They are hardware designed by Google, which are used to greatly speed up the tensor computations within neural networks, much like GPUs. They can be used for both network training and inference. They are generally accessed through Google\u2019s cloud services, but small TPUs can also be accessed directly for free through Google Colab and Kaggle Kernels.\n\nBecause [all TensorFlow models in \ud83e\udd17 Transformers are Keras models](https://huggingface.co/blog/tensorflow-philosophy), most of the methods in this document are generally applicable to TPU training for any Keras model! However, there are a few points that are specific to the HuggingFace ecosystem (hug-o-system?) of Transformers and Datasets, and we\u2019ll make sure to flag them up when we get to them.\n\n### What kinds of TPU are available?\n\nNew users are often very confused by the range of TPUs, and the different ways to access them. The first key distinction to understand is the difference between **TPU Nodes** and **TPU VMs.**\n\nWhen you use a **TPU Node**, you are effectively indirectly accessing a remote TPU. You will need a separate VM, which will initialize your network and data pipeline and then forward them to the remote node. When you use a TPU on Google Colab, you are accessing it in the **TPU Node** style.\n\nUsing TPU Nodes can have some quite unexpected behaviour for people who aren\u2019t used to them! In particular, because the TPU is located on a physically different system to the machine you\u2019re running your Python code on, your data cannot be local to your machine - any data pipeline that loads from your machine\u2019s internal storage will totally fail! Instead, data must be stored in Google Cloud Storage where your data pipeline can still access it, even when the pipeline is running on the remote TPU node.\n\n<Tip>\n\nIf you can fit all your data in memory as `np.ndarray` or `tf.Tensor`, then you can `fit()` on that data even when using Colab or a TPU Node, without needing to upload it to Google Cloud Storage.\n\n</Tip>\n\n<Tip>\n\n**\ud83e\udd17Specific Hugging Face Tip\ud83e\udd17:** The methods `Dataset.to_tf_dataset()` and its higher-level wrapper `model.prepare_tf_dataset()` , which you will see throughout our TF code examples, will both fail on a TPU Node. The reason for this is that even though they create a `tf.data.Dataset` it is not a \u201cpure\u201d `tf.data` pipeline and uses `tf.numpy_function` or `Dataset.from_generator()` to stream data from the underlying HuggingFace `Dataset`. This HuggingFace `Dataset` is backed by data that is on a local disc and which the remote TPU Node will not be able to read.\n\n</Tip>\n\nThe second way to access a TPU is via a **TPU VM.** When using a TPU VM, you connect directly to the machine that the TPU is attached to, much like training on a GPU VM. TPU VMs are generally easier to work with, particularly when it comes to your data pipeline. All of the above warnings do not apply to TPU VMs!\n\nThis is an opinionated document, so here\u2019s our opinion: **Avoid using TPU Node if possible.** It is more confusing and more difficult to debug than TPU VMs. It is also likely to be unsupported in future - Google\u2019s latest TPU, TPUv4, can only be accessed as a TPU VM, which suggests that TPU Nodes are increasingly going to become a \u201clegacy\u201d access method. However, we understand that the only free TPU access is on Colab and Kaggle Kernels, which uses TPU Node - so we\u2019ll try to explain how to handle it if you have to! Check the [TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) for code samples that explain this in more detail.\n\n### What sizes of TPU are available?\n\nA single TPU (a v2-8/v3-8/v4-8) runs 8 replicas. TPUs exist in **pods** that can run hundreds or thousands of replicas simultaneously. When you use more than a single TPU but less than a whole pod (for example, a v3-32), your TPU fleet is referred to as a **pod slice.**\n\nWhen you access a free TPU via Colab, you generally get a single v2-8 TPU.\n\n### I keep hearing about this XLA thing. What\u2019s XLA, and how does it relate to TPUs?\n\nXLA is an optimizing compiler, used by both TensorFlow and JAX. In JAX it is the only compiler, whereas in TensorFlow it is optional\n2,\tlabel_mask  # Set negative label positions to 0\nmean_loss = tf.reduce_sum(loss) / tf.reduce_sum(label_mask)\n```\n\nHere, we avoid data-dependent shapes by computing the loss for every position, but zeroing out the masked positions in both the numerator and denominator when we calculate the mean, which yields exactly the same result as the first block while maintaining XLA compatibility. Note that we use the same trick as in rule #1 - converting a `tf.bool` to `tf.float32` and using it as an indicator variable. This is a really useful trick, so remember it if you need to convert your own code to XLA!\n\n#### XLA Rule #3: XLA will need to recompile your model for every different input shape it sees\n\nThis is the big one. What this means is that if your input shapes are very variable, XLA will have to recompile your model over and over, which will create huge performance problems. This commonly arises in NLP models, where input texts have variable lengths after tokenization. In other modalities, static shapes are more common and this rule is much less of a problem.\n\nHow can you get around rule #3? The key is **padding** - if you pad all your inputs to the same length, and then use an `attention_mask`, you can get the same results as you\u2019d get from variable shapes, but without any XLA issues. However, excessive padding can cause severe slowdown too - if you pad all your samples to the maximum length in the whole dataset, you might end up with batches consisting endless padding tokens, which will waste a lot of compute and memory!\n\nThere isn\u2019t a perfect solution to this problem. However, you can try some tricks. One very useful trick is to **pad batches of samples up to a multiple of a number like 32 or 64 tokens.** This often only increases the number of tokens by a small amount, but it hugely reduces the number of unique input shapes, because every input shape now has to be a multiple of 32 or 64. Fewer unique input shapes means fewer XLA compilations!\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** Our tokenizers and data collators have methods that can help you here. You can use `padding=\"max_length\"` or `padding=\"longest\"` when calling tokenizers to get them to output padded data. Our tokenizers and data collators also have a `pad_to_multiple_of` argument that you can use to reduce the number of unique input shapes you see!\n\n</Tip>\n\n### How do I actually train my model on TPU?\n\nOnce your training is XLA-compatible and (if you\u2019re using TPU Node / Colab) your dataset has been prepared appropriately, running on TPU is surprisingly easy! All you really need to change in your code is to add a few lines to initialize your TPU, and to ensure that your model and dataset are created inside a `TPUStrategy` scope. Take a look at [our TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) to see this in action!\n\n### Summary\n\nThere was a lot in here, so let\u2019s summarize with a quick checklist you can follow when you want to get your model ready for TPU training:\n\n- Make sure your code follows the three rules of XLA\n- Compile your model with `jit_compile=True` on CPU/GPU and confirm that you can train it with XLA\n- Either load your dataset into memory or use a TPU-compatible dataset loading approach (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Migrate your code either to Colab (with accelerator set to \u201cTPU\u201d) or a TPU VM on Google Cloud\n- Add TPU initializer code (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Create your `TPUStrategy` and make sure dataset loading and model creation are inside the `strategy.scope()` (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Don\u2019t forget to take `jit_compile=True` out again when you move to TPU!\n- \ud83d\ude4f\ud83d\ude4f\ud83d\ude4f\ud83e\udd7a\ud83e\udd7a\ud83e\udd7a\n- Call model.fit()\n- You did it!\n3,\t(for example, a v3-32), your TPU fleet is referred to as a **pod slice.**\n\nWhen you access a free TPU via Colab, you generally get a single v2-8 TPU.\n\n### I keep hearing about this XLA thing. What\u2019s XLA, and how does it relate to TPUs?\n\nXLA is an optimizing compiler, used by both TensorFlow and JAX. In JAX it is the only compiler, whereas in TensorFlow it is optional (but mandatory on TPU!). The easiest way to enable it when training a Keras model is to pass the argument `jit_compile=True` to `model.compile()`. If you don\u2019t get any errors and performance is good, that\u2019s a great sign that you\u2019re ready to move to TPU!\n\nDebugging on TPU is generally a bit harder than on CPU/GPU, so we recommend getting your code running on CPU/GPU with XLA first before trying it on TPU. You don\u2019t have to train for long, of course - just for a few steps to make sure that your model and data pipeline are working like you expect them to.\n\n<Tip>\n\nXLA compiled code is usually faster - so even if you\u2019re not planning to run on TPU, adding `jit_compile=True` can improve your performance. Be sure to note the caveats below about XLA compatibility, though!\n\n</Tip>\n\n<Tip warning={true}>\n\n**Tip born of painful experience:** Although using `jit_compile=True` is a good way to get a speed boost and test if your CPU/GPU code is XLA-compatible, it can actually cause a lot of problems if you leave it in when actually training on TPU. XLA compilation will happen implicitly on TPU, so remember to remove that line before actually running your code on a TPU!\n\n</Tip>\n\n### How do I make my model XLA compatible?\n\nIn many cases, your code is probably XLA-compatible already! However, there are a few things that work in normal TensorFlow that don\u2019t work in XLA. We\u2019ve distilled them into three core rules below:\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** We\u2019ve put a lot of effort into rewriting our TensorFlow models and loss functions to be XLA-compatible. Our models and loss functions generally obey rule #1 and #2 by default, so you can skip over them if you\u2019re using `transformers` models. Don\u2019t forget about these rules when writing your own models and loss functions, though!\n\n</Tip>\n\n#### XLA Rule #1: Your code cannot have \u201cdata-dependent conditionals\u201d\n\nWhat that means is that any `if` statement cannot depend on values inside a `tf.Tensor`. For example, this code block cannot be compiled with XLA!\n\n```python\nif tf.reduce_sum(tensor) > 10:\n    tensor = tensor / 2.0\n```\n\nThis might seem very restrictive at first, but most neural net code doesn\u2019t need to do this. You can often get around this restriction by using `tf.cond` (see the documentation [here](https://www.tensorflow.org/api_docs/python/tf/cond)) or by removing the conditional and finding a clever math trick with indicator variables instead, like so:\n\n```python\nsum_over_10 = tf.cast(tf.reduce_sum(tensor) > 10, tf.float32)\ntensor = tensor / (1.0 + sum_over_10)\n```\n\nThis code has exactly the same effect as the code above, but by avoiding a conditional, we ensure it will compile with XLA without problems!\n\n#### XLA Rule #2: Your code cannot have \u201cdata-dependent shapes\u201d\n\nWhat this means is that the shape of all of the `tf.Tensor` objects in your code cannot depend on their values. For example, the function `tf.unique` cannot be compiled with XLA, because it returns a `tensor` containing one instance of each unique value in the input. The shape of this output will obviously be different depending on how repetitive the input `Tensor` was, and so XLA refuses to handle it!\n\nIn general, most neural network code obeys rule #2 by default. However, there are a few common cases where it becomes a problem. One very common one is when you use **label masking**, setting your labels to a negative value to indicate that those positions should be ignored when computing the loss. If you look at NumPy or PyTorch loss functions that support label masking, you will often see code like this that uses [boolean indexing](https://numpy.org/doc/stable/user/basics.indexing.html#boolean-array-indexing):\n\n```python\nlabel_mask = labels >= 0\nmasked_outputs = outputs[label_mask]\nmasked_labels = labels[label_mask]\nloss = compute_loss(masked_outputs, masked_labels)\nmean_loss = torch.mean(loss)\n```\n\nThis code is totally fine in NumPy or PyTorch, but it breaks in XLA! Why? Because the shape of `masked_outputs` and `masked_labels` depends on how many positions are masked - that makes it a **data-dependent shape.** However, just like for rule #1, we can often rewrite this code to yield exactly the same output without any data-dependent shapes.\n\n```python\nlabel_mask = tf.cast(labels >= 0, tf.float32)\nloss = compute_loss(outputs, labels)\nloss = loss * label_mask  # Set negative label positions to 0\nmean_loss = tf.reduce_sum(loss) / tf.reduce_sum(label_mask)\n```\n\nHere, we avoid data-dependent shapes by computing the loss for every position, but zeroing out the masked positions in both the numerator and denominator when we calculate the mean, which yields exactly the same result as the first block while maintaining XLA compatibility. Note that we use the same trick as in rule #1 - converting a `tf.bool` to `\n    ```",
            "vector_context": "[Created at: 2025-03-24 13:17:32]\n!--Copyright 2023 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\nthe License. You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under the License is distributed on\nan \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n\n\u26a0\ufe0f Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be\nrendered properly in your Markdown viewer.\n\n-->\n\n# Training on TPU with TensorFlow\n\n<Tip>\n\nIf you don't need long explanations and just want TPU code samples to get started with, check out [our TPU example notebook!](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb)\n\n</Tip>\n\n### What is a TPU?\n\nA TPU is a **Tensor Processing Unit.** They are hardware designed by Google, which are used to greatly speed up the tensor computations within neural networks, much like GPUs. They can be used for both network training and inference. They are generally accessed through Google\u2019s cloud services, but small TPUs can also be accessed directly for free through Google Colab and Kaggle Kernels.\n\nBecause [all TensorFlow models in \ud83e\udd17 Transformers are Keras models](https://huggingface.co/blog/tensorflow-philosophy), most of the methods in this document are generally applicable to TPU training for any Keras model! However, there are a few points that are specific to the HuggingFace ecosystem (hug-o-system?) of Transformers and Datasets, and we\u2019ll make sure to flag them up when we get to them.\n\n### What kinds of TPU are available?\n\nNew users are often very confused by the range of TPUs, and the different ways to access them. The first key distinction to understand is the difference between **TPU Nodes** and **TPU VMs.**\n\nWhen you use a **TPU Node**, you are effectively indirectly accessing a remote TPU. You will need a separate VM, which will initialize your network and data pipeline and then forward them to the remote node. When you use a TPU on Google Colab, you are accessing it in the **TPU Node** style.\n\nUsing TPU Nodes can have some quite unexpected behaviour for people who aren\u2019t used to them! In particular, because the TPU is located on a physically different system to the machine you\u2019re running your Python code on, your data cannot be local to your machine - any data pipeline that loads from your machine\u2019s internal storage will totally fail! Instead, data must be stored in Google Cloud Storage where your data pipeline can still access it, even when the pipeline is running on the remote TPU node.\n\n<Tip>\n\nIf you can fit all your data in memory as `np.ndarray` or `tf.Tensor`, then you can `fit()` on that data even when using Colab or a TPU Node, without needing to upload it to Google Cloud Storage.\n\n</Tip>\n\n<Tip>\n\n**\ud83e\udd17Specific Hugging Face Tip\ud83e\udd17:** The methods `Dataset.to_tf_dataset()` and its higher-level wrapper `model.prepare_tf_dataset()` , which you will see throughout our TF code examples, will both fail on a TPU Node. The reason for this is that even though they create a `tf.data.Dataset` it is not a \u201cpure\u201d `tf.data` pipeline and uses `tf.numpy_function` or `Dataset.from_generator()` to stream data from the underlying HuggingFace `Dataset`. This HuggingFace `Dataset` is backed by data that is on a local disc and which the remote TPU Node will not be able to read.\n\n</Tip>\n\nThe second way to access a TPU is via a **TPU VM.** When using a TPU VM, you connect directly to the machine that the TPU is attached to, much like training on a GPU VM. TPU VMs are generally easier to work with, particularly when it comes to your data pipeline. All of the above warnings do not apply to TPU VMs!\n\nThis is an opinionated document, so here\u2019s our opinion: **Avoid using TPU Node if possible.** It is more confusing and more difficult to debug than TPU VMs. It is also likely to be unsupported in future - Google\u2019s latest TPU, TPUv4, can only be accessed as a TPU VM, which suggests that TPU Nodes are increasingly going to become a \u201clegacy\u201d access method. However, we understand that the only free TPU access is on Colab and Kaggle Kernels, which uses TPU Node - so we\u2019ll try to explain how to handle it if you have to! Check the [TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) for code samples that explain this in more detail.\n\n### What sizes of TPU are available?\n\nA single TPU (a v2-8/v3-8/v4-8) runs 8 replicas. TPUs exist in **pods** that can run hundreds or thousands of replicas simultaneously. When you use more than a single TPU but less than a whole pod (for example, a v3-32), your TPU fleet is referred to as a **pod slice.**\n\nWhen you access a free TPU via Colab, you generally get a single v2-8 TPU.\n\n### I keep hearing about this XLA thing. What\u2019s XLA, and how does it relate to TPUs?\n\nXLA is an optimizing compiler, used by both TensorFlow and JAX. In JAX it is the only compiler, whereas in TensorFlow it is optional\n--New Chunk--\n[Created at: 2025-03-24 13:17:32]\n(for example, a v3-32), your TPU fleet is referred to as a **pod slice.**\n\nWhen you access a free TPU via Colab, you generally get a single v2-8 TPU.\n\n### I keep hearing about this XLA thing. What\u2019s XLA, and how does it relate to TPUs?\n\nXLA is an optimizing compiler, used by both TensorFlow and JAX. In JAX it is the only compiler, whereas in TensorFlow it is optional (but mandatory on TPU!). The easiest way to enable it when training a Keras model is to pass the argument `jit_compile=True` to `model.compile()`. If you don\u2019t get any errors and performance is good, that\u2019s a great sign that you\u2019re ready to move to TPU!\n\nDebugging on TPU is generally a bit harder than on CPU/GPU, so we recommend getting your code running on CPU/GPU with XLA first before trying it on TPU. You don\u2019t have to train for long, of course - just for a few steps to make sure that your model and data pipeline are working like you expect them to.\n\n<Tip>\n\nXLA compiled code is usually faster - so even if you\u2019re not planning to run on TPU, adding `jit_compile=True` can improve your performance. Be sure to note the caveats below about XLA compatibility, though!\n\n</Tip>\n\n<Tip warning={true}>\n\n**Tip born of painful experience:** Although using `jit_compile=True` is a good way to get a speed boost and test if your CPU/GPU code is XLA-compatible, it can actually cause a lot of problems if you leave it in when actually training on TPU. XLA compilation will happen implicitly on TPU, so remember to remove that line before actually running your code on a TPU!\n\n</Tip>\n\n### How do I make my model XLA compatible?\n\nIn many cases, your code is probably XLA-compatible already! However, there are a few things that work in normal TensorFlow that don\u2019t work in XLA. We\u2019ve distilled them into three core rules below:\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** We\u2019ve put a lot of effort into rewriting our TensorFlow models and loss functions to be XLA-compatible. Our models and loss functions generally obey rule #1 and #2 by default, so you can skip over them if you\u2019re using `transformers` models. Don\u2019t forget about these rules when writing your own models and loss functions, though!\n\n</Tip>\n\n#### XLA Rule #1: Your code cannot have \u201cdata-dependent conditionals\u201d\n\nWhat that means is that any `if` statement cannot depend on values inside a `tf.Tensor`. For example, this code block cannot be compiled with XLA!\n\n```python\nif tf.reduce_sum(tensor) > 10:\n    tensor = tensor / 2.0\n```\n\nThis might seem very restrictive at first, but most neural net code doesn\u2019t need to do this. You can often get around this restriction by using `tf.cond` (see the documentation [here](https://www.tensorflow.org/api_docs/python/tf/cond)) or by removing the conditional and finding a clever math trick with indicator variables instead, like so:\n\n```python\nsum_over_10 = tf.cast(tf.reduce_sum(tensor) > 10, tf.float32)\ntensor = tensor / (1.0 + sum_over_10)\n```\n\nThis code has exactly the same effect as the code above, but by avoiding a conditional, we ensure it will compile with XLA without problems!\n\n#### XLA Rule #2: Your code cannot have \u201cdata-dependent shapes\u201d\n\nWhat this means is that the shape of all of the `tf.Tensor` objects in your code cannot depend on their values. For example, the function `tf.unique` cannot be compiled with XLA, because it returns a `tensor` containing one instance of each unique value in the input. The shape of this output will obviously be different depending on how repetitive the input `Tensor` was, and so XLA refuses to handle it!\n\nIn general, most neural network code obeys rule #2 by default. However, there are a few common cases where it becomes a problem. One very common one is when you use **label masking**, setting your labels to a negative value to indicate that those positions should be ignored when computing the loss. If you look at NumPy or PyTorch loss functions that support label masking, you will often see code like this that uses [boolean indexing](https://numpy.org/doc/stable/user/basics.indexing.html#boolean-array-indexing):\n\n```python\nlabel_mask = labels >= 0\nmasked_outputs = outputs[label_mask]\nmasked_labels = labels[label_mask]\nloss = compute_loss(masked_outputs, masked_labels)\nmean_loss = torch.mean(loss)\n```\n\nThis code is totally fine in NumPy or PyTorch, but it breaks in XLA! Why? Because the shape of `masked_outputs` and `masked_labels` depends on how many positions are masked - that makes it a **data-dependent shape.** However, just like for rule #1, we can often rewrite this code to yield exactly the same output without any data-dependent shapes.\n\n```python\nlabel_mask = tf.cast(labels >= 0, tf.float32)\nloss = compute_loss(outputs, labels)\nloss = loss * label_mask  # Set negative label positions to 0\nmean_loss = tf.reduce_sum(loss) / tf.reduce_sum(label_mask)\n```\n\nHere, we avoid data-dependent shapes by computing the loss for every position, but zeroing out the masked positions in both the numerator and denominator when we calculate the mean, which yields exactly the same result as the first block while maintaining XLA compatibility. Note that we use the same trick as in rule #1 - converting a `tf.bool` to `\n--New Chunk--\n[Created at: 2025-03-24 13:17:32]\nlabel_mask  # Set negative label positions to 0\nmean_loss = tf.reduce_sum(loss) / tf.reduce_sum(label_mask)\n```\n\nHere, we avoid data-dependent shapes by computing the loss for every position, but zeroing out the masked positions in both the numerator and denominator when we calculate the mean, which yields exactly the same result as the first block while maintaining XLA compatibility. Note that we use the same trick as in rule #1 - converting a `tf.bool` to `tf.float32` and using it as an indicator variable. This is a really useful trick, so remember it if you need to convert your own code to XLA!\n\n#### XLA Rule #3: XLA will need to recompile your model for every different input shape it sees\n\nThis is the big one. What this means is that if your input shapes are very variable, XLA will have to recompile your model over and over, which will create huge performance problems. This commonly arises in NLP models, where input texts have variable lengths after tokenization. In other modalities, static shapes are more common and this rule is much less of a problem.\n\nHow can you get around rule #3? The key is **padding** - if you pad all your inputs to the same length, and then use an `attention_mask`, you can get the same results as you\u2019d get from variable shapes, but without any XLA issues. However, excessive padding can cause severe slowdown too - if you pad all your samples to the maximum length in the whole dataset, you might end up with batches consisting endless padding tokens, which will waste a lot of compute and memory!\n\nThere isn\u2019t a perfect solution to this problem. However, you can try some tricks. One very useful trick is to **pad batches of samples up to a multiple of a number like 32 or 64 tokens.** This often only increases the number of tokens by a small amount, but it hugely reduces the number of unique input shapes, because every input shape now has to be a multiple of 32 or 64. Fewer unique input shapes means fewer XLA compilations!\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** Our tokenizers and data collators have methods that can help you here. You can use `padding=\"max_length\"` or `padding=\"longest\"` when calling tokenizers to get them to output padded data. Our tokenizers and data collators also have a `pad_to_multiple_of` argument that you can use to reduce the number of unique input shapes you see!\n\n</Tip>\n\n### How do I actually train my model on TPU?\n\nOnce your training is XLA-compatible and (if you\u2019re using TPU Node / Colab) your dataset has been prepared appropriately, running on TPU is surprisingly easy! All you really need to change in your code is to add a few lines to initialize your TPU, and to ensure that your model and dataset are created inside a `TPUStrategy` scope. Take a look at [our TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) to see this in action!\n\n### Summary\n\nThere was a lot in here, so let\u2019s summarize with a quick checklist you can follow when you want to get your model ready for TPU training:\n\n- Make sure your code follows the three rules of XLA\n- Compile your model with `jit_compile=True` on CPU/GPU and confirm that you can train it with XLA\n- Either load your dataset into memory or use a TPU-compatible dataset loading approach (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Migrate your code either to Colab (with accelerator set to \u201cTPU\u201d) or a TPU VM on Google Cloud\n- Add TPU initializer code (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Create your `TPUStrategy` and make sure dataset loading and model creation are inside the `strategy.scope()` (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Don\u2019t forget to take `jit_compile=True` out again when you move to TPU!\n- \ud83d\ude4f\ud83d\ude4f\ud83d\ude4f\ud83e\udd7a\ud83e\udd7a\ud83e\udd7a\n- Call model.fit()\n- You did it!"
        }
    },
    {
        "sample_idx": 48,
        "question": "Why do the methods Dataset.to_tf_dataset() and model.prepare_tf_dataset() fail on a TPU Node?",
        "answer": "The methods Dataset.to_tf_dataset() and model.prepare_tf_dataset() fail on a TPU Node because they use tf.numpy_function or Dataset.from_generator() to stream data from the underlying HuggingFace Dataset, which is backed by data on a local disc that the remote TPU Node cannot read.",
        "rag_answer": "The methods `Dataset.to_tf_dataset()` and `model.prepare_tf_dataset()` fail on a TPU Node because they create a `tf.data.Dataset` pipeline that uses `tf.numpy_function` or `Dataset.from_generator()` to stream data from the underlying HuggingFace `Dataset`. This HuggingFace `Dataset` is backed by data that is stored on a local disk, which the remote TPU Node cannot access.",
        "rag_score": null,
        "rag_feedback": null,
        "rag_context": {
            "kg_context": "-----Entities-----\n    ```csv\n    id,\tentity,\ttype,\tdescription,\trankcreated_at\n1,\tTPU,technology,TPU is a Tensor Processing Unit, a hardware designed by Google to speed up tensor computations within neural networks.<SEP>TPU is a type of hardware accelerator designed for machine learning workloads.<SEP>TPU is a type of hardware accelerator used for machine learning computations.,4,2025-03-24 13:18:20\n2,\tXLA,technology,XLA is a technology that compiles TensorFlow graphs into executable code for various platforms.<SEP>XLA is an optimizing compiler used by TensorFlow and JAX to improve performance.<SEP>XLA is an optimizing compiler, used by both TensorFlow and JAX to optimize computations.,6,2025-03-24 13:18:20\n3,\tGoogle,organization,Google is the company that designs and provides TPUs, which are used to speed up tensor computations within neural networks.,3,2025-03-24 13:18:20\n4,\tGoogle Cloud,organization,Google Cloud is a cloud computing platform that provides infrastructure and services for building and deploying machine learning models.,1,2025-03-24 13:18:20\n5,\tv3-32 TPU,category,v3-32 TPU is a type of TPU, a hardware designed by Google to speed up tensor computations within neural networks.,0,UNKNOWN\n6,\tTF,technology,TF is an abbreviation for TensorFlow.,0,UNKNOWN\n7,\tTPU,technology,TPU is a Tensor Processing Unit, a hardware designed by Google to speed up tensor computations within neural networks.<SEP>TPU is a type of hardware accelerator designed for machine learning workloads.<SEP>TPU is a type of hardware accelerator used for machine learning computations.,4,UNKNOWN\n    ```\n    -----Relationships-----\n    ```csv\n    id,\tsource,\ttarget,\tdescription,\tkeywords,\tweight,\trank,\tcreated_at\n1,\tTPU,XLA,XLA compiles TensorFlow graphs into executable code for TPU hardware.<SEP>XLA is used to optimize code for TPU hardware.,compilation, hardware acceleration<SEP>compiler, hardware optimization,36.0,10,2025-03-24 13:18:20\n2,\tGoogle,TPU,Google designs and provides TPUs, which are used to speed up tensor computations within neural networks.,hardware design, acceleration,18.0,7,2025-03-24 13:18:20\n3,\tGoogle Cloud,TPU,Google Cloud provides infrastructure and services for building and deploying machine learning models, including TPU hardware.,infrastructure provision, hardware acceleration,14.0,5,2025-03-24 13:18:20\n4,\tTPU,XLA,XLA compiles TensorFlow graphs into executable code for TPU hardware.<SEP>XLA is used to optimize code for TPU hardware.,compilation, hardware acceleration<SEP>compiler, hardware optimization,36.0,10,UNKNOWN\n5,\tGoogle,TPU,Google designs and provides TPUs, which are used to speed up tensor computations within neural networks.,hardware design, acceleration,18.0,7,UNKNOWN\n6,\tColab,TPU,Colab provides access to a free TPU for users.,platform, hardware acceleration,16.0,7,UNKNOWN\n7,\tGoogle Cloud,TPU,Google Cloud provides infrastructure and services for building and deploying machine learning models, including TPU hardware.,infrastructure provision, hardware acceleration,14.0,5,UNKNOWN\n    ```\n    -----Sources-----\n    ```csv\n    id,\tcontent\n1,\t(for example, a v3-32), your TPU fleet is referred to as a **pod slice.**\n\nWhen you access a free TPU via Colab, you generally get a single v2-8 TPU.\n\n### I keep hearing about this XLA thing. What\u2019s XLA, and how does it relate to TPUs?\n\nXLA is an optimizing compiler, used by both TensorFlow and JAX. In JAX it is the only compiler, whereas in TensorFlow it is optional (but mandatory on TPU!). The easiest way to enable it when training a Keras model is to pass the argument `jit_compile=True` to `model.compile()`. If you don\u2019t get any errors and performance is good, that\u2019s a great sign that you\u2019re ready to move to TPU!\n\nDebugging on TPU is generally a bit harder than on CPU/GPU, so we recommend getting your code running on CPU/GPU with XLA first before trying it on TPU. You don\u2019t have to train for long, of course - just for a few steps to make sure that your model and data pipeline are working like you expect them to.\n\n<Tip>\n\nXLA compiled code is usually faster - so even if you\u2019re not planning to run on TPU, adding `jit_compile=True` can improve your performance. Be sure to note the caveats below about XLA compatibility, though!\n\n</Tip>\n\n<Tip warning={true}>\n\n**Tip born of painful experience:** Although using `jit_compile=True` is a good way to get a speed boost and test if your CPU/GPU code is XLA-compatible, it can actually cause a lot of problems if you leave it in when actually training on TPU. XLA compilation will happen implicitly on TPU, so remember to remove that line before actually running your code on a TPU!\n\n</Tip>\n\n### How do I make my model XLA compatible?\n\nIn many cases, your code is probably XLA-compatible already! However, there are a few things that work in normal TensorFlow that don\u2019t work in XLA. We\u2019ve distilled them into three core rules below:\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** We\u2019ve put a lot of effort into rewriting our TensorFlow models and loss functions to be XLA-compatible. Our models and loss functions generally obey rule #1 and #2 by default, so you can skip over them if you\u2019re using `transformers` models. Don\u2019t forget about these rules when writing your own models and loss functions, though!\n\n</Tip>\n\n#### XLA Rule #1: Your code cannot have \u201cdata-dependent conditionals\u201d\n\nWhat that means is that any `if` statement cannot depend on values inside a `tf.Tensor`. For example, this code block cannot be compiled with XLA!\n\n```python\nif tf.reduce_sum(tensor) > 10:\n    tensor = tensor / 2.0\n```\n\nThis might seem very restrictive at first, but most neural net code doesn\u2019t need to do this. You can often get around this restriction by using `tf.cond` (see the documentation [here](https://www.tensorflow.org/api_docs/python/tf/cond)) or by removing the conditional and finding a clever math trick with indicator variables instead, like so:\n\n```python\nsum_over_10 = tf.cast(tf.reduce_sum(tensor) > 10, tf.float32)\ntensor = tensor / (1.0 + sum_over_10)\n```\n\nThis code has exactly the same effect as the code above, but by avoiding a conditional, we ensure it will compile with XLA without problems!\n\n#### XLA Rule #2: Your code cannot have \u201cdata-dependent shapes\u201d\n\nWhat this means is that the shape of all of the `tf.Tensor` objects in your code cannot depend on their values. For example, the function `tf.unique` cannot be compiled with XLA, because it returns a `tensor` containing one instance of each unique value in the input. The shape of this output will obviously be different depending on how repetitive the input `Tensor` was, and so XLA refuses to handle it!\n\nIn general, most neural network code obeys rule #2 by default. However, there are a few common cases where it becomes a problem. One very common one is when you use **label masking**, setting your labels to a negative value to indicate that those positions should be ignored when computing the loss. If you look at NumPy or PyTorch loss functions that support label masking, you will often see code like this that uses [boolean indexing](https://numpy.org/doc/stable/user/basics.indexing.html#boolean-array-indexing):\n\n```python\nlabel_mask = labels >= 0\nmasked_outputs = outputs[label_mask]\nmasked_labels = labels[label_mask]\nloss = compute_loss(masked_outputs, masked_labels)\nmean_loss = torch.mean(loss)\n```\n\nThis code is totally fine in NumPy or PyTorch, but it breaks in XLA! Why? Because the shape of `masked_outputs` and `masked_labels` depends on how many positions are masked - that makes it a **data-dependent shape.** However, just like for rule #1, we can often rewrite this code to yield exactly the same output without any data-dependent shapes.\n\n```python\nlabel_mask = tf.cast(labels >= 0, tf.float32)\nloss = compute_loss(outputs, labels)\nloss = loss * label_mask  # Set negative label positions to 0\nmean_loss = tf.reduce_sum(loss) / tf.reduce_sum(label_mask)\n```\n\nHere, we avoid data-dependent shapes by computing the loss for every position, but zeroing out the masked positions in both the numerator and denominator when we calculate the mean, which yields exactly the same result as the first block while maintaining XLA compatibility. Note that we use the same trick as in rule #1 - converting a `tf.bool` to `\n2,\tlabel_mask  # Set negative label positions to 0\nmean_loss = tf.reduce_sum(loss) / tf.reduce_sum(label_mask)\n```\n\nHere, we avoid data-dependent shapes by computing the loss for every position, but zeroing out the masked positions in both the numerator and denominator when we calculate the mean, which yields exactly the same result as the first block while maintaining XLA compatibility. Note that we use the same trick as in rule #1 - converting a `tf.bool` to `tf.float32` and using it as an indicator variable. This is a really useful trick, so remember it if you need to convert your own code to XLA!\n\n#### XLA Rule #3: XLA will need to recompile your model for every different input shape it sees\n\nThis is the big one. What this means is that if your input shapes are very variable, XLA will have to recompile your model over and over, which will create huge performance problems. This commonly arises in NLP models, where input texts have variable lengths after tokenization. In other modalities, static shapes are more common and this rule is much less of a problem.\n\nHow can you get around rule #3? The key is **padding** - if you pad all your inputs to the same length, and then use an `attention_mask`, you can get the same results as you\u2019d get from variable shapes, but without any XLA issues. However, excessive padding can cause severe slowdown too - if you pad all your samples to the maximum length in the whole dataset, you might end up with batches consisting endless padding tokens, which will waste a lot of compute and memory!\n\nThere isn\u2019t a perfect solution to this problem. However, you can try some tricks. One very useful trick is to **pad batches of samples up to a multiple of a number like 32 or 64 tokens.** This often only increases the number of tokens by a small amount, but it hugely reduces the number of unique input shapes, because every input shape now has to be a multiple of 32 or 64. Fewer unique input shapes means fewer XLA compilations!\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** Our tokenizers and data collators have methods that can help you here. You can use `padding=\"max_length\"` or `padding=\"longest\"` when calling tokenizers to get them to output padded data. Our tokenizers and data collators also have a `pad_to_multiple_of` argument that you can use to reduce the number of unique input shapes you see!\n\n</Tip>\n\n### How do I actually train my model on TPU?\n\nOnce your training is XLA-compatible and (if you\u2019re using TPU Node / Colab) your dataset has been prepared appropriately, running on TPU is surprisingly easy! All you really need to change in your code is to add a few lines to initialize your TPU, and to ensure that your model and dataset are created inside a `TPUStrategy` scope. Take a look at [our TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) to see this in action!\n\n### Summary\n\nThere was a lot in here, so let\u2019s summarize with a quick checklist you can follow when you want to get your model ready for TPU training:\n\n- Make sure your code follows the three rules of XLA\n- Compile your model with `jit_compile=True` on CPU/GPU and confirm that you can train it with XLA\n- Either load your dataset into memory or use a TPU-compatible dataset loading approach (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Migrate your code either to Colab (with accelerator set to \u201cTPU\u201d) or a TPU VM on Google Cloud\n- Add TPU initializer code (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Create your `TPUStrategy` and make sure dataset loading and model creation are inside the `strategy.scope()` (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Don\u2019t forget to take `jit_compile=True` out again when you move to TPU!\n- \ud83d\ude4f\ud83d\ude4f\ud83d\ude4f\ud83e\udd7a\ud83e\udd7a\ud83e\udd7a\n- Call model.fit()\n- You did it!\n3,\t!--Copyright 2023 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\nthe License. You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under the License is distributed on\nan \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n\n\u26a0\ufe0f Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be\nrendered properly in your Markdown viewer.\n\n-->\n\n# Training on TPU with TensorFlow\n\n<Tip>\n\nIf you don't need long explanations and just want TPU code samples to get started with, check out [our TPU example notebook!](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb)\n\n</Tip>\n\n### What is a TPU?\n\nA TPU is a **Tensor Processing Unit.** They are hardware designed by Google, which are used to greatly speed up the tensor computations within neural networks, much like GPUs. They can be used for both network training and inference. They are generally accessed through Google\u2019s cloud services, but small TPUs can also be accessed directly for free through Google Colab and Kaggle Kernels.\n\nBecause [all TensorFlow models in \ud83e\udd17 Transformers are Keras models](https://huggingface.co/blog/tensorflow-philosophy), most of the methods in this document are generally applicable to TPU training for any Keras model! However, there are a few points that are specific to the HuggingFace ecosystem (hug-o-system?) of Transformers and Datasets, and we\u2019ll make sure to flag them up when we get to them.\n\n### What kinds of TPU are available?\n\nNew users are often very confused by the range of TPUs, and the different ways to access them. The first key distinction to understand is the difference between **TPU Nodes** and **TPU VMs.**\n\nWhen you use a **TPU Node**, you are effectively indirectly accessing a remote TPU. You will need a separate VM, which will initialize your network and data pipeline and then forward them to the remote node. When you use a TPU on Google Colab, you are accessing it in the **TPU Node** style.\n\nUsing TPU Nodes can have some quite unexpected behaviour for people who aren\u2019t used to them! In particular, because the TPU is located on a physically different system to the machine you\u2019re running your Python code on, your data cannot be local to your machine - any data pipeline that loads from your machine\u2019s internal storage will totally fail! Instead, data must be stored in Google Cloud Storage where your data pipeline can still access it, even when the pipeline is running on the remote TPU node.\n\n<Tip>\n\nIf you can fit all your data in memory as `np.ndarray` or `tf.Tensor`, then you can `fit()` on that data even when using Colab or a TPU Node, without needing to upload it to Google Cloud Storage.\n\n</Tip>\n\n<Tip>\n\n**\ud83e\udd17Specific Hugging Face Tip\ud83e\udd17:** The methods `Dataset.to_tf_dataset()` and its higher-level wrapper `model.prepare_tf_dataset()` , which you will see throughout our TF code examples, will both fail on a TPU Node. The reason for this is that even though they create a `tf.data.Dataset` it is not a \u201cpure\u201d `tf.data` pipeline and uses `tf.numpy_function` or `Dataset.from_generator()` to stream data from the underlying HuggingFace `Dataset`. This HuggingFace `Dataset` is backed by data that is on a local disc and which the remote TPU Node will not be able to read.\n\n</Tip>\n\nThe second way to access a TPU is via a **TPU VM.** When using a TPU VM, you connect directly to the machine that the TPU is attached to, much like training on a GPU VM. TPU VMs are generally easier to work with, particularly when it comes to your data pipeline. All of the above warnings do not apply to TPU VMs!\n\nThis is an opinionated document, so here\u2019s our opinion: **Avoid using TPU Node if possible.** It is more confusing and more difficult to debug than TPU VMs. It is also likely to be unsupported in future - Google\u2019s latest TPU, TPUv4, can only be accessed as a TPU VM, which suggests that TPU Nodes are increasingly going to become a \u201clegacy\u201d access method. However, we understand that the only free TPU access is on Colab and Kaggle Kernels, which uses TPU Node - so we\u2019ll try to explain how to handle it if you have to! Check the [TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) for code samples that explain this in more detail.\n\n### What sizes of TPU are available?\n\nA single TPU (a v2-8/v3-8/v4-8) runs 8 replicas. TPUs exist in **pods** that can run hundreds or thousands of replicas simultaneously. When you use more than a single TPU but less than a whole pod (for example, a v3-32), your TPU fleet is referred to as a **pod slice.**\n\nWhen you access a free TPU via Colab, you generally get a single v2-8 TPU.\n\n### I keep hearing about this XLA thing. What\u2019s XLA, and how does it relate to TPUs?\n\nXLA is an optimizing compiler, used by both TensorFlow and JAX. In JAX it is the only compiler, whereas in TensorFlow it is optional\n    ```",
            "vector_context": "[Created at: 2025-03-24 13:17:32]\n!--Copyright 2023 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\nthe License. You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under the License is distributed on\nan \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n\n\u26a0\ufe0f Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be\nrendered properly in your Markdown viewer.\n\n-->\n\n# Training on TPU with TensorFlow\n\n<Tip>\n\nIf you don't need long explanations and just want TPU code samples to get started with, check out [our TPU example notebook!](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb)\n\n</Tip>\n\n### What is a TPU?\n\nA TPU is a **Tensor Processing Unit.** They are hardware designed by Google, which are used to greatly speed up the tensor computations within neural networks, much like GPUs. They can be used for both network training and inference. They are generally accessed through Google\u2019s cloud services, but small TPUs can also be accessed directly for free through Google Colab and Kaggle Kernels.\n\nBecause [all TensorFlow models in \ud83e\udd17 Transformers are Keras models](https://huggingface.co/blog/tensorflow-philosophy), most of the methods in this document are generally applicable to TPU training for any Keras model! However, there are a few points that are specific to the HuggingFace ecosystem (hug-o-system?) of Transformers and Datasets, and we\u2019ll make sure to flag them up when we get to them.\n\n### What kinds of TPU are available?\n\nNew users are often very confused by the range of TPUs, and the different ways to access them. The first key distinction to understand is the difference between **TPU Nodes** and **TPU VMs.**\n\nWhen you use a **TPU Node**, you are effectively indirectly accessing a remote TPU. You will need a separate VM, which will initialize your network and data pipeline and then forward them to the remote node. When you use a TPU on Google Colab, you are accessing it in the **TPU Node** style.\n\nUsing TPU Nodes can have some quite unexpected behaviour for people who aren\u2019t used to them! In particular, because the TPU is located on a physically different system to the machine you\u2019re running your Python code on, your data cannot be local to your machine - any data pipeline that loads from your machine\u2019s internal storage will totally fail! Instead, data must be stored in Google Cloud Storage where your data pipeline can still access it, even when the pipeline is running on the remote TPU node.\n\n<Tip>\n\nIf you can fit all your data in memory as `np.ndarray` or `tf.Tensor`, then you can `fit()` on that data even when using Colab or a TPU Node, without needing to upload it to Google Cloud Storage.\n\n</Tip>\n\n<Tip>\n\n**\ud83e\udd17Specific Hugging Face Tip\ud83e\udd17:** The methods `Dataset.to_tf_dataset()` and its higher-level wrapper `model.prepare_tf_dataset()` , which you will see throughout our TF code examples, will both fail on a TPU Node. The reason for this is that even though they create a `tf.data.Dataset` it is not a \u201cpure\u201d `tf.data` pipeline and uses `tf.numpy_function` or `Dataset.from_generator()` to stream data from the underlying HuggingFace `Dataset`. This HuggingFace `Dataset` is backed by data that is on a local disc and which the remote TPU Node will not be able to read.\n\n</Tip>\n\nThe second way to access a TPU is via a **TPU VM.** When using a TPU VM, you connect directly to the machine that the TPU is attached to, much like training on a GPU VM. TPU VMs are generally easier to work with, particularly when it comes to your data pipeline. All of the above warnings do not apply to TPU VMs!\n\nThis is an opinionated document, so here\u2019s our opinion: **Avoid using TPU Node if possible.** It is more confusing and more difficult to debug than TPU VMs. It is also likely to be unsupported in future - Google\u2019s latest TPU, TPUv4, can only be accessed as a TPU VM, which suggests that TPU Nodes are increasingly going to become a \u201clegacy\u201d access method. However, we understand that the only free TPU access is on Colab and Kaggle Kernels, which uses TPU Node - so we\u2019ll try to explain how to handle it if you have to! Check the [TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) for code samples that explain this in more detail.\n\n### What sizes of TPU are available?\n\nA single TPU (a v2-8/v3-8/v4-8) runs 8 replicas. TPUs exist in **pods** that can run hundreds or thousands of replicas simultaneously. When you use more than a single TPU but less than a whole pod (for example, a v3-32), your TPU fleet is referred to as a **pod slice.**\n\nWhen you access a free TPU via Colab, you generally get a single v2-8 TPU.\n\n### I keep hearing about this XLA thing. What\u2019s XLA, and how does it relate to TPUs?\n\nXLA is an optimizing compiler, used by both TensorFlow and JAX. In JAX it is the only compiler, whereas in TensorFlow it is optional\n--New Chunk--\n[Created at: 2025-03-24 13:17:32]\n(for example, a v3-32), your TPU fleet is referred to as a **pod slice.**\n\nWhen you access a free TPU via Colab, you generally get a single v2-8 TPU.\n\n### I keep hearing about this XLA thing. What\u2019s XLA, and how does it relate to TPUs?\n\nXLA is an optimizing compiler, used by both TensorFlow and JAX. In JAX it is the only compiler, whereas in TensorFlow it is optional (but mandatory on TPU!). The easiest way to enable it when training a Keras model is to pass the argument `jit_compile=True` to `model.compile()`. If you don\u2019t get any errors and performance is good, that\u2019s a great sign that you\u2019re ready to move to TPU!\n\nDebugging on TPU is generally a bit harder than on CPU/GPU, so we recommend getting your code running on CPU/GPU with XLA first before trying it on TPU. You don\u2019t have to train for long, of course - just for a few steps to make sure that your model and data pipeline are working like you expect them to.\n\n<Tip>\n\nXLA compiled code is usually faster - so even if you\u2019re not planning to run on TPU, adding `jit_compile=True` can improve your performance. Be sure to note the caveats below about XLA compatibility, though!\n\n</Tip>\n\n<Tip warning={true}>\n\n**Tip born of painful experience:** Although using `jit_compile=True` is a good way to get a speed boost and test if your CPU/GPU code is XLA-compatible, it can actually cause a lot of problems if you leave it in when actually training on TPU. XLA compilation will happen implicitly on TPU, so remember to remove that line before actually running your code on a TPU!\n\n</Tip>\n\n### How do I make my model XLA compatible?\n\nIn many cases, your code is probably XLA-compatible already! However, there are a few things that work in normal TensorFlow that don\u2019t work in XLA. We\u2019ve distilled them into three core rules below:\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** We\u2019ve put a lot of effort into rewriting our TensorFlow models and loss functions to be XLA-compatible. Our models and loss functions generally obey rule #1 and #2 by default, so you can skip over them if you\u2019re using `transformers` models. Don\u2019t forget about these rules when writing your own models and loss functions, though!\n\n</Tip>\n\n#### XLA Rule #1: Your code cannot have \u201cdata-dependent conditionals\u201d\n\nWhat that means is that any `if` statement cannot depend on values inside a `tf.Tensor`. For example, this code block cannot be compiled with XLA!\n\n```python\nif tf.reduce_sum(tensor) > 10:\n    tensor = tensor / 2.0\n```\n\nThis might seem very restrictive at first, but most neural net code doesn\u2019t need to do this. You can often get around this restriction by using `tf.cond` (see the documentation [here](https://www.tensorflow.org/api_docs/python/tf/cond)) or by removing the conditional and finding a clever math trick with indicator variables instead, like so:\n\n```python\nsum_over_10 = tf.cast(tf.reduce_sum(tensor) > 10, tf.float32)\ntensor = tensor / (1.0 + sum_over_10)\n```\n\nThis code has exactly the same effect as the code above, but by avoiding a conditional, we ensure it will compile with XLA without problems!\n\n#### XLA Rule #2: Your code cannot have \u201cdata-dependent shapes\u201d\n\nWhat this means is that the shape of all of the `tf.Tensor` objects in your code cannot depend on their values. For example, the function `tf.unique` cannot be compiled with XLA, because it returns a `tensor` containing one instance of each unique value in the input. The shape of this output will obviously be different depending on how repetitive the input `Tensor` was, and so XLA refuses to handle it!\n\nIn general, most neural network code obeys rule #2 by default. However, there are a few common cases where it becomes a problem. One very common one is when you use **label masking**, setting your labels to a negative value to indicate that those positions should be ignored when computing the loss. If you look at NumPy or PyTorch loss functions that support label masking, you will often see code like this that uses [boolean indexing](https://numpy.org/doc/stable/user/basics.indexing.html#boolean-array-indexing):\n\n```python\nlabel_mask = labels >= 0\nmasked_outputs = outputs[label_mask]\nmasked_labels = labels[label_mask]\nloss = compute_loss(masked_outputs, masked_labels)\nmean_loss = torch.mean(loss)\n```\n\nThis code is totally fine in NumPy or PyTorch, but it breaks in XLA! Why? Because the shape of `masked_outputs` and `masked_labels` depends on how many positions are masked - that makes it a **data-dependent shape.** However, just like for rule #1, we can often rewrite this code to yield exactly the same output without any data-dependent shapes.\n\n```python\nlabel_mask = tf.cast(labels >= 0, tf.float32)\nloss = compute_loss(outputs, labels)\nloss = loss * label_mask  # Set negative label positions to 0\nmean_loss = tf.reduce_sum(loss) / tf.reduce_sum(label_mask)\n```\n\nHere, we avoid data-dependent shapes by computing the loss for every position, but zeroing out the masked positions in both the numerator and denominator when we calculate the mean, which yields exactly the same result as the first block while maintaining XLA compatibility. Note that we use the same trick as in rule #1 - converting a `tf.bool` to `\n--New Chunk--\n[Created at: 2025-03-24 13:17:32]\nlabel_mask  # Set negative label positions to 0\nmean_loss = tf.reduce_sum(loss) / tf.reduce_sum(label_mask)\n```\n\nHere, we avoid data-dependent shapes by computing the loss for every position, but zeroing out the masked positions in both the numerator and denominator when we calculate the mean, which yields exactly the same result as the first block while maintaining XLA compatibility. Note that we use the same trick as in rule #1 - converting a `tf.bool` to `tf.float32` and using it as an indicator variable. This is a really useful trick, so remember it if you need to convert your own code to XLA!\n\n#### XLA Rule #3: XLA will need to recompile your model for every different input shape it sees\n\nThis is the big one. What this means is that if your input shapes are very variable, XLA will have to recompile your model over and over, which will create huge performance problems. This commonly arises in NLP models, where input texts have variable lengths after tokenization. In other modalities, static shapes are more common and this rule is much less of a problem.\n\nHow can you get around rule #3? The key is **padding** - if you pad all your inputs to the same length, and then use an `attention_mask`, you can get the same results as you\u2019d get from variable shapes, but without any XLA issues. However, excessive padding can cause severe slowdown too - if you pad all your samples to the maximum length in the whole dataset, you might end up with batches consisting endless padding tokens, which will waste a lot of compute and memory!\n\nThere isn\u2019t a perfect solution to this problem. However, you can try some tricks. One very useful trick is to **pad batches of samples up to a multiple of a number like 32 or 64 tokens.** This often only increases the number of tokens by a small amount, but it hugely reduces the number of unique input shapes, because every input shape now has to be a multiple of 32 or 64. Fewer unique input shapes means fewer XLA compilations!\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** Our tokenizers and data collators have methods that can help you here. You can use `padding=\"max_length\"` or `padding=\"longest\"` when calling tokenizers to get them to output padded data. Our tokenizers and data collators also have a `pad_to_multiple_of` argument that you can use to reduce the number of unique input shapes you see!\n\n</Tip>\n\n### How do I actually train my model on TPU?\n\nOnce your training is XLA-compatible and (if you\u2019re using TPU Node / Colab) your dataset has been prepared appropriately, running on TPU is surprisingly easy! All you really need to change in your code is to add a few lines to initialize your TPU, and to ensure that your model and dataset are created inside a `TPUStrategy` scope. Take a look at [our TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) to see this in action!\n\n### Summary\n\nThere was a lot in here, so let\u2019s summarize with a quick checklist you can follow when you want to get your model ready for TPU training:\n\n- Make sure your code follows the three rules of XLA\n- Compile your model with `jit_compile=True` on CPU/GPU and confirm that you can train it with XLA\n- Either load your dataset into memory or use a TPU-compatible dataset loading approach (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Migrate your code either to Colab (with accelerator set to \u201cTPU\u201d) or a TPU VM on Google Cloud\n- Add TPU initializer code (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Create your `TPUStrategy` and make sure dataset loading and model creation are inside the `strategy.scope()` (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Don\u2019t forget to take `jit_compile=True` out again when you move to TPU!\n- \ud83d\ude4f\ud83d\ude4f\ud83d\ude4f\ud83e\udd7a\ud83e\udd7a\ud83e\udd7a\n- Call model.fit()\n- You did it!"
        }
    },
    {
        "sample_idx": 49,
        "question": "What is a TPU VM?",
        "answer": "A TPU VM is a machine that a TPU is attached to, allowing direct connection for training, similar to a GPU VM.",
        "rag_answer": "A **TPU VM** (Tensor Processing Unit Virtual Machine) is a type of virtual machine that provides direct access to a TPU (Tensor Processing Unit), which is a hardware accelerator designed by Google for machine learning workloads. \n\nWhen using a TPU VM, you connect directly to the machine that the TPU is attached to, similar to training on a GPU VM. This approach is generally easier to work with, especially",
        "rag_score": null,
        "rag_feedback": null,
        "rag_context": {
            "kg_context": "-----Entities-----\n    ```csv\n    id,\tentity,\ttype,\tdescription,\trankcreated_at\n1,\tGoogle,organization,Google is the company that designs and provides TPUs, which are used to speed up tensor computations within neural networks.,3,2025-03-24 13:18:20\n2,\tTPU,technology,TPU is a Tensor Processing Unit, a hardware designed by Google to speed up tensor computations within neural networks.<SEP>TPU is a type of hardware accelerator designed for machine learning workloads.<SEP>TPU is a type of hardware accelerator used for machine learning computations.,4,2025-03-24 13:18:20\n3,\tColab,geo,Colab is a cloud-based platform for data science and machine learning, provided by Google.<SEP>Colab is a platform where users can access a free TPU.,3,2025-03-24 13:18:20\n4,\tGoogle Cloud,organization,Google Cloud is a cloud computing platform that provides infrastructure and services for building and deploying machine learning models.,1,2025-03-24 13:18:20\n5,\tTPU,technology,TPU is a Tensor Processing Unit, a hardware designed by Google to speed up tensor computations within neural networks.<SEP>TPU is a type of hardware accelerator designed for machine learning workloads.<SEP>TPU is a type of hardware accelerator used for machine learning computations.,4,UNKNOWN\n6,\tTPUv4,category,TPUv4 is a type of TPU, a hardware designed by Google to speed up tensor computations within neural networks.,0,UNKNOWN\n7,\tGoogle,organization,Google is the company that designs and provides TPUs, which are used to speed up tensor computations within neural networks.,3,UNKNOWN\n    ```\n    -----Relationships-----\n    ```csv\n    id,\tsource,\ttarget,\tdescription,\tkeywords,\tweight,\trank,\tcreated_at\n1,\tGoogle,TPU,Google designs and provides TPUs, which are used to speed up tensor computations within neural networks.,hardware design, acceleration,18.0,7,2025-03-24 13:18:20\n2,\tColab,TPU,Colab provides access to a free TPU for users.,platform, hardware acceleration,16.0,7,2025-03-24 13:18:20\n3,\tGoogle Cloud,TPU,Google Cloud provides infrastructure and services for building and deploying machine learning models, including TPU hardware.,infrastructure provision, hardware acceleration,14.0,5,2025-03-24 13:18:20\n4,\tTPU,XLA,XLA compiles TensorFlow graphs into executable code for TPU hardware.<SEP>XLA is used to optimize code for TPU hardware.,compilation, hardware acceleration<SEP>compiler, hardware optimization,36.0,10,UNKNOWN\n5,\tGoogle,TPU,Google designs and provides TPUs, which are used to speed up tensor computations within neural networks.,hardware design, acceleration,18.0,7,UNKNOWN\n6,\tColab,TPU,Colab provides access to a free TPU for users.,platform, hardware acceleration,16.0,7,UNKNOWN\n7,\tColab,Google,Colab is a cloud-based platform provided by Google for data science and machine learning.,platform provision, cloud computing,16.0,6,UNKNOWN\n8,\tGoogle Cloud,TPU,Google Cloud provides infrastructure and services for building and deploying machine learning models, including TPU hardware.,infrastructure provision, hardware acceleration,14.0,5,UNKNOWN\n9,\tGoogle,Kaggle Kernels,Kaggle Kernels is a cloud-based platform provided by Google for data science and machine learning competitions.,platform provision, cloud computing,16.0,4,UNKNOWN\n    ```\n    -----Sources-----\n    ```csv\n    id,\tcontent\n1,\t!--Copyright 2023 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\nthe License. You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under the License is distributed on\nan \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n\n\u26a0\ufe0f Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be\nrendered properly in your Markdown viewer.\n\n-->\n\n# Training on TPU with TensorFlow\n\n<Tip>\n\nIf you don't need long explanations and just want TPU code samples to get started with, check out [our TPU example notebook!](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb)\n\n</Tip>\n\n### What is a TPU?\n\nA TPU is a **Tensor Processing Unit.** They are hardware designed by Google, which are used to greatly speed up the tensor computations within neural networks, much like GPUs. They can be used for both network training and inference. They are generally accessed through Google\u2019s cloud services, but small TPUs can also be accessed directly for free through Google Colab and Kaggle Kernels.\n\nBecause [all TensorFlow models in \ud83e\udd17 Transformers are Keras models](https://huggingface.co/blog/tensorflow-philosophy), most of the methods in this document are generally applicable to TPU training for any Keras model! However, there are a few points that are specific to the HuggingFace ecosystem (hug-o-system?) of Transformers and Datasets, and we\u2019ll make sure to flag them up when we get to them.\n\n### What kinds of TPU are available?\n\nNew users are often very confused by the range of TPUs, and the different ways to access them. The first key distinction to understand is the difference between **TPU Nodes** and **TPU VMs.**\n\nWhen you use a **TPU Node**, you are effectively indirectly accessing a remote TPU. You will need a separate VM, which will initialize your network and data pipeline and then forward them to the remote node. When you use a TPU on Google Colab, you are accessing it in the **TPU Node** style.\n\nUsing TPU Nodes can have some quite unexpected behaviour for people who aren\u2019t used to them! In particular, because the TPU is located on a physically different system to the machine you\u2019re running your Python code on, your data cannot be local to your machine - any data pipeline that loads from your machine\u2019s internal storage will totally fail! Instead, data must be stored in Google Cloud Storage where your data pipeline can still access it, even when the pipeline is running on the remote TPU node.\n\n<Tip>\n\nIf you can fit all your data in memory as `np.ndarray` or `tf.Tensor`, then you can `fit()` on that data even when using Colab or a TPU Node, without needing to upload it to Google Cloud Storage.\n\n</Tip>\n\n<Tip>\n\n**\ud83e\udd17Specific Hugging Face Tip\ud83e\udd17:** The methods `Dataset.to_tf_dataset()` and its higher-level wrapper `model.prepare_tf_dataset()` , which you will see throughout our TF code examples, will both fail on a TPU Node. The reason for this is that even though they create a `tf.data.Dataset` it is not a \u201cpure\u201d `tf.data` pipeline and uses `tf.numpy_function` or `Dataset.from_generator()` to stream data from the underlying HuggingFace `Dataset`. This HuggingFace `Dataset` is backed by data that is on a local disc and which the remote TPU Node will not be able to read.\n\n</Tip>\n\nThe second way to access a TPU is via a **TPU VM.** When using a TPU VM, you connect directly to the machine that the TPU is attached to, much like training on a GPU VM. TPU VMs are generally easier to work with, particularly when it comes to your data pipeline. All of the above warnings do not apply to TPU VMs!\n\nThis is an opinionated document, so here\u2019s our opinion: **Avoid using TPU Node if possible.** It is more confusing and more difficult to debug than TPU VMs. It is also likely to be unsupported in future - Google\u2019s latest TPU, TPUv4, can only be accessed as a TPU VM, which suggests that TPU Nodes are increasingly going to become a \u201clegacy\u201d access method. However, we understand that the only free TPU access is on Colab and Kaggle Kernels, which uses TPU Node - so we\u2019ll try to explain how to handle it if you have to! Check the [TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) for code samples that explain this in more detail.\n\n### What sizes of TPU are available?\n\nA single TPU (a v2-8/v3-8/v4-8) runs 8 replicas. TPUs exist in **pods** that can run hundreds or thousands of replicas simultaneously. When you use more than a single TPU but less than a whole pod (for example, a v3-32), your TPU fleet is referred to as a **pod slice.**\n\nWhen you access a free TPU via Colab, you generally get a single v2-8 TPU.\n\n### I keep hearing about this XLA thing. What\u2019s XLA, and how does it relate to TPUs?\n\nXLA is an optimizing compiler, used by both TensorFlow and JAX. In JAX it is the only compiler, whereas in TensorFlow it is optional\n2,\t(for example, a v3-32), your TPU fleet is referred to as a **pod slice.**\n\nWhen you access a free TPU via Colab, you generally get a single v2-8 TPU.\n\n### I keep hearing about this XLA thing. What\u2019s XLA, and how does it relate to TPUs?\n\nXLA is an optimizing compiler, used by both TensorFlow and JAX. In JAX it is the only compiler, whereas in TensorFlow it is optional (but mandatory on TPU!). The easiest way to enable it when training a Keras model is to pass the argument `jit_compile=True` to `model.compile()`. If you don\u2019t get any errors and performance is good, that\u2019s a great sign that you\u2019re ready to move to TPU!\n\nDebugging on TPU is generally a bit harder than on CPU/GPU, so we recommend getting your code running on CPU/GPU with XLA first before trying it on TPU. You don\u2019t have to train for long, of course - just for a few steps to make sure that your model and data pipeline are working like you expect them to.\n\n<Tip>\n\nXLA compiled code is usually faster - so even if you\u2019re not planning to run on TPU, adding `jit_compile=True` can improve your performance. Be sure to note the caveats below about XLA compatibility, though!\n\n</Tip>\n\n<Tip warning={true}>\n\n**Tip born of painful experience:** Although using `jit_compile=True` is a good way to get a speed boost and test if your CPU/GPU code is XLA-compatible, it can actually cause a lot of problems if you leave it in when actually training on TPU. XLA compilation will happen implicitly on TPU, so remember to remove that line before actually running your code on a TPU!\n\n</Tip>\n\n### How do I make my model XLA compatible?\n\nIn many cases, your code is probably XLA-compatible already! However, there are a few things that work in normal TensorFlow that don\u2019t work in XLA. We\u2019ve distilled them into three core rules below:\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** We\u2019ve put a lot of effort into rewriting our TensorFlow models and loss functions to be XLA-compatible. Our models and loss functions generally obey rule #1 and #2 by default, so you can skip over them if you\u2019re using `transformers` models. Don\u2019t forget about these rules when writing your own models and loss functions, though!\n\n</Tip>\n\n#### XLA Rule #1: Your code cannot have \u201cdata-dependent conditionals\u201d\n\nWhat that means is that any `if` statement cannot depend on values inside a `tf.Tensor`. For example, this code block cannot be compiled with XLA!\n\n```python\nif tf.reduce_sum(tensor) > 10:\n    tensor = tensor / 2.0\n```\n\nThis might seem very restrictive at first, but most neural net code doesn\u2019t need to do this. You can often get around this restriction by using `tf.cond` (see the documentation [here](https://www.tensorflow.org/api_docs/python/tf/cond)) or by removing the conditional and finding a clever math trick with indicator variables instead, like so:\n\n```python\nsum_over_10 = tf.cast(tf.reduce_sum(tensor) > 10, tf.float32)\ntensor = tensor / (1.0 + sum_over_10)\n```\n\nThis code has exactly the same effect as the code above, but by avoiding a conditional, we ensure it will compile with XLA without problems!\n\n#### XLA Rule #2: Your code cannot have \u201cdata-dependent shapes\u201d\n\nWhat this means is that the shape of all of the `tf.Tensor` objects in your code cannot depend on their values. For example, the function `tf.unique` cannot be compiled with XLA, because it returns a `tensor` containing one instance of each unique value in the input. The shape of this output will obviously be different depending on how repetitive the input `Tensor` was, and so XLA refuses to handle it!\n\nIn general, most neural network code obeys rule #2 by default. However, there are a few common cases where it becomes a problem. One very common one is when you use **label masking**, setting your labels to a negative value to indicate that those positions should be ignored when computing the loss. If you look at NumPy or PyTorch loss functions that support label masking, you will often see code like this that uses [boolean indexing](https://numpy.org/doc/stable/user/basics.indexing.html#boolean-array-indexing):\n\n```python\nlabel_mask = labels >= 0\nmasked_outputs = outputs[label_mask]\nmasked_labels = labels[label_mask]\nloss = compute_loss(masked_outputs, masked_labels)\nmean_loss = torch.mean(loss)\n```\n\nThis code is totally fine in NumPy or PyTorch, but it breaks in XLA! Why? Because the shape of `masked_outputs` and `masked_labels` depends on how many positions are masked - that makes it a **data-dependent shape.** However, just like for rule #1, we can often rewrite this code to yield exactly the same output without any data-dependent shapes.\n\n```python\nlabel_mask = tf.cast(labels >= 0, tf.float32)\nloss = compute_loss(outputs, labels)\nloss = loss * label_mask  # Set negative label positions to 0\nmean_loss = tf.reduce_sum(loss) / tf.reduce_sum(label_mask)\n```\n\nHere, we avoid data-dependent shapes by computing the loss for every position, but zeroing out the masked positions in both the numerator and denominator when we calculate the mean, which yields exactly the same result as the first block while maintaining XLA compatibility. Note that we use the same trick as in rule #1 - converting a `tf.bool` to `\n3,\tlabel_mask  # Set negative label positions to 0\nmean_loss = tf.reduce_sum(loss) / tf.reduce_sum(label_mask)\n```\n\nHere, we avoid data-dependent shapes by computing the loss for every position, but zeroing out the masked positions in both the numerator and denominator when we calculate the mean, which yields exactly the same result as the first block while maintaining XLA compatibility. Note that we use the same trick as in rule #1 - converting a `tf.bool` to `tf.float32` and using it as an indicator variable. This is a really useful trick, so remember it if you need to convert your own code to XLA!\n\n#### XLA Rule #3: XLA will need to recompile your model for every different input shape it sees\n\nThis is the big one. What this means is that if your input shapes are very variable, XLA will have to recompile your model over and over, which will create huge performance problems. This commonly arises in NLP models, where input texts have variable lengths after tokenization. In other modalities, static shapes are more common and this rule is much less of a problem.\n\nHow can you get around rule #3? The key is **padding** - if you pad all your inputs to the same length, and then use an `attention_mask`, you can get the same results as you\u2019d get from variable shapes, but without any XLA issues. However, excessive padding can cause severe slowdown too - if you pad all your samples to the maximum length in the whole dataset, you might end up with batches consisting endless padding tokens, which will waste a lot of compute and memory!\n\nThere isn\u2019t a perfect solution to this problem. However, you can try some tricks. One very useful trick is to **pad batches of samples up to a multiple of a number like 32 or 64 tokens.** This often only increases the number of tokens by a small amount, but it hugely reduces the number of unique input shapes, because every input shape now has to be a multiple of 32 or 64. Fewer unique input shapes means fewer XLA compilations!\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** Our tokenizers and data collators have methods that can help you here. You can use `padding=\"max_length\"` or `padding=\"longest\"` when calling tokenizers to get them to output padded data. Our tokenizers and data collators also have a `pad_to_multiple_of` argument that you can use to reduce the number of unique input shapes you see!\n\n</Tip>\n\n### How do I actually train my model on TPU?\n\nOnce your training is XLA-compatible and (if you\u2019re using TPU Node / Colab) your dataset has been prepared appropriately, running on TPU is surprisingly easy! All you really need to change in your code is to add a few lines to initialize your TPU, and to ensure that your model and dataset are created inside a `TPUStrategy` scope. Take a look at [our TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) to see this in action!\n\n### Summary\n\nThere was a lot in here, so let\u2019s summarize with a quick checklist you can follow when you want to get your model ready for TPU training:\n\n- Make sure your code follows the three rules of XLA\n- Compile your model with `jit_compile=True` on CPU/GPU and confirm that you can train it with XLA\n- Either load your dataset into memory or use a TPU-compatible dataset loading approach (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Migrate your code either to Colab (with accelerator set to \u201cTPU\u201d) or a TPU VM on Google Cloud\n- Add TPU initializer code (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Create your `TPUStrategy` and make sure dataset loading and model creation are inside the `strategy.scope()` (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Don\u2019t forget to take `jit_compile=True` out again when you move to TPU!\n- \ud83d\ude4f\ud83d\ude4f\ud83d\ude4f\ud83e\udd7a\ud83e\udd7a\ud83e\udd7a\n- Call model.fit()\n- You did it!\n    ```",
            "vector_context": "[Created at: 2025-03-24 13:17:32]\n!--Copyright 2023 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\nthe License. You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under the License is distributed on\nan \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n\n\u26a0\ufe0f Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be\nrendered properly in your Markdown viewer.\n\n-->\n\n# Training on TPU with TensorFlow\n\n<Tip>\n\nIf you don't need long explanations and just want TPU code samples to get started with, check out [our TPU example notebook!](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb)\n\n</Tip>\n\n### What is a TPU?\n\nA TPU is a **Tensor Processing Unit.** They are hardware designed by Google, which are used to greatly speed up the tensor computations within neural networks, much like GPUs. They can be used for both network training and inference. They are generally accessed through Google\u2019s cloud services, but small TPUs can also be accessed directly for free through Google Colab and Kaggle Kernels.\n\nBecause [all TensorFlow models in \ud83e\udd17 Transformers are Keras models](https://huggingface.co/blog/tensorflow-philosophy), most of the methods in this document are generally applicable to TPU training for any Keras model! However, there are a few points that are specific to the HuggingFace ecosystem (hug-o-system?) of Transformers and Datasets, and we\u2019ll make sure to flag them up when we get to them.\n\n### What kinds of TPU are available?\n\nNew users are often very confused by the range of TPUs, and the different ways to access them. The first key distinction to understand is the difference between **TPU Nodes** and **TPU VMs.**\n\nWhen you use a **TPU Node**, you are effectively indirectly accessing a remote TPU. You will need a separate VM, which will initialize your network and data pipeline and then forward them to the remote node. When you use a TPU on Google Colab, you are accessing it in the **TPU Node** style.\n\nUsing TPU Nodes can have some quite unexpected behaviour for people who aren\u2019t used to them! In particular, because the TPU is located on a physically different system to the machine you\u2019re running your Python code on, your data cannot be local to your machine - any data pipeline that loads from your machine\u2019s internal storage will totally fail! Instead, data must be stored in Google Cloud Storage where your data pipeline can still access it, even when the pipeline is running on the remote TPU node.\n\n<Tip>\n\nIf you can fit all your data in memory as `np.ndarray` or `tf.Tensor`, then you can `fit()` on that data even when using Colab or a TPU Node, without needing to upload it to Google Cloud Storage.\n\n</Tip>\n\n<Tip>\n\n**\ud83e\udd17Specific Hugging Face Tip\ud83e\udd17:** The methods `Dataset.to_tf_dataset()` and its higher-level wrapper `model.prepare_tf_dataset()` , which you will see throughout our TF code examples, will both fail on a TPU Node. The reason for this is that even though they create a `tf.data.Dataset` it is not a \u201cpure\u201d `tf.data` pipeline and uses `tf.numpy_function` or `Dataset.from_generator()` to stream data from the underlying HuggingFace `Dataset`. This HuggingFace `Dataset` is backed by data that is on a local disc and which the remote TPU Node will not be able to read.\n\n</Tip>\n\nThe second way to access a TPU is via a **TPU VM.** When using a TPU VM, you connect directly to the machine that the TPU is attached to, much like training on a GPU VM. TPU VMs are generally easier to work with, particularly when it comes to your data pipeline. All of the above warnings do not apply to TPU VMs!\n\nThis is an opinionated document, so here\u2019s our opinion: **Avoid using TPU Node if possible.** It is more confusing and more difficult to debug than TPU VMs. It is also likely to be unsupported in future - Google\u2019s latest TPU, TPUv4, can only be accessed as a TPU VM, which suggests that TPU Nodes are increasingly going to become a \u201clegacy\u201d access method. However, we understand that the only free TPU access is on Colab and Kaggle Kernels, which uses TPU Node - so we\u2019ll try to explain how to handle it if you have to! Check the [TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) for code samples that explain this in more detail.\n\n### What sizes of TPU are available?\n\nA single TPU (a v2-8/v3-8/v4-8) runs 8 replicas. TPUs exist in **pods** that can run hundreds or thousands of replicas simultaneously. When you use more than a single TPU but less than a whole pod (for example, a v3-32), your TPU fleet is referred to as a **pod slice.**\n\nWhen you access a free TPU via Colab, you generally get a single v2-8 TPU.\n\n### I keep hearing about this XLA thing. What\u2019s XLA, and how does it relate to TPUs?\n\nXLA is an optimizing compiler, used by both TensorFlow and JAX. In JAX it is the only compiler, whereas in TensorFlow it is optional\n--New Chunk--\n[Created at: 2025-03-24 13:17:32]\n(for example, a v3-32), your TPU fleet is referred to as a **pod slice.**\n\nWhen you access a free TPU via Colab, you generally get a single v2-8 TPU.\n\n### I keep hearing about this XLA thing. What\u2019s XLA, and how does it relate to TPUs?\n\nXLA is an optimizing compiler, used by both TensorFlow and JAX. In JAX it is the only compiler, whereas in TensorFlow it is optional (but mandatory on TPU!). The easiest way to enable it when training a Keras model is to pass the argument `jit_compile=True` to `model.compile()`. If you don\u2019t get any errors and performance is good, that\u2019s a great sign that you\u2019re ready to move to TPU!\n\nDebugging on TPU is generally a bit harder than on CPU/GPU, so we recommend getting your code running on CPU/GPU with XLA first before trying it on TPU. You don\u2019t have to train for long, of course - just for a few steps to make sure that your model and data pipeline are working like you expect them to.\n\n<Tip>\n\nXLA compiled code is usually faster - so even if you\u2019re not planning to run on TPU, adding `jit_compile=True` can improve your performance. Be sure to note the caveats below about XLA compatibility, though!\n\n</Tip>\n\n<Tip warning={true}>\n\n**Tip born of painful experience:** Although using `jit_compile=True` is a good way to get a speed boost and test if your CPU/GPU code is XLA-compatible, it can actually cause a lot of problems if you leave it in when actually training on TPU. XLA compilation will happen implicitly on TPU, so remember to remove that line before actually running your code on a TPU!\n\n</Tip>\n\n### How do I make my model XLA compatible?\n\nIn many cases, your code is probably XLA-compatible already! However, there are a few things that work in normal TensorFlow that don\u2019t work in XLA. We\u2019ve distilled them into three core rules below:\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** We\u2019ve put a lot of effort into rewriting our TensorFlow models and loss functions to be XLA-compatible. Our models and loss functions generally obey rule #1 and #2 by default, so you can skip over them if you\u2019re using `transformers` models. Don\u2019t forget about these rules when writing your own models and loss functions, though!\n\n</Tip>\n\n#### XLA Rule #1: Your code cannot have \u201cdata-dependent conditionals\u201d\n\nWhat that means is that any `if` statement cannot depend on values inside a `tf.Tensor`. For example, this code block cannot be compiled with XLA!\n\n```python\nif tf.reduce_sum(tensor) > 10:\n    tensor = tensor / 2.0\n```\n\nThis might seem very restrictive at first, but most neural net code doesn\u2019t need to do this. You can often get around this restriction by using `tf.cond` (see the documentation [here](https://www.tensorflow.org/api_docs/python/tf/cond)) or by removing the conditional and finding a clever math trick with indicator variables instead, like so:\n\n```python\nsum_over_10 = tf.cast(tf.reduce_sum(tensor) > 10, tf.float32)\ntensor = tensor / (1.0 + sum_over_10)\n```\n\nThis code has exactly the same effect as the code above, but by avoiding a conditional, we ensure it will compile with XLA without problems!\n\n#### XLA Rule #2: Your code cannot have \u201cdata-dependent shapes\u201d\n\nWhat this means is that the shape of all of the `tf.Tensor` objects in your code cannot depend on their values. For example, the function `tf.unique` cannot be compiled with XLA, because it returns a `tensor` containing one instance of each unique value in the input. The shape of this output will obviously be different depending on how repetitive the input `Tensor` was, and so XLA refuses to handle it!\n\nIn general, most neural network code obeys rule #2 by default. However, there are a few common cases where it becomes a problem. One very common one is when you use **label masking**, setting your labels to a negative value to indicate that those positions should be ignored when computing the loss. If you look at NumPy or PyTorch loss functions that support label masking, you will often see code like this that uses [boolean indexing](https://numpy.org/doc/stable/user/basics.indexing.html#boolean-array-indexing):\n\n```python\nlabel_mask = labels >= 0\nmasked_outputs = outputs[label_mask]\nmasked_labels = labels[label_mask]\nloss = compute_loss(masked_outputs, masked_labels)\nmean_loss = torch.mean(loss)\n```\n\nThis code is totally fine in NumPy or PyTorch, but it breaks in XLA! Why? Because the shape of `masked_outputs` and `masked_labels` depends on how many positions are masked - that makes it a **data-dependent shape.** However, just like for rule #1, we can often rewrite this code to yield exactly the same output without any data-dependent shapes.\n\n```python\nlabel_mask = tf.cast(labels >= 0, tf.float32)\nloss = compute_loss(outputs, labels)\nloss = loss * label_mask  # Set negative label positions to 0\nmean_loss = tf.reduce_sum(loss) / tf.reduce_sum(label_mask)\n```\n\nHere, we avoid data-dependent shapes by computing the loss for every position, but zeroing out the masked positions in both the numerator and denominator when we calculate the mean, which yields exactly the same result as the first block while maintaining XLA compatibility. Note that we use the same trick as in rule #1 - converting a `tf.bool` to `\n--New Chunk--\n[Created at: 2025-03-24 13:17:32]\nlabel_mask  # Set negative label positions to 0\nmean_loss = tf.reduce_sum(loss) / tf.reduce_sum(label_mask)\n```\n\nHere, we avoid data-dependent shapes by computing the loss for every position, but zeroing out the masked positions in both the numerator and denominator when we calculate the mean, which yields exactly the same result as the first block while maintaining XLA compatibility. Note that we use the same trick as in rule #1 - converting a `tf.bool` to `tf.float32` and using it as an indicator variable. This is a really useful trick, so remember it if you need to convert your own code to XLA!\n\n#### XLA Rule #3: XLA will need to recompile your model for every different input shape it sees\n\nThis is the big one. What this means is that if your input shapes are very variable, XLA will have to recompile your model over and over, which will create huge performance problems. This commonly arises in NLP models, where input texts have variable lengths after tokenization. In other modalities, static shapes are more common and this rule is much less of a problem.\n\nHow can you get around rule #3? The key is **padding** - if you pad all your inputs to the same length, and then use an `attention_mask`, you can get the same results as you\u2019d get from variable shapes, but without any XLA issues. However, excessive padding can cause severe slowdown too - if you pad all your samples to the maximum length in the whole dataset, you might end up with batches consisting endless padding tokens, which will waste a lot of compute and memory!\n\nThere isn\u2019t a perfect solution to this problem. However, you can try some tricks. One very useful trick is to **pad batches of samples up to a multiple of a number like 32 or 64 tokens.** This often only increases the number of tokens by a small amount, but it hugely reduces the number of unique input shapes, because every input shape now has to be a multiple of 32 or 64. Fewer unique input shapes means fewer XLA compilations!\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** Our tokenizers and data collators have methods that can help you here. You can use `padding=\"max_length\"` or `padding=\"longest\"` when calling tokenizers to get them to output padded data. Our tokenizers and data collators also have a `pad_to_multiple_of` argument that you can use to reduce the number of unique input shapes you see!\n\n</Tip>\n\n### How do I actually train my model on TPU?\n\nOnce your training is XLA-compatible and (if you\u2019re using TPU Node / Colab) your dataset has been prepared appropriately, running on TPU is surprisingly easy! All you really need to change in your code is to add a few lines to initialize your TPU, and to ensure that your model and dataset are created inside a `TPUStrategy` scope. Take a look at [our TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) to see this in action!\n\n### Summary\n\nThere was a lot in here, so let\u2019s summarize with a quick checklist you can follow when you want to get your model ready for TPU training:\n\n- Make sure your code follows the three rules of XLA\n- Compile your model with `jit_compile=True` on CPU/GPU and confirm that you can train it with XLA\n- Either load your dataset into memory or use a TPU-compatible dataset loading approach (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Migrate your code either to Colab (with accelerator set to \u201cTPU\u201d) or a TPU VM on Google Cloud\n- Add TPU initializer code (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Create your `TPUStrategy` and make sure dataset loading and model creation are inside the `strategy.scope()` (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Don\u2019t forget to take `jit_compile=True` out again when you move to TPU!\n- \ud83d\ude4f\ud83d\ude4f\ud83d\ude4f\ud83e\udd7a\ud83e\udd7a\ud83e\udd7a\n- Call model.fit()\n- You did it!"
        }
    },
    {
        "context": "</Tip>\n\nThe second way to access a TPU is via a **TPU VM.** When using a TPU VM, you connect directly to the machine that the TPU is attached to, much like training on a GPU VM. TPU VMs are generally easier to work with, particularly when it comes to your data pipeline. All of the above warnings do not apply to TPU VMs!\n\nThis is an opinionated document, so here\u2019s our opinion: **Avoid using TPU Node if possible.** It is more confusing and more difficult to debug than TPU VMs. It is also likely to be unsupported in future - Google\u2019s latest TPU, TPUv4, can only be accessed as a TPU VM, which suggests that TPU Nodes are increasingly going to become a \u201clegacy\u201d access method. However, we understand that the only free TPU access is on Colab and Kaggle Kernels, which uses TPU Node - so we\u2019ll try to explain how to handle it if you have to! Check the [TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) for code samples that explain this in more detail.\n\n### What sizes of TPU are available?\n\nA single TPU (a v2-8/v3-8/v4-8) runs 8 replicas. TPUs exist in **pods** that can run hundreds or thousands of replicas simultaneously. When you use more than a single TPU but less than a whole pod (for example, a v3-32), your TPU fleet is referred to as a **pod slice.**\n\nWhen you access a free TPU via Colab, you generally get a single v2-8 TPU.\n\n### I keep hearing about this XLA thing. What\u2019s XLA, and how does it relate to TPUs?\n\nXLA is an optimizing compiler, used by both TensorFlow and JAX. In JAX it is the only compiler, whereas in TensorFlow it is optional (but mandatory on TPU!). The easiest way to enable it when training a Keras model is to pass the argument `jit_compile=True` to `model.compile()`. If you don\u2019t get any errors and performance is good, that\u2019s a great sign that you\u2019re ready to move to TPU!",
        "question": "Why is it recommended to avoid using TPU Node?",
        "answer": "TPU Node is more confusing and difficult to debug than TPU VMs, and it is likely to be unsupported in the future.",
        "source_doc": "huggingface/transformers/blob/main/docs/source/en/perf_train_tpu_tf.md",
        "rag_answer": null,
        "rag_context": null,
        "rag_score": null,
        "rag_feedback": null
    },
    {
        "sample_idx": 51,
        "question": "How many replicas can a single TPU run?",
        "answer": "A single TPU can run 8 replicas.",
        "rag_answer": "According to the provided Data Sources, a single TPU (a v2-8/v3-8/v4-8) can run 8 replicas.",
        "rag_score": null,
        "rag_feedback": null,
        "rag_context": {
            "kg_context": "-----Entities-----\n    ```csv\n    id,\tentity,\ttype,\tdescription,\trankcreated_at\n1,\tGoogle,organization,Google is the company that designs and provides TPUs, which are used to speed up tensor computations within neural networks.,3,2025-03-24 13:18:20\n2,\tTPU,technology,TPU is a Tensor Processing Unit, a hardware designed by Google to speed up tensor computations within neural networks.<SEP>TPU is a type of hardware accelerator designed for machine learning workloads.<SEP>TPU is a type of hardware accelerator used for machine learning computations.,4,2025-03-24 13:18:20\n3,\tColab,geo,Colab is a cloud-based platform for data science and machine learning, provided by Google.<SEP>Colab is a platform where users can access a free TPU.,3,2025-03-24 13:18:20\n4,\tGoogle Cloud,organization,Google Cloud is a cloud computing platform that provides infrastructure and services for building and deploying machine learning models.,1,2025-03-24 13:18:20\n5,\tTensor Processing Unit,category,Tensor Processing Unit is a hardware designed by Google to speed up tensor computations within neural networks.,0,UNKNOWN\n6,\tGoogle,organization,Google is the company that designs and provides TPUs, which are used to speed up tensor computations within neural networks.,3,UNKNOWN\n7,\tTPU,technology,TPU is a Tensor Processing Unit, a hardware designed by Google to speed up tensor computations within neural networks.<SEP>TPU is a type of hardware accelerator designed for machine learning workloads.<SEP>TPU is a type of hardware accelerator used for machine learning computations.,4,UNKNOWN\n    ```\n    -----Relationships-----\n    ```csv\n    id,\tsource,\ttarget,\tdescription,\tkeywords,\tweight,\trank,\tcreated_at\n1,\tGoogle,TPU,Google designs and provides TPUs, which are used to speed up tensor computations within neural networks.,hardware design, acceleration,18.0,7,2025-03-24 13:18:20\n2,\tColab,TPU,Colab provides access to a free TPU for users.,platform, hardware acceleration,16.0,7,2025-03-24 13:18:20\n3,\tGoogle Cloud,TPU,Google Cloud provides infrastructure and services for building and deploying machine learning models, including TPU hardware.,infrastructure provision, hardware acceleration,14.0,5,2025-03-24 13:18:20\n4,\tTPU,XLA,XLA compiles TensorFlow graphs into executable code for TPU hardware.<SEP>XLA is used to optimize code for TPU hardware.,compilation, hardware acceleration<SEP>compiler, hardware optimization,36.0,10,UNKNOWN\n5,\tGoogle,TPU,Google designs and provides TPUs, which are used to speed up tensor computations within neural networks.,hardware design, acceleration,18.0,7,UNKNOWN\n6,\tColab,TPU,Colab provides access to a free TPU for users.,platform, hardware acceleration,16.0,7,UNKNOWN\n7,\tColab,Google,Colab is a cloud-based platform provided by Google for data science and machine learning.,platform provision, cloud computing,16.0,6,UNKNOWN\n8,\tGoogle Cloud,TPU,Google Cloud provides infrastructure and services for building and deploying machine learning models, including TPU hardware.,infrastructure provision, hardware acceleration,14.0,5,UNKNOWN\n9,\tGoogle,Kaggle Kernels,Kaggle Kernels is a cloud-based platform provided by Google for data science and machine learning competitions.,platform provision, cloud computing,16.0,4,UNKNOWN\n    ```\n    -----Sources-----\n    ```csv\n    id,\tcontent\n1,\t!--Copyright 2023 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\nthe License. You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under the License is distributed on\nan \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n\n\u26a0\ufe0f Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be\nrendered properly in your Markdown viewer.\n\n-->\n\n# Training on TPU with TensorFlow\n\n<Tip>\n\nIf you don't need long explanations and just want TPU code samples to get started with, check out [our TPU example notebook!](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb)\n\n</Tip>\n\n### What is a TPU?\n\nA TPU is a **Tensor Processing Unit.** They are hardware designed by Google, which are used to greatly speed up the tensor computations within neural networks, much like GPUs. They can be used for both network training and inference. They are generally accessed through Google\u2019s cloud services, but small TPUs can also be accessed directly for free through Google Colab and Kaggle Kernels.\n\nBecause [all TensorFlow models in \ud83e\udd17 Transformers are Keras models](https://huggingface.co/blog/tensorflow-philosophy), most of the methods in this document are generally applicable to TPU training for any Keras model! However, there are a few points that are specific to the HuggingFace ecosystem (hug-o-system?) of Transformers and Datasets, and we\u2019ll make sure to flag them up when we get to them.\n\n### What kinds of TPU are available?\n\nNew users are often very confused by the range of TPUs, and the different ways to access them. The first key distinction to understand is the difference between **TPU Nodes** and **TPU VMs.**\n\nWhen you use a **TPU Node**, you are effectively indirectly accessing a remote TPU. You will need a separate VM, which will initialize your network and data pipeline and then forward them to the remote node. When you use a TPU on Google Colab, you are accessing it in the **TPU Node** style.\n\nUsing TPU Nodes can have some quite unexpected behaviour for people who aren\u2019t used to them! In particular, because the TPU is located on a physically different system to the machine you\u2019re running your Python code on, your data cannot be local to your machine - any data pipeline that loads from your machine\u2019s internal storage will totally fail! Instead, data must be stored in Google Cloud Storage where your data pipeline can still access it, even when the pipeline is running on the remote TPU node.\n\n<Tip>\n\nIf you can fit all your data in memory as `np.ndarray` or `tf.Tensor`, then you can `fit()` on that data even when using Colab or a TPU Node, without needing to upload it to Google Cloud Storage.\n\n</Tip>\n\n<Tip>\n\n**\ud83e\udd17Specific Hugging Face Tip\ud83e\udd17:** The methods `Dataset.to_tf_dataset()` and its higher-level wrapper `model.prepare_tf_dataset()` , which you will see throughout our TF code examples, will both fail on a TPU Node. The reason for this is that even though they create a `tf.data.Dataset` it is not a \u201cpure\u201d `tf.data` pipeline and uses `tf.numpy_function` or `Dataset.from_generator()` to stream data from the underlying HuggingFace `Dataset`. This HuggingFace `Dataset` is backed by data that is on a local disc and which the remote TPU Node will not be able to read.\n\n</Tip>\n\nThe second way to access a TPU is via a **TPU VM.** When using a TPU VM, you connect directly to the machine that the TPU is attached to, much like training on a GPU VM. TPU VMs are generally easier to work with, particularly when it comes to your data pipeline. All of the above warnings do not apply to TPU VMs!\n\nThis is an opinionated document, so here\u2019s our opinion: **Avoid using TPU Node if possible.** It is more confusing and more difficult to debug than TPU VMs. It is also likely to be unsupported in future - Google\u2019s latest TPU, TPUv4, can only be accessed as a TPU VM, which suggests that TPU Nodes are increasingly going to become a \u201clegacy\u201d access method. However, we understand that the only free TPU access is on Colab and Kaggle Kernels, which uses TPU Node - so we\u2019ll try to explain how to handle it if you have to! Check the [TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) for code samples that explain this in more detail.\n\n### What sizes of TPU are available?\n\nA single TPU (a v2-8/v3-8/v4-8) runs 8 replicas. TPUs exist in **pods** that can run hundreds or thousands of replicas simultaneously. When you use more than a single TPU but less than a whole pod (for example, a v3-32), your TPU fleet is referred to as a **pod slice.**\n\nWhen you access a free TPU via Colab, you generally get a single v2-8 TPU.\n\n### I keep hearing about this XLA thing. What\u2019s XLA, and how does it relate to TPUs?\n\nXLA is an optimizing compiler, used by both TensorFlow and JAX. In JAX it is the only compiler, whereas in TensorFlow it is optional\n2,\t(for example, a v3-32), your TPU fleet is referred to as a **pod slice.**\n\nWhen you access a free TPU via Colab, you generally get a single v2-8 TPU.\n\n### I keep hearing about this XLA thing. What\u2019s XLA, and how does it relate to TPUs?\n\nXLA is an optimizing compiler, used by both TensorFlow and JAX. In JAX it is the only compiler, whereas in TensorFlow it is optional (but mandatory on TPU!). The easiest way to enable it when training a Keras model is to pass the argument `jit_compile=True` to `model.compile()`. If you don\u2019t get any errors and performance is good, that\u2019s a great sign that you\u2019re ready to move to TPU!\n\nDebugging on TPU is generally a bit harder than on CPU/GPU, so we recommend getting your code running on CPU/GPU with XLA first before trying it on TPU. You don\u2019t have to train for long, of course - just for a few steps to make sure that your model and data pipeline are working like you expect them to.\n\n<Tip>\n\nXLA compiled code is usually faster - so even if you\u2019re not planning to run on TPU, adding `jit_compile=True` can improve your performance. Be sure to note the caveats below about XLA compatibility, though!\n\n</Tip>\n\n<Tip warning={true}>\n\n**Tip born of painful experience:** Although using `jit_compile=True` is a good way to get a speed boost and test if your CPU/GPU code is XLA-compatible, it can actually cause a lot of problems if you leave it in when actually training on TPU. XLA compilation will happen implicitly on TPU, so remember to remove that line before actually running your code on a TPU!\n\n</Tip>\n\n### How do I make my model XLA compatible?\n\nIn many cases, your code is probably XLA-compatible already! However, there are a few things that work in normal TensorFlow that don\u2019t work in XLA. We\u2019ve distilled them into three core rules below:\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** We\u2019ve put a lot of effort into rewriting our TensorFlow models and loss functions to be XLA-compatible. Our models and loss functions generally obey rule #1 and #2 by default, so you can skip over them if you\u2019re using `transformers` models. Don\u2019t forget about these rules when writing your own models and loss functions, though!\n\n</Tip>\n\n#### XLA Rule #1: Your code cannot have \u201cdata-dependent conditionals\u201d\n\nWhat that means is that any `if` statement cannot depend on values inside a `tf.Tensor`. For example, this code block cannot be compiled with XLA!\n\n```python\nif tf.reduce_sum(tensor) > 10:\n    tensor = tensor / 2.0\n```\n\nThis might seem very restrictive at first, but most neural net code doesn\u2019t need to do this. You can often get around this restriction by using `tf.cond` (see the documentation [here](https://www.tensorflow.org/api_docs/python/tf/cond)) or by removing the conditional and finding a clever math trick with indicator variables instead, like so:\n\n```python\nsum_over_10 = tf.cast(tf.reduce_sum(tensor) > 10, tf.float32)\ntensor = tensor / (1.0 + sum_over_10)\n```\n\nThis code has exactly the same effect as the code above, but by avoiding a conditional, we ensure it will compile with XLA without problems!\n\n#### XLA Rule #2: Your code cannot have \u201cdata-dependent shapes\u201d\n\nWhat this means is that the shape of all of the `tf.Tensor` objects in your code cannot depend on their values. For example, the function `tf.unique` cannot be compiled with XLA, because it returns a `tensor` containing one instance of each unique value in the input. The shape of this output will obviously be different depending on how repetitive the input `Tensor` was, and so XLA refuses to handle it!\n\nIn general, most neural network code obeys rule #2 by default. However, there are a few common cases where it becomes a problem. One very common one is when you use **label masking**, setting your labels to a negative value to indicate that those positions should be ignored when computing the loss. If you look at NumPy or PyTorch loss functions that support label masking, you will often see code like this that uses [boolean indexing](https://numpy.org/doc/stable/user/basics.indexing.html#boolean-array-indexing):\n\n```python\nlabel_mask = labels >= 0\nmasked_outputs = outputs[label_mask]\nmasked_labels = labels[label_mask]\nloss = compute_loss(masked_outputs, masked_labels)\nmean_loss = torch.mean(loss)\n```\n\nThis code is totally fine in NumPy or PyTorch, but it breaks in XLA! Why? Because the shape of `masked_outputs` and `masked_labels` depends on how many positions are masked - that makes it a **data-dependent shape.** However, just like for rule #1, we can often rewrite this code to yield exactly the same output without any data-dependent shapes.\n\n```python\nlabel_mask = tf.cast(labels >= 0, tf.float32)\nloss = compute_loss(outputs, labels)\nloss = loss * label_mask  # Set negative label positions to 0\nmean_loss = tf.reduce_sum(loss) / tf.reduce_sum(label_mask)\n```\n\nHere, we avoid data-dependent shapes by computing the loss for every position, but zeroing out the masked positions in both the numerator and denominator when we calculate the mean, which yields exactly the same result as the first block while maintaining XLA compatibility. Note that we use the same trick as in rule #1 - converting a `tf.bool` to `\n3,\tlabel_mask  # Set negative label positions to 0\nmean_loss = tf.reduce_sum(loss) / tf.reduce_sum(label_mask)\n```\n\nHere, we avoid data-dependent shapes by computing the loss for every position, but zeroing out the masked positions in both the numerator and denominator when we calculate the mean, which yields exactly the same result as the first block while maintaining XLA compatibility. Note that we use the same trick as in rule #1 - converting a `tf.bool` to `tf.float32` and using it as an indicator variable. This is a really useful trick, so remember it if you need to convert your own code to XLA!\n\n#### XLA Rule #3: XLA will need to recompile your model for every different input shape it sees\n\nThis is the big one. What this means is that if your input shapes are very variable, XLA will have to recompile your model over and over, which will create huge performance problems. This commonly arises in NLP models, where input texts have variable lengths after tokenization. In other modalities, static shapes are more common and this rule is much less of a problem.\n\nHow can you get around rule #3? The key is **padding** - if you pad all your inputs to the same length, and then use an `attention_mask`, you can get the same results as you\u2019d get from variable shapes, but without any XLA issues. However, excessive padding can cause severe slowdown too - if you pad all your samples to the maximum length in the whole dataset, you might end up with batches consisting endless padding tokens, which will waste a lot of compute and memory!\n\nThere isn\u2019t a perfect solution to this problem. However, you can try some tricks. One very useful trick is to **pad batches of samples up to a multiple of a number like 32 or 64 tokens.** This often only increases the number of tokens by a small amount, but it hugely reduces the number of unique input shapes, because every input shape now has to be a multiple of 32 or 64. Fewer unique input shapes means fewer XLA compilations!\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** Our tokenizers and data collators have methods that can help you here. You can use `padding=\"max_length\"` or `padding=\"longest\"` when calling tokenizers to get them to output padded data. Our tokenizers and data collators also have a `pad_to_multiple_of` argument that you can use to reduce the number of unique input shapes you see!\n\n</Tip>\n\n### How do I actually train my model on TPU?\n\nOnce your training is XLA-compatible and (if you\u2019re using TPU Node / Colab) your dataset has been prepared appropriately, running on TPU is surprisingly easy! All you really need to change in your code is to add a few lines to initialize your TPU, and to ensure that your model and dataset are created inside a `TPUStrategy` scope. Take a look at [our TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) to see this in action!\n\n### Summary\n\nThere was a lot in here, so let\u2019s summarize with a quick checklist you can follow when you want to get your model ready for TPU training:\n\n- Make sure your code follows the three rules of XLA\n- Compile your model with `jit_compile=True` on CPU/GPU and confirm that you can train it with XLA\n- Either load your dataset into memory or use a TPU-compatible dataset loading approach (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Migrate your code either to Colab (with accelerator set to \u201cTPU\u201d) or a TPU VM on Google Cloud\n- Add TPU initializer code (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Create your `TPUStrategy` and make sure dataset loading and model creation are inside the `strategy.scope()` (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Don\u2019t forget to take `jit_compile=True` out again when you move to TPU!\n- \ud83d\ude4f\ud83d\ude4f\ud83d\ude4f\ud83e\udd7a\ud83e\udd7a\ud83e\udd7a\n- Call model.fit()\n- You did it!\n    ```",
            "vector_context": "[Created at: 2025-03-24 13:17:32]\n!--Copyright 2023 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\nthe License. You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under the License is distributed on\nan \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n\n\u26a0\ufe0f Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be\nrendered properly in your Markdown viewer.\n\n-->\n\n# Training on TPU with TensorFlow\n\n<Tip>\n\nIf you don't need long explanations and just want TPU code samples to get started with, check out [our TPU example notebook!](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb)\n\n</Tip>\n\n### What is a TPU?\n\nA TPU is a **Tensor Processing Unit.** They are hardware designed by Google, which are used to greatly speed up the tensor computations within neural networks, much like GPUs. They can be used for both network training and inference. They are generally accessed through Google\u2019s cloud services, but small TPUs can also be accessed directly for free through Google Colab and Kaggle Kernels.\n\nBecause [all TensorFlow models in \ud83e\udd17 Transformers are Keras models](https://huggingface.co/blog/tensorflow-philosophy), most of the methods in this document are generally applicable to TPU training for any Keras model! However, there are a few points that are specific to the HuggingFace ecosystem (hug-o-system?) of Transformers and Datasets, and we\u2019ll make sure to flag them up when we get to them.\n\n### What kinds of TPU are available?\n\nNew users are often very confused by the range of TPUs, and the different ways to access them. The first key distinction to understand is the difference between **TPU Nodes** and **TPU VMs.**\n\nWhen you use a **TPU Node**, you are effectively indirectly accessing a remote TPU. You will need a separate VM, which will initialize your network and data pipeline and then forward them to the remote node. When you use a TPU on Google Colab, you are accessing it in the **TPU Node** style.\n\nUsing TPU Nodes can have some quite unexpected behaviour for people who aren\u2019t used to them! In particular, because the TPU is located on a physically different system to the machine you\u2019re running your Python code on, your data cannot be local to your machine - any data pipeline that loads from your machine\u2019s internal storage will totally fail! Instead, data must be stored in Google Cloud Storage where your data pipeline can still access it, even when the pipeline is running on the remote TPU node.\n\n<Tip>\n\nIf you can fit all your data in memory as `np.ndarray` or `tf.Tensor`, then you can `fit()` on that data even when using Colab or a TPU Node, without needing to upload it to Google Cloud Storage.\n\n</Tip>\n\n<Tip>\n\n**\ud83e\udd17Specific Hugging Face Tip\ud83e\udd17:** The methods `Dataset.to_tf_dataset()` and its higher-level wrapper `model.prepare_tf_dataset()` , which you will see throughout our TF code examples, will both fail on a TPU Node. The reason for this is that even though they create a `tf.data.Dataset` it is not a \u201cpure\u201d `tf.data` pipeline and uses `tf.numpy_function` or `Dataset.from_generator()` to stream data from the underlying HuggingFace `Dataset`. This HuggingFace `Dataset` is backed by data that is on a local disc and which the remote TPU Node will not be able to read.\n\n</Tip>\n\nThe second way to access a TPU is via a **TPU VM.** When using a TPU VM, you connect directly to the machine that the TPU is attached to, much like training on a GPU VM. TPU VMs are generally easier to work with, particularly when it comes to your data pipeline. All of the above warnings do not apply to TPU VMs!\n\nThis is an opinionated document, so here\u2019s our opinion: **Avoid using TPU Node if possible.** It is more confusing and more difficult to debug than TPU VMs. It is also likely to be unsupported in future - Google\u2019s latest TPU, TPUv4, can only be accessed as a TPU VM, which suggests that TPU Nodes are increasingly going to become a \u201clegacy\u201d access method. However, we understand that the only free TPU access is on Colab and Kaggle Kernels, which uses TPU Node - so we\u2019ll try to explain how to handle it if you have to! Check the [TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) for code samples that explain this in more detail.\n\n### What sizes of TPU are available?\n\nA single TPU (a v2-8/v3-8/v4-8) runs 8 replicas. TPUs exist in **pods** that can run hundreds or thousands of replicas simultaneously. When you use more than a single TPU but less than a whole pod (for example, a v3-32), your TPU fleet is referred to as a **pod slice.**\n\nWhen you access a free TPU via Colab, you generally get a single v2-8 TPU.\n\n### I keep hearing about this XLA thing. What\u2019s XLA, and how does it relate to TPUs?\n\nXLA is an optimizing compiler, used by both TensorFlow and JAX. In JAX it is the only compiler, whereas in TensorFlow it is optional\n--New Chunk--\n[Created at: 2025-03-24 13:17:32]\n(for example, a v3-32), your TPU fleet is referred to as a **pod slice.**\n\nWhen you access a free TPU via Colab, you generally get a single v2-8 TPU.\n\n### I keep hearing about this XLA thing. What\u2019s XLA, and how does it relate to TPUs?\n\nXLA is an optimizing compiler, used by both TensorFlow and JAX. In JAX it is the only compiler, whereas in TensorFlow it is optional (but mandatory on TPU!). The easiest way to enable it when training a Keras model is to pass the argument `jit_compile=True` to `model.compile()`. If you don\u2019t get any errors and performance is good, that\u2019s a great sign that you\u2019re ready to move to TPU!\n\nDebugging on TPU is generally a bit harder than on CPU/GPU, so we recommend getting your code running on CPU/GPU with XLA first before trying it on TPU. You don\u2019t have to train for long, of course - just for a few steps to make sure that your model and data pipeline are working like you expect them to.\n\n<Tip>\n\nXLA compiled code is usually faster - so even if you\u2019re not planning to run on TPU, adding `jit_compile=True` can improve your performance. Be sure to note the caveats below about XLA compatibility, though!\n\n</Tip>\n\n<Tip warning={true}>\n\n**Tip born of painful experience:** Although using `jit_compile=True` is a good way to get a speed boost and test if your CPU/GPU code is XLA-compatible, it can actually cause a lot of problems if you leave it in when actually training on TPU. XLA compilation will happen implicitly on TPU, so remember to remove that line before actually running your code on a TPU!\n\n</Tip>\n\n### How do I make my model XLA compatible?\n\nIn many cases, your code is probably XLA-compatible already! However, there are a few things that work in normal TensorFlow that don\u2019t work in XLA. We\u2019ve distilled them into three core rules below:\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** We\u2019ve put a lot of effort into rewriting our TensorFlow models and loss functions to be XLA-compatible. Our models and loss functions generally obey rule #1 and #2 by default, so you can skip over them if you\u2019re using `transformers` models. Don\u2019t forget about these rules when writing your own models and loss functions, though!\n\n</Tip>\n\n#### XLA Rule #1: Your code cannot have \u201cdata-dependent conditionals\u201d\n\nWhat that means is that any `if` statement cannot depend on values inside a `tf.Tensor`. For example, this code block cannot be compiled with XLA!\n\n```python\nif tf.reduce_sum(tensor) > 10:\n    tensor = tensor / 2.0\n```\n\nThis might seem very restrictive at first, but most neural net code doesn\u2019t need to do this. You can often get around this restriction by using `tf.cond` (see the documentation [here](https://www.tensorflow.org/api_docs/python/tf/cond)) or by removing the conditional and finding a clever math trick with indicator variables instead, like so:\n\n```python\nsum_over_10 = tf.cast(tf.reduce_sum(tensor) > 10, tf.float32)\ntensor = tensor / (1.0 + sum_over_10)\n```\n\nThis code has exactly the same effect as the code above, but by avoiding a conditional, we ensure it will compile with XLA without problems!\n\n#### XLA Rule #2: Your code cannot have \u201cdata-dependent shapes\u201d\n\nWhat this means is that the shape of all of the `tf.Tensor` objects in your code cannot depend on their values. For example, the function `tf.unique` cannot be compiled with XLA, because it returns a `tensor` containing one instance of each unique value in the input. The shape of this output will obviously be different depending on how repetitive the input `Tensor` was, and so XLA refuses to handle it!\n\nIn general, most neural network code obeys rule #2 by default. However, there are a few common cases where it becomes a problem. One very common one is when you use **label masking**, setting your labels to a negative value to indicate that those positions should be ignored when computing the loss. If you look at NumPy or PyTorch loss functions that support label masking, you will often see code like this that uses [boolean indexing](https://numpy.org/doc/stable/user/basics.indexing.html#boolean-array-indexing):\n\n```python\nlabel_mask = labels >= 0\nmasked_outputs = outputs[label_mask]\nmasked_labels = labels[label_mask]\nloss = compute_loss(masked_outputs, masked_labels)\nmean_loss = torch.mean(loss)\n```\n\nThis code is totally fine in NumPy or PyTorch, but it breaks in XLA! Why? Because the shape of `masked_outputs` and `masked_labels` depends on how many positions are masked - that makes it a **data-dependent shape.** However, just like for rule #1, we can often rewrite this code to yield exactly the same output without any data-dependent shapes.\n\n```python\nlabel_mask = tf.cast(labels >= 0, tf.float32)\nloss = compute_loss(outputs, labels)\nloss = loss * label_mask  # Set negative label positions to 0\nmean_loss = tf.reduce_sum(loss) / tf.reduce_sum(label_mask)\n```\n\nHere, we avoid data-dependent shapes by computing the loss for every position, but zeroing out the masked positions in both the numerator and denominator when we calculate the mean, which yields exactly the same result as the first block while maintaining XLA compatibility. Note that we use the same trick as in rule #1 - converting a `tf.bool` to `\n--New Chunk--\n[Created at: 2025-03-24 13:17:32]\nlabel_mask  # Set negative label positions to 0\nmean_loss = tf.reduce_sum(loss) / tf.reduce_sum(label_mask)\n```\n\nHere, we avoid data-dependent shapes by computing the loss for every position, but zeroing out the masked positions in both the numerator and denominator when we calculate the mean, which yields exactly the same result as the first block while maintaining XLA compatibility. Note that we use the same trick as in rule #1 - converting a `tf.bool` to `tf.float32` and using it as an indicator variable. This is a really useful trick, so remember it if you need to convert your own code to XLA!\n\n#### XLA Rule #3: XLA will need to recompile your model for every different input shape it sees\n\nThis is the big one. What this means is that if your input shapes are very variable, XLA will have to recompile your model over and over, which will create huge performance problems. This commonly arises in NLP models, where input texts have variable lengths after tokenization. In other modalities, static shapes are more common and this rule is much less of a problem.\n\nHow can you get around rule #3? The key is **padding** - if you pad all your inputs to the same length, and then use an `attention_mask`, you can get the same results as you\u2019d get from variable shapes, but without any XLA issues. However, excessive padding can cause severe slowdown too - if you pad all your samples to the maximum length in the whole dataset, you might end up with batches consisting endless padding tokens, which will waste a lot of compute and memory!\n\nThere isn\u2019t a perfect solution to this problem. However, you can try some tricks. One very useful trick is to **pad batches of samples up to a multiple of a number like 32 or 64 tokens.** This often only increases the number of tokens by a small amount, but it hugely reduces the number of unique input shapes, because every input shape now has to be a multiple of 32 or 64. Fewer unique input shapes means fewer XLA compilations!\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** Our tokenizers and data collators have methods that can help you here. You can use `padding=\"max_length\"` or `padding=\"longest\"` when calling tokenizers to get them to output padded data. Our tokenizers and data collators also have a `pad_to_multiple_of` argument that you can use to reduce the number of unique input shapes you see!\n\n</Tip>\n\n### How do I actually train my model on TPU?\n\nOnce your training is XLA-compatible and (if you\u2019re using TPU Node / Colab) your dataset has been prepared appropriately, running on TPU is surprisingly easy! All you really need to change in your code is to add a few lines to initialize your TPU, and to ensure that your model and dataset are created inside a `TPUStrategy` scope. Take a look at [our TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) to see this in action!\n\n### Summary\n\nThere was a lot in here, so let\u2019s summarize with a quick checklist you can follow when you want to get your model ready for TPU training:\n\n- Make sure your code follows the three rules of XLA\n- Compile your model with `jit_compile=True` on CPU/GPU and confirm that you can train it with XLA\n- Either load your dataset into memory or use a TPU-compatible dataset loading approach (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Migrate your code either to Colab (with accelerator set to \u201cTPU\u201d) or a TPU VM on Google Cloud\n- Add TPU initializer code (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Create your `TPUStrategy` and make sure dataset loading and model creation are inside the `strategy.scope()` (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Don\u2019t forget to take `jit_compile=True` out again when you move to TPU!\n- \ud83d\ude4f\ud83d\ude4f\ud83d\ude4f\ud83e\udd7a\ud83e\udd7a\ud83e\udd7a\n- Call model.fit()\n- You did it!"
        }
    },
    {
        "sample_idx": 52,
        "question": "What is a pod in the context of TPUs?",
        "answer": "A pod is a group of TPUs that can run hundreds or thousands of replicas simultaneously.",
        "rag_answer": "In the context of TPUs (Tensor Processing Units), a **pod** refers to a group of TPUs that can run hundreds or thousands of replicas simultaneously. In other words, a pod is a cluster of TPUs that can be used to scale up machine learning model training or inference.\n\nWhen you use more than a single TPU but less than a whole pod (for example, a v3-32), your TPU fleet is referred to",
        "rag_score": null,
        "rag_feedback": null,
        "rag_context": {
            "kg_context": "-----Entities-----\n    ```csv\n    id,\tentity,\ttype,\tdescription,\trankcreated_at\n1,\tGoogle,organization,Google is the company that designs and provides TPUs, which are used to speed up tensor computations within neural networks.,3,2025-03-24 13:18:20\n2,\tTPU,technology,TPU is a Tensor Processing Unit, a hardware designed by Google to speed up tensor computations within neural networks.<SEP>TPU is a type of hardware accelerator designed for machine learning workloads.<SEP>TPU is a type of hardware accelerator used for machine learning computations.,4,2025-03-24 13:18:20\n3,\tColab,geo,Colab is a cloud-based platform for data science and machine learning, provided by Google.<SEP>Colab is a platform where users can access a free TPU.,3,2025-03-24 13:18:20\n4,\tGoogle Cloud,organization,Google Cloud is a cloud computing platform that provides infrastructure and services for building and deploying machine learning models.,1,2025-03-24 13:18:20\n5,\tGoogle,organization,Google is the company that designs and provides TPUs, which are used to speed up tensor computations within neural networks.,3,UNKNOWN\n6,\tTensor Processing Unit,category,Tensor Processing Unit is a hardware designed by Google to speed up tensor computations within neural networks.,0,UNKNOWN\n7,\tTPU,technology,TPU is a Tensor Processing Unit, a hardware designed by Google to speed up tensor computations within neural networks.<SEP>TPU is a type of hardware accelerator designed for machine learning workloads.<SEP>TPU is a type of hardware accelerator used for machine learning computations.,4,UNKNOWN\n    ```\n    -----Relationships-----\n    ```csv\n    id,\tsource,\ttarget,\tdescription,\tkeywords,\tweight,\trank,\tcreated_at\n1,\tGoogle,TPU,Google designs and provides TPUs, which are used to speed up tensor computations within neural networks.,hardware design, acceleration,18.0,7,2025-03-24 13:18:20\n2,\tColab,TPU,Colab provides access to a free TPU for users.,platform, hardware acceleration,16.0,7,2025-03-24 13:18:20\n3,\tGoogle Cloud,TPU,Google Cloud provides infrastructure and services for building and deploying machine learning models, including TPU hardware.,infrastructure provision, hardware acceleration,14.0,5,2025-03-24 13:18:20\n4,\tTPU,XLA,XLA compiles TensorFlow graphs into executable code for TPU hardware.<SEP>XLA is used to optimize code for TPU hardware.,compilation, hardware acceleration<SEP>compiler, hardware optimization,36.0,10,UNKNOWN\n5,\tGoogle,TPU,Google designs and provides TPUs, which are used to speed up tensor computations within neural networks.,hardware design, acceleration,18.0,7,UNKNOWN\n6,\tColab,TPU,Colab provides access to a free TPU for users.,platform, hardware acceleration,16.0,7,UNKNOWN\n7,\tColab,Google,Colab is a cloud-based platform provided by Google for data science and machine learning.,platform provision, cloud computing,16.0,6,UNKNOWN\n8,\tGoogle Cloud,TPU,Google Cloud provides infrastructure and services for building and deploying machine learning models, including TPU hardware.,infrastructure provision, hardware acceleration,14.0,5,UNKNOWN\n9,\tGoogle,Kaggle Kernels,Kaggle Kernels is a cloud-based platform provided by Google for data science and machine learning competitions.,platform provision, cloud computing,16.0,4,UNKNOWN\n    ```\n    -----Sources-----\n    ```csv\n    id,\tcontent\n1,\t!--Copyright 2023 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\nthe License. You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under the License is distributed on\nan \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n\n\u26a0\ufe0f Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be\nrendered properly in your Markdown viewer.\n\n-->\n\n# Training on TPU with TensorFlow\n\n<Tip>\n\nIf you don't need long explanations and just want TPU code samples to get started with, check out [our TPU example notebook!](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb)\n\n</Tip>\n\n### What is a TPU?\n\nA TPU is a **Tensor Processing Unit.** They are hardware designed by Google, which are used to greatly speed up the tensor computations within neural networks, much like GPUs. They can be used for both network training and inference. They are generally accessed through Google\u2019s cloud services, but small TPUs can also be accessed directly for free through Google Colab and Kaggle Kernels.\n\nBecause [all TensorFlow models in \ud83e\udd17 Transformers are Keras models](https://huggingface.co/blog/tensorflow-philosophy), most of the methods in this document are generally applicable to TPU training for any Keras model! However, there are a few points that are specific to the HuggingFace ecosystem (hug-o-system?) of Transformers and Datasets, and we\u2019ll make sure to flag them up when we get to them.\n\n### What kinds of TPU are available?\n\nNew users are often very confused by the range of TPUs, and the different ways to access them. The first key distinction to understand is the difference between **TPU Nodes** and **TPU VMs.**\n\nWhen you use a **TPU Node**, you are effectively indirectly accessing a remote TPU. You will need a separate VM, which will initialize your network and data pipeline and then forward them to the remote node. When you use a TPU on Google Colab, you are accessing it in the **TPU Node** style.\n\nUsing TPU Nodes can have some quite unexpected behaviour for people who aren\u2019t used to them! In particular, because the TPU is located on a physically different system to the machine you\u2019re running your Python code on, your data cannot be local to your machine - any data pipeline that loads from your machine\u2019s internal storage will totally fail! Instead, data must be stored in Google Cloud Storage where your data pipeline can still access it, even when the pipeline is running on the remote TPU node.\n\n<Tip>\n\nIf you can fit all your data in memory as `np.ndarray` or `tf.Tensor`, then you can `fit()` on that data even when using Colab or a TPU Node, without needing to upload it to Google Cloud Storage.\n\n</Tip>\n\n<Tip>\n\n**\ud83e\udd17Specific Hugging Face Tip\ud83e\udd17:** The methods `Dataset.to_tf_dataset()` and its higher-level wrapper `model.prepare_tf_dataset()` , which you will see throughout our TF code examples, will both fail on a TPU Node. The reason for this is that even though they create a `tf.data.Dataset` it is not a \u201cpure\u201d `tf.data` pipeline and uses `tf.numpy_function` or `Dataset.from_generator()` to stream data from the underlying HuggingFace `Dataset`. This HuggingFace `Dataset` is backed by data that is on a local disc and which the remote TPU Node will not be able to read.\n\n</Tip>\n\nThe second way to access a TPU is via a **TPU VM.** When using a TPU VM, you connect directly to the machine that the TPU is attached to, much like training on a GPU VM. TPU VMs are generally easier to work with, particularly when it comes to your data pipeline. All of the above warnings do not apply to TPU VMs!\n\nThis is an opinionated document, so here\u2019s our opinion: **Avoid using TPU Node if possible.** It is more confusing and more difficult to debug than TPU VMs. It is also likely to be unsupported in future - Google\u2019s latest TPU, TPUv4, can only be accessed as a TPU VM, which suggests that TPU Nodes are increasingly going to become a \u201clegacy\u201d access method. However, we understand that the only free TPU access is on Colab and Kaggle Kernels, which uses TPU Node - so we\u2019ll try to explain how to handle it if you have to! Check the [TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) for code samples that explain this in more detail.\n\n### What sizes of TPU are available?\n\nA single TPU (a v2-8/v3-8/v4-8) runs 8 replicas. TPUs exist in **pods** that can run hundreds or thousands of replicas simultaneously. When you use more than a single TPU but less than a whole pod (for example, a v3-32), your TPU fleet is referred to as a **pod slice.**\n\nWhen you access a free TPU via Colab, you generally get a single v2-8 TPU.\n\n### I keep hearing about this XLA thing. What\u2019s XLA, and how does it relate to TPUs?\n\nXLA is an optimizing compiler, used by both TensorFlow and JAX. In JAX it is the only compiler, whereas in TensorFlow it is optional\n2,\t(for example, a v3-32), your TPU fleet is referred to as a **pod slice.**\n\nWhen you access a free TPU via Colab, you generally get a single v2-8 TPU.\n\n### I keep hearing about this XLA thing. What\u2019s XLA, and how does it relate to TPUs?\n\nXLA is an optimizing compiler, used by both TensorFlow and JAX. In JAX it is the only compiler, whereas in TensorFlow it is optional (but mandatory on TPU!). The easiest way to enable it when training a Keras model is to pass the argument `jit_compile=True` to `model.compile()`. If you don\u2019t get any errors and performance is good, that\u2019s a great sign that you\u2019re ready to move to TPU!\n\nDebugging on TPU is generally a bit harder than on CPU/GPU, so we recommend getting your code running on CPU/GPU with XLA first before trying it on TPU. You don\u2019t have to train for long, of course - just for a few steps to make sure that your model and data pipeline are working like you expect them to.\n\n<Tip>\n\nXLA compiled code is usually faster - so even if you\u2019re not planning to run on TPU, adding `jit_compile=True` can improve your performance. Be sure to note the caveats below about XLA compatibility, though!\n\n</Tip>\n\n<Tip warning={true}>\n\n**Tip born of painful experience:** Although using `jit_compile=True` is a good way to get a speed boost and test if your CPU/GPU code is XLA-compatible, it can actually cause a lot of problems if you leave it in when actually training on TPU. XLA compilation will happen implicitly on TPU, so remember to remove that line before actually running your code on a TPU!\n\n</Tip>\n\n### How do I make my model XLA compatible?\n\nIn many cases, your code is probably XLA-compatible already! However, there are a few things that work in normal TensorFlow that don\u2019t work in XLA. We\u2019ve distilled them into three core rules below:\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** We\u2019ve put a lot of effort into rewriting our TensorFlow models and loss functions to be XLA-compatible. Our models and loss functions generally obey rule #1 and #2 by default, so you can skip over them if you\u2019re using `transformers` models. Don\u2019t forget about these rules when writing your own models and loss functions, though!\n\n</Tip>\n\n#### XLA Rule #1: Your code cannot have \u201cdata-dependent conditionals\u201d\n\nWhat that means is that any `if` statement cannot depend on values inside a `tf.Tensor`. For example, this code block cannot be compiled with XLA!\n\n```python\nif tf.reduce_sum(tensor) > 10:\n    tensor = tensor / 2.0\n```\n\nThis might seem very restrictive at first, but most neural net code doesn\u2019t need to do this. You can often get around this restriction by using `tf.cond` (see the documentation [here](https://www.tensorflow.org/api_docs/python/tf/cond)) or by removing the conditional and finding a clever math trick with indicator variables instead, like so:\n\n```python\nsum_over_10 = tf.cast(tf.reduce_sum(tensor) > 10, tf.float32)\ntensor = tensor / (1.0 + sum_over_10)\n```\n\nThis code has exactly the same effect as the code above, but by avoiding a conditional, we ensure it will compile with XLA without problems!\n\n#### XLA Rule #2: Your code cannot have \u201cdata-dependent shapes\u201d\n\nWhat this means is that the shape of all of the `tf.Tensor` objects in your code cannot depend on their values. For example, the function `tf.unique` cannot be compiled with XLA, because it returns a `tensor` containing one instance of each unique value in the input. The shape of this output will obviously be different depending on how repetitive the input `Tensor` was, and so XLA refuses to handle it!\n\nIn general, most neural network code obeys rule #2 by default. However, there are a few common cases where it becomes a problem. One very common one is when you use **label masking**, setting your labels to a negative value to indicate that those positions should be ignored when computing the loss. If you look at NumPy or PyTorch loss functions that support label masking, you will often see code like this that uses [boolean indexing](https://numpy.org/doc/stable/user/basics.indexing.html#boolean-array-indexing):\n\n```python\nlabel_mask = labels >= 0\nmasked_outputs = outputs[label_mask]\nmasked_labels = labels[label_mask]\nloss = compute_loss(masked_outputs, masked_labels)\nmean_loss = torch.mean(loss)\n```\n\nThis code is totally fine in NumPy or PyTorch, but it breaks in XLA! Why? Because the shape of `masked_outputs` and `masked_labels` depends on how many positions are masked - that makes it a **data-dependent shape.** However, just like for rule #1, we can often rewrite this code to yield exactly the same output without any data-dependent shapes.\n\n```python\nlabel_mask = tf.cast(labels >= 0, tf.float32)\nloss = compute_loss(outputs, labels)\nloss = loss * label_mask  # Set negative label positions to 0\nmean_loss = tf.reduce_sum(loss) / tf.reduce_sum(label_mask)\n```\n\nHere, we avoid data-dependent shapes by computing the loss for every position, but zeroing out the masked positions in both the numerator and denominator when we calculate the mean, which yields exactly the same result as the first block while maintaining XLA compatibility. Note that we use the same trick as in rule #1 - converting a `tf.bool` to `\n3,\tlabel_mask  # Set negative label positions to 0\nmean_loss = tf.reduce_sum(loss) / tf.reduce_sum(label_mask)\n```\n\nHere, we avoid data-dependent shapes by computing the loss for every position, but zeroing out the masked positions in both the numerator and denominator when we calculate the mean, which yields exactly the same result as the first block while maintaining XLA compatibility. Note that we use the same trick as in rule #1 - converting a `tf.bool` to `tf.float32` and using it as an indicator variable. This is a really useful trick, so remember it if you need to convert your own code to XLA!\n\n#### XLA Rule #3: XLA will need to recompile your model for every different input shape it sees\n\nThis is the big one. What this means is that if your input shapes are very variable, XLA will have to recompile your model over and over, which will create huge performance problems. This commonly arises in NLP models, where input texts have variable lengths after tokenization. In other modalities, static shapes are more common and this rule is much less of a problem.\n\nHow can you get around rule #3? The key is **padding** - if you pad all your inputs to the same length, and then use an `attention_mask`, you can get the same results as you\u2019d get from variable shapes, but without any XLA issues. However, excessive padding can cause severe slowdown too - if you pad all your samples to the maximum length in the whole dataset, you might end up with batches consisting endless padding tokens, which will waste a lot of compute and memory!\n\nThere isn\u2019t a perfect solution to this problem. However, you can try some tricks. One very useful trick is to **pad batches of samples up to a multiple of a number like 32 or 64 tokens.** This often only increases the number of tokens by a small amount, but it hugely reduces the number of unique input shapes, because every input shape now has to be a multiple of 32 or 64. Fewer unique input shapes means fewer XLA compilations!\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** Our tokenizers and data collators have methods that can help you here. You can use `padding=\"max_length\"` or `padding=\"longest\"` when calling tokenizers to get them to output padded data. Our tokenizers and data collators also have a `pad_to_multiple_of` argument that you can use to reduce the number of unique input shapes you see!\n\n</Tip>\n\n### How do I actually train my model on TPU?\n\nOnce your training is XLA-compatible and (if you\u2019re using TPU Node / Colab) your dataset has been prepared appropriately, running on TPU is surprisingly easy! All you really need to change in your code is to add a few lines to initialize your TPU, and to ensure that your model and dataset are created inside a `TPUStrategy` scope. Take a look at [our TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) to see this in action!\n\n### Summary\n\nThere was a lot in here, so let\u2019s summarize with a quick checklist you can follow when you want to get your model ready for TPU training:\n\n- Make sure your code follows the three rules of XLA\n- Compile your model with `jit_compile=True` on CPU/GPU and confirm that you can train it with XLA\n- Either load your dataset into memory or use a TPU-compatible dataset loading approach (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Migrate your code either to Colab (with accelerator set to \u201cTPU\u201d) or a TPU VM on Google Cloud\n- Add TPU initializer code (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Create your `TPUStrategy` and make sure dataset loading and model creation are inside the `strategy.scope()` (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Don\u2019t forget to take `jit_compile=True` out again when you move to TPU!\n- \ud83d\ude4f\ud83d\ude4f\ud83d\ude4f\ud83e\udd7a\ud83e\udd7a\ud83e\udd7a\n- Call model.fit()\n- You did it!\n    ```",
            "vector_context": "[Created at: 2025-03-24 13:17:32]\n(for example, a v3-32), your TPU fleet is referred to as a **pod slice.**\n\nWhen you access a free TPU via Colab, you generally get a single v2-8 TPU.\n\n### I keep hearing about this XLA thing. What\u2019s XLA, and how does it relate to TPUs?\n\nXLA is an optimizing compiler, used by both TensorFlow and JAX. In JAX it is the only compiler, whereas in TensorFlow it is optional (but mandatory on TPU!). The easiest way to enable it when training a Keras model is to pass the argument `jit_compile=True` to `model.compile()`. If you don\u2019t get any errors and performance is good, that\u2019s a great sign that you\u2019re ready to move to TPU!\n\nDebugging on TPU is generally a bit harder than on CPU/GPU, so we recommend getting your code running on CPU/GPU with XLA first before trying it on TPU. You don\u2019t have to train for long, of course - just for a few steps to make sure that your model and data pipeline are working like you expect them to.\n\n<Tip>\n\nXLA compiled code is usually faster - so even if you\u2019re not planning to run on TPU, adding `jit_compile=True` can improve your performance. Be sure to note the caveats below about XLA compatibility, though!\n\n</Tip>\n\n<Tip warning={true}>\n\n**Tip born of painful experience:** Although using `jit_compile=True` is a good way to get a speed boost and test if your CPU/GPU code is XLA-compatible, it can actually cause a lot of problems if you leave it in when actually training on TPU. XLA compilation will happen implicitly on TPU, so remember to remove that line before actually running your code on a TPU!\n\n</Tip>\n\n### How do I make my model XLA compatible?\n\nIn many cases, your code is probably XLA-compatible already! However, there are a few things that work in normal TensorFlow that don\u2019t work in XLA. We\u2019ve distilled them into three core rules below:\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** We\u2019ve put a lot of effort into rewriting our TensorFlow models and loss functions to be XLA-compatible. Our models and loss functions generally obey rule #1 and #2 by default, so you can skip over them if you\u2019re using `transformers` models. Don\u2019t forget about these rules when writing your own models and loss functions, though!\n\n</Tip>\n\n#### XLA Rule #1: Your code cannot have \u201cdata-dependent conditionals\u201d\n\nWhat that means is that any `if` statement cannot depend on values inside a `tf.Tensor`. For example, this code block cannot be compiled with XLA!\n\n```python\nif tf.reduce_sum(tensor) > 10:\n    tensor = tensor / 2.0\n```\n\nThis might seem very restrictive at first, but most neural net code doesn\u2019t need to do this. You can often get around this restriction by using `tf.cond` (see the documentation [here](https://www.tensorflow.org/api_docs/python/tf/cond)) or by removing the conditional and finding a clever math trick with indicator variables instead, like so:\n\n```python\nsum_over_10 = tf.cast(tf.reduce_sum(tensor) > 10, tf.float32)\ntensor = tensor / (1.0 + sum_over_10)\n```\n\nThis code has exactly the same effect as the code above, but by avoiding a conditional, we ensure it will compile with XLA without problems!\n\n#### XLA Rule #2: Your code cannot have \u201cdata-dependent shapes\u201d\n\nWhat this means is that the shape of all of the `tf.Tensor` objects in your code cannot depend on their values. For example, the function `tf.unique` cannot be compiled with XLA, because it returns a `tensor` containing one instance of each unique value in the input. The shape of this output will obviously be different depending on how repetitive the input `Tensor` was, and so XLA refuses to handle it!\n\nIn general, most neural network code obeys rule #2 by default. However, there are a few common cases where it becomes a problem. One very common one is when you use **label masking**, setting your labels to a negative value to indicate that those positions should be ignored when computing the loss. If you look at NumPy or PyTorch loss functions that support label masking, you will often see code like this that uses [boolean indexing](https://numpy.org/doc/stable/user/basics.indexing.html#boolean-array-indexing):\n\n```python\nlabel_mask = labels >= 0\nmasked_outputs = outputs[label_mask]\nmasked_labels = labels[label_mask]\nloss = compute_loss(masked_outputs, masked_labels)\nmean_loss = torch.mean(loss)\n```\n\nThis code is totally fine in NumPy or PyTorch, but it breaks in XLA! Why? Because the shape of `masked_outputs` and `masked_labels` depends on how many positions are masked - that makes it a **data-dependent shape.** However, just like for rule #1, we can often rewrite this code to yield exactly the same output without any data-dependent shapes.\n\n```python\nlabel_mask = tf.cast(labels >= 0, tf.float32)\nloss = compute_loss(outputs, labels)\nloss = loss * label_mask  # Set negative label positions to 0\nmean_loss = tf.reduce_sum(loss) / tf.reduce_sum(label_mask)\n```\n\nHere, we avoid data-dependent shapes by computing the loss for every position, but zeroing out the masked positions in both the numerator and denominator when we calculate the mean, which yields exactly the same result as the first block while maintaining XLA compatibility. Note that we use the same trick as in rule #1 - converting a `tf.bool` to `\n--New Chunk--\n[Created at: 2025-03-24 13:17:32]\n!--Copyright 2023 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\nthe License. You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under the License is distributed on\nan \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n\n\u26a0\ufe0f Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be\nrendered properly in your Markdown viewer.\n\n-->\n\n# Training on TPU with TensorFlow\n\n<Tip>\n\nIf you don't need long explanations and just want TPU code samples to get started with, check out [our TPU example notebook!](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb)\n\n</Tip>\n\n### What is a TPU?\n\nA TPU is a **Tensor Processing Unit.** They are hardware designed by Google, which are used to greatly speed up the tensor computations within neural networks, much like GPUs. They can be used for both network training and inference. They are generally accessed through Google\u2019s cloud services, but small TPUs can also be accessed directly for free through Google Colab and Kaggle Kernels.\n\nBecause [all TensorFlow models in \ud83e\udd17 Transformers are Keras models](https://huggingface.co/blog/tensorflow-philosophy), most of the methods in this document are generally applicable to TPU training for any Keras model! However, there are a few points that are specific to the HuggingFace ecosystem (hug-o-system?) of Transformers and Datasets, and we\u2019ll make sure to flag them up when we get to them.\n\n### What kinds of TPU are available?\n\nNew users are often very confused by the range of TPUs, and the different ways to access them. The first key distinction to understand is the difference between **TPU Nodes** and **TPU VMs.**\n\nWhen you use a **TPU Node**, you are effectively indirectly accessing a remote TPU. You will need a separate VM, which will initialize your network and data pipeline and then forward them to the remote node. When you use a TPU on Google Colab, you are accessing it in the **TPU Node** style.\n\nUsing TPU Nodes can have some quite unexpected behaviour for people who aren\u2019t used to them! In particular, because the TPU is located on a physically different system to the machine you\u2019re running your Python code on, your data cannot be local to your machine - any data pipeline that loads from your machine\u2019s internal storage will totally fail! Instead, data must be stored in Google Cloud Storage where your data pipeline can still access it, even when the pipeline is running on the remote TPU node.\n\n<Tip>\n\nIf you can fit all your data in memory as `np.ndarray` or `tf.Tensor`, then you can `fit()` on that data even when using Colab or a TPU Node, without needing to upload it to Google Cloud Storage.\n\n</Tip>\n\n<Tip>\n\n**\ud83e\udd17Specific Hugging Face Tip\ud83e\udd17:** The methods `Dataset.to_tf_dataset()` and its higher-level wrapper `model.prepare_tf_dataset()` , which you will see throughout our TF code examples, will both fail on a TPU Node. The reason for this is that even though they create a `tf.data.Dataset` it is not a \u201cpure\u201d `tf.data` pipeline and uses `tf.numpy_function` or `Dataset.from_generator()` to stream data from the underlying HuggingFace `Dataset`. This HuggingFace `Dataset` is backed by data that is on a local disc and which the remote TPU Node will not be able to read.\n\n</Tip>\n\nThe second way to access a TPU is via a **TPU VM.** When using a TPU VM, you connect directly to the machine that the TPU is attached to, much like training on a GPU VM. TPU VMs are generally easier to work with, particularly when it comes to your data pipeline. All of the above warnings do not apply to TPU VMs!\n\nThis is an opinionated document, so here\u2019s our opinion: **Avoid using TPU Node if possible.** It is more confusing and more difficult to debug than TPU VMs. It is also likely to be unsupported in future - Google\u2019s latest TPU, TPUv4, can only be accessed as a TPU VM, which suggests that TPU Nodes are increasingly going to become a \u201clegacy\u201d access method. However, we understand that the only free TPU access is on Colab and Kaggle Kernels, which uses TPU Node - so we\u2019ll try to explain how to handle it if you have to! Check the [TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) for code samples that explain this in more detail.\n\n### What sizes of TPU are available?\n\nA single TPU (a v2-8/v3-8/v4-8) runs 8 replicas. TPUs exist in **pods** that can run hundreds or thousands of replicas simultaneously. When you use more than a single TPU but less than a whole pod (for example, a v3-32), your TPU fleet is referred to as a **pod slice.**\n\nWhen you access a free TPU via Colab, you generally get a single v2-8 TPU.\n\n### I keep hearing about this XLA thing. What\u2019s XLA, and how does it relate to TPUs?\n\nXLA is an optimizing compiler, used by both TensorFlow and JAX. In JAX it is the only compiler, whereas in TensorFlow it is optional\n--New Chunk--\n[Created at: 2025-03-24 13:17:32]\nlabel_mask  # Set negative label positions to 0\nmean_loss = tf.reduce_sum(loss) / tf.reduce_sum(label_mask)\n```\n\nHere, we avoid data-dependent shapes by computing the loss for every position, but zeroing out the masked positions in both the numerator and denominator when we calculate the mean, which yields exactly the same result as the first block while maintaining XLA compatibility. Note that we use the same trick as in rule #1 - converting a `tf.bool` to `tf.float32` and using it as an indicator variable. This is a really useful trick, so remember it if you need to convert your own code to XLA!\n\n#### XLA Rule #3: XLA will need to recompile your model for every different input shape it sees\n\nThis is the big one. What this means is that if your input shapes are very variable, XLA will have to recompile your model over and over, which will create huge performance problems. This commonly arises in NLP models, where input texts have variable lengths after tokenization. In other modalities, static shapes are more common and this rule is much less of a problem.\n\nHow can you get around rule #3? The key is **padding** - if you pad all your inputs to the same length, and then use an `attention_mask`, you can get the same results as you\u2019d get from variable shapes, but without any XLA issues. However, excessive padding can cause severe slowdown too - if you pad all your samples to the maximum length in the whole dataset, you might end up with batches consisting endless padding tokens, which will waste a lot of compute and memory!\n\nThere isn\u2019t a perfect solution to this problem. However, you can try some tricks. One very useful trick is to **pad batches of samples up to a multiple of a number like 32 or 64 tokens.** This often only increases the number of tokens by a small amount, but it hugely reduces the number of unique input shapes, because every input shape now has to be a multiple of 32 or 64. Fewer unique input shapes means fewer XLA compilations!\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** Our tokenizers and data collators have methods that can help you here. You can use `padding=\"max_length\"` or `padding=\"longest\"` when calling tokenizers to get them to output padded data. Our tokenizers and data collators also have a `pad_to_multiple_of` argument that you can use to reduce the number of unique input shapes you see!\n\n</Tip>\n\n### How do I actually train my model on TPU?\n\nOnce your training is XLA-compatible and (if you\u2019re using TPU Node / Colab) your dataset has been prepared appropriately, running on TPU is surprisingly easy! All you really need to change in your code is to add a few lines to initialize your TPU, and to ensure that your model and dataset are created inside a `TPUStrategy` scope. Take a look at [our TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) to see this in action!\n\n### Summary\n\nThere was a lot in here, so let\u2019s summarize with a quick checklist you can follow when you want to get your model ready for TPU training:\n\n- Make sure your code follows the three rules of XLA\n- Compile your model with `jit_compile=True` on CPU/GPU and confirm that you can train it with XLA\n- Either load your dataset into memory or use a TPU-compatible dataset loading approach (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Migrate your code either to Colab (with accelerator set to \u201cTPU\u201d) or a TPU VM on Google Cloud\n- Add TPU initializer code (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Create your `TPUStrategy` and make sure dataset loading and model creation are inside the `strategy.scope()` (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Don\u2019t forget to take `jit_compile=True` out again when you move to TPU!\n- \ud83d\ude4f\ud83d\ude4f\ud83d\ude4f\ud83e\udd7a\ud83e\udd7a\ud83e\udd7a\n- Call model.fit()\n- You did it!"
        }
    },
    {
        "sample_idx": 53,
        "question": "What is a pod slice in the context of TPUs?",
        "answer": "A pod slice is a TPU fleet that uses more than a single TPU but less than a whole pod.",
        "rag_answer": "In the context of TPUs, a **pod slice** refers to a subset of replicas within a **pod**, which is a group of TPUs that can run hundreds or thousands of replicas simultaneously. \n\nWhen you use more than a single TPU but less than a whole pod (for example, a v3-32), your TPU fleet is referred to as a **pod slice**. This means you are utilizing a portion of the",
        "rag_score": null,
        "rag_feedback": null,
        "rag_context": {
            "kg_context": "-----Entities-----\n    ```csv\n    id,\tentity,\ttype,\tdescription,\trankcreated_at\n1,\tGoogle,organization,Google is the company that designs and provides TPUs, which are used to speed up tensor computations within neural networks.,3,2025-03-24 13:18:20\n2,\tTPU,technology,TPU is a Tensor Processing Unit, a hardware designed by Google to speed up tensor computations within neural networks.<SEP>TPU is a type of hardware accelerator designed for machine learning workloads.<SEP>TPU is a type of hardware accelerator used for machine learning computations.,4,2025-03-24 13:18:20\n3,\tColab,geo,Colab is a cloud-based platform for data science and machine learning, provided by Google.<SEP>Colab is a platform where users can access a free TPU.,3,2025-03-24 13:18:20\n4,\tGoogle Cloud,organization,Google Cloud is a cloud computing platform that provides infrastructure and services for building and deploying machine learning models.,1,2025-03-24 13:18:20\n5,\tTensor Processing Unit,category,Tensor Processing Unit is a hardware designed by Google to speed up tensor computations within neural networks.,0,UNKNOWN\n6,\tGoogle,organization,Google is the company that designs and provides TPUs, which are used to speed up tensor computations within neural networks.,3,UNKNOWN\n7,\tTPU,technology,TPU is a Tensor Processing Unit, a hardware designed by Google to speed up tensor computations within neural networks.<SEP>TPU is a type of hardware accelerator designed for machine learning workloads.<SEP>TPU is a type of hardware accelerator used for machine learning computations.,4,UNKNOWN\n    ```\n    -----Relationships-----\n    ```csv\n    id,\tsource,\ttarget,\tdescription,\tkeywords,\tweight,\trank,\tcreated_at\n1,\tGoogle,TPU,Google designs and provides TPUs, which are used to speed up tensor computations within neural networks.,hardware design, acceleration,18.0,7,2025-03-24 13:18:20\n2,\tColab,TPU,Colab provides access to a free TPU for users.,platform, hardware acceleration,16.0,7,2025-03-24 13:18:20\n3,\tGoogle Cloud,TPU,Google Cloud provides infrastructure and services for building and deploying machine learning models, including TPU hardware.,infrastructure provision, hardware acceleration,14.0,5,2025-03-24 13:18:20\n4,\tTPU,XLA,XLA compiles TensorFlow graphs into executable code for TPU hardware.<SEP>XLA is used to optimize code for TPU hardware.,compilation, hardware acceleration<SEP>compiler, hardware optimization,36.0,10,UNKNOWN\n5,\tGoogle,TPU,Google designs and provides TPUs, which are used to speed up tensor computations within neural networks.,hardware design, acceleration,18.0,7,UNKNOWN\n6,\tColab,TPU,Colab provides access to a free TPU for users.,platform, hardware acceleration,16.0,7,UNKNOWN\n7,\tColab,Google,Colab is a cloud-based platform provided by Google for data science and machine learning.,platform provision, cloud computing,16.0,6,UNKNOWN\n8,\tGoogle Cloud,TPU,Google Cloud provides infrastructure and services for building and deploying machine learning models, including TPU hardware.,infrastructure provision, hardware acceleration,14.0,5,UNKNOWN\n9,\tGoogle,Kaggle Kernels,Kaggle Kernels is a cloud-based platform provided by Google for data science and machine learning competitions.,platform provision, cloud computing,16.0,4,UNKNOWN\n    ```\n    -----Sources-----\n    ```csv\n    id,\tcontent\n1,\t!--Copyright 2023 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\nthe License. You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under the License is distributed on\nan \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n\n\u26a0\ufe0f Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be\nrendered properly in your Markdown viewer.\n\n-->\n\n# Training on TPU with TensorFlow\n\n<Tip>\n\nIf you don't need long explanations and just want TPU code samples to get started with, check out [our TPU example notebook!](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb)\n\n</Tip>\n\n### What is a TPU?\n\nA TPU is a **Tensor Processing Unit.** They are hardware designed by Google, which are used to greatly speed up the tensor computations within neural networks, much like GPUs. They can be used for both network training and inference. They are generally accessed through Google\u2019s cloud services, but small TPUs can also be accessed directly for free through Google Colab and Kaggle Kernels.\n\nBecause [all TensorFlow models in \ud83e\udd17 Transformers are Keras models](https://huggingface.co/blog/tensorflow-philosophy), most of the methods in this document are generally applicable to TPU training for any Keras model! However, there are a few points that are specific to the HuggingFace ecosystem (hug-o-system?) of Transformers and Datasets, and we\u2019ll make sure to flag them up when we get to them.\n\n### What kinds of TPU are available?\n\nNew users are often very confused by the range of TPUs, and the different ways to access them. The first key distinction to understand is the difference between **TPU Nodes** and **TPU VMs.**\n\nWhen you use a **TPU Node**, you are effectively indirectly accessing a remote TPU. You will need a separate VM, which will initialize your network and data pipeline and then forward them to the remote node. When you use a TPU on Google Colab, you are accessing it in the **TPU Node** style.\n\nUsing TPU Nodes can have some quite unexpected behaviour for people who aren\u2019t used to them! In particular, because the TPU is located on a physically different system to the machine you\u2019re running your Python code on, your data cannot be local to your machine - any data pipeline that loads from your machine\u2019s internal storage will totally fail! Instead, data must be stored in Google Cloud Storage where your data pipeline can still access it, even when the pipeline is running on the remote TPU node.\n\n<Tip>\n\nIf you can fit all your data in memory as `np.ndarray` or `tf.Tensor`, then you can `fit()` on that data even when using Colab or a TPU Node, without needing to upload it to Google Cloud Storage.\n\n</Tip>\n\n<Tip>\n\n**\ud83e\udd17Specific Hugging Face Tip\ud83e\udd17:** The methods `Dataset.to_tf_dataset()` and its higher-level wrapper `model.prepare_tf_dataset()` , which you will see throughout our TF code examples, will both fail on a TPU Node. The reason for this is that even though they create a `tf.data.Dataset` it is not a \u201cpure\u201d `tf.data` pipeline and uses `tf.numpy_function` or `Dataset.from_generator()` to stream data from the underlying HuggingFace `Dataset`. This HuggingFace `Dataset` is backed by data that is on a local disc and which the remote TPU Node will not be able to read.\n\n</Tip>\n\nThe second way to access a TPU is via a **TPU VM.** When using a TPU VM, you connect directly to the machine that the TPU is attached to, much like training on a GPU VM. TPU VMs are generally easier to work with, particularly when it comes to your data pipeline. All of the above warnings do not apply to TPU VMs!\n\nThis is an opinionated document, so here\u2019s our opinion: **Avoid using TPU Node if possible.** It is more confusing and more difficult to debug than TPU VMs. It is also likely to be unsupported in future - Google\u2019s latest TPU, TPUv4, can only be accessed as a TPU VM, which suggests that TPU Nodes are increasingly going to become a \u201clegacy\u201d access method. However, we understand that the only free TPU access is on Colab and Kaggle Kernels, which uses TPU Node - so we\u2019ll try to explain how to handle it if you have to! Check the [TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) for code samples that explain this in more detail.\n\n### What sizes of TPU are available?\n\nA single TPU (a v2-8/v3-8/v4-8) runs 8 replicas. TPUs exist in **pods** that can run hundreds or thousands of replicas simultaneously. When you use more than a single TPU but less than a whole pod (for example, a v3-32), your TPU fleet is referred to as a **pod slice.**\n\nWhen you access a free TPU via Colab, you generally get a single v2-8 TPU.\n\n### I keep hearing about this XLA thing. What\u2019s XLA, and how does it relate to TPUs?\n\nXLA is an optimizing compiler, used by both TensorFlow and JAX. In JAX it is the only compiler, whereas in TensorFlow it is optional\n2,\t(for example, a v3-32), your TPU fleet is referred to as a **pod slice.**\n\nWhen you access a free TPU via Colab, you generally get a single v2-8 TPU.\n\n### I keep hearing about this XLA thing. What\u2019s XLA, and how does it relate to TPUs?\n\nXLA is an optimizing compiler, used by both TensorFlow and JAX. In JAX it is the only compiler, whereas in TensorFlow it is optional (but mandatory on TPU!). The easiest way to enable it when training a Keras model is to pass the argument `jit_compile=True` to `model.compile()`. If you don\u2019t get any errors and performance is good, that\u2019s a great sign that you\u2019re ready to move to TPU!\n\nDebugging on TPU is generally a bit harder than on CPU/GPU, so we recommend getting your code running on CPU/GPU with XLA first before trying it on TPU. You don\u2019t have to train for long, of course - just for a few steps to make sure that your model and data pipeline are working like you expect them to.\n\n<Tip>\n\nXLA compiled code is usually faster - so even if you\u2019re not planning to run on TPU, adding `jit_compile=True` can improve your performance. Be sure to note the caveats below about XLA compatibility, though!\n\n</Tip>\n\n<Tip warning={true}>\n\n**Tip born of painful experience:** Although using `jit_compile=True` is a good way to get a speed boost and test if your CPU/GPU code is XLA-compatible, it can actually cause a lot of problems if you leave it in when actually training on TPU. XLA compilation will happen implicitly on TPU, so remember to remove that line before actually running your code on a TPU!\n\n</Tip>\n\n### How do I make my model XLA compatible?\n\nIn many cases, your code is probably XLA-compatible already! However, there are a few things that work in normal TensorFlow that don\u2019t work in XLA. We\u2019ve distilled them into three core rules below:\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** We\u2019ve put a lot of effort into rewriting our TensorFlow models and loss functions to be XLA-compatible. Our models and loss functions generally obey rule #1 and #2 by default, so you can skip over them if you\u2019re using `transformers` models. Don\u2019t forget about these rules when writing your own models and loss functions, though!\n\n</Tip>\n\n#### XLA Rule #1: Your code cannot have \u201cdata-dependent conditionals\u201d\n\nWhat that means is that any `if` statement cannot depend on values inside a `tf.Tensor`. For example, this code block cannot be compiled with XLA!\n\n```python\nif tf.reduce_sum(tensor) > 10:\n    tensor = tensor / 2.0\n```\n\nThis might seem very restrictive at first, but most neural net code doesn\u2019t need to do this. You can often get around this restriction by using `tf.cond` (see the documentation [here](https://www.tensorflow.org/api_docs/python/tf/cond)) or by removing the conditional and finding a clever math trick with indicator variables instead, like so:\n\n```python\nsum_over_10 = tf.cast(tf.reduce_sum(tensor) > 10, tf.float32)\ntensor = tensor / (1.0 + sum_over_10)\n```\n\nThis code has exactly the same effect as the code above, but by avoiding a conditional, we ensure it will compile with XLA without problems!\n\n#### XLA Rule #2: Your code cannot have \u201cdata-dependent shapes\u201d\n\nWhat this means is that the shape of all of the `tf.Tensor` objects in your code cannot depend on their values. For example, the function `tf.unique` cannot be compiled with XLA, because it returns a `tensor` containing one instance of each unique value in the input. The shape of this output will obviously be different depending on how repetitive the input `Tensor` was, and so XLA refuses to handle it!\n\nIn general, most neural network code obeys rule #2 by default. However, there are a few common cases where it becomes a problem. One very common one is when you use **label masking**, setting your labels to a negative value to indicate that those positions should be ignored when computing the loss. If you look at NumPy or PyTorch loss functions that support label masking, you will often see code like this that uses [boolean indexing](https://numpy.org/doc/stable/user/basics.indexing.html#boolean-array-indexing):\n\n```python\nlabel_mask = labels >= 0\nmasked_outputs = outputs[label_mask]\nmasked_labels = labels[label_mask]\nloss = compute_loss(masked_outputs, masked_labels)\nmean_loss = torch.mean(loss)\n```\n\nThis code is totally fine in NumPy or PyTorch, but it breaks in XLA! Why? Because the shape of `masked_outputs` and `masked_labels` depends on how many positions are masked - that makes it a **data-dependent shape.** However, just like for rule #1, we can often rewrite this code to yield exactly the same output without any data-dependent shapes.\n\n```python\nlabel_mask = tf.cast(labels >= 0, tf.float32)\nloss = compute_loss(outputs, labels)\nloss = loss * label_mask  # Set negative label positions to 0\nmean_loss = tf.reduce_sum(loss) / tf.reduce_sum(label_mask)\n```\n\nHere, we avoid data-dependent shapes by computing the loss for every position, but zeroing out the masked positions in both the numerator and denominator when we calculate the mean, which yields exactly the same result as the first block while maintaining XLA compatibility. Note that we use the same trick as in rule #1 - converting a `tf.bool` to `\n3,\tlabel_mask  # Set negative label positions to 0\nmean_loss = tf.reduce_sum(loss) / tf.reduce_sum(label_mask)\n```\n\nHere, we avoid data-dependent shapes by computing the loss for every position, but zeroing out the masked positions in both the numerator and denominator when we calculate the mean, which yields exactly the same result as the first block while maintaining XLA compatibility. Note that we use the same trick as in rule #1 - converting a `tf.bool` to `tf.float32` and using it as an indicator variable. This is a really useful trick, so remember it if you need to convert your own code to XLA!\n\n#### XLA Rule #3: XLA will need to recompile your model for every different input shape it sees\n\nThis is the big one. What this means is that if your input shapes are very variable, XLA will have to recompile your model over and over, which will create huge performance problems. This commonly arises in NLP models, where input texts have variable lengths after tokenization. In other modalities, static shapes are more common and this rule is much less of a problem.\n\nHow can you get around rule #3? The key is **padding** - if you pad all your inputs to the same length, and then use an `attention_mask`, you can get the same results as you\u2019d get from variable shapes, but without any XLA issues. However, excessive padding can cause severe slowdown too - if you pad all your samples to the maximum length in the whole dataset, you might end up with batches consisting endless padding tokens, which will waste a lot of compute and memory!\n\nThere isn\u2019t a perfect solution to this problem. However, you can try some tricks. One very useful trick is to **pad batches of samples up to a multiple of a number like 32 or 64 tokens.** This often only increases the number of tokens by a small amount, but it hugely reduces the number of unique input shapes, because every input shape now has to be a multiple of 32 or 64. Fewer unique input shapes means fewer XLA compilations!\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** Our tokenizers and data collators have methods that can help you here. You can use `padding=\"max_length\"` or `padding=\"longest\"` when calling tokenizers to get them to output padded data. Our tokenizers and data collators also have a `pad_to_multiple_of` argument that you can use to reduce the number of unique input shapes you see!\n\n</Tip>\n\n### How do I actually train my model on TPU?\n\nOnce your training is XLA-compatible and (if you\u2019re using TPU Node / Colab) your dataset has been prepared appropriately, running on TPU is surprisingly easy! All you really need to change in your code is to add a few lines to initialize your TPU, and to ensure that your model and dataset are created inside a `TPUStrategy` scope. Take a look at [our TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) to see this in action!\n\n### Summary\n\nThere was a lot in here, so let\u2019s summarize with a quick checklist you can follow when you want to get your model ready for TPU training:\n\n- Make sure your code follows the three rules of XLA\n- Compile your model with `jit_compile=True` on CPU/GPU and confirm that you can train it with XLA\n- Either load your dataset into memory or use a TPU-compatible dataset loading approach (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Migrate your code either to Colab (with accelerator set to \u201cTPU\u201d) or a TPU VM on Google Cloud\n- Add TPU initializer code (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Create your `TPUStrategy` and make sure dataset loading and model creation are inside the `strategy.scope()` (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Don\u2019t forget to take `jit_compile=True` out again when you move to TPU!\n- \ud83d\ude4f\ud83d\ude4f\ud83d\ude4f\ud83e\udd7a\ud83e\udd7a\ud83e\udd7a\n- Call model.fit()\n- You did it!\n    ```",
            "vector_context": "[Created at: 2025-03-24 13:17:32]\n(for example, a v3-32), your TPU fleet is referred to as a **pod slice.**\n\nWhen you access a free TPU via Colab, you generally get a single v2-8 TPU.\n\n### I keep hearing about this XLA thing. What\u2019s XLA, and how does it relate to TPUs?\n\nXLA is an optimizing compiler, used by both TensorFlow and JAX. In JAX it is the only compiler, whereas in TensorFlow it is optional (but mandatory on TPU!). The easiest way to enable it when training a Keras model is to pass the argument `jit_compile=True` to `model.compile()`. If you don\u2019t get any errors and performance is good, that\u2019s a great sign that you\u2019re ready to move to TPU!\n\nDebugging on TPU is generally a bit harder than on CPU/GPU, so we recommend getting your code running on CPU/GPU with XLA first before trying it on TPU. You don\u2019t have to train for long, of course - just for a few steps to make sure that your model and data pipeline are working like you expect them to.\n\n<Tip>\n\nXLA compiled code is usually faster - so even if you\u2019re not planning to run on TPU, adding `jit_compile=True` can improve your performance. Be sure to note the caveats below about XLA compatibility, though!\n\n</Tip>\n\n<Tip warning={true}>\n\n**Tip born of painful experience:** Although using `jit_compile=True` is a good way to get a speed boost and test if your CPU/GPU code is XLA-compatible, it can actually cause a lot of problems if you leave it in when actually training on TPU. XLA compilation will happen implicitly on TPU, so remember to remove that line before actually running your code on a TPU!\n\n</Tip>\n\n### How do I make my model XLA compatible?\n\nIn many cases, your code is probably XLA-compatible already! However, there are a few things that work in normal TensorFlow that don\u2019t work in XLA. We\u2019ve distilled them into three core rules below:\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** We\u2019ve put a lot of effort into rewriting our TensorFlow models and loss functions to be XLA-compatible. Our models and loss functions generally obey rule #1 and #2 by default, so you can skip over them if you\u2019re using `transformers` models. Don\u2019t forget about these rules when writing your own models and loss functions, though!\n\n</Tip>\n\n#### XLA Rule #1: Your code cannot have \u201cdata-dependent conditionals\u201d\n\nWhat that means is that any `if` statement cannot depend on values inside a `tf.Tensor`. For example, this code block cannot be compiled with XLA!\n\n```python\nif tf.reduce_sum(tensor) > 10:\n    tensor = tensor / 2.0\n```\n\nThis might seem very restrictive at first, but most neural net code doesn\u2019t need to do this. You can often get around this restriction by using `tf.cond` (see the documentation [here](https://www.tensorflow.org/api_docs/python/tf/cond)) or by removing the conditional and finding a clever math trick with indicator variables instead, like so:\n\n```python\nsum_over_10 = tf.cast(tf.reduce_sum(tensor) > 10, tf.float32)\ntensor = tensor / (1.0 + sum_over_10)\n```\n\nThis code has exactly the same effect as the code above, but by avoiding a conditional, we ensure it will compile with XLA without problems!\n\n#### XLA Rule #2: Your code cannot have \u201cdata-dependent shapes\u201d\n\nWhat this means is that the shape of all of the `tf.Tensor` objects in your code cannot depend on their values. For example, the function `tf.unique` cannot be compiled with XLA, because it returns a `tensor` containing one instance of each unique value in the input. The shape of this output will obviously be different depending on how repetitive the input `Tensor` was, and so XLA refuses to handle it!\n\nIn general, most neural network code obeys rule #2 by default. However, there are a few common cases where it becomes a problem. One very common one is when you use **label masking**, setting your labels to a negative value to indicate that those positions should be ignored when computing the loss. If you look at NumPy or PyTorch loss functions that support label masking, you will often see code like this that uses [boolean indexing](https://numpy.org/doc/stable/user/basics.indexing.html#boolean-array-indexing):\n\n```python\nlabel_mask = labels >= 0\nmasked_outputs = outputs[label_mask]\nmasked_labels = labels[label_mask]\nloss = compute_loss(masked_outputs, masked_labels)\nmean_loss = torch.mean(loss)\n```\n\nThis code is totally fine in NumPy or PyTorch, but it breaks in XLA! Why? Because the shape of `masked_outputs` and `masked_labels` depends on how many positions are masked - that makes it a **data-dependent shape.** However, just like for rule #1, we can often rewrite this code to yield exactly the same output without any data-dependent shapes.\n\n```python\nlabel_mask = tf.cast(labels >= 0, tf.float32)\nloss = compute_loss(outputs, labels)\nloss = loss * label_mask  # Set negative label positions to 0\nmean_loss = tf.reduce_sum(loss) / tf.reduce_sum(label_mask)\n```\n\nHere, we avoid data-dependent shapes by computing the loss for every position, but zeroing out the masked positions in both the numerator and denominator when we calculate the mean, which yields exactly the same result as the first block while maintaining XLA compatibility. Note that we use the same trick as in rule #1 - converting a `tf.bool` to `\n--New Chunk--\n[Created at: 2025-03-24 13:17:32]\n!--Copyright 2023 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\nthe License. You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under the License is distributed on\nan \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n\n\u26a0\ufe0f Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be\nrendered properly in your Markdown viewer.\n\n-->\n\n# Training on TPU with TensorFlow\n\n<Tip>\n\nIf you don't need long explanations and just want TPU code samples to get started with, check out [our TPU example notebook!](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb)\n\n</Tip>\n\n### What is a TPU?\n\nA TPU is a **Tensor Processing Unit.** They are hardware designed by Google, which are used to greatly speed up the tensor computations within neural networks, much like GPUs. They can be used for both network training and inference. They are generally accessed through Google\u2019s cloud services, but small TPUs can also be accessed directly for free through Google Colab and Kaggle Kernels.\n\nBecause [all TensorFlow models in \ud83e\udd17 Transformers are Keras models](https://huggingface.co/blog/tensorflow-philosophy), most of the methods in this document are generally applicable to TPU training for any Keras model! However, there are a few points that are specific to the HuggingFace ecosystem (hug-o-system?) of Transformers and Datasets, and we\u2019ll make sure to flag them up when we get to them.\n\n### What kinds of TPU are available?\n\nNew users are often very confused by the range of TPUs, and the different ways to access them. The first key distinction to understand is the difference between **TPU Nodes** and **TPU VMs.**\n\nWhen you use a **TPU Node**, you are effectively indirectly accessing a remote TPU. You will need a separate VM, which will initialize your network and data pipeline and then forward them to the remote node. When you use a TPU on Google Colab, you are accessing it in the **TPU Node** style.\n\nUsing TPU Nodes can have some quite unexpected behaviour for people who aren\u2019t used to them! In particular, because the TPU is located on a physically different system to the machine you\u2019re running your Python code on, your data cannot be local to your machine - any data pipeline that loads from your machine\u2019s internal storage will totally fail! Instead, data must be stored in Google Cloud Storage where your data pipeline can still access it, even when the pipeline is running on the remote TPU node.\n\n<Tip>\n\nIf you can fit all your data in memory as `np.ndarray` or `tf.Tensor`, then you can `fit()` on that data even when using Colab or a TPU Node, without needing to upload it to Google Cloud Storage.\n\n</Tip>\n\n<Tip>\n\n**\ud83e\udd17Specific Hugging Face Tip\ud83e\udd17:** The methods `Dataset.to_tf_dataset()` and its higher-level wrapper `model.prepare_tf_dataset()` , which you will see throughout our TF code examples, will both fail on a TPU Node. The reason for this is that even though they create a `tf.data.Dataset` it is not a \u201cpure\u201d `tf.data` pipeline and uses `tf.numpy_function` or `Dataset.from_generator()` to stream data from the underlying HuggingFace `Dataset`. This HuggingFace `Dataset` is backed by data that is on a local disc and which the remote TPU Node will not be able to read.\n\n</Tip>\n\nThe second way to access a TPU is via a **TPU VM.** When using a TPU VM, you connect directly to the machine that the TPU is attached to, much like training on a GPU VM. TPU VMs are generally easier to work with, particularly when it comes to your data pipeline. All of the above warnings do not apply to TPU VMs!\n\nThis is an opinionated document, so here\u2019s our opinion: **Avoid using TPU Node if possible.** It is more confusing and more difficult to debug than TPU VMs. It is also likely to be unsupported in future - Google\u2019s latest TPU, TPUv4, can only be accessed as a TPU VM, which suggests that TPU Nodes are increasingly going to become a \u201clegacy\u201d access method. However, we understand that the only free TPU access is on Colab and Kaggle Kernels, which uses TPU Node - so we\u2019ll try to explain how to handle it if you have to! Check the [TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) for code samples that explain this in more detail.\n\n### What sizes of TPU are available?\n\nA single TPU (a v2-8/v3-8/v4-8) runs 8 replicas. TPUs exist in **pods** that can run hundreds or thousands of replicas simultaneously. When you use more than a single TPU but less than a whole pod (for example, a v3-32), your TPU fleet is referred to as a **pod slice.**\n\nWhen you access a free TPU via Colab, you generally get a single v2-8 TPU.\n\n### I keep hearing about this XLA thing. What\u2019s XLA, and how does it relate to TPUs?\n\nXLA is an optimizing compiler, used by both TensorFlow and JAX. In JAX it is the only compiler, whereas in TensorFlow it is optional\n--New Chunk--\n[Created at: 2025-03-24 13:17:32]\nlabel_mask  # Set negative label positions to 0\nmean_loss = tf.reduce_sum(loss) / tf.reduce_sum(label_mask)\n```\n\nHere, we avoid data-dependent shapes by computing the loss for every position, but zeroing out the masked positions in both the numerator and denominator when we calculate the mean, which yields exactly the same result as the first block while maintaining XLA compatibility. Note that we use the same trick as in rule #1 - converting a `tf.bool` to `tf.float32` and using it as an indicator variable. This is a really useful trick, so remember it if you need to convert your own code to XLA!\n\n#### XLA Rule #3: XLA will need to recompile your model for every different input shape it sees\n\nThis is the big one. What this means is that if your input shapes are very variable, XLA will have to recompile your model over and over, which will create huge performance problems. This commonly arises in NLP models, where input texts have variable lengths after tokenization. In other modalities, static shapes are more common and this rule is much less of a problem.\n\nHow can you get around rule #3? The key is **padding** - if you pad all your inputs to the same length, and then use an `attention_mask`, you can get the same results as you\u2019d get from variable shapes, but without any XLA issues. However, excessive padding can cause severe slowdown too - if you pad all your samples to the maximum length in the whole dataset, you might end up with batches consisting endless padding tokens, which will waste a lot of compute and memory!\n\nThere isn\u2019t a perfect solution to this problem. However, you can try some tricks. One very useful trick is to **pad batches of samples up to a multiple of a number like 32 or 64 tokens.** This often only increases the number of tokens by a small amount, but it hugely reduces the number of unique input shapes, because every input shape now has to be a multiple of 32 or 64. Fewer unique input shapes means fewer XLA compilations!\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** Our tokenizers and data collators have methods that can help you here. You can use `padding=\"max_length\"` or `padding=\"longest\"` when calling tokenizers to get them to output padded data. Our tokenizers and data collators also have a `pad_to_multiple_of` argument that you can use to reduce the number of unique input shapes you see!\n\n</Tip>\n\n### How do I actually train my model on TPU?\n\nOnce your training is XLA-compatible and (if you\u2019re using TPU Node / Colab) your dataset has been prepared appropriately, running on TPU is surprisingly easy! All you really need to change in your code is to add a few lines to initialize your TPU, and to ensure that your model and dataset are created inside a `TPUStrategy` scope. Take a look at [our TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) to see this in action!\n\n### Summary\n\nThere was a lot in here, so let\u2019s summarize with a quick checklist you can follow when you want to get your model ready for TPU training:\n\n- Make sure your code follows the three rules of XLA\n- Compile your model with `jit_compile=True` on CPU/GPU and confirm that you can train it with XLA\n- Either load your dataset into memory or use a TPU-compatible dataset loading approach (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Migrate your code either to Colab (with accelerator set to \u201cTPU\u201d) or a TPU VM on Google Cloud\n- Add TPU initializer code (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Create your `TPUStrategy` and make sure dataset loading and model creation are inside the `strategy.scope()` (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Don\u2019t forget to take `jit_compile=True` out again when you move to TPU!\n- \ud83d\ude4f\ud83d\ude4f\ud83d\ude4f\ud83e\udd7a\ud83e\udd7a\ud83e\udd7a\n- Call model.fit()\n- You did it!"
        }
    },
    {
        "sample_idx": 54,
        "question": "What type of TPU is typically provided for free via Colab?",
        "answer": "A single v2-8 TPU is typically provided for free via Colab.",
        "rag_answer": "A single v2-8 TPU is typically provided for free via Colab.",
        "rag_score": null,
        "rag_feedback": null,
        "rag_context": {
            "kg_context": "-----Entities-----\n    ```csv\n    id,\tentity,\ttype,\tdescription,\trankcreated_at\n1,\tGoogle,organization,Google is the company that designs and provides TPUs, which are used to speed up tensor computations within neural networks.,3,2025-03-24 13:18:20\n2,\tTPU,technology,TPU is a Tensor Processing Unit, a hardware designed by Google to speed up tensor computations within neural networks.<SEP>TPU is a type of hardware accelerator designed for machine learning workloads.<SEP>TPU is a type of hardware accelerator used for machine learning computations.,4,2025-03-24 13:18:20\n3,\tGoogle Cloud,organization,Google Cloud is a cloud computing platform that provides infrastructure and services for building and deploying machine learning models.,1,2025-03-24 13:18:20\n4,\tKaggle Kernels,geo,Kaggle Kernels is a cloud-based platform for data science and machine learning competitions.,1,2025-03-24 13:18:20\n5,\tGoogle Colab,geo,Google Colab is a cloud-based platform for data science and machine learning.,1,UNKNOWN\n6,\tColab,geo,Colab is a cloud-based platform for data science and machine learning, provided by Google.<SEP>Colab is a platform where users can access a free TPU.,3,UNKNOWN\n7,\tTPU,technology,TPU is a Tensor Processing Unit, a hardware designed by Google to speed up tensor computations within neural networks.<SEP>TPU is a type of hardware accelerator designed for machine learning workloads.<SEP>TPU is a type of hardware accelerator used for machine learning computations.,4,UNKNOWN\n    ```\n    -----Relationships-----\n    ```csv\n    id,\tsource,\ttarget,\tdescription,\tkeywords,\tweight,\trank,\tcreated_at\n1,\tGoogle,TPU,Google designs and provides TPUs, which are used to speed up tensor computations within neural networks.,hardware design, acceleration,18.0,7,2025-03-24 13:18:20\n2,\tGoogle Cloud,TPU,Google Cloud provides infrastructure and services for building and deploying machine learning models, including TPU hardware.,infrastructure provision, hardware acceleration,14.0,5,2025-03-24 13:18:20\n3,\tGoogle,Kaggle Kernels,Kaggle Kernels is a cloud-based platform provided by Google for data science and machine learning competitions.,platform provision, cloud computing,16.0,4,2025-03-24 13:18:20\n4,\tGoogle Colab,Gradio,Gradio can be run on Google Colab notebooks.,platform compatibility, cloud-based,14.0,37,UNKNOWN\n5,\tTPU,XLA,XLA compiles TensorFlow graphs into executable code for TPU hardware.<SEP>XLA is used to optimize code for TPU hardware.,compilation, hardware acceleration<SEP>compiler, hardware optimization,36.0,10,UNKNOWN\n6,\tColab,HuggingFace,Colab provides a platform for data science and machine learning, and HuggingFace provides tools and resources for NLP and machine learning.,platform provision, resource support,12.0,8,UNKNOWN\n7,\tGoogle,TPU,Google designs and provides TPUs, which are used to speed up tensor computations within neural networks.,hardware design, acceleration,18.0,7,UNKNOWN\n8,\tColab,TPU,Colab provides access to a free TPU for users.,platform, hardware acceleration,16.0,7,UNKNOWN\n9,\tColab,Google,Colab is a cloud-based platform provided by Google for data science and machine learning.,platform provision, cloud computing,16.0,6,UNKNOWN\n10,\tGoogle Cloud,TPU,Google Cloud provides infrastructure and services for building and deploying machine learning models, including TPU hardware.,infrastructure provision, hardware acceleration,14.0,5,UNKNOWN\n    ```\n    -----Sources-----\n    ```csv\n    id,\tcontent\n1,\t!--Copyright 2023 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\nthe License. You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under the License is distributed on\nan \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n\n\u26a0\ufe0f Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be\nrendered properly in your Markdown viewer.\n\n-->\n\n# Training on TPU with TensorFlow\n\n<Tip>\n\nIf you don't need long explanations and just want TPU code samples to get started with, check out [our TPU example notebook!](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb)\n\n</Tip>\n\n### What is a TPU?\n\nA TPU is a **Tensor Processing Unit.** They are hardware designed by Google, which are used to greatly speed up the tensor computations within neural networks, much like GPUs. They can be used for both network training and inference. They are generally accessed through Google\u2019s cloud services, but small TPUs can also be accessed directly for free through Google Colab and Kaggle Kernels.\n\nBecause [all TensorFlow models in \ud83e\udd17 Transformers are Keras models](https://huggingface.co/blog/tensorflow-philosophy), most of the methods in this document are generally applicable to TPU training for any Keras model! However, there are a few points that are specific to the HuggingFace ecosystem (hug-o-system?) of Transformers and Datasets, and we\u2019ll make sure to flag them up when we get to them.\n\n### What kinds of TPU are available?\n\nNew users are often very confused by the range of TPUs, and the different ways to access them. The first key distinction to understand is the difference between **TPU Nodes** and **TPU VMs.**\n\nWhen you use a **TPU Node**, you are effectively indirectly accessing a remote TPU. You will need a separate VM, which will initialize your network and data pipeline and then forward them to the remote node. When you use a TPU on Google Colab, you are accessing it in the **TPU Node** style.\n\nUsing TPU Nodes can have some quite unexpected behaviour for people who aren\u2019t used to them! In particular, because the TPU is located on a physically different system to the machine you\u2019re running your Python code on, your data cannot be local to your machine - any data pipeline that loads from your machine\u2019s internal storage will totally fail! Instead, data must be stored in Google Cloud Storage where your data pipeline can still access it, even when the pipeline is running on the remote TPU node.\n\n<Tip>\n\nIf you can fit all your data in memory as `np.ndarray` or `tf.Tensor`, then you can `fit()` on that data even when using Colab or a TPU Node, without needing to upload it to Google Cloud Storage.\n\n</Tip>\n\n<Tip>\n\n**\ud83e\udd17Specific Hugging Face Tip\ud83e\udd17:** The methods `Dataset.to_tf_dataset()` and its higher-level wrapper `model.prepare_tf_dataset()` , which you will see throughout our TF code examples, will both fail on a TPU Node. The reason for this is that even though they create a `tf.data.Dataset` it is not a \u201cpure\u201d `tf.data` pipeline and uses `tf.numpy_function` or `Dataset.from_generator()` to stream data from the underlying HuggingFace `Dataset`. This HuggingFace `Dataset` is backed by data that is on a local disc and which the remote TPU Node will not be able to read.\n\n</Tip>\n\nThe second way to access a TPU is via a **TPU VM.** When using a TPU VM, you connect directly to the machine that the TPU is attached to, much like training on a GPU VM. TPU VMs are generally easier to work with, particularly when it comes to your data pipeline. All of the above warnings do not apply to TPU VMs!\n\nThis is an opinionated document, so here\u2019s our opinion: **Avoid using TPU Node if possible.** It is more confusing and more difficult to debug than TPU VMs. It is also likely to be unsupported in future - Google\u2019s latest TPU, TPUv4, can only be accessed as a TPU VM, which suggests that TPU Nodes are increasingly going to become a \u201clegacy\u201d access method. However, we understand that the only free TPU access is on Colab and Kaggle Kernels, which uses TPU Node - so we\u2019ll try to explain how to handle it if you have to! Check the [TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) for code samples that explain this in more detail.\n\n### What sizes of TPU are available?\n\nA single TPU (a v2-8/v3-8/v4-8) runs 8 replicas. TPUs exist in **pods** that can run hundreds or thousands of replicas simultaneously. When you use more than a single TPU but less than a whole pod (for example, a v3-32), your TPU fleet is referred to as a **pod slice.**\n\nWhen you access a free TPU via Colab, you generally get a single v2-8 TPU.\n\n### I keep hearing about this XLA thing. What\u2019s XLA, and how does it relate to TPUs?\n\nXLA is an optimizing compiler, used by both TensorFlow and JAX. In JAX it is the only compiler, whereas in TensorFlow it is optional\n2,\tlabel_mask  # Set negative label positions to 0\nmean_loss = tf.reduce_sum(loss) / tf.reduce_sum(label_mask)\n```\n\nHere, we avoid data-dependent shapes by computing the loss for every position, but zeroing out the masked positions in both the numerator and denominator when we calculate the mean, which yields exactly the same result as the first block while maintaining XLA compatibility. Note that we use the same trick as in rule #1 - converting a `tf.bool` to `tf.float32` and using it as an indicator variable. This is a really useful trick, so remember it if you need to convert your own code to XLA!\n\n#### XLA Rule #3: XLA will need to recompile your model for every different input shape it sees\n\nThis is the big one. What this means is that if your input shapes are very variable, XLA will have to recompile your model over and over, which will create huge performance problems. This commonly arises in NLP models, where input texts have variable lengths after tokenization. In other modalities, static shapes are more common and this rule is much less of a problem.\n\nHow can you get around rule #3? The key is **padding** - if you pad all your inputs to the same length, and then use an `attention_mask`, you can get the same results as you\u2019d get from variable shapes, but without any XLA issues. However, excessive padding can cause severe slowdown too - if you pad all your samples to the maximum length in the whole dataset, you might end up with batches consisting endless padding tokens, which will waste a lot of compute and memory!\n\nThere isn\u2019t a perfect solution to this problem. However, you can try some tricks. One very useful trick is to **pad batches of samples up to a multiple of a number like 32 or 64 tokens.** This often only increases the number of tokens by a small amount, but it hugely reduces the number of unique input shapes, because every input shape now has to be a multiple of 32 or 64. Fewer unique input shapes means fewer XLA compilations!\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** Our tokenizers and data collators have methods that can help you here. You can use `padding=\"max_length\"` or `padding=\"longest\"` when calling tokenizers to get them to output padded data. Our tokenizers and data collators also have a `pad_to_multiple_of` argument that you can use to reduce the number of unique input shapes you see!\n\n</Tip>\n\n### How do I actually train my model on TPU?\n\nOnce your training is XLA-compatible and (if you\u2019re using TPU Node / Colab) your dataset has been prepared appropriately, running on TPU is surprisingly easy! All you really need to change in your code is to add a few lines to initialize your TPU, and to ensure that your model and dataset are created inside a `TPUStrategy` scope. Take a look at [our TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) to see this in action!\n\n### Summary\n\nThere was a lot in here, so let\u2019s summarize with a quick checklist you can follow when you want to get your model ready for TPU training:\n\n- Make sure your code follows the three rules of XLA\n- Compile your model with `jit_compile=True` on CPU/GPU and confirm that you can train it with XLA\n- Either load your dataset into memory or use a TPU-compatible dataset loading approach (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Migrate your code either to Colab (with accelerator set to \u201cTPU\u201d) or a TPU VM on Google Cloud\n- Add TPU initializer code (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Create your `TPUStrategy` and make sure dataset loading and model creation are inside the `strategy.scope()` (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Don\u2019t forget to take `jit_compile=True` out again when you move to TPU!\n- \ud83d\ude4f\ud83d\ude4f\ud83d\ude4f\ud83e\udd7a\ud83e\udd7a\ud83e\udd7a\n- Call model.fit()\n- You did it!\n3,\t\u4e0e\u5e38\u89c4\u51fd\u6570\u76f8\u540c\u7684\u65b9\u5f0f\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio\u3002\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\uff08\u865a\u62df\u7684\uff09\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5b83\u5728\u8f93\u51fa\u56fe\u50cf\u4e4b\u524d\u751f\u6210\u6570\u4e2a\u6b65\u9aa4\u7684\u566a\u97f3\uff1a\n\n$code_fake_diffusion\n$demo_fake_diffusion\n\n\u8bf7\u6ce8\u610f\uff0c\u6211\u4eec\u5728\u8fed\u4ee3\u5668\u4e2d\u6dfb\u52a0\u4e86 `time.sleep(1)`\uff0c\u4ee5\u521b\u5efa\u6b65\u9aa4\u4e4b\u95f4\u7684\u4eba\u5de5\u6682\u505c\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u89c2\u5bdf\u8fed\u4ee3\u5668\u7684\u6b65\u9aa4\uff08\u5728\u771f\u5b9e\u7684\u56fe\u50cf\u751f\u6210\u6a21\u578b\u4e2d\uff0c\u8fd9\u53ef\u80fd\u662f\u4e0d\u5fc5\u8981\u7684\uff09\u3002\n\n\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio **\u9700\u8981**\u5728\u5e95\u5c42 Interface \u6216 Blocks \u4e2d\u542f\u7528\u961f\u5217\uff08\u8bf7\u53c2\u9605\u4e0a\u9762\u7684\u961f\u5217\u90e8\u5206\uff09\u3002\n\n## \u8fdb\u5ea6\u6761\n\nGradio \u652f\u6301\u521b\u5efa\u81ea\u5b9a\u4e49\u8fdb\u5ea6\u6761\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u81ea\u5b9a\u4e49\u548c\u63a7\u5236\u5411\u7528\u6237\u663e\u793a\u7684\u8fdb\u5ea6\u66f4\u65b0\u3002\u8981\u542f\u7528\u6b64\u529f\u80fd\uff0c\u53ea\u9700\u4e3a\u65b9\u6cd5\u6dfb\u52a0\u4e00\u4e2a\u9ed8\u8ba4\u503c\u4e3a `gr.Progress` \u5b9e\u4f8b\u7684\u53c2\u6570\u5373\u53ef\u3002\u7136\u540e\uff0c\u60a8\u53ef\u4ee5\u76f4\u63a5\u8c03\u7528\u6b64\u5b9e\u4f8b\u5e76\u4f20\u5165 0 \u5230 1 \u4e4b\u95f4\u7684\u6d6e\u70b9\u6570\u6765\u66f4\u65b0\u8fdb\u5ea6\u7ea7\u522b\uff0c\u6216\u8005 with `Progress` \u5b9e\u4f8b\u7684 `tqdm()` \u65b9\u6cd5\u6765\u8ddf\u8e2a\u53ef\u8fed\u4ee3\u5bf9\u8c61\u4e0a\u7684\u8fdb\u5ea6\uff0c\u5982\u4e0b\u6240\u793a\u3002\u5fc5\u987b\u542f\u7528\u961f\u5217\u4ee5\u8fdb\u884c\u8fdb\u5ea6\u66f4\u65b0\u3002\n\n$code_progress_simple\n$demo_progress_simple\n\n\u5982\u679c\u60a8 with `tqdm` \u5e93\uff0c\u5e76\u4e14\u5e0c\u671b\u4ece\u51fd\u6570\u5185\u90e8\u7684\u4efb\u4f55 `tqdm.tqdm` \u81ea\u52a8\u62a5\u544a\u8fdb\u5ea6\u66f4\u65b0\uff0c\u8bf7\u5c06\u9ed8\u8ba4\u53c2\u6570\u8bbe\u7f6e\u4e3a `gr.Progress(track_tqdm=True)`\uff01\n\n## \u6279\u5904\u7406\u51fd\u6570 (Batch Functions)\n\nGradio \u652f\u6301\u4f20\u9012*\u6279\u5904\u7406*\u51fd\u6570\u3002\u6279\u5904\u7406\u51fd\u6570\u53ea\u662f\u63a5\u53d7\u8f93\u5165\u5217\u8868\u5e76\u8fd4\u56de\u9884\u6d4b\u5217\u8868\u7684\u51fd\u6570\u3002\n\n\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\u6279\u5904\u7406\u51fd\u6570\uff0c\u5b83\u63a5\u53d7\u4e24\u4e2a\u8f93\u5165\u5217\u8868\uff08\u4e00\u4e2a\u5355\u8bcd\u5217\u8868\u548c\u4e00\u4e2a\u6574\u6570\u5217\u8868\uff09\uff0c\u5e76\u8fd4\u56de\u4fee\u526a\u8fc7\u7684\u5355\u8bcd\u5217\u8868\u4f5c\u4e3a\u8f93\u51fa\uff1a\n\n```python\nimport time\n\ndef trim_words(words, lens):\n    trimmed_words = []\n    time.sleep(5)\n    for w, l in zip(words, lens):\n        trimmed_words.append(w[:int(l)])\n    return [trimmed_words]\n    for w, l in zip(words, lens):\n```\n\n\u4f7f\u7528\u6279\u5904\u7406\u51fd\u6570\u7684\u4f18\u70b9\u662f\uff0c\u5982\u679c\u542f\u7528\u4e86\u961f\u5217\uff0cGradio \u670d\u52a1\u5668\u53ef\u4ee5\u81ea\u52a8*\u6279\u5904\u7406*\u4f20\u5165\u7684\u8bf7\u6c42\u5e76\u5e76\u884c\u5904\u7406\u5b83\u4eec\uff0c\u4ece\u800c\u53ef\u80fd\u52a0\u5feb\u6f14\u793a\u901f\u5ea6\u3002\u4ee5\u4e0b\u662f Gradio \u4ee3\u7801\u7684\u793a\u4f8b\uff08\u8bf7\u6ce8\u610f `batch=True` \u548c `max_batch_size=16` - \u8fd9\u4e24\u4e2a\u53c2\u6570\u90fd\u53ef\u4ee5\u4f20\u9012\u7ed9\u4e8b\u4ef6\u89e6\u53d1\u5668\u6216 `Interface` \u7c7b\uff09\n\nwith `Interface`\uff1a\n\n```python\ndemo = gr.Interface(trim_words, [\"textbox\", \"number\"], [\"output\"],\n                    batch=True, max_batch_size=16)\ndemo.queue()\ndemo.launch()\n```\n\nwith `Blocks`\uff1a\n\n```python\nimport gradio as gr\n\nwith gr.Blocks() as demo:\n    with gr.Row():\n        word = gr.Textbox(label=\"word\")\n        leng = gr.Number(label=\"leng\")\n        output = gr.Textbox(label=\"Output\")\n    with gr.Row():\n        run = gr.Button()\n\n    event = run.click(trim_words, [word, leng], output, batch=True, max_batch_size=16)\n\ndemo.queue()\ndemo.launch()\n```\n\n\u5728\u4e0a\u9762\u7684\u793a\u4f8b\u4e2d\uff0c\u53ef\u4ee5\u5e76\u884c\u5904\u7406 16 \u4e2a\u8bf7\u6c42\uff08\u603b\u63a8\u7406\u65f6\u95f4\u4e3a 5 \u79d2\uff09\uff0c\u800c\u4e0d\u662f\u5206\u522b\u5904\u7406\u6bcf\u4e2a\u8bf7\u6c42\uff08\u603b\u63a8\u7406\u65f6\u95f4\u4e3a 80 \u79d2\uff09\u3002\u8bb8\u591a Hugging Face \u7684 `transformers` \u548c `diffusers` \u6a21\u578b\u5728 Gradio \u7684\u6279\u5904\u7406\u6a21\u5f0f\u4e0b\u81ea\u7136\u5de5\u4f5c\uff1a\u8fd9\u662f[\u4f7f\u7528\u6279\u5904\u7406\u751f\u6210\u56fe\u50cf\u7684\u793a\u4f8b\u6f14\u793a](https://github.com/gradio-app/gradio/blob/main/demo/diffusers_with_batching/run.py)\n\n\u6ce8\u610f\uff1a\u4f7f\u7528 Gradio \u7684\u6279\u5904\u7406\u51fd\u6570 **requires** \u5728\u5e95\u5c42 Interface \u6216 Blocks \u4e2d\u542f\u7528\u961f\u5217\uff08\u8bf7\u53c2\u9605\u4e0a\u9762\u7684\u961f\u5217\u90e8\u5206\uff09\u3002\n\n## Gradio \u7b14\u8bb0\u672c (Colab Notebooks)\n\nGradio \u53ef\u4ee5\u5728\u4efb\u4f55\u8fd0\u884c Python \u7684\u5730\u65b9\u8fd0\u884c\uff0c\u5305\u62ec\u672c\u5730 Jupyter \u7b14\u8bb0\u672c\u548c\u534f\u4f5c\u7b14\u8bb0\u672c\uff0c\u5982[Google Colab](https://colab.research.google.com/)\u3002\u5bf9\u4e8e\u672c\u5730 Jupyter \u7b14\u8bb0\u672c\u548c Google Colab \u7b14\u8bb0\u672c\uff0cGradio \u5728\u672c\u5730\u670d\u52a1\u5668\u4e0a\u8fd0\u884c\uff0c\u60a8\u53ef\u4ee5\u5728\u6d4f\u89c8\u5668\u4e2d\u4e0e\u4e4b\u4ea4\u4e92\u3002\uff08\u6ce8\u610f\uff1a\u5bf9\u4e8e Google Colab\uff0c\u8fd9\u662f\u901a\u8fc7[\u670d\u52a1\u5de5\u4f5c\u5668\u96a7\u9053](https://github.com/tensorflow/tensorboard/blob/master/docs/design/colab_integration.md)\u5b9e\u73b0\u7684\uff0c\u60a8\u7684\u6d4f\u89c8\u5668\u9700\u8981\u542f\u7528 cookies\u3002\uff09\u5bf9\u4e8e\u5176\u4ed6\u8fdc\u7a0b\u7b14\u8bb0\u672c\uff0cGradio \u4e5f\u5c06\u5728\u670d\u52a1\u5668\u4e0a\u8fd0\u884c\uff0c\u4f46\u60a8\u9700\u8981\u4f7f\u7528[SSH \u96a7\u9053](https://coderwall.com/p/ohk6cg/remote-access-to-ipython-notebooks-via-ssh)\u5728\u672c\u5730\u6d4f\u89c8\u5668\u4e2d\u67e5\u770b\u5e94\u7528\u7a0b\u5e8f\u3002\u901a\u5e38\uff0c\u66f4\u7b80\u5355\u7684\u9009\u62e9\u662f\u4f7f\u7528 Gradio \u5185\u7f6e\u7684\u516c\u5171\u94fe\u63a5\uff0c[\u5728\u4e0b\u4e00\u7bc7\u6307\u5357\u4e2d\u8ba8\u8bba](/sharing-your-app/#sharing-demos)\u3002\n    ```",
            "vector_context": "[Created at: 2025-03-24 13:17:32]\n!--Copyright 2023 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\nthe License. You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under the License is distributed on\nan \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n\n\u26a0\ufe0f Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be\nrendered properly in your Markdown viewer.\n\n-->\n\n# Training on TPU with TensorFlow\n\n<Tip>\n\nIf you don't need long explanations and just want TPU code samples to get started with, check out [our TPU example notebook!](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb)\n\n</Tip>\n\n### What is a TPU?\n\nA TPU is a **Tensor Processing Unit.** They are hardware designed by Google, which are used to greatly speed up the tensor computations within neural networks, much like GPUs. They can be used for both network training and inference. They are generally accessed through Google\u2019s cloud services, but small TPUs can also be accessed directly for free through Google Colab and Kaggle Kernels.\n\nBecause [all TensorFlow models in \ud83e\udd17 Transformers are Keras models](https://huggingface.co/blog/tensorflow-philosophy), most of the methods in this document are generally applicable to TPU training for any Keras model! However, there are a few points that are specific to the HuggingFace ecosystem (hug-o-system?) of Transformers and Datasets, and we\u2019ll make sure to flag them up when we get to them.\n\n### What kinds of TPU are available?\n\nNew users are often very confused by the range of TPUs, and the different ways to access them. The first key distinction to understand is the difference between **TPU Nodes** and **TPU VMs.**\n\nWhen you use a **TPU Node**, you are effectively indirectly accessing a remote TPU. You will need a separate VM, which will initialize your network and data pipeline and then forward them to the remote node. When you use a TPU on Google Colab, you are accessing it in the **TPU Node** style.\n\nUsing TPU Nodes can have some quite unexpected behaviour for people who aren\u2019t used to them! In particular, because the TPU is located on a physically different system to the machine you\u2019re running your Python code on, your data cannot be local to your machine - any data pipeline that loads from your machine\u2019s internal storage will totally fail! Instead, data must be stored in Google Cloud Storage where your data pipeline can still access it, even when the pipeline is running on the remote TPU node.\n\n<Tip>\n\nIf you can fit all your data in memory as `np.ndarray` or `tf.Tensor`, then you can `fit()` on that data even when using Colab or a TPU Node, without needing to upload it to Google Cloud Storage.\n\n</Tip>\n\n<Tip>\n\n**\ud83e\udd17Specific Hugging Face Tip\ud83e\udd17:** The methods `Dataset.to_tf_dataset()` and its higher-level wrapper `model.prepare_tf_dataset()` , which you will see throughout our TF code examples, will both fail on a TPU Node. The reason for this is that even though they create a `tf.data.Dataset` it is not a \u201cpure\u201d `tf.data` pipeline and uses `tf.numpy_function` or `Dataset.from_generator()` to stream data from the underlying HuggingFace `Dataset`. This HuggingFace `Dataset` is backed by data that is on a local disc and which the remote TPU Node will not be able to read.\n\n</Tip>\n\nThe second way to access a TPU is via a **TPU VM.** When using a TPU VM, you connect directly to the machine that the TPU is attached to, much like training on a GPU VM. TPU VMs are generally easier to work with, particularly when it comes to your data pipeline. All of the above warnings do not apply to TPU VMs!\n\nThis is an opinionated document, so here\u2019s our opinion: **Avoid using TPU Node if possible.** It is more confusing and more difficult to debug than TPU VMs. It is also likely to be unsupported in future - Google\u2019s latest TPU, TPUv4, can only be accessed as a TPU VM, which suggests that TPU Nodes are increasingly going to become a \u201clegacy\u201d access method. However, we understand that the only free TPU access is on Colab and Kaggle Kernels, which uses TPU Node - so we\u2019ll try to explain how to handle it if you have to! Check the [TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) for code samples that explain this in more detail.\n\n### What sizes of TPU are available?\n\nA single TPU (a v2-8/v3-8/v4-8) runs 8 replicas. TPUs exist in **pods** that can run hundreds or thousands of replicas simultaneously. When you use more than a single TPU but less than a whole pod (for example, a v3-32), your TPU fleet is referred to as a **pod slice.**\n\nWhen you access a free TPU via Colab, you generally get a single v2-8 TPU.\n\n### I keep hearing about this XLA thing. What\u2019s XLA, and how does it relate to TPUs?\n\nXLA is an optimizing compiler, used by both TensorFlow and JAX. In JAX it is the only compiler, whereas in TensorFlow it is optional\n--New Chunk--\n[Created at: 2025-03-24 13:17:32]\n(for example, a v3-32), your TPU fleet is referred to as a **pod slice.**\n\nWhen you access a free TPU via Colab, you generally get a single v2-8 TPU.\n\n### I keep hearing about this XLA thing. What\u2019s XLA, and how does it relate to TPUs?\n\nXLA is an optimizing compiler, used by both TensorFlow and JAX. In JAX it is the only compiler, whereas in TensorFlow it is optional (but mandatory on TPU!). The easiest way to enable it when training a Keras model is to pass the argument `jit_compile=True` to `model.compile()`. If you don\u2019t get any errors and performance is good, that\u2019s a great sign that you\u2019re ready to move to TPU!\n\nDebugging on TPU is generally a bit harder than on CPU/GPU, so we recommend getting your code running on CPU/GPU with XLA first before trying it on TPU. You don\u2019t have to train for long, of course - just for a few steps to make sure that your model and data pipeline are working like you expect them to.\n\n<Tip>\n\nXLA compiled code is usually faster - so even if you\u2019re not planning to run on TPU, adding `jit_compile=True` can improve your performance. Be sure to note the caveats below about XLA compatibility, though!\n\n</Tip>\n\n<Tip warning={true}>\n\n**Tip born of painful experience:** Although using `jit_compile=True` is a good way to get a speed boost and test if your CPU/GPU code is XLA-compatible, it can actually cause a lot of problems if you leave it in when actually training on TPU. XLA compilation will happen implicitly on TPU, so remember to remove that line before actually running your code on a TPU!\n\n</Tip>\n\n### How do I make my model XLA compatible?\n\nIn many cases, your code is probably XLA-compatible already! However, there are a few things that work in normal TensorFlow that don\u2019t work in XLA. We\u2019ve distilled them into three core rules below:\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** We\u2019ve put a lot of effort into rewriting our TensorFlow models and loss functions to be XLA-compatible. Our models and loss functions generally obey rule #1 and #2 by default, so you can skip over them if you\u2019re using `transformers` models. Don\u2019t forget about these rules when writing your own models and loss functions, though!\n\n</Tip>\n\n#### XLA Rule #1: Your code cannot have \u201cdata-dependent conditionals\u201d\n\nWhat that means is that any `if` statement cannot depend on values inside a `tf.Tensor`. For example, this code block cannot be compiled with XLA!\n\n```python\nif tf.reduce_sum(tensor) > 10:\n    tensor = tensor / 2.0\n```\n\nThis might seem very restrictive at first, but most neural net code doesn\u2019t need to do this. You can often get around this restriction by using `tf.cond` (see the documentation [here](https://www.tensorflow.org/api_docs/python/tf/cond)) or by removing the conditional and finding a clever math trick with indicator variables instead, like so:\n\n```python\nsum_over_10 = tf.cast(tf.reduce_sum(tensor) > 10, tf.float32)\ntensor = tensor / (1.0 + sum_over_10)\n```\n\nThis code has exactly the same effect as the code above, but by avoiding a conditional, we ensure it will compile with XLA without problems!\n\n#### XLA Rule #2: Your code cannot have \u201cdata-dependent shapes\u201d\n\nWhat this means is that the shape of all of the `tf.Tensor` objects in your code cannot depend on their values. For example, the function `tf.unique` cannot be compiled with XLA, because it returns a `tensor` containing one instance of each unique value in the input. The shape of this output will obviously be different depending on how repetitive the input `Tensor` was, and so XLA refuses to handle it!\n\nIn general, most neural network code obeys rule #2 by default. However, there are a few common cases where it becomes a problem. One very common one is when you use **label masking**, setting your labels to a negative value to indicate that those positions should be ignored when computing the loss. If you look at NumPy or PyTorch loss functions that support label masking, you will often see code like this that uses [boolean indexing](https://numpy.org/doc/stable/user/basics.indexing.html#boolean-array-indexing):\n\n```python\nlabel_mask = labels >= 0\nmasked_outputs = outputs[label_mask]\nmasked_labels = labels[label_mask]\nloss = compute_loss(masked_outputs, masked_labels)\nmean_loss = torch.mean(loss)\n```\n\nThis code is totally fine in NumPy or PyTorch, but it breaks in XLA! Why? Because the shape of `masked_outputs` and `masked_labels` depends on how many positions are masked - that makes it a **data-dependent shape.** However, just like for rule #1, we can often rewrite this code to yield exactly the same output without any data-dependent shapes.\n\n```python\nlabel_mask = tf.cast(labels >= 0, tf.float32)\nloss = compute_loss(outputs, labels)\nloss = loss * label_mask  # Set negative label positions to 0\nmean_loss = tf.reduce_sum(loss) / tf.reduce_sum(label_mask)\n```\n\nHere, we avoid data-dependent shapes by computing the loss for every position, but zeroing out the masked positions in both the numerator and denominator when we calculate the mean, which yields exactly the same result as the first block while maintaining XLA compatibility. Note that we use the same trick as in rule #1 - converting a `tf.bool` to `\n--New Chunk--\n[Created at: 2025-03-24 13:17:32]\nlabel_mask  # Set negative label positions to 0\nmean_loss = tf.reduce_sum(loss) / tf.reduce_sum(label_mask)\n```\n\nHere, we avoid data-dependent shapes by computing the loss for every position, but zeroing out the masked positions in both the numerator and denominator when we calculate the mean, which yields exactly the same result as the first block while maintaining XLA compatibility. Note that we use the same trick as in rule #1 - converting a `tf.bool` to `tf.float32` and using it as an indicator variable. This is a really useful trick, so remember it if you need to convert your own code to XLA!\n\n#### XLA Rule #3: XLA will need to recompile your model for every different input shape it sees\n\nThis is the big one. What this means is that if your input shapes are very variable, XLA will have to recompile your model over and over, which will create huge performance problems. This commonly arises in NLP models, where input texts have variable lengths after tokenization. In other modalities, static shapes are more common and this rule is much less of a problem.\n\nHow can you get around rule #3? The key is **padding** - if you pad all your inputs to the same length, and then use an `attention_mask`, you can get the same results as you\u2019d get from variable shapes, but without any XLA issues. However, excessive padding can cause severe slowdown too - if you pad all your samples to the maximum length in the whole dataset, you might end up with batches consisting endless padding tokens, which will waste a lot of compute and memory!\n\nThere isn\u2019t a perfect solution to this problem. However, you can try some tricks. One very useful trick is to **pad batches of samples up to a multiple of a number like 32 or 64 tokens.** This often only increases the number of tokens by a small amount, but it hugely reduces the number of unique input shapes, because every input shape now has to be a multiple of 32 or 64. Fewer unique input shapes means fewer XLA compilations!\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** Our tokenizers and data collators have methods that can help you here. You can use `padding=\"max_length\"` or `padding=\"longest\"` when calling tokenizers to get them to output padded data. Our tokenizers and data collators also have a `pad_to_multiple_of` argument that you can use to reduce the number of unique input shapes you see!\n\n</Tip>\n\n### How do I actually train my model on TPU?\n\nOnce your training is XLA-compatible and (if you\u2019re using TPU Node / Colab) your dataset has been prepared appropriately, running on TPU is surprisingly easy! All you really need to change in your code is to add a few lines to initialize your TPU, and to ensure that your model and dataset are created inside a `TPUStrategy` scope. Take a look at [our TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) to see this in action!\n\n### Summary\n\nThere was a lot in here, so let\u2019s summarize with a quick checklist you can follow when you want to get your model ready for TPU training:\n\n- Make sure your code follows the three rules of XLA\n- Compile your model with `jit_compile=True` on CPU/GPU and confirm that you can train it with XLA\n- Either load your dataset into memory or use a TPU-compatible dataset loading approach (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Migrate your code either to Colab (with accelerator set to \u201cTPU\u201d) or a TPU VM on Google Cloud\n- Add TPU initializer code (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Create your `TPUStrategy` and make sure dataset loading and model creation are inside the `strategy.scope()` (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Don\u2019t forget to take `jit_compile=True` out again when you move to TPU!\n- \ud83d\ude4f\ud83d\ude4f\ud83d\ude4f\ud83e\udd7a\ud83e\udd7a\ud83e\udd7a\n- Call model.fit()\n- You did it!"
        }
    },
    {
        "sample_idx": 55,
        "question": "What is XLA?",
        "answer": "XLA is an optimizing compiler used by both TensorFlow and JAX.",
        "rag_answer": "### What is XLA?\n\nXLA (Accelerated Linear Algebra) is an optimizing compiler used by both TensorFlow and",
        "rag_score": null,
        "rag_feedback": null,
        "rag_context": {
            "kg_context": "-----Entities-----\n    ```csv\n    id,\tentity,\ttype,\tdescription,\trankcreated_at\n1,\tTPU,technology,TPU is a Tensor Processing Unit, a hardware designed by Google to speed up tensor computations within neural networks.<SEP>TPU is a type of hardware accelerator designed for machine learning workloads.<SEP>TPU is a type of hardware accelerator used for machine learning computations.,4,2025-03-24 13:18:20\n2,\tXLA,technology,XLA is a technology that compiles TensorFlow graphs into executable code for various platforms.<SEP>XLA is an optimizing compiler used by TensorFlow and JAX to improve performance.<SEP>XLA is an optimizing compiler, used by both TensorFlow and JAX to optimize computations.,6,2025-03-24 13:18:20\n3,\tTensorFlow,category,TensorFlow is a machine learning framework that uses XLA as an optimizing compiler.<SEP>TensorFlow is a software framework used for building and training neural networks.<SEP>TensorFlow is an open-source machine learning framework.,3,2025-03-24 13:18:20\n4,\tKeras,category,Keras is a high-level neural networks API, used for building and training neural networks.<SEP>Keras is a machine learning framework that uses XLA for optimization.,2,2025-03-24 13:18:20\n5,\tGoogle,organization,Google is the company that designs and provides TPUs, which are used to speed up tensor computations within neural networks.,3,UNKNOWN\n6,\tTensorFlow,category,TensorFlow is a machine learning framework that uses XLA as an optimizing compiler.<SEP>TensorFlow is a software framework used for building and training neural networks.<SEP>TensorFlow is an open-source machine learning framework.,3,UNKNOWN\n7,\tTensor Processing Unit,category,Tensor Processing Unit is a hardware designed by Google to speed up tensor computations within neural networks.,0,UNKNOWN\n    ```\n    -----Relationships-----\n    ```csv\n    id,\tsource,\ttarget,\tdescription,\tkeywords,\tweight,\trank,\tcreated_at\n1,\tTPU,XLA,XLA compiles TensorFlow graphs into executable code for TPU hardware.<SEP>XLA is used to optimize code for TPU hardware.,compilation, hardware acceleration<SEP>compiler, hardware optimization,36.0,10,2025-03-24 13:18:20\n2,\tTensorFlow,XLA,TensorFlow graphs can be compiled into executable code using XLA.<SEP>TensorFlow uses XLA as an optimizing compiler to improve performance.,compilation, framework support<SEP>compiler, performance optimization,23.0,9,2025-03-24 13:18:20\n3,\tKeras,XLA,Keras uses XLA for optimization.,compiler, performance optimization,8.0,8,2025-03-24 13:18:20\n4,\tTensorFlow,XLA,TensorFlow graphs can be compiled into executable code using XLA.<SEP>TensorFlow uses XLA as an optimizing compiler to improve performance.,compilation, framework support<SEP>compiler, performance optimization,23.0,9,UNKNOWN\n5,\tHuggingFace,TensorFlow,HuggingFace provides a range of AI models and tools, including the Transformers and Datasets ecosystem, which are built on top of TensorFlow.,ecosystem integration, AI models,18.0,8,UNKNOWN\n6,\tGoogle,TPU,Google designs and provides TPUs, which are used to speed up tensor computations within neural networks.,hardware design, acceleration,18.0,7,UNKNOWN\n7,\tColab,Google,Colab is a cloud-based platform provided by Google for data science and machine learning.,platform provision, cloud computing,16.0,6,UNKNOWN\n8,\tKeras,TensorFlow,TensorFlow uses Keras as a high-level neural networks API.,API integration, neural networks,16.0,5,UNKNOWN\n9,\tGoogle,Kaggle Kernels,Kaggle Kernels is a cloud-based platform provided by Google for data science and machine learning competitions.,platform provision, cloud computing,16.0,4,UNKNOWN\n    ```\n    -----Sources-----\n    ```csv\n    id,\tcontent\n1,\t(for example, a v3-32), your TPU fleet is referred to as a **pod slice.**\n\nWhen you access a free TPU via Colab, you generally get a single v2-8 TPU.\n\n### I keep hearing about this XLA thing. What\u2019s XLA, and how does it relate to TPUs?\n\nXLA is an optimizing compiler, used by both TensorFlow and JAX. In JAX it is the only compiler, whereas in TensorFlow it is optional (but mandatory on TPU!). The easiest way to enable it when training a Keras model is to pass the argument `jit_compile=True` to `model.compile()`. If you don\u2019t get any errors and performance is good, that\u2019s a great sign that you\u2019re ready to move to TPU!\n\nDebugging on TPU is generally a bit harder than on CPU/GPU, so we recommend getting your code running on CPU/GPU with XLA first before trying it on TPU. You don\u2019t have to train for long, of course - just for a few steps to make sure that your model and data pipeline are working like you expect them to.\n\n<Tip>\n\nXLA compiled code is usually faster - so even if you\u2019re not planning to run on TPU, adding `jit_compile=True` can improve your performance. Be sure to note the caveats below about XLA compatibility, though!\n\n</Tip>\n\n<Tip warning={true}>\n\n**Tip born of painful experience:** Although using `jit_compile=True` is a good way to get a speed boost and test if your CPU/GPU code is XLA-compatible, it can actually cause a lot of problems if you leave it in when actually training on TPU. XLA compilation will happen implicitly on TPU, so remember to remove that line before actually running your code on a TPU!\n\n</Tip>\n\n### How do I make my model XLA compatible?\n\nIn many cases, your code is probably XLA-compatible already! However, there are a few things that work in normal TensorFlow that don\u2019t work in XLA. We\u2019ve distilled them into three core rules below:\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** We\u2019ve put a lot of effort into rewriting our TensorFlow models and loss functions to be XLA-compatible. Our models and loss functions generally obey rule #1 and #2 by default, so you can skip over them if you\u2019re using `transformers` models. Don\u2019t forget about these rules when writing your own models and loss functions, though!\n\n</Tip>\n\n#### XLA Rule #1: Your code cannot have \u201cdata-dependent conditionals\u201d\n\nWhat that means is that any `if` statement cannot depend on values inside a `tf.Tensor`. For example, this code block cannot be compiled with XLA!\n\n```python\nif tf.reduce_sum(tensor) > 10:\n    tensor = tensor / 2.0\n```\n\nThis might seem very restrictive at first, but most neural net code doesn\u2019t need to do this. You can often get around this restriction by using `tf.cond` (see the documentation [here](https://www.tensorflow.org/api_docs/python/tf/cond)) or by removing the conditional and finding a clever math trick with indicator variables instead, like so:\n\n```python\nsum_over_10 = tf.cast(tf.reduce_sum(tensor) > 10, tf.float32)\ntensor = tensor / (1.0 + sum_over_10)\n```\n\nThis code has exactly the same effect as the code above, but by avoiding a conditional, we ensure it will compile with XLA without problems!\n\n#### XLA Rule #2: Your code cannot have \u201cdata-dependent shapes\u201d\n\nWhat this means is that the shape of all of the `tf.Tensor` objects in your code cannot depend on their values. For example, the function `tf.unique` cannot be compiled with XLA, because it returns a `tensor` containing one instance of each unique value in the input. The shape of this output will obviously be different depending on how repetitive the input `Tensor` was, and so XLA refuses to handle it!\n\nIn general, most neural network code obeys rule #2 by default. However, there are a few common cases where it becomes a problem. One very common one is when you use **label masking**, setting your labels to a negative value to indicate that those positions should be ignored when computing the loss. If you look at NumPy or PyTorch loss functions that support label masking, you will often see code like this that uses [boolean indexing](https://numpy.org/doc/stable/user/basics.indexing.html#boolean-array-indexing):\n\n```python\nlabel_mask = labels >= 0\nmasked_outputs = outputs[label_mask]\nmasked_labels = labels[label_mask]\nloss = compute_loss(masked_outputs, masked_labels)\nmean_loss = torch.mean(loss)\n```\n\nThis code is totally fine in NumPy or PyTorch, but it breaks in XLA! Why? Because the shape of `masked_outputs` and `masked_labels` depends on how many positions are masked - that makes it a **data-dependent shape.** However, just like for rule #1, we can often rewrite this code to yield exactly the same output without any data-dependent shapes.\n\n```python\nlabel_mask = tf.cast(labels >= 0, tf.float32)\nloss = compute_loss(outputs, labels)\nloss = loss * label_mask  # Set negative label positions to 0\nmean_loss = tf.reduce_sum(loss) / tf.reduce_sum(label_mask)\n```\n\nHere, we avoid data-dependent shapes by computing the loss for every position, but zeroing out the masked positions in both the numerator and denominator when we calculate the mean, which yields exactly the same result as the first block while maintaining XLA compatibility. Note that we use the same trick as in rule #1 - converting a `tf.bool` to `\n2,\tlabel_mask  # Set negative label positions to 0\nmean_loss = tf.reduce_sum(loss) / tf.reduce_sum(label_mask)\n```\n\nHere, we avoid data-dependent shapes by computing the loss for every position, but zeroing out the masked positions in both the numerator and denominator when we calculate the mean, which yields exactly the same result as the first block while maintaining XLA compatibility. Note that we use the same trick as in rule #1 - converting a `tf.bool` to `tf.float32` and using it as an indicator variable. This is a really useful trick, so remember it if you need to convert your own code to XLA!\n\n#### XLA Rule #3: XLA will need to recompile your model for every different input shape it sees\n\nThis is the big one. What this means is that if your input shapes are very variable, XLA will have to recompile your model over and over, which will create huge performance problems. This commonly arises in NLP models, where input texts have variable lengths after tokenization. In other modalities, static shapes are more common and this rule is much less of a problem.\n\nHow can you get around rule #3? The key is **padding** - if you pad all your inputs to the same length, and then use an `attention_mask`, you can get the same results as you\u2019d get from variable shapes, but without any XLA issues. However, excessive padding can cause severe slowdown too - if you pad all your samples to the maximum length in the whole dataset, you might end up with batches consisting endless padding tokens, which will waste a lot of compute and memory!\n\nThere isn\u2019t a perfect solution to this problem. However, you can try some tricks. One very useful trick is to **pad batches of samples up to a multiple of a number like 32 or 64 tokens.** This often only increases the number of tokens by a small amount, but it hugely reduces the number of unique input shapes, because every input shape now has to be a multiple of 32 or 64. Fewer unique input shapes means fewer XLA compilations!\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** Our tokenizers and data collators have methods that can help you here. You can use `padding=\"max_length\"` or `padding=\"longest\"` when calling tokenizers to get them to output padded data. Our tokenizers and data collators also have a `pad_to_multiple_of` argument that you can use to reduce the number of unique input shapes you see!\n\n</Tip>\n\n### How do I actually train my model on TPU?\n\nOnce your training is XLA-compatible and (if you\u2019re using TPU Node / Colab) your dataset has been prepared appropriately, running on TPU is surprisingly easy! All you really need to change in your code is to add a few lines to initialize your TPU, and to ensure that your model and dataset are created inside a `TPUStrategy` scope. Take a look at [our TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) to see this in action!\n\n### Summary\n\nThere was a lot in here, so let\u2019s summarize with a quick checklist you can follow when you want to get your model ready for TPU training:\n\n- Make sure your code follows the three rules of XLA\n- Compile your model with `jit_compile=True` on CPU/GPU and confirm that you can train it with XLA\n- Either load your dataset into memory or use a TPU-compatible dataset loading approach (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Migrate your code either to Colab (with accelerator set to \u201cTPU\u201d) or a TPU VM on Google Cloud\n- Add TPU initializer code (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Create your `TPUStrategy` and make sure dataset loading and model creation are inside the `strategy.scope()` (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Don\u2019t forget to take `jit_compile=True` out again when you move to TPU!\n- \ud83d\ude4f\ud83d\ude4f\ud83d\ude4f\ud83e\udd7a\ud83e\udd7a\ud83e\udd7a\n- Call model.fit()\n- You did it!\n3,\t!--Copyright 2023 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\nthe License. You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under the License is distributed on\nan \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n\n\u26a0\ufe0f Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be\nrendered properly in your Markdown viewer.\n\n-->\n\n# Training on TPU with TensorFlow\n\n<Tip>\n\nIf you don't need long explanations and just want TPU code samples to get started with, check out [our TPU example notebook!](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb)\n\n</Tip>\n\n### What is a TPU?\n\nA TPU is a **Tensor Processing Unit.** They are hardware designed by Google, which are used to greatly speed up the tensor computations within neural networks, much like GPUs. They can be used for both network training and inference. They are generally accessed through Google\u2019s cloud services, but small TPUs can also be accessed directly for free through Google Colab and Kaggle Kernels.\n\nBecause [all TensorFlow models in \ud83e\udd17 Transformers are Keras models](https://huggingface.co/blog/tensorflow-philosophy), most of the methods in this document are generally applicable to TPU training for any Keras model! However, there are a few points that are specific to the HuggingFace ecosystem (hug-o-system?) of Transformers and Datasets, and we\u2019ll make sure to flag them up when we get to them.\n\n### What kinds of TPU are available?\n\nNew users are often very confused by the range of TPUs, and the different ways to access them. The first key distinction to understand is the difference between **TPU Nodes** and **TPU VMs.**\n\nWhen you use a **TPU Node**, you are effectively indirectly accessing a remote TPU. You will need a separate VM, which will initialize your network and data pipeline and then forward them to the remote node. When you use a TPU on Google Colab, you are accessing it in the **TPU Node** style.\n\nUsing TPU Nodes can have some quite unexpected behaviour for people who aren\u2019t used to them! In particular, because the TPU is located on a physically different system to the machine you\u2019re running your Python code on, your data cannot be local to your machine - any data pipeline that loads from your machine\u2019s internal storage will totally fail! Instead, data must be stored in Google Cloud Storage where your data pipeline can still access it, even when the pipeline is running on the remote TPU node.\n\n<Tip>\n\nIf you can fit all your data in memory as `np.ndarray` or `tf.Tensor`, then you can `fit()` on that data even when using Colab or a TPU Node, without needing to upload it to Google Cloud Storage.\n\n</Tip>\n\n<Tip>\n\n**\ud83e\udd17Specific Hugging Face Tip\ud83e\udd17:** The methods `Dataset.to_tf_dataset()` and its higher-level wrapper `model.prepare_tf_dataset()` , which you will see throughout our TF code examples, will both fail on a TPU Node. The reason for this is that even though they create a `tf.data.Dataset` it is not a \u201cpure\u201d `tf.data` pipeline and uses `tf.numpy_function` or `Dataset.from_generator()` to stream data from the underlying HuggingFace `Dataset`. This HuggingFace `Dataset` is backed by data that is on a local disc and which the remote TPU Node will not be able to read.\n\n</Tip>\n\nThe second way to access a TPU is via a **TPU VM.** When using a TPU VM, you connect directly to the machine that the TPU is attached to, much like training on a GPU VM. TPU VMs are generally easier to work with, particularly when it comes to your data pipeline. All of the above warnings do not apply to TPU VMs!\n\nThis is an opinionated document, so here\u2019s our opinion: **Avoid using TPU Node if possible.** It is more confusing and more difficult to debug than TPU VMs. It is also likely to be unsupported in future - Google\u2019s latest TPU, TPUv4, can only be accessed as a TPU VM, which suggests that TPU Nodes are increasingly going to become a \u201clegacy\u201d access method. However, we understand that the only free TPU access is on Colab and Kaggle Kernels, which uses TPU Node - so we\u2019ll try to explain how to handle it if you have to! Check the [TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) for code samples that explain this in more detail.\n\n### What sizes of TPU are available?\n\nA single TPU (a v2-8/v3-8/v4-8) runs 8 replicas. TPUs exist in **pods** that can run hundreds or thousands of replicas simultaneously. When you use more than a single TPU but less than a whole pod (for example, a v3-32), your TPU fleet is referred to as a **pod slice.**\n\nWhen you access a free TPU via Colab, you generally get a single v2-8 TPU.\n\n### I keep hearing about this XLA thing. What\u2019s XLA, and how does it relate to TPUs?\n\nXLA is an optimizing compiler, used by both TensorFlow and JAX. In JAX it is the only compiler, whereas in TensorFlow it is optional\n    ```",
            "vector_context": "[Created at: 2025-03-24 13:17:32]\n(for example, a v3-32), your TPU fleet is referred to as a **pod slice.**\n\nWhen you access a free TPU via Colab, you generally get a single v2-8 TPU.\n\n### I keep hearing about this XLA thing. What\u2019s XLA, and how does it relate to TPUs?\n\nXLA is an optimizing compiler, used by both TensorFlow and JAX. In JAX it is the only compiler, whereas in TensorFlow it is optional (but mandatory on TPU!). The easiest way to enable it when training a Keras model is to pass the argument `jit_compile=True` to `model.compile()`. If you don\u2019t get any errors and performance is good, that\u2019s a great sign that you\u2019re ready to move to TPU!\n\nDebugging on TPU is generally a bit harder than on CPU/GPU, so we recommend getting your code running on CPU/GPU with XLA first before trying it on TPU. You don\u2019t have to train for long, of course - just for a few steps to make sure that your model and data pipeline are working like you expect them to.\n\n<Tip>\n\nXLA compiled code is usually faster - so even if you\u2019re not planning to run on TPU, adding `jit_compile=True` can improve your performance. Be sure to note the caveats below about XLA compatibility, though!\n\n</Tip>\n\n<Tip warning={true}>\n\n**Tip born of painful experience:** Although using `jit_compile=True` is a good way to get a speed boost and test if your CPU/GPU code is XLA-compatible, it can actually cause a lot of problems if you leave it in when actually training on TPU. XLA compilation will happen implicitly on TPU, so remember to remove that line before actually running your code on a TPU!\n\n</Tip>\n\n### How do I make my model XLA compatible?\n\nIn many cases, your code is probably XLA-compatible already! However, there are a few things that work in normal TensorFlow that don\u2019t work in XLA. We\u2019ve distilled them into three core rules below:\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** We\u2019ve put a lot of effort into rewriting our TensorFlow models and loss functions to be XLA-compatible. Our models and loss functions generally obey rule #1 and #2 by default, so you can skip over them if you\u2019re using `transformers` models. Don\u2019t forget about these rules when writing your own models and loss functions, though!\n\n</Tip>\n\n#### XLA Rule #1: Your code cannot have \u201cdata-dependent conditionals\u201d\n\nWhat that means is that any `if` statement cannot depend on values inside a `tf.Tensor`. For example, this code block cannot be compiled with XLA!\n\n```python\nif tf.reduce_sum(tensor) > 10:\n    tensor = tensor / 2.0\n```\n\nThis might seem very restrictive at first, but most neural net code doesn\u2019t need to do this. You can often get around this restriction by using `tf.cond` (see the documentation [here](https://www.tensorflow.org/api_docs/python/tf/cond)) or by removing the conditional and finding a clever math trick with indicator variables instead, like so:\n\n```python\nsum_over_10 = tf.cast(tf.reduce_sum(tensor) > 10, tf.float32)\ntensor = tensor / (1.0 + sum_over_10)\n```\n\nThis code has exactly the same effect as the code above, but by avoiding a conditional, we ensure it will compile with XLA without problems!\n\n#### XLA Rule #2: Your code cannot have \u201cdata-dependent shapes\u201d\n\nWhat this means is that the shape of all of the `tf.Tensor` objects in your code cannot depend on their values. For example, the function `tf.unique` cannot be compiled with XLA, because it returns a `tensor` containing one instance of each unique value in the input. The shape of this output will obviously be different depending on how repetitive the input `Tensor` was, and so XLA refuses to handle it!\n\nIn general, most neural network code obeys rule #2 by default. However, there are a few common cases where it becomes a problem. One very common one is when you use **label masking**, setting your labels to a negative value to indicate that those positions should be ignored when computing the loss. If you look at NumPy or PyTorch loss functions that support label masking, you will often see code like this that uses [boolean indexing](https://numpy.org/doc/stable/user/basics.indexing.html#boolean-array-indexing):\n\n```python\nlabel_mask = labels >= 0\nmasked_outputs = outputs[label_mask]\nmasked_labels = labels[label_mask]\nloss = compute_loss(masked_outputs, masked_labels)\nmean_loss = torch.mean(loss)\n```\n\nThis code is totally fine in NumPy or PyTorch, but it breaks in XLA! Why? Because the shape of `masked_outputs` and `masked_labels` depends on how many positions are masked - that makes it a **data-dependent shape.** However, just like for rule #1, we can often rewrite this code to yield exactly the same output without any data-dependent shapes.\n\n```python\nlabel_mask = tf.cast(labels >= 0, tf.float32)\nloss = compute_loss(outputs, labels)\nloss = loss * label_mask  # Set negative label positions to 0\nmean_loss = tf.reduce_sum(loss) / tf.reduce_sum(label_mask)\n```\n\nHere, we avoid data-dependent shapes by computing the loss for every position, but zeroing out the masked positions in both the numerator and denominator when we calculate the mean, which yields exactly the same result as the first block while maintaining XLA compatibility. Note that we use the same trick as in rule #1 - converting a `tf.bool` to `\n--New Chunk--\n[Created at: 2025-03-24 13:17:32]\nlabel_mask  # Set negative label positions to 0\nmean_loss = tf.reduce_sum(loss) / tf.reduce_sum(label_mask)\n```\n\nHere, we avoid data-dependent shapes by computing the loss for every position, but zeroing out the masked positions in both the numerator and denominator when we calculate the mean, which yields exactly the same result as the first block while maintaining XLA compatibility. Note that we use the same trick as in rule #1 - converting a `tf.bool` to `tf.float32` and using it as an indicator variable. This is a really useful trick, so remember it if you need to convert your own code to XLA!\n\n#### XLA Rule #3: XLA will need to recompile your model for every different input shape it sees\n\nThis is the big one. What this means is that if your input shapes are very variable, XLA will have to recompile your model over and over, which will create huge performance problems. This commonly arises in NLP models, where input texts have variable lengths after tokenization. In other modalities, static shapes are more common and this rule is much less of a problem.\n\nHow can you get around rule #3? The key is **padding** - if you pad all your inputs to the same length, and then use an `attention_mask`, you can get the same results as you\u2019d get from variable shapes, but without any XLA issues. However, excessive padding can cause severe slowdown too - if you pad all your samples to the maximum length in the whole dataset, you might end up with batches consisting endless padding tokens, which will waste a lot of compute and memory!\n\nThere isn\u2019t a perfect solution to this problem. However, you can try some tricks. One very useful trick is to **pad batches of samples up to a multiple of a number like 32 or 64 tokens.** This often only increases the number of tokens by a small amount, but it hugely reduces the number of unique input shapes, because every input shape now has to be a multiple of 32 or 64. Fewer unique input shapes means fewer XLA compilations!\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** Our tokenizers and data collators have methods that can help you here. You can use `padding=\"max_length\"` or `padding=\"longest\"` when calling tokenizers to get them to output padded data. Our tokenizers and data collators also have a `pad_to_multiple_of` argument that you can use to reduce the number of unique input shapes you see!\n\n</Tip>\n\n### How do I actually train my model on TPU?\n\nOnce your training is XLA-compatible and (if you\u2019re using TPU Node / Colab) your dataset has been prepared appropriately, running on TPU is surprisingly easy! All you really need to change in your code is to add a few lines to initialize your TPU, and to ensure that your model and dataset are created inside a `TPUStrategy` scope. Take a look at [our TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) to see this in action!\n\n### Summary\n\nThere was a lot in here, so let\u2019s summarize with a quick checklist you can follow when you want to get your model ready for TPU training:\n\n- Make sure your code follows the three rules of XLA\n- Compile your model with `jit_compile=True` on CPU/GPU and confirm that you can train it with XLA\n- Either load your dataset into memory or use a TPU-compatible dataset loading approach (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Migrate your code either to Colab (with accelerator set to \u201cTPU\u201d) or a TPU VM on Google Cloud\n- Add TPU initializer code (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Create your `TPUStrategy` and make sure dataset loading and model creation are inside the `strategy.scope()` (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Don\u2019t forget to take `jit_compile=True` out again when you move to TPU!\n- \ud83d\ude4f\ud83d\ude4f\ud83d\ude4f\ud83e\udd7a\ud83e\udd7a\ud83e\udd7a\n- Call model.fit()\n- You did it!\n--New Chunk--\n[Created at: 2025-03-24 13:17:32]\n!--Copyright 2023 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\nthe License. You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under the License is distributed on\nan \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n\n\u26a0\ufe0f Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be\nrendered properly in your Markdown viewer.\n\n-->\n\n# Training on TPU with TensorFlow\n\n<Tip>\n\nIf you don't need long explanations and just want TPU code samples to get started with, check out [our TPU example notebook!](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb)\n\n</Tip>\n\n### What is a TPU?\n\nA TPU is a **Tensor Processing Unit.** They are hardware designed by Google, which are used to greatly speed up the tensor computations within neural networks, much like GPUs. They can be used for both network training and inference. They are generally accessed through Google\u2019s cloud services, but small TPUs can also be accessed directly for free through Google Colab and Kaggle Kernels.\n\nBecause [all TensorFlow models in \ud83e\udd17 Transformers are Keras models](https://huggingface.co/blog/tensorflow-philosophy), most of the methods in this document are generally applicable to TPU training for any Keras model! However, there are a few points that are specific to the HuggingFace ecosystem (hug-o-system?) of Transformers and Datasets, and we\u2019ll make sure to flag them up when we get to them.\n\n### What kinds of TPU are available?\n\nNew users are often very confused by the range of TPUs, and the different ways to access them. The first key distinction to understand is the difference between **TPU Nodes** and **TPU VMs.**\n\nWhen you use a **TPU Node**, you are effectively indirectly accessing a remote TPU. You will need a separate VM, which will initialize your network and data pipeline and then forward them to the remote node. When you use a TPU on Google Colab, you are accessing it in the **TPU Node** style.\n\nUsing TPU Nodes can have some quite unexpected behaviour for people who aren\u2019t used to them! In particular, because the TPU is located on a physically different system to the machine you\u2019re running your Python code on, your data cannot be local to your machine - any data pipeline that loads from your machine\u2019s internal storage will totally fail! Instead, data must be stored in Google Cloud Storage where your data pipeline can still access it, even when the pipeline is running on the remote TPU node.\n\n<Tip>\n\nIf you can fit all your data in memory as `np.ndarray` or `tf.Tensor`, then you can `fit()` on that data even when using Colab or a TPU Node, without needing to upload it to Google Cloud Storage.\n\n</Tip>\n\n<Tip>\n\n**\ud83e\udd17Specific Hugging Face Tip\ud83e\udd17:** The methods `Dataset.to_tf_dataset()` and its higher-level wrapper `model.prepare_tf_dataset()` , which you will see throughout our TF code examples, will both fail on a TPU Node. The reason for this is that even though they create a `tf.data.Dataset` it is not a \u201cpure\u201d `tf.data` pipeline and uses `tf.numpy_function` or `Dataset.from_generator()` to stream data from the underlying HuggingFace `Dataset`. This HuggingFace `Dataset` is backed by data that is on a local disc and which the remote TPU Node will not be able to read.\n\n</Tip>\n\nThe second way to access a TPU is via a **TPU VM.** When using a TPU VM, you connect directly to the machine that the TPU is attached to, much like training on a GPU VM. TPU VMs are generally easier to work with, particularly when it comes to your data pipeline. All of the above warnings do not apply to TPU VMs!\n\nThis is an opinionated document, so here\u2019s our opinion: **Avoid using TPU Node if possible.** It is more confusing and more difficult to debug than TPU VMs. It is also likely to be unsupported in future - Google\u2019s latest TPU, TPUv4, can only be accessed as a TPU VM, which suggests that TPU Nodes are increasingly going to become a \u201clegacy\u201d access method. However, we understand that the only free TPU access is on Colab and Kaggle Kernels, which uses TPU Node - so we\u2019ll try to explain how to handle it if you have to! Check the [TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) for code samples that explain this in more detail.\n\n### What sizes of TPU are available?\n\nA single TPU (a v2-8/v3-8/v4-8) runs 8 replicas. TPUs exist in **pods** that can run hundreds or thousands of replicas simultaneously. When you use more than a single TPU but less than a whole pod (for example, a v3-32), your TPU fleet is referred to as a **pod slice.**\n\nWhen you access a free TPU via Colab, you generally get a single v2-8 TPU.\n\n### I keep hearing about this XLA thing. What\u2019s XLA, and how does it relate to TPUs?\n\nXLA is an optimizing compiler, used by both TensorFlow and JAX. In JAX it is the only compiler, whereas in TensorFlow it is optional"
        }
    },
    {
        "context": "</Tip>\n\nThe second way to access a TPU is via a **TPU VM.** When using a TPU VM, you connect directly to the machine that the TPU is attached to, much like training on a GPU VM. TPU VMs are generally easier to work with, particularly when it comes to your data pipeline. All of the above warnings do not apply to TPU VMs!\n\nThis is an opinionated document, so here\u2019s our opinion: **Avoid using TPU Node if possible.** It is more confusing and more difficult to debug than TPU VMs. It is also likely to be unsupported in future - Google\u2019s latest TPU, TPUv4, can only be accessed as a TPU VM, which suggests that TPU Nodes are increasingly going to become a \u201clegacy\u201d access method. However, we understand that the only free TPU access is on Colab and Kaggle Kernels, which uses TPU Node - so we\u2019ll try to explain how to handle it if you have to! Check the [TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) for code samples that explain this in more detail.\n\n### What sizes of TPU are available?\n\nA single TPU (a v2-8/v3-8/v4-8) runs 8 replicas. TPUs exist in **pods** that can run hundreds or thousands of replicas simultaneously. When you use more than a single TPU but less than a whole pod (for example, a v3-32), your TPU fleet is referred to as a **pod slice.**\n\nWhen you access a free TPU via Colab, you generally get a single v2-8 TPU.\n\n### I keep hearing about this XLA thing. What\u2019s XLA, and how does it relate to TPUs?\n\nXLA is an optimizing compiler, used by both TensorFlow and JAX. In JAX it is the only compiler, whereas in TensorFlow it is optional (but mandatory on TPU!). The easiest way to enable it when training a Keras model is to pass the argument `jit_compile=True` to `model.compile()`. If you don\u2019t get any errors and performance is good, that\u2019s a great sign that you\u2019re ready to move to TPU!",
        "question": "How can you enable XLA when training a Keras model?",
        "answer": "You can enable XLA by passing the argument `jit_compile=True` to `model.compile()`.",
        "source_doc": "huggingface/transformers/blob/main/docs/source/en/perf_train_tpu_tf.md",
        "rag_answer": null,
        "rag_context": null,
        "rag_score": null,
        "rag_feedback": null
    },
    {
        "sample_idx": 57,
        "question": "What is recommended to do before trying to run code on TPU?",
        "answer": "Get your code running on CPU/GPU with XLA first.",
        "rag_answer": "Before trying to run code on TPU, it is recommended to:\n\n1. **Make sure your code follows the three rules of XLA**:\n\t* Rule #1: Your code cannot have \"data-dependent condition",
        "rag_score": null,
        "rag_feedback": null,
        "rag_context": {
            "kg_context": "-----Entities-----\n    ```csv\n    id,\tentity,\ttype,\tdescription,\trankcreated_at\n1,\tTPU,technology,TPU is a Tensor Processing Unit, a hardware designed by Google to speed up tensor computations within neural networks.<SEP>TPU is a type of hardware accelerator designed for machine learning workloads.<SEP>TPU is a type of hardware accelerator used for machine learning computations.,4,2025-03-24 13:18:20\n2,\tXLA,technology,XLA is a technology that compiles TensorFlow graphs into executable code for various platforms.<SEP>XLA is an optimizing compiler used by TensorFlow and JAX to improve performance.<SEP>XLA is an optimizing compiler, used by both TensorFlow and JAX to optimize computations.,6,2025-03-24 13:18:20\n3,\tGoogle,organization,Google is the company that designs and provides TPUs, which are used to speed up tensor computations within neural networks.,3,2025-03-24 13:18:20\n4,\tColab,geo,Colab is a cloud-based platform for data science and machine learning, provided by Google.<SEP>Colab is a platform where users can access a free TPU.,3,2025-03-24 13:18:20\n5,\tTensor Processing Unit,category,Tensor Processing Unit is a hardware designed by Google to speed up tensor computations within neural networks.,0,UNKNOWN\n6,\tTPU,technology,TPU is a Tensor Processing Unit, a hardware designed by Google to speed up tensor computations within neural networks.<SEP>TPU is a type of hardware accelerator designed for machine learning workloads.<SEP>TPU is a type of hardware accelerator used for machine learning computations.,4,UNKNOWN\n7,\tGoogle,organization,Google is the company that designs and provides TPUs, which are used to speed up tensor computations within neural networks.,3,UNKNOWN\n    ```\n    -----Relationships-----\n    ```csv\n    id,\tsource,\ttarget,\tdescription,\tkeywords,\tweight,\trank,\tcreated_at\n1,\tTPU,XLA,XLA compiles TensorFlow graphs into executable code for TPU hardware.<SEP>XLA is used to optimize code for TPU hardware.,compilation, hardware acceleration<SEP>compiler, hardware optimization,36.0,10,2025-03-24 13:18:20\n2,\tGoogle,TPU,Google designs and provides TPUs, which are used to speed up tensor computations within neural networks.,hardware design, acceleration,18.0,7,2025-03-24 13:18:20\n3,\tColab,TPU,Colab provides access to a free TPU for users.,platform, hardware acceleration,16.0,7,2025-03-24 13:18:20\n4,\tTPU,XLA,XLA compiles TensorFlow graphs into executable code for TPU hardware.<SEP>XLA is used to optimize code for TPU hardware.,compilation, hardware acceleration<SEP>compiler, hardware optimization,36.0,10,UNKNOWN\n5,\tGoogle,TPU,Google designs and provides TPUs, which are used to speed up tensor computations within neural networks.,hardware design, acceleration,18.0,7,UNKNOWN\n6,\tColab,TPU,Colab provides access to a free TPU for users.,platform, hardware acceleration,16.0,7,UNKNOWN\n7,\tColab,Google,Colab is a cloud-based platform provided by Google for data science and machine learning.,platform provision, cloud computing,16.0,6,UNKNOWN\n8,\tGoogle Cloud,TPU,Google Cloud provides infrastructure and services for building and deploying machine learning models, including TPU hardware.,infrastructure provision, hardware acceleration,14.0,5,UNKNOWN\n9,\tGoogle,Kaggle Kernels,Kaggle Kernels is a cloud-based platform provided by Google for data science and machine learning competitions.,platform provision, cloud computing,16.0,4,UNKNOWN\n    ```\n    -----Sources-----\n    ```csv\n    id,\tcontent\n1,\t(for example, a v3-32), your TPU fleet is referred to as a **pod slice.**\n\nWhen you access a free TPU via Colab, you generally get a single v2-8 TPU.\n\n### I keep hearing about this XLA thing. What\u2019s XLA, and how does it relate to TPUs?\n\nXLA is an optimizing compiler, used by both TensorFlow and JAX. In JAX it is the only compiler, whereas in TensorFlow it is optional (but mandatory on TPU!). The easiest way to enable it when training a Keras model is to pass the argument `jit_compile=True` to `model.compile()`. If you don\u2019t get any errors and performance is good, that\u2019s a great sign that you\u2019re ready to move to TPU!\n\nDebugging on TPU is generally a bit harder than on CPU/GPU, so we recommend getting your code running on CPU/GPU with XLA first before trying it on TPU. You don\u2019t have to train for long, of course - just for a few steps to make sure that your model and data pipeline are working like you expect them to.\n\n<Tip>\n\nXLA compiled code is usually faster - so even if you\u2019re not planning to run on TPU, adding `jit_compile=True` can improve your performance. Be sure to note the caveats below about XLA compatibility, though!\n\n</Tip>\n\n<Tip warning={true}>\n\n**Tip born of painful experience:** Although using `jit_compile=True` is a good way to get a speed boost and test if your CPU/GPU code is XLA-compatible, it can actually cause a lot of problems if you leave it in when actually training on TPU. XLA compilation will happen implicitly on TPU, so remember to remove that line before actually running your code on a TPU!\n\n</Tip>\n\n### How do I make my model XLA compatible?\n\nIn many cases, your code is probably XLA-compatible already! However, there are a few things that work in normal TensorFlow that don\u2019t work in XLA. We\u2019ve distilled them into three core rules below:\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** We\u2019ve put a lot of effort into rewriting our TensorFlow models and loss functions to be XLA-compatible. Our models and loss functions generally obey rule #1 and #2 by default, so you can skip over them if you\u2019re using `transformers` models. Don\u2019t forget about these rules when writing your own models and loss functions, though!\n\n</Tip>\n\n#### XLA Rule #1: Your code cannot have \u201cdata-dependent conditionals\u201d\n\nWhat that means is that any `if` statement cannot depend on values inside a `tf.Tensor`. For example, this code block cannot be compiled with XLA!\n\n```python\nif tf.reduce_sum(tensor) > 10:\n    tensor = tensor / 2.0\n```\n\nThis might seem very restrictive at first, but most neural net code doesn\u2019t need to do this. You can often get around this restriction by using `tf.cond` (see the documentation [here](https://www.tensorflow.org/api_docs/python/tf/cond)) or by removing the conditional and finding a clever math trick with indicator variables instead, like so:\n\n```python\nsum_over_10 = tf.cast(tf.reduce_sum(tensor) > 10, tf.float32)\ntensor = tensor / (1.0 + sum_over_10)\n```\n\nThis code has exactly the same effect as the code above, but by avoiding a conditional, we ensure it will compile with XLA without problems!\n\n#### XLA Rule #2: Your code cannot have \u201cdata-dependent shapes\u201d\n\nWhat this means is that the shape of all of the `tf.Tensor` objects in your code cannot depend on their values. For example, the function `tf.unique` cannot be compiled with XLA, because it returns a `tensor` containing one instance of each unique value in the input. The shape of this output will obviously be different depending on how repetitive the input `Tensor` was, and so XLA refuses to handle it!\n\nIn general, most neural network code obeys rule #2 by default. However, there are a few common cases where it becomes a problem. One very common one is when you use **label masking**, setting your labels to a negative value to indicate that those positions should be ignored when computing the loss. If you look at NumPy or PyTorch loss functions that support label masking, you will often see code like this that uses [boolean indexing](https://numpy.org/doc/stable/user/basics.indexing.html#boolean-array-indexing):\n\n```python\nlabel_mask = labels >= 0\nmasked_outputs = outputs[label_mask]\nmasked_labels = labels[label_mask]\nloss = compute_loss(masked_outputs, masked_labels)\nmean_loss = torch.mean(loss)\n```\n\nThis code is totally fine in NumPy or PyTorch, but it breaks in XLA! Why? Because the shape of `masked_outputs` and `masked_labels` depends on how many positions are masked - that makes it a **data-dependent shape.** However, just like for rule #1, we can often rewrite this code to yield exactly the same output without any data-dependent shapes.\n\n```python\nlabel_mask = tf.cast(labels >= 0, tf.float32)\nloss = compute_loss(outputs, labels)\nloss = loss * label_mask  # Set negative label positions to 0\nmean_loss = tf.reduce_sum(loss) / tf.reduce_sum(label_mask)\n```\n\nHere, we avoid data-dependent shapes by computing the loss for every position, but zeroing out the masked positions in both the numerator and denominator when we calculate the mean, which yields exactly the same result as the first block while maintaining XLA compatibility. Note that we use the same trick as in rule #1 - converting a `tf.bool` to `\n2,\tlabel_mask  # Set negative label positions to 0\nmean_loss = tf.reduce_sum(loss) / tf.reduce_sum(label_mask)\n```\n\nHere, we avoid data-dependent shapes by computing the loss for every position, but zeroing out the masked positions in both the numerator and denominator when we calculate the mean, which yields exactly the same result as the first block while maintaining XLA compatibility. Note that we use the same trick as in rule #1 - converting a `tf.bool` to `tf.float32` and using it as an indicator variable. This is a really useful trick, so remember it if you need to convert your own code to XLA!\n\n#### XLA Rule #3: XLA will need to recompile your model for every different input shape it sees\n\nThis is the big one. What this means is that if your input shapes are very variable, XLA will have to recompile your model over and over, which will create huge performance problems. This commonly arises in NLP models, where input texts have variable lengths after tokenization. In other modalities, static shapes are more common and this rule is much less of a problem.\n\nHow can you get around rule #3? The key is **padding** - if you pad all your inputs to the same length, and then use an `attention_mask`, you can get the same results as you\u2019d get from variable shapes, but without any XLA issues. However, excessive padding can cause severe slowdown too - if you pad all your samples to the maximum length in the whole dataset, you might end up with batches consisting endless padding tokens, which will waste a lot of compute and memory!\n\nThere isn\u2019t a perfect solution to this problem. However, you can try some tricks. One very useful trick is to **pad batches of samples up to a multiple of a number like 32 or 64 tokens.** This often only increases the number of tokens by a small amount, but it hugely reduces the number of unique input shapes, because every input shape now has to be a multiple of 32 or 64. Fewer unique input shapes means fewer XLA compilations!\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** Our tokenizers and data collators have methods that can help you here. You can use `padding=\"max_length\"` or `padding=\"longest\"` when calling tokenizers to get them to output padded data. Our tokenizers and data collators also have a `pad_to_multiple_of` argument that you can use to reduce the number of unique input shapes you see!\n\n</Tip>\n\n### How do I actually train my model on TPU?\n\nOnce your training is XLA-compatible and (if you\u2019re using TPU Node / Colab) your dataset has been prepared appropriately, running on TPU is surprisingly easy! All you really need to change in your code is to add a few lines to initialize your TPU, and to ensure that your model and dataset are created inside a `TPUStrategy` scope. Take a look at [our TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) to see this in action!\n\n### Summary\n\nThere was a lot in here, so let\u2019s summarize with a quick checklist you can follow when you want to get your model ready for TPU training:\n\n- Make sure your code follows the three rules of XLA\n- Compile your model with `jit_compile=True` on CPU/GPU and confirm that you can train it with XLA\n- Either load your dataset into memory or use a TPU-compatible dataset loading approach (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Migrate your code either to Colab (with accelerator set to \u201cTPU\u201d) or a TPU VM on Google Cloud\n- Add TPU initializer code (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Create your `TPUStrategy` and make sure dataset loading and model creation are inside the `strategy.scope()` (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Don\u2019t forget to take `jit_compile=True` out again when you move to TPU!\n- \ud83d\ude4f\ud83d\ude4f\ud83d\ude4f\ud83e\udd7a\ud83e\udd7a\ud83e\udd7a\n- Call model.fit()\n- You did it!\n3,\t!--Copyright 2023 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\nthe License. You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under the License is distributed on\nan \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n\n\u26a0\ufe0f Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be\nrendered properly in your Markdown viewer.\n\n-->\n\n# Training on TPU with TensorFlow\n\n<Tip>\n\nIf you don't need long explanations and just want TPU code samples to get started with, check out [our TPU example notebook!](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb)\n\n</Tip>\n\n### What is a TPU?\n\nA TPU is a **Tensor Processing Unit.** They are hardware designed by Google, which are used to greatly speed up the tensor computations within neural networks, much like GPUs. They can be used for both network training and inference. They are generally accessed through Google\u2019s cloud services, but small TPUs can also be accessed directly for free through Google Colab and Kaggle Kernels.\n\nBecause [all TensorFlow models in \ud83e\udd17 Transformers are Keras models](https://huggingface.co/blog/tensorflow-philosophy), most of the methods in this document are generally applicable to TPU training for any Keras model! However, there are a few points that are specific to the HuggingFace ecosystem (hug-o-system?) of Transformers and Datasets, and we\u2019ll make sure to flag them up when we get to them.\n\n### What kinds of TPU are available?\n\nNew users are often very confused by the range of TPUs, and the different ways to access them. The first key distinction to understand is the difference between **TPU Nodes** and **TPU VMs.**\n\nWhen you use a **TPU Node**, you are effectively indirectly accessing a remote TPU. You will need a separate VM, which will initialize your network and data pipeline and then forward them to the remote node. When you use a TPU on Google Colab, you are accessing it in the **TPU Node** style.\n\nUsing TPU Nodes can have some quite unexpected behaviour for people who aren\u2019t used to them! In particular, because the TPU is located on a physically different system to the machine you\u2019re running your Python code on, your data cannot be local to your machine - any data pipeline that loads from your machine\u2019s internal storage will totally fail! Instead, data must be stored in Google Cloud Storage where your data pipeline can still access it, even when the pipeline is running on the remote TPU node.\n\n<Tip>\n\nIf you can fit all your data in memory as `np.ndarray` or `tf.Tensor`, then you can `fit()` on that data even when using Colab or a TPU Node, without needing to upload it to Google Cloud Storage.\n\n</Tip>\n\n<Tip>\n\n**\ud83e\udd17Specific Hugging Face Tip\ud83e\udd17:** The methods `Dataset.to_tf_dataset()` and its higher-level wrapper `model.prepare_tf_dataset()` , which you will see throughout our TF code examples, will both fail on a TPU Node. The reason for this is that even though they create a `tf.data.Dataset` it is not a \u201cpure\u201d `tf.data` pipeline and uses `tf.numpy_function` or `Dataset.from_generator()` to stream data from the underlying HuggingFace `Dataset`. This HuggingFace `Dataset` is backed by data that is on a local disc and which the remote TPU Node will not be able to read.\n\n</Tip>\n\nThe second way to access a TPU is via a **TPU VM.** When using a TPU VM, you connect directly to the machine that the TPU is attached to, much like training on a GPU VM. TPU VMs are generally easier to work with, particularly when it comes to your data pipeline. All of the above warnings do not apply to TPU VMs!\n\nThis is an opinionated document, so here\u2019s our opinion: **Avoid using TPU Node if possible.** It is more confusing and more difficult to debug than TPU VMs. It is also likely to be unsupported in future - Google\u2019s latest TPU, TPUv4, can only be accessed as a TPU VM, which suggests that TPU Nodes are increasingly going to become a \u201clegacy\u201d access method. However, we understand that the only free TPU access is on Colab and Kaggle Kernels, which uses TPU Node - so we\u2019ll try to explain how to handle it if you have to! Check the [TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) for code samples that explain this in more detail.\n\n### What sizes of TPU are available?\n\nA single TPU (a v2-8/v3-8/v4-8) runs 8 replicas. TPUs exist in **pods** that can run hundreds or thousands of replicas simultaneously. When you use more than a single TPU but less than a whole pod (for example, a v3-32), your TPU fleet is referred to as a **pod slice.**\n\nWhen you access a free TPU via Colab, you generally get a single v2-8 TPU.\n\n### I keep hearing about this XLA thing. What\u2019s XLA, and how does it relate to TPUs?\n\nXLA is an optimizing compiler, used by both TensorFlow and JAX. In JAX it is the only compiler, whereas in TensorFlow it is optional\n    ```",
            "vector_context": "[Created at: 2025-03-24 13:17:32]\n!--Copyright 2023 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\nthe License. You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under the License is distributed on\nan \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n\n\u26a0\ufe0f Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be\nrendered properly in your Markdown viewer.\n\n-->\n\n# Training on TPU with TensorFlow\n\n<Tip>\n\nIf you don't need long explanations and just want TPU code samples to get started with, check out [our TPU example notebook!](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb)\n\n</Tip>\n\n### What is a TPU?\n\nA TPU is a **Tensor Processing Unit.** They are hardware designed by Google, which are used to greatly speed up the tensor computations within neural networks, much like GPUs. They can be used for both network training and inference. They are generally accessed through Google\u2019s cloud services, but small TPUs can also be accessed directly for free through Google Colab and Kaggle Kernels.\n\nBecause [all TensorFlow models in \ud83e\udd17 Transformers are Keras models](https://huggingface.co/blog/tensorflow-philosophy), most of the methods in this document are generally applicable to TPU training for any Keras model! However, there are a few points that are specific to the HuggingFace ecosystem (hug-o-system?) of Transformers and Datasets, and we\u2019ll make sure to flag them up when we get to them.\n\n### What kinds of TPU are available?\n\nNew users are often very confused by the range of TPUs, and the different ways to access them. The first key distinction to understand is the difference between **TPU Nodes** and **TPU VMs.**\n\nWhen you use a **TPU Node**, you are effectively indirectly accessing a remote TPU. You will need a separate VM, which will initialize your network and data pipeline and then forward them to the remote node. When you use a TPU on Google Colab, you are accessing it in the **TPU Node** style.\n\nUsing TPU Nodes can have some quite unexpected behaviour for people who aren\u2019t used to them! In particular, because the TPU is located on a physically different system to the machine you\u2019re running your Python code on, your data cannot be local to your machine - any data pipeline that loads from your machine\u2019s internal storage will totally fail! Instead, data must be stored in Google Cloud Storage where your data pipeline can still access it, even when the pipeline is running on the remote TPU node.\n\n<Tip>\n\nIf you can fit all your data in memory as `np.ndarray` or `tf.Tensor`, then you can `fit()` on that data even when using Colab or a TPU Node, without needing to upload it to Google Cloud Storage.\n\n</Tip>\n\n<Tip>\n\n**\ud83e\udd17Specific Hugging Face Tip\ud83e\udd17:** The methods `Dataset.to_tf_dataset()` and its higher-level wrapper `model.prepare_tf_dataset()` , which you will see throughout our TF code examples, will both fail on a TPU Node. The reason for this is that even though they create a `tf.data.Dataset` it is not a \u201cpure\u201d `tf.data` pipeline and uses `tf.numpy_function` or `Dataset.from_generator()` to stream data from the underlying HuggingFace `Dataset`. This HuggingFace `Dataset` is backed by data that is on a local disc and which the remote TPU Node will not be able to read.\n\n</Tip>\n\nThe second way to access a TPU is via a **TPU VM.** When using a TPU VM, you connect directly to the machine that the TPU is attached to, much like training on a GPU VM. TPU VMs are generally easier to work with, particularly when it comes to your data pipeline. All of the above warnings do not apply to TPU VMs!\n\nThis is an opinionated document, so here\u2019s our opinion: **Avoid using TPU Node if possible.** It is more confusing and more difficult to debug than TPU VMs. It is also likely to be unsupported in future - Google\u2019s latest TPU, TPUv4, can only be accessed as a TPU VM, which suggests that TPU Nodes are increasingly going to become a \u201clegacy\u201d access method. However, we understand that the only free TPU access is on Colab and Kaggle Kernels, which uses TPU Node - so we\u2019ll try to explain how to handle it if you have to! Check the [TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) for code samples that explain this in more detail.\n\n### What sizes of TPU are available?\n\nA single TPU (a v2-8/v3-8/v4-8) runs 8 replicas. TPUs exist in **pods** that can run hundreds or thousands of replicas simultaneously. When you use more than a single TPU but less than a whole pod (for example, a v3-32), your TPU fleet is referred to as a **pod slice.**\n\nWhen you access a free TPU via Colab, you generally get a single v2-8 TPU.\n\n### I keep hearing about this XLA thing. What\u2019s XLA, and how does it relate to TPUs?\n\nXLA is an optimizing compiler, used by both TensorFlow and JAX. In JAX it is the only compiler, whereas in TensorFlow it is optional\n--New Chunk--\n[Created at: 2025-03-24 13:17:32]\n(for example, a v3-32), your TPU fleet is referred to as a **pod slice.**\n\nWhen you access a free TPU via Colab, you generally get a single v2-8 TPU.\n\n### I keep hearing about this XLA thing. What\u2019s XLA, and how does it relate to TPUs?\n\nXLA is an optimizing compiler, used by both TensorFlow and JAX. In JAX it is the only compiler, whereas in TensorFlow it is optional (but mandatory on TPU!). The easiest way to enable it when training a Keras model is to pass the argument `jit_compile=True` to `model.compile()`. If you don\u2019t get any errors and performance is good, that\u2019s a great sign that you\u2019re ready to move to TPU!\n\nDebugging on TPU is generally a bit harder than on CPU/GPU, so we recommend getting your code running on CPU/GPU with XLA first before trying it on TPU. You don\u2019t have to train for long, of course - just for a few steps to make sure that your model and data pipeline are working like you expect them to.\n\n<Tip>\n\nXLA compiled code is usually faster - so even if you\u2019re not planning to run on TPU, adding `jit_compile=True` can improve your performance. Be sure to note the caveats below about XLA compatibility, though!\n\n</Tip>\n\n<Tip warning={true}>\n\n**Tip born of painful experience:** Although using `jit_compile=True` is a good way to get a speed boost and test if your CPU/GPU code is XLA-compatible, it can actually cause a lot of problems if you leave it in when actually training on TPU. XLA compilation will happen implicitly on TPU, so remember to remove that line before actually running your code on a TPU!\n\n</Tip>\n\n### How do I make my model XLA compatible?\n\nIn many cases, your code is probably XLA-compatible already! However, there are a few things that work in normal TensorFlow that don\u2019t work in XLA. We\u2019ve distilled them into three core rules below:\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** We\u2019ve put a lot of effort into rewriting our TensorFlow models and loss functions to be XLA-compatible. Our models and loss functions generally obey rule #1 and #2 by default, so you can skip over them if you\u2019re using `transformers` models. Don\u2019t forget about these rules when writing your own models and loss functions, though!\n\n</Tip>\n\n#### XLA Rule #1: Your code cannot have \u201cdata-dependent conditionals\u201d\n\nWhat that means is that any `if` statement cannot depend on values inside a `tf.Tensor`. For example, this code block cannot be compiled with XLA!\n\n```python\nif tf.reduce_sum(tensor) > 10:\n    tensor = tensor / 2.0\n```\n\nThis might seem very restrictive at first, but most neural net code doesn\u2019t need to do this. You can often get around this restriction by using `tf.cond` (see the documentation [here](https://www.tensorflow.org/api_docs/python/tf/cond)) or by removing the conditional and finding a clever math trick with indicator variables instead, like so:\n\n```python\nsum_over_10 = tf.cast(tf.reduce_sum(tensor) > 10, tf.float32)\ntensor = tensor / (1.0 + sum_over_10)\n```\n\nThis code has exactly the same effect as the code above, but by avoiding a conditional, we ensure it will compile with XLA without problems!\n\n#### XLA Rule #2: Your code cannot have \u201cdata-dependent shapes\u201d\n\nWhat this means is that the shape of all of the `tf.Tensor` objects in your code cannot depend on their values. For example, the function `tf.unique` cannot be compiled with XLA, because it returns a `tensor` containing one instance of each unique value in the input. The shape of this output will obviously be different depending on how repetitive the input `Tensor` was, and so XLA refuses to handle it!\n\nIn general, most neural network code obeys rule #2 by default. However, there are a few common cases where it becomes a problem. One very common one is when you use **label masking**, setting your labels to a negative value to indicate that those positions should be ignored when computing the loss. If you look at NumPy or PyTorch loss functions that support label masking, you will often see code like this that uses [boolean indexing](https://numpy.org/doc/stable/user/basics.indexing.html#boolean-array-indexing):\n\n```python\nlabel_mask = labels >= 0\nmasked_outputs = outputs[label_mask]\nmasked_labels = labels[label_mask]\nloss = compute_loss(masked_outputs, masked_labels)\nmean_loss = torch.mean(loss)\n```\n\nThis code is totally fine in NumPy or PyTorch, but it breaks in XLA! Why? Because the shape of `masked_outputs` and `masked_labels` depends on how many positions are masked - that makes it a **data-dependent shape.** However, just like for rule #1, we can often rewrite this code to yield exactly the same output without any data-dependent shapes.\n\n```python\nlabel_mask = tf.cast(labels >= 0, tf.float32)\nloss = compute_loss(outputs, labels)\nloss = loss * label_mask  # Set negative label positions to 0\nmean_loss = tf.reduce_sum(loss) / tf.reduce_sum(label_mask)\n```\n\nHere, we avoid data-dependent shapes by computing the loss for every position, but zeroing out the masked positions in both the numerator and denominator when we calculate the mean, which yields exactly the same result as the first block while maintaining XLA compatibility. Note that we use the same trick as in rule #1 - converting a `tf.bool` to `\n--New Chunk--\n[Created at: 2025-03-24 13:17:32]\nlabel_mask  # Set negative label positions to 0\nmean_loss = tf.reduce_sum(loss) / tf.reduce_sum(label_mask)\n```\n\nHere, we avoid data-dependent shapes by computing the loss for every position, but zeroing out the masked positions in both the numerator and denominator when we calculate the mean, which yields exactly the same result as the first block while maintaining XLA compatibility. Note that we use the same trick as in rule #1 - converting a `tf.bool` to `tf.float32` and using it as an indicator variable. This is a really useful trick, so remember it if you need to convert your own code to XLA!\n\n#### XLA Rule #3: XLA will need to recompile your model for every different input shape it sees\n\nThis is the big one. What this means is that if your input shapes are very variable, XLA will have to recompile your model over and over, which will create huge performance problems. This commonly arises in NLP models, where input texts have variable lengths after tokenization. In other modalities, static shapes are more common and this rule is much less of a problem.\n\nHow can you get around rule #3? The key is **padding** - if you pad all your inputs to the same length, and then use an `attention_mask`, you can get the same results as you\u2019d get from variable shapes, but without any XLA issues. However, excessive padding can cause severe slowdown too - if you pad all your samples to the maximum length in the whole dataset, you might end up with batches consisting endless padding tokens, which will waste a lot of compute and memory!\n\nThere isn\u2019t a perfect solution to this problem. However, you can try some tricks. One very useful trick is to **pad batches of samples up to a multiple of a number like 32 or 64 tokens.** This often only increases the number of tokens by a small amount, but it hugely reduces the number of unique input shapes, because every input shape now has to be a multiple of 32 or 64. Fewer unique input shapes means fewer XLA compilations!\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** Our tokenizers and data collators have methods that can help you here. You can use `padding=\"max_length\"` or `padding=\"longest\"` when calling tokenizers to get them to output padded data. Our tokenizers and data collators also have a `pad_to_multiple_of` argument that you can use to reduce the number of unique input shapes you see!\n\n</Tip>\n\n### How do I actually train my model on TPU?\n\nOnce your training is XLA-compatible and (if you\u2019re using TPU Node / Colab) your dataset has been prepared appropriately, running on TPU is surprisingly easy! All you really need to change in your code is to add a few lines to initialize your TPU, and to ensure that your model and dataset are created inside a `TPUStrategy` scope. Take a look at [our TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) to see this in action!\n\n### Summary\n\nThere was a lot in here, so let\u2019s summarize with a quick checklist you can follow when you want to get your model ready for TPU training:\n\n- Make sure your code follows the three rules of XLA\n- Compile your model with `jit_compile=True` on CPU/GPU and confirm that you can train it with XLA\n- Either load your dataset into memory or use a TPU-compatible dataset loading approach (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Migrate your code either to Colab (with accelerator set to \u201cTPU\u201d) or a TPU VM on Google Cloud\n- Add TPU initializer code (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Create your `TPUStrategy` and make sure dataset loading and model creation are inside the `strategy.scope()` (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Don\u2019t forget to take `jit_compile=True` out again when you move to TPU!\n- \ud83d\ude4f\ud83d\ude4f\ud83d\ude4f\ud83e\udd7a\ud83e\udd7a\ud83e\udd7a\n- Call model.fit()\n- You did it!"
        }
    },
    {
        "sample_idx": 58,
        "question": "What is the effect of adding jit_compile=True to code?",
        "answer": "XLA compiled code is usually faster.",
        "rag_answer": "Adding `jit_compile=True` to your code enables XLA (Accelerated Linear Algebra) compilation, which is an optimizing compiler used by both TensorFlow and JAX. This can lead to several benefits:\n\n**Faster Performance**: XLA compiled code is usually faster, as it optimizes the computation graph and generates more efficient machine code.\n\n**TPU Compatibility**: If you're planning to run your model on a TPU (Tensor Processing Unit), `jit_compile=True` is mandatory. XLA compilation will happen implicitly on TPU, so you need to remove this line when actually running your code on a TPU to avoid issues.\n\n**Debugging**: By enabling XLA compilation, you can test if your CPU/GPU code is XLA-compatible, which can help with debugging.\n\nHowever, keep in mind that XLA compilation has some restrictions:\n\n* **Data-dependent conditionals**: Your code cannot have conditionals that depend on values inside a `tf.Tensor`.\n* **Data-dependent shapes**: The shape of all `tf.Tensor` objects in your code cannot depend on their values.\n\nIf your code adheres to these rules, enabling XLA compilation with `jit_compile=True` can lead to significant performance improvements.\n\nReferences:\n[",
        "rag_score": null,
        "rag_feedback": null,
        "rag_context": {
            "kg_context": "-----Entities-----\n    ```csv\n    id,\tentity,\ttype,\tdescription,\trankcreated_at\n1,\tTPU,technology,TPU is a Tensor Processing Unit, a hardware designed by Google to speed up tensor computations within neural networks.<SEP>TPU is a type of hardware accelerator designed for machine learning workloads.<SEP>TPU is a type of hardware accelerator used for machine learning computations.,4,2025-03-24 13:18:20\n2,\tXLA,technology,XLA is a technology that compiles TensorFlow graphs into executable code for various platforms.<SEP>XLA is an optimizing compiler used by TensorFlow and JAX to improve performance.<SEP>XLA is an optimizing compiler, used by both TensorFlow and JAX to optimize computations.,6,2025-03-24 13:18:20\n3,\tTensorFlow,category,TensorFlow is a machine learning framework that uses XLA as an optimizing compiler.<SEP>TensorFlow is a software framework used for building and training neural networks.<SEP>TensorFlow is an open-source machine learning framework.,3,2025-03-24 13:18:20\n4,\tjit_compile,concept,jit_compile is a technique for compiling TensorFlow graphs into executable code.,1,2025-03-24 13:18:20\n5,\tjit_compile,concept,jit_compile is a technique for compiling TensorFlow graphs into executable code.,1,UNKNOWN\n6,\tJupyter,category,Jupyter is a platform for interactive computing and data science.,2,UNKNOWN\n7,\ttqdm,category,tqdm is a library for creating progress bars in Python.,1,UNKNOWN\n    ```\n    -----Relationships-----\n    ```csv\n    id,\tsource,\ttarget,\tdescription,\tkeywords,\tweight,\trank,\tcreated_at\n1,\tTPU,XLA,XLA compiles TensorFlow graphs into executable code for TPU hardware.<SEP>XLA is used to optimize code for TPU hardware.,compilation, hardware acceleration<SEP>compiler, hardware optimization,36.0,10,2025-03-24 13:18:20\n2,\tTensorFlow,XLA,TensorFlow graphs can be compiled into executable code using XLA.<SEP>TensorFlow uses XLA as an optimizing compiler to improve performance.,compilation, framework support<SEP>compiler, performance optimization,23.0,9,2025-03-24 13:18:20\n3,\tXLA,jit_compile,jit_compile is a technique used in XLA to compile TensorFlow graphs into executable code.,compilation technique, XLA support,3.0,7,2025-03-24 13:18:20\n4,\tGradio,Jupyter,Gradio can be run on Jupyter notebooks.,platform compatibility, interactive computing,7.0,38,UNKNOWN\n5,\tGradio,tqdm,tqdm is used in Gradio for creating progress bars.,library integration, progress tracking,7.0,37,UNKNOWN\n6,\tXLA,jit_compile,jit_compile is a technique used in XLA to compile TensorFlow graphs into executable code.,compilation technique, XLA support,3.0,7,UNKNOWN\n7,\tJupyter,notebooks,Notebooks are a type of interactive document used in Jupyter.,document type, interactive computing,7.0,3,UNKNOWN\n    ```\n    -----Sources-----\n    ```csv\n    id,\tcontent\n1,\t(for example, a v3-32), your TPU fleet is referred to as a **pod slice.**\n\nWhen you access a free TPU via Colab, you generally get a single v2-8 TPU.\n\n### I keep hearing about this XLA thing. What\u2019s XLA, and how does it relate to TPUs?\n\nXLA is an optimizing compiler, used by both TensorFlow and JAX. In JAX it is the only compiler, whereas in TensorFlow it is optional (but mandatory on TPU!). The easiest way to enable it when training a Keras model is to pass the argument `jit_compile=True` to `model.compile()`. If you don\u2019t get any errors and performance is good, that\u2019s a great sign that you\u2019re ready to move to TPU!\n\nDebugging on TPU is generally a bit harder than on CPU/GPU, so we recommend getting your code running on CPU/GPU with XLA first before trying it on TPU. You don\u2019t have to train for long, of course - just for a few steps to make sure that your model and data pipeline are working like you expect them to.\n\n<Tip>\n\nXLA compiled code is usually faster - so even if you\u2019re not planning to run on TPU, adding `jit_compile=True` can improve your performance. Be sure to note the caveats below about XLA compatibility, though!\n\n</Tip>\n\n<Tip warning={true}>\n\n**Tip born of painful experience:** Although using `jit_compile=True` is a good way to get a speed boost and test if your CPU/GPU code is XLA-compatible, it can actually cause a lot of problems if you leave it in when actually training on TPU. XLA compilation will happen implicitly on TPU, so remember to remove that line before actually running your code on a TPU!\n\n</Tip>\n\n### How do I make my model XLA compatible?\n\nIn many cases, your code is probably XLA-compatible already! However, there are a few things that work in normal TensorFlow that don\u2019t work in XLA. We\u2019ve distilled them into three core rules below:\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** We\u2019ve put a lot of effort into rewriting our TensorFlow models and loss functions to be XLA-compatible. Our models and loss functions generally obey rule #1 and #2 by default, so you can skip over them if you\u2019re using `transformers` models. Don\u2019t forget about these rules when writing your own models and loss functions, though!\n\n</Tip>\n\n#### XLA Rule #1: Your code cannot have \u201cdata-dependent conditionals\u201d\n\nWhat that means is that any `if` statement cannot depend on values inside a `tf.Tensor`. For example, this code block cannot be compiled with XLA!\n\n```python\nif tf.reduce_sum(tensor) > 10:\n    tensor = tensor / 2.0\n```\n\nThis might seem very restrictive at first, but most neural net code doesn\u2019t need to do this. You can often get around this restriction by using `tf.cond` (see the documentation [here](https://www.tensorflow.org/api_docs/python/tf/cond)) or by removing the conditional and finding a clever math trick with indicator variables instead, like so:\n\n```python\nsum_over_10 = tf.cast(tf.reduce_sum(tensor) > 10, tf.float32)\ntensor = tensor / (1.0 + sum_over_10)\n```\n\nThis code has exactly the same effect as the code above, but by avoiding a conditional, we ensure it will compile with XLA without problems!\n\n#### XLA Rule #2: Your code cannot have \u201cdata-dependent shapes\u201d\n\nWhat this means is that the shape of all of the `tf.Tensor` objects in your code cannot depend on their values. For example, the function `tf.unique` cannot be compiled with XLA, because it returns a `tensor` containing one instance of each unique value in the input. The shape of this output will obviously be different depending on how repetitive the input `Tensor` was, and so XLA refuses to handle it!\n\nIn general, most neural network code obeys rule #2 by default. However, there are a few common cases where it becomes a problem. One very common one is when you use **label masking**, setting your labels to a negative value to indicate that those positions should be ignored when computing the loss. If you look at NumPy or PyTorch loss functions that support label masking, you will often see code like this that uses [boolean indexing](https://numpy.org/doc/stable/user/basics.indexing.html#boolean-array-indexing):\n\n```python\nlabel_mask = labels >= 0\nmasked_outputs = outputs[label_mask]\nmasked_labels = labels[label_mask]\nloss = compute_loss(masked_outputs, masked_labels)\nmean_loss = torch.mean(loss)\n```\n\nThis code is totally fine in NumPy or PyTorch, but it breaks in XLA! Why? Because the shape of `masked_outputs` and `masked_labels` depends on how many positions are masked - that makes it a **data-dependent shape.** However, just like for rule #1, we can often rewrite this code to yield exactly the same output without any data-dependent shapes.\n\n```python\nlabel_mask = tf.cast(labels >= 0, tf.float32)\nloss = compute_loss(outputs, labels)\nloss = loss * label_mask  # Set negative label positions to 0\nmean_loss = tf.reduce_sum(loss) / tf.reduce_sum(label_mask)\n```\n\nHere, we avoid data-dependent shapes by computing the loss for every position, but zeroing out the masked positions in both the numerator and denominator when we calculate the mean, which yields exactly the same result as the first block while maintaining XLA compatibility. Note that we use the same trick as in rule #1 - converting a `tf.bool` to `\n2,\tlabel_mask  # Set negative label positions to 0\nmean_loss = tf.reduce_sum(loss) / tf.reduce_sum(label_mask)\n```\n\nHere, we avoid data-dependent shapes by computing the loss for every position, but zeroing out the masked positions in both the numerator and denominator when we calculate the mean, which yields exactly the same result as the first block while maintaining XLA compatibility. Note that we use the same trick as in rule #1 - converting a `tf.bool` to `tf.float32` and using it as an indicator variable. This is a really useful trick, so remember it if you need to convert your own code to XLA!\n\n#### XLA Rule #3: XLA will need to recompile your model for every different input shape it sees\n\nThis is the big one. What this means is that if your input shapes are very variable, XLA will have to recompile your model over and over, which will create huge performance problems. This commonly arises in NLP models, where input texts have variable lengths after tokenization. In other modalities, static shapes are more common and this rule is much less of a problem.\n\nHow can you get around rule #3? The key is **padding** - if you pad all your inputs to the same length, and then use an `attention_mask`, you can get the same results as you\u2019d get from variable shapes, but without any XLA issues. However, excessive padding can cause severe slowdown too - if you pad all your samples to the maximum length in the whole dataset, you might end up with batches consisting endless padding tokens, which will waste a lot of compute and memory!\n\nThere isn\u2019t a perfect solution to this problem. However, you can try some tricks. One very useful trick is to **pad batches of samples up to a multiple of a number like 32 or 64 tokens.** This often only increases the number of tokens by a small amount, but it hugely reduces the number of unique input shapes, because every input shape now has to be a multiple of 32 or 64. Fewer unique input shapes means fewer XLA compilations!\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** Our tokenizers and data collators have methods that can help you here. You can use `padding=\"max_length\"` or `padding=\"longest\"` when calling tokenizers to get them to output padded data. Our tokenizers and data collators also have a `pad_to_multiple_of` argument that you can use to reduce the number of unique input shapes you see!\n\n</Tip>\n\n### How do I actually train my model on TPU?\n\nOnce your training is XLA-compatible and (if you\u2019re using TPU Node / Colab) your dataset has been prepared appropriately, running on TPU is surprisingly easy! All you really need to change in your code is to add a few lines to initialize your TPU, and to ensure that your model and dataset are created inside a `TPUStrategy` scope. Take a look at [our TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) to see this in action!\n\n### Summary\n\nThere was a lot in here, so let\u2019s summarize with a quick checklist you can follow when you want to get your model ready for TPU training:\n\n- Make sure your code follows the three rules of XLA\n- Compile your model with `jit_compile=True` on CPU/GPU and confirm that you can train it with XLA\n- Either load your dataset into memory or use a TPU-compatible dataset loading approach (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Migrate your code either to Colab (with accelerator set to \u201cTPU\u201d) or a TPU VM on Google Cloud\n- Add TPU initializer code (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Create your `TPUStrategy` and make sure dataset loading and model creation are inside the `strategy.scope()` (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Don\u2019t forget to take `jit_compile=True` out again when you move to TPU!\n- \ud83d\ude4f\ud83d\ude4f\ud83d\ude4f\ud83e\udd7a\ud83e\udd7a\ud83e\udd7a\n- Call model.fit()\n- You did it!\n3,\t\u4e0e\u5e38\u89c4\u51fd\u6570\u76f8\u540c\u7684\u65b9\u5f0f\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio\u3002\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\uff08\u865a\u62df\u7684\uff09\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5b83\u5728\u8f93\u51fa\u56fe\u50cf\u4e4b\u524d\u751f\u6210\u6570\u4e2a\u6b65\u9aa4\u7684\u566a\u97f3\uff1a\n\n$code_fake_diffusion\n$demo_fake_diffusion\n\n\u8bf7\u6ce8\u610f\uff0c\u6211\u4eec\u5728\u8fed\u4ee3\u5668\u4e2d\u6dfb\u52a0\u4e86 `time.sleep(1)`\uff0c\u4ee5\u521b\u5efa\u6b65\u9aa4\u4e4b\u95f4\u7684\u4eba\u5de5\u6682\u505c\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u89c2\u5bdf\u8fed\u4ee3\u5668\u7684\u6b65\u9aa4\uff08\u5728\u771f\u5b9e\u7684\u56fe\u50cf\u751f\u6210\u6a21\u578b\u4e2d\uff0c\u8fd9\u53ef\u80fd\u662f\u4e0d\u5fc5\u8981\u7684\uff09\u3002\n\n\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio **\u9700\u8981**\u5728\u5e95\u5c42 Interface \u6216 Blocks \u4e2d\u542f\u7528\u961f\u5217\uff08\u8bf7\u53c2\u9605\u4e0a\u9762\u7684\u961f\u5217\u90e8\u5206\uff09\u3002\n\n## \u8fdb\u5ea6\u6761\n\nGradio \u652f\u6301\u521b\u5efa\u81ea\u5b9a\u4e49\u8fdb\u5ea6\u6761\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u81ea\u5b9a\u4e49\u548c\u63a7\u5236\u5411\u7528\u6237\u663e\u793a\u7684\u8fdb\u5ea6\u66f4\u65b0\u3002\u8981\u542f\u7528\u6b64\u529f\u80fd\uff0c\u53ea\u9700\u4e3a\u65b9\u6cd5\u6dfb\u52a0\u4e00\u4e2a\u9ed8\u8ba4\u503c\u4e3a `gr.Progress` \u5b9e\u4f8b\u7684\u53c2\u6570\u5373\u53ef\u3002\u7136\u540e\uff0c\u60a8\u53ef\u4ee5\u76f4\u63a5\u8c03\u7528\u6b64\u5b9e\u4f8b\u5e76\u4f20\u5165 0 \u5230 1 \u4e4b\u95f4\u7684\u6d6e\u70b9\u6570\u6765\u66f4\u65b0\u8fdb\u5ea6\u7ea7\u522b\uff0c\u6216\u8005 with `Progress` \u5b9e\u4f8b\u7684 `tqdm()` \u65b9\u6cd5\u6765\u8ddf\u8e2a\u53ef\u8fed\u4ee3\u5bf9\u8c61\u4e0a\u7684\u8fdb\u5ea6\uff0c\u5982\u4e0b\u6240\u793a\u3002\u5fc5\u987b\u542f\u7528\u961f\u5217\u4ee5\u8fdb\u884c\u8fdb\u5ea6\u66f4\u65b0\u3002\n\n$code_progress_simple\n$demo_progress_simple\n\n\u5982\u679c\u60a8 with `tqdm` \u5e93\uff0c\u5e76\u4e14\u5e0c\u671b\u4ece\u51fd\u6570\u5185\u90e8\u7684\u4efb\u4f55 `tqdm.tqdm` \u81ea\u52a8\u62a5\u544a\u8fdb\u5ea6\u66f4\u65b0\uff0c\u8bf7\u5c06\u9ed8\u8ba4\u53c2\u6570\u8bbe\u7f6e\u4e3a `gr.Progress(track_tqdm=True)`\uff01\n\n## \u6279\u5904\u7406\u51fd\u6570 (Batch Functions)\n\nGradio \u652f\u6301\u4f20\u9012*\u6279\u5904\u7406*\u51fd\u6570\u3002\u6279\u5904\u7406\u51fd\u6570\u53ea\u662f\u63a5\u53d7\u8f93\u5165\u5217\u8868\u5e76\u8fd4\u56de\u9884\u6d4b\u5217\u8868\u7684\u51fd\u6570\u3002\n\n\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\u6279\u5904\u7406\u51fd\u6570\uff0c\u5b83\u63a5\u53d7\u4e24\u4e2a\u8f93\u5165\u5217\u8868\uff08\u4e00\u4e2a\u5355\u8bcd\u5217\u8868\u548c\u4e00\u4e2a\u6574\u6570\u5217\u8868\uff09\uff0c\u5e76\u8fd4\u56de\u4fee\u526a\u8fc7\u7684\u5355\u8bcd\u5217\u8868\u4f5c\u4e3a\u8f93\u51fa\uff1a\n\n```python\nimport time\n\ndef trim_words(words, lens):\n    trimmed_words = []\n    time.sleep(5)\n    for w, l in zip(words, lens):\n        trimmed_words.append(w[:int(l)])\n    return [trimmed_words]\n    for w, l in zip(words, lens):\n```\n\n\u4f7f\u7528\u6279\u5904\u7406\u51fd\u6570\u7684\u4f18\u70b9\u662f\uff0c\u5982\u679c\u542f\u7528\u4e86\u961f\u5217\uff0cGradio \u670d\u52a1\u5668\u53ef\u4ee5\u81ea\u52a8*\u6279\u5904\u7406*\u4f20\u5165\u7684\u8bf7\u6c42\u5e76\u5e76\u884c\u5904\u7406\u5b83\u4eec\uff0c\u4ece\u800c\u53ef\u80fd\u52a0\u5feb\u6f14\u793a\u901f\u5ea6\u3002\u4ee5\u4e0b\u662f Gradio \u4ee3\u7801\u7684\u793a\u4f8b\uff08\u8bf7\u6ce8\u610f `batch=True` \u548c `max_batch_size=16` - \u8fd9\u4e24\u4e2a\u53c2\u6570\u90fd\u53ef\u4ee5\u4f20\u9012\u7ed9\u4e8b\u4ef6\u89e6\u53d1\u5668\u6216 `Interface` \u7c7b\uff09\n\nwith `Interface`\uff1a\n\n```python\ndemo = gr.Interface(trim_words, [\"textbox\", \"number\"], [\"output\"],\n                    batch=True, max_batch_size=16)\ndemo.queue()\ndemo.launch()\n```\n\nwith `Blocks`\uff1a\n\n```python\nimport gradio as gr\n\nwith gr.Blocks() as demo:\n    with gr.Row():\n        word = gr.Textbox(label=\"word\")\n        leng = gr.Number(label=\"leng\")\n        output = gr.Textbox(label=\"Output\")\n    with gr.Row():\n        run = gr.Button()\n\n    event = run.click(trim_words, [word, leng], output, batch=True, max_batch_size=16)\n\ndemo.queue()\ndemo.launch()\n```\n\n\u5728\u4e0a\u9762\u7684\u793a\u4f8b\u4e2d\uff0c\u53ef\u4ee5\u5e76\u884c\u5904\u7406 16 \u4e2a\u8bf7\u6c42\uff08\u603b\u63a8\u7406\u65f6\u95f4\u4e3a 5 \u79d2\uff09\uff0c\u800c\u4e0d\u662f\u5206\u522b\u5904\u7406\u6bcf\u4e2a\u8bf7\u6c42\uff08\u603b\u63a8\u7406\u65f6\u95f4\u4e3a 80 \u79d2\uff09\u3002\u8bb8\u591a Hugging Face \u7684 `transformers` \u548c `diffusers` \u6a21\u578b\u5728 Gradio \u7684\u6279\u5904\u7406\u6a21\u5f0f\u4e0b\u81ea\u7136\u5de5\u4f5c\uff1a\u8fd9\u662f[\u4f7f\u7528\u6279\u5904\u7406\u751f\u6210\u56fe\u50cf\u7684\u793a\u4f8b\u6f14\u793a](https://github.com/gradio-app/gradio/blob/main/demo/diffusers_with_batching/run.py)\n\n\u6ce8\u610f\uff1a\u4f7f\u7528 Gradio \u7684\u6279\u5904\u7406\u51fd\u6570 **requires** \u5728\u5e95\u5c42 Interface \u6216 Blocks \u4e2d\u542f\u7528\u961f\u5217\uff08\u8bf7\u53c2\u9605\u4e0a\u9762\u7684\u961f\u5217\u90e8\u5206\uff09\u3002\n\n## Gradio \u7b14\u8bb0\u672c (Colab Notebooks)\n\nGradio \u53ef\u4ee5\u5728\u4efb\u4f55\u8fd0\u884c Python \u7684\u5730\u65b9\u8fd0\u884c\uff0c\u5305\u62ec\u672c\u5730 Jupyter \u7b14\u8bb0\u672c\u548c\u534f\u4f5c\u7b14\u8bb0\u672c\uff0c\u5982[Google Colab](https://colab.research.google.com/)\u3002\u5bf9\u4e8e\u672c\u5730 Jupyter \u7b14\u8bb0\u672c\u548c Google Colab \u7b14\u8bb0\u672c\uff0cGradio \u5728\u672c\u5730\u670d\u52a1\u5668\u4e0a\u8fd0\u884c\uff0c\u60a8\u53ef\u4ee5\u5728\u6d4f\u89c8\u5668\u4e2d\u4e0e\u4e4b\u4ea4\u4e92\u3002\uff08\u6ce8\u610f\uff1a\u5bf9\u4e8e Google Colab\uff0c\u8fd9\u662f\u901a\u8fc7[\u670d\u52a1\u5de5\u4f5c\u5668\u96a7\u9053](https://github.com/tensorflow/tensorboard/blob/master/docs/design/colab_integration.md)\u5b9e\u73b0\u7684\uff0c\u60a8\u7684\u6d4f\u89c8\u5668\u9700\u8981\u542f\u7528 cookies\u3002\uff09\u5bf9\u4e8e\u5176\u4ed6\u8fdc\u7a0b\u7b14\u8bb0\u672c\uff0cGradio \u4e5f\u5c06\u5728\u670d\u52a1\u5668\u4e0a\u8fd0\u884c\uff0c\u4f46\u60a8\u9700\u8981\u4f7f\u7528[SSH \u96a7\u9053](https://coderwall.com/p/ohk6cg/remote-access-to-ipython-notebooks-via-ssh)\u5728\u672c\u5730\u6d4f\u89c8\u5668\u4e2d\u67e5\u770b\u5e94\u7528\u7a0b\u5e8f\u3002\u901a\u5e38\uff0c\u66f4\u7b80\u5355\u7684\u9009\u62e9\u662f\u4f7f\u7528 Gradio \u5185\u7f6e\u7684\u516c\u5171\u94fe\u63a5\uff0c[\u5728\u4e0b\u4e00\u7bc7\u6307\u5357\u4e2d\u8ba8\u8bba](/sharing-your-app/#sharing-demos)\u3002\n    ```",
            "vector_context": "[Created at: 2025-03-24 13:17:32]\n(for example, a v3-32), your TPU fleet is referred to as a **pod slice.**\n\nWhen you access a free TPU via Colab, you generally get a single v2-8 TPU.\n\n### I keep hearing about this XLA thing. What\u2019s XLA, and how does it relate to TPUs?\n\nXLA is an optimizing compiler, used by both TensorFlow and JAX. In JAX it is the only compiler, whereas in TensorFlow it is optional (but mandatory on TPU!). The easiest way to enable it when training a Keras model is to pass the argument `jit_compile=True` to `model.compile()`. If you don\u2019t get any errors and performance is good, that\u2019s a great sign that you\u2019re ready to move to TPU!\n\nDebugging on TPU is generally a bit harder than on CPU/GPU, so we recommend getting your code running on CPU/GPU with XLA first before trying it on TPU. You don\u2019t have to train for long, of course - just for a few steps to make sure that your model and data pipeline are working like you expect them to.\n\n<Tip>\n\nXLA compiled code is usually faster - so even if you\u2019re not planning to run on TPU, adding `jit_compile=True` can improve your performance. Be sure to note the caveats below about XLA compatibility, though!\n\n</Tip>\n\n<Tip warning={true}>\n\n**Tip born of painful experience:** Although using `jit_compile=True` is a good way to get a speed boost and test if your CPU/GPU code is XLA-compatible, it can actually cause a lot of problems if you leave it in when actually training on TPU. XLA compilation will happen implicitly on TPU, so remember to remove that line before actually running your code on a TPU!\n\n</Tip>\n\n### How do I make my model XLA compatible?\n\nIn many cases, your code is probably XLA-compatible already! However, there are a few things that work in normal TensorFlow that don\u2019t work in XLA. We\u2019ve distilled them into three core rules below:\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** We\u2019ve put a lot of effort into rewriting our TensorFlow models and loss functions to be XLA-compatible. Our models and loss functions generally obey rule #1 and #2 by default, so you can skip over them if you\u2019re using `transformers` models. Don\u2019t forget about these rules when writing your own models and loss functions, though!\n\n</Tip>\n\n#### XLA Rule #1: Your code cannot have \u201cdata-dependent conditionals\u201d\n\nWhat that means is that any `if` statement cannot depend on values inside a `tf.Tensor`. For example, this code block cannot be compiled with XLA!\n\n```python\nif tf.reduce_sum(tensor) > 10:\n    tensor = tensor / 2.0\n```\n\nThis might seem very restrictive at first, but most neural net code doesn\u2019t need to do this. You can often get around this restriction by using `tf.cond` (see the documentation [here](https://www.tensorflow.org/api_docs/python/tf/cond)) or by removing the conditional and finding a clever math trick with indicator variables instead, like so:\n\n```python\nsum_over_10 = tf.cast(tf.reduce_sum(tensor) > 10, tf.float32)\ntensor = tensor / (1.0 + sum_over_10)\n```\n\nThis code has exactly the same effect as the code above, but by avoiding a conditional, we ensure it will compile with XLA without problems!\n\n#### XLA Rule #2: Your code cannot have \u201cdata-dependent shapes\u201d\n\nWhat this means is that the shape of all of the `tf.Tensor` objects in your code cannot depend on their values. For example, the function `tf.unique` cannot be compiled with XLA, because it returns a `tensor` containing one instance of each unique value in the input. The shape of this output will obviously be different depending on how repetitive the input `Tensor` was, and so XLA refuses to handle it!\n\nIn general, most neural network code obeys rule #2 by default. However, there are a few common cases where it becomes a problem. One very common one is when you use **label masking**, setting your labels to a negative value to indicate that those positions should be ignored when computing the loss. If you look at NumPy or PyTorch loss functions that support label masking, you will often see code like this that uses [boolean indexing](https://numpy.org/doc/stable/user/basics.indexing.html#boolean-array-indexing):\n\n```python\nlabel_mask = labels >= 0\nmasked_outputs = outputs[label_mask]\nmasked_labels = labels[label_mask]\nloss = compute_loss(masked_outputs, masked_labels)\nmean_loss = torch.mean(loss)\n```\n\nThis code is totally fine in NumPy or PyTorch, but it breaks in XLA! Why? Because the shape of `masked_outputs` and `masked_labels` depends on how many positions are masked - that makes it a **data-dependent shape.** However, just like for rule #1, we can often rewrite this code to yield exactly the same output without any data-dependent shapes.\n\n```python\nlabel_mask = tf.cast(labels >= 0, tf.float32)\nloss = compute_loss(outputs, labels)\nloss = loss * label_mask  # Set negative label positions to 0\nmean_loss = tf.reduce_sum(loss) / tf.reduce_sum(label_mask)\n```\n\nHere, we avoid data-dependent shapes by computing the loss for every position, but zeroing out the masked positions in both the numerator and denominator when we calculate the mean, which yields exactly the same result as the first block while maintaining XLA compatibility. Note that we use the same trick as in rule #1 - converting a `tf.bool` to `\n--New Chunk--\n[Created at: 2025-03-24 13:16:48]\n\u4e0e\u5e38\u89c4\u51fd\u6570\u76f8\u540c\u7684\u65b9\u5f0f\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio\u3002\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\uff08\u865a\u62df\u7684\uff09\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5b83\u5728\u8f93\u51fa\u56fe\u50cf\u4e4b\u524d\u751f\u6210\u6570\u4e2a\u6b65\u9aa4\u7684\u566a\u97f3\uff1a\n\n$code_fake_diffusion\n$demo_fake_diffusion\n\n\u8bf7\u6ce8\u610f\uff0c\u6211\u4eec\u5728\u8fed\u4ee3\u5668\u4e2d\u6dfb\u52a0\u4e86 `time.sleep(1)`\uff0c\u4ee5\u521b\u5efa\u6b65\u9aa4\u4e4b\u95f4\u7684\u4eba\u5de5\u6682\u505c\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u89c2\u5bdf\u8fed\u4ee3\u5668\u7684\u6b65\u9aa4\uff08\u5728\u771f\u5b9e\u7684\u56fe\u50cf\u751f\u6210\u6a21\u578b\u4e2d\uff0c\u8fd9\u53ef\u80fd\u662f\u4e0d\u5fc5\u8981\u7684\uff09\u3002\n\n\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio **\u9700\u8981**\u5728\u5e95\u5c42 Interface \u6216 Blocks \u4e2d\u542f\u7528\u961f\u5217\uff08\u8bf7\u53c2\u9605\u4e0a\u9762\u7684\u961f\u5217\u90e8\u5206\uff09\u3002\n\n## \u8fdb\u5ea6\u6761\n\nGradio \u652f\u6301\u521b\u5efa\u81ea\u5b9a\u4e49\u8fdb\u5ea6\u6761\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u81ea\u5b9a\u4e49\u548c\u63a7\u5236\u5411\u7528\u6237\u663e\u793a\u7684\u8fdb\u5ea6\u66f4\u65b0\u3002\u8981\u542f\u7528\u6b64\u529f\u80fd\uff0c\u53ea\u9700\u4e3a\u65b9\u6cd5\u6dfb\u52a0\u4e00\u4e2a\u9ed8\u8ba4\u503c\u4e3a `gr.Progress` \u5b9e\u4f8b\u7684\u53c2\u6570\u5373\u53ef\u3002\u7136\u540e\uff0c\u60a8\u53ef\u4ee5\u76f4\u63a5\u8c03\u7528\u6b64\u5b9e\u4f8b\u5e76\u4f20\u5165 0 \u5230 1 \u4e4b\u95f4\u7684\u6d6e\u70b9\u6570\u6765\u66f4\u65b0\u8fdb\u5ea6\u7ea7\u522b\uff0c\u6216\u8005 with `Progress` \u5b9e\u4f8b\u7684 `tqdm()` \u65b9\u6cd5\u6765\u8ddf\u8e2a\u53ef\u8fed\u4ee3\u5bf9\u8c61\u4e0a\u7684\u8fdb\u5ea6\uff0c\u5982\u4e0b\u6240\u793a\u3002\u5fc5\u987b\u542f\u7528\u961f\u5217\u4ee5\u8fdb\u884c\u8fdb\u5ea6\u66f4\u65b0\u3002\n\n$code_progress_simple\n$demo_progress_simple\n\n\u5982\u679c\u60a8 with `tqdm` \u5e93\uff0c\u5e76\u4e14\u5e0c\u671b\u4ece\u51fd\u6570\u5185\u90e8\u7684\u4efb\u4f55 `tqdm.tqdm` \u81ea\u52a8\u62a5\u544a\u8fdb\u5ea6\u66f4\u65b0\uff0c\u8bf7\u5c06\u9ed8\u8ba4\u53c2\u6570\u8bbe\u7f6e\u4e3a `gr.Progress(track_tqdm=True)`\uff01\n\n## \u6279\u5904\u7406\u51fd\u6570 (Batch Functions)\n\nGradio \u652f\u6301\u4f20\u9012*\u6279\u5904\u7406*\u51fd\u6570\u3002\u6279\u5904\u7406\u51fd\u6570\u53ea\u662f\u63a5\u53d7\u8f93\u5165\u5217\u8868\u5e76\u8fd4\u56de\u9884\u6d4b\u5217\u8868\u7684\u51fd\u6570\u3002\n\n\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\u6279\u5904\u7406\u51fd\u6570\uff0c\u5b83\u63a5\u53d7\u4e24\u4e2a\u8f93\u5165\u5217\u8868\uff08\u4e00\u4e2a\u5355\u8bcd\u5217\u8868\u548c\u4e00\u4e2a\u6574\u6570\u5217\u8868\uff09\uff0c\u5e76\u8fd4\u56de\u4fee\u526a\u8fc7\u7684\u5355\u8bcd\u5217\u8868\u4f5c\u4e3a\u8f93\u51fa\uff1a\n\n```python\nimport time\n\ndef trim_words(words, lens):\n    trimmed_words = []\n    time.sleep(5)\n    for w, l in zip(words, lens):\n        trimmed_words.append(w[:int(l)])\n    return [trimmed_words]\n    for w, l in zip(words, lens):\n```\n\n\u4f7f\u7528\u6279\u5904\u7406\u51fd\u6570\u7684\u4f18\u70b9\u662f\uff0c\u5982\u679c\u542f\u7528\u4e86\u961f\u5217\uff0cGradio \u670d\u52a1\u5668\u53ef\u4ee5\u81ea\u52a8*\u6279\u5904\u7406*\u4f20\u5165\u7684\u8bf7\u6c42\u5e76\u5e76\u884c\u5904\u7406\u5b83\u4eec\uff0c\u4ece\u800c\u53ef\u80fd\u52a0\u5feb\u6f14\u793a\u901f\u5ea6\u3002\u4ee5\u4e0b\u662f Gradio \u4ee3\u7801\u7684\u793a\u4f8b\uff08\u8bf7\u6ce8\u610f `batch=True` \u548c `max_batch_size=16` - \u8fd9\u4e24\u4e2a\u53c2\u6570\u90fd\u53ef\u4ee5\u4f20\u9012\u7ed9\u4e8b\u4ef6\u89e6\u53d1\u5668\u6216 `Interface` \u7c7b\uff09\n\nwith `Interface`\uff1a\n\n```python\ndemo = gr.Interface(trim_words, [\"textbox\", \"number\"], [\"output\"],\n                    batch=True, max_batch_size=16)\ndemo.queue()\ndemo.launch()\n```\n\nwith `Blocks`\uff1a\n\n```python\nimport gradio as gr\n\nwith gr.Blocks() as demo:\n    with gr.Row():\n        word = gr.Textbox(label=\"word\")\n        leng = gr.Number(label=\"leng\")\n        output = gr.Textbox(label=\"Output\")\n    with gr.Row():\n        run = gr.Button()\n\n    event = run.click(trim_words, [word, leng], output, batch=True, max_batch_size=16)\n\ndemo.queue()\ndemo.launch()\n```\n\n\u5728\u4e0a\u9762\u7684\u793a\u4f8b\u4e2d\uff0c\u53ef\u4ee5\u5e76\u884c\u5904\u7406 16 \u4e2a\u8bf7\u6c42\uff08\u603b\u63a8\u7406\u65f6\u95f4\u4e3a 5 \u79d2\uff09\uff0c\u800c\u4e0d\u662f\u5206\u522b\u5904\u7406\u6bcf\u4e2a\u8bf7\u6c42\uff08\u603b\u63a8\u7406\u65f6\u95f4\u4e3a 80 \u79d2\uff09\u3002\u8bb8\u591a Hugging Face \u7684 `transformers` \u548c `diffusers` \u6a21\u578b\u5728 Gradio \u7684\u6279\u5904\u7406\u6a21\u5f0f\u4e0b\u81ea\u7136\u5de5\u4f5c\uff1a\u8fd9\u662f[\u4f7f\u7528\u6279\u5904\u7406\u751f\u6210\u56fe\u50cf\u7684\u793a\u4f8b\u6f14\u793a](https://github.com/gradio-app/gradio/blob/main/demo/diffusers_with_batching/run.py)\n\n\u6ce8\u610f\uff1a\u4f7f\u7528 Gradio \u7684\u6279\u5904\u7406\u51fd\u6570 **requires** \u5728\u5e95\u5c42 Interface \u6216 Blocks \u4e2d\u542f\u7528\u961f\u5217\uff08\u8bf7\u53c2\u9605\u4e0a\u9762\u7684\u961f\u5217\u90e8\u5206\uff09\u3002\n\n## Gradio \u7b14\u8bb0\u672c (Colab Notebooks)\n\nGradio \u53ef\u4ee5\u5728\u4efb\u4f55\u8fd0\u884c Python \u7684\u5730\u65b9\u8fd0\u884c\uff0c\u5305\u62ec\u672c\u5730 Jupyter \u7b14\u8bb0\u672c\u548c\u534f\u4f5c\u7b14\u8bb0\u672c\uff0c\u5982[Google Colab](https://colab.research.google.com/)\u3002\u5bf9\u4e8e\u672c\u5730 Jupyter \u7b14\u8bb0\u672c\u548c Google Colab \u7b14\u8bb0\u672c\uff0cGradio \u5728\u672c\u5730\u670d\u52a1\u5668\u4e0a\u8fd0\u884c\uff0c\u60a8\u53ef\u4ee5\u5728\u6d4f\u89c8\u5668\u4e2d\u4e0e\u4e4b\u4ea4\u4e92\u3002\uff08\u6ce8\u610f\uff1a\u5bf9\u4e8e Google Colab\uff0c\u8fd9\u662f\u901a\u8fc7[\u670d\u52a1\u5de5\u4f5c\u5668\u96a7\u9053](https://github.com/tensorflow/tensorboard/blob/master/docs/design/colab_integration.md)\u5b9e\u73b0\u7684\uff0c\u60a8\u7684\u6d4f\u89c8\u5668\u9700\u8981\u542f\u7528 cookies\u3002\uff09\u5bf9\u4e8e\u5176\u4ed6\u8fdc\u7a0b\u7b14\u8bb0\u672c\uff0cGradio \u4e5f\u5c06\u5728\u670d\u52a1\u5668\u4e0a\u8fd0\u884c\uff0c\u4f46\u60a8\u9700\u8981\u4f7f\u7528[SSH \u96a7\u9053](https://coderwall.com/p/ohk6cg/remote-access-to-ipython-notebooks-via-ssh)\u5728\u672c\u5730\u6d4f\u89c8\u5668\u4e2d\u67e5\u770b\u5e94\u7528\u7a0b\u5e8f\u3002\u901a\u5e38\uff0c\u66f4\u7b80\u5355\u7684\u9009\u62e9\u662f\u4f7f\u7528 Gradio \u5185\u7f6e\u7684\u516c\u5171\u94fe\u63a5\uff0c[\u5728\u4e0b\u4e00\u7bc7\u6307\u5357\u4e2d\u8ba8\u8bba](/sharing-your-app/#sharing-demos)\u3002\n--New Chunk--\n[Created at: 2025-03-24 13:16:48]\n\u65f6\u5fc5\u987b\u9009\u62e9\u5176\u4e2d\u4e00\u4e2a\u5b57\u7b26\u4e32\uff0c\u8fd9\u5c06\u4f5c\u4e3a\u9644\u52a0\u5217\u4fdd\u5b58\u5230 CSV \u4e2d\u3002\n\n## \u9884\u5904\u7406\u548c\u540e\u5904\u7406 (Preprocessing and Postprocessing)\n\n![annotated](/assets/img/dataflow.svg)\n\n\u5982\u60a8\u6240\u89c1\uff0cGradio \u5305\u62ec\u53ef\u4ee5\u5904\u7406\u5404\u79cd\u4e0d\u540c\u6570\u636e\u7c7b\u578b\u7684\u7ec4\u4ef6\uff0c\u4f8b\u5982\u56fe\u50cf\u3001\u97f3\u9891\u548c\u89c6\u9891\u3002\u5927\u591a\u6570\u7ec4\u4ef6\u90fd\u53ef\u4ee5\u7528\u4f5c\u8f93\u5165\u6216\u8f93\u51fa\u3002\n\n\u5f53\u7ec4\u4ef6\u7528\u4f5c\u8f93\u5165\u65f6\uff0cGradio \u81ea\u52a8\u5904\u7406*\u9884\u5904\u7406*\uff0c\u5c06\u6570\u636e\u4ece\u7528\u6237\u6d4f\u89c8\u5668\u53d1\u9001\u7684\u7c7b\u578b\uff08\u4f8b\u5982\u7f51\u7edc\u6444\u50cf\u5934\u5feb\u7167\u7684 base64 \u8868\u793a\uff09\u8f6c\u6362\u4e3a\u60a8\u7684\u51fd\u6570\u53ef\u4ee5\u63a5\u53d7\u7684\u5f62\u5f0f\uff08\u4f8b\u5982 `numpy` \u6570\u7ec4\uff09\u3002\n\n\u540c\u6837\uff0c\u5f53\u7ec4\u4ef6\u7528\u4f5c\u8f93\u51fa\u65f6\uff0cGradio \u81ea\u52a8\u5904\u7406*\u540e\u5904\u7406*\uff0c\u5c06\u6570\u636e\u4ece\u51fd\u6570\u8fd4\u56de\u7684\u5f62\u5f0f\uff08\u4f8b\u5982\u56fe\u50cf\u8def\u5f84\u5217\u8868\uff09\u8f6c\u6362\u4e3a\u53ef\u4ee5\u5728\u7528\u6237\u6d4f\u89c8\u5668\u4e2d\u663e\u793a\u7684\u5f62\u5f0f\uff08\u4f8b\u5982\u4ee5 base64 \u683c\u5f0f\u663e\u793a\u56fe\u50cf\u7684 `Gallery`\uff09\u3002\n\n\u60a8\u53ef\u4ee5\u4f7f\u7528\u6784\u5efa\u56fe\u50cf\u7ec4\u4ef6\u65f6\u7684\u53c2\u6570\u63a7\u5236*\u9884\u5904\u7406*\u3002\u4f8b\u5982\uff0c\u5982\u679c\u60a8\u4f7f\u7528\u4ee5\u4e0b\u53c2\u6570\u5b9e\u4f8b\u5316 `Image` \u7ec4\u4ef6\uff0c\u5b83\u5c06\u5c06\u56fe\u50cf\u8f6c\u6362\u4e3a `PIL` \u7c7b\u578b\uff0c\u5e76\u5c06\u5176\u91cd\u5851\u4e3a`(100, 100)`\uff0c\u800c\u4e0d\u7ba1\u63d0\u4ea4\u65f6\u7684\u539f\u59cb\u5927\u5c0f\u5982\u4f55\uff1a\n\n```py\nimg = gr.Image(shape=(100, 100), type=\"pil\")\n```\n\n\u76f8\u53cd\uff0c\u8fd9\u91cc\u6211\u4eec\u4fdd\u7559\u56fe\u50cf\u7684\u539f\u59cb\u5927\u5c0f\uff0c\u4f46\u5728\u5c06\u5176\u8f6c\u6362\u4e3a numpy \u6570\u7ec4\u4e4b\u524d\u53cd\u8f6c\u989c\u8272\uff1a\n\n```py\nimg = gr.Image(invert_colors=True, type=\"numpy\")\n```\n\n\u540e\u5904\u7406\u8981\u5bb9\u6613\u5f97\u591a\uff01Gradio \u81ea\u52a8\u8bc6\u522b\u8fd4\u56de\u6570\u636e\u7684\u683c\u5f0f\uff08\u4f8b\u5982 `Image` \u662f `numpy` \u6570\u7ec4\u8fd8\u662f `str` \u6587\u4ef6\u8def\u5f84\uff1f\uff09\uff0c\u5e76\u5c06\u5176\u540e\u5904\u7406\u4e3a\u53ef\u4ee5\u7531\u6d4f\u89c8\u5668\u663e\u793a\u7684\u683c\u5f0f\u3002\n\n\u8bf7\u67e5\u770b[\u6587\u6863](https://gradio.app/docs)\uff0c\u4e86\u89e3\u6bcf\u4e2a\u7ec4\u4ef6\u7684\u6240\u6709\u4e0e\u9884\u5904\u7406\u76f8\u5173\u7684\u53c2\u6570\u3002\n\n## \u6837\u5f0f (Styling)\n\nGradio \u4e3b\u9898\u662f\u81ea\u5b9a\u4e49\u5e94\u7528\u7a0b\u5e8f\u5916\u89c2\u548c\u611f\u89c9\u7684\u6700\u7b80\u5355\u65b9\u6cd5\u3002\u60a8\u53ef\u4ee5\u9009\u62e9\u591a\u79cd\u4e3b\u9898\u6216\u521b\u5efa\u81ea\u5df1\u7684\u4e3b\u9898\u3002\u8981\u8fd9\u6837\u505a\uff0c\u8bf7\u5c06 `theme=` \u53c2\u6570\u4f20\u9012\u7ed9 `Interface` \u6784\u9020\u51fd\u6570\u3002\u4f8b\u5982\uff1a\n\n```python\ndemo = gr.Interface(..., theme=gr.themes.Monochrome())\n```\n\nGradio \u5e26\u6709\u4e00\u7ec4\u9884\u5148\u6784\u5efa\u7684\u4e3b\u9898\uff0c\u60a8\u53ef\u4ee5\u4ece `gr.themes.*` \u52a0\u8f7d\u3002\u60a8\u53ef\u4ee5\u6269\u5c55\u8fd9\u4e9b\u4e3b\u9898\u6216\u4ece\u5934\u5f00\u59cb\u521b\u5efa\u81ea\u5df1\u7684\u4e3b\u9898 - \u6709\u5173\u66f4\u591a\u8be6\u7ec6\u4fe1\u606f\uff0c\u8bf7\u53c2\u9605[\u4e3b\u9898\u6307\u5357](https://gradio.app/theming-guide)\u3002\n\n\u8981\u589e\u52a0\u989d\u5916\u7684\u6837\u5f0f\u80fd\u529b\uff0c\u60a8\u53ef\u4ee5 with `css=` \u5173\u952e\u5b57\u5c06\u4efb\u4f55 CSS \u4f20\u9012\u7ed9\u60a8\u7684\u5e94\u7528\u7a0b\u5e8f\u3002\nGradio \u5e94\u7528\u7a0b\u5e8f\u7684\u57fa\u7c7b\u662f `gradio-container`\uff0c\u56e0\u6b64\u4ee5\u4e0b\u662f\u4e00\u4e2a\u66f4\u6539 Gradio \u5e94\u7528\u7a0b\u5e8f\u80cc\u666f\u989c\u8272\u7684\u793a\u4f8b\uff1a\n\n```python\nwith `gr.Interface(css=\".gradio-container {background-color: red}\") as demo:\n    ...\n```\n\n## \u961f\u5217 (Queuing)\n\n\u5982\u679c\u60a8\u7684\u5e94\u7528\u7a0b\u5e8f\u9884\u8ba1\u4f1a\u6709\u5927\u91cf\u6d41\u91cf\uff0c\u8bf7 with `queue()` \u65b9\u6cd5\u6765\u63a7\u5236\u5904\u7406\u901f\u7387\u3002\u8fd9\u5c06\u6392\u961f\u5904\u7406\u8c03\u7528\uff0c\u56e0\u6b64\u4e00\u6b21\u53ea\u5904\u7406\u4e00\u5b9a\u6570\u91cf\u7684\u8bf7\u6c42\u3002\u961f\u5217\u4f7f\u7528 Websockets\uff0c\u8fd8\u53ef\u4ee5\u9632\u6b62\u7f51\u7edc\u8d85\u65f6\uff0c\u56e0\u6b64\u5982\u679c\u60a8\u7684\u51fd\u6570\u7684\u63a8\u7406\u65f6\u95f4\u5f88\u957f\uff08> 1 \u5206\u949f\uff09\uff0c\u5e94\u4f7f\u7528\u961f\u5217\u3002\n\nwith `Interface`\uff1a\n\n```python\ndemo = gr.Interface(...).queue()\ndemo.launch()\n```\n\nwith `Blocks`\uff1a\n\n```python\nwith gr.Blocks() as demo\uff1a\n    #...\ndemo.queue()\ndemo.launch()\n```\n\n\u60a8\u53ef\u4ee5\u901a\u8fc7\u4ee5\u4e0b\u65b9\u5f0f\u63a7\u5236\u4e00\u6b21\u5904\u7406\u7684\u8bf7\u6c42\u6570\u91cf\uff1a\n\n```python\ndemo.queue(concurrency_count=3)\n```\n\n\u67e5\u770b\u6709\u5173\u914d\u7f6e\u5176\u4ed6\u961f\u5217\u53c2\u6570\u7684[\u961f\u5217\u6587\u6863](/docs/#queue)\u3002\n\n\u5728 Blocks \u4e2d\u6307\u5b9a\u4ec5\u5bf9\u67d0\u4e9b\u51fd\u6570\u8fdb\u884c\u6392\u961f\uff1a\n\n```python\nwith gr.Blocks() as demo2\uff1a\n    num1 = gr.Number()\n    num2 = gr.Number()\n    output = gr.Number()\n    gr.Button(\"Add\").click(\n        lambda a, b: a + b, [num1, num2], output)\n    gr.Button(\"Multiply\").click(\n        lambda a, b: a * b, [num1, num2], output, queue=True)\ndemo2.launch()\n```\n\n## \u8fed\u4ee3\u8f93\u51fa (Iterative Outputs)\n\n\u5728\u67d0\u4e9b\u60c5\u51b5\u4e0b\uff0c\u60a8\u53ef\u80fd\u9700\u8981\u4f20\u8f93\u4e00\u7cfb\u5217\u8f93\u51fa\u800c\u4e0d\u662f\u4e00\u6b21\u663e\u793a\u5355\u4e2a\u8f93\u51fa\u3002\u4f8b\u5982\uff0c\u60a8\u53ef\u80fd\u6709\u4e00\u4e2a\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5e0c\u671b\u663e\u793a\u751f\u6210\u7684\u6bcf\u4e2a\u6b65\u9aa4\u7684\u56fe\u50cf\uff0c\u76f4\u5230\u6700\u7ec8\u56fe\u50cf\u3002\u6216\u8005\u60a8\u53ef\u80fd\u6709\u4e00\u4e2a\u804a\u5929\u673a\u5668\u4eba\uff0c\u5b83\u9010\u5b57\u9010\u53e5\u5730\u6d41\u5f0f\u4f20\u8f93\u54cd\u5e94\uff0c\u800c\u4e0d\u662f\u4e00\u6b21\u8fd4\u56de\u5168\u90e8\u54cd\u5e94\u3002\n\n\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u60a8\u53ef\u4ee5\u5c06**\u751f\u6210\u5668**\u51fd\u6570\u63d0\u4f9b\u7ed9 Gradio\uff0c\u800c\u4e0d\u662f\u5e38\u89c4\u51fd\u6570\u3002\u5728 Python \u4e2d\u521b\u5efa\u751f\u6210\u5668\u975e\u5e38\u7b80\u5355\uff1a\u51fd\u6570\u4e0d\u5e94\u8be5\u6709\u4e00\u4e2a\u5355\u72ec\u7684 `return` \u503c\uff0c\u800c\u662f\u5e94\u8be5 with `yield` \u8fde\u7eed\u8fd4\u56de\u4e00\u7cfb\u5217\u503c\u3002\u901a\u5e38\uff0c`yield` \u8bed\u53e5\u653e\u7f6e\u5728\u67d0\u79cd\u5faa\u73af\u4e2d\u3002\u4e0b\u9762\u662f\u4e00\u4e2a\u7b80\u5355\u793a\u4f8b\uff0c\u751f\u6210\u5668\u53ea\u662f\u7b80\u5355\u8ba1\u6570\u5230\u7ed9\u5b9a\u6570\u5b57\uff1a\n\n```python\ndef my_generator(x):\n    for i in range(x):\n        yield i\n```\n\n\u60a8\u4ee5\u4e0e\u5e38\u89c4\u51fd\u6570\u76f8\u540c\u7684\u65b9\u5f0f\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio\u3002\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\uff08\u865a\u62df\u7684\uff09\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5b83\u5728\u8f93\u51fa\u56fe\u50cf\u4e4b\u524d\u751f\u6210\u6570\u4e2a\u6b65\u9aa4\u7684\u566a\u97f3\uff1a\n\n$code_fake_diffusion\n$demo_fake_diffusion\n\n\u8bf7\u6ce8\u610f\uff0c\u6211\u4eec\u5728\u8fed\u4ee3\u5668\u4e2d\u6dfb\u52a0\u4e86 `time.sleep(1)`\uff0c\u4ee5\u521b\u5efa\u6b65\u9aa4\u4e4b\u95f4\u7684\u4eba\u5de5\u6682\u505c\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u89c2\u5bdf\u8fed\u4ee3\u5668\u7684\u6b65\u9aa4\uff08\u5728\u771f\u5b9e\u7684\u56fe\u50cf\u751f\u6210\u6a21\u578b\u4e2d\uff0c\u8fd9"
        }
    },
    {
        "sample_idx": 59,
        "question": "What happens if you leave jit_compile=True when training on TPU?",
        "answer": "It can cause a lot of problems.",
        "rag_answer": "If you leave `jit_compile=True` when training on TPU,",
        "rag_score": null,
        "rag_feedback": null,
        "rag_context": {
            "kg_context": "-----Entities-----\n    ```csv\n    id,\tentity,\ttype,\tdescription,\trankcreated_at\n1,\tTPU,technology,TPU is a Tensor Processing Unit, a hardware designed by Google to speed up tensor computations within neural networks.<SEP>TPU is a type of hardware accelerator designed for machine learning workloads.<SEP>TPU is a type of hardware accelerator used for machine learning computations.,4,2025-03-24 13:18:20\n2,\tXLA,technology,XLA is a technology that compiles TensorFlow graphs into executable code for various platforms.<SEP>XLA is an optimizing compiler used by TensorFlow and JAX to improve performance.<SEP>XLA is an optimizing compiler, used by both TensorFlow and JAX to optimize computations.,6,2025-03-24 13:18:20\n3,\tGoogle,organization,Google is the company that designs and provides TPUs, which are used to speed up tensor computations within neural networks.,3,2025-03-24 13:18:20\n4,\tGoogle Cloud,organization,Google Cloud is a cloud computing platform that provides infrastructure and services for building and deploying machine learning models.,1,2025-03-24 13:18:20\n5,\tjit_compile,concept,jit_compile is a technique for compiling TensorFlow graphs into executable code.,1,UNKNOWN\n6,\tTPU,technology,TPU is a Tensor Processing Unit, a hardware designed by Google to speed up tensor computations within neural networks.<SEP>TPU is a type of hardware accelerator designed for machine learning workloads.<SEP>TPU is a type of hardware accelerator used for machine learning computations.,4,UNKNOWN\n7,\tGoogle,organization,Google is the company that designs and provides TPUs, which are used to speed up tensor computations within neural networks.,3,UNKNOWN\n    ```\n    -----Relationships-----\n    ```csv\n    id,\tsource,\ttarget,\tdescription,\tkeywords,\tweight,\trank,\tcreated_at\n1,\tTPU,XLA,XLA compiles TensorFlow graphs into executable code for TPU hardware.<SEP>XLA is used to optimize code for TPU hardware.,compilation, hardware acceleration<SEP>compiler, hardware optimization,36.0,10,2025-03-24 13:18:20\n2,\tGoogle,TPU,Google designs and provides TPUs, which are used to speed up tensor computations within neural networks.,hardware design, acceleration,18.0,7,2025-03-24 13:18:20\n3,\tGoogle Cloud,TPU,Google Cloud provides infrastructure and services for building and deploying machine learning models, including TPU hardware.,infrastructure provision, hardware acceleration,14.0,5,2025-03-24 13:18:20\n4,\tTPU,XLA,XLA compiles TensorFlow graphs into executable code for TPU hardware.<SEP>XLA is used to optimize code for TPU hardware.,compilation, hardware acceleration<SEP>compiler, hardware optimization,36.0,10,UNKNOWN\n5,\tGoogle,TPU,Google designs and provides TPUs, which are used to speed up tensor computations within neural networks.,hardware design, acceleration,18.0,7,UNKNOWN\n6,\tColab,TPU,Colab provides access to a free TPU for users.,platform, hardware acceleration,16.0,7,UNKNOWN\n7,\tXLA,jit_compile,jit_compile is a technique used in XLA to compile TensorFlow graphs into executable code.,compilation technique, XLA support,3.0,7,UNKNOWN\n8,\tColab,Google,Colab is a cloud-based platform provided by Google for data science and machine learning.,platform provision, cloud computing,16.0,6,UNKNOWN\n9,\tGoogle Cloud,TPU,Google Cloud provides infrastructure and services for building and deploying machine learning models, including TPU hardware.,infrastructure provision, hardware acceleration,14.0,5,UNKNOWN\n10,\tGoogle,Kaggle Kernels,Kaggle Kernels is a cloud-based platform provided by Google for data science and machine learning competitions.,platform provision, cloud computing,16.0,4,UNKNOWN\n    ```\n    -----Sources-----\n    ```csv\n    id,\tcontent\n1,\t(for example, a v3-32), your TPU fleet is referred to as a **pod slice.**\n\nWhen you access a free TPU via Colab, you generally get a single v2-8 TPU.\n\n### I keep hearing about this XLA thing. What\u2019s XLA, and how does it relate to TPUs?\n\nXLA is an optimizing compiler, used by both TensorFlow and JAX. In JAX it is the only compiler, whereas in TensorFlow it is optional (but mandatory on TPU!). The easiest way to enable it when training a Keras model is to pass the argument `jit_compile=True` to `model.compile()`. If you don\u2019t get any errors and performance is good, that\u2019s a great sign that you\u2019re ready to move to TPU!\n\nDebugging on TPU is generally a bit harder than on CPU/GPU, so we recommend getting your code running on CPU/GPU with XLA first before trying it on TPU. You don\u2019t have to train for long, of course - just for a few steps to make sure that your model and data pipeline are working like you expect them to.\n\n<Tip>\n\nXLA compiled code is usually faster - so even if you\u2019re not planning to run on TPU, adding `jit_compile=True` can improve your performance. Be sure to note the caveats below about XLA compatibility, though!\n\n</Tip>\n\n<Tip warning={true}>\n\n**Tip born of painful experience:** Although using `jit_compile=True` is a good way to get a speed boost and test if your CPU/GPU code is XLA-compatible, it can actually cause a lot of problems if you leave it in when actually training on TPU. XLA compilation will happen implicitly on TPU, so remember to remove that line before actually running your code on a TPU!\n\n</Tip>\n\n### How do I make my model XLA compatible?\n\nIn many cases, your code is probably XLA-compatible already! However, there are a few things that work in normal TensorFlow that don\u2019t work in XLA. We\u2019ve distilled them into three core rules below:\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** We\u2019ve put a lot of effort into rewriting our TensorFlow models and loss functions to be XLA-compatible. Our models and loss functions generally obey rule #1 and #2 by default, so you can skip over them if you\u2019re using `transformers` models. Don\u2019t forget about these rules when writing your own models and loss functions, though!\n\n</Tip>\n\n#### XLA Rule #1: Your code cannot have \u201cdata-dependent conditionals\u201d\n\nWhat that means is that any `if` statement cannot depend on values inside a `tf.Tensor`. For example, this code block cannot be compiled with XLA!\n\n```python\nif tf.reduce_sum(tensor) > 10:\n    tensor = tensor / 2.0\n```\n\nThis might seem very restrictive at first, but most neural net code doesn\u2019t need to do this. You can often get around this restriction by using `tf.cond` (see the documentation [here](https://www.tensorflow.org/api_docs/python/tf/cond)) or by removing the conditional and finding a clever math trick with indicator variables instead, like so:\n\n```python\nsum_over_10 = tf.cast(tf.reduce_sum(tensor) > 10, tf.float32)\ntensor = tensor / (1.0 + sum_over_10)\n```\n\nThis code has exactly the same effect as the code above, but by avoiding a conditional, we ensure it will compile with XLA without problems!\n\n#### XLA Rule #2: Your code cannot have \u201cdata-dependent shapes\u201d\n\nWhat this means is that the shape of all of the `tf.Tensor` objects in your code cannot depend on their values. For example, the function `tf.unique` cannot be compiled with XLA, because it returns a `tensor` containing one instance of each unique value in the input. The shape of this output will obviously be different depending on how repetitive the input `Tensor` was, and so XLA refuses to handle it!\n\nIn general, most neural network code obeys rule #2 by default. However, there are a few common cases where it becomes a problem. One very common one is when you use **label masking**, setting your labels to a negative value to indicate that those positions should be ignored when computing the loss. If you look at NumPy or PyTorch loss functions that support label masking, you will often see code like this that uses [boolean indexing](https://numpy.org/doc/stable/user/basics.indexing.html#boolean-array-indexing):\n\n```python\nlabel_mask = labels >= 0\nmasked_outputs = outputs[label_mask]\nmasked_labels = labels[label_mask]\nloss = compute_loss(masked_outputs, masked_labels)\nmean_loss = torch.mean(loss)\n```\n\nThis code is totally fine in NumPy or PyTorch, but it breaks in XLA! Why? Because the shape of `masked_outputs` and `masked_labels` depends on how many positions are masked - that makes it a **data-dependent shape.** However, just like for rule #1, we can often rewrite this code to yield exactly the same output without any data-dependent shapes.\n\n```python\nlabel_mask = tf.cast(labels >= 0, tf.float32)\nloss = compute_loss(outputs, labels)\nloss = loss * label_mask  # Set negative label positions to 0\nmean_loss = tf.reduce_sum(loss) / tf.reduce_sum(label_mask)\n```\n\nHere, we avoid data-dependent shapes by computing the loss for every position, but zeroing out the masked positions in both the numerator and denominator when we calculate the mean, which yields exactly the same result as the first block while maintaining XLA compatibility. Note that we use the same trick as in rule #1 - converting a `tf.bool` to `\n2,\tlabel_mask  # Set negative label positions to 0\nmean_loss = tf.reduce_sum(loss) / tf.reduce_sum(label_mask)\n```\n\nHere, we avoid data-dependent shapes by computing the loss for every position, but zeroing out the masked positions in both the numerator and denominator when we calculate the mean, which yields exactly the same result as the first block while maintaining XLA compatibility. Note that we use the same trick as in rule #1 - converting a `tf.bool` to `tf.float32` and using it as an indicator variable. This is a really useful trick, so remember it if you need to convert your own code to XLA!\n\n#### XLA Rule #3: XLA will need to recompile your model for every different input shape it sees\n\nThis is the big one. What this means is that if your input shapes are very variable, XLA will have to recompile your model over and over, which will create huge performance problems. This commonly arises in NLP models, where input texts have variable lengths after tokenization. In other modalities, static shapes are more common and this rule is much less of a problem.\n\nHow can you get around rule #3? The key is **padding** - if you pad all your inputs to the same length, and then use an `attention_mask`, you can get the same results as you\u2019d get from variable shapes, but without any XLA issues. However, excessive padding can cause severe slowdown too - if you pad all your samples to the maximum length in the whole dataset, you might end up with batches consisting endless padding tokens, which will waste a lot of compute and memory!\n\nThere isn\u2019t a perfect solution to this problem. However, you can try some tricks. One very useful trick is to **pad batches of samples up to a multiple of a number like 32 or 64 tokens.** This often only increases the number of tokens by a small amount, but it hugely reduces the number of unique input shapes, because every input shape now has to be a multiple of 32 or 64. Fewer unique input shapes means fewer XLA compilations!\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** Our tokenizers and data collators have methods that can help you here. You can use `padding=\"max_length\"` or `padding=\"longest\"` when calling tokenizers to get them to output padded data. Our tokenizers and data collators also have a `pad_to_multiple_of` argument that you can use to reduce the number of unique input shapes you see!\n\n</Tip>\n\n### How do I actually train my model on TPU?\n\nOnce your training is XLA-compatible and (if you\u2019re using TPU Node / Colab) your dataset has been prepared appropriately, running on TPU is surprisingly easy! All you really need to change in your code is to add a few lines to initialize your TPU, and to ensure that your model and dataset are created inside a `TPUStrategy` scope. Take a look at [our TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) to see this in action!\n\n### Summary\n\nThere was a lot in here, so let\u2019s summarize with a quick checklist you can follow when you want to get your model ready for TPU training:\n\n- Make sure your code follows the three rules of XLA\n- Compile your model with `jit_compile=True` on CPU/GPU and confirm that you can train it with XLA\n- Either load your dataset into memory or use a TPU-compatible dataset loading approach (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Migrate your code either to Colab (with accelerator set to \u201cTPU\u201d) or a TPU VM on Google Cloud\n- Add TPU initializer code (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Create your `TPUStrategy` and make sure dataset loading and model creation are inside the `strategy.scope()` (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Don\u2019t forget to take `jit_compile=True` out again when you move to TPU!\n- \ud83d\ude4f\ud83d\ude4f\ud83d\ude4f\ud83e\udd7a\ud83e\udd7a\ud83e\udd7a\n- Call model.fit()\n- You did it!\n3,\t!--Copyright 2023 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\nthe License. You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under the License is distributed on\nan \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n\n\u26a0\ufe0f Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be\nrendered properly in your Markdown viewer.\n\n-->\n\n# Training on TPU with TensorFlow\n\n<Tip>\n\nIf you don't need long explanations and just want TPU code samples to get started with, check out [our TPU example notebook!](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb)\n\n</Tip>\n\n### What is a TPU?\n\nA TPU is a **Tensor Processing Unit.** They are hardware designed by Google, which are used to greatly speed up the tensor computations within neural networks, much like GPUs. They can be used for both network training and inference. They are generally accessed through Google\u2019s cloud services, but small TPUs can also be accessed directly for free through Google Colab and Kaggle Kernels.\n\nBecause [all TensorFlow models in \ud83e\udd17 Transformers are Keras models](https://huggingface.co/blog/tensorflow-philosophy), most of the methods in this document are generally applicable to TPU training for any Keras model! However, there are a few points that are specific to the HuggingFace ecosystem (hug-o-system?) of Transformers and Datasets, and we\u2019ll make sure to flag them up when we get to them.\n\n### What kinds of TPU are available?\n\nNew users are often very confused by the range of TPUs, and the different ways to access them. The first key distinction to understand is the difference between **TPU Nodes** and **TPU VMs.**\n\nWhen you use a **TPU Node**, you are effectively indirectly accessing a remote TPU. You will need a separate VM, which will initialize your network and data pipeline and then forward them to the remote node. When you use a TPU on Google Colab, you are accessing it in the **TPU Node** style.\n\nUsing TPU Nodes can have some quite unexpected behaviour for people who aren\u2019t used to them! In particular, because the TPU is located on a physically different system to the machine you\u2019re running your Python code on, your data cannot be local to your machine - any data pipeline that loads from your machine\u2019s internal storage will totally fail! Instead, data must be stored in Google Cloud Storage where your data pipeline can still access it, even when the pipeline is running on the remote TPU node.\n\n<Tip>\n\nIf you can fit all your data in memory as `np.ndarray` or `tf.Tensor`, then you can `fit()` on that data even when using Colab or a TPU Node, without needing to upload it to Google Cloud Storage.\n\n</Tip>\n\n<Tip>\n\n**\ud83e\udd17Specific Hugging Face Tip\ud83e\udd17:** The methods `Dataset.to_tf_dataset()` and its higher-level wrapper `model.prepare_tf_dataset()` , which you will see throughout our TF code examples, will both fail on a TPU Node. The reason for this is that even though they create a `tf.data.Dataset` it is not a \u201cpure\u201d `tf.data` pipeline and uses `tf.numpy_function` or `Dataset.from_generator()` to stream data from the underlying HuggingFace `Dataset`. This HuggingFace `Dataset` is backed by data that is on a local disc and which the remote TPU Node will not be able to read.\n\n</Tip>\n\nThe second way to access a TPU is via a **TPU VM.** When using a TPU VM, you connect directly to the machine that the TPU is attached to, much like training on a GPU VM. TPU VMs are generally easier to work with, particularly when it comes to your data pipeline. All of the above warnings do not apply to TPU VMs!\n\nThis is an opinionated document, so here\u2019s our opinion: **Avoid using TPU Node if possible.** It is more confusing and more difficult to debug than TPU VMs. It is also likely to be unsupported in future - Google\u2019s latest TPU, TPUv4, can only be accessed as a TPU VM, which suggests that TPU Nodes are increasingly going to become a \u201clegacy\u201d access method. However, we understand that the only free TPU access is on Colab and Kaggle Kernels, which uses TPU Node - so we\u2019ll try to explain how to handle it if you have to! Check the [TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) for code samples that explain this in more detail.\n\n### What sizes of TPU are available?\n\nA single TPU (a v2-8/v3-8/v4-8) runs 8 replicas. TPUs exist in **pods** that can run hundreds or thousands of replicas simultaneously. When you use more than a single TPU but less than a whole pod (for example, a v3-32), your TPU fleet is referred to as a **pod slice.**\n\nWhen you access a free TPU via Colab, you generally get a single v2-8 TPU.\n\n### I keep hearing about this XLA thing. What\u2019s XLA, and how does it relate to TPUs?\n\nXLA is an optimizing compiler, used by both TensorFlow and JAX. In JAX it is the only compiler, whereas in TensorFlow it is optional\n    ```",
            "vector_context": "[Created at: 2025-03-24 13:17:32]\n(for example, a v3-32), your TPU fleet is referred to as a **pod slice.**\n\nWhen you access a free TPU via Colab, you generally get a single v2-8 TPU.\n\n### I keep hearing about this XLA thing. What\u2019s XLA, and how does it relate to TPUs?\n\nXLA is an optimizing compiler, used by both TensorFlow and JAX. In JAX it is the only compiler, whereas in TensorFlow it is optional (but mandatory on TPU!). The easiest way to enable it when training a Keras model is to pass the argument `jit_compile=True` to `model.compile()`. If you don\u2019t get any errors and performance is good, that\u2019s a great sign that you\u2019re ready to move to TPU!\n\nDebugging on TPU is generally a bit harder than on CPU/GPU, so we recommend getting your code running on CPU/GPU with XLA first before trying it on TPU. You don\u2019t have to train for long, of course - just for a few steps to make sure that your model and data pipeline are working like you expect them to.\n\n<Tip>\n\nXLA compiled code is usually faster - so even if you\u2019re not planning to run on TPU, adding `jit_compile=True` can improve your performance. Be sure to note the caveats below about XLA compatibility, though!\n\n</Tip>\n\n<Tip warning={true}>\n\n**Tip born of painful experience:** Although using `jit_compile=True` is a good way to get a speed boost and test if your CPU/GPU code is XLA-compatible, it can actually cause a lot of problems if you leave it in when actually training on TPU. XLA compilation will happen implicitly on TPU, so remember to remove that line before actually running your code on a TPU!\n\n</Tip>\n\n### How do I make my model XLA compatible?\n\nIn many cases, your code is probably XLA-compatible already! However, there are a few things that work in normal TensorFlow that don\u2019t work in XLA. We\u2019ve distilled them into three core rules below:\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** We\u2019ve put a lot of effort into rewriting our TensorFlow models and loss functions to be XLA-compatible. Our models and loss functions generally obey rule #1 and #2 by default, so you can skip over them if you\u2019re using `transformers` models. Don\u2019t forget about these rules when writing your own models and loss functions, though!\n\n</Tip>\n\n#### XLA Rule #1: Your code cannot have \u201cdata-dependent conditionals\u201d\n\nWhat that means is that any `if` statement cannot depend on values inside a `tf.Tensor`. For example, this code block cannot be compiled with XLA!\n\n```python\nif tf.reduce_sum(tensor) > 10:\n    tensor = tensor / 2.0\n```\n\nThis might seem very restrictive at first, but most neural net code doesn\u2019t need to do this. You can often get around this restriction by using `tf.cond` (see the documentation [here](https://www.tensorflow.org/api_docs/python/tf/cond)) or by removing the conditional and finding a clever math trick with indicator variables instead, like so:\n\n```python\nsum_over_10 = tf.cast(tf.reduce_sum(tensor) > 10, tf.float32)\ntensor = tensor / (1.0 + sum_over_10)\n```\n\nThis code has exactly the same effect as the code above, but by avoiding a conditional, we ensure it will compile with XLA without problems!\n\n#### XLA Rule #2: Your code cannot have \u201cdata-dependent shapes\u201d\n\nWhat this means is that the shape of all of the `tf.Tensor` objects in your code cannot depend on their values. For example, the function `tf.unique` cannot be compiled with XLA, because it returns a `tensor` containing one instance of each unique value in the input. The shape of this output will obviously be different depending on how repetitive the input `Tensor` was, and so XLA refuses to handle it!\n\nIn general, most neural network code obeys rule #2 by default. However, there are a few common cases where it becomes a problem. One very common one is when you use **label masking**, setting your labels to a negative value to indicate that those positions should be ignored when computing the loss. If you look at NumPy or PyTorch loss functions that support label masking, you will often see code like this that uses [boolean indexing](https://numpy.org/doc/stable/user/basics.indexing.html#boolean-array-indexing):\n\n```python\nlabel_mask = labels >= 0\nmasked_outputs = outputs[label_mask]\nmasked_labels = labels[label_mask]\nloss = compute_loss(masked_outputs, masked_labels)\nmean_loss = torch.mean(loss)\n```\n\nThis code is totally fine in NumPy or PyTorch, but it breaks in XLA! Why? Because the shape of `masked_outputs` and `masked_labels` depends on how many positions are masked - that makes it a **data-dependent shape.** However, just like for rule #1, we can often rewrite this code to yield exactly the same output without any data-dependent shapes.\n\n```python\nlabel_mask = tf.cast(labels >= 0, tf.float32)\nloss = compute_loss(outputs, labels)\nloss = loss * label_mask  # Set negative label positions to 0\nmean_loss = tf.reduce_sum(loss) / tf.reduce_sum(label_mask)\n```\n\nHere, we avoid data-dependent shapes by computing the loss for every position, but zeroing out the masked positions in both the numerator and denominator when we calculate the mean, which yields exactly the same result as the first block while maintaining XLA compatibility. Note that we use the same trick as in rule #1 - converting a `tf.bool` to `\n--New Chunk--\n[Created at: 2025-03-24 13:17:32]\n!--Copyright 2023 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\nthe License. You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under the License is distributed on\nan \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n\n\u26a0\ufe0f Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be\nrendered properly in your Markdown viewer.\n\n-->\n\n# Training on TPU with TensorFlow\n\n<Tip>\n\nIf you don't need long explanations and just want TPU code samples to get started with, check out [our TPU example notebook!](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb)\n\n</Tip>\n\n### What is a TPU?\n\nA TPU is a **Tensor Processing Unit.** They are hardware designed by Google, which are used to greatly speed up the tensor computations within neural networks, much like GPUs. They can be used for both network training and inference. They are generally accessed through Google\u2019s cloud services, but small TPUs can also be accessed directly for free through Google Colab and Kaggle Kernels.\n\nBecause [all TensorFlow models in \ud83e\udd17 Transformers are Keras models](https://huggingface.co/blog/tensorflow-philosophy), most of the methods in this document are generally applicable to TPU training for any Keras model! However, there are a few points that are specific to the HuggingFace ecosystem (hug-o-system?) of Transformers and Datasets, and we\u2019ll make sure to flag them up when we get to them.\n\n### What kinds of TPU are available?\n\nNew users are often very confused by the range of TPUs, and the different ways to access them. The first key distinction to understand is the difference between **TPU Nodes** and **TPU VMs.**\n\nWhen you use a **TPU Node**, you are effectively indirectly accessing a remote TPU. You will need a separate VM, which will initialize your network and data pipeline and then forward them to the remote node. When you use a TPU on Google Colab, you are accessing it in the **TPU Node** style.\n\nUsing TPU Nodes can have some quite unexpected behaviour for people who aren\u2019t used to them! In particular, because the TPU is located on a physically different system to the machine you\u2019re running your Python code on, your data cannot be local to your machine - any data pipeline that loads from your machine\u2019s internal storage will totally fail! Instead, data must be stored in Google Cloud Storage where your data pipeline can still access it, even when the pipeline is running on the remote TPU node.\n\n<Tip>\n\nIf you can fit all your data in memory as `np.ndarray` or `tf.Tensor`, then you can `fit()` on that data even when using Colab or a TPU Node, without needing to upload it to Google Cloud Storage.\n\n</Tip>\n\n<Tip>\n\n**\ud83e\udd17Specific Hugging Face Tip\ud83e\udd17:** The methods `Dataset.to_tf_dataset()` and its higher-level wrapper `model.prepare_tf_dataset()` , which you will see throughout our TF code examples, will both fail on a TPU Node. The reason for this is that even though they create a `tf.data.Dataset` it is not a \u201cpure\u201d `tf.data` pipeline and uses `tf.numpy_function` or `Dataset.from_generator()` to stream data from the underlying HuggingFace `Dataset`. This HuggingFace `Dataset` is backed by data that is on a local disc and which the remote TPU Node will not be able to read.\n\n</Tip>\n\nThe second way to access a TPU is via a **TPU VM.** When using a TPU VM, you connect directly to the machine that the TPU is attached to, much like training on a GPU VM. TPU VMs are generally easier to work with, particularly when it comes to your data pipeline. All of the above warnings do not apply to TPU VMs!\n\nThis is an opinionated document, so here\u2019s our opinion: **Avoid using TPU Node if possible.** It is more confusing and more difficult to debug than TPU VMs. It is also likely to be unsupported in future - Google\u2019s latest TPU, TPUv4, can only be accessed as a TPU VM, which suggests that TPU Nodes are increasingly going to become a \u201clegacy\u201d access method. However, we understand that the only free TPU access is on Colab and Kaggle Kernels, which uses TPU Node - so we\u2019ll try to explain how to handle it if you have to! Check the [TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) for code samples that explain this in more detail.\n\n### What sizes of TPU are available?\n\nA single TPU (a v2-8/v3-8/v4-8) runs 8 replicas. TPUs exist in **pods** that can run hundreds or thousands of replicas simultaneously. When you use more than a single TPU but less than a whole pod (for example, a v3-32), your TPU fleet is referred to as a **pod slice.**\n\nWhen you access a free TPU via Colab, you generally get a single v2-8 TPU.\n\n### I keep hearing about this XLA thing. What\u2019s XLA, and how does it relate to TPUs?\n\nXLA is an optimizing compiler, used by both TensorFlow and JAX. In JAX it is the only compiler, whereas in TensorFlow it is optional\n--New Chunk--\n[Created at: 2025-03-24 13:17:32]\nlabel_mask  # Set negative label positions to 0\nmean_loss = tf.reduce_sum(loss) / tf.reduce_sum(label_mask)\n```\n\nHere, we avoid data-dependent shapes by computing the loss for every position, but zeroing out the masked positions in both the numerator and denominator when we calculate the mean, which yields exactly the same result as the first block while maintaining XLA compatibility. Note that we use the same trick as in rule #1 - converting a `tf.bool` to `tf.float32` and using it as an indicator variable. This is a really useful trick, so remember it if you need to convert your own code to XLA!\n\n#### XLA Rule #3: XLA will need to recompile your model for every different input shape it sees\n\nThis is the big one. What this means is that if your input shapes are very variable, XLA will have to recompile your model over and over, which will create huge performance problems. This commonly arises in NLP models, where input texts have variable lengths after tokenization. In other modalities, static shapes are more common and this rule is much less of a problem.\n\nHow can you get around rule #3? The key is **padding** - if you pad all your inputs to the same length, and then use an `attention_mask`, you can get the same results as you\u2019d get from variable shapes, but without any XLA issues. However, excessive padding can cause severe slowdown too - if you pad all your samples to the maximum length in the whole dataset, you might end up with batches consisting endless padding tokens, which will waste a lot of compute and memory!\n\nThere isn\u2019t a perfect solution to this problem. However, you can try some tricks. One very useful trick is to **pad batches of samples up to a multiple of a number like 32 or 64 tokens.** This often only increases the number of tokens by a small amount, but it hugely reduces the number of unique input shapes, because every input shape now has to be a multiple of 32 or 64. Fewer unique input shapes means fewer XLA compilations!\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** Our tokenizers and data collators have methods that can help you here. You can use `padding=\"max_length\"` or `padding=\"longest\"` when calling tokenizers to get them to output padded data. Our tokenizers and data collators also have a `pad_to_multiple_of` argument that you can use to reduce the number of unique input shapes you see!\n\n</Tip>\n\n### How do I actually train my model on TPU?\n\nOnce your training is XLA-compatible and (if you\u2019re using TPU Node / Colab) your dataset has been prepared appropriately, running on TPU is surprisingly easy! All you really need to change in your code is to add a few lines to initialize your TPU, and to ensure that your model and dataset are created inside a `TPUStrategy` scope. Take a look at [our TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) to see this in action!\n\n### Summary\n\nThere was a lot in here, so let\u2019s summarize with a quick checklist you can follow when you want to get your model ready for TPU training:\n\n- Make sure your code follows the three rules of XLA\n- Compile your model with `jit_compile=True` on CPU/GPU and confirm that you can train it with XLA\n- Either load your dataset into memory or use a TPU-compatible dataset loading approach (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Migrate your code either to Colab (with accelerator set to \u201cTPU\u201d) or a TPU VM on Google Cloud\n- Add TPU initializer code (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Create your `TPUStrategy` and make sure dataset loading and model creation are inside the `strategy.scope()` (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Don\u2019t forget to take `jit_compile=True` out again when you move to TPU!\n- \ud83d\ude4f\ud83d\ude4f\ud83d\ude4f\ud83e\udd7a\ud83e\udd7a\ud83e\udd7a\n- Call model.fit()\n- You did it!"
        }
    },
    {
        "sample_idx": 60,
        "question": "What is required to make a model XLA compatible?",
        "answer": "Following three core rules: no data-dependent conditionals, no dynamic shapes, and no Python control flow.",
        "rag_answer": "### XLA Compatibility Requirements\n\nTo make a model XLA compatible, there are three core",
        "rag_score": null,
        "rag_feedback": null,
        "rag_context": {
            "kg_context": "-----Entities-----\n    ```csv\n    id,\tentity,\ttype,\tdescription,\trankcreated_at\n1,\tHuggingFace,organization,HuggingFace is a company that provides a range of AI models and tools, including the Transformers and Datasets ecosystem.<SEP>HuggingFace is an organization that provides pre-trained models and loss functions for machine learning.<SEP>HuggingFace is an organization that provides tools and resources for natural language processing and machine learning.,5,2025-03-24 13:18:20\n2,\tXLA,technology,XLA is a technology that compiles TensorFlow graphs into executable code for various platforms.<SEP>XLA is an optimizing compiler used by TensorFlow and JAX to improve performance.<SEP>XLA is an optimizing compiler, used by both TensorFlow and JAX to optimize computations.,6,2025-03-24 13:18:20\n3,\tTPU,technology,TPU is a Tensor Processing Unit, a hardware designed by Google to speed up tensor computations within neural networks.<SEP>TPU is a type of hardware accelerator designed for machine learning workloads.<SEP>TPU is a type of hardware accelerator used for machine learning computations.,4,2025-03-24 13:18:20\n4,\tKeras,category,Keras is a high-level neural networks API, used for building and training neural networks.<SEP>Keras is a machine learning framework that uses XLA for optimization.,2,2025-03-24 13:18:20\n5,\tTensorFlow,category,TensorFlow is a machine learning framework that uses XLA as an optimizing compiler.<SEP>TensorFlow is a software framework used for building and training neural networks.<SEP>TensorFlow is an open-source machine learning framework.,3,UNKNOWN\n6,\tGoogle,organization,Google is the company that designs and provides TPUs, which are used to speed up tensor computations within neural networks.,3,UNKNOWN\n7,\tTensor Processing Unit,category,Tensor Processing Unit is a hardware designed by Google to speed up tensor computations within neural networks.,0,UNKNOWN\n    ```\n    -----Relationships-----\n    ```csv\n    id,\tsource,\ttarget,\tdescription,\tkeywords,\tweight,\trank,\tcreated_at\n1,\tHuggingFace,XLA,HuggingFace provides pre-trained models and loss functions that are XLA-compatible.,compatibility, pre-trained models,8.0,11,2025-03-24 13:18:20\n2,\tTPU,XLA,XLA compiles TensorFlow graphs into executable code for TPU hardware.<SEP>XLA is used to optimize code for TPU hardware.,compilation, hardware acceleration<SEP>compiler, hardware optimization,36.0,10,2025-03-24 13:18:20\n3,\tKeras,XLA,Keras uses XLA for optimization.,compiler, performance optimization,8.0,8,2025-03-24 13:18:20\n4,\tTensorFlow,XLA,TensorFlow graphs can be compiled into executable code using XLA.<SEP>TensorFlow uses XLA as an optimizing compiler to improve performance.,compilation, framework support<SEP>compiler, performance optimization,23.0,9,UNKNOWN\n5,\tHuggingFace,TensorFlow,HuggingFace provides a range of AI models and tools, including the Transformers and Datasets ecosystem, which are built on top of TensorFlow.,ecosystem integration, AI models,18.0,8,UNKNOWN\n6,\tGoogle,TPU,Google designs and provides TPUs, which are used to speed up tensor computations within neural networks.,hardware design, acceleration,18.0,7,UNKNOWN\n7,\tColab,Google,Colab is a cloud-based platform provided by Google for data science and machine learning.,platform provision, cloud computing,16.0,6,UNKNOWN\n8,\tKeras,TensorFlow,TensorFlow uses Keras as a high-level neural networks API.,API integration, neural networks,16.0,5,UNKNOWN\n9,\tGoogle,Kaggle Kernels,Kaggle Kernels is a cloud-based platform provided by Google for data science and machine learning competitions.,platform provision, cloud computing,16.0,4,UNKNOWN\n    ```\n    -----Sources-----\n    ```csv\n    id,\tcontent\n1,\t(for example, a v3-32), your TPU fleet is referred to as a **pod slice.**\n\nWhen you access a free TPU via Colab, you generally get a single v2-8 TPU.\n\n### I keep hearing about this XLA thing. What\u2019s XLA, and how does it relate to TPUs?\n\nXLA is an optimizing compiler, used by both TensorFlow and JAX. In JAX it is the only compiler, whereas in TensorFlow it is optional (but mandatory on TPU!). The easiest way to enable it when training a Keras model is to pass the argument `jit_compile=True` to `model.compile()`. If you don\u2019t get any errors and performance is good, that\u2019s a great sign that you\u2019re ready to move to TPU!\n\nDebugging on TPU is generally a bit harder than on CPU/GPU, so we recommend getting your code running on CPU/GPU with XLA first before trying it on TPU. You don\u2019t have to train for long, of course - just for a few steps to make sure that your model and data pipeline are working like you expect them to.\n\n<Tip>\n\nXLA compiled code is usually faster - so even if you\u2019re not planning to run on TPU, adding `jit_compile=True` can improve your performance. Be sure to note the caveats below about XLA compatibility, though!\n\n</Tip>\n\n<Tip warning={true}>\n\n**Tip born of painful experience:** Although using `jit_compile=True` is a good way to get a speed boost and test if your CPU/GPU code is XLA-compatible, it can actually cause a lot of problems if you leave it in when actually training on TPU. XLA compilation will happen implicitly on TPU, so remember to remove that line before actually running your code on a TPU!\n\n</Tip>\n\n### How do I make my model XLA compatible?\n\nIn many cases, your code is probably XLA-compatible already! However, there are a few things that work in normal TensorFlow that don\u2019t work in XLA. We\u2019ve distilled them into three core rules below:\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** We\u2019ve put a lot of effort into rewriting our TensorFlow models and loss functions to be XLA-compatible. Our models and loss functions generally obey rule #1 and #2 by default, so you can skip over them if you\u2019re using `transformers` models. Don\u2019t forget about these rules when writing your own models and loss functions, though!\n\n</Tip>\n\n#### XLA Rule #1: Your code cannot have \u201cdata-dependent conditionals\u201d\n\nWhat that means is that any `if` statement cannot depend on values inside a `tf.Tensor`. For example, this code block cannot be compiled with XLA!\n\n```python\nif tf.reduce_sum(tensor) > 10:\n    tensor = tensor / 2.0\n```\n\nThis might seem very restrictive at first, but most neural net code doesn\u2019t need to do this. You can often get around this restriction by using `tf.cond` (see the documentation [here](https://www.tensorflow.org/api_docs/python/tf/cond)) or by removing the conditional and finding a clever math trick with indicator variables instead, like so:\n\n```python\nsum_over_10 = tf.cast(tf.reduce_sum(tensor) > 10, tf.float32)\ntensor = tensor / (1.0 + sum_over_10)\n```\n\nThis code has exactly the same effect as the code above, but by avoiding a conditional, we ensure it will compile with XLA without problems!\n\n#### XLA Rule #2: Your code cannot have \u201cdata-dependent shapes\u201d\n\nWhat this means is that the shape of all of the `tf.Tensor` objects in your code cannot depend on their values. For example, the function `tf.unique` cannot be compiled with XLA, because it returns a `tensor` containing one instance of each unique value in the input. The shape of this output will obviously be different depending on how repetitive the input `Tensor` was, and so XLA refuses to handle it!\n\nIn general, most neural network code obeys rule #2 by default. However, there are a few common cases where it becomes a problem. One very common one is when you use **label masking**, setting your labels to a negative value to indicate that those positions should be ignored when computing the loss. If you look at NumPy or PyTorch loss functions that support label masking, you will often see code like this that uses [boolean indexing](https://numpy.org/doc/stable/user/basics.indexing.html#boolean-array-indexing):\n\n```python\nlabel_mask = labels >= 0\nmasked_outputs = outputs[label_mask]\nmasked_labels = labels[label_mask]\nloss = compute_loss(masked_outputs, masked_labels)\nmean_loss = torch.mean(loss)\n```\n\nThis code is totally fine in NumPy or PyTorch, but it breaks in XLA! Why? Because the shape of `masked_outputs` and `masked_labels` depends on how many positions are masked - that makes it a **data-dependent shape.** However, just like for rule #1, we can often rewrite this code to yield exactly the same output without any data-dependent shapes.\n\n```python\nlabel_mask = tf.cast(labels >= 0, tf.float32)\nloss = compute_loss(outputs, labels)\nloss = loss * label_mask  # Set negative label positions to 0\nmean_loss = tf.reduce_sum(loss) / tf.reduce_sum(label_mask)\n```\n\nHere, we avoid data-dependent shapes by computing the loss for every position, but zeroing out the masked positions in both the numerator and denominator when we calculate the mean, which yields exactly the same result as the first block while maintaining XLA compatibility. Note that we use the same trick as in rule #1 - converting a `tf.bool` to `\n2,\tlabel_mask  # Set negative label positions to 0\nmean_loss = tf.reduce_sum(loss) / tf.reduce_sum(label_mask)\n```\n\nHere, we avoid data-dependent shapes by computing the loss for every position, but zeroing out the masked positions in both the numerator and denominator when we calculate the mean, which yields exactly the same result as the first block while maintaining XLA compatibility. Note that we use the same trick as in rule #1 - converting a `tf.bool` to `tf.float32` and using it as an indicator variable. This is a really useful trick, so remember it if you need to convert your own code to XLA!\n\n#### XLA Rule #3: XLA will need to recompile your model for every different input shape it sees\n\nThis is the big one. What this means is that if your input shapes are very variable, XLA will have to recompile your model over and over, which will create huge performance problems. This commonly arises in NLP models, where input texts have variable lengths after tokenization. In other modalities, static shapes are more common and this rule is much less of a problem.\n\nHow can you get around rule #3? The key is **padding** - if you pad all your inputs to the same length, and then use an `attention_mask`, you can get the same results as you\u2019d get from variable shapes, but without any XLA issues. However, excessive padding can cause severe slowdown too - if you pad all your samples to the maximum length in the whole dataset, you might end up with batches consisting endless padding tokens, which will waste a lot of compute and memory!\n\nThere isn\u2019t a perfect solution to this problem. However, you can try some tricks. One very useful trick is to **pad batches of samples up to a multiple of a number like 32 or 64 tokens.** This often only increases the number of tokens by a small amount, but it hugely reduces the number of unique input shapes, because every input shape now has to be a multiple of 32 or 64. Fewer unique input shapes means fewer XLA compilations!\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** Our tokenizers and data collators have methods that can help you here. You can use `padding=\"max_length\"` or `padding=\"longest\"` when calling tokenizers to get them to output padded data. Our tokenizers and data collators also have a `pad_to_multiple_of` argument that you can use to reduce the number of unique input shapes you see!\n\n</Tip>\n\n### How do I actually train my model on TPU?\n\nOnce your training is XLA-compatible and (if you\u2019re using TPU Node / Colab) your dataset has been prepared appropriately, running on TPU is surprisingly easy! All you really need to change in your code is to add a few lines to initialize your TPU, and to ensure that your model and dataset are created inside a `TPUStrategy` scope. Take a look at [our TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) to see this in action!\n\n### Summary\n\nThere was a lot in here, so let\u2019s summarize with a quick checklist you can follow when you want to get your model ready for TPU training:\n\n- Make sure your code follows the three rules of XLA\n- Compile your model with `jit_compile=True` on CPU/GPU and confirm that you can train it with XLA\n- Either load your dataset into memory or use a TPU-compatible dataset loading approach (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Migrate your code either to Colab (with accelerator set to \u201cTPU\u201d) or a TPU VM on Google Cloud\n- Add TPU initializer code (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Create your `TPUStrategy` and make sure dataset loading and model creation are inside the `strategy.scope()` (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Don\u2019t forget to take `jit_compile=True` out again when you move to TPU!\n- \ud83d\ude4f\ud83d\ude4f\ud83d\ude4f\ud83e\udd7a\ud83e\udd7a\ud83e\udd7a\n- Call model.fit()\n- You did it!\n3,\t!--Copyright 2023 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\nthe License. You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under the License is distributed on\nan \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n\n\u26a0\ufe0f Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be\nrendered properly in your Markdown viewer.\n\n-->\n\n# Training on TPU with TensorFlow\n\n<Tip>\n\nIf you don't need long explanations and just want TPU code samples to get started with, check out [our TPU example notebook!](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb)\n\n</Tip>\n\n### What is a TPU?\n\nA TPU is a **Tensor Processing Unit.** They are hardware designed by Google, which are used to greatly speed up the tensor computations within neural networks, much like GPUs. They can be used for both network training and inference. They are generally accessed through Google\u2019s cloud services, but small TPUs can also be accessed directly for free through Google Colab and Kaggle Kernels.\n\nBecause [all TensorFlow models in \ud83e\udd17 Transformers are Keras models](https://huggingface.co/blog/tensorflow-philosophy), most of the methods in this document are generally applicable to TPU training for any Keras model! However, there are a few points that are specific to the HuggingFace ecosystem (hug-o-system?) of Transformers and Datasets, and we\u2019ll make sure to flag them up when we get to them.\n\n### What kinds of TPU are available?\n\nNew users are often very confused by the range of TPUs, and the different ways to access them. The first key distinction to understand is the difference between **TPU Nodes** and **TPU VMs.**\n\nWhen you use a **TPU Node**, you are effectively indirectly accessing a remote TPU. You will need a separate VM, which will initialize your network and data pipeline and then forward them to the remote node. When you use a TPU on Google Colab, you are accessing it in the **TPU Node** style.\n\nUsing TPU Nodes can have some quite unexpected behaviour for people who aren\u2019t used to them! In particular, because the TPU is located on a physically different system to the machine you\u2019re running your Python code on, your data cannot be local to your machine - any data pipeline that loads from your machine\u2019s internal storage will totally fail! Instead, data must be stored in Google Cloud Storage where your data pipeline can still access it, even when the pipeline is running on the remote TPU node.\n\n<Tip>\n\nIf you can fit all your data in memory as `np.ndarray` or `tf.Tensor`, then you can `fit()` on that data even when using Colab or a TPU Node, without needing to upload it to Google Cloud Storage.\n\n</Tip>\n\n<Tip>\n\n**\ud83e\udd17Specific Hugging Face Tip\ud83e\udd17:** The methods `Dataset.to_tf_dataset()` and its higher-level wrapper `model.prepare_tf_dataset()` , which you will see throughout our TF code examples, will both fail on a TPU Node. The reason for this is that even though they create a `tf.data.Dataset` it is not a \u201cpure\u201d `tf.data` pipeline and uses `tf.numpy_function` or `Dataset.from_generator()` to stream data from the underlying HuggingFace `Dataset`. This HuggingFace `Dataset` is backed by data that is on a local disc and which the remote TPU Node will not be able to read.\n\n</Tip>\n\nThe second way to access a TPU is via a **TPU VM.** When using a TPU VM, you connect directly to the machine that the TPU is attached to, much like training on a GPU VM. TPU VMs are generally easier to work with, particularly when it comes to your data pipeline. All of the above warnings do not apply to TPU VMs!\n\nThis is an opinionated document, so here\u2019s our opinion: **Avoid using TPU Node if possible.** It is more confusing and more difficult to debug than TPU VMs. It is also likely to be unsupported in future - Google\u2019s latest TPU, TPUv4, can only be accessed as a TPU VM, which suggests that TPU Nodes are increasingly going to become a \u201clegacy\u201d access method. However, we understand that the only free TPU access is on Colab and Kaggle Kernels, which uses TPU Node - so we\u2019ll try to explain how to handle it if you have to! Check the [TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) for code samples that explain this in more detail.\n\n### What sizes of TPU are available?\n\nA single TPU (a v2-8/v3-8/v4-8) runs 8 replicas. TPUs exist in **pods** that can run hundreds or thousands of replicas simultaneously. When you use more than a single TPU but less than a whole pod (for example, a v3-32), your TPU fleet is referred to as a **pod slice.**\n\nWhen you access a free TPU via Colab, you generally get a single v2-8 TPU.\n\n### I keep hearing about this XLA thing. What\u2019s XLA, and how does it relate to TPUs?\n\nXLA is an optimizing compiler, used by both TensorFlow and JAX. In JAX it is the only compiler, whereas in TensorFlow it is optional\n    ```",
            "vector_context": "[Created at: 2025-03-24 13:17:32]\n(for example, a v3-32), your TPU fleet is referred to as a **pod slice.**\n\nWhen you access a free TPU via Colab, you generally get a single v2-8 TPU.\n\n### I keep hearing about this XLA thing. What\u2019s XLA, and how does it relate to TPUs?\n\nXLA is an optimizing compiler, used by both TensorFlow and JAX. In JAX it is the only compiler, whereas in TensorFlow it is optional (but mandatory on TPU!). The easiest way to enable it when training a Keras model is to pass the argument `jit_compile=True` to `model.compile()`. If you don\u2019t get any errors and performance is good, that\u2019s a great sign that you\u2019re ready to move to TPU!\n\nDebugging on TPU is generally a bit harder than on CPU/GPU, so we recommend getting your code running on CPU/GPU with XLA first before trying it on TPU. You don\u2019t have to train for long, of course - just for a few steps to make sure that your model and data pipeline are working like you expect them to.\n\n<Tip>\n\nXLA compiled code is usually faster - so even if you\u2019re not planning to run on TPU, adding `jit_compile=True` can improve your performance. Be sure to note the caveats below about XLA compatibility, though!\n\n</Tip>\n\n<Tip warning={true}>\n\n**Tip born of painful experience:** Although using `jit_compile=True` is a good way to get a speed boost and test if your CPU/GPU code is XLA-compatible, it can actually cause a lot of problems if you leave it in when actually training on TPU. XLA compilation will happen implicitly on TPU, so remember to remove that line before actually running your code on a TPU!\n\n</Tip>\n\n### How do I make my model XLA compatible?\n\nIn many cases, your code is probably XLA-compatible already! However, there are a few things that work in normal TensorFlow that don\u2019t work in XLA. We\u2019ve distilled them into three core rules below:\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** We\u2019ve put a lot of effort into rewriting our TensorFlow models and loss functions to be XLA-compatible. Our models and loss functions generally obey rule #1 and #2 by default, so you can skip over them if you\u2019re using `transformers` models. Don\u2019t forget about these rules when writing your own models and loss functions, though!\n\n</Tip>\n\n#### XLA Rule #1: Your code cannot have \u201cdata-dependent conditionals\u201d\n\nWhat that means is that any `if` statement cannot depend on values inside a `tf.Tensor`. For example, this code block cannot be compiled with XLA!\n\n```python\nif tf.reduce_sum(tensor) > 10:\n    tensor = tensor / 2.0\n```\n\nThis might seem very restrictive at first, but most neural net code doesn\u2019t need to do this. You can often get around this restriction by using `tf.cond` (see the documentation [here](https://www.tensorflow.org/api_docs/python/tf/cond)) or by removing the conditional and finding a clever math trick with indicator variables instead, like so:\n\n```python\nsum_over_10 = tf.cast(tf.reduce_sum(tensor) > 10, tf.float32)\ntensor = tensor / (1.0 + sum_over_10)\n```\n\nThis code has exactly the same effect as the code above, but by avoiding a conditional, we ensure it will compile with XLA without problems!\n\n#### XLA Rule #2: Your code cannot have \u201cdata-dependent shapes\u201d\n\nWhat this means is that the shape of all of the `tf.Tensor` objects in your code cannot depend on their values. For example, the function `tf.unique` cannot be compiled with XLA, because it returns a `tensor` containing one instance of each unique value in the input. The shape of this output will obviously be different depending on how repetitive the input `Tensor` was, and so XLA refuses to handle it!\n\nIn general, most neural network code obeys rule #2 by default. However, there are a few common cases where it becomes a problem. One very common one is when you use **label masking**, setting your labels to a negative value to indicate that those positions should be ignored when computing the loss. If you look at NumPy or PyTorch loss functions that support label masking, you will often see code like this that uses [boolean indexing](https://numpy.org/doc/stable/user/basics.indexing.html#boolean-array-indexing):\n\n```python\nlabel_mask = labels >= 0\nmasked_outputs = outputs[label_mask]\nmasked_labels = labels[label_mask]\nloss = compute_loss(masked_outputs, masked_labels)\nmean_loss = torch.mean(loss)\n```\n\nThis code is totally fine in NumPy or PyTorch, but it breaks in XLA! Why? Because the shape of `masked_outputs` and `masked_labels` depends on how many positions are masked - that makes it a **data-dependent shape.** However, just like for rule #1, we can often rewrite this code to yield exactly the same output without any data-dependent shapes.\n\n```python\nlabel_mask = tf.cast(labels >= 0, tf.float32)\nloss = compute_loss(outputs, labels)\nloss = loss * label_mask  # Set negative label positions to 0\nmean_loss = tf.reduce_sum(loss) / tf.reduce_sum(label_mask)\n```\n\nHere, we avoid data-dependent shapes by computing the loss for every position, but zeroing out the masked positions in both the numerator and denominator when we calculate the mean, which yields exactly the same result as the first block while maintaining XLA compatibility. Note that we use the same trick as in rule #1 - converting a `tf.bool` to `\n--New Chunk--\n[Created at: 2025-03-24 13:17:32]\nlabel_mask  # Set negative label positions to 0\nmean_loss = tf.reduce_sum(loss) / tf.reduce_sum(label_mask)\n```\n\nHere, we avoid data-dependent shapes by computing the loss for every position, but zeroing out the masked positions in both the numerator and denominator when we calculate the mean, which yields exactly the same result as the first block while maintaining XLA compatibility. Note that we use the same trick as in rule #1 - converting a `tf.bool` to `tf.float32` and using it as an indicator variable. This is a really useful trick, so remember it if you need to convert your own code to XLA!\n\n#### XLA Rule #3: XLA will need to recompile your model for every different input shape it sees\n\nThis is the big one. What this means is that if your input shapes are very variable, XLA will have to recompile your model over and over, which will create huge performance problems. This commonly arises in NLP models, where input texts have variable lengths after tokenization. In other modalities, static shapes are more common and this rule is much less of a problem.\n\nHow can you get around rule #3? The key is **padding** - if you pad all your inputs to the same length, and then use an `attention_mask`, you can get the same results as you\u2019d get from variable shapes, but without any XLA issues. However, excessive padding can cause severe slowdown too - if you pad all your samples to the maximum length in the whole dataset, you might end up with batches consisting endless padding tokens, which will waste a lot of compute and memory!\n\nThere isn\u2019t a perfect solution to this problem. However, you can try some tricks. One very useful trick is to **pad batches of samples up to a multiple of a number like 32 or 64 tokens.** This often only increases the number of tokens by a small amount, but it hugely reduces the number of unique input shapes, because every input shape now has to be a multiple of 32 or 64. Fewer unique input shapes means fewer XLA compilations!\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** Our tokenizers and data collators have methods that can help you here. You can use `padding=\"max_length\"` or `padding=\"longest\"` when calling tokenizers to get them to output padded data. Our tokenizers and data collators also have a `pad_to_multiple_of` argument that you can use to reduce the number of unique input shapes you see!\n\n</Tip>\n\n### How do I actually train my model on TPU?\n\nOnce your training is XLA-compatible and (if you\u2019re using TPU Node / Colab) your dataset has been prepared appropriately, running on TPU is surprisingly easy! All you really need to change in your code is to add a few lines to initialize your TPU, and to ensure that your model and dataset are created inside a `TPUStrategy` scope. Take a look at [our TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) to see this in action!\n\n### Summary\n\nThere was a lot in here, so let\u2019s summarize with a quick checklist you can follow when you want to get your model ready for TPU training:\n\n- Make sure your code follows the three rules of XLA\n- Compile your model with `jit_compile=True` on CPU/GPU and confirm that you can train it with XLA\n- Either load your dataset into memory or use a TPU-compatible dataset loading approach (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Migrate your code either to Colab (with accelerator set to \u201cTPU\u201d) or a TPU VM on Google Cloud\n- Add TPU initializer code (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Create your `TPUStrategy` and make sure dataset loading and model creation are inside the `strategy.scope()` (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Don\u2019t forget to take `jit_compile=True` out again when you move to TPU!\n- \ud83d\ude4f\ud83d\ude4f\ud83d\ude4f\ud83e\udd7a\ud83e\udd7a\ud83e\udd7a\n- Call model.fit()\n- You did it!\n--New Chunk--\n[Created at: 2025-03-24 13:17:32]\n!--Copyright 2023 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\nthe License. You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under the License is distributed on\nan \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n\n\u26a0\ufe0f Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be\nrendered properly in your Markdown viewer.\n\n-->\n\n# Training on TPU with TensorFlow\n\n<Tip>\n\nIf you don't need long explanations and just want TPU code samples to get started with, check out [our TPU example notebook!](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb)\n\n</Tip>\n\n### What is a TPU?\n\nA TPU is a **Tensor Processing Unit.** They are hardware designed by Google, which are used to greatly speed up the tensor computations within neural networks, much like GPUs. They can be used for both network training and inference. They are generally accessed through Google\u2019s cloud services, but small TPUs can also be accessed directly for free through Google Colab and Kaggle Kernels.\n\nBecause [all TensorFlow models in \ud83e\udd17 Transformers are Keras models](https://huggingface.co/blog/tensorflow-philosophy), most of the methods in this document are generally applicable to TPU training for any Keras model! However, there are a few points that are specific to the HuggingFace ecosystem (hug-o-system?) of Transformers and Datasets, and we\u2019ll make sure to flag them up when we get to them.\n\n### What kinds of TPU are available?\n\nNew users are often very confused by the range of TPUs, and the different ways to access them. The first key distinction to understand is the difference between **TPU Nodes** and **TPU VMs.**\n\nWhen you use a **TPU Node**, you are effectively indirectly accessing a remote TPU. You will need a separate VM, which will initialize your network and data pipeline and then forward them to the remote node. When you use a TPU on Google Colab, you are accessing it in the **TPU Node** style.\n\nUsing TPU Nodes can have some quite unexpected behaviour for people who aren\u2019t used to them! In particular, because the TPU is located on a physically different system to the machine you\u2019re running your Python code on, your data cannot be local to your machine - any data pipeline that loads from your machine\u2019s internal storage will totally fail! Instead, data must be stored in Google Cloud Storage where your data pipeline can still access it, even when the pipeline is running on the remote TPU node.\n\n<Tip>\n\nIf you can fit all your data in memory as `np.ndarray` or `tf.Tensor`, then you can `fit()` on that data even when using Colab or a TPU Node, without needing to upload it to Google Cloud Storage.\n\n</Tip>\n\n<Tip>\n\n**\ud83e\udd17Specific Hugging Face Tip\ud83e\udd17:** The methods `Dataset.to_tf_dataset()` and its higher-level wrapper `model.prepare_tf_dataset()` , which you will see throughout our TF code examples, will both fail on a TPU Node. The reason for this is that even though they create a `tf.data.Dataset` it is not a \u201cpure\u201d `tf.data` pipeline and uses `tf.numpy_function` or `Dataset.from_generator()` to stream data from the underlying HuggingFace `Dataset`. This HuggingFace `Dataset` is backed by data that is on a local disc and which the remote TPU Node will not be able to read.\n\n</Tip>\n\nThe second way to access a TPU is via a **TPU VM.** When using a TPU VM, you connect directly to the machine that the TPU is attached to, much like training on a GPU VM. TPU VMs are generally easier to work with, particularly when it comes to your data pipeline. All of the above warnings do not apply to TPU VMs!\n\nThis is an opinionated document, so here\u2019s our opinion: **Avoid using TPU Node if possible.** It is more confusing and more difficult to debug than TPU VMs. It is also likely to be unsupported in future - Google\u2019s latest TPU, TPUv4, can only be accessed as a TPU VM, which suggests that TPU Nodes are increasingly going to become a \u201clegacy\u201d access method. However, we understand that the only free TPU access is on Colab and Kaggle Kernels, which uses TPU Node - so we\u2019ll try to explain how to handle it if you have to! Check the [TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) for code samples that explain this in more detail.\n\n### What sizes of TPU are available?\n\nA single TPU (a v2-8/v3-8/v4-8) runs 8 replicas. TPUs exist in **pods** that can run hundreds or thousands of replicas simultaneously. When you use more than a single TPU but less than a whole pod (for example, a v3-32), your TPU fleet is referred to as a **pod slice.**\n\nWhen you access a free TPU via Colab, you generally get a single v2-8 TPU.\n\n### I keep hearing about this XLA thing. What\u2019s XLA, and how does it relate to TPUs?\n\nXLA is an optimizing compiler, used by both TensorFlow and JAX. In JAX it is the only compiler, whereas in TensorFlow it is optional"
        }
    },
    {
        "sample_idx": 61,
        "question": "What is meant by 'data-dependent conditionals' in XLA?",
        "answer": "Any if statement cannot depend on values inside a tf.Tensor.",
        "rag_answer": "In XLA (Accelerated Linear Algebra), \"data-dependent conditionals\" refer to `if` statements or conditional expressions that depend on the values of tensors or variables in the computation graph. In other words, the conditional statement's outcome is determined by the data flowing through the graph.\n\nXLA restricts the use of data-dependent conditionals because they can prevent the compiler from generating efficient, optimized code for the target hardware (e.g., TPUs or GPUs). This is because the conditional statements introduce uncertainty, making it harder for the compiler to predict the control flow and optimize the code.\n\nFor example, consider the following code:\n```python\nif tf.reduce_sum(tensor) > 10:\n    tensor = tensor / 2.0\n```\nIn this example, the conditional statement depends on the value of `tensor`, which is a data-dependent conditional. XLA will not compile this code because it cannot determine the outcome of the conditional statement at compile-time.\n\nTo work around this limitation, you can use alternative approaches, such as:\n\n1. Using `tf.cond` (a TensorFlow function that allows conditional execution) instead of Python `if` statements.\n2. Rewriting the code to avoid conditional statements, e.g., using arithmetic operations to achieve the desired result.\n\nBy avoiding data-dependent conditionals, you can ensure that your code is XLA-compatible and can be optimized for efficient execution on TPUs or GPUs.\n\nReferences:\n[KG] 1. XLA documentation: \"XLA: TensorFlow's Compiler\" - TensorFlow\n[DC] 2. Hugging Face documentation: \"Training on TPU with TensorFlow\" - Hugging Face",
        "rag_score": 5,
        "rag_feedback": "The system's response is completely correct, accurate, and factual. It provides a detailed explanation of data-dependent conditionals in XLA, including examples of code that cannot be compiled with XLA and how to rewrite them to make them XLA-compatible.",
        "rag_context": {
            "kg_context": "-----Entities-----\n    ```csv\n    id,\tentity,\ttype,\tdescription,\trankcreated_at\n1,\tTPU,technology,TPU is a Tensor Processing Unit, a hardware designed by Google to speed up tensor computations within neural networks.<SEP>TPU is a type of hardware accelerator designed for machine learning workloads.<SEP>TPU is a type of hardware accelerator used for machine learning computations.,4,2025-03-24 13:18:20\n2,\tXLA,technology,XLA is a technology that compiles TensorFlow graphs into executable code for various platforms.<SEP>XLA is an optimizing compiler used by TensorFlow and JAX to improve performance.<SEP>XLA is an optimizing compiler, used by both TensorFlow and JAX to optimize computations.,6,2025-03-24 13:18:20\n3,\tKeras,category,Keras is a high-level neural networks API, used for building and training neural networks.<SEP>Keras is a machine learning framework that uses XLA for optimization.,2,2025-03-24 13:18:20\n4,\tJAX,organization,JAX is a machine learning framework that uses XLA as its only compiler.<SEP>JAX is a software framework used for building and training neural networks.,1,2025-03-24 13:18:20\n5,\tTensorFlow,category,TensorFlow is a machine learning framework that uses XLA as an optimizing compiler.<SEP>TensorFlow is a software framework used for building and training neural networks.<SEP>TensorFlow is an open-source machine learning framework.,3,UNKNOWN\n6,\tjit_compile,concept,jit_compile is a technique for compiling TensorFlow graphs into executable code.,1,UNKNOWN\n7,\tGoogle,organization,Google is the company that designs and provides TPUs, which are used to speed up tensor computations within neural networks.,3,UNKNOWN\n    ```\n    -----Relationships-----\n    ```csv\n    id,\tsource,\ttarget,\tdescription,\tkeywords,\tweight,\trank,\tcreated_at\n1,\tTPU,XLA,XLA compiles TensorFlow graphs into executable code for TPU hardware.<SEP>XLA is used to optimize code for TPU hardware.,compilation, hardware acceleration<SEP>compiler, hardware optimization,36.0,10,2025-03-24 13:18:20\n2,\tKeras,XLA,Keras uses XLA for optimization.,compiler, performance optimization,8.0,8,2025-03-24 13:18:20\n3,\tJAX,XLA,JAX uses XLA as its only compiler.,compiler, framework integration,18.0,7,2025-03-24 13:18:20\n4,\tTensorFlow,XLA,TensorFlow graphs can be compiled into executable code using XLA.<SEP>TensorFlow uses XLA as an optimizing compiler to improve performance.,compilation, framework support<SEP>compiler, performance optimization,23.0,9,UNKNOWN\n5,\tHuggingFace,TensorFlow,HuggingFace provides a range of AI models and tools, including the Transformers and Datasets ecosystem, which are built on top of TensorFlow.,ecosystem integration, AI models,18.0,8,UNKNOWN\n6,\tGoogle,TPU,Google designs and provides TPUs, which are used to speed up tensor computations within neural networks.,hardware design, acceleration,18.0,7,UNKNOWN\n7,\tXLA,jit_compile,jit_compile is a technique used in XLA to compile TensorFlow graphs into executable code.,compilation technique, XLA support,3.0,7,UNKNOWN\n8,\tColab,Google,Colab is a cloud-based platform provided by Google for data science and machine learning.,platform provision, cloud computing,16.0,6,UNKNOWN\n9,\tKeras,TensorFlow,TensorFlow uses Keras as a high-level neural networks API.,API integration, neural networks,16.0,5,UNKNOWN\n10,\tGoogle,Kaggle Kernels,Kaggle Kernels is a cloud-based platform provided by Google for data science and machine learning competitions.,platform provision, cloud computing,16.0,4,UNKNOWN\n    ```\n    -----Sources-----\n    ```csv\n    id,\tcontent\n1,\t(for example, a v3-32), your TPU fleet is referred to as a **pod slice.**\n\nWhen you access a free TPU via Colab, you generally get a single v2-8 TPU.\n\n### I keep hearing about this XLA thing. What\u2019s XLA, and how does it relate to TPUs?\n\nXLA is an optimizing compiler, used by both TensorFlow and JAX. In JAX it is the only compiler, whereas in TensorFlow it is optional (but mandatory on TPU!). The easiest way to enable it when training a Keras model is to pass the argument `jit_compile=True` to `model.compile()`. If you don\u2019t get any errors and performance is good, that\u2019s a great sign that you\u2019re ready to move to TPU!\n\nDebugging on TPU is generally a bit harder than on CPU/GPU, so we recommend getting your code running on CPU/GPU with XLA first before trying it on TPU. You don\u2019t have to train for long, of course - just for a few steps to make sure that your model and data pipeline are working like you expect them to.\n\n<Tip>\n\nXLA compiled code is usually faster - so even if you\u2019re not planning to run on TPU, adding `jit_compile=True` can improve your performance. Be sure to note the caveats below about XLA compatibility, though!\n\n</Tip>\n\n<Tip warning={true}>\n\n**Tip born of painful experience:** Although using `jit_compile=True` is a good way to get a speed boost and test if your CPU/GPU code is XLA-compatible, it can actually cause a lot of problems if you leave it in when actually training on TPU. XLA compilation will happen implicitly on TPU, so remember to remove that line before actually running your code on a TPU!\n\n</Tip>\n\n### How do I make my model XLA compatible?\n\nIn many cases, your code is probably XLA-compatible already! However, there are a few things that work in normal TensorFlow that don\u2019t work in XLA. We\u2019ve distilled them into three core rules below:\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** We\u2019ve put a lot of effort into rewriting our TensorFlow models and loss functions to be XLA-compatible. Our models and loss functions generally obey rule #1 and #2 by default, so you can skip over them if you\u2019re using `transformers` models. Don\u2019t forget about these rules when writing your own models and loss functions, though!\n\n</Tip>\n\n#### XLA Rule #1: Your code cannot have \u201cdata-dependent conditionals\u201d\n\nWhat that means is that any `if` statement cannot depend on values inside a `tf.Tensor`. For example, this code block cannot be compiled with XLA!\n\n```python\nif tf.reduce_sum(tensor) > 10:\n    tensor = tensor / 2.0\n```\n\nThis might seem very restrictive at first, but most neural net code doesn\u2019t need to do this. You can often get around this restriction by using `tf.cond` (see the documentation [here](https://www.tensorflow.org/api_docs/python/tf/cond)) or by removing the conditional and finding a clever math trick with indicator variables instead, like so:\n\n```python\nsum_over_10 = tf.cast(tf.reduce_sum(tensor) > 10, tf.float32)\ntensor = tensor / (1.0 + sum_over_10)\n```\n\nThis code has exactly the same effect as the code above, but by avoiding a conditional, we ensure it will compile with XLA without problems!\n\n#### XLA Rule #2: Your code cannot have \u201cdata-dependent shapes\u201d\n\nWhat this means is that the shape of all of the `tf.Tensor` objects in your code cannot depend on their values. For example, the function `tf.unique` cannot be compiled with XLA, because it returns a `tensor` containing one instance of each unique value in the input. The shape of this output will obviously be different depending on how repetitive the input `Tensor` was, and so XLA refuses to handle it!\n\nIn general, most neural network code obeys rule #2 by default. However, there are a few common cases where it becomes a problem. One very common one is when you use **label masking**, setting your labels to a negative value to indicate that those positions should be ignored when computing the loss. If you look at NumPy or PyTorch loss functions that support label masking, you will often see code like this that uses [boolean indexing](https://numpy.org/doc/stable/user/basics.indexing.html#boolean-array-indexing):\n\n```python\nlabel_mask = labels >= 0\nmasked_outputs = outputs[label_mask]\nmasked_labels = labels[label_mask]\nloss = compute_loss(masked_outputs, masked_labels)\nmean_loss = torch.mean(loss)\n```\n\nThis code is totally fine in NumPy or PyTorch, but it breaks in XLA! Why? Because the shape of `masked_outputs` and `masked_labels` depends on how many positions are masked - that makes it a **data-dependent shape.** However, just like for rule #1, we can often rewrite this code to yield exactly the same output without any data-dependent shapes.\n\n```python\nlabel_mask = tf.cast(labels >= 0, tf.float32)\nloss = compute_loss(outputs, labels)\nloss = loss * label_mask  # Set negative label positions to 0\nmean_loss = tf.reduce_sum(loss) / tf.reduce_sum(label_mask)\n```\n\nHere, we avoid data-dependent shapes by computing the loss for every position, but zeroing out the masked positions in both the numerator and denominator when we calculate the mean, which yields exactly the same result as the first block while maintaining XLA compatibility. Note that we use the same trick as in rule #1 - converting a `tf.bool` to `\n2,\tlabel_mask  # Set negative label positions to 0\nmean_loss = tf.reduce_sum(loss) / tf.reduce_sum(label_mask)\n```\n\nHere, we avoid data-dependent shapes by computing the loss for every position, but zeroing out the masked positions in both the numerator and denominator when we calculate the mean, which yields exactly the same result as the first block while maintaining XLA compatibility. Note that we use the same trick as in rule #1 - converting a `tf.bool` to `tf.float32` and using it as an indicator variable. This is a really useful trick, so remember it if you need to convert your own code to XLA!\n\n#### XLA Rule #3: XLA will need to recompile your model for every different input shape it sees\n\nThis is the big one. What this means is that if your input shapes are very variable, XLA will have to recompile your model over and over, which will create huge performance problems. This commonly arises in NLP models, where input texts have variable lengths after tokenization. In other modalities, static shapes are more common and this rule is much less of a problem.\n\nHow can you get around rule #3? The key is **padding** - if you pad all your inputs to the same length, and then use an `attention_mask`, you can get the same results as you\u2019d get from variable shapes, but without any XLA issues. However, excessive padding can cause severe slowdown too - if you pad all your samples to the maximum length in the whole dataset, you might end up with batches consisting endless padding tokens, which will waste a lot of compute and memory!\n\nThere isn\u2019t a perfect solution to this problem. However, you can try some tricks. One very useful trick is to **pad batches of samples up to a multiple of a number like 32 or 64 tokens.** This often only increases the number of tokens by a small amount, but it hugely reduces the number of unique input shapes, because every input shape now has to be a multiple of 32 or 64. Fewer unique input shapes means fewer XLA compilations!\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** Our tokenizers and data collators have methods that can help you here. You can use `padding=\"max_length\"` or `padding=\"longest\"` when calling tokenizers to get them to output padded data. Our tokenizers and data collators also have a `pad_to_multiple_of` argument that you can use to reduce the number of unique input shapes you see!\n\n</Tip>\n\n### How do I actually train my model on TPU?\n\nOnce your training is XLA-compatible and (if you\u2019re using TPU Node / Colab) your dataset has been prepared appropriately, running on TPU is surprisingly easy! All you really need to change in your code is to add a few lines to initialize your TPU, and to ensure that your model and dataset are created inside a `TPUStrategy` scope. Take a look at [our TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) to see this in action!\n\n### Summary\n\nThere was a lot in here, so let\u2019s summarize with a quick checklist you can follow when you want to get your model ready for TPU training:\n\n- Make sure your code follows the three rules of XLA\n- Compile your model with `jit_compile=True` on CPU/GPU and confirm that you can train it with XLA\n- Either load your dataset into memory or use a TPU-compatible dataset loading approach (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Migrate your code either to Colab (with accelerator set to \u201cTPU\u201d) or a TPU VM on Google Cloud\n- Add TPU initializer code (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Create your `TPUStrategy` and make sure dataset loading and model creation are inside the `strategy.scope()` (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Don\u2019t forget to take `jit_compile=True` out again when you move to TPU!\n- \ud83d\ude4f\ud83d\ude4f\ud83d\ude4f\ud83e\udd7a\ud83e\udd7a\ud83e\udd7a\n- Call model.fit()\n- You did it!\n3,\t!--Copyright 2023 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\nthe License. You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under the License is distributed on\nan \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n\n\u26a0\ufe0f Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be\nrendered properly in your Markdown viewer.\n\n-->\n\n# Training on TPU with TensorFlow\n\n<Tip>\n\nIf you don't need long explanations and just want TPU code samples to get started with, check out [our TPU example notebook!](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb)\n\n</Tip>\n\n### What is a TPU?\n\nA TPU is a **Tensor Processing Unit.** They are hardware designed by Google, which are used to greatly speed up the tensor computations within neural networks, much like GPUs. They can be used for both network training and inference. They are generally accessed through Google\u2019s cloud services, but small TPUs can also be accessed directly for free through Google Colab and Kaggle Kernels.\n\nBecause [all TensorFlow models in \ud83e\udd17 Transformers are Keras models](https://huggingface.co/blog/tensorflow-philosophy), most of the methods in this document are generally applicable to TPU training for any Keras model! However, there are a few points that are specific to the HuggingFace ecosystem (hug-o-system?) of Transformers and Datasets, and we\u2019ll make sure to flag them up when we get to them.\n\n### What kinds of TPU are available?\n\nNew users are often very confused by the range of TPUs, and the different ways to access them. The first key distinction to understand is the difference between **TPU Nodes** and **TPU VMs.**\n\nWhen you use a **TPU Node**, you are effectively indirectly accessing a remote TPU. You will need a separate VM, which will initialize your network and data pipeline and then forward them to the remote node. When you use a TPU on Google Colab, you are accessing it in the **TPU Node** style.\n\nUsing TPU Nodes can have some quite unexpected behaviour for people who aren\u2019t used to them! In particular, because the TPU is located on a physically different system to the machine you\u2019re running your Python code on, your data cannot be local to your machine - any data pipeline that loads from your machine\u2019s internal storage will totally fail! Instead, data must be stored in Google Cloud Storage where your data pipeline can still access it, even when the pipeline is running on the remote TPU node.\n\n<Tip>\n\nIf you can fit all your data in memory as `np.ndarray` or `tf.Tensor`, then you can `fit()` on that data even when using Colab or a TPU Node, without needing to upload it to Google Cloud Storage.\n\n</Tip>\n\n<Tip>\n\n**\ud83e\udd17Specific Hugging Face Tip\ud83e\udd17:** The methods `Dataset.to_tf_dataset()` and its higher-level wrapper `model.prepare_tf_dataset()` , which you will see throughout our TF code examples, will both fail on a TPU Node. The reason for this is that even though they create a `tf.data.Dataset` it is not a \u201cpure\u201d `tf.data` pipeline and uses `tf.numpy_function` or `Dataset.from_generator()` to stream data from the underlying HuggingFace `Dataset`. This HuggingFace `Dataset` is backed by data that is on a local disc and which the remote TPU Node will not be able to read.\n\n</Tip>\n\nThe second way to access a TPU is via a **TPU VM.** When using a TPU VM, you connect directly to the machine that the TPU is attached to, much like training on a GPU VM. TPU VMs are generally easier to work with, particularly when it comes to your data pipeline. All of the above warnings do not apply to TPU VMs!\n\nThis is an opinionated document, so here\u2019s our opinion: **Avoid using TPU Node if possible.** It is more confusing and more difficult to debug than TPU VMs. It is also likely to be unsupported in future - Google\u2019s latest TPU, TPUv4, can only be accessed as a TPU VM, which suggests that TPU Nodes are increasingly going to become a \u201clegacy\u201d access method. However, we understand that the only free TPU access is on Colab and Kaggle Kernels, which uses TPU Node - so we\u2019ll try to explain how to handle it if you have to! Check the [TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) for code samples that explain this in more detail.\n\n### What sizes of TPU are available?\n\nA single TPU (a v2-8/v3-8/v4-8) runs 8 replicas. TPUs exist in **pods** that can run hundreds or thousands of replicas simultaneously. When you use more than a single TPU but less than a whole pod (for example, a v3-32), your TPU fleet is referred to as a **pod slice.**\n\nWhen you access a free TPU via Colab, you generally get a single v2-8 TPU.\n\n### I keep hearing about this XLA thing. What\u2019s XLA, and how does it relate to TPUs?\n\nXLA is an optimizing compiler, used by both TensorFlow and JAX. In JAX it is the only compiler, whereas in TensorFlow it is optional\n    ```",
            "vector_context": "[Created at: 2025-03-24 13:17:32]\n(for example, a v3-32), your TPU fleet is referred to as a **pod slice.**\n\nWhen you access a free TPU via Colab, you generally get a single v2-8 TPU.\n\n### I keep hearing about this XLA thing. What\u2019s XLA, and how does it relate to TPUs?\n\nXLA is an optimizing compiler, used by both TensorFlow and JAX. In JAX it is the only compiler, whereas in TensorFlow it is optional (but mandatory on TPU!). The easiest way to enable it when training a Keras model is to pass the argument `jit_compile=True` to `model.compile()`. If you don\u2019t get any errors and performance is good, that\u2019s a great sign that you\u2019re ready to move to TPU!\n\nDebugging on TPU is generally a bit harder than on CPU/GPU, so we recommend getting your code running on CPU/GPU with XLA first before trying it on TPU. You don\u2019t have to train for long, of course - just for a few steps to make sure that your model and data pipeline are working like you expect them to.\n\n<Tip>\n\nXLA compiled code is usually faster - so even if you\u2019re not planning to run on TPU, adding `jit_compile=True` can improve your performance. Be sure to note the caveats below about XLA compatibility, though!\n\n</Tip>\n\n<Tip warning={true}>\n\n**Tip born of painful experience:** Although using `jit_compile=True` is a good way to get a speed boost and test if your CPU/GPU code is XLA-compatible, it can actually cause a lot of problems if you leave it in when actually training on TPU. XLA compilation will happen implicitly on TPU, so remember to remove that line before actually running your code on a TPU!\n\n</Tip>\n\n### How do I make my model XLA compatible?\n\nIn many cases, your code is probably XLA-compatible already! However, there are a few things that work in normal TensorFlow that don\u2019t work in XLA. We\u2019ve distilled them into three core rules below:\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** We\u2019ve put a lot of effort into rewriting our TensorFlow models and loss functions to be XLA-compatible. Our models and loss functions generally obey rule #1 and #2 by default, so you can skip over them if you\u2019re using `transformers` models. Don\u2019t forget about these rules when writing your own models and loss functions, though!\n\n</Tip>\n\n#### XLA Rule #1: Your code cannot have \u201cdata-dependent conditionals\u201d\n\nWhat that means is that any `if` statement cannot depend on values inside a `tf.Tensor`. For example, this code block cannot be compiled with XLA!\n\n```python\nif tf.reduce_sum(tensor) > 10:\n    tensor = tensor / 2.0\n```\n\nThis might seem very restrictive at first, but most neural net code doesn\u2019t need to do this. You can often get around this restriction by using `tf.cond` (see the documentation [here](https://www.tensorflow.org/api_docs/python/tf/cond)) or by removing the conditional and finding a clever math trick with indicator variables instead, like so:\n\n```python\nsum_over_10 = tf.cast(tf.reduce_sum(tensor) > 10, tf.float32)\ntensor = tensor / (1.0 + sum_over_10)\n```\n\nThis code has exactly the same effect as the code above, but by avoiding a conditional, we ensure it will compile with XLA without problems!\n\n#### XLA Rule #2: Your code cannot have \u201cdata-dependent shapes\u201d\n\nWhat this means is that the shape of all of the `tf.Tensor` objects in your code cannot depend on their values. For example, the function `tf.unique` cannot be compiled with XLA, because it returns a `tensor` containing one instance of each unique value in the input. The shape of this output will obviously be different depending on how repetitive the input `Tensor` was, and so XLA refuses to handle it!\n\nIn general, most neural network code obeys rule #2 by default. However, there are a few common cases where it becomes a problem. One very common one is when you use **label masking**, setting your labels to a negative value to indicate that those positions should be ignored when computing the loss. If you look at NumPy or PyTorch loss functions that support label masking, you will often see code like this that uses [boolean indexing](https://numpy.org/doc/stable/user/basics.indexing.html#boolean-array-indexing):\n\n```python\nlabel_mask = labels >= 0\nmasked_outputs = outputs[label_mask]\nmasked_labels = labels[label_mask]\nloss = compute_loss(masked_outputs, masked_labels)\nmean_loss = torch.mean(loss)\n```\n\nThis code is totally fine in NumPy or PyTorch, but it breaks in XLA! Why? Because the shape of `masked_outputs` and `masked_labels` depends on how many positions are masked - that makes it a **data-dependent shape.** However, just like for rule #1, we can often rewrite this code to yield exactly the same output without any data-dependent shapes.\n\n```python\nlabel_mask = tf.cast(labels >= 0, tf.float32)\nloss = compute_loss(outputs, labels)\nloss = loss * label_mask  # Set negative label positions to 0\nmean_loss = tf.reduce_sum(loss) / tf.reduce_sum(label_mask)\n```\n\nHere, we avoid data-dependent shapes by computing the loss for every position, but zeroing out the masked positions in both the numerator and denominator when we calculate the mean, which yields exactly the same result as the first block while maintaining XLA compatibility. Note that we use the same trick as in rule #1 - converting a `tf.bool` to `\n--New Chunk--\n[Created at: 2025-03-24 13:17:32]\nlabel_mask  # Set negative label positions to 0\nmean_loss = tf.reduce_sum(loss) / tf.reduce_sum(label_mask)\n```\n\nHere, we avoid data-dependent shapes by computing the loss for every position, but zeroing out the masked positions in both the numerator and denominator when we calculate the mean, which yields exactly the same result as the first block while maintaining XLA compatibility. Note that we use the same trick as in rule #1 - converting a `tf.bool` to `tf.float32` and using it as an indicator variable. This is a really useful trick, so remember it if you need to convert your own code to XLA!\n\n#### XLA Rule #3: XLA will need to recompile your model for every different input shape it sees\n\nThis is the big one. What this means is that if your input shapes are very variable, XLA will have to recompile your model over and over, which will create huge performance problems. This commonly arises in NLP models, where input texts have variable lengths after tokenization. In other modalities, static shapes are more common and this rule is much less of a problem.\n\nHow can you get around rule #3? The key is **padding** - if you pad all your inputs to the same length, and then use an `attention_mask`, you can get the same results as you\u2019d get from variable shapes, but without any XLA issues. However, excessive padding can cause severe slowdown too - if you pad all your samples to the maximum length in the whole dataset, you might end up with batches consisting endless padding tokens, which will waste a lot of compute and memory!\n\nThere isn\u2019t a perfect solution to this problem. However, you can try some tricks. One very useful trick is to **pad batches of samples up to a multiple of a number like 32 or 64 tokens.** This often only increases the number of tokens by a small amount, but it hugely reduces the number of unique input shapes, because every input shape now has to be a multiple of 32 or 64. Fewer unique input shapes means fewer XLA compilations!\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** Our tokenizers and data collators have methods that can help you here. You can use `padding=\"max_length\"` or `padding=\"longest\"` when calling tokenizers to get them to output padded data. Our tokenizers and data collators also have a `pad_to_multiple_of` argument that you can use to reduce the number of unique input shapes you see!\n\n</Tip>\n\n### How do I actually train my model on TPU?\n\nOnce your training is XLA-compatible and (if you\u2019re using TPU Node / Colab) your dataset has been prepared appropriately, running on TPU is surprisingly easy! All you really need to change in your code is to add a few lines to initialize your TPU, and to ensure that your model and dataset are created inside a `TPUStrategy` scope. Take a look at [our TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) to see this in action!\n\n### Summary\n\nThere was a lot in here, so let\u2019s summarize with a quick checklist you can follow when you want to get your model ready for TPU training:\n\n- Make sure your code follows the three rules of XLA\n- Compile your model with `jit_compile=True` on CPU/GPU and confirm that you can train it with XLA\n- Either load your dataset into memory or use a TPU-compatible dataset loading approach (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Migrate your code either to Colab (with accelerator set to \u201cTPU\u201d) or a TPU VM on Google Cloud\n- Add TPU initializer code (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Create your `TPUStrategy` and make sure dataset loading and model creation are inside the `strategy.scope()` (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Don\u2019t forget to take `jit_compile=True` out again when you move to TPU!\n- \ud83d\ude4f\ud83d\ude4f\ud83d\ude4f\ud83e\udd7a\ud83e\udd7a\ud83e\udd7a\n- Call model.fit()\n- You did it!\n--New Chunk--\n[Created at: 2025-03-24 13:16:13]\n=predictions, references=references)\n>>> results\n{'exact_match': 100.0, 'f1': 100.0}\n```\n\nYou can find examples of dataset structures by consulting the \"Dataset Preview\" function or the dataset card for a given dataset, and you can see how to use its dedicated evaluation function based on the metric card."
        }
    },
    {
        "context": "```python\nif tf.reduce_sum(tensor) > 10:\n    tensor = tensor / 2.0\n```\n\nThis might seem very restrictive at first, but most neural net code doesn\u2019t need to do this. You can often get around this restriction by using `tf.cond` (see the documentation [here](https://www.tensorflow.org/api_docs/python/tf/cond)) or by removing the conditional and finding a clever math trick with indicator variables instead, like so:\n\n```python\nsum_over_10 = tf.cast(tf.reduce_sum(tensor) > 10, tf.float32)\ntensor = tensor / (1.0 + sum_over_10)\n```\n\nThis code has exactly the same effect as the code above, but by avoiding a conditional, we ensure it will compile with XLA without problems!\n\n#### XLA Rule #2: Your code cannot have \u201cdata-dependent shapes\u201d\n\nWhat this means is that the shape of all of the `tf.Tensor` objects in your code cannot depend on their values. For example, the function `tf.unique` cannot be compiled with XLA, because it returns a `tensor` containing one instance of each unique value in the input. The shape of this output will obviously be different depending on how repetitive the input `Tensor` was, and so XLA refuses to handle it!\n\nIn general, most neural network code obeys rule #2 by default. However, there are a few common cases where it becomes a problem. One very common one is when you use **label masking**, setting your labels to a negative value to indicate that those positions should be ignored when computing the loss. If you look at NumPy or PyTorch loss functions that support label masking, you will often see code like this that uses [boolean indexing](https://numpy.org/doc/stable/user/basics.indexing.html#boolean-array-indexing):\n\n```python\nlabel_mask = labels >= 0\nmasked_outputs = outputs[label_mask]\nmasked_labels = labels[label_mask]\nloss = compute_loss(masked_outputs, masked_labels)\nmean_loss = torch.mean(loss)\n```",
        "question": "What is the alternative to using a conditional statement in TensorFlow to avoid XLA compilation problems?",
        "answer": "Using tf.cond or removing the conditional and finding a clever math trick with indicator variables.",
        "source_doc": "huggingface/transformers/blob/main/docs/source/en/perf_train_tpu_tf.md",
        "rag_answer": null,
        "rag_context": null,
        "rag_score": null,
        "rag_feedback": null
    },
    {
        "sample_idx": 63,
        "question": "What is XLA Rule #2?",
        "answer": "Your code cannot have 'data-dependent shapes'.",
        "rag_answer": "**XLA Rule #2: Your code cannot have \u201cdata-dependent shapes\u201d**\n\nWhat this means is that the shape of all of the `tf.Tensor` objects in your code cannot depend on their values. For example, the function `tf.unique` cannot be compiled with XLA, because it returns a `tensor` containing one instance of each unique value in the input. The shape of this output will obviously be different depending on how repetitive the input `Tensor` was, and so XLA refuses to handle",
        "rag_score": null,
        "rag_feedback": null,
        "rag_context": {
            "kg_context": "-----Entities-----\n    ```csv\n    id,\tentity,\ttype,\tdescription,\trankcreated_at\n1,\tHuggingFace,organization,HuggingFace is a company that provides a range of AI models and tools, including the Transformers and Datasets ecosystem.<SEP>HuggingFace is an organization that provides pre-trained models and loss functions for machine learning.<SEP>HuggingFace is an organization that provides tools and resources for natural language processing and machine learning.,5,2025-03-24 13:18:20\n2,\tXLA,technology,XLA is a technology that compiles TensorFlow graphs into executable code for various platforms.<SEP>XLA is an optimizing compiler used by TensorFlow and JAX to improve performance.<SEP>XLA is an optimizing compiler, used by both TensorFlow and JAX to optimize computations.,6,2025-03-24 13:18:20\n3,\tKeras,category,Keras is a high-level neural networks API, used for building and training neural networks.<SEP>Keras is a machine learning framework that uses XLA for optimization.,2,2025-03-24 13:18:20\n4,\tjit_compile,concept,jit_compile is a technique for compiling TensorFlow graphs into executable code.,1,2025-03-24 13:18:20\n5,\trule #3,concept,rule #3 is a guideline for writing XLA-compatible code.,0,UNKNOWN\n6,\trule #1,concept,rule #1 is a guideline for writing XLA-compatible code.,0,UNKNOWN\n7,\tXLA,technology,XLA is a technology that compiles TensorFlow graphs into executable code for various platforms.<SEP>XLA is an optimizing compiler used by TensorFlow and JAX to improve performance.<SEP>XLA is an optimizing compiler, used by both TensorFlow and JAX to optimize computations.,6,UNKNOWN\n    ```\n    -----Relationships-----\n    ```csv\n    id,\tsource,\ttarget,\tdescription,\tkeywords,\tweight,\trank,\tcreated_at\n1,\tHuggingFace,XLA,HuggingFace provides pre-trained models and loss functions that are XLA-compatible.,compatibility, pre-trained models,8.0,11,2025-03-24 13:18:20\n2,\tKeras,XLA,Keras uses XLA for optimization.,compiler, performance optimization,8.0,8,2025-03-24 13:18:20\n3,\tXLA,jit_compile,jit_compile is a technique used in XLA to compile TensorFlow graphs into executable code.,compilation technique, XLA support,3.0,7,2025-03-24 13:18:20\n4,\tHuggingFace,XLA,HuggingFace provides pre-trained models and loss functions that are XLA-compatible.,compatibility, pre-trained models,8.0,11,UNKNOWN\n5,\tTPU,XLA,XLA compiles TensorFlow graphs into executable code for TPU hardware.<SEP>XLA is used to optimize code for TPU hardware.,compilation, hardware acceleration<SEP>compiler, hardware optimization,36.0,10,UNKNOWN\n6,\tTensorFlow,XLA,TensorFlow graphs can be compiled into executable code using XLA.<SEP>TensorFlow uses XLA as an optimizing compiler to improve performance.,compilation, framework support<SEP>compiler, performance optimization,23.0,9,UNKNOWN\n7,\tKeras,XLA,Keras uses XLA for optimization.,compiler, performance optimization,8.0,8,UNKNOWN\n8,\tJAX,XLA,JAX uses XLA as its only compiler.,compiler, framework integration,18.0,7,UNKNOWN\n9,\tXLA,jit_compile,jit_compile is a technique used in XLA to compile TensorFlow graphs into executable code.,compilation technique, XLA support,3.0,7,UNKNOWN\n    ```\n    -----Sources-----\n    ```csv\n    id,\tcontent\n1,\t(for example, a v3-32), your TPU fleet is referred to as a **pod slice.**\n\nWhen you access a free TPU via Colab, you generally get a single v2-8 TPU.\n\n### I keep hearing about this XLA thing. What\u2019s XLA, and how does it relate to TPUs?\n\nXLA is an optimizing compiler, used by both TensorFlow and JAX. In JAX it is the only compiler, whereas in TensorFlow it is optional (but mandatory on TPU!). The easiest way to enable it when training a Keras model is to pass the argument `jit_compile=True` to `model.compile()`. If you don\u2019t get any errors and performance is good, that\u2019s a great sign that you\u2019re ready to move to TPU!\n\nDebugging on TPU is generally a bit harder than on CPU/GPU, so we recommend getting your code running on CPU/GPU with XLA first before trying it on TPU. You don\u2019t have to train for long, of course - just for a few steps to make sure that your model and data pipeline are working like you expect them to.\n\n<Tip>\n\nXLA compiled code is usually faster - so even if you\u2019re not planning to run on TPU, adding `jit_compile=True` can improve your performance. Be sure to note the caveats below about XLA compatibility, though!\n\n</Tip>\n\n<Tip warning={true}>\n\n**Tip born of painful experience:** Although using `jit_compile=True` is a good way to get a speed boost and test if your CPU/GPU code is XLA-compatible, it can actually cause a lot of problems if you leave it in when actually training on TPU. XLA compilation will happen implicitly on TPU, so remember to remove that line before actually running your code on a TPU!\n\n</Tip>\n\n### How do I make my model XLA compatible?\n\nIn many cases, your code is probably XLA-compatible already! However, there are a few things that work in normal TensorFlow that don\u2019t work in XLA. We\u2019ve distilled them into three core rules below:\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** We\u2019ve put a lot of effort into rewriting our TensorFlow models and loss functions to be XLA-compatible. Our models and loss functions generally obey rule #1 and #2 by default, so you can skip over them if you\u2019re using `transformers` models. Don\u2019t forget about these rules when writing your own models and loss functions, though!\n\n</Tip>\n\n#### XLA Rule #1: Your code cannot have \u201cdata-dependent conditionals\u201d\n\nWhat that means is that any `if` statement cannot depend on values inside a `tf.Tensor`. For example, this code block cannot be compiled with XLA!\n\n```python\nif tf.reduce_sum(tensor) > 10:\n    tensor = tensor / 2.0\n```\n\nThis might seem very restrictive at first, but most neural net code doesn\u2019t need to do this. You can often get around this restriction by using `tf.cond` (see the documentation [here](https://www.tensorflow.org/api_docs/python/tf/cond)) or by removing the conditional and finding a clever math trick with indicator variables instead, like so:\n\n```python\nsum_over_10 = tf.cast(tf.reduce_sum(tensor) > 10, tf.float32)\ntensor = tensor / (1.0 + sum_over_10)\n```\n\nThis code has exactly the same effect as the code above, but by avoiding a conditional, we ensure it will compile with XLA without problems!\n\n#### XLA Rule #2: Your code cannot have \u201cdata-dependent shapes\u201d\n\nWhat this means is that the shape of all of the `tf.Tensor` objects in your code cannot depend on their values. For example, the function `tf.unique` cannot be compiled with XLA, because it returns a `tensor` containing one instance of each unique value in the input. The shape of this output will obviously be different depending on how repetitive the input `Tensor` was, and so XLA refuses to handle it!\n\nIn general, most neural network code obeys rule #2 by default. However, there are a few common cases where it becomes a problem. One very common one is when you use **label masking**, setting your labels to a negative value to indicate that those positions should be ignored when computing the loss. If you look at NumPy or PyTorch loss functions that support label masking, you will often see code like this that uses [boolean indexing](https://numpy.org/doc/stable/user/basics.indexing.html#boolean-array-indexing):\n\n```python\nlabel_mask = labels >= 0\nmasked_outputs = outputs[label_mask]\nmasked_labels = labels[label_mask]\nloss = compute_loss(masked_outputs, masked_labels)\nmean_loss = torch.mean(loss)\n```\n\nThis code is totally fine in NumPy or PyTorch, but it breaks in XLA! Why? Because the shape of `masked_outputs` and `masked_labels` depends on how many positions are masked - that makes it a **data-dependent shape.** However, just like for rule #1, we can often rewrite this code to yield exactly the same output without any data-dependent shapes.\n\n```python\nlabel_mask = tf.cast(labels >= 0, tf.float32)\nloss = compute_loss(outputs, labels)\nloss = loss * label_mask  # Set negative label positions to 0\nmean_loss = tf.reduce_sum(loss) / tf.reduce_sum(label_mask)\n```\n\nHere, we avoid data-dependent shapes by computing the loss for every position, but zeroing out the masked positions in both the numerator and denominator when we calculate the mean, which yields exactly the same result as the first block while maintaining XLA compatibility. Note that we use the same trick as in rule #1 - converting a `tf.bool` to `\n2,\tlabel_mask  # Set negative label positions to 0\nmean_loss = tf.reduce_sum(loss) / tf.reduce_sum(label_mask)\n```\n\nHere, we avoid data-dependent shapes by computing the loss for every position, but zeroing out the masked positions in both the numerator and denominator when we calculate the mean, which yields exactly the same result as the first block while maintaining XLA compatibility. Note that we use the same trick as in rule #1 - converting a `tf.bool` to `tf.float32` and using it as an indicator variable. This is a really useful trick, so remember it if you need to convert your own code to XLA!\n\n#### XLA Rule #3: XLA will need to recompile your model for every different input shape it sees\n\nThis is the big one. What this means is that if your input shapes are very variable, XLA will have to recompile your model over and over, which will create huge performance problems. This commonly arises in NLP models, where input texts have variable lengths after tokenization. In other modalities, static shapes are more common and this rule is much less of a problem.\n\nHow can you get around rule #3? The key is **padding** - if you pad all your inputs to the same length, and then use an `attention_mask`, you can get the same results as you\u2019d get from variable shapes, but without any XLA issues. However, excessive padding can cause severe slowdown too - if you pad all your samples to the maximum length in the whole dataset, you might end up with batches consisting endless padding tokens, which will waste a lot of compute and memory!\n\nThere isn\u2019t a perfect solution to this problem. However, you can try some tricks. One very useful trick is to **pad batches of samples up to a multiple of a number like 32 or 64 tokens.** This often only increases the number of tokens by a small amount, but it hugely reduces the number of unique input shapes, because every input shape now has to be a multiple of 32 or 64. Fewer unique input shapes means fewer XLA compilations!\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** Our tokenizers and data collators have methods that can help you here. You can use `padding=\"max_length\"` or `padding=\"longest\"` when calling tokenizers to get them to output padded data. Our tokenizers and data collators also have a `pad_to_multiple_of` argument that you can use to reduce the number of unique input shapes you see!\n\n</Tip>\n\n### How do I actually train my model on TPU?\n\nOnce your training is XLA-compatible and (if you\u2019re using TPU Node / Colab) your dataset has been prepared appropriately, running on TPU is surprisingly easy! All you really need to change in your code is to add a few lines to initialize your TPU, and to ensure that your model and dataset are created inside a `TPUStrategy` scope. Take a look at [our TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) to see this in action!\n\n### Summary\n\nThere was a lot in here, so let\u2019s summarize with a quick checklist you can follow when you want to get your model ready for TPU training:\n\n- Make sure your code follows the three rules of XLA\n- Compile your model with `jit_compile=True` on CPU/GPU and confirm that you can train it with XLA\n- Either load your dataset into memory or use a TPU-compatible dataset loading approach (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Migrate your code either to Colab (with accelerator set to \u201cTPU\u201d) or a TPU VM on Google Cloud\n- Add TPU initializer code (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Create your `TPUStrategy` and make sure dataset loading and model creation are inside the `strategy.scope()` (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Don\u2019t forget to take `jit_compile=True` out again when you move to TPU!\n- \ud83d\ude4f\ud83d\ude4f\ud83d\ude4f\ud83e\udd7a\ud83e\udd7a\ud83e\udd7a\n- Call model.fit()\n- You did it!\n3,\t!--Copyright 2023 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\nthe License. You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under the License is distributed on\nan \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n\n\u26a0\ufe0f Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be\nrendered properly in your Markdown viewer.\n\n-->\n\n# Training on TPU with TensorFlow\n\n<Tip>\n\nIf you don't need long explanations and just want TPU code samples to get started with, check out [our TPU example notebook!](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb)\n\n</Tip>\n\n### What is a TPU?\n\nA TPU is a **Tensor Processing Unit.** They are hardware designed by Google, which are used to greatly speed up the tensor computations within neural networks, much like GPUs. They can be used for both network training and inference. They are generally accessed through Google\u2019s cloud services, but small TPUs can also be accessed directly for free through Google Colab and Kaggle Kernels.\n\nBecause [all TensorFlow models in \ud83e\udd17 Transformers are Keras models](https://huggingface.co/blog/tensorflow-philosophy), most of the methods in this document are generally applicable to TPU training for any Keras model! However, there are a few points that are specific to the HuggingFace ecosystem (hug-o-system?) of Transformers and Datasets, and we\u2019ll make sure to flag them up when we get to them.\n\n### What kinds of TPU are available?\n\nNew users are often very confused by the range of TPUs, and the different ways to access them. The first key distinction to understand is the difference between **TPU Nodes** and **TPU VMs.**\n\nWhen you use a **TPU Node**, you are effectively indirectly accessing a remote TPU. You will need a separate VM, which will initialize your network and data pipeline and then forward them to the remote node. When you use a TPU on Google Colab, you are accessing it in the **TPU Node** style.\n\nUsing TPU Nodes can have some quite unexpected behaviour for people who aren\u2019t used to them! In particular, because the TPU is located on a physically different system to the machine you\u2019re running your Python code on, your data cannot be local to your machine - any data pipeline that loads from your machine\u2019s internal storage will totally fail! Instead, data must be stored in Google Cloud Storage where your data pipeline can still access it, even when the pipeline is running on the remote TPU node.\n\n<Tip>\n\nIf you can fit all your data in memory as `np.ndarray` or `tf.Tensor`, then you can `fit()` on that data even when using Colab or a TPU Node, without needing to upload it to Google Cloud Storage.\n\n</Tip>\n\n<Tip>\n\n**\ud83e\udd17Specific Hugging Face Tip\ud83e\udd17:** The methods `Dataset.to_tf_dataset()` and its higher-level wrapper `model.prepare_tf_dataset()` , which you will see throughout our TF code examples, will both fail on a TPU Node. The reason for this is that even though they create a `tf.data.Dataset` it is not a \u201cpure\u201d `tf.data` pipeline and uses `tf.numpy_function` or `Dataset.from_generator()` to stream data from the underlying HuggingFace `Dataset`. This HuggingFace `Dataset` is backed by data that is on a local disc and which the remote TPU Node will not be able to read.\n\n</Tip>\n\nThe second way to access a TPU is via a **TPU VM.** When using a TPU VM, you connect directly to the machine that the TPU is attached to, much like training on a GPU VM. TPU VMs are generally easier to work with, particularly when it comes to your data pipeline. All of the above warnings do not apply to TPU VMs!\n\nThis is an opinionated document, so here\u2019s our opinion: **Avoid using TPU Node if possible.** It is more confusing and more difficult to debug than TPU VMs. It is also likely to be unsupported in future - Google\u2019s latest TPU, TPUv4, can only be accessed as a TPU VM, which suggests that TPU Nodes are increasingly going to become a \u201clegacy\u201d access method. However, we understand that the only free TPU access is on Colab and Kaggle Kernels, which uses TPU Node - so we\u2019ll try to explain how to handle it if you have to! Check the [TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) for code samples that explain this in more detail.\n\n### What sizes of TPU are available?\n\nA single TPU (a v2-8/v3-8/v4-8) runs 8 replicas. TPUs exist in **pods** that can run hundreds or thousands of replicas simultaneously. When you use more than a single TPU but less than a whole pod (for example, a v3-32), your TPU fleet is referred to as a **pod slice.**\n\nWhen you access a free TPU via Colab, you generally get a single v2-8 TPU.\n\n### I keep hearing about this XLA thing. What\u2019s XLA, and how does it relate to TPUs?\n\nXLA is an optimizing compiler, used by both TensorFlow and JAX. In JAX it is the only compiler, whereas in TensorFlow it is optional\n    ```",
            "vector_context": "[Created at: 2025-03-24 13:17:32]\n(for example, a v3-32), your TPU fleet is referred to as a **pod slice.**\n\nWhen you access a free TPU via Colab, you generally get a single v2-8 TPU.\n\n### I keep hearing about this XLA thing. What\u2019s XLA, and how does it relate to TPUs?\n\nXLA is an optimizing compiler, used by both TensorFlow and JAX. In JAX it is the only compiler, whereas in TensorFlow it is optional (but mandatory on TPU!). The easiest way to enable it when training a Keras model is to pass the argument `jit_compile=True` to `model.compile()`. If you don\u2019t get any errors and performance is good, that\u2019s a great sign that you\u2019re ready to move to TPU!\n\nDebugging on TPU is generally a bit harder than on CPU/GPU, so we recommend getting your code running on CPU/GPU with XLA first before trying it on TPU. You don\u2019t have to train for long, of course - just for a few steps to make sure that your model and data pipeline are working like you expect them to.\n\n<Tip>\n\nXLA compiled code is usually faster - so even if you\u2019re not planning to run on TPU, adding `jit_compile=True` can improve your performance. Be sure to note the caveats below about XLA compatibility, though!\n\n</Tip>\n\n<Tip warning={true}>\n\n**Tip born of painful experience:** Although using `jit_compile=True` is a good way to get a speed boost and test if your CPU/GPU code is XLA-compatible, it can actually cause a lot of problems if you leave it in when actually training on TPU. XLA compilation will happen implicitly on TPU, so remember to remove that line before actually running your code on a TPU!\n\n</Tip>\n\n### How do I make my model XLA compatible?\n\nIn many cases, your code is probably XLA-compatible already! However, there are a few things that work in normal TensorFlow that don\u2019t work in XLA. We\u2019ve distilled them into three core rules below:\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** We\u2019ve put a lot of effort into rewriting our TensorFlow models and loss functions to be XLA-compatible. Our models and loss functions generally obey rule #1 and #2 by default, so you can skip over them if you\u2019re using `transformers` models. Don\u2019t forget about these rules when writing your own models and loss functions, though!\n\n</Tip>\n\n#### XLA Rule #1: Your code cannot have \u201cdata-dependent conditionals\u201d\n\nWhat that means is that any `if` statement cannot depend on values inside a `tf.Tensor`. For example, this code block cannot be compiled with XLA!\n\n```python\nif tf.reduce_sum(tensor) > 10:\n    tensor = tensor / 2.0\n```\n\nThis might seem very restrictive at first, but most neural net code doesn\u2019t need to do this. You can often get around this restriction by using `tf.cond` (see the documentation [here](https://www.tensorflow.org/api_docs/python/tf/cond)) or by removing the conditional and finding a clever math trick with indicator variables instead, like so:\n\n```python\nsum_over_10 = tf.cast(tf.reduce_sum(tensor) > 10, tf.float32)\ntensor = tensor / (1.0 + sum_over_10)\n```\n\nThis code has exactly the same effect as the code above, but by avoiding a conditional, we ensure it will compile with XLA without problems!\n\n#### XLA Rule #2: Your code cannot have \u201cdata-dependent shapes\u201d\n\nWhat this means is that the shape of all of the `tf.Tensor` objects in your code cannot depend on their values. For example, the function `tf.unique` cannot be compiled with XLA, because it returns a `tensor` containing one instance of each unique value in the input. The shape of this output will obviously be different depending on how repetitive the input `Tensor` was, and so XLA refuses to handle it!\n\nIn general, most neural network code obeys rule #2 by default. However, there are a few common cases where it becomes a problem. One very common one is when you use **label masking**, setting your labels to a negative value to indicate that those positions should be ignored when computing the loss. If you look at NumPy or PyTorch loss functions that support label masking, you will often see code like this that uses [boolean indexing](https://numpy.org/doc/stable/user/basics.indexing.html#boolean-array-indexing):\n\n```python\nlabel_mask = labels >= 0\nmasked_outputs = outputs[label_mask]\nmasked_labels = labels[label_mask]\nloss = compute_loss(masked_outputs, masked_labels)\nmean_loss = torch.mean(loss)\n```\n\nThis code is totally fine in NumPy or PyTorch, but it breaks in XLA! Why? Because the shape of `masked_outputs` and `masked_labels` depends on how many positions are masked - that makes it a **data-dependent shape.** However, just like for rule #1, we can often rewrite this code to yield exactly the same output without any data-dependent shapes.\n\n```python\nlabel_mask = tf.cast(labels >= 0, tf.float32)\nloss = compute_loss(outputs, labels)\nloss = loss * label_mask  # Set negative label positions to 0\nmean_loss = tf.reduce_sum(loss) / tf.reduce_sum(label_mask)\n```\n\nHere, we avoid data-dependent shapes by computing the loss for every position, but zeroing out the masked positions in both the numerator and denominator when we calculate the mean, which yields exactly the same result as the first block while maintaining XLA compatibility. Note that we use the same trick as in rule #1 - converting a `tf.bool` to `\n--New Chunk--\n[Created at: 2025-03-24 13:17:32]\nlabel_mask  # Set negative label positions to 0\nmean_loss = tf.reduce_sum(loss) / tf.reduce_sum(label_mask)\n```\n\nHere, we avoid data-dependent shapes by computing the loss for every position, but zeroing out the masked positions in both the numerator and denominator when we calculate the mean, which yields exactly the same result as the first block while maintaining XLA compatibility. Note that we use the same trick as in rule #1 - converting a `tf.bool` to `tf.float32` and using it as an indicator variable. This is a really useful trick, so remember it if you need to convert your own code to XLA!\n\n#### XLA Rule #3: XLA will need to recompile your model for every different input shape it sees\n\nThis is the big one. What this means is that if your input shapes are very variable, XLA will have to recompile your model over and over, which will create huge performance problems. This commonly arises in NLP models, where input texts have variable lengths after tokenization. In other modalities, static shapes are more common and this rule is much less of a problem.\n\nHow can you get around rule #3? The key is **padding** - if you pad all your inputs to the same length, and then use an `attention_mask`, you can get the same results as you\u2019d get from variable shapes, but without any XLA issues. However, excessive padding can cause severe slowdown too - if you pad all your samples to the maximum length in the whole dataset, you might end up with batches consisting endless padding tokens, which will waste a lot of compute and memory!\n\nThere isn\u2019t a perfect solution to this problem. However, you can try some tricks. One very useful trick is to **pad batches of samples up to a multiple of a number like 32 or 64 tokens.** This often only increases the number of tokens by a small amount, but it hugely reduces the number of unique input shapes, because every input shape now has to be a multiple of 32 or 64. Fewer unique input shapes means fewer XLA compilations!\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** Our tokenizers and data collators have methods that can help you here. You can use `padding=\"max_length\"` or `padding=\"longest\"` when calling tokenizers to get them to output padded data. Our tokenizers and data collators also have a `pad_to_multiple_of` argument that you can use to reduce the number of unique input shapes you see!\n\n</Tip>\n\n### How do I actually train my model on TPU?\n\nOnce your training is XLA-compatible and (if you\u2019re using TPU Node / Colab) your dataset has been prepared appropriately, running on TPU is surprisingly easy! All you really need to change in your code is to add a few lines to initialize your TPU, and to ensure that your model and dataset are created inside a `TPUStrategy` scope. Take a look at [our TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) to see this in action!\n\n### Summary\n\nThere was a lot in here, so let\u2019s summarize with a quick checklist you can follow when you want to get your model ready for TPU training:\n\n- Make sure your code follows the three rules of XLA\n- Compile your model with `jit_compile=True` on CPU/GPU and confirm that you can train it with XLA\n- Either load your dataset into memory or use a TPU-compatible dataset loading approach (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Migrate your code either to Colab (with accelerator set to \u201cTPU\u201d) or a TPU VM on Google Cloud\n- Add TPU initializer code (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Create your `TPUStrategy` and make sure dataset loading and model creation are inside the `strategy.scope()` (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Don\u2019t forget to take `jit_compile=True` out again when you move to TPU!\n- \ud83d\ude4f\ud83d\ude4f\ud83d\ude4f\ud83e\udd7a\ud83e\udd7a\ud83e\udd7a\n- Call model.fit()\n- You did it!\n--New Chunk--\n[Created at: 2025-03-24 13:17:32]\n!--Copyright 2023 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\nthe License. You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under the License is distributed on\nan \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n\n\u26a0\ufe0f Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be\nrendered properly in your Markdown viewer.\n\n-->\n\n# Training on TPU with TensorFlow\n\n<Tip>\n\nIf you don't need long explanations and just want TPU code samples to get started with, check out [our TPU example notebook!](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb)\n\n</Tip>\n\n### What is a TPU?\n\nA TPU is a **Tensor Processing Unit.** They are hardware designed by Google, which are used to greatly speed up the tensor computations within neural networks, much like GPUs. They can be used for both network training and inference. They are generally accessed through Google\u2019s cloud services, but small TPUs can also be accessed directly for free through Google Colab and Kaggle Kernels.\n\nBecause [all TensorFlow models in \ud83e\udd17 Transformers are Keras models](https://huggingface.co/blog/tensorflow-philosophy), most of the methods in this document are generally applicable to TPU training for any Keras model! However, there are a few points that are specific to the HuggingFace ecosystem (hug-o-system?) of Transformers and Datasets, and we\u2019ll make sure to flag them up when we get to them.\n\n### What kinds of TPU are available?\n\nNew users are often very confused by the range of TPUs, and the different ways to access them. The first key distinction to understand is the difference between **TPU Nodes** and **TPU VMs.**\n\nWhen you use a **TPU Node**, you are effectively indirectly accessing a remote TPU. You will need a separate VM, which will initialize your network and data pipeline and then forward them to the remote node. When you use a TPU on Google Colab, you are accessing it in the **TPU Node** style.\n\nUsing TPU Nodes can have some quite unexpected behaviour for people who aren\u2019t used to them! In particular, because the TPU is located on a physically different system to the machine you\u2019re running your Python code on, your data cannot be local to your machine - any data pipeline that loads from your machine\u2019s internal storage will totally fail! Instead, data must be stored in Google Cloud Storage where your data pipeline can still access it, even when the pipeline is running on the remote TPU node.\n\n<Tip>\n\nIf you can fit all your data in memory as `np.ndarray` or `tf.Tensor`, then you can `fit()` on that data even when using Colab or a TPU Node, without needing to upload it to Google Cloud Storage.\n\n</Tip>\n\n<Tip>\n\n**\ud83e\udd17Specific Hugging Face Tip\ud83e\udd17:** The methods `Dataset.to_tf_dataset()` and its higher-level wrapper `model.prepare_tf_dataset()` , which you will see throughout our TF code examples, will both fail on a TPU Node. The reason for this is that even though they create a `tf.data.Dataset` it is not a \u201cpure\u201d `tf.data` pipeline and uses `tf.numpy_function` or `Dataset.from_generator()` to stream data from the underlying HuggingFace `Dataset`. This HuggingFace `Dataset` is backed by data that is on a local disc and which the remote TPU Node will not be able to read.\n\n</Tip>\n\nThe second way to access a TPU is via a **TPU VM.** When using a TPU VM, you connect directly to the machine that the TPU is attached to, much like training on a GPU VM. TPU VMs are generally easier to work with, particularly when it comes to your data pipeline. All of the above warnings do not apply to TPU VMs!\n\nThis is an opinionated document, so here\u2019s our opinion: **Avoid using TPU Node if possible.** It is more confusing and more difficult to debug than TPU VMs. It is also likely to be unsupported in future - Google\u2019s latest TPU, TPUv4, can only be accessed as a TPU VM, which suggests that TPU Nodes are increasingly going to become a \u201clegacy\u201d access method. However, we understand that the only free TPU access is on Colab and Kaggle Kernels, which uses TPU Node - so we\u2019ll try to explain how to handle it if you have to! Check the [TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) for code samples that explain this in more detail.\n\n### What sizes of TPU are available?\n\nA single TPU (a v2-8/v3-8/v4-8) runs 8 replicas. TPUs exist in **pods** that can run hundreds or thousands of replicas simultaneously. When you use more than a single TPU but less than a whole pod (for example, a v3-32), your TPU fleet is referred to as a **pod slice.**\n\nWhen you access a free TPU via Colab, you generally get a single v2-8 TPU.\n\n### I keep hearing about this XLA thing. What\u2019s XLA, and how does it relate to TPUs?\n\nXLA is an optimizing compiler, used by both TensorFlow and JAX. In JAX it is the only compiler, whereas in TensorFlow it is optional"
        }
    },
    {
        "sample_idx": 64,
        "question": "What does XLA Rule #2 mean?",
        "answer": "The shape of all of the tf.Tensor objects in your code cannot depend on their values.",
        "rag_answer": "**XLA Rule #2: No Data-Dependent Shapes**\n\nXLA Rule #2 states that the shape of all `tf.Tensor` objects in your code cannot depend on their values. In other words, the shape of your tensors should be fixed and known at compile time.\n\nThis rule means that you cannot have tensors whose shape changes dynamically based on the input data. For example, if you have a tensor that returns a different shape depending on the input, XLA will not be able to compile it",
        "rag_score": null,
        "rag_feedback": null,
        "rag_context": {
            "kg_context": "-----Entities-----\n    ```csv\n    id,\tentity,\ttype,\tdescription,\trankcreated_at\n1,\tHuggingFace,organization,HuggingFace is a company that provides a range of AI models and tools, including the Transformers and Datasets ecosystem.<SEP>HuggingFace is an organization that provides pre-trained models and loss functions for machine learning.<SEP>HuggingFace is an organization that provides tools and resources for natural language processing and machine learning.,5,2025-03-24 13:18:20\n2,\tXLA,technology,XLA is a technology that compiles TensorFlow graphs into executable code for various platforms.<SEP>XLA is an optimizing compiler used by TensorFlow and JAX to improve performance.<SEP>XLA is an optimizing compiler, used by both TensorFlow and JAX to optimize computations.,6,2025-03-24 13:18:20\n3,\tKeras,category,Keras is a high-level neural networks API, used for building and training neural networks.<SEP>Keras is a machine learning framework that uses XLA for optimization.,2,2025-03-24 13:18:20\n4,\tjit_compile,concept,jit_compile is a technique for compiling TensorFlow graphs into executable code.,1,2025-03-24 13:18:20\n5,\trule #3,concept,rule #3 is a guideline for writing XLA-compatible code.,0,UNKNOWN\n6,\trule #1,concept,rule #1 is a guideline for writing XLA-compatible code.,0,UNKNOWN\n7,\tXLA,technology,XLA is a technology that compiles TensorFlow graphs into executable code for various platforms.<SEP>XLA is an optimizing compiler used by TensorFlow and JAX to improve performance.<SEP>XLA is an optimizing compiler, used by both TensorFlow and JAX to optimize computations.,6,UNKNOWN\n    ```\n    -----Relationships-----\n    ```csv\n    id,\tsource,\ttarget,\tdescription,\tkeywords,\tweight,\trank,\tcreated_at\n1,\tHuggingFace,XLA,HuggingFace provides pre-trained models and loss functions that are XLA-compatible.,compatibility, pre-trained models,8.0,11,2025-03-24 13:18:20\n2,\tKeras,XLA,Keras uses XLA for optimization.,compiler, performance optimization,8.0,8,2025-03-24 13:18:20\n3,\tXLA,jit_compile,jit_compile is a technique used in XLA to compile TensorFlow graphs into executable code.,compilation technique, XLA support,3.0,7,2025-03-24 13:18:20\n4,\tHuggingFace,XLA,HuggingFace provides pre-trained models and loss functions that are XLA-compatible.,compatibility, pre-trained models,8.0,11,UNKNOWN\n5,\tTPU,XLA,XLA compiles TensorFlow graphs into executable code for TPU hardware.<SEP>XLA is used to optimize code for TPU hardware.,compilation, hardware acceleration<SEP>compiler, hardware optimization,36.0,10,UNKNOWN\n6,\tTensorFlow,XLA,TensorFlow graphs can be compiled into executable code using XLA.<SEP>TensorFlow uses XLA as an optimizing compiler to improve performance.,compilation, framework support<SEP>compiler, performance optimization,23.0,9,UNKNOWN\n7,\tKeras,XLA,Keras uses XLA for optimization.,compiler, performance optimization,8.0,8,UNKNOWN\n8,\tJAX,XLA,JAX uses XLA as its only compiler.,compiler, framework integration,18.0,7,UNKNOWN\n9,\tXLA,jit_compile,jit_compile is a technique used in XLA to compile TensorFlow graphs into executable code.,compilation technique, XLA support,3.0,7,UNKNOWN\n    ```\n    -----Sources-----\n    ```csv\n    id,\tcontent\n1,\t(for example, a v3-32), your TPU fleet is referred to as a **pod slice.**\n\nWhen you access a free TPU via Colab, you generally get a single v2-8 TPU.\n\n### I keep hearing about this XLA thing. What\u2019s XLA, and how does it relate to TPUs?\n\nXLA is an optimizing compiler, used by both TensorFlow and JAX. In JAX it is the only compiler, whereas in TensorFlow it is optional (but mandatory on TPU!). The easiest way to enable it when training a Keras model is to pass the argument `jit_compile=True` to `model.compile()`. If you don\u2019t get any errors and performance is good, that\u2019s a great sign that you\u2019re ready to move to TPU!\n\nDebugging on TPU is generally a bit harder than on CPU/GPU, so we recommend getting your code running on CPU/GPU with XLA first before trying it on TPU. You don\u2019t have to train for long, of course - just for a few steps to make sure that your model and data pipeline are working like you expect them to.\n\n<Tip>\n\nXLA compiled code is usually faster - so even if you\u2019re not planning to run on TPU, adding `jit_compile=True` can improve your performance. Be sure to note the caveats below about XLA compatibility, though!\n\n</Tip>\n\n<Tip warning={true}>\n\n**Tip born of painful experience:** Although using `jit_compile=True` is a good way to get a speed boost and test if your CPU/GPU code is XLA-compatible, it can actually cause a lot of problems if you leave it in when actually training on TPU. XLA compilation will happen implicitly on TPU, so remember to remove that line before actually running your code on a TPU!\n\n</Tip>\n\n### How do I make my model XLA compatible?\n\nIn many cases, your code is probably XLA-compatible already! However, there are a few things that work in normal TensorFlow that don\u2019t work in XLA. We\u2019ve distilled them into three core rules below:\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** We\u2019ve put a lot of effort into rewriting our TensorFlow models and loss functions to be XLA-compatible. Our models and loss functions generally obey rule #1 and #2 by default, so you can skip over them if you\u2019re using `transformers` models. Don\u2019t forget about these rules when writing your own models and loss functions, though!\n\n</Tip>\n\n#### XLA Rule #1: Your code cannot have \u201cdata-dependent conditionals\u201d\n\nWhat that means is that any `if` statement cannot depend on values inside a `tf.Tensor`. For example, this code block cannot be compiled with XLA!\n\n```python\nif tf.reduce_sum(tensor) > 10:\n    tensor = tensor / 2.0\n```\n\nThis might seem very restrictive at first, but most neural net code doesn\u2019t need to do this. You can often get around this restriction by using `tf.cond` (see the documentation [here](https://www.tensorflow.org/api_docs/python/tf/cond)) or by removing the conditional and finding a clever math trick with indicator variables instead, like so:\n\n```python\nsum_over_10 = tf.cast(tf.reduce_sum(tensor) > 10, tf.float32)\ntensor = tensor / (1.0 + sum_over_10)\n```\n\nThis code has exactly the same effect as the code above, but by avoiding a conditional, we ensure it will compile with XLA without problems!\n\n#### XLA Rule #2: Your code cannot have \u201cdata-dependent shapes\u201d\n\nWhat this means is that the shape of all of the `tf.Tensor` objects in your code cannot depend on their values. For example, the function `tf.unique` cannot be compiled with XLA, because it returns a `tensor` containing one instance of each unique value in the input. The shape of this output will obviously be different depending on how repetitive the input `Tensor` was, and so XLA refuses to handle it!\n\nIn general, most neural network code obeys rule #2 by default. However, there are a few common cases where it becomes a problem. One very common one is when you use **label masking**, setting your labels to a negative value to indicate that those positions should be ignored when computing the loss. If you look at NumPy or PyTorch loss functions that support label masking, you will often see code like this that uses [boolean indexing](https://numpy.org/doc/stable/user/basics.indexing.html#boolean-array-indexing):\n\n```python\nlabel_mask = labels >= 0\nmasked_outputs = outputs[label_mask]\nmasked_labels = labels[label_mask]\nloss = compute_loss(masked_outputs, masked_labels)\nmean_loss = torch.mean(loss)\n```\n\nThis code is totally fine in NumPy or PyTorch, but it breaks in XLA! Why? Because the shape of `masked_outputs` and `masked_labels` depends on how many positions are masked - that makes it a **data-dependent shape.** However, just like for rule #1, we can often rewrite this code to yield exactly the same output without any data-dependent shapes.\n\n```python\nlabel_mask = tf.cast(labels >= 0, tf.float32)\nloss = compute_loss(outputs, labels)\nloss = loss * label_mask  # Set negative label positions to 0\nmean_loss = tf.reduce_sum(loss) / tf.reduce_sum(label_mask)\n```\n\nHere, we avoid data-dependent shapes by computing the loss for every position, but zeroing out the masked positions in both the numerator and denominator when we calculate the mean, which yields exactly the same result as the first block while maintaining XLA compatibility. Note that we use the same trick as in rule #1 - converting a `tf.bool` to `\n2,\tlabel_mask  # Set negative label positions to 0\nmean_loss = tf.reduce_sum(loss) / tf.reduce_sum(label_mask)\n```\n\nHere, we avoid data-dependent shapes by computing the loss for every position, but zeroing out the masked positions in both the numerator and denominator when we calculate the mean, which yields exactly the same result as the first block while maintaining XLA compatibility. Note that we use the same trick as in rule #1 - converting a `tf.bool` to `tf.float32` and using it as an indicator variable. This is a really useful trick, so remember it if you need to convert your own code to XLA!\n\n#### XLA Rule #3: XLA will need to recompile your model for every different input shape it sees\n\nThis is the big one. What this means is that if your input shapes are very variable, XLA will have to recompile your model over and over, which will create huge performance problems. This commonly arises in NLP models, where input texts have variable lengths after tokenization. In other modalities, static shapes are more common and this rule is much less of a problem.\n\nHow can you get around rule #3? The key is **padding** - if you pad all your inputs to the same length, and then use an `attention_mask`, you can get the same results as you\u2019d get from variable shapes, but without any XLA issues. However, excessive padding can cause severe slowdown too - if you pad all your samples to the maximum length in the whole dataset, you might end up with batches consisting endless padding tokens, which will waste a lot of compute and memory!\n\nThere isn\u2019t a perfect solution to this problem. However, you can try some tricks. One very useful trick is to **pad batches of samples up to a multiple of a number like 32 or 64 tokens.** This often only increases the number of tokens by a small amount, but it hugely reduces the number of unique input shapes, because every input shape now has to be a multiple of 32 or 64. Fewer unique input shapes means fewer XLA compilations!\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** Our tokenizers and data collators have methods that can help you here. You can use `padding=\"max_length\"` or `padding=\"longest\"` when calling tokenizers to get them to output padded data. Our tokenizers and data collators also have a `pad_to_multiple_of` argument that you can use to reduce the number of unique input shapes you see!\n\n</Tip>\n\n### How do I actually train my model on TPU?\n\nOnce your training is XLA-compatible and (if you\u2019re using TPU Node / Colab) your dataset has been prepared appropriately, running on TPU is surprisingly easy! All you really need to change in your code is to add a few lines to initialize your TPU, and to ensure that your model and dataset are created inside a `TPUStrategy` scope. Take a look at [our TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) to see this in action!\n\n### Summary\n\nThere was a lot in here, so let\u2019s summarize with a quick checklist you can follow when you want to get your model ready for TPU training:\n\n- Make sure your code follows the three rules of XLA\n- Compile your model with `jit_compile=True` on CPU/GPU and confirm that you can train it with XLA\n- Either load your dataset into memory or use a TPU-compatible dataset loading approach (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Migrate your code either to Colab (with accelerator set to \u201cTPU\u201d) or a TPU VM on Google Cloud\n- Add TPU initializer code (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Create your `TPUStrategy` and make sure dataset loading and model creation are inside the `strategy.scope()` (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Don\u2019t forget to take `jit_compile=True` out again when you move to TPU!\n- \ud83d\ude4f\ud83d\ude4f\ud83d\ude4f\ud83e\udd7a\ud83e\udd7a\ud83e\udd7a\n- Call model.fit()\n- You did it!\n3,\t!--Copyright 2023 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\nthe License. You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under the License is distributed on\nan \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n\n\u26a0\ufe0f Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be\nrendered properly in your Markdown viewer.\n\n-->\n\n# Training on TPU with TensorFlow\n\n<Tip>\n\nIf you don't need long explanations and just want TPU code samples to get started with, check out [our TPU example notebook!](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb)\n\n</Tip>\n\n### What is a TPU?\n\nA TPU is a **Tensor Processing Unit.** They are hardware designed by Google, which are used to greatly speed up the tensor computations within neural networks, much like GPUs. They can be used for both network training and inference. They are generally accessed through Google\u2019s cloud services, but small TPUs can also be accessed directly for free through Google Colab and Kaggle Kernels.\n\nBecause [all TensorFlow models in \ud83e\udd17 Transformers are Keras models](https://huggingface.co/blog/tensorflow-philosophy), most of the methods in this document are generally applicable to TPU training for any Keras model! However, there are a few points that are specific to the HuggingFace ecosystem (hug-o-system?) of Transformers and Datasets, and we\u2019ll make sure to flag them up when we get to them.\n\n### What kinds of TPU are available?\n\nNew users are often very confused by the range of TPUs, and the different ways to access them. The first key distinction to understand is the difference between **TPU Nodes** and **TPU VMs.**\n\nWhen you use a **TPU Node**, you are effectively indirectly accessing a remote TPU. You will need a separate VM, which will initialize your network and data pipeline and then forward them to the remote node. When you use a TPU on Google Colab, you are accessing it in the **TPU Node** style.\n\nUsing TPU Nodes can have some quite unexpected behaviour for people who aren\u2019t used to them! In particular, because the TPU is located on a physically different system to the machine you\u2019re running your Python code on, your data cannot be local to your machine - any data pipeline that loads from your machine\u2019s internal storage will totally fail! Instead, data must be stored in Google Cloud Storage where your data pipeline can still access it, even when the pipeline is running on the remote TPU node.\n\n<Tip>\n\nIf you can fit all your data in memory as `np.ndarray` or `tf.Tensor`, then you can `fit()` on that data even when using Colab or a TPU Node, without needing to upload it to Google Cloud Storage.\n\n</Tip>\n\n<Tip>\n\n**\ud83e\udd17Specific Hugging Face Tip\ud83e\udd17:** The methods `Dataset.to_tf_dataset()` and its higher-level wrapper `model.prepare_tf_dataset()` , which you will see throughout our TF code examples, will both fail on a TPU Node. The reason for this is that even though they create a `tf.data.Dataset` it is not a \u201cpure\u201d `tf.data` pipeline and uses `tf.numpy_function` or `Dataset.from_generator()` to stream data from the underlying HuggingFace `Dataset`. This HuggingFace `Dataset` is backed by data that is on a local disc and which the remote TPU Node will not be able to read.\n\n</Tip>\n\nThe second way to access a TPU is via a **TPU VM.** When using a TPU VM, you connect directly to the machine that the TPU is attached to, much like training on a GPU VM. TPU VMs are generally easier to work with, particularly when it comes to your data pipeline. All of the above warnings do not apply to TPU VMs!\n\nThis is an opinionated document, so here\u2019s our opinion: **Avoid using TPU Node if possible.** It is more confusing and more difficult to debug than TPU VMs. It is also likely to be unsupported in future - Google\u2019s latest TPU, TPUv4, can only be accessed as a TPU VM, which suggests that TPU Nodes are increasingly going to become a \u201clegacy\u201d access method. However, we understand that the only free TPU access is on Colab and Kaggle Kernels, which uses TPU Node - so we\u2019ll try to explain how to handle it if you have to! Check the [TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) for code samples that explain this in more detail.\n\n### What sizes of TPU are available?\n\nA single TPU (a v2-8/v3-8/v4-8) runs 8 replicas. TPUs exist in **pods** that can run hundreds or thousands of replicas simultaneously. When you use more than a single TPU but less than a whole pod (for example, a v3-32), your TPU fleet is referred to as a **pod slice.**\n\nWhen you access a free TPU via Colab, you generally get a single v2-8 TPU.\n\n### I keep hearing about this XLA thing. What\u2019s XLA, and how does it relate to TPUs?\n\nXLA is an optimizing compiler, used by both TensorFlow and JAX. In JAX it is the only compiler, whereas in TensorFlow it is optional\n    ```",
            "vector_context": "[Created at: 2025-03-24 13:17:32]\n(for example, a v3-32), your TPU fleet is referred to as a **pod slice.**\n\nWhen you access a free TPU via Colab, you generally get a single v2-8 TPU.\n\n### I keep hearing about this XLA thing. What\u2019s XLA, and how does it relate to TPUs?\n\nXLA is an optimizing compiler, used by both TensorFlow and JAX. In JAX it is the only compiler, whereas in TensorFlow it is optional (but mandatory on TPU!). The easiest way to enable it when training a Keras model is to pass the argument `jit_compile=True` to `model.compile()`. If you don\u2019t get any errors and performance is good, that\u2019s a great sign that you\u2019re ready to move to TPU!\n\nDebugging on TPU is generally a bit harder than on CPU/GPU, so we recommend getting your code running on CPU/GPU with XLA first before trying it on TPU. You don\u2019t have to train for long, of course - just for a few steps to make sure that your model and data pipeline are working like you expect them to.\n\n<Tip>\n\nXLA compiled code is usually faster - so even if you\u2019re not planning to run on TPU, adding `jit_compile=True` can improve your performance. Be sure to note the caveats below about XLA compatibility, though!\n\n</Tip>\n\n<Tip warning={true}>\n\n**Tip born of painful experience:** Although using `jit_compile=True` is a good way to get a speed boost and test if your CPU/GPU code is XLA-compatible, it can actually cause a lot of problems if you leave it in when actually training on TPU. XLA compilation will happen implicitly on TPU, so remember to remove that line before actually running your code on a TPU!\n\n</Tip>\n\n### How do I make my model XLA compatible?\n\nIn many cases, your code is probably XLA-compatible already! However, there are a few things that work in normal TensorFlow that don\u2019t work in XLA. We\u2019ve distilled them into three core rules below:\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** We\u2019ve put a lot of effort into rewriting our TensorFlow models and loss functions to be XLA-compatible. Our models and loss functions generally obey rule #1 and #2 by default, so you can skip over them if you\u2019re using `transformers` models. Don\u2019t forget about these rules when writing your own models and loss functions, though!\n\n</Tip>\n\n#### XLA Rule #1: Your code cannot have \u201cdata-dependent conditionals\u201d\n\nWhat that means is that any `if` statement cannot depend on values inside a `tf.Tensor`. For example, this code block cannot be compiled with XLA!\n\n```python\nif tf.reduce_sum(tensor) > 10:\n    tensor = tensor / 2.0\n```\n\nThis might seem very restrictive at first, but most neural net code doesn\u2019t need to do this. You can often get around this restriction by using `tf.cond` (see the documentation [here](https://www.tensorflow.org/api_docs/python/tf/cond)) or by removing the conditional and finding a clever math trick with indicator variables instead, like so:\n\n```python\nsum_over_10 = tf.cast(tf.reduce_sum(tensor) > 10, tf.float32)\ntensor = tensor / (1.0 + sum_over_10)\n```\n\nThis code has exactly the same effect as the code above, but by avoiding a conditional, we ensure it will compile with XLA without problems!\n\n#### XLA Rule #2: Your code cannot have \u201cdata-dependent shapes\u201d\n\nWhat this means is that the shape of all of the `tf.Tensor` objects in your code cannot depend on their values. For example, the function `tf.unique` cannot be compiled with XLA, because it returns a `tensor` containing one instance of each unique value in the input. The shape of this output will obviously be different depending on how repetitive the input `Tensor` was, and so XLA refuses to handle it!\n\nIn general, most neural network code obeys rule #2 by default. However, there are a few common cases where it becomes a problem. One very common one is when you use **label masking**, setting your labels to a negative value to indicate that those positions should be ignored when computing the loss. If you look at NumPy or PyTorch loss functions that support label masking, you will often see code like this that uses [boolean indexing](https://numpy.org/doc/stable/user/basics.indexing.html#boolean-array-indexing):\n\n```python\nlabel_mask = labels >= 0\nmasked_outputs = outputs[label_mask]\nmasked_labels = labels[label_mask]\nloss = compute_loss(masked_outputs, masked_labels)\nmean_loss = torch.mean(loss)\n```\n\nThis code is totally fine in NumPy or PyTorch, but it breaks in XLA! Why? Because the shape of `masked_outputs` and `masked_labels` depends on how many positions are masked - that makes it a **data-dependent shape.** However, just like for rule #1, we can often rewrite this code to yield exactly the same output without any data-dependent shapes.\n\n```python\nlabel_mask = tf.cast(labels >= 0, tf.float32)\nloss = compute_loss(outputs, labels)\nloss = loss * label_mask  # Set negative label positions to 0\nmean_loss = tf.reduce_sum(loss) / tf.reduce_sum(label_mask)\n```\n\nHere, we avoid data-dependent shapes by computing the loss for every position, but zeroing out the masked positions in both the numerator and denominator when we calculate the mean, which yields exactly the same result as the first block while maintaining XLA compatibility. Note that we use the same trick as in rule #1 - converting a `tf.bool` to `\n--New Chunk--\n[Created at: 2025-03-24 13:17:32]\nlabel_mask  # Set negative label positions to 0\nmean_loss = tf.reduce_sum(loss) / tf.reduce_sum(label_mask)\n```\n\nHere, we avoid data-dependent shapes by computing the loss for every position, but zeroing out the masked positions in both the numerator and denominator when we calculate the mean, which yields exactly the same result as the first block while maintaining XLA compatibility. Note that we use the same trick as in rule #1 - converting a `tf.bool` to `tf.float32` and using it as an indicator variable. This is a really useful trick, so remember it if you need to convert your own code to XLA!\n\n#### XLA Rule #3: XLA will need to recompile your model for every different input shape it sees\n\nThis is the big one. What this means is that if your input shapes are very variable, XLA will have to recompile your model over and over, which will create huge performance problems. This commonly arises in NLP models, where input texts have variable lengths after tokenization. In other modalities, static shapes are more common and this rule is much less of a problem.\n\nHow can you get around rule #3? The key is **padding** - if you pad all your inputs to the same length, and then use an `attention_mask`, you can get the same results as you\u2019d get from variable shapes, but without any XLA issues. However, excessive padding can cause severe slowdown too - if you pad all your samples to the maximum length in the whole dataset, you might end up with batches consisting endless padding tokens, which will waste a lot of compute and memory!\n\nThere isn\u2019t a perfect solution to this problem. However, you can try some tricks. One very useful trick is to **pad batches of samples up to a multiple of a number like 32 or 64 tokens.** This often only increases the number of tokens by a small amount, but it hugely reduces the number of unique input shapes, because every input shape now has to be a multiple of 32 or 64. Fewer unique input shapes means fewer XLA compilations!\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** Our tokenizers and data collators have methods that can help you here. You can use `padding=\"max_length\"` or `padding=\"longest\"` when calling tokenizers to get them to output padded data. Our tokenizers and data collators also have a `pad_to_multiple_of` argument that you can use to reduce the number of unique input shapes you see!\n\n</Tip>\n\n### How do I actually train my model on TPU?\n\nOnce your training is XLA-compatible and (if you\u2019re using TPU Node / Colab) your dataset has been prepared appropriately, running on TPU is surprisingly easy! All you really need to change in your code is to add a few lines to initialize your TPU, and to ensure that your model and dataset are created inside a `TPUStrategy` scope. Take a look at [our TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) to see this in action!\n\n### Summary\n\nThere was a lot in here, so let\u2019s summarize with a quick checklist you can follow when you want to get your model ready for TPU training:\n\n- Make sure your code follows the three rules of XLA\n- Compile your model with `jit_compile=True` on CPU/GPU and confirm that you can train it with XLA\n- Either load your dataset into memory or use a TPU-compatible dataset loading approach (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Migrate your code either to Colab (with accelerator set to \u201cTPU\u201d) or a TPU VM on Google Cloud\n- Add TPU initializer code (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Create your `TPUStrategy` and make sure dataset loading and model creation are inside the `strategy.scope()` (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Don\u2019t forget to take `jit_compile=True` out again when you move to TPU!\n- \ud83d\ude4f\ud83d\ude4f\ud83d\ude4f\ud83e\udd7a\ud83e\udd7a\ud83e\udd7a\n- Call model.fit()\n- You did it!\n--New Chunk--\n[Created at: 2025-03-24 13:17:32]\n!--Copyright 2023 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\nthe License. You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under the License is distributed on\nan \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n\n\u26a0\ufe0f Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be\nrendered properly in your Markdown viewer.\n\n-->\n\n# Training on TPU with TensorFlow\n\n<Tip>\n\nIf you don't need long explanations and just want TPU code samples to get started with, check out [our TPU example notebook!](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb)\n\n</Tip>\n\n### What is a TPU?\n\nA TPU is a **Tensor Processing Unit.** They are hardware designed by Google, which are used to greatly speed up the tensor computations within neural networks, much like GPUs. They can be used for both network training and inference. They are generally accessed through Google\u2019s cloud services, but small TPUs can also be accessed directly for free through Google Colab and Kaggle Kernels.\n\nBecause [all TensorFlow models in \ud83e\udd17 Transformers are Keras models](https://huggingface.co/blog/tensorflow-philosophy), most of the methods in this document are generally applicable to TPU training for any Keras model! However, there are a few points that are specific to the HuggingFace ecosystem (hug-o-system?) of Transformers and Datasets, and we\u2019ll make sure to flag them up when we get to them.\n\n### What kinds of TPU are available?\n\nNew users are often very confused by the range of TPUs, and the different ways to access them. The first key distinction to understand is the difference between **TPU Nodes** and **TPU VMs.**\n\nWhen you use a **TPU Node**, you are effectively indirectly accessing a remote TPU. You will need a separate VM, which will initialize your network and data pipeline and then forward them to the remote node. When you use a TPU on Google Colab, you are accessing it in the **TPU Node** style.\n\nUsing TPU Nodes can have some quite unexpected behaviour for people who aren\u2019t used to them! In particular, because the TPU is located on a physically different system to the machine you\u2019re running your Python code on, your data cannot be local to your machine - any data pipeline that loads from your machine\u2019s internal storage will totally fail! Instead, data must be stored in Google Cloud Storage where your data pipeline can still access it, even when the pipeline is running on the remote TPU node.\n\n<Tip>\n\nIf you can fit all your data in memory as `np.ndarray` or `tf.Tensor`, then you can `fit()` on that data even when using Colab or a TPU Node, without needing to upload it to Google Cloud Storage.\n\n</Tip>\n\n<Tip>\n\n**\ud83e\udd17Specific Hugging Face Tip\ud83e\udd17:** The methods `Dataset.to_tf_dataset()` and its higher-level wrapper `model.prepare_tf_dataset()` , which you will see throughout our TF code examples, will both fail on a TPU Node. The reason for this is that even though they create a `tf.data.Dataset` it is not a \u201cpure\u201d `tf.data` pipeline and uses `tf.numpy_function` or `Dataset.from_generator()` to stream data from the underlying HuggingFace `Dataset`. This HuggingFace `Dataset` is backed by data that is on a local disc and which the remote TPU Node will not be able to read.\n\n</Tip>\n\nThe second way to access a TPU is via a **TPU VM.** When using a TPU VM, you connect directly to the machine that the TPU is attached to, much like training on a GPU VM. TPU VMs are generally easier to work with, particularly when it comes to your data pipeline. All of the above warnings do not apply to TPU VMs!\n\nThis is an opinionated document, so here\u2019s our opinion: **Avoid using TPU Node if possible.** It is more confusing and more difficult to debug than TPU VMs. It is also likely to be unsupported in future - Google\u2019s latest TPU, TPUv4, can only be accessed as a TPU VM, which suggests that TPU Nodes are increasingly going to become a \u201clegacy\u201d access method. However, we understand that the only free TPU access is on Colab and Kaggle Kernels, which uses TPU Node - so we\u2019ll try to explain how to handle it if you have to! Check the [TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) for code samples that explain this in more detail.\n\n### What sizes of TPU are available?\n\nA single TPU (a v2-8/v3-8/v4-8) runs 8 replicas. TPUs exist in **pods** that can run hundreds or thousands of replicas simultaneously. When you use more than a single TPU but less than a whole pod (for example, a v3-32), your TPU fleet is referred to as a **pod slice.**\n\nWhen you access a free TPU via Colab, you generally get a single v2-8 TPU.\n\n### I keep hearing about this XLA thing. What\u2019s XLA, and how does it relate to TPUs?\n\nXLA is an optimizing compiler, used by both TensorFlow and JAX. In JAX it is the only compiler, whereas in TensorFlow it is optional"
        }
    },
    {
        "context": "```python\nif tf.reduce_sum(tensor) > 10:\n    tensor = tensor / 2.0\n```\n\nThis might seem very restrictive at first, but most neural net code doesn\u2019t need to do this. You can often get around this restriction by using `tf.cond` (see the documentation [here](https://www.tensorflow.org/api_docs/python/tf/cond)) or by removing the conditional and finding a clever math trick with indicator variables instead, like so:\n\n```python\nsum_over_10 = tf.cast(tf.reduce_sum(tensor) > 10, tf.float32)\ntensor = tensor / (1.0 + sum_over_10)\n```\n\nThis code has exactly the same effect as the code above, but by avoiding a conditional, we ensure it will compile with XLA without problems!\n\n#### XLA Rule #2: Your code cannot have \u201cdata-dependent shapes\u201d\n\nWhat this means is that the shape of all of the `tf.Tensor` objects in your code cannot depend on their values. For example, the function `tf.unique` cannot be compiled with XLA, because it returns a `tensor` containing one instance of each unique value in the input. The shape of this output will obviously be different depending on how repetitive the input `Tensor` was, and so XLA refuses to handle it!\n\nIn general, most neural network code obeys rule #2 by default. However, there are a few common cases where it becomes a problem. One very common one is when you use **label masking**, setting your labels to a negative value to indicate that those positions should be ignored when computing the loss. If you look at NumPy or PyTorch loss functions that support label masking, you will often see code like this that uses [boolean indexing](https://numpy.org/doc/stable/user/basics.indexing.html#boolean-array-indexing):\n\n```python\nlabel_mask = labels >= 0\nmasked_outputs = outputs[label_mask]\nmasked_labels = labels[label_mask]\nloss = compute_loss(masked_outputs, masked_labels)\nmean_loss = torch.mean(loss)\n```",
        "question": "Why can't the function tf.unique be compiled with XLA?",
        "answer": "Because it returns a tensor containing one instance of each unique value in the input, and the shape of this output will obviously be different depending on how repetitive the input Tensor was.",
        "source_doc": "huggingface/transformers/blob/main/docs/source/en/perf_train_tpu_tf.md",
        "rag_answer": null,
        "rag_context": null,
        "rag_score": null,
        "rag_feedback": null
    },
    {
        "context": "```python\nif tf.reduce_sum(tensor) > 10:\n    tensor = tensor / 2.0\n```\n\nThis might seem very restrictive at first, but most neural net code doesn\u2019t need to do this. You can often get around this restriction by using `tf.cond` (see the documentation [here](https://www.tensorflow.org/api_docs/python/tf/cond)) or by removing the conditional and finding a clever math trick with indicator variables instead, like so:\n\n```python\nsum_over_10 = tf.cast(tf.reduce_sum(tensor) > 10, tf.float32)\ntensor = tensor / (1.0 + sum_over_10)\n```\n\nThis code has exactly the same effect as the code above, but by avoiding a conditional, we ensure it will compile with XLA without problems!\n\n#### XLA Rule #2: Your code cannot have \u201cdata-dependent shapes\u201d\n\nWhat this means is that the shape of all of the `tf.Tensor` objects in your code cannot depend on their values. For example, the function `tf.unique` cannot be compiled with XLA, because it returns a `tensor` containing one instance of each unique value in the input. The shape of this output will obviously be different depending on how repetitive the input `Tensor` was, and so XLA refuses to handle it!\n\nIn general, most neural network code obeys rule #2 by default. However, there are a few common cases where it becomes a problem. One very common one is when you use **label masking**, setting your labels to a negative value to indicate that those positions should be ignored when computing the loss. If you look at NumPy or PyTorch loss functions that support label masking, you will often see code like this that uses [boolean indexing](https://numpy.org/doc/stable/user/basics.indexing.html#boolean-array-indexing):\n\n```python\nlabel_mask = labels >= 0\nmasked_outputs = outputs[label_mask]\nmasked_labels = labels[label_mask]\nloss = compute_loss(masked_outputs, masked_labels)\nmean_loss = torch.mean(loss)\n```",
        "question": "What is a common case where XLA Rule #2 becomes a problem in neural network code?",
        "answer": "When you use label masking, setting your labels to a negative value to indicate that those positions should be ignored when computing the loss.",
        "source_doc": "huggingface/transformers/blob/main/docs/source/en/perf_train_tpu_tf.md",
        "rag_answer": null,
        "rag_context": null,
        "rag_score": null,
        "rag_feedback": null
    },
    {
        "context": "```python\nlabel_mask = labels >= 0\nmasked_outputs = outputs[label_mask]\nmasked_labels = labels[label_mask]\nloss = compute_loss(masked_outputs, masked_labels)\nmean_loss = torch.mean(loss)\n```\n\nThis code is totally fine in NumPy or PyTorch, but it breaks in XLA! Why? Because the shape of `masked_outputs` and `masked_labels` depends on how many positions are masked - that makes it a **data-dependent shape.** However, just like for rule #1, we can often rewrite this code to yield exactly the same output without any data-dependent shapes.\n\n```python\nlabel_mask = tf.cast(labels >= 0, tf.float32)\nloss = compute_loss(outputs, labels)\nloss = loss * label_mask  # Set negative label positions to 0\nmean_loss = tf.reduce_sum(loss) / tf.reduce_sum(label_mask)\n```\n\nHere, we avoid data-dependent shapes by computing the loss for every position, but zeroing out the masked positions in both the numerator and denominator when we calculate the mean, which yields exactly the same result as the first block while maintaining XLA compatibility. Note that we use the same trick as in rule #1 - converting a `tf.bool` to `tf.float32` and using it as an indicator variable. This is a really useful trick, so remember it if you need to convert your own code to XLA!\n\n#### XLA Rule #3: XLA will need to recompile your model for every different input shape it sees\n\nThis is the big one. What this means is that if your input shapes are very variable, XLA will have to recompile your model over and over, which will create huge performance problems. This commonly arises in NLP models, where input texts have variable lengths after tokenization. In other modalities, static shapes are more common and this rule is much less of a problem.",
        "question": "Why does the code break in XLA?",
        "answer": "Because the shape of `masked_outputs` and `masked_labels` depends on how many positions are masked, making it a data-dependent shape.",
        "source_doc": "huggingface/transformers/blob/main/docs/source/en/perf_train_tpu_tf.md",
        "rag_answer": null,
        "rag_context": null,
        "rag_score": null,
        "rag_feedback": null
    },
    {
        "sample_idx": 68,
        "question": "How can the code be rewritten to avoid data-dependent shapes?",
        "answer": "By computing the loss for every position and zeroing out the masked positions in both the numerator and denominator when calculating the mean.",
        "rag_answer": "To avoid data-dependent shapes, you can rewrite the code by computing the loss for every position and then zeroing out the masked positions in both the numerator and denominator when calculating the mean. Here's an example:\n\n```python\nlabel_mask = tf.cast(labels >= 0, tf.float32)\nloss = compute_loss(outputs, labels)\nloss = loss * label_mask  # Set negative label positions to 0\nmean_loss = tf.reduce_sum(loss) / tf.reduce_sum(label_mask)\n```\n\nThis rewritten code maintains XLA compatibility by avoiding data-dependent shapes. It achieves the same result as the original code but uses a different approach to handle label masking.\n\nReferences:\n[DC] label_mask  # Set negative label positions to 0\nmean_loss = tf.reduce_sum(loss) / tf.reduce_sum(label_mask)",
        "rag_score": 5,
        "rag_feedback": "The system's response is completely correct, accurate, and factual. It provides a clear and detailed explanation of how to avoid data-dependent shapes when computing the loss for every position and zeroing out the masked positions in both the numerator and denominator when calculating the mean. The response also provides a code example that demonstrates how to achieve this, which is identical to the expected answer.",
        "rag_context": {
            "kg_context": "-----Entities-----\n    ```csv\n    id,\tentity,\ttype,\tdescription,\trankcreated_at\n1,\tTPU,technology,TPU is a Tensor Processing Unit, a hardware designed by Google to speed up tensor computations within neural networks.<SEP>TPU is a type of hardware accelerator designed for machine learning workloads.<SEP>TPU is a type of hardware accelerator used for machine learning computations.,4,2025-03-24 13:18:20\n2,\tXLA,technology,XLA is a technology that compiles TensorFlow graphs into executable code for various platforms.<SEP>XLA is an optimizing compiler used by TensorFlow and JAX to improve performance.<SEP>XLA is an optimizing compiler, used by both TensorFlow and JAX to optimize computations.,6,2025-03-24 13:18:20\n3,\tTensorFlow,category,TensorFlow is a machine learning framework that uses XLA as an optimizing compiler.<SEP>TensorFlow is a software framework used for building and training neural networks.<SEP>TensorFlow is an open-source machine learning framework.,3,2025-03-24 13:18:20\n4,\tKeras,category,Keras is a high-level neural networks API, used for building and training neural networks.<SEP>Keras is a machine learning framework that uses XLA for optimization.,2,2025-03-24 13:18:20\n5,\tTensorFlow,category,TensorFlow is a machine learning framework that uses XLA as an optimizing compiler.<SEP>TensorFlow is a software framework used for building and training neural networks.<SEP>TensorFlow is an open-source machine learning framework.,3,UNKNOWN\n6,\tGoogle,organization,Google is the company that designs and provides TPUs, which are used to speed up tensor computations within neural networks.,3,UNKNOWN\n7,\tCORD,geo,CORD is a form understanding dataset used for fine-tuning LayoutLMv3.,1,UNKNOWN\n    ```\n    -----Relationships-----\n    ```csv\n    id,\tsource,\ttarget,\tdescription,\tkeywords,\tweight,\trank,\tcreated_at\n1,\tTPU,XLA,XLA compiles TensorFlow graphs into executable code for TPU hardware.<SEP>XLA is used to optimize code for TPU hardware.,compilation, hardware acceleration<SEP>compiler, hardware optimization,36.0,10,2025-03-24 13:18:20\n2,\tTensorFlow,XLA,TensorFlow graphs can be compiled into executable code using XLA.<SEP>TensorFlow uses XLA as an optimizing compiler to improve performance.,compilation, framework support<SEP>compiler, performance optimization,23.0,9,2025-03-24 13:18:20\n3,\tKeras,XLA,Keras uses XLA for optimization.,compiler, performance optimization,8.0,8,2025-03-24 13:18:20\n4,\tCORD,LayoutLMv3,CORD is a dataset used for fine-tuning the LayoutLMv3 model.,dataset, model training,14.0,12,UNKNOWN\n5,\tTensorFlow,XLA,TensorFlow graphs can be compiled into executable code using XLA.<SEP>TensorFlow uses XLA as an optimizing compiler to improve performance.,compilation, framework support<SEP>compiler, performance optimization,23.0,9,UNKNOWN\n6,\tHuggingFace,TensorFlow,HuggingFace provides a range of AI models and tools, including the Transformers and Datasets ecosystem, which are built on top of TensorFlow.,ecosystem integration, AI models,18.0,8,UNKNOWN\n7,\tGoogle,TPU,Google designs and provides TPUs, which are used to speed up tensor computations within neural networks.,hardware design, acceleration,18.0,7,UNKNOWN\n8,\tColab,Google,Colab is a cloud-based platform provided by Google for data science and machine learning.,platform provision, cloud computing,16.0,6,UNKNOWN\n9,\tKeras,TensorFlow,TensorFlow uses Keras as a high-level neural networks API.,API integration, neural networks,16.0,5,UNKNOWN\n10,\tGoogle,Kaggle Kernels,Kaggle Kernels is a cloud-based platform provided by Google for data science and machine learning competitions.,platform provision, cloud computing,16.0,4,UNKNOWN\n    ```\n    -----Sources-----\n    ```csv\n    id,\tcontent\n1,\t(for example, a v3-32), your TPU fleet is referred to as a **pod slice.**\n\nWhen you access a free TPU via Colab, you generally get a single v2-8 TPU.\n\n### I keep hearing about this XLA thing. What\u2019s XLA, and how does it relate to TPUs?\n\nXLA is an optimizing compiler, used by both TensorFlow and JAX. In JAX it is the only compiler, whereas in TensorFlow it is optional (but mandatory on TPU!). The easiest way to enable it when training a Keras model is to pass the argument `jit_compile=True` to `model.compile()`. If you don\u2019t get any errors and performance is good, that\u2019s a great sign that you\u2019re ready to move to TPU!\n\nDebugging on TPU is generally a bit harder than on CPU/GPU, so we recommend getting your code running on CPU/GPU with XLA first before trying it on TPU. You don\u2019t have to train for long, of course - just for a few steps to make sure that your model and data pipeline are working like you expect them to.\n\n<Tip>\n\nXLA compiled code is usually faster - so even if you\u2019re not planning to run on TPU, adding `jit_compile=True` can improve your performance. Be sure to note the caveats below about XLA compatibility, though!\n\n</Tip>\n\n<Tip warning={true}>\n\n**Tip born of painful experience:** Although using `jit_compile=True` is a good way to get a speed boost and test if your CPU/GPU code is XLA-compatible, it can actually cause a lot of problems if you leave it in when actually training on TPU. XLA compilation will happen implicitly on TPU, so remember to remove that line before actually running your code on a TPU!\n\n</Tip>\n\n### How do I make my model XLA compatible?\n\nIn many cases, your code is probably XLA-compatible already! However, there are a few things that work in normal TensorFlow that don\u2019t work in XLA. We\u2019ve distilled them into three core rules below:\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** We\u2019ve put a lot of effort into rewriting our TensorFlow models and loss functions to be XLA-compatible. Our models and loss functions generally obey rule #1 and #2 by default, so you can skip over them if you\u2019re using `transformers` models. Don\u2019t forget about these rules when writing your own models and loss functions, though!\n\n</Tip>\n\n#### XLA Rule #1: Your code cannot have \u201cdata-dependent conditionals\u201d\n\nWhat that means is that any `if` statement cannot depend on values inside a `tf.Tensor`. For example, this code block cannot be compiled with XLA!\n\n```python\nif tf.reduce_sum(tensor) > 10:\n    tensor = tensor / 2.0\n```\n\nThis might seem very restrictive at first, but most neural net code doesn\u2019t need to do this. You can often get around this restriction by using `tf.cond` (see the documentation [here](https://www.tensorflow.org/api_docs/python/tf/cond)) or by removing the conditional and finding a clever math trick with indicator variables instead, like so:\n\n```python\nsum_over_10 = tf.cast(tf.reduce_sum(tensor) > 10, tf.float32)\ntensor = tensor / (1.0 + sum_over_10)\n```\n\nThis code has exactly the same effect as the code above, but by avoiding a conditional, we ensure it will compile with XLA without problems!\n\n#### XLA Rule #2: Your code cannot have \u201cdata-dependent shapes\u201d\n\nWhat this means is that the shape of all of the `tf.Tensor` objects in your code cannot depend on their values. For example, the function `tf.unique` cannot be compiled with XLA, because it returns a `tensor` containing one instance of each unique value in the input. The shape of this output will obviously be different depending on how repetitive the input `Tensor` was, and so XLA refuses to handle it!\n\nIn general, most neural network code obeys rule #2 by default. However, there are a few common cases where it becomes a problem. One very common one is when you use **label masking**, setting your labels to a negative value to indicate that those positions should be ignored when computing the loss. If you look at NumPy or PyTorch loss functions that support label masking, you will often see code like this that uses [boolean indexing](https://numpy.org/doc/stable/user/basics.indexing.html#boolean-array-indexing):\n\n```python\nlabel_mask = labels >= 0\nmasked_outputs = outputs[label_mask]\nmasked_labels = labels[label_mask]\nloss = compute_loss(masked_outputs, masked_labels)\nmean_loss = torch.mean(loss)\n```\n\nThis code is totally fine in NumPy or PyTorch, but it breaks in XLA! Why? Because the shape of `masked_outputs` and `masked_labels` depends on how many positions are masked - that makes it a **data-dependent shape.** However, just like for rule #1, we can often rewrite this code to yield exactly the same output without any data-dependent shapes.\n\n```python\nlabel_mask = tf.cast(labels >= 0, tf.float32)\nloss = compute_loss(outputs, labels)\nloss = loss * label_mask  # Set negative label positions to 0\nmean_loss = tf.reduce_sum(loss) / tf.reduce_sum(label_mask)\n```\n\nHere, we avoid data-dependent shapes by computing the loss for every position, but zeroing out the masked positions in both the numerator and denominator when we calculate the mean, which yields exactly the same result as the first block while maintaining XLA compatibility. Note that we use the same trick as in rule #1 - converting a `tf.bool` to `\n2,\tlabel_mask  # Set negative label positions to 0\nmean_loss = tf.reduce_sum(loss) / tf.reduce_sum(label_mask)\n```\n\nHere, we avoid data-dependent shapes by computing the loss for every position, but zeroing out the masked positions in both the numerator and denominator when we calculate the mean, which yields exactly the same result as the first block while maintaining XLA compatibility. Note that we use the same trick as in rule #1 - converting a `tf.bool` to `tf.float32` and using it as an indicator variable. This is a really useful trick, so remember it if you need to convert your own code to XLA!\n\n#### XLA Rule #3: XLA will need to recompile your model for every different input shape it sees\n\nThis is the big one. What this means is that if your input shapes are very variable, XLA will have to recompile your model over and over, which will create huge performance problems. This commonly arises in NLP models, where input texts have variable lengths after tokenization. In other modalities, static shapes are more common and this rule is much less of a problem.\n\nHow can you get around rule #3? The key is **padding** - if you pad all your inputs to the same length, and then use an `attention_mask`, you can get the same results as you\u2019d get from variable shapes, but without any XLA issues. However, excessive padding can cause severe slowdown too - if you pad all your samples to the maximum length in the whole dataset, you might end up with batches consisting endless padding tokens, which will waste a lot of compute and memory!\n\nThere isn\u2019t a perfect solution to this problem. However, you can try some tricks. One very useful trick is to **pad batches of samples up to a multiple of a number like 32 or 64 tokens.** This often only increases the number of tokens by a small amount, but it hugely reduces the number of unique input shapes, because every input shape now has to be a multiple of 32 or 64. Fewer unique input shapes means fewer XLA compilations!\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** Our tokenizers and data collators have methods that can help you here. You can use `padding=\"max_length\"` or `padding=\"longest\"` when calling tokenizers to get them to output padded data. Our tokenizers and data collators also have a `pad_to_multiple_of` argument that you can use to reduce the number of unique input shapes you see!\n\n</Tip>\n\n### How do I actually train my model on TPU?\n\nOnce your training is XLA-compatible and (if you\u2019re using TPU Node / Colab) your dataset has been prepared appropriately, running on TPU is surprisingly easy! All you really need to change in your code is to add a few lines to initialize your TPU, and to ensure that your model and dataset are created inside a `TPUStrategy` scope. Take a look at [our TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) to see this in action!\n\n### Summary\n\nThere was a lot in here, so let\u2019s summarize with a quick checklist you can follow when you want to get your model ready for TPU training:\n\n- Make sure your code follows the three rules of XLA\n- Compile your model with `jit_compile=True` on CPU/GPU and confirm that you can train it with XLA\n- Either load your dataset into memory or use a TPU-compatible dataset loading approach (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Migrate your code either to Colab (with accelerator set to \u201cTPU\u201d) or a TPU VM on Google Cloud\n- Add TPU initializer code (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Create your `TPUStrategy` and make sure dataset loading and model creation are inside the `strategy.scope()` (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Don\u2019t forget to take `jit_compile=True` out again when you move to TPU!\n- \ud83d\ude4f\ud83d\ude4f\ud83d\ude4f\ud83e\udd7a\ud83e\udd7a\ud83e\udd7a\n- Call model.fit()\n- You did it!\n3,\t!--Copyright 2023 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\nthe License. You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under the License is distributed on\nan \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n\n\u26a0\ufe0f Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be\nrendered properly in your Markdown viewer.\n\n-->\n\n# Training on TPU with TensorFlow\n\n<Tip>\n\nIf you don't need long explanations and just want TPU code samples to get started with, check out [our TPU example notebook!](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb)\n\n</Tip>\n\n### What is a TPU?\n\nA TPU is a **Tensor Processing Unit.** They are hardware designed by Google, which are used to greatly speed up the tensor computations within neural networks, much like GPUs. They can be used for both network training and inference. They are generally accessed through Google\u2019s cloud services, but small TPUs can also be accessed directly for free through Google Colab and Kaggle Kernels.\n\nBecause [all TensorFlow models in \ud83e\udd17 Transformers are Keras models](https://huggingface.co/blog/tensorflow-philosophy), most of the methods in this document are generally applicable to TPU training for any Keras model! However, there are a few points that are specific to the HuggingFace ecosystem (hug-o-system?) of Transformers and Datasets, and we\u2019ll make sure to flag them up when we get to them.\n\n### What kinds of TPU are available?\n\nNew users are often very confused by the range of TPUs, and the different ways to access them. The first key distinction to understand is the difference between **TPU Nodes** and **TPU VMs.**\n\nWhen you use a **TPU Node**, you are effectively indirectly accessing a remote TPU. You will need a separate VM, which will initialize your network and data pipeline and then forward them to the remote node. When you use a TPU on Google Colab, you are accessing it in the **TPU Node** style.\n\nUsing TPU Nodes can have some quite unexpected behaviour for people who aren\u2019t used to them! In particular, because the TPU is located on a physically different system to the machine you\u2019re running your Python code on, your data cannot be local to your machine - any data pipeline that loads from your machine\u2019s internal storage will totally fail! Instead, data must be stored in Google Cloud Storage where your data pipeline can still access it, even when the pipeline is running on the remote TPU node.\n\n<Tip>\n\nIf you can fit all your data in memory as `np.ndarray` or `tf.Tensor`, then you can `fit()` on that data even when using Colab or a TPU Node, without needing to upload it to Google Cloud Storage.\n\n</Tip>\n\n<Tip>\n\n**\ud83e\udd17Specific Hugging Face Tip\ud83e\udd17:** The methods `Dataset.to_tf_dataset()` and its higher-level wrapper `model.prepare_tf_dataset()` , which you will see throughout our TF code examples, will both fail on a TPU Node. The reason for this is that even though they create a `tf.data.Dataset` it is not a \u201cpure\u201d `tf.data` pipeline and uses `tf.numpy_function` or `Dataset.from_generator()` to stream data from the underlying HuggingFace `Dataset`. This HuggingFace `Dataset` is backed by data that is on a local disc and which the remote TPU Node will not be able to read.\n\n</Tip>\n\nThe second way to access a TPU is via a **TPU VM.** When using a TPU VM, you connect directly to the machine that the TPU is attached to, much like training on a GPU VM. TPU VMs are generally easier to work with, particularly when it comes to your data pipeline. All of the above warnings do not apply to TPU VMs!\n\nThis is an opinionated document, so here\u2019s our opinion: **Avoid using TPU Node if possible.** It is more confusing and more difficult to debug than TPU VMs. It is also likely to be unsupported in future - Google\u2019s latest TPU, TPUv4, can only be accessed as a TPU VM, which suggests that TPU Nodes are increasingly going to become a \u201clegacy\u201d access method. However, we understand that the only free TPU access is on Colab and Kaggle Kernels, which uses TPU Node - so we\u2019ll try to explain how to handle it if you have to! Check the [TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) for code samples that explain this in more detail.\n\n### What sizes of TPU are available?\n\nA single TPU (a v2-8/v3-8/v4-8) runs 8 replicas. TPUs exist in **pods** that can run hundreds or thousands of replicas simultaneously. When you use more than a single TPU but less than a whole pod (for example, a v3-32), your TPU fleet is referred to as a **pod slice.**\n\nWhen you access a free TPU via Colab, you generally get a single v2-8 TPU.\n\n### I keep hearing about this XLA thing. What\u2019s XLA, and how does it relate to TPUs?\n\nXLA is an optimizing compiler, used by both TensorFlow and JAX. In JAX it is the only compiler, whereas in TensorFlow it is optional\n    ```",
            "vector_context": "[Created at: 2025-03-24 13:17:32]\nlabel_mask  # Set negative label positions to 0\nmean_loss = tf.reduce_sum(loss) / tf.reduce_sum(label_mask)\n```\n\nHere, we avoid data-dependent shapes by computing the loss for every position, but zeroing out the masked positions in both the numerator and denominator when we calculate the mean, which yields exactly the same result as the first block while maintaining XLA compatibility. Note that we use the same trick as in rule #1 - converting a `tf.bool` to `tf.float32` and using it as an indicator variable. This is a really useful trick, so remember it if you need to convert your own code to XLA!\n\n#### XLA Rule #3: XLA will need to recompile your model for every different input shape it sees\n\nThis is the big one. What this means is that if your input shapes are very variable, XLA will have to recompile your model over and over, which will create huge performance problems. This commonly arises in NLP models, where input texts have variable lengths after tokenization. In other modalities, static shapes are more common and this rule is much less of a problem.\n\nHow can you get around rule #3? The key is **padding** - if you pad all your inputs to the same length, and then use an `attention_mask`, you can get the same results as you\u2019d get from variable shapes, but without any XLA issues. However, excessive padding can cause severe slowdown too - if you pad all your samples to the maximum length in the whole dataset, you might end up with batches consisting endless padding tokens, which will waste a lot of compute and memory!\n\nThere isn\u2019t a perfect solution to this problem. However, you can try some tricks. One very useful trick is to **pad batches of samples up to a multiple of a number like 32 or 64 tokens.** This often only increases the number of tokens by a small amount, but it hugely reduces the number of unique input shapes, because every input shape now has to be a multiple of 32 or 64. Fewer unique input shapes means fewer XLA compilations!\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** Our tokenizers and data collators have methods that can help you here. You can use `padding=\"max_length\"` or `padding=\"longest\"` when calling tokenizers to get them to output padded data. Our tokenizers and data collators also have a `pad_to_multiple_of` argument that you can use to reduce the number of unique input shapes you see!\n\n</Tip>\n\n### How do I actually train my model on TPU?\n\nOnce your training is XLA-compatible and (if you\u2019re using TPU Node / Colab) your dataset has been prepared appropriately, running on TPU is surprisingly easy! All you really need to change in your code is to add a few lines to initialize your TPU, and to ensure that your model and dataset are created inside a `TPUStrategy` scope. Take a look at [our TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) to see this in action!\n\n### Summary\n\nThere was a lot in here, so let\u2019s summarize with a quick checklist you can follow when you want to get your model ready for TPU training:\n\n- Make sure your code follows the three rules of XLA\n- Compile your model with `jit_compile=True` on CPU/GPU and confirm that you can train it with XLA\n- Either load your dataset into memory or use a TPU-compatible dataset loading approach (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Migrate your code either to Colab (with accelerator set to \u201cTPU\u201d) or a TPU VM on Google Cloud\n- Add TPU initializer code (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Create your `TPUStrategy` and make sure dataset loading and model creation are inside the `strategy.scope()` (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Don\u2019t forget to take `jit_compile=True` out again when you move to TPU!\n- \ud83d\ude4f\ud83d\ude4f\ud83d\ude4f\ud83e\udd7a\ud83e\udd7a\ud83e\udd7a\n- Call model.fit()\n- You did it!\n--New Chunk--\n[Created at: 2025-03-24 13:16:13]\n=predictions, references=references)\n>>> results\n{'exact_match': 100.0, 'f1': 100.0}\n```\n\nYou can find examples of dataset structures by consulting the \"Dataset Preview\" function or the dataset card for a given dataset, and you can see how to use its dedicated evaluation function based on the metric card.\n--New Chunk--\n[Created at: 2025-03-24 13:17:32]\n(for example, a v3-32), your TPU fleet is referred to as a **pod slice.**\n\nWhen you access a free TPU via Colab, you generally get a single v2-8 TPU.\n\n### I keep hearing about this XLA thing. What\u2019s XLA, and how does it relate to TPUs?\n\nXLA is an optimizing compiler, used by both TensorFlow and JAX. In JAX it is the only compiler, whereas in TensorFlow it is optional (but mandatory on TPU!). The easiest way to enable it when training a Keras model is to pass the argument `jit_compile=True` to `model.compile()`. If you don\u2019t get any errors and performance is good, that\u2019s a great sign that you\u2019re ready to move to TPU!\n\nDebugging on TPU is generally a bit harder than on CPU/GPU, so we recommend getting your code running on CPU/GPU with XLA first before trying it on TPU. You don\u2019t have to train for long, of course - just for a few steps to make sure that your model and data pipeline are working like you expect them to.\n\n<Tip>\n\nXLA compiled code is usually faster - so even if you\u2019re not planning to run on TPU, adding `jit_compile=True` can improve your performance. Be sure to note the caveats below about XLA compatibility, though!\n\n</Tip>\n\n<Tip warning={true}>\n\n**Tip born of painful experience:** Although using `jit_compile=True` is a good way to get a speed boost and test if your CPU/GPU code is XLA-compatible, it can actually cause a lot of problems if you leave it in when actually training on TPU. XLA compilation will happen implicitly on TPU, so remember to remove that line before actually running your code on a TPU!\n\n</Tip>\n\n### How do I make my model XLA compatible?\n\nIn many cases, your code is probably XLA-compatible already! However, there are a few things that work in normal TensorFlow that don\u2019t work in XLA. We\u2019ve distilled them into three core rules below:\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** We\u2019ve put a lot of effort into rewriting our TensorFlow models and loss functions to be XLA-compatible. Our models and loss functions generally obey rule #1 and #2 by default, so you can skip over them if you\u2019re using `transformers` models. Don\u2019t forget about these rules when writing your own models and loss functions, though!\n\n</Tip>\n\n#### XLA Rule #1: Your code cannot have \u201cdata-dependent conditionals\u201d\n\nWhat that means is that any `if` statement cannot depend on values inside a `tf.Tensor`. For example, this code block cannot be compiled with XLA!\n\n```python\nif tf.reduce_sum(tensor) > 10:\n    tensor = tensor / 2.0\n```\n\nThis might seem very restrictive at first, but most neural net code doesn\u2019t need to do this. You can often get around this restriction by using `tf.cond` (see the documentation [here](https://www.tensorflow.org/api_docs/python/tf/cond)) or by removing the conditional and finding a clever math trick with indicator variables instead, like so:\n\n```python\nsum_over_10 = tf.cast(tf.reduce_sum(tensor) > 10, tf.float32)\ntensor = tensor / (1.0 + sum_over_10)\n```\n\nThis code has exactly the same effect as the code above, but by avoiding a conditional, we ensure it will compile with XLA without problems!\n\n#### XLA Rule #2: Your code cannot have \u201cdata-dependent shapes\u201d\n\nWhat this means is that the shape of all of the `tf.Tensor` objects in your code cannot depend on their values. For example, the function `tf.unique` cannot be compiled with XLA, because it returns a `tensor` containing one instance of each unique value in the input. The shape of this output will obviously be different depending on how repetitive the input `Tensor` was, and so XLA refuses to handle it!\n\nIn general, most neural network code obeys rule #2 by default. However, there are a few common cases where it becomes a problem. One very common one is when you use **label masking**, setting your labels to a negative value to indicate that those positions should be ignored when computing the loss. If you look at NumPy or PyTorch loss functions that support label masking, you will often see code like this that uses [boolean indexing](https://numpy.org/doc/stable/user/basics.indexing.html#boolean-array-indexing):\n\n```python\nlabel_mask = labels >= 0\nmasked_outputs = outputs[label_mask]\nmasked_labels = labels[label_mask]\nloss = compute_loss(masked_outputs, masked_labels)\nmean_loss = torch.mean(loss)\n```\n\nThis code is totally fine in NumPy or PyTorch, but it breaks in XLA! Why? Because the shape of `masked_outputs` and `masked_labels` depends on how many positions are masked - that makes it a **data-dependent shape.** However, just like for rule #1, we can often rewrite this code to yield exactly the same output without any data-dependent shapes.\n\n```python\nlabel_mask = tf.cast(labels >= 0, tf.float32)\nloss = compute_loss(outputs, labels)\nloss = loss * label_mask  # Set negative label positions to 0\nmean_loss = tf.reduce_sum(loss) / tf.reduce_sum(label_mask)\n```\n\nHere, we avoid data-dependent shapes by computing the loss for every position, but zeroing out the masked positions in both the numerator and denominator when we calculate the mean, which yields exactly the same result as the first block while maintaining XLA compatibility. Note that we use the same trick as in rule #1 - converting a `tf.bool` to `"
        }
    },
    {
        "sample_idx": 69,
        "question": "What trick is used to convert a `tf.bool` to `tf.float32`?",
        "answer": "Converting a `tf.bool` to `tf.float32` and using it as an indicator variable.",
        "rag_answer": "The trick used to convert a `tf.bool` to `tf.float32` is by using the `tf.cast` function. Specifically, `tf.cast(tf.bool, tf.float32)` is used to convert a boolean tensor to a float tensor. This is a useful trick when working with XLA-compatible code, as it allows you to use boolean values as indicators in mathematical operations.",
        "rag_score": null,
        "rag_feedback": null,
        "rag_context": {
            "kg_context": "-----Entities-----\n    ```csv\n    id,\tentity,\ttype,\tdescription,\trankcreated_at\n1,\tTPU,technology,TPU is a Tensor Processing Unit, a hardware designed by Google to speed up tensor computations within neural networks.<SEP>TPU is a type of hardware accelerator designed for machine learning workloads.<SEP>TPU is a type of hardware accelerator used for machine learning computations.,4,2025-03-24 13:18:20\n2,\tXLA,technology,XLA is a technology that compiles TensorFlow graphs into executable code for various platforms.<SEP>XLA is an optimizing compiler used by TensorFlow and JAX to improve performance.<SEP>XLA is an optimizing compiler, used by both TensorFlow and JAX to optimize computations.,6,2025-03-24 13:18:20\n3,\tTensorFlow,category,TensorFlow is a machine learning framework that uses XLA as an optimizing compiler.<SEP>TensorFlow is a software framework used for building and training neural networks.<SEP>TensorFlow is an open-source machine learning framework.,3,2025-03-24 13:18:20\n4,\tKeras,category,Keras is a high-level neural networks API, used for building and training neural networks.<SEP>Keras is a machine learning framework that uses XLA for optimization.,2,2025-03-24 13:18:20\n5,\tTF,technology,TF is an abbreviation for TensorFlow.,0,UNKNOWN\n6,\tTensorFlow,category,TensorFlow is a machine learning framework that uses XLA as an optimizing compiler.<SEP>TensorFlow is a software framework used for building and training neural networks.<SEP>TensorFlow is an open-source machine learning framework.,3,UNKNOWN\n7,\tjit_compile,concept,jit_compile is a technique for compiling TensorFlow graphs into executable code.,1,UNKNOWN\n    ```\n    -----Relationships-----\n    ```csv\n    id,\tsource,\ttarget,\tdescription,\tkeywords,\tweight,\trank,\tcreated_at\n1,\tTPU,XLA,XLA compiles TensorFlow graphs into executable code for TPU hardware.<SEP>XLA is used to optimize code for TPU hardware.,compilation, hardware acceleration<SEP>compiler, hardware optimization,36.0,10,2025-03-24 13:18:20\n2,\tTensorFlow,XLA,TensorFlow graphs can be compiled into executable code using XLA.<SEP>TensorFlow uses XLA as an optimizing compiler to improve performance.,compilation, framework support<SEP>compiler, performance optimization,23.0,9,2025-03-24 13:18:20\n3,\tKeras,TensorFlow,TensorFlow uses Keras as a high-level neural networks API.,API integration, neural networks,16.0,5,2025-03-24 13:18:20\n4,\tTensorFlow,XLA,TensorFlow graphs can be compiled into executable code using XLA.<SEP>TensorFlow uses XLA as an optimizing compiler to improve performance.,compilation, framework support<SEP>compiler, performance optimization,23.0,9,UNKNOWN\n5,\tHuggingFace,TensorFlow,HuggingFace provides a range of AI models and tools, including the Transformers and Datasets ecosystem, which are built on top of TensorFlow.,ecosystem integration, AI models,18.0,8,UNKNOWN\n6,\tXLA,jit_compile,jit_compile is a technique used in XLA to compile TensorFlow graphs into executable code.,compilation technique, XLA support,3.0,7,UNKNOWN\n7,\tKeras,TensorFlow,TensorFlow uses Keras as a high-level neural networks API.,API integration, neural networks,16.0,5,UNKNOWN\n    ```\n    -----Sources-----\n    ```csv\n    id,\tcontent\n1,\t(for example, a v3-32), your TPU fleet is referred to as a **pod slice.**\n\nWhen you access a free TPU via Colab, you generally get a single v2-8 TPU.\n\n### I keep hearing about this XLA thing. What\u2019s XLA, and how does it relate to TPUs?\n\nXLA is an optimizing compiler, used by both TensorFlow and JAX. In JAX it is the only compiler, whereas in TensorFlow it is optional (but mandatory on TPU!). The easiest way to enable it when training a Keras model is to pass the argument `jit_compile=True` to `model.compile()`. If you don\u2019t get any errors and performance is good, that\u2019s a great sign that you\u2019re ready to move to TPU!\n\nDebugging on TPU is generally a bit harder than on CPU/GPU, so we recommend getting your code running on CPU/GPU with XLA first before trying it on TPU. You don\u2019t have to train for long, of course - just for a few steps to make sure that your model and data pipeline are working like you expect them to.\n\n<Tip>\n\nXLA compiled code is usually faster - so even if you\u2019re not planning to run on TPU, adding `jit_compile=True` can improve your performance. Be sure to note the caveats below about XLA compatibility, though!\n\n</Tip>\n\n<Tip warning={true}>\n\n**Tip born of painful experience:** Although using `jit_compile=True` is a good way to get a speed boost and test if your CPU/GPU code is XLA-compatible, it can actually cause a lot of problems if you leave it in when actually training on TPU. XLA compilation will happen implicitly on TPU, so remember to remove that line before actually running your code on a TPU!\n\n</Tip>\n\n### How do I make my model XLA compatible?\n\nIn many cases, your code is probably XLA-compatible already! However, there are a few things that work in normal TensorFlow that don\u2019t work in XLA. We\u2019ve distilled them into three core rules below:\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** We\u2019ve put a lot of effort into rewriting our TensorFlow models and loss functions to be XLA-compatible. Our models and loss functions generally obey rule #1 and #2 by default, so you can skip over them if you\u2019re using `transformers` models. Don\u2019t forget about these rules when writing your own models and loss functions, though!\n\n</Tip>\n\n#### XLA Rule #1: Your code cannot have \u201cdata-dependent conditionals\u201d\n\nWhat that means is that any `if` statement cannot depend on values inside a `tf.Tensor`. For example, this code block cannot be compiled with XLA!\n\n```python\nif tf.reduce_sum(tensor) > 10:\n    tensor = tensor / 2.0\n```\n\nThis might seem very restrictive at first, but most neural net code doesn\u2019t need to do this. You can often get around this restriction by using `tf.cond` (see the documentation [here](https://www.tensorflow.org/api_docs/python/tf/cond)) or by removing the conditional and finding a clever math trick with indicator variables instead, like so:\n\n```python\nsum_over_10 = tf.cast(tf.reduce_sum(tensor) > 10, tf.float32)\ntensor = tensor / (1.0 + sum_over_10)\n```\n\nThis code has exactly the same effect as the code above, but by avoiding a conditional, we ensure it will compile with XLA without problems!\n\n#### XLA Rule #2: Your code cannot have \u201cdata-dependent shapes\u201d\n\nWhat this means is that the shape of all of the `tf.Tensor` objects in your code cannot depend on their values. For example, the function `tf.unique` cannot be compiled with XLA, because it returns a `tensor` containing one instance of each unique value in the input. The shape of this output will obviously be different depending on how repetitive the input `Tensor` was, and so XLA refuses to handle it!\n\nIn general, most neural network code obeys rule #2 by default. However, there are a few common cases where it becomes a problem. One very common one is when you use **label masking**, setting your labels to a negative value to indicate that those positions should be ignored when computing the loss. If you look at NumPy or PyTorch loss functions that support label masking, you will often see code like this that uses [boolean indexing](https://numpy.org/doc/stable/user/basics.indexing.html#boolean-array-indexing):\n\n```python\nlabel_mask = labels >= 0\nmasked_outputs = outputs[label_mask]\nmasked_labels = labels[label_mask]\nloss = compute_loss(masked_outputs, masked_labels)\nmean_loss = torch.mean(loss)\n```\n\nThis code is totally fine in NumPy or PyTorch, but it breaks in XLA! Why? Because the shape of `masked_outputs` and `masked_labels` depends on how many positions are masked - that makes it a **data-dependent shape.** However, just like for rule #1, we can often rewrite this code to yield exactly the same output without any data-dependent shapes.\n\n```python\nlabel_mask = tf.cast(labels >= 0, tf.float32)\nloss = compute_loss(outputs, labels)\nloss = loss * label_mask  # Set negative label positions to 0\nmean_loss = tf.reduce_sum(loss) / tf.reduce_sum(label_mask)\n```\n\nHere, we avoid data-dependent shapes by computing the loss for every position, but zeroing out the masked positions in both the numerator and denominator when we calculate the mean, which yields exactly the same result as the first block while maintaining XLA compatibility. Note that we use the same trick as in rule #1 - converting a `tf.bool` to `\n2,\tlabel_mask  # Set negative label positions to 0\nmean_loss = tf.reduce_sum(loss) / tf.reduce_sum(label_mask)\n```\n\nHere, we avoid data-dependent shapes by computing the loss for every position, but zeroing out the masked positions in both the numerator and denominator when we calculate the mean, which yields exactly the same result as the first block while maintaining XLA compatibility. Note that we use the same trick as in rule #1 - converting a `tf.bool` to `tf.float32` and using it as an indicator variable. This is a really useful trick, so remember it if you need to convert your own code to XLA!\n\n#### XLA Rule #3: XLA will need to recompile your model for every different input shape it sees\n\nThis is the big one. What this means is that if your input shapes are very variable, XLA will have to recompile your model over and over, which will create huge performance problems. This commonly arises in NLP models, where input texts have variable lengths after tokenization. In other modalities, static shapes are more common and this rule is much less of a problem.\n\nHow can you get around rule #3? The key is **padding** - if you pad all your inputs to the same length, and then use an `attention_mask`, you can get the same results as you\u2019d get from variable shapes, but without any XLA issues. However, excessive padding can cause severe slowdown too - if you pad all your samples to the maximum length in the whole dataset, you might end up with batches consisting endless padding tokens, which will waste a lot of compute and memory!\n\nThere isn\u2019t a perfect solution to this problem. However, you can try some tricks. One very useful trick is to **pad batches of samples up to a multiple of a number like 32 or 64 tokens.** This often only increases the number of tokens by a small amount, but it hugely reduces the number of unique input shapes, because every input shape now has to be a multiple of 32 or 64. Fewer unique input shapes means fewer XLA compilations!\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** Our tokenizers and data collators have methods that can help you here. You can use `padding=\"max_length\"` or `padding=\"longest\"` when calling tokenizers to get them to output padded data. Our tokenizers and data collators also have a `pad_to_multiple_of` argument that you can use to reduce the number of unique input shapes you see!\n\n</Tip>\n\n### How do I actually train my model on TPU?\n\nOnce your training is XLA-compatible and (if you\u2019re using TPU Node / Colab) your dataset has been prepared appropriately, running on TPU is surprisingly easy! All you really need to change in your code is to add a few lines to initialize your TPU, and to ensure that your model and dataset are created inside a `TPUStrategy` scope. Take a look at [our TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) to see this in action!\n\n### Summary\n\nThere was a lot in here, so let\u2019s summarize with a quick checklist you can follow when you want to get your model ready for TPU training:\n\n- Make sure your code follows the three rules of XLA\n- Compile your model with `jit_compile=True` on CPU/GPU and confirm that you can train it with XLA\n- Either load your dataset into memory or use a TPU-compatible dataset loading approach (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Migrate your code either to Colab (with accelerator set to \u201cTPU\u201d) or a TPU VM on Google Cloud\n- Add TPU initializer code (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Create your `TPUStrategy` and make sure dataset loading and model creation are inside the `strategy.scope()` (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Don\u2019t forget to take `jit_compile=True` out again when you move to TPU!\n- \ud83d\ude4f\ud83d\ude4f\ud83d\ude4f\ud83e\udd7a\ud83e\udd7a\ud83e\udd7a\n- Call model.fit()\n- You did it!\n3,\t!--Copyright 2023 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\nthe License. You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under the License is distributed on\nan \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n\n\u26a0\ufe0f Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be\nrendered properly in your Markdown viewer.\n\n-->\n\n# Training on TPU with TensorFlow\n\n<Tip>\n\nIf you don't need long explanations and just want TPU code samples to get started with, check out [our TPU example notebook!](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb)\n\n</Tip>\n\n### What is a TPU?\n\nA TPU is a **Tensor Processing Unit.** They are hardware designed by Google, which are used to greatly speed up the tensor computations within neural networks, much like GPUs. They can be used for both network training and inference. They are generally accessed through Google\u2019s cloud services, but small TPUs can also be accessed directly for free through Google Colab and Kaggle Kernels.\n\nBecause [all TensorFlow models in \ud83e\udd17 Transformers are Keras models](https://huggingface.co/blog/tensorflow-philosophy), most of the methods in this document are generally applicable to TPU training for any Keras model! However, there are a few points that are specific to the HuggingFace ecosystem (hug-o-system?) of Transformers and Datasets, and we\u2019ll make sure to flag them up when we get to them.\n\n### What kinds of TPU are available?\n\nNew users are often very confused by the range of TPUs, and the different ways to access them. The first key distinction to understand is the difference between **TPU Nodes** and **TPU VMs.**\n\nWhen you use a **TPU Node**, you are effectively indirectly accessing a remote TPU. You will need a separate VM, which will initialize your network and data pipeline and then forward them to the remote node. When you use a TPU on Google Colab, you are accessing it in the **TPU Node** style.\n\nUsing TPU Nodes can have some quite unexpected behaviour for people who aren\u2019t used to them! In particular, because the TPU is located on a physically different system to the machine you\u2019re running your Python code on, your data cannot be local to your machine - any data pipeline that loads from your machine\u2019s internal storage will totally fail! Instead, data must be stored in Google Cloud Storage where your data pipeline can still access it, even when the pipeline is running on the remote TPU node.\n\n<Tip>\n\nIf you can fit all your data in memory as `np.ndarray` or `tf.Tensor`, then you can `fit()` on that data even when using Colab or a TPU Node, without needing to upload it to Google Cloud Storage.\n\n</Tip>\n\n<Tip>\n\n**\ud83e\udd17Specific Hugging Face Tip\ud83e\udd17:** The methods `Dataset.to_tf_dataset()` and its higher-level wrapper `model.prepare_tf_dataset()` , which you will see throughout our TF code examples, will both fail on a TPU Node. The reason for this is that even though they create a `tf.data.Dataset` it is not a \u201cpure\u201d `tf.data` pipeline and uses `tf.numpy_function` or `Dataset.from_generator()` to stream data from the underlying HuggingFace `Dataset`. This HuggingFace `Dataset` is backed by data that is on a local disc and which the remote TPU Node will not be able to read.\n\n</Tip>\n\nThe second way to access a TPU is via a **TPU VM.** When using a TPU VM, you connect directly to the machine that the TPU is attached to, much like training on a GPU VM. TPU VMs are generally easier to work with, particularly when it comes to your data pipeline. All of the above warnings do not apply to TPU VMs!\n\nThis is an opinionated document, so here\u2019s our opinion: **Avoid using TPU Node if possible.** It is more confusing and more difficult to debug than TPU VMs. It is also likely to be unsupported in future - Google\u2019s latest TPU, TPUv4, can only be accessed as a TPU VM, which suggests that TPU Nodes are increasingly going to become a \u201clegacy\u201d access method. However, we understand that the only free TPU access is on Colab and Kaggle Kernels, which uses TPU Node - so we\u2019ll try to explain how to handle it if you have to! Check the [TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) for code samples that explain this in more detail.\n\n### What sizes of TPU are available?\n\nA single TPU (a v2-8/v3-8/v4-8) runs 8 replicas. TPUs exist in **pods** that can run hundreds or thousands of replicas simultaneously. When you use more than a single TPU but less than a whole pod (for example, a v3-32), your TPU fleet is referred to as a **pod slice.**\n\nWhen you access a free TPU via Colab, you generally get a single v2-8 TPU.\n\n### I keep hearing about this XLA thing. What\u2019s XLA, and how does it relate to TPUs?\n\nXLA is an optimizing compiler, used by both TensorFlow and JAX. In JAX it is the only compiler, whereas in TensorFlow it is optional\n    ```",
            "vector_context": "[Created at: 2025-03-24 13:17:32]\n(for example, a v3-32), your TPU fleet is referred to as a **pod slice.**\n\nWhen you access a free TPU via Colab, you generally get a single v2-8 TPU.\n\n### I keep hearing about this XLA thing. What\u2019s XLA, and how does it relate to TPUs?\n\nXLA is an optimizing compiler, used by both TensorFlow and JAX. In JAX it is the only compiler, whereas in TensorFlow it is optional (but mandatory on TPU!). The easiest way to enable it when training a Keras model is to pass the argument `jit_compile=True` to `model.compile()`. If you don\u2019t get any errors and performance is good, that\u2019s a great sign that you\u2019re ready to move to TPU!\n\nDebugging on TPU is generally a bit harder than on CPU/GPU, so we recommend getting your code running on CPU/GPU with XLA first before trying it on TPU. You don\u2019t have to train for long, of course - just for a few steps to make sure that your model and data pipeline are working like you expect them to.\n\n<Tip>\n\nXLA compiled code is usually faster - so even if you\u2019re not planning to run on TPU, adding `jit_compile=True` can improve your performance. Be sure to note the caveats below about XLA compatibility, though!\n\n</Tip>\n\n<Tip warning={true}>\n\n**Tip born of painful experience:** Although using `jit_compile=True` is a good way to get a speed boost and test if your CPU/GPU code is XLA-compatible, it can actually cause a lot of problems if you leave it in when actually training on TPU. XLA compilation will happen implicitly on TPU, so remember to remove that line before actually running your code on a TPU!\n\n</Tip>\n\n### How do I make my model XLA compatible?\n\nIn many cases, your code is probably XLA-compatible already! However, there are a few things that work in normal TensorFlow that don\u2019t work in XLA. We\u2019ve distilled them into three core rules below:\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** We\u2019ve put a lot of effort into rewriting our TensorFlow models and loss functions to be XLA-compatible. Our models and loss functions generally obey rule #1 and #2 by default, so you can skip over them if you\u2019re using `transformers` models. Don\u2019t forget about these rules when writing your own models and loss functions, though!\n\n</Tip>\n\n#### XLA Rule #1: Your code cannot have \u201cdata-dependent conditionals\u201d\n\nWhat that means is that any `if` statement cannot depend on values inside a `tf.Tensor`. For example, this code block cannot be compiled with XLA!\n\n```python\nif tf.reduce_sum(tensor) > 10:\n    tensor = tensor / 2.0\n```\n\nThis might seem very restrictive at first, but most neural net code doesn\u2019t need to do this. You can often get around this restriction by using `tf.cond` (see the documentation [here](https://www.tensorflow.org/api_docs/python/tf/cond)) or by removing the conditional and finding a clever math trick with indicator variables instead, like so:\n\n```python\nsum_over_10 = tf.cast(tf.reduce_sum(tensor) > 10, tf.float32)\ntensor = tensor / (1.0 + sum_over_10)\n```\n\nThis code has exactly the same effect as the code above, but by avoiding a conditional, we ensure it will compile with XLA without problems!\n\n#### XLA Rule #2: Your code cannot have \u201cdata-dependent shapes\u201d\n\nWhat this means is that the shape of all of the `tf.Tensor` objects in your code cannot depend on their values. For example, the function `tf.unique` cannot be compiled with XLA, because it returns a `tensor` containing one instance of each unique value in the input. The shape of this output will obviously be different depending on how repetitive the input `Tensor` was, and so XLA refuses to handle it!\n\nIn general, most neural network code obeys rule #2 by default. However, there are a few common cases where it becomes a problem. One very common one is when you use **label masking**, setting your labels to a negative value to indicate that those positions should be ignored when computing the loss. If you look at NumPy or PyTorch loss functions that support label masking, you will often see code like this that uses [boolean indexing](https://numpy.org/doc/stable/user/basics.indexing.html#boolean-array-indexing):\n\n```python\nlabel_mask = labels >= 0\nmasked_outputs = outputs[label_mask]\nmasked_labels = labels[label_mask]\nloss = compute_loss(masked_outputs, masked_labels)\nmean_loss = torch.mean(loss)\n```\n\nThis code is totally fine in NumPy or PyTorch, but it breaks in XLA! Why? Because the shape of `masked_outputs` and `masked_labels` depends on how many positions are masked - that makes it a **data-dependent shape.** However, just like for rule #1, we can often rewrite this code to yield exactly the same output without any data-dependent shapes.\n\n```python\nlabel_mask = tf.cast(labels >= 0, tf.float32)\nloss = compute_loss(outputs, labels)\nloss = loss * label_mask  # Set negative label positions to 0\nmean_loss = tf.reduce_sum(loss) / tf.reduce_sum(label_mask)\n```\n\nHere, we avoid data-dependent shapes by computing the loss for every position, but zeroing out the masked positions in both the numerator and denominator when we calculate the mean, which yields exactly the same result as the first block while maintaining XLA compatibility. Note that we use the same trick as in rule #1 - converting a `tf.bool` to `\n--New Chunk--\n[Created at: 2025-03-24 13:17:32]\n!--Copyright 2023 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\nthe License. You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under the License is distributed on\nan \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n\n\u26a0\ufe0f Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be\nrendered properly in your Markdown viewer.\n\n-->\n\n# Training on TPU with TensorFlow\n\n<Tip>\n\nIf you don't need long explanations and just want TPU code samples to get started with, check out [our TPU example notebook!](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb)\n\n</Tip>\n\n### What is a TPU?\n\nA TPU is a **Tensor Processing Unit.** They are hardware designed by Google, which are used to greatly speed up the tensor computations within neural networks, much like GPUs. They can be used for both network training and inference. They are generally accessed through Google\u2019s cloud services, but small TPUs can also be accessed directly for free through Google Colab and Kaggle Kernels.\n\nBecause [all TensorFlow models in \ud83e\udd17 Transformers are Keras models](https://huggingface.co/blog/tensorflow-philosophy), most of the methods in this document are generally applicable to TPU training for any Keras model! However, there are a few points that are specific to the HuggingFace ecosystem (hug-o-system?) of Transformers and Datasets, and we\u2019ll make sure to flag them up when we get to them.\n\n### What kinds of TPU are available?\n\nNew users are often very confused by the range of TPUs, and the different ways to access them. The first key distinction to understand is the difference between **TPU Nodes** and **TPU VMs.**\n\nWhen you use a **TPU Node**, you are effectively indirectly accessing a remote TPU. You will need a separate VM, which will initialize your network and data pipeline and then forward them to the remote node. When you use a TPU on Google Colab, you are accessing it in the **TPU Node** style.\n\nUsing TPU Nodes can have some quite unexpected behaviour for people who aren\u2019t used to them! In particular, because the TPU is located on a physically different system to the machine you\u2019re running your Python code on, your data cannot be local to your machine - any data pipeline that loads from your machine\u2019s internal storage will totally fail! Instead, data must be stored in Google Cloud Storage where your data pipeline can still access it, even when the pipeline is running on the remote TPU node.\n\n<Tip>\n\nIf you can fit all your data in memory as `np.ndarray` or `tf.Tensor`, then you can `fit()` on that data even when using Colab or a TPU Node, without needing to upload it to Google Cloud Storage.\n\n</Tip>\n\n<Tip>\n\n**\ud83e\udd17Specific Hugging Face Tip\ud83e\udd17:** The methods `Dataset.to_tf_dataset()` and its higher-level wrapper `model.prepare_tf_dataset()` , which you will see throughout our TF code examples, will both fail on a TPU Node. The reason for this is that even though they create a `tf.data.Dataset` it is not a \u201cpure\u201d `tf.data` pipeline and uses `tf.numpy_function` or `Dataset.from_generator()` to stream data from the underlying HuggingFace `Dataset`. This HuggingFace `Dataset` is backed by data that is on a local disc and which the remote TPU Node will not be able to read.\n\n</Tip>\n\nThe second way to access a TPU is via a **TPU VM.** When using a TPU VM, you connect directly to the machine that the TPU is attached to, much like training on a GPU VM. TPU VMs are generally easier to work with, particularly when it comes to your data pipeline. All of the above warnings do not apply to TPU VMs!\n\nThis is an opinionated document, so here\u2019s our opinion: **Avoid using TPU Node if possible.** It is more confusing and more difficult to debug than TPU VMs. It is also likely to be unsupported in future - Google\u2019s latest TPU, TPUv4, can only be accessed as a TPU VM, which suggests that TPU Nodes are increasingly going to become a \u201clegacy\u201d access method. However, we understand that the only free TPU access is on Colab and Kaggle Kernels, which uses TPU Node - so we\u2019ll try to explain how to handle it if you have to! Check the [TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) for code samples that explain this in more detail.\n\n### What sizes of TPU are available?\n\nA single TPU (a v2-8/v3-8/v4-8) runs 8 replicas. TPUs exist in **pods** that can run hundreds or thousands of replicas simultaneously. When you use more than a single TPU but less than a whole pod (for example, a v3-32), your TPU fleet is referred to as a **pod slice.**\n\nWhen you access a free TPU via Colab, you generally get a single v2-8 TPU.\n\n### I keep hearing about this XLA thing. What\u2019s XLA, and how does it relate to TPUs?\n\nXLA is an optimizing compiler, used by both TensorFlow and JAX. In JAX it is the only compiler, whereas in TensorFlow it is optional\n--New Chunk--\n[Created at: 2025-03-24 13:17:32]\nlabel_mask  # Set negative label positions to 0\nmean_loss = tf.reduce_sum(loss) / tf.reduce_sum(label_mask)\n```\n\nHere, we avoid data-dependent shapes by computing the loss for every position, but zeroing out the masked positions in both the numerator and denominator when we calculate the mean, which yields exactly the same result as the first block while maintaining XLA compatibility. Note that we use the same trick as in rule #1 - converting a `tf.bool` to `tf.float32` and using it as an indicator variable. This is a really useful trick, so remember it if you need to convert your own code to XLA!\n\n#### XLA Rule #3: XLA will need to recompile your model for every different input shape it sees\n\nThis is the big one. What this means is that if your input shapes are very variable, XLA will have to recompile your model over and over, which will create huge performance problems. This commonly arises in NLP models, where input texts have variable lengths after tokenization. In other modalities, static shapes are more common and this rule is much less of a problem.\n\nHow can you get around rule #3? The key is **padding** - if you pad all your inputs to the same length, and then use an `attention_mask`, you can get the same results as you\u2019d get from variable shapes, but without any XLA issues. However, excessive padding can cause severe slowdown too - if you pad all your samples to the maximum length in the whole dataset, you might end up with batches consisting endless padding tokens, which will waste a lot of compute and memory!\n\nThere isn\u2019t a perfect solution to this problem. However, you can try some tricks. One very useful trick is to **pad batches of samples up to a multiple of a number like 32 or 64 tokens.** This often only increases the number of tokens by a small amount, but it hugely reduces the number of unique input shapes, because every input shape now has to be a multiple of 32 or 64. Fewer unique input shapes means fewer XLA compilations!\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** Our tokenizers and data collators have methods that can help you here. You can use `padding=\"max_length\"` or `padding=\"longest\"` when calling tokenizers to get them to output padded data. Our tokenizers and data collators also have a `pad_to_multiple_of` argument that you can use to reduce the number of unique input shapes you see!\n\n</Tip>\n\n### How do I actually train my model on TPU?\n\nOnce your training is XLA-compatible and (if you\u2019re using TPU Node / Colab) your dataset has been prepared appropriately, running on TPU is surprisingly easy! All you really need to change in your code is to add a few lines to initialize your TPU, and to ensure that your model and dataset are created inside a `TPUStrategy` scope. Take a look at [our TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) to see this in action!\n\n### Summary\n\nThere was a lot in here, so let\u2019s summarize with a quick checklist you can follow when you want to get your model ready for TPU training:\n\n- Make sure your code follows the three rules of XLA\n- Compile your model with `jit_compile=True` on CPU/GPU and confirm that you can train it with XLA\n- Either load your dataset into memory or use a TPU-compatible dataset loading approach (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Migrate your code either to Colab (with accelerator set to \u201cTPU\u201d) or a TPU VM on Google Cloud\n- Add TPU initializer code (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Create your `TPUStrategy` and make sure dataset loading and model creation are inside the `strategy.scope()` (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Don\u2019t forget to take `jit_compile=True` out again when you move to TPU!\n- \ud83d\ude4f\ud83d\ude4f\ud83d\ude4f\ud83e\udd7a\ud83e\udd7a\ud83e\udd7a\n- Call model.fit()\n- You did it!"
        }
    },
    {
        "context": "```python\nlabel_mask = labels >= 0\nmasked_outputs = outputs[label_mask]\nmasked_labels = labels[label_mask]\nloss = compute_loss(masked_outputs, masked_labels)\nmean_loss = torch.mean(loss)\n```\n\nThis code is totally fine in NumPy or PyTorch, but it breaks in XLA! Why? Because the shape of `masked_outputs` and `masked_labels` depends on how many positions are masked - that makes it a **data-dependent shape.** However, just like for rule #1, we can often rewrite this code to yield exactly the same output without any data-dependent shapes.\n\n```python\nlabel_mask = tf.cast(labels >= 0, tf.float32)\nloss = compute_loss(outputs, labels)\nloss = loss * label_mask  # Set negative label positions to 0\nmean_loss = tf.reduce_sum(loss) / tf.reduce_sum(label_mask)\n```\n\nHere, we avoid data-dependent shapes by computing the loss for every position, but zeroing out the masked positions in both the numerator and denominator when we calculate the mean, which yields exactly the same result as the first block while maintaining XLA compatibility. Note that we use the same trick as in rule #1 - converting a `tf.bool` to `tf.float32` and using it as an indicator variable. This is a really useful trick, so remember it if you need to convert your own code to XLA!\n\n#### XLA Rule #3: XLA will need to recompile your model for every different input shape it sees\n\nThis is the big one. What this means is that if your input shapes are very variable, XLA will have to recompile your model over and over, which will create huge performance problems. This commonly arises in NLP models, where input texts have variable lengths after tokenization. In other modalities, static shapes are more common and this rule is much less of a problem.",
        "question": "What happens if XLA sees different input shapes?",
        "answer": "XLA will need to recompile the model for every different input shape it sees.",
        "source_doc": "huggingface/transformers/blob/main/docs/source/en/perf_train_tpu_tf.md",
        "rag_answer": null,
        "rag_context": null,
        "rag_score": null,
        "rag_feedback": null
    },
    {
        "context": "```python\nlabel_mask = labels >= 0\nmasked_outputs = outputs[label_mask]\nmasked_labels = labels[label_mask]\nloss = compute_loss(masked_outputs, masked_labels)\nmean_loss = torch.mean(loss)\n```\n\nThis code is totally fine in NumPy or PyTorch, but it breaks in XLA! Why? Because the shape of `masked_outputs` and `masked_labels` depends on how many positions are masked - that makes it a **data-dependent shape.** However, just like for rule #1, we can often rewrite this code to yield exactly the same output without any data-dependent shapes.\n\n```python\nlabel_mask = tf.cast(labels >= 0, tf.float32)\nloss = compute_loss(outputs, labels)\nloss = loss * label_mask  # Set negative label positions to 0\nmean_loss = tf.reduce_sum(loss) / tf.reduce_sum(label_mask)\n```\n\nHere, we avoid data-dependent shapes by computing the loss for every position, but zeroing out the masked positions in both the numerator and denominator when we calculate the mean, which yields exactly the same result as the first block while maintaining XLA compatibility. Note that we use the same trick as in rule #1 - converting a `tf.bool` to `tf.float32` and using it as an indicator variable. This is a really useful trick, so remember it if you need to convert your own code to XLA!\n\n#### XLA Rule #3: XLA will need to recompile your model for every different input shape it sees\n\nThis is the big one. What this means is that if your input shapes are very variable, XLA will have to recompile your model over and over, which will create huge performance problems. This commonly arises in NLP models, where input texts have variable lengths after tokenization. In other modalities, static shapes are more common and this rule is much less of a problem.",
        "question": "What kind of models are commonly affected by XLA Rule #3?",
        "answer": "NLP models, where input texts have variable lengths after tokenization.",
        "source_doc": "huggingface/transformers/blob/main/docs/source/en/perf_train_tpu_tf.md",
        "rag_answer": null,
        "rag_context": null,
        "rag_score": null,
        "rag_feedback": null
    },
    {
        "sample_idx": 72,
        "question": "What is the key to getting around rule #3?",
        "answer": "The key is padding.",
        "rag_answer": "The key to getting around rule #3, which states that XLA will need to recompile your model for every different input shape it sees, is **padding**. By padding all your inputs to the same length and then using an `attention_mask`, you can get the same results as you would with variable shapes, but without any XLA issues. Additionally, you can try padding batches of samples up to a multiple of a number like 32 or 64 tokens, which can reduce the number of unique input shapes and thus fewer XLA compilations.\n\nReferences:\n[DC] How do I actually train my model on TPU?",
        "rag_score": 5,
        "rag_feedback": "The system's response is completely correct, accurate, and factual. It provides a detailed explanation of how to get around rule #3 of XLA, which is to pad all inputs to the same length and use an attention mask. The response also provides additional tips and tricks to reduce the number of unique input shapes, which can help with XLA compilations.",
        "rag_context": {
            "kg_context": "-----Entities-----\n    ```csv\n    id,\tentity,\ttype,\tdescription,\trankcreated_at\n1,\tGradio,organization,Gradio is a platform that supports state in Blocks, providing features such as global state and session state.<SEP>Gradio is an interface that provides various features for demonstrating models, including adding example inputs, custom error messages, descriptive content, flagging, and more.<SEP>Gradio is an organization that provides a platform for building and deploying machine learning models.<SEP>Gradio is an organization that provides a platform for creating and deploying machine learning models.<SEP>Gradio is an organization that provides a demo for blocks_random_slider, and its library is used to create interactive interfaces.,36,2025-03-24 13:20:24\n2,\tdocs,geo,docs is a location where more information about Gradio's state can be found.,1,2025-03-24 13:20:24\n3,\tErrors,category,Errors are a feature in Gradio that allows users to display custom error messages.,1,2025-03-24 13:20:24\n4,\tInterface,category,Interface is a category of components in Gradio that enables the creation of custom interfaces.<SEP>Interface is a component of Gradio that allows users to interact with machine learning models.<SEP>Interface is a concept in Gradio that refers to a user interface for demonstrating models.<SEP>Interface is a category related to Gradio, where state works similarly to Blocks.,3,2025-03-24 13:20:24\n5,\tState,category,State is a concept in Gradio that refers to the storage of data, including global state and session state.,2,2025-03-24 13:20:24\n6,\trule #3,concept,rule #3 is a guideline for writing XLA-compatible code.,0,UNKNOWN\n7,\trule #1,concept,rule #1 is a guideline for writing XLA-compatible code.,0,UNKNOWN\n8,\tdocs,geo,docs is a location where more information about Gradio's state can be found.,1,UNKNOWN\n    ```\n    -----Relationships-----\n    ```csv\n    id,\tsource,\ttarget,\tdescription,\tkeywords,\tweight,\trank,\tcreated_at\n1,\tGradio,docs,The Gradio docs provide more information about state.,documentation, platform information,8.0,37,2025-03-24 13:20:24\n2,\tErrors,Gradio,Gradio allows users to display custom error messages.,error messages, interface feature,7.0,37,2025-03-24 13:17:31\n3,\tInterface,State,State works similarly in Interface and Blocks.,similar concept, data storage,14.0,5,2025-03-24 13:20:24\n4,\tGradio,docs,The Gradio docs provide more information about state.,documentation, platform information,8.0,37,UNKNOWN\n    ```\n    -----Sources-----\n    ```csv\n    id,\tcontent\n1,\tState in Blocks\n\nWe covered [State in Interfaces](https://gradio.app/interface-state), this guide takes a look at state in Blocks, which works mostly the same.\n\n## Global State\n\nGlobal state in Blocks works the same as in Interface. Any variable created outside a function call is a reference shared between all users.\n\n## Session State\n\nGradio supports session **state**, where data persists across multiple submits within a page session, in Blocks apps as well. To reiterate, session data is _not_ shared between different users of your model. To store data in a session state, you need to do three things:\n\n1. Create a `gr.State()` object. If there is a default value to this stateful object, pass that into the constructor.\n2. In the event listener, put the `State` object as an input and output.\n3. In the event listener function, add the variable to the input parameters and the return value.\n\nLet's take a look at a game of hangman.\n\n$code_hangman\n$demo_hangman\n\nLet's see how we do each of the 3 steps listed above in this game:\n\n1. We store the used letters in `used_letters_var`. In the constructor of `State`, we set the initial value of this to `[]`, an empty list.\n2. In `btn.click()`, we have a reference to `used_letters_var` in both the inputs and outputs.\n3. In `guess_letter`, we pass the value of this `State` to `used_letters`, and then return an updated value of this `State` in the return statement.\n\nWith more complex apps, you will likely have many State variables storing session state in a single Blocks app.\n\nLearn more about `State` in the [docs](https://gradio.app/docs#state).\n2,\t\u4e3b\u8981\u7279\u70b9\n\n\u8ba9\u6211\u4eec\u6765\u4ecb\u7ecd\u4e00\u4e0b Gradio \u6700\u53d7\u6b22\u8fce\u7684\u4e00\u4e9b\u529f\u80fd\uff01\u8fd9\u91cc\u662f Gradio \u7684\u4e3b\u8981\u7279\u70b9\uff1a\n\n1. [\u6dfb\u52a0\u793a\u4f8b\u8f93\u5165](#example-inputs)\n2. [\u4f20\u9012\u81ea\u5b9a\u4e49\u9519\u8bef\u6d88\u606f](#errors)\n3. [\u6dfb\u52a0\u63cf\u8ff0\u5185\u5bb9](#descriptive-content)\n4. [\u8bbe\u7f6e\u65d7\u6807](#flagging)\n5. [\u9884\u5904\u7406\u548c\u540e\u5904\u7406](#preprocessing-and-postprocessing)\n6. [\u6837\u5f0f\u5316\u6f14\u793a](#styling)\n7. [\u6392\u961f\u7528\u6237](#queuing)\n8. [\u8fed\u4ee3\u8f93\u51fa](#iterative-outputs)\n9. [\u8fdb\u5ea6\u6761](#progress-bars)\n10. [\u6279\u5904\u7406\u51fd\u6570](#batch-functions)\n11. [\u5728\u534f\u4f5c\u7b14\u8bb0\u672c\u4e0a\u8fd0\u884c](#colab-notebooks)\n\n## \u793a\u4f8b\u8f93\u5165\n\n\u60a8\u53ef\u4ee5\u63d0\u4f9b\u7528\u6237\u53ef\u4ee5\u8f7b\u677e\u52a0\u8f7d\u5230 \"Interface\" \u4e2d\u7684\u793a\u4f8b\u6570\u636e\u3002\u8fd9\u5bf9\u4e8e\u6f14\u793a\u6a21\u578b\u671f\u671b\u7684\u8f93\u5165\u7c7b\u578b\u4ee5\u53ca\u6f14\u793a\u6570\u636e\u96c6\u548c\u6a21\u578b\u4e00\u8d77\u63a2\u7d22\u7684\u65b9\u5f0f\u975e\u5e38\u6709\u5e2e\u52a9\u3002\u8981\u52a0\u8f7d\u793a\u4f8b\u6570\u636e\uff0c\u60a8\u53ef\u4ee5\u5c06\u5d4c\u5957\u5217\u8868\u63d0\u4f9b\u7ed9 Interface \u6784\u9020\u51fd\u6570\u7684 `examples=` \u5173\u952e\u5b57\u53c2\u6570\u3002\u5916\u90e8\u5217\u8868\u4e2d\u7684\u6bcf\u4e2a\u5b50\u5217\u8868\u8868\u793a\u4e00\u4e2a\u6570\u636e\u6837\u672c\uff0c\u5b50\u5217\u8868\u4e2d\u7684\u6bcf\u4e2a\u5143\u7d20\u8868\u793a\u6bcf\u4e2a\u8f93\u5165\u7ec4\u4ef6\u7684\u8f93\u5165\u3002\u6709\u5173\u6bcf\u4e2a\u7ec4\u4ef6\u7684\u793a\u4f8b\u6570\u636e\u683c\u5f0f\u5728[Docs](https://gradio.app/docs#components)\u4e2d\u6709\u8bf4\u660e\u3002\n\n$code_calculator\n$demo_calculator\n\n\u60a8\u53ef\u4ee5\u5c06\u5927\u578b\u6570\u636e\u96c6\u52a0\u8f7d\u5230\u793a\u4f8b\u4e2d\uff0c\u901a\u8fc7 Gradio \u6d4f\u89c8\u548c\u4e0e\u6570\u636e\u96c6\u8fdb\u884c\u4ea4\u4e92\u3002\u793a\u4f8b\u5c06\u81ea\u52a8\u5206\u9875\uff08\u53ef\u4ee5\u901a\u8fc7 Interface \u7684 `examples_per_page` \u53c2\u6570\u8fdb\u884c\u914d\u7f6e\uff09\u3002\n\n\u7ee7\u7eed\u4e86\u89e3\u793a\u4f8b\uff0c\u8bf7\u53c2\u9605[\u66f4\u591a\u793a\u4f8b](https://gradio.app/more-on-examples)\u6307\u5357\u3002\n\n## \u9519\u8bef\n\n\u60a8\u5e0c\u671b\u5411\u7528\u6237\u4f20\u9012\u81ea\u5b9a\u4e49\u9519\u8bef\u6d88\u606f\u3002\u4e3a\u6b64\uff0cwith `gr.Error(\"custom message\")` \u6765\u663e\u793a\u9519\u8bef\u6d88\u606f\u3002\u5982\u679c\u5728\u4e0a\u9762\u7684\u8ba1\u7b97\u5668\u793a\u4f8b\u4e2d\u5c1d\u8bd5\u9664\u4ee5\u96f6\uff0c\u5c06\u663e\u793a\u81ea\u5b9a\u4e49\u9519\u8bef\u6d88\u606f\u7684\u5f39\u51fa\u6a21\u6001\u7a97\u53e3\u3002\u4e86\u89e3\u6709\u5173\u9519\u8bef\u7684\u66f4\u591a\u4fe1\u606f\uff0c\u8bf7\u53c2\u9605[\u6587\u6863](https://gradio.app/docs#error)\u3002\n\n## \u63cf\u8ff0\u6027\u5185\u5bb9\n\n\u5728\u524d\u9762\u7684\u793a\u4f8b\u4e2d\uff0c\u60a8\u53ef\u80fd\u5df2\u7ecf\u6ce8\u610f\u5230 Interface \u6784\u9020\u51fd\u6570\u4e2d\u7684 `title=` \u548c `description=` \u5173\u952e\u5b57\u53c2\u6570\uff0c\u5e2e\u52a9\u7528\u6237\u4e86\u89e3\u60a8\u7684\u5e94\u7528\u7a0b\u5e8f\u3002\n\nInterface \u6784\u9020\u51fd\u6570\u4e2d\u6709\u4e09\u4e2a\u53c2\u6570\u7528\u4e8e\u6307\u5b9a\u6b64\u5185\u5bb9\u5e94\u653e\u7f6e\u5728\u54ea\u91cc\uff1a\n\n- `title`\uff1a\u63a5\u53d7\u6587\u672c\uff0c\u5e76\u53ef\u4ee5\u5c06\u5176\u663e\u793a\u5728\u754c\u9762\u7684\u9876\u90e8\uff0c\u4e5f\u5c06\u6210\u4e3a\u9875\u9762\u6807\u9898\u3002\n- `description`\uff1a\u63a5\u53d7\u6587\u672c\u3001Markdown \u6216 HTML\uff0c\u5e76\u5c06\u5176\u653e\u7f6e\u5728\u6807\u9898\u6b63\u4e0b\u65b9\u3002\n- `article`\uff1a\u4e5f\u63a5\u53d7\u6587\u672c\u3001Markdown \u6216 HTML\uff0c\u5e76\u5c06\u5176\u653e\u7f6e\u5728\u754c\u9762\u4e0b\u65b9\u3002\n\n![annotated](/assets/guides/annotated.png)\n\n\u5982\u679c\u60a8\u4f7f\u7528\u7684\u662f `Blocks` API\uff0c\u5219\u53ef\u4ee5 with `gr.Markdown(...)` \u6216 `gr.HTML(...)` \u7ec4\u4ef6\u5728\u4efb\u4f55\u4f4d\u7f6e\u63d2\u5165\u6587\u672c\u3001Markdown \u6216 HTML\uff0c\u5176\u4e2d\u63cf\u8ff0\u6027\u5185\u5bb9\u4f4d\u4e8e `Component` \u6784\u9020\u51fd\u6570\u5185\u90e8\u3002\n\n\u53e6\u4e00\u4e2a\u6709\u7528\u7684\u5173\u952e\u5b57\u53c2\u6570\u662f `label=`\uff0c\u5b83\u5b58\u5728\u4e8e\u6bcf\u4e2a `Component` \u4e2d\u3002\u8fd9\u4fee\u6539\u4e86\u6bcf\u4e2a `Component` \u9876\u90e8\u7684\u6807\u7b7e\u6587\u672c\u3002\u8fd8\u53ef\u4ee5\u4e3a\u8bf8\u5982 `Textbox` \u6216 `Radio` \u4e4b\u7c7b\u7684\u8868\u5355\u5143\u7d20\u6dfb\u52a0 `info=` \u5173\u952e\u5b57\u53c2\u6570\uff0c\u4ee5\u63d0\u4f9b\u6709\u5173\u5176\u7528\u6cd5\u7684\u8fdb\u4e00\u6b65\u4fe1\u606f\u3002\n\n```python\ngr.Number(label='\u5e74\u9f84', info='\u4ee5\u5e74\u4e3a\u5355\u4f4d\uff0c\u5fc5\u987b\u5927\u4e8e0')\n```\n\n## \u65d7\u6807\n\n\u9ed8\u8ba4\u60c5\u51b5\u4e0b\uff0c\"Interface\" \u5c06\u6709\u4e00\u4e2a \"Flag\" \u6309\u94ae\u3002\u5f53\u7528\u6237\u6d4b\u8bd5\u60a8\u7684 `Interface` \u65f6\uff0c\u5982\u679c\u770b\u5230\u6709\u8da3\u7684\u8f93\u51fa\uff0c\u4f8b\u5982\u9519\u8bef\u6216\u610f\u5916\u7684\u6a21\u578b\u884c\u4e3a\uff0c\u4ed6\u4eec\u53ef\u4ee5\u5c06\u8f93\u5165\u6807\u8bb0\u4e3a\u60a8\u8fdb\u884c\u67e5\u770b\u3002\u5728\u7531 `Interface` \u6784\u9020\u51fd\u6570\u7684 `flagging_dir=` \u53c2\u6570\u63d0\u4f9b\u7684\u76ee\u5f55\u4e2d\uff0c\u5c06\u8bb0\u5f55\u6807\u8bb0\u7684\u8f93\u5165\u5230\u4e00\u4e2a CSV \u6587\u4ef6\u4e2d\u3002\u5982\u679c\u754c\u9762\u6d89\u53ca\u6587\u4ef6\u6570\u636e\uff0c\u4f8b\u5982\u56fe\u50cf\u548c\u97f3\u9891\u7ec4\u4ef6\uff0c\u5c06\u521b\u5efa\u6587\u4ef6\u5939\u6765\u5b58\u50a8\u8fd9\u4e9b\u6807\u8bb0\u7684\u6570\u636e\u3002\n\n\u4f8b\u5982\uff0c\u5bf9\u4e8e\u4e0a\u9762\u663e\u793a\u7684\u8ba1\u7b97\u5668\u754c\u9762\uff0c\u6211\u4eec\u5c06\u5728\u4e0b\u9762\u7684\u65d7\u6807\u76ee\u5f55\u4e2d\u5b58\u50a8\u6807\u8bb0\u7684\u6570\u636e\uff1a\n\n```directory\n+-- calculator.py\n+-- flagged/\n|   +-- logs.csv\n```\n\n_flagged/logs.csv_\n\n```csv\nnum1,operation,num2,Output\n5,add,7,12\n6,subtract,1.5,4.5\n```\n\n\u4e0e\u65e9\u671f\u663e\u793a\u7684\u51b7\u8272\u754c\u9762\u76f8\u5bf9\u5e94\uff0c\u6211\u4eec\u5c06\u5728\u4e0b\u9762\u7684\u65d7\u6807\u76ee\u5f55\u4e2d\u5b58\u50a8\u6807\u8bb0\u7684\u6570\u636e\uff1a\n\n```directory\n+-- sepia.py\n+-- flagged/\n|   +-- logs.csv\n|   +-- im/\n|   |   +-- 0.png\n|   |   +-- 1.png\n|   +-- Output/\n|   |   +-- 0.png\n|   |   +-- 1.png\n```\n\n_flagged/logs.csv_\n\n```csv\nim,Output\nim/0.png,Output/0.png\nim/1.png,Output/1.png\n```\n\n\u5982\u679c\u60a8\u5e0c\u671b\u7528\u6237\u63d0\u4f9b\u65d7\u6807\u539f\u56e0\uff0c\u53ef\u4ee5\u5c06\u5b57\u7b26\u4e32\u5217\u8868\u4f20\u9012\u7ed9 Interface \u7684 `flagging_options` \u53c2\u6570\u3002\u7528\u6237\u5728\u8fdb\u884c\u65d7\u6807\u65f6\u5fc5\u987b\u9009\u62e9\u5176\u4e2d\u4e00\u4e2a\u5b57\u7b26\u4e32\uff0c\u8fd9\u5c06\u4f5c\u4e3a\u9644\u52a0\u5217\u4fdd\u5b58\u5230 CSV \u4e2d\u3002\n\n## \u9884\u5904\u7406\u548c\u540e\u5904\u7406 (Preprocessing and Postprocessing)\n\n![annotated](/assets/img/dataflow.svg)\n\n\u5982\u60a8\u6240\u89c1\uff0cGradio \u5305\u62ec\u53ef\u4ee5\u5904\u7406\u5404\u79cd\u4e0d\u540c\u6570\u636e\u7c7b\u578b\u7684\u7ec4\u4ef6\uff0c\u4f8b\u5982\u56fe\u50cf\u3001\u97f3\u9891\u548c\u89c6\u9891\u3002\u5927\u591a\u6570\u7ec4\u4ef6\u90fd\u53ef\u4ee5\u7528\u4f5c\u8f93\u5165\u6216\u8f93\u51fa\u3002\n\n\u5f53\u7ec4\u4ef6\u7528\u4f5c\u8f93\u5165\u65f6\uff0cGradio \u81ea\u52a8\u5904\u7406*\u9884\u5904\u7406*\uff0c\u5c06\u6570\u636e\u4ece\u7528\u6237\n3,\tlabel_mask  # Set negative label positions to 0\nmean_loss = tf.reduce_sum(loss) / tf.reduce_sum(label_mask)\n```\n\nHere, we avoid data-dependent shapes by computing the loss for every position, but zeroing out the masked positions in both the numerator and denominator when we calculate the mean, which yields exactly the same result as the first block while maintaining XLA compatibility. Note that we use the same trick as in rule #1 - converting a `tf.bool` to `tf.float32` and using it as an indicator variable. This is a really useful trick, so remember it if you need to convert your own code to XLA!\n\n#### XLA Rule #3: XLA will need to recompile your model for every different input shape it sees\n\nThis is the big one. What this means is that if your input shapes are very variable, XLA will have to recompile your model over and over, which will create huge performance problems. This commonly arises in NLP models, where input texts have variable lengths after tokenization. In other modalities, static shapes are more common and this rule is much less of a problem.\n\nHow can you get around rule #3? The key is **padding** - if you pad all your inputs to the same length, and then use an `attention_mask`, you can get the same results as you\u2019d get from variable shapes, but without any XLA issues. However, excessive padding can cause severe slowdown too - if you pad all your samples to the maximum length in the whole dataset, you might end up with batches consisting endless padding tokens, which will waste a lot of compute and memory!\n\nThere isn\u2019t a perfect solution to this problem. However, you can try some tricks. One very useful trick is to **pad batches of samples up to a multiple of a number like 32 or 64 tokens.** This often only increases the number of tokens by a small amount, but it hugely reduces the number of unique input shapes, because every input shape now has to be a multiple of 32 or 64. Fewer unique input shapes means fewer XLA compilations!\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** Our tokenizers and data collators have methods that can help you here. You can use `padding=\"max_length\"` or `padding=\"longest\"` when calling tokenizers to get them to output padded data. Our tokenizers and data collators also have a `pad_to_multiple_of` argument that you can use to reduce the number of unique input shapes you see!\n\n</Tip>\n\n### How do I actually train my model on TPU?\n\nOnce your training is XLA-compatible and (if you\u2019re using TPU Node / Colab) your dataset has been prepared appropriately, running on TPU is surprisingly easy! All you really need to change in your code is to add a few lines to initialize your TPU, and to ensure that your model and dataset are created inside a `TPUStrategy` scope. Take a look at [our TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) to see this in action!\n\n### Summary\n\nThere was a lot in here, so let\u2019s summarize with a quick checklist you can follow when you want to get your model ready for TPU training:\n\n- Make sure your code follows the three rules of XLA\n- Compile your model with `jit_compile=True` on CPU/GPU and confirm that you can train it with XLA\n- Either load your dataset into memory or use a TPU-compatible dataset loading approach (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Migrate your code either to Colab (with accelerator set to \u201cTPU\u201d) or a TPU VM on Google Cloud\n- Add TPU initializer code (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Create your `TPUStrategy` and make sure dataset loading and model creation are inside the `strategy.scope()` (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Don\u2019t forget to take `jit_compile=True` out again when you move to TPU!\n- \ud83d\ude4f\ud83d\ude4f\ud83d\ude4f\ud83e\udd7a\ud83e\udd7a\ud83e\udd7a\n- Call model.fit()\n- You did it!\n    ```",
            "vector_context": "[Created at: 2025-03-24 13:17:32]\n!--Copyright 2023 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\nthe License. You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under the License is distributed on\nan \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n\n\u26a0\ufe0f Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be\nrendered properly in your Markdown viewer.\n\n-->\n\n# Training on TPU with TensorFlow\n\n<Tip>\n\nIf you don't need long explanations and just want TPU code samples to get started with, check out [our TPU example notebook!](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb)\n\n</Tip>\n\n### What is a TPU?\n\nA TPU is a **Tensor Processing Unit.** They are hardware designed by Google, which are used to greatly speed up the tensor computations within neural networks, much like GPUs. They can be used for both network training and inference. They are generally accessed through Google\u2019s cloud services, but small TPUs can also be accessed directly for free through Google Colab and Kaggle Kernels.\n\nBecause [all TensorFlow models in \ud83e\udd17 Transformers are Keras models](https://huggingface.co/blog/tensorflow-philosophy), most of the methods in this document are generally applicable to TPU training for any Keras model! However, there are a few points that are specific to the HuggingFace ecosystem (hug-o-system?) of Transformers and Datasets, and we\u2019ll make sure to flag them up when we get to them.\n\n### What kinds of TPU are available?\n\nNew users are often very confused by the range of TPUs, and the different ways to access them. The first key distinction to understand is the difference between **TPU Nodes** and **TPU VMs.**\n\nWhen you use a **TPU Node**, you are effectively indirectly accessing a remote TPU. You will need a separate VM, which will initialize your network and data pipeline and then forward them to the remote node. When you use a TPU on Google Colab, you are accessing it in the **TPU Node** style.\n\nUsing TPU Nodes can have some quite unexpected behaviour for people who aren\u2019t used to them! In particular, because the TPU is located on a physically different system to the machine you\u2019re running your Python code on, your data cannot be local to your machine - any data pipeline that loads from your machine\u2019s internal storage will totally fail! Instead, data must be stored in Google Cloud Storage where your data pipeline can still access it, even when the pipeline is running on the remote TPU node.\n\n<Tip>\n\nIf you can fit all your data in memory as `np.ndarray` or `tf.Tensor`, then you can `fit()` on that data even when using Colab or a TPU Node, without needing to upload it to Google Cloud Storage.\n\n</Tip>\n\n<Tip>\n\n**\ud83e\udd17Specific Hugging Face Tip\ud83e\udd17:** The methods `Dataset.to_tf_dataset()` and its higher-level wrapper `model.prepare_tf_dataset()` , which you will see throughout our TF code examples, will both fail on a TPU Node. The reason for this is that even though they create a `tf.data.Dataset` it is not a \u201cpure\u201d `tf.data` pipeline and uses `tf.numpy_function` or `Dataset.from_generator()` to stream data from the underlying HuggingFace `Dataset`. This HuggingFace `Dataset` is backed by data that is on a local disc and which the remote TPU Node will not be able to read.\n\n</Tip>\n\nThe second way to access a TPU is via a **TPU VM.** When using a TPU VM, you connect directly to the machine that the TPU is attached to, much like training on a GPU VM. TPU VMs are generally easier to work with, particularly when it comes to your data pipeline. All of the above warnings do not apply to TPU VMs!\n\nThis is an opinionated document, so here\u2019s our opinion: **Avoid using TPU Node if possible.** It is more confusing and more difficult to debug than TPU VMs. It is also likely to be unsupported in future - Google\u2019s latest TPU, TPUv4, can only be accessed as a TPU VM, which suggests that TPU Nodes are increasingly going to become a \u201clegacy\u201d access method. However, we understand that the only free TPU access is on Colab and Kaggle Kernels, which uses TPU Node - so we\u2019ll try to explain how to handle it if you have to! Check the [TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) for code samples that explain this in more detail.\n\n### What sizes of TPU are available?\n\nA single TPU (a v2-8/v3-8/v4-8) runs 8 replicas. TPUs exist in **pods** that can run hundreds or thousands of replicas simultaneously. When you use more than a single TPU but less than a whole pod (for example, a v3-32), your TPU fleet is referred to as a **pod slice.**\n\nWhen you access a free TPU via Colab, you generally get a single v2-8 TPU.\n\n### I keep hearing about this XLA thing. What\u2019s XLA, and how does it relate to TPUs?\n\nXLA is an optimizing compiler, used by both TensorFlow and JAX. In JAX it is the only compiler, whereas in TensorFlow it is optional\n--New Chunk--\n[Created at: 2025-03-24 13:19:17]\n!---\nCopyright 2022 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n-->\n\n# Token classification with LayoutLMv3 (PyTorch version)\n\nThis directory contains a script, `run_funsd_cord.py`, that can be used to fine-tune (or evaluate) LayoutLMv3 on form understanding datasets, such as [FUNSD](https://guillaumejaume.github.io/FUNSD/) and [CORD](https://github.com/clovaai/cord).\n\nThe script `run_funsd_cord.py` leverages the \ud83e\udd17 Datasets library and the Trainer API. You can easily customize it to your needs.\n\n## Fine-tuning on FUNSD\n\nFine-tuning LayoutLMv3 for token classification on [FUNSD](https://guillaumejaume.github.io/FUNSD/) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name funsd \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 1e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-funsd\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd. By specifying the `push_to_hub` flag, the model gets uploaded automatically to the hub (regularly), together with a model card, which includes metrics such as precision, recall and F1. Note that you can easily update the model card, as it's just a README file of the respective repo on the hub.\n\nThere's also the \"Training metrics\" [tab](https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd/tensorboard), which shows Tensorboard logs over the course of training. Pretty neat, huh?\n\n## Fine-tuning on CORD\n\nFine-tuning LayoutLMv3 for token classification on [CORD](https://github.com/clovaai/cord) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name cord \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 5e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-cord\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-cord. Note that a model card gets generated automatically in case you specify the `push_to_hub` flag.\n--New Chunk--\n[Created at: 2025-03-24 13:17:32]\nlabel_mask  # Set negative label positions to 0\nmean_loss = tf.reduce_sum(loss) / tf.reduce_sum(label_mask)\n```\n\nHere, we avoid data-dependent shapes by computing the loss for every position, but zeroing out the masked positions in both the numerator and denominator when we calculate the mean, which yields exactly the same result as the first block while maintaining XLA compatibility. Note that we use the same trick as in rule #1 - converting a `tf.bool` to `tf.float32` and using it as an indicator variable. This is a really useful trick, so remember it if you need to convert your own code to XLA!\n\n#### XLA Rule #3: XLA will need to recompile your model for every different input shape it sees\n\nThis is the big one. What this means is that if your input shapes are very variable, XLA will have to recompile your model over and over, which will create huge performance problems. This commonly arises in NLP models, where input texts have variable lengths after tokenization. In other modalities, static shapes are more common and this rule is much less of a problem.\n\nHow can you get around rule #3? The key is **padding** - if you pad all your inputs to the same length, and then use an `attention_mask`, you can get the same results as you\u2019d get from variable shapes, but without any XLA issues. However, excessive padding can cause severe slowdown too - if you pad all your samples to the maximum length in the whole dataset, you might end up with batches consisting endless padding tokens, which will waste a lot of compute and memory!\n\nThere isn\u2019t a perfect solution to this problem. However, you can try some tricks. One very useful trick is to **pad batches of samples up to a multiple of a number like 32 or 64 tokens.** This often only increases the number of tokens by a small amount, but it hugely reduces the number of unique input shapes, because every input shape now has to be a multiple of 32 or 64. Fewer unique input shapes means fewer XLA compilations!\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** Our tokenizers and data collators have methods that can help you here. You can use `padding=\"max_length\"` or `padding=\"longest\"` when calling tokenizers to get them to output padded data. Our tokenizers and data collators also have a `pad_to_multiple_of` argument that you can use to reduce the number of unique input shapes you see!\n\n</Tip>\n\n### How do I actually train my model on TPU?\n\nOnce your training is XLA-compatible and (if you\u2019re using TPU Node / Colab) your dataset has been prepared appropriately, running on TPU is surprisingly easy! All you really need to change in your code is to add a few lines to initialize your TPU, and to ensure that your model and dataset are created inside a `TPUStrategy` scope. Take a look at [our TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) to see this in action!\n\n### Summary\n\nThere was a lot in here, so let\u2019s summarize with a quick checklist you can follow when you want to get your model ready for TPU training:\n\n- Make sure your code follows the three rules of XLA\n- Compile your model with `jit_compile=True` on CPU/GPU and confirm that you can train it with XLA\n- Either load your dataset into memory or use a TPU-compatible dataset loading approach (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Migrate your code either to Colab (with accelerator set to \u201cTPU\u201d) or a TPU VM on Google Cloud\n- Add TPU initializer code (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Create your `TPUStrategy` and make sure dataset loading and model creation are inside the `strategy.scope()` (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Don\u2019t forget to take `jit_compile=True` out again when you move to TPU!\n- \ud83d\ude4f\ud83d\ude4f\ud83d\ude4f\ud83e\udd7a\ud83e\udd7a\ud83e\udd7a\n- Call model.fit()\n- You did it!"
        }
    },
    {
        "sample_idx": 73,
        "question": "What can excessive padding cause?",
        "answer": "Excessive padding can cause severe slowdown.",
        "rag_answer": "Excessive padding can cause severe slowdowns in performance and memory waste. If you pad all your samples to the maximum length in the whole dataset, you might end up with batches consisting of endless padding tokens, which will waste a lot of compute and memory.",
        "rag_score": null,
        "rag_feedback": null,
        "rag_context": {
            "kg_context": "-----Entities-----\n    ```csv\n    id,\tentity,\ttype,\tdescription,\trankcreated_at\n1,\tFUNSD,geo,FUNSD is a form understanding dataset used for fine-tuning LayoutLMv3.,1,2025-03-24 13:18:20\n2,\tLayoutLMv3,technology,LayoutLMv3 is a model used for token classification and form understanding tasks.,11,2025-03-24 13:18:20\n3,\tCORD,geo,CORD is a form understanding dataset used for fine-tuning LayoutLMv3.,1,2025-03-24 13:18:20\n4,\tHuggingFace,organization,HuggingFace is a company that provides a range of AI models and tools, including the Transformers and Datasets ecosystem.<SEP>HuggingFace is an organization that provides pre-trained models and loss functions for machine learning.<SEP>HuggingFace is an organization that provides tools and resources for natural language processing and machine learning.,5,2025-03-24 13:18:20\n5,\tXLA,technology,XLA is a technology that compiles TensorFlow graphs into executable code for various platforms.<SEP>XLA is an optimizing compiler used by TensorFlow and JAX to improve performance.<SEP>XLA is an optimizing compiler, used by both TensorFlow and JAX to optimize computations.,6,2025-03-24 13:18:20\n6,\tCORD,geo,CORD is a form understanding dataset used for fine-tuning LayoutLMv3.,1,UNKNOWN\n7,\tMDX,category,MDX is a syntax for Markdown that is used by the HuggingFace doc-builder.,0,UNKNOWN\n8,\tFUNSD,geo,FUNSD is a form understanding dataset used for fine-tuning LayoutLMv3.,1,UNKNOWN\n    ```\n    -----Relationships-----\n    ```csv\n    id,\tsource,\ttarget,\tdescription,\tkeywords,\tweight,\trank,\tcreated_at\n1,\tFUNSD,LayoutLMv3,FUNSD is a dataset used for fine-tuning the LayoutLMv3 model.,dataset, model training,14.0,12,2025-03-24 13:19:57\n2,\tCORD,LayoutLMv3,CORD is a dataset used for fine-tuning the LayoutLMv3 model.,dataset, model training,14.0,12,2025-03-24 13:19:57\n3,\tHuggingFace,XLA,HuggingFace provides pre-trained models and loss functions that are XLA-compatible.,compatibility, pre-trained models,8.0,11,2025-03-24 13:18:20\n4,\tCORD,LayoutLMv3,CORD is a dataset used for fine-tuning the LayoutLMv3 model.,dataset, model training,14.0,12,UNKNOWN\n5,\tFUNSD,LayoutLMv3,FUNSD is a dataset used for fine-tuning the LayoutLMv3 model.,dataset, model training,14.0,12,UNKNOWN\n    ```\n    -----Sources-----\n    ```csv\n    id,\tcontent\n1,\t!---\nCopyright 2022 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n-->\n\n# Token classification with LayoutLMv3 (PyTorch version)\n\nThis directory contains a script, `run_funsd_cord.py`, that can be used to fine-tune (or evaluate) LayoutLMv3 on form understanding datasets, such as [FUNSD](https://guillaumejaume.github.io/FUNSD/) and [CORD](https://github.com/clovaai/cord).\n\nThe script `run_funsd_cord.py` leverages the \ud83e\udd17 Datasets library and the Trainer API. You can easily customize it to your needs.\n\n## Fine-tuning on FUNSD\n\nFine-tuning LayoutLMv3 for token classification on [FUNSD](https://guillaumejaume.github.io/FUNSD/) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name funsd \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 1e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-funsd\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd. By specifying the `push_to_hub` flag, the model gets uploaded automatically to the hub (regularly), together with a model card, which includes metrics such as precision, recall and F1. Note that you can easily update the model card, as it's just a README file of the respective repo on the hub.\n\nThere's also the \"Training metrics\" [tab](https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd/tensorboard), which shows Tensorboard logs over the course of training. Pretty neat, huh?\n\n## Fine-tuning on CORD\n\nFine-tuning LayoutLMv3 for token classification on [CORD](https://github.com/clovaai/cord) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name cord \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 5e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-cord\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-cord. Note that a model card gets generated automatically in case you specify the `push_to_hub` flag.\n2,\t(for example, a v3-32), your TPU fleet is referred to as a **pod slice.**\n\nWhen you access a free TPU via Colab, you generally get a single v2-8 TPU.\n\n### I keep hearing about this XLA thing. What\u2019s XLA, and how does it relate to TPUs?\n\nXLA is an optimizing compiler, used by both TensorFlow and JAX. In JAX it is the only compiler, whereas in TensorFlow it is optional (but mandatory on TPU!). The easiest way to enable it when training a Keras model is to pass the argument `jit_compile=True` to `model.compile()`. If you don\u2019t get any errors and performance is good, that\u2019s a great sign that you\u2019re ready to move to TPU!\n\nDebugging on TPU is generally a bit harder than on CPU/GPU, so we recommend getting your code running on CPU/GPU with XLA first before trying it on TPU. You don\u2019t have to train for long, of course - just for a few steps to make sure that your model and data pipeline are working like you expect them to.\n\n<Tip>\n\nXLA compiled code is usually faster - so even if you\u2019re not planning to run on TPU, adding `jit_compile=True` can improve your performance. Be sure to note the caveats below about XLA compatibility, though!\n\n</Tip>\n\n<Tip warning={true}>\n\n**Tip born of painful experience:** Although using `jit_compile=True` is a good way to get a speed boost and test if your CPU/GPU code is XLA-compatible, it can actually cause a lot of problems if you leave it in when actually training on TPU. XLA compilation will happen implicitly on TPU, so remember to remove that line before actually running your code on a TPU!\n\n</Tip>\n\n### How do I make my model XLA compatible?\n\nIn many cases, your code is probably XLA-compatible already! However, there are a few things that work in normal TensorFlow that don\u2019t work in XLA. We\u2019ve distilled them into three core rules below:\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** We\u2019ve put a lot of effort into rewriting our TensorFlow models and loss functions to be XLA-compatible. Our models and loss functions generally obey rule #1 and #2 by default, so you can skip over them if you\u2019re using `transformers` models. Don\u2019t forget about these rules when writing your own models and loss functions, though!\n\n</Tip>\n\n#### XLA Rule #1: Your code cannot have \u201cdata-dependent conditionals\u201d\n\nWhat that means is that any `if` statement cannot depend on values inside a `tf.Tensor`. For example, this code block cannot be compiled with XLA!\n\n```python\nif tf.reduce_sum(tensor) > 10:\n    tensor = tensor / 2.0\n```\n\nThis might seem very restrictive at first, but most neural net code doesn\u2019t need to do this. You can often get around this restriction by using `tf.cond` (see the documentation [here](https://www.tensorflow.org/api_docs/python/tf/cond)) or by removing the conditional and finding a clever math trick with indicator variables instead, like so:\n\n```python\nsum_over_10 = tf.cast(tf.reduce_sum(tensor) > 10, tf.float32)\ntensor = tensor / (1.0 + sum_over_10)\n```\n\nThis code has exactly the same effect as the code above, but by avoiding a conditional, we ensure it will compile with XLA without problems!\n\n#### XLA Rule #2: Your code cannot have \u201cdata-dependent shapes\u201d\n\nWhat this means is that the shape of all of the `tf.Tensor` objects in your code cannot depend on their values. For example, the function `tf.unique` cannot be compiled with XLA, because it returns a `tensor` containing one instance of each unique value in the input. The shape of this output will obviously be different depending on how repetitive the input `Tensor` was, and so XLA refuses to handle it!\n\nIn general, most neural network code obeys rule #2 by default. However, there are a few common cases where it becomes a problem. One very common one is when you use **label masking**, setting your labels to a negative value to indicate that those positions should be ignored when computing the loss. If you look at NumPy or PyTorch loss functions that support label masking, you will often see code like this that uses [boolean indexing](https://numpy.org/doc/stable/user/basics.indexing.html#boolean-array-indexing):\n\n```python\nlabel_mask = labels >= 0\nmasked_outputs = outputs[label_mask]\nmasked_labels = labels[label_mask]\nloss = compute_loss(masked_outputs, masked_labels)\nmean_loss = torch.mean(loss)\n```\n\nThis code is totally fine in NumPy or PyTorch, but it breaks in XLA! Why? Because the shape of `masked_outputs` and `masked_labels` depends on how many positions are masked - that makes it a **data-dependent shape.** However, just like for rule #1, we can often rewrite this code to yield exactly the same output without any data-dependent shapes.\n\n```python\nlabel_mask = tf.cast(labels >= 0, tf.float32)\nloss = compute_loss(outputs, labels)\nloss = loss * label_mask  # Set negative label positions to 0\nmean_loss = tf.reduce_sum(loss) / tf.reduce_sum(label_mask)\n```\n\nHere, we avoid data-dependent shapes by computing the loss for every position, but zeroing out the masked positions in both the numerator and denominator when we calculate the mean, which yields exactly the same result as the first block while maintaining XLA compatibility. Note that we use the same trick as in rule #1 - converting a `tf.bool` to `\n3,\t!--Copyright 2023 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\nthe License. You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under the License is distributed on\nan \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n\n\u26a0\ufe0f Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be\nrendered properly in your Markdown viewer.\n\n-->\n\n# Training on TPU with TensorFlow\n\n<Tip>\n\nIf you don't need long explanations and just want TPU code samples to get started with, check out [our TPU example notebook!](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb)\n\n</Tip>\n\n### What is a TPU?\n\nA TPU is a **Tensor Processing Unit.** They are hardware designed by Google, which are used to greatly speed up the tensor computations within neural networks, much like GPUs. They can be used for both network training and inference. They are generally accessed through Google\u2019s cloud services, but small TPUs can also be accessed directly for free through Google Colab and Kaggle Kernels.\n\nBecause [all TensorFlow models in \ud83e\udd17 Transformers are Keras models](https://huggingface.co/blog/tensorflow-philosophy), most of the methods in this document are generally applicable to TPU training for any Keras model! However, there are a few points that are specific to the HuggingFace ecosystem (hug-o-system?) of Transformers and Datasets, and we\u2019ll make sure to flag them up when we get to them.\n\n### What kinds of TPU are available?\n\nNew users are often very confused by the range of TPUs, and the different ways to access them. The first key distinction to understand is the difference between **TPU Nodes** and **TPU VMs.**\n\nWhen you use a **TPU Node**, you are effectively indirectly accessing a remote TPU. You will need a separate VM, which will initialize your network and data pipeline and then forward them to the remote node. When you use a TPU on Google Colab, you are accessing it in the **TPU Node** style.\n\nUsing TPU Nodes can have some quite unexpected behaviour for people who aren\u2019t used to them! In particular, because the TPU is located on a physically different system to the machine you\u2019re running your Python code on, your data cannot be local to your machine - any data pipeline that loads from your machine\u2019s internal storage will totally fail! Instead, data must be stored in Google Cloud Storage where your data pipeline can still access it, even when the pipeline is running on the remote TPU node.\n\n<Tip>\n\nIf you can fit all your data in memory as `np.ndarray` or `tf.Tensor`, then you can `fit()` on that data even when using Colab or a TPU Node, without needing to upload it to Google Cloud Storage.\n\n</Tip>\n\n<Tip>\n\n**\ud83e\udd17Specific Hugging Face Tip\ud83e\udd17:** The methods `Dataset.to_tf_dataset()` and its higher-level wrapper `model.prepare_tf_dataset()` , which you will see throughout our TF code examples, will both fail on a TPU Node. The reason for this is that even though they create a `tf.data.Dataset` it is not a \u201cpure\u201d `tf.data` pipeline and uses `tf.numpy_function` or `Dataset.from_generator()` to stream data from the underlying HuggingFace `Dataset`. This HuggingFace `Dataset` is backed by data that is on a local disc and which the remote TPU Node will not be able to read.\n\n</Tip>\n\nThe second way to access a TPU is via a **TPU VM.** When using a TPU VM, you connect directly to the machine that the TPU is attached to, much like training on a GPU VM. TPU VMs are generally easier to work with, particularly when it comes to your data pipeline. All of the above warnings do not apply to TPU VMs!\n\nThis is an opinionated document, so here\u2019s our opinion: **Avoid using TPU Node if possible.** It is more confusing and more difficult to debug than TPU VMs. It is also likely to be unsupported in future - Google\u2019s latest TPU, TPUv4, can only be accessed as a TPU VM, which suggests that TPU Nodes are increasingly going to become a \u201clegacy\u201d access method. However, we understand that the only free TPU access is on Colab and Kaggle Kernels, which uses TPU Node - so we\u2019ll try to explain how to handle it if you have to! Check the [TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) for code samples that explain this in more detail.\n\n### What sizes of TPU are available?\n\nA single TPU (a v2-8/v3-8/v4-8) runs 8 replicas. TPUs exist in **pods** that can run hundreds or thousands of replicas simultaneously. When you use more than a single TPU but less than a whole pod (for example, a v3-32), your TPU fleet is referred to as a **pod slice.**\n\nWhen you access a free TPU via Colab, you generally get a single v2-8 TPU.\n\n### I keep hearing about this XLA thing. What\u2019s XLA, and how does it relate to TPUs?\n\nXLA is an optimizing compiler, used by both TensorFlow and JAX. In JAX it is the only compiler, whereas in TensorFlow it is optional\n    ```",
            "vector_context": "[Created at: 2025-03-24 13:17:32]\nlabel_mask  # Set negative label positions to 0\nmean_loss = tf.reduce_sum(loss) / tf.reduce_sum(label_mask)\n```\n\nHere, we avoid data-dependent shapes by computing the loss for every position, but zeroing out the masked positions in both the numerator and denominator when we calculate the mean, which yields exactly the same result as the first block while maintaining XLA compatibility. Note that we use the same trick as in rule #1 - converting a `tf.bool` to `tf.float32` and using it as an indicator variable. This is a really useful trick, so remember it if you need to convert your own code to XLA!\n\n#### XLA Rule #3: XLA will need to recompile your model for every different input shape it sees\n\nThis is the big one. What this means is that if your input shapes are very variable, XLA will have to recompile your model over and over, which will create huge performance problems. This commonly arises in NLP models, where input texts have variable lengths after tokenization. In other modalities, static shapes are more common and this rule is much less of a problem.\n\nHow can you get around rule #3? The key is **padding** - if you pad all your inputs to the same length, and then use an `attention_mask`, you can get the same results as you\u2019d get from variable shapes, but without any XLA issues. However, excessive padding can cause severe slowdown too - if you pad all your samples to the maximum length in the whole dataset, you might end up with batches consisting endless padding tokens, which will waste a lot of compute and memory!\n\nThere isn\u2019t a perfect solution to this problem. However, you can try some tricks. One very useful trick is to **pad batches of samples up to a multiple of a number like 32 or 64 tokens.** This often only increases the number of tokens by a small amount, but it hugely reduces the number of unique input shapes, because every input shape now has to be a multiple of 32 or 64. Fewer unique input shapes means fewer XLA compilations!\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** Our tokenizers and data collators have methods that can help you here. You can use `padding=\"max_length\"` or `padding=\"longest\"` when calling tokenizers to get them to output padded data. Our tokenizers and data collators also have a `pad_to_multiple_of` argument that you can use to reduce the number of unique input shapes you see!\n\n</Tip>\n\n### How do I actually train my model on TPU?\n\nOnce your training is XLA-compatible and (if you\u2019re using TPU Node / Colab) your dataset has been prepared appropriately, running on TPU is surprisingly easy! All you really need to change in your code is to add a few lines to initialize your TPU, and to ensure that your model and dataset are created inside a `TPUStrategy` scope. Take a look at [our TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) to see this in action!\n\n### Summary\n\nThere was a lot in here, so let\u2019s summarize with a quick checklist you can follow when you want to get your model ready for TPU training:\n\n- Make sure your code follows the three rules of XLA\n- Compile your model with `jit_compile=True` on CPU/GPU and confirm that you can train it with XLA\n- Either load your dataset into memory or use a TPU-compatible dataset loading approach (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Migrate your code either to Colab (with accelerator set to \u201cTPU\u201d) or a TPU VM on Google Cloud\n- Add TPU initializer code (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Create your `TPUStrategy` and make sure dataset loading and model creation are inside the `strategy.scope()` (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Don\u2019t forget to take `jit_compile=True` out again when you move to TPU!\n- \ud83d\ude4f\ud83d\ude4f\ud83d\ude4f\ud83e\udd7a\ud83e\udd7a\ud83e\udd7a\n- Call model.fit()\n- You did it!\n--New Chunk--\n[Created at: 2025-03-24 13:17:32]\n(for example, a v3-32), your TPU fleet is referred to as a **pod slice.**\n\nWhen you access a free TPU via Colab, you generally get a single v2-8 TPU.\n\n### I keep hearing about this XLA thing. What\u2019s XLA, and how does it relate to TPUs?\n\nXLA is an optimizing compiler, used by both TensorFlow and JAX. In JAX it is the only compiler, whereas in TensorFlow it is optional (but mandatory on TPU!). The easiest way to enable it when training a Keras model is to pass the argument `jit_compile=True` to `model.compile()`. If you don\u2019t get any errors and performance is good, that\u2019s a great sign that you\u2019re ready to move to TPU!\n\nDebugging on TPU is generally a bit harder than on CPU/GPU, so we recommend getting your code running on CPU/GPU with XLA first before trying it on TPU. You don\u2019t have to train for long, of course - just for a few steps to make sure that your model and data pipeline are working like you expect them to.\n\n<Tip>\n\nXLA compiled code is usually faster - so even if you\u2019re not planning to run on TPU, adding `jit_compile=True` can improve your performance. Be sure to note the caveats below about XLA compatibility, though!\n\n</Tip>\n\n<Tip warning={true}>\n\n**Tip born of painful experience:** Although using `jit_compile=True` is a good way to get a speed boost and test if your CPU/GPU code is XLA-compatible, it can actually cause a lot of problems if you leave it in when actually training on TPU. XLA compilation will happen implicitly on TPU, so remember to remove that line before actually running your code on a TPU!\n\n</Tip>\n\n### How do I make my model XLA compatible?\n\nIn many cases, your code is probably XLA-compatible already! However, there are a few things that work in normal TensorFlow that don\u2019t work in XLA. We\u2019ve distilled them into three core rules below:\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** We\u2019ve put a lot of effort into rewriting our TensorFlow models and loss functions to be XLA-compatible. Our models and loss functions generally obey rule #1 and #2 by default, so you can skip over them if you\u2019re using `transformers` models. Don\u2019t forget about these rules when writing your own models and loss functions, though!\n\n</Tip>\n\n#### XLA Rule #1: Your code cannot have \u201cdata-dependent conditionals\u201d\n\nWhat that means is that any `if` statement cannot depend on values inside a `tf.Tensor`. For example, this code block cannot be compiled with XLA!\n\n```python\nif tf.reduce_sum(tensor) > 10:\n    tensor = tensor / 2.0\n```\n\nThis might seem very restrictive at first, but most neural net code doesn\u2019t need to do this. You can often get around this restriction by using `tf.cond` (see the documentation [here](https://www.tensorflow.org/api_docs/python/tf/cond)) or by removing the conditional and finding a clever math trick with indicator variables instead, like so:\n\n```python\nsum_over_10 = tf.cast(tf.reduce_sum(tensor) > 10, tf.float32)\ntensor = tensor / (1.0 + sum_over_10)\n```\n\nThis code has exactly the same effect as the code above, but by avoiding a conditional, we ensure it will compile with XLA without problems!\n\n#### XLA Rule #2: Your code cannot have \u201cdata-dependent shapes\u201d\n\nWhat this means is that the shape of all of the `tf.Tensor` objects in your code cannot depend on their values. For example, the function `tf.unique` cannot be compiled with XLA, because it returns a `tensor` containing one instance of each unique value in the input. The shape of this output will obviously be different depending on how repetitive the input `Tensor` was, and so XLA refuses to handle it!\n\nIn general, most neural network code obeys rule #2 by default. However, there are a few common cases where it becomes a problem. One very common one is when you use **label masking**, setting your labels to a negative value to indicate that those positions should be ignored when computing the loss. If you look at NumPy or PyTorch loss functions that support label masking, you will often see code like this that uses [boolean indexing](https://numpy.org/doc/stable/user/basics.indexing.html#boolean-array-indexing):\n\n```python\nlabel_mask = labels >= 0\nmasked_outputs = outputs[label_mask]\nmasked_labels = labels[label_mask]\nloss = compute_loss(masked_outputs, masked_labels)\nmean_loss = torch.mean(loss)\n```\n\nThis code is totally fine in NumPy or PyTorch, but it breaks in XLA! Why? Because the shape of `masked_outputs` and `masked_labels` depends on how many positions are masked - that makes it a **data-dependent shape.** However, just like for rule #1, we can often rewrite this code to yield exactly the same output without any data-dependent shapes.\n\n```python\nlabel_mask = tf.cast(labels >= 0, tf.float32)\nloss = compute_loss(outputs, labels)\nloss = loss * label_mask  # Set negative label positions to 0\nmean_loss = tf.reduce_sum(loss) / tf.reduce_sum(label_mask)\n```\n\nHere, we avoid data-dependent shapes by computing the loss for every position, but zeroing out the masked positions in both the numerator and denominator when we calculate the mean, which yields exactly the same result as the first block while maintaining XLA compatibility. Note that we use the same trick as in rule #1 - converting a `tf.bool` to `\n--New Chunk--\n[Created at: 2025-03-24 13:16:48]\n\u65f6\u5fc5\u987b\u9009\u62e9\u5176\u4e2d\u4e00\u4e2a\u5b57\u7b26\u4e32\uff0c\u8fd9\u5c06\u4f5c\u4e3a\u9644\u52a0\u5217\u4fdd\u5b58\u5230 CSV \u4e2d\u3002\n\n## \u9884\u5904\u7406\u548c\u540e\u5904\u7406 (Preprocessing and Postprocessing)\n\n![annotated](/assets/img/dataflow.svg)\n\n\u5982\u60a8\u6240\u89c1\uff0cGradio \u5305\u62ec\u53ef\u4ee5\u5904\u7406\u5404\u79cd\u4e0d\u540c\u6570\u636e\u7c7b\u578b\u7684\u7ec4\u4ef6\uff0c\u4f8b\u5982\u56fe\u50cf\u3001\u97f3\u9891\u548c\u89c6\u9891\u3002\u5927\u591a\u6570\u7ec4\u4ef6\u90fd\u53ef\u4ee5\u7528\u4f5c\u8f93\u5165\u6216\u8f93\u51fa\u3002\n\n\u5f53\u7ec4\u4ef6\u7528\u4f5c\u8f93\u5165\u65f6\uff0cGradio \u81ea\u52a8\u5904\u7406*\u9884\u5904\u7406*\uff0c\u5c06\u6570\u636e\u4ece\u7528\u6237\u6d4f\u89c8\u5668\u53d1\u9001\u7684\u7c7b\u578b\uff08\u4f8b\u5982\u7f51\u7edc\u6444\u50cf\u5934\u5feb\u7167\u7684 base64 \u8868\u793a\uff09\u8f6c\u6362\u4e3a\u60a8\u7684\u51fd\u6570\u53ef\u4ee5\u63a5\u53d7\u7684\u5f62\u5f0f\uff08\u4f8b\u5982 `numpy` \u6570\u7ec4\uff09\u3002\n\n\u540c\u6837\uff0c\u5f53\u7ec4\u4ef6\u7528\u4f5c\u8f93\u51fa\u65f6\uff0cGradio \u81ea\u52a8\u5904\u7406*\u540e\u5904\u7406*\uff0c\u5c06\u6570\u636e\u4ece\u51fd\u6570\u8fd4\u56de\u7684\u5f62\u5f0f\uff08\u4f8b\u5982\u56fe\u50cf\u8def\u5f84\u5217\u8868\uff09\u8f6c\u6362\u4e3a\u53ef\u4ee5\u5728\u7528\u6237\u6d4f\u89c8\u5668\u4e2d\u663e\u793a\u7684\u5f62\u5f0f\uff08\u4f8b\u5982\u4ee5 base64 \u683c\u5f0f\u663e\u793a\u56fe\u50cf\u7684 `Gallery`\uff09\u3002\n\n\u60a8\u53ef\u4ee5\u4f7f\u7528\u6784\u5efa\u56fe\u50cf\u7ec4\u4ef6\u65f6\u7684\u53c2\u6570\u63a7\u5236*\u9884\u5904\u7406*\u3002\u4f8b\u5982\uff0c\u5982\u679c\u60a8\u4f7f\u7528\u4ee5\u4e0b\u53c2\u6570\u5b9e\u4f8b\u5316 `Image` \u7ec4\u4ef6\uff0c\u5b83\u5c06\u5c06\u56fe\u50cf\u8f6c\u6362\u4e3a `PIL` \u7c7b\u578b\uff0c\u5e76\u5c06\u5176\u91cd\u5851\u4e3a`(100, 100)`\uff0c\u800c\u4e0d\u7ba1\u63d0\u4ea4\u65f6\u7684\u539f\u59cb\u5927\u5c0f\u5982\u4f55\uff1a\n\n```py\nimg = gr.Image(shape=(100, 100), type=\"pil\")\n```\n\n\u76f8\u53cd\uff0c\u8fd9\u91cc\u6211\u4eec\u4fdd\u7559\u56fe\u50cf\u7684\u539f\u59cb\u5927\u5c0f\uff0c\u4f46\u5728\u5c06\u5176\u8f6c\u6362\u4e3a numpy \u6570\u7ec4\u4e4b\u524d\u53cd\u8f6c\u989c\u8272\uff1a\n\n```py\nimg = gr.Image(invert_colors=True, type=\"numpy\")\n```\n\n\u540e\u5904\u7406\u8981\u5bb9\u6613\u5f97\u591a\uff01Gradio \u81ea\u52a8\u8bc6\u522b\u8fd4\u56de\u6570\u636e\u7684\u683c\u5f0f\uff08\u4f8b\u5982 `Image` \u662f `numpy` \u6570\u7ec4\u8fd8\u662f `str` \u6587\u4ef6\u8def\u5f84\uff1f\uff09\uff0c\u5e76\u5c06\u5176\u540e\u5904\u7406\u4e3a\u53ef\u4ee5\u7531\u6d4f\u89c8\u5668\u663e\u793a\u7684\u683c\u5f0f\u3002\n\n\u8bf7\u67e5\u770b[\u6587\u6863](https://gradio.app/docs)\uff0c\u4e86\u89e3\u6bcf\u4e2a\u7ec4\u4ef6\u7684\u6240\u6709\u4e0e\u9884\u5904\u7406\u76f8\u5173\u7684\u53c2\u6570\u3002\n\n## \u6837\u5f0f (Styling)\n\nGradio \u4e3b\u9898\u662f\u81ea\u5b9a\u4e49\u5e94\u7528\u7a0b\u5e8f\u5916\u89c2\u548c\u611f\u89c9\u7684\u6700\u7b80\u5355\u65b9\u6cd5\u3002\u60a8\u53ef\u4ee5\u9009\u62e9\u591a\u79cd\u4e3b\u9898\u6216\u521b\u5efa\u81ea\u5df1\u7684\u4e3b\u9898\u3002\u8981\u8fd9\u6837\u505a\uff0c\u8bf7\u5c06 `theme=` \u53c2\u6570\u4f20\u9012\u7ed9 `Interface` \u6784\u9020\u51fd\u6570\u3002\u4f8b\u5982\uff1a\n\n```python\ndemo = gr.Interface(..., theme=gr.themes.Monochrome())\n```\n\nGradio \u5e26\u6709\u4e00\u7ec4\u9884\u5148\u6784\u5efa\u7684\u4e3b\u9898\uff0c\u60a8\u53ef\u4ee5\u4ece `gr.themes.*` \u52a0\u8f7d\u3002\u60a8\u53ef\u4ee5\u6269\u5c55\u8fd9\u4e9b\u4e3b\u9898\u6216\u4ece\u5934\u5f00\u59cb\u521b\u5efa\u81ea\u5df1\u7684\u4e3b\u9898 - \u6709\u5173\u66f4\u591a\u8be6\u7ec6\u4fe1\u606f\uff0c\u8bf7\u53c2\u9605[\u4e3b\u9898\u6307\u5357](https://gradio.app/theming-guide)\u3002\n\n\u8981\u589e\u52a0\u989d\u5916\u7684\u6837\u5f0f\u80fd\u529b\uff0c\u60a8\u53ef\u4ee5 with `css=` \u5173\u952e\u5b57\u5c06\u4efb\u4f55 CSS \u4f20\u9012\u7ed9\u60a8\u7684\u5e94\u7528\u7a0b\u5e8f\u3002\nGradio \u5e94\u7528\u7a0b\u5e8f\u7684\u57fa\u7c7b\u662f `gradio-container`\uff0c\u56e0\u6b64\u4ee5\u4e0b\u662f\u4e00\u4e2a\u66f4\u6539 Gradio \u5e94\u7528\u7a0b\u5e8f\u80cc\u666f\u989c\u8272\u7684\u793a\u4f8b\uff1a\n\n```python\nwith `gr.Interface(css=\".gradio-container {background-color: red}\") as demo:\n    ...\n```\n\n## \u961f\u5217 (Queuing)\n\n\u5982\u679c\u60a8\u7684\u5e94\u7528\u7a0b\u5e8f\u9884\u8ba1\u4f1a\u6709\u5927\u91cf\u6d41\u91cf\uff0c\u8bf7 with `queue()` \u65b9\u6cd5\u6765\u63a7\u5236\u5904\u7406\u901f\u7387\u3002\u8fd9\u5c06\u6392\u961f\u5904\u7406\u8c03\u7528\uff0c\u56e0\u6b64\u4e00\u6b21\u53ea\u5904\u7406\u4e00\u5b9a\u6570\u91cf\u7684\u8bf7\u6c42\u3002\u961f\u5217\u4f7f\u7528 Websockets\uff0c\u8fd8\u53ef\u4ee5\u9632\u6b62\u7f51\u7edc\u8d85\u65f6\uff0c\u56e0\u6b64\u5982\u679c\u60a8\u7684\u51fd\u6570\u7684\u63a8\u7406\u65f6\u95f4\u5f88\u957f\uff08> 1 \u5206\u949f\uff09\uff0c\u5e94\u4f7f\u7528\u961f\u5217\u3002\n\nwith `Interface`\uff1a\n\n```python\ndemo = gr.Interface(...).queue()\ndemo.launch()\n```\n\nwith `Blocks`\uff1a\n\n```python\nwith gr.Blocks() as demo\uff1a\n    #...\ndemo.queue()\ndemo.launch()\n```\n\n\u60a8\u53ef\u4ee5\u901a\u8fc7\u4ee5\u4e0b\u65b9\u5f0f\u63a7\u5236\u4e00\u6b21\u5904\u7406\u7684\u8bf7\u6c42\u6570\u91cf\uff1a\n\n```python\ndemo.queue(concurrency_count=3)\n```\n\n\u67e5\u770b\u6709\u5173\u914d\u7f6e\u5176\u4ed6\u961f\u5217\u53c2\u6570\u7684[\u961f\u5217\u6587\u6863](/docs/#queue)\u3002\n\n\u5728 Blocks \u4e2d\u6307\u5b9a\u4ec5\u5bf9\u67d0\u4e9b\u51fd\u6570\u8fdb\u884c\u6392\u961f\uff1a\n\n```python\nwith gr.Blocks() as demo2\uff1a\n    num1 = gr.Number()\n    num2 = gr.Number()\n    output = gr.Number()\n    gr.Button(\"Add\").click(\n        lambda a, b: a + b, [num1, num2], output)\n    gr.Button(\"Multiply\").click(\n        lambda a, b: a * b, [num1, num2], output, queue=True)\ndemo2.launch()\n```\n\n## \u8fed\u4ee3\u8f93\u51fa (Iterative Outputs)\n\n\u5728\u67d0\u4e9b\u60c5\u51b5\u4e0b\uff0c\u60a8\u53ef\u80fd\u9700\u8981\u4f20\u8f93\u4e00\u7cfb\u5217\u8f93\u51fa\u800c\u4e0d\u662f\u4e00\u6b21\u663e\u793a\u5355\u4e2a\u8f93\u51fa\u3002\u4f8b\u5982\uff0c\u60a8\u53ef\u80fd\u6709\u4e00\u4e2a\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5e0c\u671b\u663e\u793a\u751f\u6210\u7684\u6bcf\u4e2a\u6b65\u9aa4\u7684\u56fe\u50cf\uff0c\u76f4\u5230\u6700\u7ec8\u56fe\u50cf\u3002\u6216\u8005\u60a8\u53ef\u80fd\u6709\u4e00\u4e2a\u804a\u5929\u673a\u5668\u4eba\uff0c\u5b83\u9010\u5b57\u9010\u53e5\u5730\u6d41\u5f0f\u4f20\u8f93\u54cd\u5e94\uff0c\u800c\u4e0d\u662f\u4e00\u6b21\u8fd4\u56de\u5168\u90e8\u54cd\u5e94\u3002\n\n\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u60a8\u53ef\u4ee5\u5c06**\u751f\u6210\u5668**\u51fd\u6570\u63d0\u4f9b\u7ed9 Gradio\uff0c\u800c\u4e0d\u662f\u5e38\u89c4\u51fd\u6570\u3002\u5728 Python \u4e2d\u521b\u5efa\u751f\u6210\u5668\u975e\u5e38\u7b80\u5355\uff1a\u51fd\u6570\u4e0d\u5e94\u8be5\u6709\u4e00\u4e2a\u5355\u72ec\u7684 `return` \u503c\uff0c\u800c\u662f\u5e94\u8be5 with `yield` \u8fde\u7eed\u8fd4\u56de\u4e00\u7cfb\u5217\u503c\u3002\u901a\u5e38\uff0c`yield` \u8bed\u53e5\u653e\u7f6e\u5728\u67d0\u79cd\u5faa\u73af\u4e2d\u3002\u4e0b\u9762\u662f\u4e00\u4e2a\u7b80\u5355\u793a\u4f8b\uff0c\u751f\u6210\u5668\u53ea\u662f\u7b80\u5355\u8ba1\u6570\u5230\u7ed9\u5b9a\u6570\u5b57\uff1a\n\n```python\ndef my_generator(x):\n    for i in range(x):\n        yield i\n```\n\n\u60a8\u4ee5\u4e0e\u5e38\u89c4\u51fd\u6570\u76f8\u540c\u7684\u65b9\u5f0f\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio\u3002\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\uff08\u865a\u62df\u7684\uff09\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5b83\u5728\u8f93\u51fa\u56fe\u50cf\u4e4b\u524d\u751f\u6210\u6570\u4e2a\u6b65\u9aa4\u7684\u566a\u97f3\uff1a\n\n$code_fake_diffusion\n$demo_fake_diffusion\n\n\u8bf7\u6ce8\u610f\uff0c\u6211\u4eec\u5728\u8fed\u4ee3\u5668\u4e2d\u6dfb\u52a0\u4e86 `time.sleep(1)`\uff0c\u4ee5\u521b\u5efa\u6b65\u9aa4\u4e4b\u95f4\u7684\u4eba\u5de5\u6682\u505c\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u89c2\u5bdf\u8fed\u4ee3\u5668\u7684\u6b65\u9aa4\uff08\u5728\u771f\u5b9e\u7684\u56fe\u50cf\u751f\u6210\u6a21\u578b\u4e2d\uff0c\u8fd9"
        }
    },
    {
        "sample_idx": 74,
        "question": "What is a useful trick to reduce the number of unique input shapes?",
        "answer": "Pad batches of samples up to a multiple of a number like 32 or 64 tokens.",
        "rag_answer": "A useful trick to reduce the number of unique input shapes is to **pad batches of samples up to a multiple of a number like 32 or 64 tokens**. This often only increases the number of tokens by a small amount, but it hugely reduces the number of unique input shapes, because every input shape now has to be a multiple of 32 or 64. Fewer unique input shapes means fewer XLA compilations!",
        "rag_score": 5,
        "rag_feedback": "The response is completely correct, accurate, and factual. It provides a detailed explanation of how to pad batches of samples up to a multiple of a number like 32 or 64 tokens to reduce the number of unique input shapes, which is a useful trick to avoid XLA compilation issues.",
        "rag_context": {
            "kg_context": "-----Entities-----\n    ```csv\n    id,\tentity,\ttype,\tdescription,\trankcreated_at\n1,\tMachine Learning,category,Machine Learning is a field of study that involves training models to make predictions.,5,2025-03-24 13:16:48\n2,\tModel,category,Model refers to a machine learning model being evaluated.,3,2025-03-24 13:16:48\n3,\tKeras,category,Keras is a high-level neural networks API, used for building and training neural networks.<SEP>Keras is a machine learning framework that uses XLA for optimization.,2,2025-03-24 13:16:48\n4,\tXLA,technology,XLA is a technology that compiles TensorFlow graphs into executable code for various platforms.<SEP>XLA is an optimizing compiler used by TensorFlow and JAX to improve performance.<SEP>XLA is an optimizing compiler, used by both TensorFlow and JAX to optimize computations.,6,2025-03-24 13:16:48\n5,\tPredictions,category,Predictions are the outcome of a model's performance.,2,2025-03-24 13:16:48\n6,\tGoogle,organization,Google is the company that designs and provides TPUs, which are used to speed up tensor computations within neural networks.,3,UNKNOWN\n7,\tPreprocessing,concept,Preprocessing refers to the process of preparing data for use in machine learning models.,1,UNKNOWN\n8,\tNeural Networks,category,Neural Networks are a type of machine learning model used for various tasks such as image recognition and natural language processing.,0,UNKNOWN\n    ```\n    -----Relationships-----\n    ```csv\n    id,\tsource,\ttarget,\tdescription,\tkeywords,\tweight,\trank,\tcreated_at\n1,\tMachine Learning,Model,Machine Learning involves training models to make predictions.,field of study, model training,9.0,8,2025-03-24 13:16:48\n2,\tKeras,XLA,Keras uses XLA for optimization.,compiler, performance optimization,8.0,8,2025-03-24 13:18:20\n3,\tModel,Predictions,The model makes predictions based on the input data.,model output, predictions,8.0,5,2025-03-24 13:16:48\n4,\tGradio,Preprocessing,Gradio supports preprocessing of data for machine learning models.,data preprocessing, machine learning,8.0,37,UNKNOWN\n5,\tGoogle,TPU,Google designs and provides TPUs, which are used to speed up tensor computations within neural networks.,hardware design, acceleration,18.0,7,UNKNOWN\n6,\tColab,Google,Colab is a cloud-based platform provided by Google for data science and machine learning.,platform provision, cloud computing,16.0,6,UNKNOWN\n7,\tGoogle,Kaggle Kernels,Kaggle Kernels is a cloud-based platform provided by Google for data science and machine learning competitions.,platform provision, cloud computing,16.0,4,UNKNOWN\n    ```\n    -----Sources-----\n    ```csv\n    id,\tcontent\n1,\t=predictions, references=references)\n>>> results\n{'exact_match': 100.0, 'f1': 100.0}\n```\n\nYou can find examples of dataset structures by consulting the \"Dataset Preview\" function or the dataset card for a given dataset, and you can see how to use its dedicated evaluation function based on the metric card.\n2,\t(for example, a v3-32), your TPU fleet is referred to as a **pod slice.**\n\nWhen you access a free TPU via Colab, you generally get a single v2-8 TPU.\n\n### I keep hearing about this XLA thing. What\u2019s XLA, and how does it relate to TPUs?\n\nXLA is an optimizing compiler, used by both TensorFlow and JAX. In JAX it is the only compiler, whereas in TensorFlow it is optional (but mandatory on TPU!). The easiest way to enable it when training a Keras model is to pass the argument `jit_compile=True` to `model.compile()`. If you don\u2019t get any errors and performance is good, that\u2019s a great sign that you\u2019re ready to move to TPU!\n\nDebugging on TPU is generally a bit harder than on CPU/GPU, so we recommend getting your code running on CPU/GPU with XLA first before trying it on TPU. You don\u2019t have to train for long, of course - just for a few steps to make sure that your model and data pipeline are working like you expect them to.\n\n<Tip>\n\nXLA compiled code is usually faster - so even if you\u2019re not planning to run on TPU, adding `jit_compile=True` can improve your performance. Be sure to note the caveats below about XLA compatibility, though!\n\n</Tip>\n\n<Tip warning={true}>\n\n**Tip born of painful experience:** Although using `jit_compile=True` is a good way to get a speed boost and test if your CPU/GPU code is XLA-compatible, it can actually cause a lot of problems if you leave it in when actually training on TPU. XLA compilation will happen implicitly on TPU, so remember to remove that line before actually running your code on a TPU!\n\n</Tip>\n\n### How do I make my model XLA compatible?\n\nIn many cases, your code is probably XLA-compatible already! However, there are a few things that work in normal TensorFlow that don\u2019t work in XLA. We\u2019ve distilled them into three core rules below:\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** We\u2019ve put a lot of effort into rewriting our TensorFlow models and loss functions to be XLA-compatible. Our models and loss functions generally obey rule #1 and #2 by default, so you can skip over them if you\u2019re using `transformers` models. Don\u2019t forget about these rules when writing your own models and loss functions, though!\n\n</Tip>\n\n#### XLA Rule #1: Your code cannot have \u201cdata-dependent conditionals\u201d\n\nWhat that means is that any `if` statement cannot depend on values inside a `tf.Tensor`. For example, this code block cannot be compiled with XLA!\n\n```python\nif tf.reduce_sum(tensor) > 10:\n    tensor = tensor / 2.0\n```\n\nThis might seem very restrictive at first, but most neural net code doesn\u2019t need to do this. You can often get around this restriction by using `tf.cond` (see the documentation [here](https://www.tensorflow.org/api_docs/python/tf/cond)) or by removing the conditional and finding a clever math trick with indicator variables instead, like so:\n\n```python\nsum_over_10 = tf.cast(tf.reduce_sum(tensor) > 10, tf.float32)\ntensor = tensor / (1.0 + sum_over_10)\n```\n\nThis code has exactly the same effect as the code above, but by avoiding a conditional, we ensure it will compile with XLA without problems!\n\n#### XLA Rule #2: Your code cannot have \u201cdata-dependent shapes\u201d\n\nWhat this means is that the shape of all of the `tf.Tensor` objects in your code cannot depend on their values. For example, the function `tf.unique` cannot be compiled with XLA, because it returns a `tensor` containing one instance of each unique value in the input. The shape of this output will obviously be different depending on how repetitive the input `Tensor` was, and so XLA refuses to handle it!\n\nIn general, most neural network code obeys rule #2 by default. However, there are a few common cases where it becomes a problem. One very common one is when you use **label masking**, setting your labels to a negative value to indicate that those positions should be ignored when computing the loss. If you look at NumPy or PyTorch loss functions that support label masking, you will often see code like this that uses [boolean indexing](https://numpy.org/doc/stable/user/basics.indexing.html#boolean-array-indexing):\n\n```python\nlabel_mask = labels >= 0\nmasked_outputs = outputs[label_mask]\nmasked_labels = labels[label_mask]\nloss = compute_loss(masked_outputs, masked_labels)\nmean_loss = torch.mean(loss)\n```\n\nThis code is totally fine in NumPy or PyTorch, but it breaks in XLA! Why? Because the shape of `masked_outputs` and `masked_labels` depends on how many positions are masked - that makes it a **data-dependent shape.** However, just like for rule #1, we can often rewrite this code to yield exactly the same output without any data-dependent shapes.\n\n```python\nlabel_mask = tf.cast(labels >= 0, tf.float32)\nloss = compute_loss(outputs, labels)\nloss = loss * label_mask  # Set negative label positions to 0\nmean_loss = tf.reduce_sum(loss) / tf.reduce_sum(label_mask)\n```\n\nHere, we avoid data-dependent shapes by computing the loss for every position, but zeroing out the masked positions in both the numerator and denominator when we calculate the mean, which yields exactly the same result as the first block while maintaining XLA compatibility. Note that we use the same trick as in rule #1 - converting a `tf.bool` to `\n3,\t\u65f6\u5fc5\u987b\u9009\u62e9\u5176\u4e2d\u4e00\u4e2a\u5b57\u7b26\u4e32\uff0c\u8fd9\u5c06\u4f5c\u4e3a\u9644\u52a0\u5217\u4fdd\u5b58\u5230 CSV \u4e2d\u3002\n\n## \u9884\u5904\u7406\u548c\u540e\u5904\u7406 (Preprocessing and Postprocessing)\n\n![annotated](/assets/img/dataflow.svg)\n\n\u5982\u60a8\u6240\u89c1\uff0cGradio \u5305\u62ec\u53ef\u4ee5\u5904\u7406\u5404\u79cd\u4e0d\u540c\u6570\u636e\u7c7b\u578b\u7684\u7ec4\u4ef6\uff0c\u4f8b\u5982\u56fe\u50cf\u3001\u97f3\u9891\u548c\u89c6\u9891\u3002\u5927\u591a\u6570\u7ec4\u4ef6\u90fd\u53ef\u4ee5\u7528\u4f5c\u8f93\u5165\u6216\u8f93\u51fa\u3002\n\n\u5f53\u7ec4\u4ef6\u7528\u4f5c\u8f93\u5165\u65f6\uff0cGradio \u81ea\u52a8\u5904\u7406*\u9884\u5904\u7406*\uff0c\u5c06\u6570\u636e\u4ece\u7528\u6237\u6d4f\u89c8\u5668\u53d1\u9001\u7684\u7c7b\u578b\uff08\u4f8b\u5982\u7f51\u7edc\u6444\u50cf\u5934\u5feb\u7167\u7684 base64 \u8868\u793a\uff09\u8f6c\u6362\u4e3a\u60a8\u7684\u51fd\u6570\u53ef\u4ee5\u63a5\u53d7\u7684\u5f62\u5f0f\uff08\u4f8b\u5982 `numpy` \u6570\u7ec4\uff09\u3002\n\n\u540c\u6837\uff0c\u5f53\u7ec4\u4ef6\u7528\u4f5c\u8f93\u51fa\u65f6\uff0cGradio \u81ea\u52a8\u5904\u7406*\u540e\u5904\u7406*\uff0c\u5c06\u6570\u636e\u4ece\u51fd\u6570\u8fd4\u56de\u7684\u5f62\u5f0f\uff08\u4f8b\u5982\u56fe\u50cf\u8def\u5f84\u5217\u8868\uff09\u8f6c\u6362\u4e3a\u53ef\u4ee5\u5728\u7528\u6237\u6d4f\u89c8\u5668\u4e2d\u663e\u793a\u7684\u5f62\u5f0f\uff08\u4f8b\u5982\u4ee5 base64 \u683c\u5f0f\u663e\u793a\u56fe\u50cf\u7684 `Gallery`\uff09\u3002\n\n\u60a8\u53ef\u4ee5\u4f7f\u7528\u6784\u5efa\u56fe\u50cf\u7ec4\u4ef6\u65f6\u7684\u53c2\u6570\u63a7\u5236*\u9884\u5904\u7406*\u3002\u4f8b\u5982\uff0c\u5982\u679c\u60a8\u4f7f\u7528\u4ee5\u4e0b\u53c2\u6570\u5b9e\u4f8b\u5316 `Image` \u7ec4\u4ef6\uff0c\u5b83\u5c06\u5c06\u56fe\u50cf\u8f6c\u6362\u4e3a `PIL` \u7c7b\u578b\uff0c\u5e76\u5c06\u5176\u91cd\u5851\u4e3a`(100, 100)`\uff0c\u800c\u4e0d\u7ba1\u63d0\u4ea4\u65f6\u7684\u539f\u59cb\u5927\u5c0f\u5982\u4f55\uff1a\n\n```py\nimg = gr.Image(shape=(100, 100), type=\"pil\")\n```\n\n\u76f8\u53cd\uff0c\u8fd9\u91cc\u6211\u4eec\u4fdd\u7559\u56fe\u50cf\u7684\u539f\u59cb\u5927\u5c0f\uff0c\u4f46\u5728\u5c06\u5176\u8f6c\u6362\u4e3a numpy \u6570\u7ec4\u4e4b\u524d\u53cd\u8f6c\u989c\u8272\uff1a\n\n```py\nimg = gr.Image(invert_colors=True, type=\"numpy\")\n```\n\n\u540e\u5904\u7406\u8981\u5bb9\u6613\u5f97\u591a\uff01Gradio \u81ea\u52a8\u8bc6\u522b\u8fd4\u56de\u6570\u636e\u7684\u683c\u5f0f\uff08\u4f8b\u5982 `Image` \u662f `numpy` \u6570\u7ec4\u8fd8\u662f `str` \u6587\u4ef6\u8def\u5f84\uff1f\uff09\uff0c\u5e76\u5c06\u5176\u540e\u5904\u7406\u4e3a\u53ef\u4ee5\u7531\u6d4f\u89c8\u5668\u663e\u793a\u7684\u683c\u5f0f\u3002\n\n\u8bf7\u67e5\u770b[\u6587\u6863](https://gradio.app/docs)\uff0c\u4e86\u89e3\u6bcf\u4e2a\u7ec4\u4ef6\u7684\u6240\u6709\u4e0e\u9884\u5904\u7406\u76f8\u5173\u7684\u53c2\u6570\u3002\n\n## \u6837\u5f0f (Styling)\n\nGradio \u4e3b\u9898\u662f\u81ea\u5b9a\u4e49\u5e94\u7528\u7a0b\u5e8f\u5916\u89c2\u548c\u611f\u89c9\u7684\u6700\u7b80\u5355\u65b9\u6cd5\u3002\u60a8\u53ef\u4ee5\u9009\u62e9\u591a\u79cd\u4e3b\u9898\u6216\u521b\u5efa\u81ea\u5df1\u7684\u4e3b\u9898\u3002\u8981\u8fd9\u6837\u505a\uff0c\u8bf7\u5c06 `theme=` \u53c2\u6570\u4f20\u9012\u7ed9 `Interface` \u6784\u9020\u51fd\u6570\u3002\u4f8b\u5982\uff1a\n\n```python\ndemo = gr.Interface(..., theme=gr.themes.Monochrome())\n```\n\nGradio \u5e26\u6709\u4e00\u7ec4\u9884\u5148\u6784\u5efa\u7684\u4e3b\u9898\uff0c\u60a8\u53ef\u4ee5\u4ece `gr.themes.*` \u52a0\u8f7d\u3002\u60a8\u53ef\u4ee5\u6269\u5c55\u8fd9\u4e9b\u4e3b\u9898\u6216\u4ece\u5934\u5f00\u59cb\u521b\u5efa\u81ea\u5df1\u7684\u4e3b\u9898 - \u6709\u5173\u66f4\u591a\u8be6\u7ec6\u4fe1\u606f\uff0c\u8bf7\u53c2\u9605[\u4e3b\u9898\u6307\u5357](https://gradio.app/theming-guide)\u3002\n\n\u8981\u589e\u52a0\u989d\u5916\u7684\u6837\u5f0f\u80fd\u529b\uff0c\u60a8\u53ef\u4ee5 with `css=` \u5173\u952e\u5b57\u5c06\u4efb\u4f55 CSS \u4f20\u9012\u7ed9\u60a8\u7684\u5e94\u7528\u7a0b\u5e8f\u3002\nGradio \u5e94\u7528\u7a0b\u5e8f\u7684\u57fa\u7c7b\u662f `gradio-container`\uff0c\u56e0\u6b64\u4ee5\u4e0b\u662f\u4e00\u4e2a\u66f4\u6539 Gradio \u5e94\u7528\u7a0b\u5e8f\u80cc\u666f\u989c\u8272\u7684\u793a\u4f8b\uff1a\n\n```python\nwith `gr.Interface(css=\".gradio-container {background-color: red}\") as demo:\n    ...\n```\n\n## \u961f\u5217 (Queuing)\n\n\u5982\u679c\u60a8\u7684\u5e94\u7528\u7a0b\u5e8f\u9884\u8ba1\u4f1a\u6709\u5927\u91cf\u6d41\u91cf\uff0c\u8bf7 with `queue()` \u65b9\u6cd5\u6765\u63a7\u5236\u5904\u7406\u901f\u7387\u3002\u8fd9\u5c06\u6392\u961f\u5904\u7406\u8c03\u7528\uff0c\u56e0\u6b64\u4e00\u6b21\u53ea\u5904\u7406\u4e00\u5b9a\u6570\u91cf\u7684\u8bf7\u6c42\u3002\u961f\u5217\u4f7f\u7528 Websockets\uff0c\u8fd8\u53ef\u4ee5\u9632\u6b62\u7f51\u7edc\u8d85\u65f6\uff0c\u56e0\u6b64\u5982\u679c\u60a8\u7684\u51fd\u6570\u7684\u63a8\u7406\u65f6\u95f4\u5f88\u957f\uff08> 1 \u5206\u949f\uff09\uff0c\u5e94\u4f7f\u7528\u961f\u5217\u3002\n\nwith `Interface`\uff1a\n\n```python\ndemo = gr.Interface(...).queue()\ndemo.launch()\n```\n\nwith `Blocks`\uff1a\n\n```python\nwith gr.Blocks() as demo\uff1a\n    #...\ndemo.queue()\ndemo.launch()\n```\n\n\u60a8\u53ef\u4ee5\u901a\u8fc7\u4ee5\u4e0b\u65b9\u5f0f\u63a7\u5236\u4e00\u6b21\u5904\u7406\u7684\u8bf7\u6c42\u6570\u91cf\uff1a\n\n```python\ndemo.queue(concurrency_count=3)\n```\n\n\u67e5\u770b\u6709\u5173\u914d\u7f6e\u5176\u4ed6\u961f\u5217\u53c2\u6570\u7684[\u961f\u5217\u6587\u6863](/docs/#queue)\u3002\n\n\u5728 Blocks \u4e2d\u6307\u5b9a\u4ec5\u5bf9\u67d0\u4e9b\u51fd\u6570\u8fdb\u884c\u6392\u961f\uff1a\n\n```python\nwith gr.Blocks() as demo2\uff1a\n    num1 = gr.Number()\n    num2 = gr.Number()\n    output = gr.Number()\n    gr.Button(\"Add\").click(\n        lambda a, b: a + b, [num1, num2], output)\n    gr.Button(\"Multiply\").click(\n        lambda a, b: a * b, [num1, num2], output, queue=True)\ndemo2.launch()\n```\n\n## \u8fed\u4ee3\u8f93\u51fa (Iterative Outputs)\n\n\u5728\u67d0\u4e9b\u60c5\u51b5\u4e0b\uff0c\u60a8\u53ef\u80fd\u9700\u8981\u4f20\u8f93\u4e00\u7cfb\u5217\u8f93\u51fa\u800c\u4e0d\u662f\u4e00\u6b21\u663e\u793a\u5355\u4e2a\u8f93\u51fa\u3002\u4f8b\u5982\uff0c\u60a8\u53ef\u80fd\u6709\u4e00\u4e2a\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5e0c\u671b\u663e\u793a\u751f\u6210\u7684\u6bcf\u4e2a\u6b65\u9aa4\u7684\u56fe\u50cf\uff0c\u76f4\u5230\u6700\u7ec8\u56fe\u50cf\u3002\u6216\u8005\u60a8\u53ef\u80fd\u6709\u4e00\u4e2a\u804a\u5929\u673a\u5668\u4eba\uff0c\u5b83\u9010\u5b57\u9010\u53e5\u5730\u6d41\u5f0f\u4f20\u8f93\u54cd\u5e94\uff0c\u800c\u4e0d\u662f\u4e00\u6b21\u8fd4\u56de\u5168\u90e8\u54cd\u5e94\u3002\n\n\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u60a8\u53ef\u4ee5\u5c06**\u751f\u6210\u5668**\u51fd\u6570\u63d0\u4f9b\u7ed9 Gradio\uff0c\u800c\u4e0d\u662f\u5e38\u89c4\u51fd\u6570\u3002\u5728 Python \u4e2d\u521b\u5efa\u751f\u6210\u5668\u975e\u5e38\u7b80\u5355\uff1a\u51fd\u6570\u4e0d\u5e94\u8be5\u6709\u4e00\u4e2a\u5355\u72ec\u7684 `return` \u503c\uff0c\u800c\u662f\u5e94\u8be5 with `yield` \u8fde\u7eed\u8fd4\u56de\u4e00\u7cfb\u5217\u503c\u3002\u901a\u5e38\uff0c`yield` \u8bed\u53e5\u653e\u7f6e\u5728\u67d0\u79cd\u5faa\u73af\u4e2d\u3002\u4e0b\u9762\u662f\u4e00\u4e2a\u7b80\u5355\u793a\u4f8b\uff0c\u751f\u6210\u5668\u53ea\u662f\u7b80\u5355\u8ba1\u6570\u5230\u7ed9\u5b9a\u6570\u5b57\uff1a\n\n```python\ndef my_generator(x):\n    for i in range(x):\n        yield i\n```\n\n\u60a8\u4ee5\u4e0e\u5e38\u89c4\u51fd\u6570\u76f8\u540c\u7684\u65b9\u5f0f\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio\u3002\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\uff08\u865a\u62df\u7684\uff09\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5b83\u5728\u8f93\u51fa\u56fe\u50cf\u4e4b\u524d\u751f\u6210\u6570\u4e2a\u6b65\u9aa4\u7684\u566a\u97f3\uff1a\n\n$code_fake_diffusion\n$demo_fake_diffusion\n\n\u8bf7\u6ce8\u610f\uff0c\u6211\u4eec\u5728\u8fed\u4ee3\u5668\u4e2d\u6dfb\u52a0\u4e86 `time.sleep(1)`\uff0c\u4ee5\u521b\u5efa\u6b65\u9aa4\u4e4b\u95f4\u7684\u4eba\u5de5\u6682\u505c\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u89c2\u5bdf\u8fed\u4ee3\u5668\u7684\u6b65\u9aa4\uff08\u5728\u771f\u5b9e\u7684\u56fe\u50cf\u751f\u6210\u6a21\u578b\u4e2d\uff0c\u8fd9\n4,\t!--Copyright 2023 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\nthe License. You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under the License is distributed on\nan \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n\n\u26a0\ufe0f Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be\nrendered properly in your Markdown viewer.\n\n-->\n\n# Training on TPU with TensorFlow\n\n<Tip>\n\nIf you don't need long explanations and just want TPU code samples to get started with, check out [our TPU example notebook!](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb)\n\n</Tip>\n\n### What is a TPU?\n\nA TPU is a **Tensor Processing Unit.** They are hardware designed by Google, which are used to greatly speed up the tensor computations within neural networks, much like GPUs. They can be used for both network training and inference. They are generally accessed through Google\u2019s cloud services, but small TPUs can also be accessed directly for free through Google Colab and Kaggle Kernels.\n\nBecause [all TensorFlow models in \ud83e\udd17 Transformers are Keras models](https://huggingface.co/blog/tensorflow-philosophy), most of the methods in this document are generally applicable to TPU training for any Keras model! However, there are a few points that are specific to the HuggingFace ecosystem (hug-o-system?) of Transformers and Datasets, and we\u2019ll make sure to flag them up when we get to them.\n\n### What kinds of TPU are available?\n\nNew users are often very confused by the range of TPUs, and the different ways to access them. The first key distinction to understand is the difference between **TPU Nodes** and **TPU VMs.**\n\nWhen you use a **TPU Node**, you are effectively indirectly accessing a remote TPU. You will need a separate VM, which will initialize your network and data pipeline and then forward them to the remote node. When you use a TPU on Google Colab, you are accessing it in the **TPU Node** style.\n\nUsing TPU Nodes can have some quite unexpected behaviour for people who aren\u2019t used to them! In particular, because the TPU is located on a physically different system to the machine you\u2019re running your Python code on, your data cannot be local to your machine - any data pipeline that loads from your machine\u2019s internal storage will totally fail! Instead, data must be stored in Google Cloud Storage where your data pipeline can still access it, even when the pipeline is running on the remote TPU node.\n\n<Tip>\n\nIf you can fit all your data in memory as `np.ndarray` or `tf.Tensor`, then you can `fit()` on that data even when using Colab or a TPU Node, without needing to upload it to Google Cloud Storage.\n\n</Tip>\n\n<Tip>\n\n**\ud83e\udd17Specific Hugging Face Tip\ud83e\udd17:** The methods `Dataset.to_tf_dataset()` and its higher-level wrapper `model.prepare_tf_dataset()` , which you will see throughout our TF code examples, will both fail on a TPU Node. The reason for this is that even though they create a `tf.data.Dataset` it is not a \u201cpure\u201d `tf.data` pipeline and uses `tf.numpy_function` or `Dataset.from_generator()` to stream data from the underlying HuggingFace `Dataset`. This HuggingFace `Dataset` is backed by data that is on a local disc and which the remote TPU Node will not be able to read.\n\n</Tip>\n\nThe second way to access a TPU is via a **TPU VM.** When using a TPU VM, you connect directly to the machine that the TPU is attached to, much like training on a GPU VM. TPU VMs are generally easier to work with, particularly when it comes to your data pipeline. All of the above warnings do not apply to TPU VMs!\n\nThis is an opinionated document, so here\u2019s our opinion: **Avoid using TPU Node if possible.** It is more confusing and more difficult to debug than TPU VMs. It is also likely to be unsupported in future - Google\u2019s latest TPU, TPUv4, can only be accessed as a TPU VM, which suggests that TPU Nodes are increasingly going to become a \u201clegacy\u201d access method. However, we understand that the only free TPU access is on Colab and Kaggle Kernels, which uses TPU Node - so we\u2019ll try to explain how to handle it if you have to! Check the [TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) for code samples that explain this in more detail.\n\n### What sizes of TPU are available?\n\nA single TPU (a v2-8/v3-8/v4-8) runs 8 replicas. TPUs exist in **pods** that can run hundreds or thousands of replicas simultaneously. When you use more than a single TPU but less than a whole pod (for example, a v3-32), your TPU fleet is referred to as a **pod slice.**\n\nWhen you access a free TPU via Colab, you generally get a single v2-8 TPU.\n\n### I keep hearing about this XLA thing. What\u2019s XLA, and how does it relate to TPUs?\n\nXLA is an optimizing compiler, used by both TensorFlow and JAX. In JAX it is the only compiler, whereas in TensorFlow it is optional\n    ```",
            "vector_context": "[Created at: 2025-03-24 13:17:32]\nlabel_mask  # Set negative label positions to 0\nmean_loss = tf.reduce_sum(loss) / tf.reduce_sum(label_mask)\n```\n\nHere, we avoid data-dependent shapes by computing the loss for every position, but zeroing out the masked positions in both the numerator and denominator when we calculate the mean, which yields exactly the same result as the first block while maintaining XLA compatibility. Note that we use the same trick as in rule #1 - converting a `tf.bool` to `tf.float32` and using it as an indicator variable. This is a really useful trick, so remember it if you need to convert your own code to XLA!\n\n#### XLA Rule #3: XLA will need to recompile your model for every different input shape it sees\n\nThis is the big one. What this means is that if your input shapes are very variable, XLA will have to recompile your model over and over, which will create huge performance problems. This commonly arises in NLP models, where input texts have variable lengths after tokenization. In other modalities, static shapes are more common and this rule is much less of a problem.\n\nHow can you get around rule #3? The key is **padding** - if you pad all your inputs to the same length, and then use an `attention_mask`, you can get the same results as you\u2019d get from variable shapes, but without any XLA issues. However, excessive padding can cause severe slowdown too - if you pad all your samples to the maximum length in the whole dataset, you might end up with batches consisting endless padding tokens, which will waste a lot of compute and memory!\n\nThere isn\u2019t a perfect solution to this problem. However, you can try some tricks. One very useful trick is to **pad batches of samples up to a multiple of a number like 32 or 64 tokens.** This often only increases the number of tokens by a small amount, but it hugely reduces the number of unique input shapes, because every input shape now has to be a multiple of 32 or 64. Fewer unique input shapes means fewer XLA compilations!\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** Our tokenizers and data collators have methods that can help you here. You can use `padding=\"max_length\"` or `padding=\"longest\"` when calling tokenizers to get them to output padded data. Our tokenizers and data collators also have a `pad_to_multiple_of` argument that you can use to reduce the number of unique input shapes you see!\n\n</Tip>\n\n### How do I actually train my model on TPU?\n\nOnce your training is XLA-compatible and (if you\u2019re using TPU Node / Colab) your dataset has been prepared appropriately, running on TPU is surprisingly easy! All you really need to change in your code is to add a few lines to initialize your TPU, and to ensure that your model and dataset are created inside a `TPUStrategy` scope. Take a look at [our TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) to see this in action!\n\n### Summary\n\nThere was a lot in here, so let\u2019s summarize with a quick checklist you can follow when you want to get your model ready for TPU training:\n\n- Make sure your code follows the three rules of XLA\n- Compile your model with `jit_compile=True` on CPU/GPU and confirm that you can train it with XLA\n- Either load your dataset into memory or use a TPU-compatible dataset loading approach (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Migrate your code either to Colab (with accelerator set to \u201cTPU\u201d) or a TPU VM on Google Cloud\n- Add TPU initializer code (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Create your `TPUStrategy` and make sure dataset loading and model creation are inside the `strategy.scope()` (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Don\u2019t forget to take `jit_compile=True` out again when you move to TPU!\n- \ud83d\ude4f\ud83d\ude4f\ud83d\ude4f\ud83e\udd7a\ud83e\udd7a\ud83e\udd7a\n- Call model.fit()\n- You did it!\n--New Chunk--\n[Created at: 2025-03-24 13:19:17]\n!---\nCopyright 2022 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n-->\n\n# Token classification with LayoutLMv3 (PyTorch version)\n\nThis directory contains a script, `run_funsd_cord.py`, that can be used to fine-tune (or evaluate) LayoutLMv3 on form understanding datasets, such as [FUNSD](https://guillaumejaume.github.io/FUNSD/) and [CORD](https://github.com/clovaai/cord).\n\nThe script `run_funsd_cord.py` leverages the \ud83e\udd17 Datasets library and the Trainer API. You can easily customize it to your needs.\n\n## Fine-tuning on FUNSD\n\nFine-tuning LayoutLMv3 for token classification on [FUNSD](https://guillaumejaume.github.io/FUNSD/) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name funsd \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 1e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-funsd\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd. By specifying the `push_to_hub` flag, the model gets uploaded automatically to the hub (regularly), together with a model card, which includes metrics such as precision, recall and F1. Note that you can easily update the model card, as it's just a README file of the respective repo on the hub.\n\nThere's also the \"Training metrics\" [tab](https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd/tensorboard), which shows Tensorboard logs over the course of training. Pretty neat, huh?\n\n## Fine-tuning on CORD\n\nFine-tuning LayoutLMv3 for token classification on [CORD](https://github.com/clovaai/cord) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name cord \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 5e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-cord\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-cord. Note that a model card gets generated automatically in case you specify the `push_to_hub` flag.\n--New Chunk--\n[Created at: 2025-03-24 13:16:13]\n=predictions, references=references)\n>>> results\n{'exact_match': 100.0, 'f1': 100.0}\n```\n\nYou can find examples of dataset structures by consulting the \"Dataset Preview\" function or the dataset card for a given dataset, and you can see how to use its dedicated evaluation function based on the metric card."
        }
    },
    {
        "sample_idx": 75,
        "question": "What is the benefit of padding to a multiple of 32 or 64 tokens?",
        "answer": "It hugely reduces the number of unique input shapes.",
        "rag_answer": "The benefit of padding to a multiple of 32 or 64 tokens is that it reduces the number of unique input shapes, which in turn reduces the number of XLA compilations. This is because XLA needs to recompile the model for every different input shape it sees, which can create huge performance problems.\n\nBy padding to a multiple of 32 or 64 tokens, you",
        "rag_score": null,
        "rag_feedback": null,
        "rag_context": {
            "kg_context": "-----Entities-----\n    ```csv\n    id,\tentity,\ttype,\tdescription,\trankcreated_at\n1,\tKeras,category,Keras is a high-level neural networks API, used for building and training neural networks.<SEP>Keras is a machine learning framework that uses XLA for optimization.,2,2025-03-24 13:16:48\n2,\tXLA,technology,XLA is a technology that compiles TensorFlow graphs into executable code for various platforms.<SEP>XLA is an optimizing compiler used by TensorFlow and JAX to improve performance.<SEP>XLA is an optimizing compiler, used by both TensorFlow and JAX to optimize computations.,6,2025-03-24 13:16:48\n3,\tbtn,event,btn is a button technology used in Gradio's demo to create interactive interfaces.<SEP>btn is an event listener in the hangman game that uses state to store used letters.,2,2025-03-24 13:16:48\n4,\tguess_letter,event,guess_letter is a function in the hangman game that updates the state of used letters.,2,2025-03-24 13:16:48\n5,\tNamed Entity Recognition,event,Named Entity Recognition is an event or task in natural language processing.,1,2025-03-24 13:16:48\n6,\tseqeval,category,seqeval is a category of evaluation metrics for named entity recognition tasks.,1,2025-03-24 13:16:48\n7,\tLayoutLMv3,technology,LayoutLMv3 is a model used for token classification and form understanding tasks.,11,UNKNOWN\n8,\tGLUE,dataset,GLUE is a benchmark dataset for evaluating natural language processing models.,1,UNKNOWN\n9,\tPyTorch,technology,PyTorch is a framework used for building and fine-tuning the LayoutLMv3 model.,1,UNKNOWN\n    ```\n    -----Relationships-----\n    ```csv\n    id,\tsource,\ttarget,\tdescription,\tkeywords,\tweight,\trank,\tcreated_at\n1,\tKeras,XLA,Keras uses XLA for optimization.,compiler, performance optimization,8.0,8,2025-03-24 13:18:20\n2,\tbtn,guess_letter,btn is an event listener that calls the guess_letter function, which updates the state of used letters.,event handling, state update,18.0,4,2025-03-24 13:20:24\n3,\tNamed Entity Recognition,seqeval,seqeval is a metric used to evaluate named entity recognition models.,evaluation metric, task,9.0,2,2025-03-24 13:16:48\n4,\tLayoutLMv3,Microsoft,Microsoft provides the LayoutLMv3-base model used for fine-tuning.,model provision, technology,18.0,12,UNKNOWN\n5,\tLayoutLMv3,NielsR,NielsR fine-tuned the LayoutLMv3 model and uploaded it to the hub.,model fine-tuning, knowledge sharing,16.0,12,UNKNOWN\n6,\tFUNSD,LayoutLMv3,FUNSD is a dataset used for fine-tuning the LayoutLMv3 model.,dataset, model training,14.0,12,UNKNOWN\n7,\tCORD,LayoutLMv3,CORD is a dataset used for fine-tuning the LayoutLMv3 model.,dataset, model training,14.0,12,UNKNOWN\n8,\tLayoutLMv3,PyTorch,PyTorch is a framework used for building and fine-tuning the LayoutLMv3 model.,framework, model development,8.0,12,UNKNOWN\n9,\tLayoutLMv3,https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd,https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd is the URL of the fine-tuned LayoutLMv3 model.,model URL, knowledge sharing,8.0,12,UNKNOWN\n10,\tLayoutLMv3,https://huggingface.co/nielsr/layoutlmv3-finetuned-cord,https://huggingface.co/nielsr/layoutlmv3-finetuned-cord is the URL of the fine-tuned LayoutLMv3 model.,model URL, knowledge sharing,8.0,12,UNKNOWN\n11,\tLayoutLMv3,Trainer API,Trainer API is a tool used for fine-tuning the LayoutLMv3 model.,tool, model fine-tuning,7.0,12,UNKNOWN\n12,\tDatasets library,LayoutLMv3,Datasets library is a tool used for fine-tuning the LayoutLMv3 model.,tool, model fine-tuning,7.0,12,UNKNOWN\n13,\tLayoutLMv3,run_funsd_cord.py,run_funsd_cord.py is a script used for fine-tuning the LayoutLMv3 model.,script, model fine-tuning,7.0,12,UNKNOWN\n14,\tLayoutLMv3,Tensorboard,Tensorboard is a tool used for visualizing the training metrics of the LayoutLMv3 model.,tool, model visualization,7.0,12,UNKNOWN\n15,\tGLUE,Hugging Face,Hugging Face provides a platform for evaluating models on the GLUE benchmark dataset.,evaluation platform, benchmark dataset,16.0,9,UNKNOWN\n    ```\n    -----Sources-----\n    ```csv\n    id,\tcontent\n1,\t(for example, a v3-32), your TPU fleet is referred to as a **pod slice.**\n\nWhen you access a free TPU via Colab, you generally get a single v2-8 TPU.\n\n### I keep hearing about this XLA thing. What\u2019s XLA, and how does it relate to TPUs?\n\nXLA is an optimizing compiler, used by both TensorFlow and JAX. In JAX it is the only compiler, whereas in TensorFlow it is optional (but mandatory on TPU!). The easiest way to enable it when training a Keras model is to pass the argument `jit_compile=True` to `model.compile()`. If you don\u2019t get any errors and performance is good, that\u2019s a great sign that you\u2019re ready to move to TPU!\n\nDebugging on TPU is generally a bit harder than on CPU/GPU, so we recommend getting your code running on CPU/GPU with XLA first before trying it on TPU. You don\u2019t have to train for long, of course - just for a few steps to make sure that your model and data pipeline are working like you expect them to.\n\n<Tip>\n\nXLA compiled code is usually faster - so even if you\u2019re not planning to run on TPU, adding `jit_compile=True` can improve your performance. Be sure to note the caveats below about XLA compatibility, though!\n\n</Tip>\n\n<Tip warning={true}>\n\n**Tip born of painful experience:** Although using `jit_compile=True` is a good way to get a speed boost and test if your CPU/GPU code is XLA-compatible, it can actually cause a lot of problems if you leave it in when actually training on TPU. XLA compilation will happen implicitly on TPU, so remember to remove that line before actually running your code on a TPU!\n\n</Tip>\n\n### How do I make my model XLA compatible?\n\nIn many cases, your code is probably XLA-compatible already! However, there are a few things that work in normal TensorFlow that don\u2019t work in XLA. We\u2019ve distilled them into three core rules below:\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** We\u2019ve put a lot of effort into rewriting our TensorFlow models and loss functions to be XLA-compatible. Our models and loss functions generally obey rule #1 and #2 by default, so you can skip over them if you\u2019re using `transformers` models. Don\u2019t forget about these rules when writing your own models and loss functions, though!\n\n</Tip>\n\n#### XLA Rule #1: Your code cannot have \u201cdata-dependent conditionals\u201d\n\nWhat that means is that any `if` statement cannot depend on values inside a `tf.Tensor`. For example, this code block cannot be compiled with XLA!\n\n```python\nif tf.reduce_sum(tensor) > 10:\n    tensor = tensor / 2.0\n```\n\nThis might seem very restrictive at first, but most neural net code doesn\u2019t need to do this. You can often get around this restriction by using `tf.cond` (see the documentation [here](https://www.tensorflow.org/api_docs/python/tf/cond)) or by removing the conditional and finding a clever math trick with indicator variables instead, like so:\n\n```python\nsum_over_10 = tf.cast(tf.reduce_sum(tensor) > 10, tf.float32)\ntensor = tensor / (1.0 + sum_over_10)\n```\n\nThis code has exactly the same effect as the code above, but by avoiding a conditional, we ensure it will compile with XLA without problems!\n\n#### XLA Rule #2: Your code cannot have \u201cdata-dependent shapes\u201d\n\nWhat this means is that the shape of all of the `tf.Tensor` objects in your code cannot depend on their values. For example, the function `tf.unique` cannot be compiled with XLA, because it returns a `tensor` containing one instance of each unique value in the input. The shape of this output will obviously be different depending on how repetitive the input `Tensor` was, and so XLA refuses to handle it!\n\nIn general, most neural network code obeys rule #2 by default. However, there are a few common cases where it becomes a problem. One very common one is when you use **label masking**, setting your labels to a negative value to indicate that those positions should be ignored when computing the loss. If you look at NumPy or PyTorch loss functions that support label masking, you will often see code like this that uses [boolean indexing](https://numpy.org/doc/stable/user/basics.indexing.html#boolean-array-indexing):\n\n```python\nlabel_mask = labels >= 0\nmasked_outputs = outputs[label_mask]\nmasked_labels = labels[label_mask]\nloss = compute_loss(masked_outputs, masked_labels)\nmean_loss = torch.mean(loss)\n```\n\nThis code is totally fine in NumPy or PyTorch, but it breaks in XLA! Why? Because the shape of `masked_outputs` and `masked_labels` depends on how many positions are masked - that makes it a **data-dependent shape.** However, just like for rule #1, we can often rewrite this code to yield exactly the same output without any data-dependent shapes.\n\n```python\nlabel_mask = tf.cast(labels >= 0, tf.float32)\nloss = compute_loss(outputs, labels)\nloss = loss * label_mask  # Set negative label positions to 0\nmean_loss = tf.reduce_sum(loss) / tf.reduce_sum(label_mask)\n```\n\nHere, we avoid data-dependent shapes by computing the loss for every position, but zeroing out the masked positions in both the numerator and denominator when we calculate the mean, which yields exactly the same result as the first block while maintaining XLA compatibility. Note that we use the same trick as in rule #1 - converting a `tf.bool` to `\n2,\tState in Blocks\n\nWe covered [State in Interfaces](https://gradio.app/interface-state), this guide takes a look at state in Blocks, which works mostly the same.\n\n## Global State\n\nGlobal state in Blocks works the same as in Interface. Any variable created outside a function call is a reference shared between all users.\n\n## Session State\n\nGradio supports session **state**, where data persists across multiple submits within a page session, in Blocks apps as well. To reiterate, session data is _not_ shared between different users of your model. To store data in a session state, you need to do three things:\n\n1. Create a `gr.State()` object. If there is a default value to this stateful object, pass that into the constructor.\n2. In the event listener, put the `State` object as an input and output.\n3. In the event listener function, add the variable to the input parameters and the return value.\n\nLet's take a look at a game of hangman.\n\n$code_hangman\n$demo_hangman\n\nLet's see how we do each of the 3 steps listed above in this game:\n\n1. We store the used letters in `used_letters_var`. In the constructor of `State`, we set the initial value of this to `[]`, an empty list.\n2. In `btn.click()`, we have a reference to `used_letters_var` in both the inputs and outputs.\n3. In `guess_letter`, we pass the value of this `State` to `used_letters`, and then return an updated value of this `State` in the return statement.\n\nWith more complex apps, you will likely have many State variables storing session state in a single Blocks app.\n\nLearn more about `State` in the [docs](https://gradio.app/docs#state).\n3,\tChoosing a metric for your task\n\n**So you've trained your model and want to see how well it\u2019s doing on a dataset of your choice. Where do you start?**\n\nThere is no \u201cone size fits all\u201d approach to choosing an evaluation metric, but some good guidelines to keep in mind are:\n\n## Categories of metrics\n\nThere are 3 high-level categories of metrics:\n\n1. *Generic metrics*, which can be applied to a variety of situations and datasets, such as precision and accuracy.\n2. *Task-specific metrics*, which are limited to a given task, such as Machine Translation (often evaluated using metrics [BLEU](https://huggingface.co/metrics/bleu) or [ROUGE](https://huggingface.co/metrics/rouge)) or Named Entity Recognition (often evaluated with [seqeval](https://huggingface.co/metrics/seqeval)).\n3. *Dataset-specific metrics*, which aim to measure model performance on specific benchmarks: for instance, the [GLUE benchmark](https://huggingface.co/datasets/glue) has a dedicated [evaluation metric](https://huggingface.co/metrics/glue).\n\nLet's look at each of these three cases:\n\n### Generic metrics\n\nMany of the metrics used in the Machine Learning community are quite generic and can be applied in a variety of tasks and datasets.\n\nThis is the case for metrics like [accuracy](https://huggingface.co/metrics/accuracy) and [precision](https://huggingface.co/metrics/precision), which can be used for evaluating labeled (supervised) datasets, as well as [perplexity](https://huggingface.co/metrics/perplexity), which can be used for evaluating different kinds of (unsupervised) generative tasks.\n\nTo see the input structure of a given metric, you can look at its metric card. For example, in the case of [precision](https://huggingface.co/metrics/precision), the format is:\n```\n>>> precision_metric = evaluate.load(\"precision\")\n>>> results = precision_metric.compute(references=[0, 1], predictions=[0, 1])\n>>> print(results)\n{'precision': 1.0}\n```\n\n### Task-specific metrics\n\nPopular ML tasks like Machine Translation and Named Entity Recognition have specific metrics that can be used to compare models. For example, a series of different metrics have been proposed for text generation, ranging from [BLEU](https://huggingface.co/metrics/bleu) and its derivatives such as [GoogleBLEU](https://huggingface.co/metrics/google_bleu) and [GLEU](https://huggingface.co/metrics/gleu), but also [ROUGE](https://huggingface.co/metrics/rouge), [MAUVE](https://huggingface.co/metrics/mauve), etc.\n\nYou can find the right metric for your task by:\n\n- **Looking at the [Task pages](https://huggingface.co/tasks)** to see what metrics can be used for evaluating models for a given task.\n- **Checking out leaderboards** on sites like [Papers With Code](https://paperswithcode.com/) (you can search by task and by dataset).\n-  **Reading the metric cards** for the relevant metrics and see which ones are a good fit for your use case. For example, see the [BLEU metric card](https://github.com/huggingface/evaluate/tree/main/metrics/bleu) or [SQuaD metric card](https://github.com/huggingface/evaluate/tree/main/metrics/squad).\n- **Looking at papers and blog posts** published on the topic and see what metrics they report. This can change over time, so try to pick papers from the last couple of years!\n\n### Dataset-specific metrics\n\nSome datasets have specific metrics associated with them -- this is especially in the case of popular benchmarks like [GLUE](https://huggingface.co/metrics/glue) and [SQuAD](https://huggingface.co/metrics/squad).\n\n<Tip warning={true}>\n\ud83d\udca1\nGLUE is actually a collection of different subsets on different tasks, so first you need to choose the one that corresponds to the NLI task, such as mnli, which is described as \u201ccrowdsourced collection of sentence pairs with textual entailment annotations\u201d\n</Tip>\n\n\nIf you are evaluating your model on a benchmark dataset like the ones mentioned above, you can use its dedicated evaluation metric. Make sure you respect the format that they require. For example, to evaluate your model on the [SQuAD](https://huggingface.co/datasets/squad) dataset, you need to feed the `question` and `context` into your model and return the `prediction_text`, which should be compared with the `references` (based on matching the `id` of the question) :\n\n```\n>>> from evaluate import load\n>>> squad_metric = load(\"squad\")\n>>> predictions = [{'prediction_text': '1976', 'id': '56e10a3be3433e1400422b22'}]\n>>> references = [{'answers': {'answer_start': [97], 'text': ['1976']}, 'id': '56e10a3be3433e1400422b22'}]\n>>> results = squad_metric.compute(predictions=predictions, references=references)\n>>> results\n{'exact_match': 100.0, 'f1': 100.0}\n```\n\nYou can find examples of dataset structures by consulting the \"Dataset Preview\" function or the dataset card for a given dataset, and you can see how to use its dedicated evaluation function based on the metric card.\n4,\t!---\nCopyright 2022 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n-->\n\n# Token classification with LayoutLMv3 (PyTorch version)\n\nThis directory contains a script, `run_funsd_cord.py`, that can be used to fine-tune (or evaluate) LayoutLMv3 on form understanding datasets, such as [FUNSD](https://guillaumejaume.github.io/FUNSD/) and [CORD](https://github.com/clovaai/cord).\n\nThe script `run_funsd_cord.py` leverages the \ud83e\udd17 Datasets library and the Trainer API. You can easily customize it to your needs.\n\n## Fine-tuning on FUNSD\n\nFine-tuning LayoutLMv3 for token classification on [FUNSD](https://guillaumejaume.github.io/FUNSD/) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name funsd \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 1e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-funsd\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd. By specifying the `push_to_hub` flag, the model gets uploaded automatically to the hub (regularly), together with a model card, which includes metrics such as precision, recall and F1. Note that you can easily update the model card, as it's just a README file of the respective repo on the hub.\n\nThere's also the \"Training metrics\" [tab](https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd/tensorboard), which shows Tensorboard logs over the course of training. Pretty neat, huh?\n\n## Fine-tuning on CORD\n\nFine-tuning LayoutLMv3 for token classification on [CORD](https://github.com/clovaai/cord) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name cord \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 5e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-cord\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-cord. Note that a model card gets generated automatically in case you specify the `push_to_hub` flag.\n    ```",
            "vector_context": "[Created at: 2025-03-24 13:19:17]\n!---\nCopyright 2022 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n-->\n\n# Token classification with LayoutLMv3 (PyTorch version)\n\nThis directory contains a script, `run_funsd_cord.py`, that can be used to fine-tune (or evaluate) LayoutLMv3 on form understanding datasets, such as [FUNSD](https://guillaumejaume.github.io/FUNSD/) and [CORD](https://github.com/clovaai/cord).\n\nThe script `run_funsd_cord.py` leverages the \ud83e\udd17 Datasets library and the Trainer API. You can easily customize it to your needs.\n\n## Fine-tuning on FUNSD\n\nFine-tuning LayoutLMv3 for token classification on [FUNSD](https://guillaumejaume.github.io/FUNSD/) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name funsd \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 1e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-funsd\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd. By specifying the `push_to_hub` flag, the model gets uploaded automatically to the hub (regularly), together with a model card, which includes metrics such as precision, recall and F1. Note that you can easily update the model card, as it's just a README file of the respective repo on the hub.\n\nThere's also the \"Training metrics\" [tab](https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd/tensorboard), which shows Tensorboard logs over the course of training. Pretty neat, huh?\n\n## Fine-tuning on CORD\n\nFine-tuning LayoutLMv3 for token classification on [CORD](https://github.com/clovaai/cord) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name cord \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 5e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-cord\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-cord. Note that a model card gets generated automatically in case you specify the `push_to_hub` flag.\n--New Chunk--\n[Created at: 2025-03-24 13:17:32]\n(for example, a v3-32), your TPU fleet is referred to as a **pod slice.**\n\nWhen you access a free TPU via Colab, you generally get a single v2-8 TPU.\n\n### I keep hearing about this XLA thing. What\u2019s XLA, and how does it relate to TPUs?\n\nXLA is an optimizing compiler, used by both TensorFlow and JAX. In JAX it is the only compiler, whereas in TensorFlow it is optional (but mandatory on TPU!). The easiest way to enable it when training a Keras model is to pass the argument `jit_compile=True` to `model.compile()`. If you don\u2019t get any errors and performance is good, that\u2019s a great sign that you\u2019re ready to move to TPU!\n\nDebugging on TPU is generally a bit harder than on CPU/GPU, so we recommend getting your code running on CPU/GPU with XLA first before trying it on TPU. You don\u2019t have to train for long, of course - just for a few steps to make sure that your model and data pipeline are working like you expect them to.\n\n<Tip>\n\nXLA compiled code is usually faster - so even if you\u2019re not planning to run on TPU, adding `jit_compile=True` can improve your performance. Be sure to note the caveats below about XLA compatibility, though!\n\n</Tip>\n\n<Tip warning={true}>\n\n**Tip born of painful experience:** Although using `jit_compile=True` is a good way to get a speed boost and test if your CPU/GPU code is XLA-compatible, it can actually cause a lot of problems if you leave it in when actually training on TPU. XLA compilation will happen implicitly on TPU, so remember to remove that line before actually running your code on a TPU!\n\n</Tip>\n\n### How do I make my model XLA compatible?\n\nIn many cases, your code is probably XLA-compatible already! However, there are a few things that work in normal TensorFlow that don\u2019t work in XLA. We\u2019ve distilled them into three core rules below:\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** We\u2019ve put a lot of effort into rewriting our TensorFlow models and loss functions to be XLA-compatible. Our models and loss functions generally obey rule #1 and #2 by default, so you can skip over them if you\u2019re using `transformers` models. Don\u2019t forget about these rules when writing your own models and loss functions, though!\n\n</Tip>\n\n#### XLA Rule #1: Your code cannot have \u201cdata-dependent conditionals\u201d\n\nWhat that means is that any `if` statement cannot depend on values inside a `tf.Tensor`. For example, this code block cannot be compiled with XLA!\n\n```python\nif tf.reduce_sum(tensor) > 10:\n    tensor = tensor / 2.0\n```\n\nThis might seem very restrictive at first, but most neural net code doesn\u2019t need to do this. You can often get around this restriction by using `tf.cond` (see the documentation [here](https://www.tensorflow.org/api_docs/python/tf/cond)) or by removing the conditional and finding a clever math trick with indicator variables instead, like so:\n\n```python\nsum_over_10 = tf.cast(tf.reduce_sum(tensor) > 10, tf.float32)\ntensor = tensor / (1.0 + sum_over_10)\n```\n\nThis code has exactly the same effect as the code above, but by avoiding a conditional, we ensure it will compile with XLA without problems!\n\n#### XLA Rule #2: Your code cannot have \u201cdata-dependent shapes\u201d\n\nWhat this means is that the shape of all of the `tf.Tensor` objects in your code cannot depend on their values. For example, the function `tf.unique` cannot be compiled with XLA, because it returns a `tensor` containing one instance of each unique value in the input. The shape of this output will obviously be different depending on how repetitive the input `Tensor` was, and so XLA refuses to handle it!\n\nIn general, most neural network code obeys rule #2 by default. However, there are a few common cases where it becomes a problem. One very common one is when you use **label masking**, setting your labels to a negative value to indicate that those positions should be ignored when computing the loss. If you look at NumPy or PyTorch loss functions that support label masking, you will often see code like this that uses [boolean indexing](https://numpy.org/doc/stable/user/basics.indexing.html#boolean-array-indexing):\n\n```python\nlabel_mask = labels >= 0\nmasked_outputs = outputs[label_mask]\nmasked_labels = labels[label_mask]\nloss = compute_loss(masked_outputs, masked_labels)\nmean_loss = torch.mean(loss)\n```\n\nThis code is totally fine in NumPy or PyTorch, but it breaks in XLA! Why? Because the shape of `masked_outputs` and `masked_labels` depends on how many positions are masked - that makes it a **data-dependent shape.** However, just like for rule #1, we can often rewrite this code to yield exactly the same output without any data-dependent shapes.\n\n```python\nlabel_mask = tf.cast(labels >= 0, tf.float32)\nloss = compute_loss(outputs, labels)\nloss = loss * label_mask  # Set negative label positions to 0\nmean_loss = tf.reduce_sum(loss) / tf.reduce_sum(label_mask)\n```\n\nHere, we avoid data-dependent shapes by computing the loss for every position, but zeroing out the masked positions in both the numerator and denominator when we calculate the mean, which yields exactly the same result as the first block while maintaining XLA compatibility. Note that we use the same trick as in rule #1 - converting a `tf.bool` to `\n--New Chunk--\n[Created at: 2025-03-24 13:17:32]\nlabel_mask  # Set negative label positions to 0\nmean_loss = tf.reduce_sum(loss) / tf.reduce_sum(label_mask)\n```\n\nHere, we avoid data-dependent shapes by computing the loss for every position, but zeroing out the masked positions in both the numerator and denominator when we calculate the mean, which yields exactly the same result as the first block while maintaining XLA compatibility. Note that we use the same trick as in rule #1 - converting a `tf.bool` to `tf.float32` and using it as an indicator variable. This is a really useful trick, so remember it if you need to convert your own code to XLA!\n\n#### XLA Rule #3: XLA will need to recompile your model for every different input shape it sees\n\nThis is the big one. What this means is that if your input shapes are very variable, XLA will have to recompile your model over and over, which will create huge performance problems. This commonly arises in NLP models, where input texts have variable lengths after tokenization. In other modalities, static shapes are more common and this rule is much less of a problem.\n\nHow can you get around rule #3? The key is **padding** - if you pad all your inputs to the same length, and then use an `attention_mask`, you can get the same results as you\u2019d get from variable shapes, but without any XLA issues. However, excessive padding can cause severe slowdown too - if you pad all your samples to the maximum length in the whole dataset, you might end up with batches consisting endless padding tokens, which will waste a lot of compute and memory!\n\nThere isn\u2019t a perfect solution to this problem. However, you can try some tricks. One very useful trick is to **pad batches of samples up to a multiple of a number like 32 or 64 tokens.** This often only increases the number of tokens by a small amount, but it hugely reduces the number of unique input shapes, because every input shape now has to be a multiple of 32 or 64. Fewer unique input shapes means fewer XLA compilations!\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** Our tokenizers and data collators have methods that can help you here. You can use `padding=\"max_length\"` or `padding=\"longest\"` when calling tokenizers to get them to output padded data. Our tokenizers and data collators also have a `pad_to_multiple_of` argument that you can use to reduce the number of unique input shapes you see!\n\n</Tip>\n\n### How do I actually train my model on TPU?\n\nOnce your training is XLA-compatible and (if you\u2019re using TPU Node / Colab) your dataset has been prepared appropriately, running on TPU is surprisingly easy! All you really need to change in your code is to add a few lines to initialize your TPU, and to ensure that your model and dataset are created inside a `TPUStrategy` scope. Take a look at [our TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) to see this in action!\n\n### Summary\n\nThere was a lot in here, so let\u2019s summarize with a quick checklist you can follow when you want to get your model ready for TPU training:\n\n- Make sure your code follows the three rules of XLA\n- Compile your model with `jit_compile=True` on CPU/GPU and confirm that you can train it with XLA\n- Either load your dataset into memory or use a TPU-compatible dataset loading approach (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Migrate your code either to Colab (with accelerator set to \u201cTPU\u201d) or a TPU VM on Google Cloud\n- Add TPU initializer code (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Create your `TPUStrategy` and make sure dataset loading and model creation are inside the `strategy.scope()` (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Don\u2019t forget to take `jit_compile=True` out again when you move to TPU!\n- \ud83d\ude4f\ud83d\ude4f\ud83d\ude4f\ud83e\udd7a\ud83e\udd7a\ud83e\udd7a\n- Call model.fit()\n- You did it!"
        }
    },
    {
        "context": "How can you get around rule #3? The key is **padding** - if you pad all your inputs to the same length, and then use an `attention_mask`, you can get the same results as you\u2019d get from variable shapes, but without any XLA issues. However, excessive padding can cause severe slowdown too - if you pad all your samples to the maximum length in the whole dataset, you might end up with batches consisting endless padding tokens, which will waste a lot of compute and memory!\n\nThere isn\u2019t a perfect solution to this problem. However, you can try some tricks. One very useful trick is to **pad batches of samples up to a multiple of a number like 32 or 64 tokens.** This often only increases the number of tokens by a small amount, but it hugely reduces the number of unique input shapes, because every input shape now has to be a multiple of 32 or 64. Fewer unique input shapes means fewer XLA compilations!\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** Our tokenizers and data collators have methods that can help you here. You can use `padding=\"max_length\"` or `padding=\"longest\"` when calling tokenizers to get them to output padded data. Our tokenizers and data collators also have a `pad_to_multiple_of` argument that you can use to reduce the number of unique input shapes you see!\n\n</Tip>\n\n### How do I actually train my model on TPU?\n\nOnce your training is XLA-compatible and (if you\u2019re using TPU Node / Colab) your dataset has been prepared appropriately, running on TPU is surprisingly easy! All you really need to change in your code is to add a few lines to initialize your TPU, and to ensure that your model and dataset are created inside a `TPUStrategy` scope. Take a look at [our TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) to see this in action!\n\n### Summary\n\nThere was a lot in here, so let\u2019s summarize with a quick checklist you can follow when you want to get your model ready for TPU training:",
        "question": "What can be used to get tokenizers to output padded data?",
        "answer": "You can use 'padding=max_length' or 'padding=longest' when calling tokenizers.",
        "source_doc": "huggingface/transformers/blob/main/docs/source/en/perf_train_tpu_tf.md",
        "rag_answer": null,
        "rag_context": null,
        "rag_score": null,
        "rag_feedback": null
    },
    {
        "sample_idx": 77,
        "question": "What argument can be used to reduce the number of unique input shapes?",
        "answer": "The 'pad_to_multiple_of' argument can be used.",
        "rag_answer": "The argument that can be used to reduce the number of unique input shapes is `pad_to_multiple_of`. This argument can be used when calling tokenizers to get them to output padded data, which can help reduce the number of unique input shapes and make XLA compilation more efficient.",
        "rag_score": 5,
        "rag_feedback": "The response is completely correct, accurate, and factual. It correctly identifies the 'pad_to_multiple_of' argument as the one that can be used to reduce the number of unique input shapes, making XLA compilation more efficient.",
        "rag_context": {
            "kg_context": "-----Entities-----\n    ```csv\n    id,\tentity,\ttype,\tdescription,\trankcreated_at\n1,\tBatch Functions,category,Batch Functions is a category of functions in Gradio that enables the processing of batches of inputs.,1,2025-03-24 13:16:48\n2,\tGradio,organization,Gradio is a platform that supports state in Blocks, providing features such as global state and session state.<SEP>Gradio is an interface that provides various features for demonstrating models, including adding example inputs, custom error messages, descriptive content, flagging, and more.<SEP>Gradio is an organization that provides a platform for building and deploying machine learning models.<SEP>Gradio is an organization that provides a platform for creating and deploying machine learning models.<SEP>Gradio is an organization that provides a demo for blocks_random_slider, and its library is used to create interactive interfaces.,36,2025-03-24 13:16:48\n3,\tKeras,category,Keras is a high-level neural networks API, used for building and training neural networks.<SEP>Keras is a machine learning framework that uses XLA for optimization.,2,2025-03-24 13:16:48\n4,\tXLA,technology,XLA is a technology that compiles TensorFlow graphs into executable code for various platforms.<SEP>XLA is an optimizing compiler used by TensorFlow and JAX to improve performance.<SEP>XLA is an optimizing compiler, used by both TensorFlow and JAX to optimize computations.,6,2025-03-24 13:16:48\n5,\tModel,category,Model refers to a machine learning model being evaluated.,3,2025-03-24 13:16:48\n6,\tPredictions,category,Predictions are the outcome of a model's performance.,2,2025-03-24 13:16:48\n7,\tCORD,geo,CORD is a form understanding dataset used for fine-tuning LayoutLMv3.,1,UNKNOWN\n8,\tFUNSD,geo,FUNSD is a form understanding dataset used for fine-tuning LayoutLMv3.,1,UNKNOWN\n9,\tprecision,category,precision is a category of evaluation metrics for machine learning models.,1,UNKNOWN\n    ```\n    -----Relationships-----\n    ```csv\n    id,\tsource,\ttarget,\tdescription,\tkeywords,\tweight,\trank,\tcreated_at\n1,\tBatch Functions,Gradio,Gradio supports batch processing of inputs using batch functions.,functionality, batch processing,18.0,37,2025-03-24 13:17:31\n2,\tKeras,XLA,Keras uses XLA for optimization.,compiler, performance optimization,8.0,8,2025-03-24 13:18:20\n3,\tModel,Predictions,The model makes predictions based on the input data.,model output, predictions,8.0,5,2025-03-24 13:16:48\n4,\tCORD,LayoutLMv3,CORD is a dataset used for fine-tuning the LayoutLMv3 model.,dataset, model training,14.0,12,UNKNOWN\n5,\tFUNSD,LayoutLMv3,FUNSD is a dataset used for fine-tuning the LayoutLMv3 model.,dataset, model training,14.0,12,UNKNOWN\n6,\tMachine Learning,precision,precision is a metric used to evaluate machine learning models.,evaluation metric, task,9.0,6,UNKNOWN\n    ```\n    -----Sources-----\n    ```csv\n    id,\tcontent\n1,\t\u4e0e\u5e38\u89c4\u51fd\u6570\u76f8\u540c\u7684\u65b9\u5f0f\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio\u3002\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\uff08\u865a\u62df\u7684\uff09\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5b83\u5728\u8f93\u51fa\u56fe\u50cf\u4e4b\u524d\u751f\u6210\u6570\u4e2a\u6b65\u9aa4\u7684\u566a\u97f3\uff1a\n\n$code_fake_diffusion\n$demo_fake_diffusion\n\n\u8bf7\u6ce8\u610f\uff0c\u6211\u4eec\u5728\u8fed\u4ee3\u5668\u4e2d\u6dfb\u52a0\u4e86 `time.sleep(1)`\uff0c\u4ee5\u521b\u5efa\u6b65\u9aa4\u4e4b\u95f4\u7684\u4eba\u5de5\u6682\u505c\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u89c2\u5bdf\u8fed\u4ee3\u5668\u7684\u6b65\u9aa4\uff08\u5728\u771f\u5b9e\u7684\u56fe\u50cf\u751f\u6210\u6a21\u578b\u4e2d\uff0c\u8fd9\u53ef\u80fd\u662f\u4e0d\u5fc5\u8981\u7684\uff09\u3002\n\n\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio **\u9700\u8981**\u5728\u5e95\u5c42 Interface \u6216 Blocks \u4e2d\u542f\u7528\u961f\u5217\uff08\u8bf7\u53c2\u9605\u4e0a\u9762\u7684\u961f\u5217\u90e8\u5206\uff09\u3002\n\n## \u8fdb\u5ea6\u6761\n\nGradio \u652f\u6301\u521b\u5efa\u81ea\u5b9a\u4e49\u8fdb\u5ea6\u6761\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u81ea\u5b9a\u4e49\u548c\u63a7\u5236\u5411\u7528\u6237\u663e\u793a\u7684\u8fdb\u5ea6\u66f4\u65b0\u3002\u8981\u542f\u7528\u6b64\u529f\u80fd\uff0c\u53ea\u9700\u4e3a\u65b9\u6cd5\u6dfb\u52a0\u4e00\u4e2a\u9ed8\u8ba4\u503c\u4e3a `gr.Progress` \u5b9e\u4f8b\u7684\u53c2\u6570\u5373\u53ef\u3002\u7136\u540e\uff0c\u60a8\u53ef\u4ee5\u76f4\u63a5\u8c03\u7528\u6b64\u5b9e\u4f8b\u5e76\u4f20\u5165 0 \u5230 1 \u4e4b\u95f4\u7684\u6d6e\u70b9\u6570\u6765\u66f4\u65b0\u8fdb\u5ea6\u7ea7\u522b\uff0c\u6216\u8005 with `Progress` \u5b9e\u4f8b\u7684 `tqdm()` \u65b9\u6cd5\u6765\u8ddf\u8e2a\u53ef\u8fed\u4ee3\u5bf9\u8c61\u4e0a\u7684\u8fdb\u5ea6\uff0c\u5982\u4e0b\u6240\u793a\u3002\u5fc5\u987b\u542f\u7528\u961f\u5217\u4ee5\u8fdb\u884c\u8fdb\u5ea6\u66f4\u65b0\u3002\n\n$code_progress_simple\n$demo_progress_simple\n\n\u5982\u679c\u60a8 with `tqdm` \u5e93\uff0c\u5e76\u4e14\u5e0c\u671b\u4ece\u51fd\u6570\u5185\u90e8\u7684\u4efb\u4f55 `tqdm.tqdm` \u81ea\u52a8\u62a5\u544a\u8fdb\u5ea6\u66f4\u65b0\uff0c\u8bf7\u5c06\u9ed8\u8ba4\u53c2\u6570\u8bbe\u7f6e\u4e3a `gr.Progress(track_tqdm=True)`\uff01\n\n## \u6279\u5904\u7406\u51fd\u6570 (Batch Functions)\n\nGradio \u652f\u6301\u4f20\u9012*\u6279\u5904\u7406*\u51fd\u6570\u3002\u6279\u5904\u7406\u51fd\u6570\u53ea\u662f\u63a5\u53d7\u8f93\u5165\u5217\u8868\u5e76\u8fd4\u56de\u9884\u6d4b\u5217\u8868\u7684\u51fd\u6570\u3002\n\n\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\u6279\u5904\u7406\u51fd\u6570\uff0c\u5b83\u63a5\u53d7\u4e24\u4e2a\u8f93\u5165\u5217\u8868\uff08\u4e00\u4e2a\u5355\u8bcd\u5217\u8868\u548c\u4e00\u4e2a\u6574\u6570\u5217\u8868\uff09\uff0c\u5e76\u8fd4\u56de\u4fee\u526a\u8fc7\u7684\u5355\u8bcd\u5217\u8868\u4f5c\u4e3a\u8f93\u51fa\uff1a\n\n```python\nimport time\n\ndef trim_words(words, lens):\n    trimmed_words = []\n    time.sleep(5)\n    for w, l in zip(words, lens):\n        trimmed_words.append(w[:int(l)])\n    return [trimmed_words]\n    for w, l in zip(words, lens):\n```\n\n\u4f7f\u7528\u6279\u5904\u7406\u51fd\u6570\u7684\u4f18\u70b9\u662f\uff0c\u5982\u679c\u542f\u7528\u4e86\u961f\u5217\uff0cGradio \u670d\u52a1\u5668\u53ef\u4ee5\u81ea\u52a8*\u6279\u5904\u7406*\u4f20\u5165\u7684\u8bf7\u6c42\u5e76\u5e76\u884c\u5904\u7406\u5b83\u4eec\uff0c\u4ece\u800c\u53ef\u80fd\u52a0\u5feb\u6f14\u793a\u901f\u5ea6\u3002\u4ee5\u4e0b\u662f Gradio \u4ee3\u7801\u7684\u793a\u4f8b\uff08\u8bf7\u6ce8\u610f `batch=True` \u548c `max_batch_size=16` - \u8fd9\u4e24\u4e2a\u53c2\u6570\u90fd\u53ef\u4ee5\u4f20\u9012\u7ed9\u4e8b\u4ef6\u89e6\u53d1\u5668\u6216 `Interface` \u7c7b\uff09\n\nwith `Interface`\uff1a\n\n```python\ndemo = gr.Interface(trim_words, [\"textbox\", \"number\"], [\"output\"],\n                    batch=True, max_batch_size=16)\ndemo.queue()\ndemo.launch()\n```\n\nwith `Blocks`\uff1a\n\n```python\nimport gradio as gr\n\nwith gr.Blocks() as demo:\n    with gr.Row():\n        word = gr.Textbox(label=\"word\")\n        leng = gr.Number(label=\"leng\")\n        output = gr.Textbox(label=\"Output\")\n    with gr.Row():\n        run = gr.Button()\n\n    event = run.click(trim_words, [word, leng], output, batch=True, max_batch_size=16)\n\ndemo.queue()\ndemo.launch()\n```\n\n\u5728\u4e0a\u9762\u7684\u793a\u4f8b\u4e2d\uff0c\u53ef\u4ee5\u5e76\u884c\u5904\u7406 16 \u4e2a\u8bf7\u6c42\uff08\u603b\u63a8\u7406\u65f6\u95f4\u4e3a 5 \u79d2\uff09\uff0c\u800c\u4e0d\u662f\u5206\u522b\u5904\u7406\u6bcf\u4e2a\u8bf7\u6c42\uff08\u603b\u63a8\u7406\u65f6\u95f4\u4e3a 80 \u79d2\uff09\u3002\u8bb8\u591a Hugging Face \u7684 `transformers` \u548c `diffusers` \u6a21\u578b\u5728 Gradio \u7684\u6279\u5904\u7406\u6a21\u5f0f\u4e0b\u81ea\u7136\u5de5\u4f5c\uff1a\u8fd9\u662f[\u4f7f\u7528\u6279\u5904\u7406\u751f\u6210\u56fe\u50cf\u7684\u793a\u4f8b\u6f14\u793a](https://github.com/gradio-app/gradio/blob/main/demo/diffusers_with_batching/run.py)\n\n\u6ce8\u610f\uff1a\u4f7f\u7528 Gradio \u7684\u6279\u5904\u7406\u51fd\u6570 **requires** \u5728\u5e95\u5c42 Interface \u6216 Blocks \u4e2d\u542f\u7528\u961f\u5217\uff08\u8bf7\u53c2\u9605\u4e0a\u9762\u7684\u961f\u5217\u90e8\u5206\uff09\u3002\n\n## Gradio \u7b14\u8bb0\u672c (Colab Notebooks)\n\nGradio \u53ef\u4ee5\u5728\u4efb\u4f55\u8fd0\u884c Python \u7684\u5730\u65b9\u8fd0\u884c\uff0c\u5305\u62ec\u672c\u5730 Jupyter \u7b14\u8bb0\u672c\u548c\u534f\u4f5c\u7b14\u8bb0\u672c\uff0c\u5982[Google Colab](https://colab.research.google.com/)\u3002\u5bf9\u4e8e\u672c\u5730 Jupyter \u7b14\u8bb0\u672c\u548c Google Colab \u7b14\u8bb0\u672c\uff0cGradio \u5728\u672c\u5730\u670d\u52a1\u5668\u4e0a\u8fd0\u884c\uff0c\u60a8\u53ef\u4ee5\u5728\u6d4f\u89c8\u5668\u4e2d\u4e0e\u4e4b\u4ea4\u4e92\u3002\uff08\u6ce8\u610f\uff1a\u5bf9\u4e8e Google Colab\uff0c\u8fd9\u662f\u901a\u8fc7[\u670d\u52a1\u5de5\u4f5c\u5668\u96a7\u9053](https://github.com/tensorflow/tensorboard/blob/master/docs/design/colab_integration.md)\u5b9e\u73b0\u7684\uff0c\u60a8\u7684\u6d4f\u89c8\u5668\u9700\u8981\u542f\u7528 cookies\u3002\uff09\u5bf9\u4e8e\u5176\u4ed6\u8fdc\u7a0b\u7b14\u8bb0\u672c\uff0cGradio \u4e5f\u5c06\u5728\u670d\u52a1\u5668\u4e0a\u8fd0\u884c\uff0c\u4f46\u60a8\u9700\u8981\u4f7f\u7528[SSH \u96a7\u9053](https://coderwall.com/p/ohk6cg/remote-access-to-ipython-notebooks-via-ssh)\u5728\u672c\u5730\u6d4f\u89c8\u5668\u4e2d\u67e5\u770b\u5e94\u7528\u7a0b\u5e8f\u3002\u901a\u5e38\uff0c\u66f4\u7b80\u5355\u7684\u9009\u62e9\u662f\u4f7f\u7528 Gradio \u5185\u7f6e\u7684\u516c\u5171\u94fe\u63a5\uff0c[\u5728\u4e0b\u4e00\u7bc7\u6307\u5357\u4e2d\u8ba8\u8bba](/sharing-your-app/#sharing-demos)\u3002\n2,\t(for example, a v3-32), your TPU fleet is referred to as a **pod slice.**\n\nWhen you access a free TPU via Colab, you generally get a single v2-8 TPU.\n\n### I keep hearing about this XLA thing. What\u2019s XLA, and how does it relate to TPUs?\n\nXLA is an optimizing compiler, used by both TensorFlow and JAX. In JAX it is the only compiler, whereas in TensorFlow it is optional (but mandatory on TPU!). The easiest way to enable it when training a Keras model is to pass the argument `jit_compile=True` to `model.compile()`. If you don\u2019t get any errors and performance is good, that\u2019s a great sign that you\u2019re ready to move to TPU!\n\nDebugging on TPU is generally a bit harder than on CPU/GPU, so we recommend getting your code running on CPU/GPU with XLA first before trying it on TPU. You don\u2019t have to train for long, of course - just for a few steps to make sure that your model and data pipeline are working like you expect them to.\n\n<Tip>\n\nXLA compiled code is usually faster - so even if you\u2019re not planning to run on TPU, adding `jit_compile=True` can improve your performance. Be sure to note the caveats below about XLA compatibility, though!\n\n</Tip>\n\n<Tip warning={true}>\n\n**Tip born of painful experience:** Although using `jit_compile=True` is a good way to get a speed boost and test if your CPU/GPU code is XLA-compatible, it can actually cause a lot of problems if you leave it in when actually training on TPU. XLA compilation will happen implicitly on TPU, so remember to remove that line before actually running your code on a TPU!\n\n</Tip>\n\n### How do I make my model XLA compatible?\n\nIn many cases, your code is probably XLA-compatible already! However, there are a few things that work in normal TensorFlow that don\u2019t work in XLA. We\u2019ve distilled them into three core rules below:\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** We\u2019ve put a lot of effort into rewriting our TensorFlow models and loss functions to be XLA-compatible. Our models and loss functions generally obey rule #1 and #2 by default, so you can skip over them if you\u2019re using `transformers` models. Don\u2019t forget about these rules when writing your own models and loss functions, though!\n\n</Tip>\n\n#### XLA Rule #1: Your code cannot have \u201cdata-dependent conditionals\u201d\n\nWhat that means is that any `if` statement cannot depend on values inside a `tf.Tensor`. For example, this code block cannot be compiled with XLA!\n\n```python\nif tf.reduce_sum(tensor) > 10:\n    tensor = tensor / 2.0\n```\n\nThis might seem very restrictive at first, but most neural net code doesn\u2019t need to do this. You can often get around this restriction by using `tf.cond` (see the documentation [here](https://www.tensorflow.org/api_docs/python/tf/cond)) or by removing the conditional and finding a clever math trick with indicator variables instead, like so:\n\n```python\nsum_over_10 = tf.cast(tf.reduce_sum(tensor) > 10, tf.float32)\ntensor = tensor / (1.0 + sum_over_10)\n```\n\nThis code has exactly the same effect as the code above, but by avoiding a conditional, we ensure it will compile with XLA without problems!\n\n#### XLA Rule #2: Your code cannot have \u201cdata-dependent shapes\u201d\n\nWhat this means is that the shape of all of the `tf.Tensor` objects in your code cannot depend on their values. For example, the function `tf.unique` cannot be compiled with XLA, because it returns a `tensor` containing one instance of each unique value in the input. The shape of this output will obviously be different depending on how repetitive the input `Tensor` was, and so XLA refuses to handle it!\n\nIn general, most neural network code obeys rule #2 by default. However, there are a few common cases where it becomes a problem. One very common one is when you use **label masking**, setting your labels to a negative value to indicate that those positions should be ignored when computing the loss. If you look at NumPy or PyTorch loss functions that support label masking, you will often see code like this that uses [boolean indexing](https://numpy.org/doc/stable/user/basics.indexing.html#boolean-array-indexing):\n\n```python\nlabel_mask = labels >= 0\nmasked_outputs = outputs[label_mask]\nmasked_labels = labels[label_mask]\nloss = compute_loss(masked_outputs, masked_labels)\nmean_loss = torch.mean(loss)\n```\n\nThis code is totally fine in NumPy or PyTorch, but it breaks in XLA! Why? Because the shape of `masked_outputs` and `masked_labels` depends on how many positions are masked - that makes it a **data-dependent shape.** However, just like for rule #1, we can often rewrite this code to yield exactly the same output without any data-dependent shapes.\n\n```python\nlabel_mask = tf.cast(labels >= 0, tf.float32)\nloss = compute_loss(outputs, labels)\nloss = loss * label_mask  # Set negative label positions to 0\nmean_loss = tf.reduce_sum(loss) / tf.reduce_sum(label_mask)\n```\n\nHere, we avoid data-dependent shapes by computing the loss for every position, but zeroing out the masked positions in both the numerator and denominator when we calculate the mean, which yields exactly the same result as the first block while maintaining XLA compatibility. Note that we use the same trick as in rule #1 - converting a `tf.bool` to `\n3,\t=predictions, references=references)\n>>> results\n{'exact_match': 100.0, 'f1': 100.0}\n```\n\nYou can find examples of dataset structures by consulting the \"Dataset Preview\" function or the dataset card for a given dataset, and you can see how to use its dedicated evaluation function based on the metric card.\n4,\t!---\nCopyright 2022 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n-->\n\n# Token classification with LayoutLMv3 (PyTorch version)\n\nThis directory contains a script, `run_funsd_cord.py`, that can be used to fine-tune (or evaluate) LayoutLMv3 on form understanding datasets, such as [FUNSD](https://guillaumejaume.github.io/FUNSD/) and [CORD](https://github.com/clovaai/cord).\n\nThe script `run_funsd_cord.py` leverages the \ud83e\udd17 Datasets library and the Trainer API. You can easily customize it to your needs.\n\n## Fine-tuning on FUNSD\n\nFine-tuning LayoutLMv3 for token classification on [FUNSD](https://guillaumejaume.github.io/FUNSD/) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name funsd \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 1e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-funsd\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd. By specifying the `push_to_hub` flag, the model gets uploaded automatically to the hub (regularly), together with a model card, which includes metrics such as precision, recall and F1. Note that you can easily update the model card, as it's just a README file of the respective repo on the hub.\n\nThere's also the \"Training metrics\" [tab](https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd/tensorboard), which shows Tensorboard logs over the course of training. Pretty neat, huh?\n\n## Fine-tuning on CORD\n\nFine-tuning LayoutLMv3 for token classification on [CORD](https://github.com/clovaai/cord) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name cord \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 5e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-cord\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-cord. Note that a model card gets generated automatically in case you specify the `push_to_hub` flag.\n5,\tChoosing a metric for your task\n\n**So you've trained your model and want to see how well it\u2019s doing on a dataset of your choice. Where do you start?**\n\nThere is no \u201cone size fits all\u201d approach to choosing an evaluation metric, but some good guidelines to keep in mind are:\n\n## Categories of metrics\n\nThere are 3 high-level categories of metrics:\n\n1. *Generic metrics*, which can be applied to a variety of situations and datasets, such as precision and accuracy.\n2. *Task-specific metrics*, which are limited to a given task, such as Machine Translation (often evaluated using metrics [BLEU](https://huggingface.co/metrics/bleu) or [ROUGE](https://huggingface.co/metrics/rouge)) or Named Entity Recognition (often evaluated with [seqeval](https://huggingface.co/metrics/seqeval)).\n3. *Dataset-specific metrics*, which aim to measure model performance on specific benchmarks: for instance, the [GLUE benchmark](https://huggingface.co/datasets/glue) has a dedicated [evaluation metric](https://huggingface.co/metrics/glue).\n\nLet's look at each of these three cases:\n\n### Generic metrics\n\nMany of the metrics used in the Machine Learning community are quite generic and can be applied in a variety of tasks and datasets.\n\nThis is the case for metrics like [accuracy](https://huggingface.co/metrics/accuracy) and [precision](https://huggingface.co/metrics/precision), which can be used for evaluating labeled (supervised) datasets, as well as [perplexity](https://huggingface.co/metrics/perplexity), which can be used for evaluating different kinds of (unsupervised) generative tasks.\n\nTo see the input structure of a given metric, you can look at its metric card. For example, in the case of [precision](https://huggingface.co/metrics/precision), the format is:\n```\n>>> precision_metric = evaluate.load(\"precision\")\n>>> results = precision_metric.compute(references=[0, 1], predictions=[0, 1])\n>>> print(results)\n{'precision': 1.0}\n```\n\n### Task-specific metrics\n\nPopular ML tasks like Machine Translation and Named Entity Recognition have specific metrics that can be used to compare models. For example, a series of different metrics have been proposed for text generation, ranging from [BLEU](https://huggingface.co/metrics/bleu) and its derivatives such as [GoogleBLEU](https://huggingface.co/metrics/google_bleu) and [GLEU](https://huggingface.co/metrics/gleu), but also [ROUGE](https://huggingface.co/metrics/rouge), [MAUVE](https://huggingface.co/metrics/mauve), etc.\n\nYou can find the right metric for your task by:\n\n- **Looking at the [Task pages](https://huggingface.co/tasks)** to see what metrics can be used for evaluating models for a given task.\n- **Checking out leaderboards** on sites like [Papers With Code](https://paperswithcode.com/) (you can search by task and by dataset).\n-  **Reading the metric cards** for the relevant metrics and see which ones are a good fit for your use case. For example, see the [BLEU metric card](https://github.com/huggingface/evaluate/tree/main/metrics/bleu) or [SQuaD metric card](https://github.com/huggingface/evaluate/tree/main/metrics/squad).\n- **Looking at papers and blog posts** published on the topic and see what metrics they report. This can change over time, so try to pick papers from the last couple of years!\n\n### Dataset-specific metrics\n\nSome datasets have specific metrics associated with them -- this is especially in the case of popular benchmarks like [GLUE](https://huggingface.co/metrics/glue) and [SQuAD](https://huggingface.co/metrics/squad).\n\n<Tip warning={true}>\n\ud83d\udca1\nGLUE is actually a collection of different subsets on different tasks, so first you need to choose the one that corresponds to the NLI task, such as mnli, which is described as \u201ccrowdsourced collection of sentence pairs with textual entailment annotations\u201d\n</Tip>\n\n\nIf you are evaluating your model on a benchmark dataset like the ones mentioned above, you can use its dedicated evaluation metric. Make sure you respect the format that they require. For example, to evaluate your model on the [SQuAD](https://huggingface.co/datasets/squad) dataset, you need to feed the `question` and `context` into your model and return the `prediction_text`, which should be compared with the `references` (based on matching the `id` of the question) :\n\n```\n>>> from evaluate import load\n>>> squad_metric = load(\"squad\")\n>>> predictions = [{'prediction_text': '1976', 'id': '56e10a3be3433e1400422b22'}]\n>>> references = [{'answers': {'answer_start': [97], 'text': ['1976']}, 'id': '56e10a3be3433e1400422b22'}]\n>>> results = squad_metric.compute(predictions=predictions, references=references)\n>>> results\n{'exact_match': 100.0, 'f1': 100.0}\n```\n\nYou can find examples of dataset structures by consulting the \"Dataset Preview\" function or the dataset card for a given dataset, and you can see how to use its dedicated evaluation function based on the metric card.\n    ```",
            "vector_context": "[Created at: 2025-03-24 13:17:32]\nlabel_mask  # Set negative label positions to 0\nmean_loss = tf.reduce_sum(loss) / tf.reduce_sum(label_mask)\n```\n\nHere, we avoid data-dependent shapes by computing the loss for every position, but zeroing out the masked positions in both the numerator and denominator when we calculate the mean, which yields exactly the same result as the first block while maintaining XLA compatibility. Note that we use the same trick as in rule #1 - converting a `tf.bool` to `tf.float32` and using it as an indicator variable. This is a really useful trick, so remember it if you need to convert your own code to XLA!\n\n#### XLA Rule #3: XLA will need to recompile your model for every different input shape it sees\n\nThis is the big one. What this means is that if your input shapes are very variable, XLA will have to recompile your model over and over, which will create huge performance problems. This commonly arises in NLP models, where input texts have variable lengths after tokenization. In other modalities, static shapes are more common and this rule is much less of a problem.\n\nHow can you get around rule #3? The key is **padding** - if you pad all your inputs to the same length, and then use an `attention_mask`, you can get the same results as you\u2019d get from variable shapes, but without any XLA issues. However, excessive padding can cause severe slowdown too - if you pad all your samples to the maximum length in the whole dataset, you might end up with batches consisting endless padding tokens, which will waste a lot of compute and memory!\n\nThere isn\u2019t a perfect solution to this problem. However, you can try some tricks. One very useful trick is to **pad batches of samples up to a multiple of a number like 32 or 64 tokens.** This often only increases the number of tokens by a small amount, but it hugely reduces the number of unique input shapes, because every input shape now has to be a multiple of 32 or 64. Fewer unique input shapes means fewer XLA compilations!\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** Our tokenizers and data collators have methods that can help you here. You can use `padding=\"max_length\"` or `padding=\"longest\"` when calling tokenizers to get them to output padded data. Our tokenizers and data collators also have a `pad_to_multiple_of` argument that you can use to reduce the number of unique input shapes you see!\n\n</Tip>\n\n### How do I actually train my model on TPU?\n\nOnce your training is XLA-compatible and (if you\u2019re using TPU Node / Colab) your dataset has been prepared appropriately, running on TPU is surprisingly easy! All you really need to change in your code is to add a few lines to initialize your TPU, and to ensure that your model and dataset are created inside a `TPUStrategy` scope. Take a look at [our TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) to see this in action!\n\n### Summary\n\nThere was a lot in here, so let\u2019s summarize with a quick checklist you can follow when you want to get your model ready for TPU training:\n\n- Make sure your code follows the three rules of XLA\n- Compile your model with `jit_compile=True` on CPU/GPU and confirm that you can train it with XLA\n- Either load your dataset into memory or use a TPU-compatible dataset loading approach (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Migrate your code either to Colab (with accelerator set to \u201cTPU\u201d) or a TPU VM on Google Cloud\n- Add TPU initializer code (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Create your `TPUStrategy` and make sure dataset loading and model creation are inside the `strategy.scope()` (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Don\u2019t forget to take `jit_compile=True` out again when you move to TPU!\n- \ud83d\ude4f\ud83d\ude4f\ud83d\ude4f\ud83e\udd7a\ud83e\udd7a\ud83e\udd7a\n- Call model.fit()\n- You did it!\n--New Chunk--\n[Created at: 2025-03-24 13:19:17]\n!---\nCopyright 2022 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n-->\n\n# Token classification with LayoutLMv3 (PyTorch version)\n\nThis directory contains a script, `run_funsd_cord.py`, that can be used to fine-tune (or evaluate) LayoutLMv3 on form understanding datasets, such as [FUNSD](https://guillaumejaume.github.io/FUNSD/) and [CORD](https://github.com/clovaai/cord).\n\nThe script `run_funsd_cord.py` leverages the \ud83e\udd17 Datasets library and the Trainer API. You can easily customize it to your needs.\n\n## Fine-tuning on FUNSD\n\nFine-tuning LayoutLMv3 for token classification on [FUNSD](https://guillaumejaume.github.io/FUNSD/) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name funsd \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 1e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-funsd\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd. By specifying the `push_to_hub` flag, the model gets uploaded automatically to the hub (regularly), together with a model card, which includes metrics such as precision, recall and F1. Note that you can easily update the model card, as it's just a README file of the respective repo on the hub.\n\nThere's also the \"Training metrics\" [tab](https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd/tensorboard), which shows Tensorboard logs over the course of training. Pretty neat, huh?\n\n## Fine-tuning on CORD\n\nFine-tuning LayoutLMv3 for token classification on [CORD](https://github.com/clovaai/cord) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name cord \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 5e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-cord\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-cord. Note that a model card gets generated automatically in case you specify the `push_to_hub` flag.\n--New Chunk--\n[Created at: 2025-03-24 13:16:13]\n=predictions, references=references)\n>>> results\n{'exact_match': 100.0, 'f1': 100.0}\n```\n\nYou can find examples of dataset structures by consulting the \"Dataset Preview\" function or the dataset card for a given dataset, and you can see how to use its dedicated evaluation function based on the metric card."
        }
    },
    {
        "sample_idx": 78,
        "question": "What is required to run a model on TPU?",
        "answer": "You need to add a few lines to initialize your TPU, and ensure that your model and dataset are created inside a 'TPUStrategy' scope.",
        "rag_answer": "To run a model on a Tensor Processing Unit (TPU), you need to ensure the following:\n\n**1. XLA Compatibility**: Your model's code must follow the three rules of XLA (Accelerated Linear Algebra):\n\t* No data-dependent conditionals\n\t* No data-dependent shapes\n\t* Recompile model for every different input shape\n\n**2. TPU-Compatible Dataset Loading**: Your dataset must be loaded in a way that is compatible with T",
        "rag_score": null,
        "rag_feedback": null,
        "rag_context": {
            "kg_context": "-----Entities-----\n    ```csv\n    id,\tentity,\ttype,\tdescription,\trankcreated_at\n1,\tKeras,category,Keras is a high-level neural networks API, used for building and training neural networks.<SEP>Keras is a machine learning framework that uses XLA for optimization.,2,2025-03-24 13:18:20\n2,\tXLA,technology,XLA is a technology that compiles TensorFlow graphs into executable code for various platforms.<SEP>XLA is an optimizing compiler used by TensorFlow and JAX to improve performance.<SEP>XLA is an optimizing compiler, used by both TensorFlow and JAX to optimize computations.,6,2025-03-24 13:18:20\n3,\tGoogle,organization,Google is the company that designs and provides TPUs, which are used to speed up tensor computations within neural networks.,3,2025-03-24 13:18:20\n4,\tTPU,technology,TPU is a Tensor Processing Unit, a hardware designed by Google to speed up tensor computations within neural networks.<SEP>TPU is a type of hardware accelerator designed for machine learning workloads.<SEP>TPU is a type of hardware accelerator used for machine learning computations.,4,2025-03-24 13:18:20\n5,\tGoogle Cloud,organization,Google Cloud is a cloud computing platform that provides infrastructure and services for building and deploying machine learning models.,1,2025-03-24 13:18:20\n6,\tTPU,technology,TPU is a Tensor Processing Unit, a hardware designed by Google to speed up tensor computations within neural networks.<SEP>TPU is a type of hardware accelerator designed for machine learning workloads.<SEP>TPU is a type of hardware accelerator used for machine learning computations.,4,UNKNOWN\n7,\tv3-32 TPU,category,v3-32 TPU is a type of TPU, a hardware designed by Google to speed up tensor computations within neural networks.,0,UNKNOWN\n8,\tTPUv4,category,TPUv4 is a type of TPU, a hardware designed by Google to speed up tensor computations within neural networks.,0,UNKNOWN\n    ```\n    -----Relationships-----\n    ```csv\n    id,\tsource,\ttarget,\tdescription,\tkeywords,\tweight,\trank,\tcreated_at\n1,\tKeras,XLA,Keras uses XLA for optimization.,compiler, performance optimization,8.0,8,2025-03-24 13:18:20\n2,\tGoogle,TPU,Google designs and provides TPUs, which are used to speed up tensor computations within neural networks.,hardware design, acceleration,18.0,7,2025-03-24 13:18:20\n3,\tGoogle Cloud,TPU,Google Cloud provides infrastructure and services for building and deploying machine learning models, including TPU hardware.,infrastructure provision, hardware acceleration,14.0,5,2025-03-24 13:18:20\n4,\tTPU,XLA,XLA compiles TensorFlow graphs into executable code for TPU hardware.<SEP>XLA is used to optimize code for TPU hardware.,compilation, hardware acceleration<SEP>compiler, hardware optimization,36.0,10,UNKNOWN\n5,\tGoogle,TPU,Google designs and provides TPUs, which are used to speed up tensor computations within neural networks.,hardware design, acceleration,18.0,7,UNKNOWN\n6,\tColab,TPU,Colab provides access to a free TPU for users.,platform, hardware acceleration,16.0,7,UNKNOWN\n7,\tGoogle Cloud,TPU,Google Cloud provides infrastructure and services for building and deploying machine learning models, including TPU hardware.,infrastructure provision, hardware acceleration,14.0,5,UNKNOWN\n    ```\n    -----Sources-----\n    ```csv\n    id,\tcontent\n1,\t(for example, a v3-32), your TPU fleet is referred to as a **pod slice.**\n\nWhen you access a free TPU via Colab, you generally get a single v2-8 TPU.\n\n### I keep hearing about this XLA thing. What\u2019s XLA, and how does it relate to TPUs?\n\nXLA is an optimizing compiler, used by both TensorFlow and JAX. In JAX it is the only compiler, whereas in TensorFlow it is optional (but mandatory on TPU!). The easiest way to enable it when training a Keras model is to pass the argument `jit_compile=True` to `model.compile()`. If you don\u2019t get any errors and performance is good, that\u2019s a great sign that you\u2019re ready to move to TPU!\n\nDebugging on TPU is generally a bit harder than on CPU/GPU, so we recommend getting your code running on CPU/GPU with XLA first before trying it on TPU. You don\u2019t have to train for long, of course - just for a few steps to make sure that your model and data pipeline are working like you expect them to.\n\n<Tip>\n\nXLA compiled code is usually faster - so even if you\u2019re not planning to run on TPU, adding `jit_compile=True` can improve your performance. Be sure to note the caveats below about XLA compatibility, though!\n\n</Tip>\n\n<Tip warning={true}>\n\n**Tip born of painful experience:** Although using `jit_compile=True` is a good way to get a speed boost and test if your CPU/GPU code is XLA-compatible, it can actually cause a lot of problems if you leave it in when actually training on TPU. XLA compilation will happen implicitly on TPU, so remember to remove that line before actually running your code on a TPU!\n\n</Tip>\n\n### How do I make my model XLA compatible?\n\nIn many cases, your code is probably XLA-compatible already! However, there are a few things that work in normal TensorFlow that don\u2019t work in XLA. We\u2019ve distilled them into three core rules below:\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** We\u2019ve put a lot of effort into rewriting our TensorFlow models and loss functions to be XLA-compatible. Our models and loss functions generally obey rule #1 and #2 by default, so you can skip over them if you\u2019re using `transformers` models. Don\u2019t forget about these rules when writing your own models and loss functions, though!\n\n</Tip>\n\n#### XLA Rule #1: Your code cannot have \u201cdata-dependent conditionals\u201d\n\nWhat that means is that any `if` statement cannot depend on values inside a `tf.Tensor`. For example, this code block cannot be compiled with XLA!\n\n```python\nif tf.reduce_sum(tensor) > 10:\n    tensor = tensor / 2.0\n```\n\nThis might seem very restrictive at first, but most neural net code doesn\u2019t need to do this. You can often get around this restriction by using `tf.cond` (see the documentation [here](https://www.tensorflow.org/api_docs/python/tf/cond)) or by removing the conditional and finding a clever math trick with indicator variables instead, like so:\n\n```python\nsum_over_10 = tf.cast(tf.reduce_sum(tensor) > 10, tf.float32)\ntensor = tensor / (1.0 + sum_over_10)\n```\n\nThis code has exactly the same effect as the code above, but by avoiding a conditional, we ensure it will compile with XLA without problems!\n\n#### XLA Rule #2: Your code cannot have \u201cdata-dependent shapes\u201d\n\nWhat this means is that the shape of all of the `tf.Tensor` objects in your code cannot depend on their values. For example, the function `tf.unique` cannot be compiled with XLA, because it returns a `tensor` containing one instance of each unique value in the input. The shape of this output will obviously be different depending on how repetitive the input `Tensor` was, and so XLA refuses to handle it!\n\nIn general, most neural network code obeys rule #2 by default. However, there are a few common cases where it becomes a problem. One very common one is when you use **label masking**, setting your labels to a negative value to indicate that those positions should be ignored when computing the loss. If you look at NumPy or PyTorch loss functions that support label masking, you will often see code like this that uses [boolean indexing](https://numpy.org/doc/stable/user/basics.indexing.html#boolean-array-indexing):\n\n```python\nlabel_mask = labels >= 0\nmasked_outputs = outputs[label_mask]\nmasked_labels = labels[label_mask]\nloss = compute_loss(masked_outputs, masked_labels)\nmean_loss = torch.mean(loss)\n```\n\nThis code is totally fine in NumPy or PyTorch, but it breaks in XLA! Why? Because the shape of `masked_outputs` and `masked_labels` depends on how many positions are masked - that makes it a **data-dependent shape.** However, just like for rule #1, we can often rewrite this code to yield exactly the same output without any data-dependent shapes.\n\n```python\nlabel_mask = tf.cast(labels >= 0, tf.float32)\nloss = compute_loss(outputs, labels)\nloss = loss * label_mask  # Set negative label positions to 0\nmean_loss = tf.reduce_sum(loss) / tf.reduce_sum(label_mask)\n```\n\nHere, we avoid data-dependent shapes by computing the loss for every position, but zeroing out the masked positions in both the numerator and denominator when we calculate the mean, which yields exactly the same result as the first block while maintaining XLA compatibility. Note that we use the same trick as in rule #1 - converting a `tf.bool` to `\n2,\t!--Copyright 2023 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\nthe License. You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under the License is distributed on\nan \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n\n\u26a0\ufe0f Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be\nrendered properly in your Markdown viewer.\n\n-->\n\n# Training on TPU with TensorFlow\n\n<Tip>\n\nIf you don't need long explanations and just want TPU code samples to get started with, check out [our TPU example notebook!](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb)\n\n</Tip>\n\n### What is a TPU?\n\nA TPU is a **Tensor Processing Unit.** They are hardware designed by Google, which are used to greatly speed up the tensor computations within neural networks, much like GPUs. They can be used for both network training and inference. They are generally accessed through Google\u2019s cloud services, but small TPUs can also be accessed directly for free through Google Colab and Kaggle Kernels.\n\nBecause [all TensorFlow models in \ud83e\udd17 Transformers are Keras models](https://huggingface.co/blog/tensorflow-philosophy), most of the methods in this document are generally applicable to TPU training for any Keras model! However, there are a few points that are specific to the HuggingFace ecosystem (hug-o-system?) of Transformers and Datasets, and we\u2019ll make sure to flag them up when we get to them.\n\n### What kinds of TPU are available?\n\nNew users are often very confused by the range of TPUs, and the different ways to access them. The first key distinction to understand is the difference between **TPU Nodes** and **TPU VMs.**\n\nWhen you use a **TPU Node**, you are effectively indirectly accessing a remote TPU. You will need a separate VM, which will initialize your network and data pipeline and then forward them to the remote node. When you use a TPU on Google Colab, you are accessing it in the **TPU Node** style.\n\nUsing TPU Nodes can have some quite unexpected behaviour for people who aren\u2019t used to them! In particular, because the TPU is located on a physically different system to the machine you\u2019re running your Python code on, your data cannot be local to your machine - any data pipeline that loads from your machine\u2019s internal storage will totally fail! Instead, data must be stored in Google Cloud Storage where your data pipeline can still access it, even when the pipeline is running on the remote TPU node.\n\n<Tip>\n\nIf you can fit all your data in memory as `np.ndarray` or `tf.Tensor`, then you can `fit()` on that data even when using Colab or a TPU Node, without needing to upload it to Google Cloud Storage.\n\n</Tip>\n\n<Tip>\n\n**\ud83e\udd17Specific Hugging Face Tip\ud83e\udd17:** The methods `Dataset.to_tf_dataset()` and its higher-level wrapper `model.prepare_tf_dataset()` , which you will see throughout our TF code examples, will both fail on a TPU Node. The reason for this is that even though they create a `tf.data.Dataset` it is not a \u201cpure\u201d `tf.data` pipeline and uses `tf.numpy_function` or `Dataset.from_generator()` to stream data from the underlying HuggingFace `Dataset`. This HuggingFace `Dataset` is backed by data that is on a local disc and which the remote TPU Node will not be able to read.\n\n</Tip>\n\nThe second way to access a TPU is via a **TPU VM.** When using a TPU VM, you connect directly to the machine that the TPU is attached to, much like training on a GPU VM. TPU VMs are generally easier to work with, particularly when it comes to your data pipeline. All of the above warnings do not apply to TPU VMs!\n\nThis is an opinionated document, so here\u2019s our opinion: **Avoid using TPU Node if possible.** It is more confusing and more difficult to debug than TPU VMs. It is also likely to be unsupported in future - Google\u2019s latest TPU, TPUv4, can only be accessed as a TPU VM, which suggests that TPU Nodes are increasingly going to become a \u201clegacy\u201d access method. However, we understand that the only free TPU access is on Colab and Kaggle Kernels, which uses TPU Node - so we\u2019ll try to explain how to handle it if you have to! Check the [TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) for code samples that explain this in more detail.\n\n### What sizes of TPU are available?\n\nA single TPU (a v2-8/v3-8/v4-8) runs 8 replicas. TPUs exist in **pods** that can run hundreds or thousands of replicas simultaneously. When you use more than a single TPU but less than a whole pod (for example, a v3-32), your TPU fleet is referred to as a **pod slice.**\n\nWhen you access a free TPU via Colab, you generally get a single v2-8 TPU.\n\n### I keep hearing about this XLA thing. What\u2019s XLA, and how does it relate to TPUs?\n\nXLA is an optimizing compiler, used by both TensorFlow and JAX. In JAX it is the only compiler, whereas in TensorFlow it is optional\n3,\tlabel_mask  # Set negative label positions to 0\nmean_loss = tf.reduce_sum(loss) / tf.reduce_sum(label_mask)\n```\n\nHere, we avoid data-dependent shapes by computing the loss for every position, but zeroing out the masked positions in both the numerator and denominator when we calculate the mean, which yields exactly the same result as the first block while maintaining XLA compatibility. Note that we use the same trick as in rule #1 - converting a `tf.bool` to `tf.float32` and using it as an indicator variable. This is a really useful trick, so remember it if you need to convert your own code to XLA!\n\n#### XLA Rule #3: XLA will need to recompile your model for every different input shape it sees\n\nThis is the big one. What this means is that if your input shapes are very variable, XLA will have to recompile your model over and over, which will create huge performance problems. This commonly arises in NLP models, where input texts have variable lengths after tokenization. In other modalities, static shapes are more common and this rule is much less of a problem.\n\nHow can you get around rule #3? The key is **padding** - if you pad all your inputs to the same length, and then use an `attention_mask`, you can get the same results as you\u2019d get from variable shapes, but without any XLA issues. However, excessive padding can cause severe slowdown too - if you pad all your samples to the maximum length in the whole dataset, you might end up with batches consisting endless padding tokens, which will waste a lot of compute and memory!\n\nThere isn\u2019t a perfect solution to this problem. However, you can try some tricks. One very useful trick is to **pad batches of samples up to a multiple of a number like 32 or 64 tokens.** This often only increases the number of tokens by a small amount, but it hugely reduces the number of unique input shapes, because every input shape now has to be a multiple of 32 or 64. Fewer unique input shapes means fewer XLA compilations!\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** Our tokenizers and data collators have methods that can help you here. You can use `padding=\"max_length\"` or `padding=\"longest\"` when calling tokenizers to get them to output padded data. Our tokenizers and data collators also have a `pad_to_multiple_of` argument that you can use to reduce the number of unique input shapes you see!\n\n</Tip>\n\n### How do I actually train my model on TPU?\n\nOnce your training is XLA-compatible and (if you\u2019re using TPU Node / Colab) your dataset has been prepared appropriately, running on TPU is surprisingly easy! All you really need to change in your code is to add a few lines to initialize your TPU, and to ensure that your model and dataset are created inside a `TPUStrategy` scope. Take a look at [our TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) to see this in action!\n\n### Summary\n\nThere was a lot in here, so let\u2019s summarize with a quick checklist you can follow when you want to get your model ready for TPU training:\n\n- Make sure your code follows the three rules of XLA\n- Compile your model with `jit_compile=True` on CPU/GPU and confirm that you can train it with XLA\n- Either load your dataset into memory or use a TPU-compatible dataset loading approach (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Migrate your code either to Colab (with accelerator set to \u201cTPU\u201d) or a TPU VM on Google Cloud\n- Add TPU initializer code (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Create your `TPUStrategy` and make sure dataset loading and model creation are inside the `strategy.scope()` (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Don\u2019t forget to take `jit_compile=True` out again when you move to TPU!\n- \ud83d\ude4f\ud83d\ude4f\ud83d\ude4f\ud83e\udd7a\ud83e\udd7a\ud83e\udd7a\n- Call model.fit()\n- You did it!\n    ```",
            "vector_context": "[Created at: 2025-03-24 13:17:32]\n!--Copyright 2023 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\nthe License. You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under the License is distributed on\nan \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n\n\u26a0\ufe0f Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be\nrendered properly in your Markdown viewer.\n\n-->\n\n# Training on TPU with TensorFlow\n\n<Tip>\n\nIf you don't need long explanations and just want TPU code samples to get started with, check out [our TPU example notebook!](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb)\n\n</Tip>\n\n### What is a TPU?\n\nA TPU is a **Tensor Processing Unit.** They are hardware designed by Google, which are used to greatly speed up the tensor computations within neural networks, much like GPUs. They can be used for both network training and inference. They are generally accessed through Google\u2019s cloud services, but small TPUs can also be accessed directly for free through Google Colab and Kaggle Kernels.\n\nBecause [all TensorFlow models in \ud83e\udd17 Transformers are Keras models](https://huggingface.co/blog/tensorflow-philosophy), most of the methods in this document are generally applicable to TPU training for any Keras model! However, there are a few points that are specific to the HuggingFace ecosystem (hug-o-system?) of Transformers and Datasets, and we\u2019ll make sure to flag them up when we get to them.\n\n### What kinds of TPU are available?\n\nNew users are often very confused by the range of TPUs, and the different ways to access them. The first key distinction to understand is the difference between **TPU Nodes** and **TPU VMs.**\n\nWhen you use a **TPU Node**, you are effectively indirectly accessing a remote TPU. You will need a separate VM, which will initialize your network and data pipeline and then forward them to the remote node. When you use a TPU on Google Colab, you are accessing it in the **TPU Node** style.\n\nUsing TPU Nodes can have some quite unexpected behaviour for people who aren\u2019t used to them! In particular, because the TPU is located on a physically different system to the machine you\u2019re running your Python code on, your data cannot be local to your machine - any data pipeline that loads from your machine\u2019s internal storage will totally fail! Instead, data must be stored in Google Cloud Storage where your data pipeline can still access it, even when the pipeline is running on the remote TPU node.\n\n<Tip>\n\nIf you can fit all your data in memory as `np.ndarray` or `tf.Tensor`, then you can `fit()` on that data even when using Colab or a TPU Node, without needing to upload it to Google Cloud Storage.\n\n</Tip>\n\n<Tip>\n\n**\ud83e\udd17Specific Hugging Face Tip\ud83e\udd17:** The methods `Dataset.to_tf_dataset()` and its higher-level wrapper `model.prepare_tf_dataset()` , which you will see throughout our TF code examples, will both fail on a TPU Node. The reason for this is that even though they create a `tf.data.Dataset` it is not a \u201cpure\u201d `tf.data` pipeline and uses `tf.numpy_function` or `Dataset.from_generator()` to stream data from the underlying HuggingFace `Dataset`. This HuggingFace `Dataset` is backed by data that is on a local disc and which the remote TPU Node will not be able to read.\n\n</Tip>\n\nThe second way to access a TPU is via a **TPU VM.** When using a TPU VM, you connect directly to the machine that the TPU is attached to, much like training on a GPU VM. TPU VMs are generally easier to work with, particularly when it comes to your data pipeline. All of the above warnings do not apply to TPU VMs!\n\nThis is an opinionated document, so here\u2019s our opinion: **Avoid using TPU Node if possible.** It is more confusing and more difficult to debug than TPU VMs. It is also likely to be unsupported in future - Google\u2019s latest TPU, TPUv4, can only be accessed as a TPU VM, which suggests that TPU Nodes are increasingly going to become a \u201clegacy\u201d access method. However, we understand that the only free TPU access is on Colab and Kaggle Kernels, which uses TPU Node - so we\u2019ll try to explain how to handle it if you have to! Check the [TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) for code samples that explain this in more detail.\n\n### What sizes of TPU are available?\n\nA single TPU (a v2-8/v3-8/v4-8) runs 8 replicas. TPUs exist in **pods** that can run hundreds or thousands of replicas simultaneously. When you use more than a single TPU but less than a whole pod (for example, a v3-32), your TPU fleet is referred to as a **pod slice.**\n\nWhen you access a free TPU via Colab, you generally get a single v2-8 TPU.\n\n### I keep hearing about this XLA thing. What\u2019s XLA, and how does it relate to TPUs?\n\nXLA is an optimizing compiler, used by both TensorFlow and JAX. In JAX it is the only compiler, whereas in TensorFlow it is optional\n--New Chunk--\n[Created at: 2025-03-24 13:17:32]\n(for example, a v3-32), your TPU fleet is referred to as a **pod slice.**\n\nWhen you access a free TPU via Colab, you generally get a single v2-8 TPU.\n\n### I keep hearing about this XLA thing. What\u2019s XLA, and how does it relate to TPUs?\n\nXLA is an optimizing compiler, used by both TensorFlow and JAX. In JAX it is the only compiler, whereas in TensorFlow it is optional (but mandatory on TPU!). The easiest way to enable it when training a Keras model is to pass the argument `jit_compile=True` to `model.compile()`. If you don\u2019t get any errors and performance is good, that\u2019s a great sign that you\u2019re ready to move to TPU!\n\nDebugging on TPU is generally a bit harder than on CPU/GPU, so we recommend getting your code running on CPU/GPU with XLA first before trying it on TPU. You don\u2019t have to train for long, of course - just for a few steps to make sure that your model and data pipeline are working like you expect them to.\n\n<Tip>\n\nXLA compiled code is usually faster - so even if you\u2019re not planning to run on TPU, adding `jit_compile=True` can improve your performance. Be sure to note the caveats below about XLA compatibility, though!\n\n</Tip>\n\n<Tip warning={true}>\n\n**Tip born of painful experience:** Although using `jit_compile=True` is a good way to get a speed boost and test if your CPU/GPU code is XLA-compatible, it can actually cause a lot of problems if you leave it in when actually training on TPU. XLA compilation will happen implicitly on TPU, so remember to remove that line before actually running your code on a TPU!\n\n</Tip>\n\n### How do I make my model XLA compatible?\n\nIn many cases, your code is probably XLA-compatible already! However, there are a few things that work in normal TensorFlow that don\u2019t work in XLA. We\u2019ve distilled them into three core rules below:\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** We\u2019ve put a lot of effort into rewriting our TensorFlow models and loss functions to be XLA-compatible. Our models and loss functions generally obey rule #1 and #2 by default, so you can skip over them if you\u2019re using `transformers` models. Don\u2019t forget about these rules when writing your own models and loss functions, though!\n\n</Tip>\n\n#### XLA Rule #1: Your code cannot have \u201cdata-dependent conditionals\u201d\n\nWhat that means is that any `if` statement cannot depend on values inside a `tf.Tensor`. For example, this code block cannot be compiled with XLA!\n\n```python\nif tf.reduce_sum(tensor) > 10:\n    tensor = tensor / 2.0\n```\n\nThis might seem very restrictive at first, but most neural net code doesn\u2019t need to do this. You can often get around this restriction by using `tf.cond` (see the documentation [here](https://www.tensorflow.org/api_docs/python/tf/cond)) or by removing the conditional and finding a clever math trick with indicator variables instead, like so:\n\n```python\nsum_over_10 = tf.cast(tf.reduce_sum(tensor) > 10, tf.float32)\ntensor = tensor / (1.0 + sum_over_10)\n```\n\nThis code has exactly the same effect as the code above, but by avoiding a conditional, we ensure it will compile with XLA without problems!\n\n#### XLA Rule #2: Your code cannot have \u201cdata-dependent shapes\u201d\n\nWhat this means is that the shape of all of the `tf.Tensor` objects in your code cannot depend on their values. For example, the function `tf.unique` cannot be compiled with XLA, because it returns a `tensor` containing one instance of each unique value in the input. The shape of this output will obviously be different depending on how repetitive the input `Tensor` was, and so XLA refuses to handle it!\n\nIn general, most neural network code obeys rule #2 by default. However, there are a few common cases where it becomes a problem. One very common one is when you use **label masking**, setting your labels to a negative value to indicate that those positions should be ignored when computing the loss. If you look at NumPy or PyTorch loss functions that support label masking, you will often see code like this that uses [boolean indexing](https://numpy.org/doc/stable/user/basics.indexing.html#boolean-array-indexing):\n\n```python\nlabel_mask = labels >= 0\nmasked_outputs = outputs[label_mask]\nmasked_labels = labels[label_mask]\nloss = compute_loss(masked_outputs, masked_labels)\nmean_loss = torch.mean(loss)\n```\n\nThis code is totally fine in NumPy or PyTorch, but it breaks in XLA! Why? Because the shape of `masked_outputs` and `masked_labels` depends on how many positions are masked - that makes it a **data-dependent shape.** However, just like for rule #1, we can often rewrite this code to yield exactly the same output without any data-dependent shapes.\n\n```python\nlabel_mask = tf.cast(labels >= 0, tf.float32)\nloss = compute_loss(outputs, labels)\nloss = loss * label_mask  # Set negative label positions to 0\nmean_loss = tf.reduce_sum(loss) / tf.reduce_sum(label_mask)\n```\n\nHere, we avoid data-dependent shapes by computing the loss for every position, but zeroing out the masked positions in both the numerator and denominator when we calculate the mean, which yields exactly the same result as the first block while maintaining XLA compatibility. Note that we use the same trick as in rule #1 - converting a `tf.bool` to `\n--New Chunk--\n[Created at: 2025-03-24 13:17:32]\nlabel_mask  # Set negative label positions to 0\nmean_loss = tf.reduce_sum(loss) / tf.reduce_sum(label_mask)\n```\n\nHere, we avoid data-dependent shapes by computing the loss for every position, but zeroing out the masked positions in both the numerator and denominator when we calculate the mean, which yields exactly the same result as the first block while maintaining XLA compatibility. Note that we use the same trick as in rule #1 - converting a `tf.bool` to `tf.float32` and using it as an indicator variable. This is a really useful trick, so remember it if you need to convert your own code to XLA!\n\n#### XLA Rule #3: XLA will need to recompile your model for every different input shape it sees\n\nThis is the big one. What this means is that if your input shapes are very variable, XLA will have to recompile your model over and over, which will create huge performance problems. This commonly arises in NLP models, where input texts have variable lengths after tokenization. In other modalities, static shapes are more common and this rule is much less of a problem.\n\nHow can you get around rule #3? The key is **padding** - if you pad all your inputs to the same length, and then use an `attention_mask`, you can get the same results as you\u2019d get from variable shapes, but without any XLA issues. However, excessive padding can cause severe slowdown too - if you pad all your samples to the maximum length in the whole dataset, you might end up with batches consisting endless padding tokens, which will waste a lot of compute and memory!\n\nThere isn\u2019t a perfect solution to this problem. However, you can try some tricks. One very useful trick is to **pad batches of samples up to a multiple of a number like 32 or 64 tokens.** This often only increases the number of tokens by a small amount, but it hugely reduces the number of unique input shapes, because every input shape now has to be a multiple of 32 or 64. Fewer unique input shapes means fewer XLA compilations!\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** Our tokenizers and data collators have methods that can help you here. You can use `padding=\"max_length\"` or `padding=\"longest\"` when calling tokenizers to get them to output padded data. Our tokenizers and data collators also have a `pad_to_multiple_of` argument that you can use to reduce the number of unique input shapes you see!\n\n</Tip>\n\n### How do I actually train my model on TPU?\n\nOnce your training is XLA-compatible and (if you\u2019re using TPU Node / Colab) your dataset has been prepared appropriately, running on TPU is surprisingly easy! All you really need to change in your code is to add a few lines to initialize your TPU, and to ensure that your model and dataset are created inside a `TPUStrategy` scope. Take a look at [our TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) to see this in action!\n\n### Summary\n\nThere was a lot in here, so let\u2019s summarize with a quick checklist you can follow when you want to get your model ready for TPU training:\n\n- Make sure your code follows the three rules of XLA\n- Compile your model with `jit_compile=True` on CPU/GPU and confirm that you can train it with XLA\n- Either load your dataset into memory or use a TPU-compatible dataset loading approach (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Migrate your code either to Colab (with accelerator set to \u201cTPU\u201d) or a TPU VM on Google Cloud\n- Add TPU initializer code (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Create your `TPUStrategy` and make sure dataset loading and model creation are inside the `strategy.scope()` (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Don\u2019t forget to take `jit_compile=True` out again when you move to TPU!\n- \ud83d\ude4f\ud83d\ude4f\ud83d\ude4f\ud83e\udd7a\ud83e\udd7a\ud83e\udd7a\n- Call model.fit()\n- You did it!"
        }
    },
    {
        "context": "### Summary\n\nThere was a lot in here, so let\u2019s summarize with a quick checklist you can follow when you want to get your model ready for TPU training:\n\n- Make sure your code follows the three rules of XLA\n- Compile your model with `jit_compile=True` on CPU/GPU and confirm that you can train it with XLA\n- Either load your dataset into memory or use a TPU-compatible dataset loading approach (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Migrate your code either to Colab (with accelerator set to \u201cTPU\u201d) or a TPU VM on Google Cloud\n- Add TPU initializer code (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Create your `TPUStrategy` and make sure dataset loading and model creation are inside the `strategy.scope()` (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Don\u2019t forget to take `jit_compile=True` out again when you move to TPU!\n- \ud83d\ude4f\ud83d\ude4f\ud83d\ude4f\ud83e\udd7a\ud83e\udd7a\ud83e\udd7a\n- Call model.fit()\n- You did it!",
        "question": "What is the purpose of setting jit_compile=True on CPU/GPU?",
        "answer": "To confirm that the model can be trained with XLA.",
        "source_doc": "huggingface/transformers/blob/main/docs/source/en/perf_train_tpu_tf.md",
        "rag_answer": null,
        "rag_context": null,
        "rag_score": null,
        "rag_feedback": null
    },
    {
        "sample_idx": 80,
        "question": "What are the two options to migrate code for TPU training?",
        "answer": "Colab with accelerator set to 'TPU' or a TPU VM on Google Cloud.",
        "rag_answer": "According to the provided Data Sources, the two options to migrate code for TPU training are:\n\n1. Migrate your code to **Colab** (with accelerator set to \u201cTPU\u201d).\n2.",
        "rag_score": null,
        "rag_feedback": null,
        "rag_context": {
            "kg_context": "-----Entities-----\n    ```csv\n    id,\tentity,\ttype,\tdescription,\trankcreated_at\n1,\tTPU,technology,TPU is a Tensor Processing Unit, a hardware designed by Google to speed up tensor computations within neural networks.<SEP>TPU is a type of hardware accelerator designed for machine learning workloads.<SEP>TPU is a type of hardware accelerator used for machine learning computations.,4,2025-03-24 13:18:20\n2,\tXLA,technology,XLA is a technology that compiles TensorFlow graphs into executable code for various platforms.<SEP>XLA is an optimizing compiler used by TensorFlow and JAX to improve performance.<SEP>XLA is an optimizing compiler, used by both TensorFlow and JAX to optimize computations.,6,2025-03-24 13:18:20\n3,\tGoogle,organization,Google is the company that designs and provides TPUs, which are used to speed up tensor computations within neural networks.,3,2025-03-24 13:18:20\n4,\tGoogle Cloud,organization,Google Cloud is a cloud computing platform that provides infrastructure and services for building and deploying machine learning models.,1,2025-03-24 13:18:20\n5,\tTPU,technology,TPU is a Tensor Processing Unit, a hardware designed by Google to speed up tensor computations within neural networks.<SEP>TPU is a type of hardware accelerator designed for machine learning workloads.<SEP>TPU is a type of hardware accelerator used for machine learning computations.,4,UNKNOWN\n6,\tGoogle,organization,Google is the company that designs and provides TPUs, which are used to speed up tensor computations within neural networks.,3,UNKNOWN\n7,\tTPUv4,category,TPUv4 is a type of TPU, a hardware designed by Google to speed up tensor computations within neural networks.,0,UNKNOWN\n    ```\n    -----Relationships-----\n    ```csv\n    id,\tsource,\ttarget,\tdescription,\tkeywords,\tweight,\trank,\tcreated_at\n1,\tTPU,XLA,XLA compiles TensorFlow graphs into executable code for TPU hardware.<SEP>XLA is used to optimize code for TPU hardware.,compilation, hardware acceleration<SEP>compiler, hardware optimization,36.0,10,2025-03-24 13:18:20\n2,\tGoogle,TPU,Google designs and provides TPUs, which are used to speed up tensor computations within neural networks.,hardware design, acceleration,18.0,7,2025-03-24 13:18:20\n3,\tGoogle Cloud,TPU,Google Cloud provides infrastructure and services for building and deploying machine learning models, including TPU hardware.,infrastructure provision, hardware acceleration,14.0,5,2025-03-24 13:18:20\n4,\tTPU,XLA,XLA compiles TensorFlow graphs into executable code for TPU hardware.<SEP>XLA is used to optimize code for TPU hardware.,compilation, hardware acceleration<SEP>compiler, hardware optimization,36.0,10,UNKNOWN\n5,\tGoogle,TPU,Google designs and provides TPUs, which are used to speed up tensor computations within neural networks.,hardware design, acceleration,18.0,7,UNKNOWN\n6,\tColab,TPU,Colab provides access to a free TPU for users.,platform, hardware acceleration,16.0,7,UNKNOWN\n7,\tColab,Google,Colab is a cloud-based platform provided by Google for data science and machine learning.,platform provision, cloud computing,16.0,6,UNKNOWN\n8,\tGoogle Cloud,TPU,Google Cloud provides infrastructure and services for building and deploying machine learning models, including TPU hardware.,infrastructure provision, hardware acceleration,14.0,5,UNKNOWN\n9,\tGoogle,Kaggle Kernels,Kaggle Kernels is a cloud-based platform provided by Google for data science and machine learning competitions.,platform provision, cloud computing,16.0,4,UNKNOWN\n    ```\n    -----Sources-----\n    ```csv\n    id,\tcontent\n1,\t(for example, a v3-32), your TPU fleet is referred to as a **pod slice.**\n\nWhen you access a free TPU via Colab, you generally get a single v2-8 TPU.\n\n### I keep hearing about this XLA thing. What\u2019s XLA, and how does it relate to TPUs?\n\nXLA is an optimizing compiler, used by both TensorFlow and JAX. In JAX it is the only compiler, whereas in TensorFlow it is optional (but mandatory on TPU!). The easiest way to enable it when training a Keras model is to pass the argument `jit_compile=True` to `model.compile()`. If you don\u2019t get any errors and performance is good, that\u2019s a great sign that you\u2019re ready to move to TPU!\n\nDebugging on TPU is generally a bit harder than on CPU/GPU, so we recommend getting your code running on CPU/GPU with XLA first before trying it on TPU. You don\u2019t have to train for long, of course - just for a few steps to make sure that your model and data pipeline are working like you expect them to.\n\n<Tip>\n\nXLA compiled code is usually faster - so even if you\u2019re not planning to run on TPU, adding `jit_compile=True` can improve your performance. Be sure to note the caveats below about XLA compatibility, though!\n\n</Tip>\n\n<Tip warning={true}>\n\n**Tip born of painful experience:** Although using `jit_compile=True` is a good way to get a speed boost and test if your CPU/GPU code is XLA-compatible, it can actually cause a lot of problems if you leave it in when actually training on TPU. XLA compilation will happen implicitly on TPU, so remember to remove that line before actually running your code on a TPU!\n\n</Tip>\n\n### How do I make my model XLA compatible?\n\nIn many cases, your code is probably XLA-compatible already! However, there are a few things that work in normal TensorFlow that don\u2019t work in XLA. We\u2019ve distilled them into three core rules below:\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** We\u2019ve put a lot of effort into rewriting our TensorFlow models and loss functions to be XLA-compatible. Our models and loss functions generally obey rule #1 and #2 by default, so you can skip over them if you\u2019re using `transformers` models. Don\u2019t forget about these rules when writing your own models and loss functions, though!\n\n</Tip>\n\n#### XLA Rule #1: Your code cannot have \u201cdata-dependent conditionals\u201d\n\nWhat that means is that any `if` statement cannot depend on values inside a `tf.Tensor`. For example, this code block cannot be compiled with XLA!\n\n```python\nif tf.reduce_sum(tensor) > 10:\n    tensor = tensor / 2.0\n```\n\nThis might seem very restrictive at first, but most neural net code doesn\u2019t need to do this. You can often get around this restriction by using `tf.cond` (see the documentation [here](https://www.tensorflow.org/api_docs/python/tf/cond)) or by removing the conditional and finding a clever math trick with indicator variables instead, like so:\n\n```python\nsum_over_10 = tf.cast(tf.reduce_sum(tensor) > 10, tf.float32)\ntensor = tensor / (1.0 + sum_over_10)\n```\n\nThis code has exactly the same effect as the code above, but by avoiding a conditional, we ensure it will compile with XLA without problems!\n\n#### XLA Rule #2: Your code cannot have \u201cdata-dependent shapes\u201d\n\nWhat this means is that the shape of all of the `tf.Tensor` objects in your code cannot depend on their values. For example, the function `tf.unique` cannot be compiled with XLA, because it returns a `tensor` containing one instance of each unique value in the input. The shape of this output will obviously be different depending on how repetitive the input `Tensor` was, and so XLA refuses to handle it!\n\nIn general, most neural network code obeys rule #2 by default. However, there are a few common cases where it becomes a problem. One very common one is when you use **label masking**, setting your labels to a negative value to indicate that those positions should be ignored when computing the loss. If you look at NumPy or PyTorch loss functions that support label masking, you will often see code like this that uses [boolean indexing](https://numpy.org/doc/stable/user/basics.indexing.html#boolean-array-indexing):\n\n```python\nlabel_mask = labels >= 0\nmasked_outputs = outputs[label_mask]\nmasked_labels = labels[label_mask]\nloss = compute_loss(masked_outputs, masked_labels)\nmean_loss = torch.mean(loss)\n```\n\nThis code is totally fine in NumPy or PyTorch, but it breaks in XLA! Why? Because the shape of `masked_outputs` and `masked_labels` depends on how many positions are masked - that makes it a **data-dependent shape.** However, just like for rule #1, we can often rewrite this code to yield exactly the same output without any data-dependent shapes.\n\n```python\nlabel_mask = tf.cast(labels >= 0, tf.float32)\nloss = compute_loss(outputs, labels)\nloss = loss * label_mask  # Set negative label positions to 0\nmean_loss = tf.reduce_sum(loss) / tf.reduce_sum(label_mask)\n```\n\nHere, we avoid data-dependent shapes by computing the loss for every position, but zeroing out the masked positions in both the numerator and denominator when we calculate the mean, which yields exactly the same result as the first block while maintaining XLA compatibility. Note that we use the same trick as in rule #1 - converting a `tf.bool` to `\n2,\tlabel_mask  # Set negative label positions to 0\nmean_loss = tf.reduce_sum(loss) / tf.reduce_sum(label_mask)\n```\n\nHere, we avoid data-dependent shapes by computing the loss for every position, but zeroing out the masked positions in both the numerator and denominator when we calculate the mean, which yields exactly the same result as the first block while maintaining XLA compatibility. Note that we use the same trick as in rule #1 - converting a `tf.bool` to `tf.float32` and using it as an indicator variable. This is a really useful trick, so remember it if you need to convert your own code to XLA!\n\n#### XLA Rule #3: XLA will need to recompile your model for every different input shape it sees\n\nThis is the big one. What this means is that if your input shapes are very variable, XLA will have to recompile your model over and over, which will create huge performance problems. This commonly arises in NLP models, where input texts have variable lengths after tokenization. In other modalities, static shapes are more common and this rule is much less of a problem.\n\nHow can you get around rule #3? The key is **padding** - if you pad all your inputs to the same length, and then use an `attention_mask`, you can get the same results as you\u2019d get from variable shapes, but without any XLA issues. However, excessive padding can cause severe slowdown too - if you pad all your samples to the maximum length in the whole dataset, you might end up with batches consisting endless padding tokens, which will waste a lot of compute and memory!\n\nThere isn\u2019t a perfect solution to this problem. However, you can try some tricks. One very useful trick is to **pad batches of samples up to a multiple of a number like 32 or 64 tokens.** This often only increases the number of tokens by a small amount, but it hugely reduces the number of unique input shapes, because every input shape now has to be a multiple of 32 or 64. Fewer unique input shapes means fewer XLA compilations!\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** Our tokenizers and data collators have methods that can help you here. You can use `padding=\"max_length\"` or `padding=\"longest\"` when calling tokenizers to get them to output padded data. Our tokenizers and data collators also have a `pad_to_multiple_of` argument that you can use to reduce the number of unique input shapes you see!\n\n</Tip>\n\n### How do I actually train my model on TPU?\n\nOnce your training is XLA-compatible and (if you\u2019re using TPU Node / Colab) your dataset has been prepared appropriately, running on TPU is surprisingly easy! All you really need to change in your code is to add a few lines to initialize your TPU, and to ensure that your model and dataset are created inside a `TPUStrategy` scope. Take a look at [our TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) to see this in action!\n\n### Summary\n\nThere was a lot in here, so let\u2019s summarize with a quick checklist you can follow when you want to get your model ready for TPU training:\n\n- Make sure your code follows the three rules of XLA\n- Compile your model with `jit_compile=True` on CPU/GPU and confirm that you can train it with XLA\n- Either load your dataset into memory or use a TPU-compatible dataset loading approach (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Migrate your code either to Colab (with accelerator set to \u201cTPU\u201d) or a TPU VM on Google Cloud\n- Add TPU initializer code (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Create your `TPUStrategy` and make sure dataset loading and model creation are inside the `strategy.scope()` (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Don\u2019t forget to take `jit_compile=True` out again when you move to TPU!\n- \ud83d\ude4f\ud83d\ude4f\ud83d\ude4f\ud83e\udd7a\ud83e\udd7a\ud83e\udd7a\n- Call model.fit()\n- You did it!\n3,\t!--Copyright 2023 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\nthe License. You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under the License is distributed on\nan \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n\n\u26a0\ufe0f Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be\nrendered properly in your Markdown viewer.\n\n-->\n\n# Training on TPU with TensorFlow\n\n<Tip>\n\nIf you don't need long explanations and just want TPU code samples to get started with, check out [our TPU example notebook!](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb)\n\n</Tip>\n\n### What is a TPU?\n\nA TPU is a **Tensor Processing Unit.** They are hardware designed by Google, which are used to greatly speed up the tensor computations within neural networks, much like GPUs. They can be used for both network training and inference. They are generally accessed through Google\u2019s cloud services, but small TPUs can also be accessed directly for free through Google Colab and Kaggle Kernels.\n\nBecause [all TensorFlow models in \ud83e\udd17 Transformers are Keras models](https://huggingface.co/blog/tensorflow-philosophy), most of the methods in this document are generally applicable to TPU training for any Keras model! However, there are a few points that are specific to the HuggingFace ecosystem (hug-o-system?) of Transformers and Datasets, and we\u2019ll make sure to flag them up when we get to them.\n\n### What kinds of TPU are available?\n\nNew users are often very confused by the range of TPUs, and the different ways to access them. The first key distinction to understand is the difference between **TPU Nodes** and **TPU VMs.**\n\nWhen you use a **TPU Node**, you are effectively indirectly accessing a remote TPU. You will need a separate VM, which will initialize your network and data pipeline and then forward them to the remote node. When you use a TPU on Google Colab, you are accessing it in the **TPU Node** style.\n\nUsing TPU Nodes can have some quite unexpected behaviour for people who aren\u2019t used to them! In particular, because the TPU is located on a physically different system to the machine you\u2019re running your Python code on, your data cannot be local to your machine - any data pipeline that loads from your machine\u2019s internal storage will totally fail! Instead, data must be stored in Google Cloud Storage where your data pipeline can still access it, even when the pipeline is running on the remote TPU node.\n\n<Tip>\n\nIf you can fit all your data in memory as `np.ndarray` or `tf.Tensor`, then you can `fit()` on that data even when using Colab or a TPU Node, without needing to upload it to Google Cloud Storage.\n\n</Tip>\n\n<Tip>\n\n**\ud83e\udd17Specific Hugging Face Tip\ud83e\udd17:** The methods `Dataset.to_tf_dataset()` and its higher-level wrapper `model.prepare_tf_dataset()` , which you will see throughout our TF code examples, will both fail on a TPU Node. The reason for this is that even though they create a `tf.data.Dataset` it is not a \u201cpure\u201d `tf.data` pipeline and uses `tf.numpy_function` or `Dataset.from_generator()` to stream data from the underlying HuggingFace `Dataset`. This HuggingFace `Dataset` is backed by data that is on a local disc and which the remote TPU Node will not be able to read.\n\n</Tip>\n\nThe second way to access a TPU is via a **TPU VM.** When using a TPU VM, you connect directly to the machine that the TPU is attached to, much like training on a GPU VM. TPU VMs are generally easier to work with, particularly when it comes to your data pipeline. All of the above warnings do not apply to TPU VMs!\n\nThis is an opinionated document, so here\u2019s our opinion: **Avoid using TPU Node if possible.** It is more confusing and more difficult to debug than TPU VMs. It is also likely to be unsupported in future - Google\u2019s latest TPU, TPUv4, can only be accessed as a TPU VM, which suggests that TPU Nodes are increasingly going to become a \u201clegacy\u201d access method. However, we understand that the only free TPU access is on Colab and Kaggle Kernels, which uses TPU Node - so we\u2019ll try to explain how to handle it if you have to! Check the [TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) for code samples that explain this in more detail.\n\n### What sizes of TPU are available?\n\nA single TPU (a v2-8/v3-8/v4-8) runs 8 replicas. TPUs exist in **pods** that can run hundreds or thousands of replicas simultaneously. When you use more than a single TPU but less than a whole pod (for example, a v3-32), your TPU fleet is referred to as a **pod slice.**\n\nWhen you access a free TPU via Colab, you generally get a single v2-8 TPU.\n\n### I keep hearing about this XLA thing. What\u2019s XLA, and how does it relate to TPUs?\n\nXLA is an optimizing compiler, used by both TensorFlow and JAX. In JAX it is the only compiler, whereas in TensorFlow it is optional\n    ```",
            "vector_context": "[Created at: 2025-03-24 13:17:32]\n!--Copyright 2023 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\nthe License. You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under the License is distributed on\nan \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n\n\u26a0\ufe0f Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be\nrendered properly in your Markdown viewer.\n\n-->\n\n# Training on TPU with TensorFlow\n\n<Tip>\n\nIf you don't need long explanations and just want TPU code samples to get started with, check out [our TPU example notebook!](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb)\n\n</Tip>\n\n### What is a TPU?\n\nA TPU is a **Tensor Processing Unit.** They are hardware designed by Google, which are used to greatly speed up the tensor computations within neural networks, much like GPUs. They can be used for both network training and inference. They are generally accessed through Google\u2019s cloud services, but small TPUs can also be accessed directly for free through Google Colab and Kaggle Kernels.\n\nBecause [all TensorFlow models in \ud83e\udd17 Transformers are Keras models](https://huggingface.co/blog/tensorflow-philosophy), most of the methods in this document are generally applicable to TPU training for any Keras model! However, there are a few points that are specific to the HuggingFace ecosystem (hug-o-system?) of Transformers and Datasets, and we\u2019ll make sure to flag them up when we get to them.\n\n### What kinds of TPU are available?\n\nNew users are often very confused by the range of TPUs, and the different ways to access them. The first key distinction to understand is the difference between **TPU Nodes** and **TPU VMs.**\n\nWhen you use a **TPU Node**, you are effectively indirectly accessing a remote TPU. You will need a separate VM, which will initialize your network and data pipeline and then forward them to the remote node. When you use a TPU on Google Colab, you are accessing it in the **TPU Node** style.\n\nUsing TPU Nodes can have some quite unexpected behaviour for people who aren\u2019t used to them! In particular, because the TPU is located on a physically different system to the machine you\u2019re running your Python code on, your data cannot be local to your machine - any data pipeline that loads from your machine\u2019s internal storage will totally fail! Instead, data must be stored in Google Cloud Storage where your data pipeline can still access it, even when the pipeline is running on the remote TPU node.\n\n<Tip>\n\nIf you can fit all your data in memory as `np.ndarray` or `tf.Tensor`, then you can `fit()` on that data even when using Colab or a TPU Node, without needing to upload it to Google Cloud Storage.\n\n</Tip>\n\n<Tip>\n\n**\ud83e\udd17Specific Hugging Face Tip\ud83e\udd17:** The methods `Dataset.to_tf_dataset()` and its higher-level wrapper `model.prepare_tf_dataset()` , which you will see throughout our TF code examples, will both fail on a TPU Node. The reason for this is that even though they create a `tf.data.Dataset` it is not a \u201cpure\u201d `tf.data` pipeline and uses `tf.numpy_function` or `Dataset.from_generator()` to stream data from the underlying HuggingFace `Dataset`. This HuggingFace `Dataset` is backed by data that is on a local disc and which the remote TPU Node will not be able to read.\n\n</Tip>\n\nThe second way to access a TPU is via a **TPU VM.** When using a TPU VM, you connect directly to the machine that the TPU is attached to, much like training on a GPU VM. TPU VMs are generally easier to work with, particularly when it comes to your data pipeline. All of the above warnings do not apply to TPU VMs!\n\nThis is an opinionated document, so here\u2019s our opinion: **Avoid using TPU Node if possible.** It is more confusing and more difficult to debug than TPU VMs. It is also likely to be unsupported in future - Google\u2019s latest TPU, TPUv4, can only be accessed as a TPU VM, which suggests that TPU Nodes are increasingly going to become a \u201clegacy\u201d access method. However, we understand that the only free TPU access is on Colab and Kaggle Kernels, which uses TPU Node - so we\u2019ll try to explain how to handle it if you have to! Check the [TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) for code samples that explain this in more detail.\n\n### What sizes of TPU are available?\n\nA single TPU (a v2-8/v3-8/v4-8) runs 8 replicas. TPUs exist in **pods** that can run hundreds or thousands of replicas simultaneously. When you use more than a single TPU but less than a whole pod (for example, a v3-32), your TPU fleet is referred to as a **pod slice.**\n\nWhen you access a free TPU via Colab, you generally get a single v2-8 TPU.\n\n### I keep hearing about this XLA thing. What\u2019s XLA, and how does it relate to TPUs?\n\nXLA is an optimizing compiler, used by both TensorFlow and JAX. In JAX it is the only compiler, whereas in TensorFlow it is optional\n--New Chunk--\n[Created at: 2025-03-24 13:17:32]\n(for example, a v3-32), your TPU fleet is referred to as a **pod slice.**\n\nWhen you access a free TPU via Colab, you generally get a single v2-8 TPU.\n\n### I keep hearing about this XLA thing. What\u2019s XLA, and how does it relate to TPUs?\n\nXLA is an optimizing compiler, used by both TensorFlow and JAX. In JAX it is the only compiler, whereas in TensorFlow it is optional (but mandatory on TPU!). The easiest way to enable it when training a Keras model is to pass the argument `jit_compile=True` to `model.compile()`. If you don\u2019t get any errors and performance is good, that\u2019s a great sign that you\u2019re ready to move to TPU!\n\nDebugging on TPU is generally a bit harder than on CPU/GPU, so we recommend getting your code running on CPU/GPU with XLA first before trying it on TPU. You don\u2019t have to train for long, of course - just for a few steps to make sure that your model and data pipeline are working like you expect them to.\n\n<Tip>\n\nXLA compiled code is usually faster - so even if you\u2019re not planning to run on TPU, adding `jit_compile=True` can improve your performance. Be sure to note the caveats below about XLA compatibility, though!\n\n</Tip>\n\n<Tip warning={true}>\n\n**Tip born of painful experience:** Although using `jit_compile=True` is a good way to get a speed boost and test if your CPU/GPU code is XLA-compatible, it can actually cause a lot of problems if you leave it in when actually training on TPU. XLA compilation will happen implicitly on TPU, so remember to remove that line before actually running your code on a TPU!\n\n</Tip>\n\n### How do I make my model XLA compatible?\n\nIn many cases, your code is probably XLA-compatible already! However, there are a few things that work in normal TensorFlow that don\u2019t work in XLA. We\u2019ve distilled them into three core rules below:\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** We\u2019ve put a lot of effort into rewriting our TensorFlow models and loss functions to be XLA-compatible. Our models and loss functions generally obey rule #1 and #2 by default, so you can skip over them if you\u2019re using `transformers` models. Don\u2019t forget about these rules when writing your own models and loss functions, though!\n\n</Tip>\n\n#### XLA Rule #1: Your code cannot have \u201cdata-dependent conditionals\u201d\n\nWhat that means is that any `if` statement cannot depend on values inside a `tf.Tensor`. For example, this code block cannot be compiled with XLA!\n\n```python\nif tf.reduce_sum(tensor) > 10:\n    tensor = tensor / 2.0\n```\n\nThis might seem very restrictive at first, but most neural net code doesn\u2019t need to do this. You can often get around this restriction by using `tf.cond` (see the documentation [here](https://www.tensorflow.org/api_docs/python/tf/cond)) or by removing the conditional and finding a clever math trick with indicator variables instead, like so:\n\n```python\nsum_over_10 = tf.cast(tf.reduce_sum(tensor) > 10, tf.float32)\ntensor = tensor / (1.0 + sum_over_10)\n```\n\nThis code has exactly the same effect as the code above, but by avoiding a conditional, we ensure it will compile with XLA without problems!\n\n#### XLA Rule #2: Your code cannot have \u201cdata-dependent shapes\u201d\n\nWhat this means is that the shape of all of the `tf.Tensor` objects in your code cannot depend on their values. For example, the function `tf.unique` cannot be compiled with XLA, because it returns a `tensor` containing one instance of each unique value in the input. The shape of this output will obviously be different depending on how repetitive the input `Tensor` was, and so XLA refuses to handle it!\n\nIn general, most neural network code obeys rule #2 by default. However, there are a few common cases where it becomes a problem. One very common one is when you use **label masking**, setting your labels to a negative value to indicate that those positions should be ignored when computing the loss. If you look at NumPy or PyTorch loss functions that support label masking, you will often see code like this that uses [boolean indexing](https://numpy.org/doc/stable/user/basics.indexing.html#boolean-array-indexing):\n\n```python\nlabel_mask = labels >= 0\nmasked_outputs = outputs[label_mask]\nmasked_labels = labels[label_mask]\nloss = compute_loss(masked_outputs, masked_labels)\nmean_loss = torch.mean(loss)\n```\n\nThis code is totally fine in NumPy or PyTorch, but it breaks in XLA! Why? Because the shape of `masked_outputs` and `masked_labels` depends on how many positions are masked - that makes it a **data-dependent shape.** However, just like for rule #1, we can often rewrite this code to yield exactly the same output without any data-dependent shapes.\n\n```python\nlabel_mask = tf.cast(labels >= 0, tf.float32)\nloss = compute_loss(outputs, labels)\nloss = loss * label_mask  # Set negative label positions to 0\nmean_loss = tf.reduce_sum(loss) / tf.reduce_sum(label_mask)\n```\n\nHere, we avoid data-dependent shapes by computing the loss for every position, but zeroing out the masked positions in both the numerator and denominator when we calculate the mean, which yields exactly the same result as the first block while maintaining XLA compatibility. Note that we use the same trick as in rule #1 - converting a `tf.bool` to `\n--New Chunk--\n[Created at: 2025-03-24 13:17:32]\nlabel_mask  # Set negative label positions to 0\nmean_loss = tf.reduce_sum(loss) / tf.reduce_sum(label_mask)\n```\n\nHere, we avoid data-dependent shapes by computing the loss for every position, but zeroing out the masked positions in both the numerator and denominator when we calculate the mean, which yields exactly the same result as the first block while maintaining XLA compatibility. Note that we use the same trick as in rule #1 - converting a `tf.bool` to `tf.float32` and using it as an indicator variable. This is a really useful trick, so remember it if you need to convert your own code to XLA!\n\n#### XLA Rule #3: XLA will need to recompile your model for every different input shape it sees\n\nThis is the big one. What this means is that if your input shapes are very variable, XLA will have to recompile your model over and over, which will create huge performance problems. This commonly arises in NLP models, where input texts have variable lengths after tokenization. In other modalities, static shapes are more common and this rule is much less of a problem.\n\nHow can you get around rule #3? The key is **padding** - if you pad all your inputs to the same length, and then use an `attention_mask`, you can get the same results as you\u2019d get from variable shapes, but without any XLA issues. However, excessive padding can cause severe slowdown too - if you pad all your samples to the maximum length in the whole dataset, you might end up with batches consisting endless padding tokens, which will waste a lot of compute and memory!\n\nThere isn\u2019t a perfect solution to this problem. However, you can try some tricks. One very useful trick is to **pad batches of samples up to a multiple of a number like 32 or 64 tokens.** This often only increases the number of tokens by a small amount, but it hugely reduces the number of unique input shapes, because every input shape now has to be a multiple of 32 or 64. Fewer unique input shapes means fewer XLA compilations!\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** Our tokenizers and data collators have methods that can help you here. You can use `padding=\"max_length\"` or `padding=\"longest\"` when calling tokenizers to get them to output padded data. Our tokenizers and data collators also have a `pad_to_multiple_of` argument that you can use to reduce the number of unique input shapes you see!\n\n</Tip>\n\n### How do I actually train my model on TPU?\n\nOnce your training is XLA-compatible and (if you\u2019re using TPU Node / Colab) your dataset has been prepared appropriately, running on TPU is surprisingly easy! All you really need to change in your code is to add a few lines to initialize your TPU, and to ensure that your model and dataset are created inside a `TPUStrategy` scope. Take a look at [our TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) to see this in action!\n\n### Summary\n\nThere was a lot in here, so let\u2019s summarize with a quick checklist you can follow when you want to get your model ready for TPU training:\n\n- Make sure your code follows the three rules of XLA\n- Compile your model with `jit_compile=True` on CPU/GPU and confirm that you can train it with XLA\n- Either load your dataset into memory or use a TPU-compatible dataset loading approach (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Migrate your code either to Colab (with accelerator set to \u201cTPU\u201d) or a TPU VM on Google Cloud\n- Add TPU initializer code (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Create your `TPUStrategy` and make sure dataset loading and model creation are inside the `strategy.scope()` (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Don\u2019t forget to take `jit_compile=True` out again when you move to TPU!\n- \ud83d\ude4f\ud83d\ude4f\ud83d\ude4f\ud83e\udd7a\ud83e\udd7a\ud83e\udd7a\n- Call model.fit()\n- You did it!"
        }
    },
    {
        "sample_idx": 81,
        "question": "Where can you find the TPU initializer code?",
        "answer": "In the provided notebook.",
        "rag_answer": "You can find the TPU initializer code in the [TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb). This notebook provides a comprehensive guide",
        "rag_score": null,
        "rag_feedback": null,
        "rag_context": {
            "kg_context": "-----Entities-----\n    ```csv\n    id,\tentity,\ttype,\tdescription,\trankcreated_at\n1,\tTPU,technology,TPU is a Tensor Processing Unit, a hardware designed by Google to speed up tensor computations within neural networks.<SEP>TPU is a type of hardware accelerator designed for machine learning workloads.<SEP>TPU is a type of hardware accelerator used for machine learning computations.,4,2025-03-24 13:18:20\n2,\tXLA,technology,XLA is a technology that compiles TensorFlow graphs into executable code for various platforms.<SEP>XLA is an optimizing compiler used by TensorFlow and JAX to improve performance.<SEP>XLA is an optimizing compiler, used by both TensorFlow and JAX to optimize computations.,6,2025-03-24 13:18:20\n3,\tKeras,category,Keras is a high-level neural networks API, used for building and training neural networks.<SEP>Keras is a machine learning framework that uses XLA for optimization.,2,2025-03-24 13:18:20\n4,\tGoogle,organization,Google is the company that designs and provides TPUs, which are used to speed up tensor computations within neural networks.,3,2025-03-24 13:18:20\n5,\tTPU,technology,TPU is a Tensor Processing Unit, a hardware designed by Google to speed up tensor computations within neural networks.<SEP>TPU is a type of hardware accelerator designed for machine learning workloads.<SEP>TPU is a type of hardware accelerator used for machine learning computations.,4,UNKNOWN\n6,\tTPUv4,category,TPUv4 is a type of TPU, a hardware designed by Google to speed up tensor computations within neural networks.,0,UNKNOWN\n7,\tGoogle,organization,Google is the company that designs and provides TPUs, which are used to speed up tensor computations within neural networks.,3,UNKNOWN\n    ```\n    -----Relationships-----\n    ```csv\n    id,\tsource,\ttarget,\tdescription,\tkeywords,\tweight,\trank,\tcreated_at\n1,\tTPU,XLA,XLA compiles TensorFlow graphs into executable code for TPU hardware.<SEP>XLA is used to optimize code for TPU hardware.,compilation, hardware acceleration<SEP>compiler, hardware optimization,36.0,10,2025-03-24 13:18:20\n2,\tKeras,XLA,Keras uses XLA for optimization.,compiler, performance optimization,8.0,8,2025-03-24 13:18:20\n3,\tGoogle,TPU,Google designs and provides TPUs, which are used to speed up tensor computations within neural networks.,hardware design, acceleration,18.0,7,2025-03-24 13:18:20\n4,\tTPU,XLA,XLA compiles TensorFlow graphs into executable code for TPU hardware.<SEP>XLA is used to optimize code for TPU hardware.,compilation, hardware acceleration<SEP>compiler, hardware optimization,36.0,10,UNKNOWN\n5,\tGoogle,TPU,Google designs and provides TPUs, which are used to speed up tensor computations within neural networks.,hardware design, acceleration,18.0,7,UNKNOWN\n6,\tColab,TPU,Colab provides access to a free TPU for users.,platform, hardware acceleration,16.0,7,UNKNOWN\n7,\tColab,Google,Colab is a cloud-based platform provided by Google for data science and machine learning.,platform provision, cloud computing,16.0,6,UNKNOWN\n8,\tGoogle Cloud,TPU,Google Cloud provides infrastructure and services for building and deploying machine learning models, including TPU hardware.,infrastructure provision, hardware acceleration,14.0,5,UNKNOWN\n9,\tGoogle,Kaggle Kernels,Kaggle Kernels is a cloud-based platform provided by Google for data science and machine learning competitions.,platform provision, cloud computing,16.0,4,UNKNOWN\n    ```\n    -----Sources-----\n    ```csv\n    id,\tcontent\n1,\t(for example, a v3-32), your TPU fleet is referred to as a **pod slice.**\n\nWhen you access a free TPU via Colab, you generally get a single v2-8 TPU.\n\n### I keep hearing about this XLA thing. What\u2019s XLA, and how does it relate to TPUs?\n\nXLA is an optimizing compiler, used by both TensorFlow and JAX. In JAX it is the only compiler, whereas in TensorFlow it is optional (but mandatory on TPU!). The easiest way to enable it when training a Keras model is to pass the argument `jit_compile=True` to `model.compile()`. If you don\u2019t get any errors and performance is good, that\u2019s a great sign that you\u2019re ready to move to TPU!\n\nDebugging on TPU is generally a bit harder than on CPU/GPU, so we recommend getting your code running on CPU/GPU with XLA first before trying it on TPU. You don\u2019t have to train for long, of course - just for a few steps to make sure that your model and data pipeline are working like you expect them to.\n\n<Tip>\n\nXLA compiled code is usually faster - so even if you\u2019re not planning to run on TPU, adding `jit_compile=True` can improve your performance. Be sure to note the caveats below about XLA compatibility, though!\n\n</Tip>\n\n<Tip warning={true}>\n\n**Tip born of painful experience:** Although using `jit_compile=True` is a good way to get a speed boost and test if your CPU/GPU code is XLA-compatible, it can actually cause a lot of problems if you leave it in when actually training on TPU. XLA compilation will happen implicitly on TPU, so remember to remove that line before actually running your code on a TPU!\n\n</Tip>\n\n### How do I make my model XLA compatible?\n\nIn many cases, your code is probably XLA-compatible already! However, there are a few things that work in normal TensorFlow that don\u2019t work in XLA. We\u2019ve distilled them into three core rules below:\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** We\u2019ve put a lot of effort into rewriting our TensorFlow models and loss functions to be XLA-compatible. Our models and loss functions generally obey rule #1 and #2 by default, so you can skip over them if you\u2019re using `transformers` models. Don\u2019t forget about these rules when writing your own models and loss functions, though!\n\n</Tip>\n\n#### XLA Rule #1: Your code cannot have \u201cdata-dependent conditionals\u201d\n\nWhat that means is that any `if` statement cannot depend on values inside a `tf.Tensor`. For example, this code block cannot be compiled with XLA!\n\n```python\nif tf.reduce_sum(tensor) > 10:\n    tensor = tensor / 2.0\n```\n\nThis might seem very restrictive at first, but most neural net code doesn\u2019t need to do this. You can often get around this restriction by using `tf.cond` (see the documentation [here](https://www.tensorflow.org/api_docs/python/tf/cond)) or by removing the conditional and finding a clever math trick with indicator variables instead, like so:\n\n```python\nsum_over_10 = tf.cast(tf.reduce_sum(tensor) > 10, tf.float32)\ntensor = tensor / (1.0 + sum_over_10)\n```\n\nThis code has exactly the same effect as the code above, but by avoiding a conditional, we ensure it will compile with XLA without problems!\n\n#### XLA Rule #2: Your code cannot have \u201cdata-dependent shapes\u201d\n\nWhat this means is that the shape of all of the `tf.Tensor` objects in your code cannot depend on their values. For example, the function `tf.unique` cannot be compiled with XLA, because it returns a `tensor` containing one instance of each unique value in the input. The shape of this output will obviously be different depending on how repetitive the input `Tensor` was, and so XLA refuses to handle it!\n\nIn general, most neural network code obeys rule #2 by default. However, there are a few common cases where it becomes a problem. One very common one is when you use **label masking**, setting your labels to a negative value to indicate that those positions should be ignored when computing the loss. If you look at NumPy or PyTorch loss functions that support label masking, you will often see code like this that uses [boolean indexing](https://numpy.org/doc/stable/user/basics.indexing.html#boolean-array-indexing):\n\n```python\nlabel_mask = labels >= 0\nmasked_outputs = outputs[label_mask]\nmasked_labels = labels[label_mask]\nloss = compute_loss(masked_outputs, masked_labels)\nmean_loss = torch.mean(loss)\n```\n\nThis code is totally fine in NumPy or PyTorch, but it breaks in XLA! Why? Because the shape of `masked_outputs` and `masked_labels` depends on how many positions are masked - that makes it a **data-dependent shape.** However, just like for rule #1, we can often rewrite this code to yield exactly the same output without any data-dependent shapes.\n\n```python\nlabel_mask = tf.cast(labels >= 0, tf.float32)\nloss = compute_loss(outputs, labels)\nloss = loss * label_mask  # Set negative label positions to 0\nmean_loss = tf.reduce_sum(loss) / tf.reduce_sum(label_mask)\n```\n\nHere, we avoid data-dependent shapes by computing the loss for every position, but zeroing out the masked positions in both the numerator and denominator when we calculate the mean, which yields exactly the same result as the first block while maintaining XLA compatibility. Note that we use the same trick as in rule #1 - converting a `tf.bool` to `\n2,\tlabel_mask  # Set negative label positions to 0\nmean_loss = tf.reduce_sum(loss) / tf.reduce_sum(label_mask)\n```\n\nHere, we avoid data-dependent shapes by computing the loss for every position, but zeroing out the masked positions in both the numerator and denominator when we calculate the mean, which yields exactly the same result as the first block while maintaining XLA compatibility. Note that we use the same trick as in rule #1 - converting a `tf.bool` to `tf.float32` and using it as an indicator variable. This is a really useful trick, so remember it if you need to convert your own code to XLA!\n\n#### XLA Rule #3: XLA will need to recompile your model for every different input shape it sees\n\nThis is the big one. What this means is that if your input shapes are very variable, XLA will have to recompile your model over and over, which will create huge performance problems. This commonly arises in NLP models, where input texts have variable lengths after tokenization. In other modalities, static shapes are more common and this rule is much less of a problem.\n\nHow can you get around rule #3? The key is **padding** - if you pad all your inputs to the same length, and then use an `attention_mask`, you can get the same results as you\u2019d get from variable shapes, but without any XLA issues. However, excessive padding can cause severe slowdown too - if you pad all your samples to the maximum length in the whole dataset, you might end up with batches consisting endless padding tokens, which will waste a lot of compute and memory!\n\nThere isn\u2019t a perfect solution to this problem. However, you can try some tricks. One very useful trick is to **pad batches of samples up to a multiple of a number like 32 or 64 tokens.** This often only increases the number of tokens by a small amount, but it hugely reduces the number of unique input shapes, because every input shape now has to be a multiple of 32 or 64. Fewer unique input shapes means fewer XLA compilations!\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** Our tokenizers and data collators have methods that can help you here. You can use `padding=\"max_length\"` or `padding=\"longest\"` when calling tokenizers to get them to output padded data. Our tokenizers and data collators also have a `pad_to_multiple_of` argument that you can use to reduce the number of unique input shapes you see!\n\n</Tip>\n\n### How do I actually train my model on TPU?\n\nOnce your training is XLA-compatible and (if you\u2019re using TPU Node / Colab) your dataset has been prepared appropriately, running on TPU is surprisingly easy! All you really need to change in your code is to add a few lines to initialize your TPU, and to ensure that your model and dataset are created inside a `TPUStrategy` scope. Take a look at [our TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) to see this in action!\n\n### Summary\n\nThere was a lot in here, so let\u2019s summarize with a quick checklist you can follow when you want to get your model ready for TPU training:\n\n- Make sure your code follows the three rules of XLA\n- Compile your model with `jit_compile=True` on CPU/GPU and confirm that you can train it with XLA\n- Either load your dataset into memory or use a TPU-compatible dataset loading approach (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Migrate your code either to Colab (with accelerator set to \u201cTPU\u201d) or a TPU VM on Google Cloud\n- Add TPU initializer code (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Create your `TPUStrategy` and make sure dataset loading and model creation are inside the `strategy.scope()` (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Don\u2019t forget to take `jit_compile=True` out again when you move to TPU!\n- \ud83d\ude4f\ud83d\ude4f\ud83d\ude4f\ud83e\udd7a\ud83e\udd7a\ud83e\udd7a\n- Call model.fit()\n- You did it!\n3,\t!--Copyright 2023 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\nthe License. You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under the License is distributed on\nan \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n\n\u26a0\ufe0f Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be\nrendered properly in your Markdown viewer.\n\n-->\n\n# Training on TPU with TensorFlow\n\n<Tip>\n\nIf you don't need long explanations and just want TPU code samples to get started with, check out [our TPU example notebook!](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb)\n\n</Tip>\n\n### What is a TPU?\n\nA TPU is a **Tensor Processing Unit.** They are hardware designed by Google, which are used to greatly speed up the tensor computations within neural networks, much like GPUs. They can be used for both network training and inference. They are generally accessed through Google\u2019s cloud services, but small TPUs can also be accessed directly for free through Google Colab and Kaggle Kernels.\n\nBecause [all TensorFlow models in \ud83e\udd17 Transformers are Keras models](https://huggingface.co/blog/tensorflow-philosophy), most of the methods in this document are generally applicable to TPU training for any Keras model! However, there are a few points that are specific to the HuggingFace ecosystem (hug-o-system?) of Transformers and Datasets, and we\u2019ll make sure to flag them up when we get to them.\n\n### What kinds of TPU are available?\n\nNew users are often very confused by the range of TPUs, and the different ways to access them. The first key distinction to understand is the difference between **TPU Nodes** and **TPU VMs.**\n\nWhen you use a **TPU Node**, you are effectively indirectly accessing a remote TPU. You will need a separate VM, which will initialize your network and data pipeline and then forward them to the remote node. When you use a TPU on Google Colab, you are accessing it in the **TPU Node** style.\n\nUsing TPU Nodes can have some quite unexpected behaviour for people who aren\u2019t used to them! In particular, because the TPU is located on a physically different system to the machine you\u2019re running your Python code on, your data cannot be local to your machine - any data pipeline that loads from your machine\u2019s internal storage will totally fail! Instead, data must be stored in Google Cloud Storage where your data pipeline can still access it, even when the pipeline is running on the remote TPU node.\n\n<Tip>\n\nIf you can fit all your data in memory as `np.ndarray` or `tf.Tensor`, then you can `fit()` on that data even when using Colab or a TPU Node, without needing to upload it to Google Cloud Storage.\n\n</Tip>\n\n<Tip>\n\n**\ud83e\udd17Specific Hugging Face Tip\ud83e\udd17:** The methods `Dataset.to_tf_dataset()` and its higher-level wrapper `model.prepare_tf_dataset()` , which you will see throughout our TF code examples, will both fail on a TPU Node. The reason for this is that even though they create a `tf.data.Dataset` it is not a \u201cpure\u201d `tf.data` pipeline and uses `tf.numpy_function` or `Dataset.from_generator()` to stream data from the underlying HuggingFace `Dataset`. This HuggingFace `Dataset` is backed by data that is on a local disc and which the remote TPU Node will not be able to read.\n\n</Tip>\n\nThe second way to access a TPU is via a **TPU VM.** When using a TPU VM, you connect directly to the machine that the TPU is attached to, much like training on a GPU VM. TPU VMs are generally easier to work with, particularly when it comes to your data pipeline. All of the above warnings do not apply to TPU VMs!\n\nThis is an opinionated document, so here\u2019s our opinion: **Avoid using TPU Node if possible.** It is more confusing and more difficult to debug than TPU VMs. It is also likely to be unsupported in future - Google\u2019s latest TPU, TPUv4, can only be accessed as a TPU VM, which suggests that TPU Nodes are increasingly going to become a \u201clegacy\u201d access method. However, we understand that the only free TPU access is on Colab and Kaggle Kernels, which uses TPU Node - so we\u2019ll try to explain how to handle it if you have to! Check the [TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) for code samples that explain this in more detail.\n\n### What sizes of TPU are available?\n\nA single TPU (a v2-8/v3-8/v4-8) runs 8 replicas. TPUs exist in **pods** that can run hundreds or thousands of replicas simultaneously. When you use more than a single TPU but less than a whole pod (for example, a v3-32), your TPU fleet is referred to as a **pod slice.**\n\nWhen you access a free TPU via Colab, you generally get a single v2-8 TPU.\n\n### I keep hearing about this XLA thing. What\u2019s XLA, and how does it relate to TPUs?\n\nXLA is an optimizing compiler, used by both TensorFlow and JAX. In JAX it is the only compiler, whereas in TensorFlow it is optional\n    ```",
            "vector_context": "[Created at: 2025-03-24 13:17:32]\n!--Copyright 2023 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\nthe License. You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under the License is distributed on\nan \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n\n\u26a0\ufe0f Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be\nrendered properly in your Markdown viewer.\n\n-->\n\n# Training on TPU with TensorFlow\n\n<Tip>\n\nIf you don't need long explanations and just want TPU code samples to get started with, check out [our TPU example notebook!](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb)\n\n</Tip>\n\n### What is a TPU?\n\nA TPU is a **Tensor Processing Unit.** They are hardware designed by Google, which are used to greatly speed up the tensor computations within neural networks, much like GPUs. They can be used for both network training and inference. They are generally accessed through Google\u2019s cloud services, but small TPUs can also be accessed directly for free through Google Colab and Kaggle Kernels.\n\nBecause [all TensorFlow models in \ud83e\udd17 Transformers are Keras models](https://huggingface.co/blog/tensorflow-philosophy), most of the methods in this document are generally applicable to TPU training for any Keras model! However, there are a few points that are specific to the HuggingFace ecosystem (hug-o-system?) of Transformers and Datasets, and we\u2019ll make sure to flag them up when we get to them.\n\n### What kinds of TPU are available?\n\nNew users are often very confused by the range of TPUs, and the different ways to access them. The first key distinction to understand is the difference between **TPU Nodes** and **TPU VMs.**\n\nWhen you use a **TPU Node**, you are effectively indirectly accessing a remote TPU. You will need a separate VM, which will initialize your network and data pipeline and then forward them to the remote node. When you use a TPU on Google Colab, you are accessing it in the **TPU Node** style.\n\nUsing TPU Nodes can have some quite unexpected behaviour for people who aren\u2019t used to them! In particular, because the TPU is located on a physically different system to the machine you\u2019re running your Python code on, your data cannot be local to your machine - any data pipeline that loads from your machine\u2019s internal storage will totally fail! Instead, data must be stored in Google Cloud Storage where your data pipeline can still access it, even when the pipeline is running on the remote TPU node.\n\n<Tip>\n\nIf you can fit all your data in memory as `np.ndarray` or `tf.Tensor`, then you can `fit()` on that data even when using Colab or a TPU Node, without needing to upload it to Google Cloud Storage.\n\n</Tip>\n\n<Tip>\n\n**\ud83e\udd17Specific Hugging Face Tip\ud83e\udd17:** The methods `Dataset.to_tf_dataset()` and its higher-level wrapper `model.prepare_tf_dataset()` , which you will see throughout our TF code examples, will both fail on a TPU Node. The reason for this is that even though they create a `tf.data.Dataset` it is not a \u201cpure\u201d `tf.data` pipeline and uses `tf.numpy_function` or `Dataset.from_generator()` to stream data from the underlying HuggingFace `Dataset`. This HuggingFace `Dataset` is backed by data that is on a local disc and which the remote TPU Node will not be able to read.\n\n</Tip>\n\nThe second way to access a TPU is via a **TPU VM.** When using a TPU VM, you connect directly to the machine that the TPU is attached to, much like training on a GPU VM. TPU VMs are generally easier to work with, particularly when it comes to your data pipeline. All of the above warnings do not apply to TPU VMs!\n\nThis is an opinionated document, so here\u2019s our opinion: **Avoid using TPU Node if possible.** It is more confusing and more difficult to debug than TPU VMs. It is also likely to be unsupported in future - Google\u2019s latest TPU, TPUv4, can only be accessed as a TPU VM, which suggests that TPU Nodes are increasingly going to become a \u201clegacy\u201d access method. However, we understand that the only free TPU access is on Colab and Kaggle Kernels, which uses TPU Node - so we\u2019ll try to explain how to handle it if you have to! Check the [TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) for code samples that explain this in more detail.\n\n### What sizes of TPU are available?\n\nA single TPU (a v2-8/v3-8/v4-8) runs 8 replicas. TPUs exist in **pods** that can run hundreds or thousands of replicas simultaneously. When you use more than a single TPU but less than a whole pod (for example, a v3-32), your TPU fleet is referred to as a **pod slice.**\n\nWhen you access a free TPU via Colab, you generally get a single v2-8 TPU.\n\n### I keep hearing about this XLA thing. What\u2019s XLA, and how does it relate to TPUs?\n\nXLA is an optimizing compiler, used by both TensorFlow and JAX. In JAX it is the only compiler, whereas in TensorFlow it is optional\n--New Chunk--\n[Created at: 2025-03-24 13:17:32]\n(for example, a v3-32), your TPU fleet is referred to as a **pod slice.**\n\nWhen you access a free TPU via Colab, you generally get a single v2-8 TPU.\n\n### I keep hearing about this XLA thing. What\u2019s XLA, and how does it relate to TPUs?\n\nXLA is an optimizing compiler, used by both TensorFlow and JAX. In JAX it is the only compiler, whereas in TensorFlow it is optional (but mandatory on TPU!). The easiest way to enable it when training a Keras model is to pass the argument `jit_compile=True` to `model.compile()`. If you don\u2019t get any errors and performance is good, that\u2019s a great sign that you\u2019re ready to move to TPU!\n\nDebugging on TPU is generally a bit harder than on CPU/GPU, so we recommend getting your code running on CPU/GPU with XLA first before trying it on TPU. You don\u2019t have to train for long, of course - just for a few steps to make sure that your model and data pipeline are working like you expect them to.\n\n<Tip>\n\nXLA compiled code is usually faster - so even if you\u2019re not planning to run on TPU, adding `jit_compile=True` can improve your performance. Be sure to note the caveats below about XLA compatibility, though!\n\n</Tip>\n\n<Tip warning={true}>\n\n**Tip born of painful experience:** Although using `jit_compile=True` is a good way to get a speed boost and test if your CPU/GPU code is XLA-compatible, it can actually cause a lot of problems if you leave it in when actually training on TPU. XLA compilation will happen implicitly on TPU, so remember to remove that line before actually running your code on a TPU!\n\n</Tip>\n\n### How do I make my model XLA compatible?\n\nIn many cases, your code is probably XLA-compatible already! However, there are a few things that work in normal TensorFlow that don\u2019t work in XLA. We\u2019ve distilled them into three core rules below:\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** We\u2019ve put a lot of effort into rewriting our TensorFlow models and loss functions to be XLA-compatible. Our models and loss functions generally obey rule #1 and #2 by default, so you can skip over them if you\u2019re using `transformers` models. Don\u2019t forget about these rules when writing your own models and loss functions, though!\n\n</Tip>\n\n#### XLA Rule #1: Your code cannot have \u201cdata-dependent conditionals\u201d\n\nWhat that means is that any `if` statement cannot depend on values inside a `tf.Tensor`. For example, this code block cannot be compiled with XLA!\n\n```python\nif tf.reduce_sum(tensor) > 10:\n    tensor = tensor / 2.0\n```\n\nThis might seem very restrictive at first, but most neural net code doesn\u2019t need to do this. You can often get around this restriction by using `tf.cond` (see the documentation [here](https://www.tensorflow.org/api_docs/python/tf/cond)) or by removing the conditional and finding a clever math trick with indicator variables instead, like so:\n\n```python\nsum_over_10 = tf.cast(tf.reduce_sum(tensor) > 10, tf.float32)\ntensor = tensor / (1.0 + sum_over_10)\n```\n\nThis code has exactly the same effect as the code above, but by avoiding a conditional, we ensure it will compile with XLA without problems!\n\n#### XLA Rule #2: Your code cannot have \u201cdata-dependent shapes\u201d\n\nWhat this means is that the shape of all of the `tf.Tensor` objects in your code cannot depend on their values. For example, the function `tf.unique` cannot be compiled with XLA, because it returns a `tensor` containing one instance of each unique value in the input. The shape of this output will obviously be different depending on how repetitive the input `Tensor` was, and so XLA refuses to handle it!\n\nIn general, most neural network code obeys rule #2 by default. However, there are a few common cases where it becomes a problem. One very common one is when you use **label masking**, setting your labels to a negative value to indicate that those positions should be ignored when computing the loss. If you look at NumPy or PyTorch loss functions that support label masking, you will often see code like this that uses [boolean indexing](https://numpy.org/doc/stable/user/basics.indexing.html#boolean-array-indexing):\n\n```python\nlabel_mask = labels >= 0\nmasked_outputs = outputs[label_mask]\nmasked_labels = labels[label_mask]\nloss = compute_loss(masked_outputs, masked_labels)\nmean_loss = torch.mean(loss)\n```\n\nThis code is totally fine in NumPy or PyTorch, but it breaks in XLA! Why? Because the shape of `masked_outputs` and `masked_labels` depends on how many positions are masked - that makes it a **data-dependent shape.** However, just like for rule #1, we can often rewrite this code to yield exactly the same output without any data-dependent shapes.\n\n```python\nlabel_mask = tf.cast(labels >= 0, tf.float32)\nloss = compute_loss(outputs, labels)\nloss = loss * label_mask  # Set negative label positions to 0\nmean_loss = tf.reduce_sum(loss) / tf.reduce_sum(label_mask)\n```\n\nHere, we avoid data-dependent shapes by computing the loss for every position, but zeroing out the masked positions in both the numerator and denominator when we calculate the mean, which yields exactly the same result as the first block while maintaining XLA compatibility. Note that we use the same trick as in rule #1 - converting a `tf.bool` to `\n--New Chunk--\n[Created at: 2025-03-24 13:17:32]\nlabel_mask  # Set negative label positions to 0\nmean_loss = tf.reduce_sum(loss) / tf.reduce_sum(label_mask)\n```\n\nHere, we avoid data-dependent shapes by computing the loss for every position, but zeroing out the masked positions in both the numerator and denominator when we calculate the mean, which yields exactly the same result as the first block while maintaining XLA compatibility. Note that we use the same trick as in rule #1 - converting a `tf.bool` to `tf.float32` and using it as an indicator variable. This is a really useful trick, so remember it if you need to convert your own code to XLA!\n\n#### XLA Rule #3: XLA will need to recompile your model for every different input shape it sees\n\nThis is the big one. What this means is that if your input shapes are very variable, XLA will have to recompile your model over and over, which will create huge performance problems. This commonly arises in NLP models, where input texts have variable lengths after tokenization. In other modalities, static shapes are more common and this rule is much less of a problem.\n\nHow can you get around rule #3? The key is **padding** - if you pad all your inputs to the same length, and then use an `attention_mask`, you can get the same results as you\u2019d get from variable shapes, but without any XLA issues. However, excessive padding can cause severe slowdown too - if you pad all your samples to the maximum length in the whole dataset, you might end up with batches consisting endless padding tokens, which will waste a lot of compute and memory!\n\nThere isn\u2019t a perfect solution to this problem. However, you can try some tricks. One very useful trick is to **pad batches of samples up to a multiple of a number like 32 or 64 tokens.** This often only increases the number of tokens by a small amount, but it hugely reduces the number of unique input shapes, because every input shape now has to be a multiple of 32 or 64. Fewer unique input shapes means fewer XLA compilations!\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** Our tokenizers and data collators have methods that can help you here. You can use `padding=\"max_length\"` or `padding=\"longest\"` when calling tokenizers to get them to output padded data. Our tokenizers and data collators also have a `pad_to_multiple_of` argument that you can use to reduce the number of unique input shapes you see!\n\n</Tip>\n\n### How do I actually train my model on TPU?\n\nOnce your training is XLA-compatible and (if you\u2019re using TPU Node / Colab) your dataset has been prepared appropriately, running on TPU is surprisingly easy! All you really need to change in your code is to add a few lines to initialize your TPU, and to ensure that your model and dataset are created inside a `TPUStrategy` scope. Take a look at [our TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) to see this in action!\n\n### Summary\n\nThere was a lot in here, so let\u2019s summarize with a quick checklist you can follow when you want to get your model ready for TPU training:\n\n- Make sure your code follows the three rules of XLA\n- Compile your model with `jit_compile=True` on CPU/GPU and confirm that you can train it with XLA\n- Either load your dataset into memory or use a TPU-compatible dataset loading approach (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Migrate your code either to Colab (with accelerator set to \u201cTPU\u201d) or a TPU VM on Google Cloud\n- Add TPU initializer code (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Create your `TPUStrategy` and make sure dataset loading and model creation are inside the `strategy.scope()` (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Don\u2019t forget to take `jit_compile=True` out again when you move to TPU!\n- \ud83d\ude4f\ud83d\ude4f\ud83d\ude4f\ud83e\udd7a\ud83e\udd7a\ud83e\udd7a\n- Call model.fit()\n- You did it!"
        }
    },
    {
        "sample_idx": 82,
        "question": "What should you do with jit_compile=True when moving to TPU?",
        "answer": "Take it out.",
        "rag_answer": "When moving to TPU, you should **",
        "rag_score": null,
        "rag_feedback": null,
        "rag_context": {
            "kg_context": "-----Entities-----\n    ```csv\n    id,\tentity,\ttype,\tdescription,\trankcreated_at\n1,\tTPU,technology,TPU is a Tensor Processing Unit, a hardware designed by Google to speed up tensor computations within neural networks.<SEP>TPU is a type of hardware accelerator designed for machine learning workloads.<SEP>TPU is a type of hardware accelerator used for machine learning computations.,4,2025-03-24 13:18:20\n2,\tXLA,technology,XLA is a technology that compiles TensorFlow graphs into executable code for various platforms.<SEP>XLA is an optimizing compiler used by TensorFlow and JAX to improve performance.<SEP>XLA is an optimizing compiler, used by both TensorFlow and JAX to optimize computations.,6,2025-03-24 13:18:20\n3,\tGoogle,organization,Google is the company that designs and provides TPUs, which are used to speed up tensor computations within neural networks.,3,2025-03-24 13:18:20\n4,\tColab,geo,Colab is a cloud-based platform for data science and machine learning, provided by Google.<SEP>Colab is a platform where users can access a free TPU.,3,2025-03-24 13:18:20\n5,\tjit_compile,concept,jit_compile is a technique for compiling TensorFlow graphs into executable code.,1,UNKNOWN\n6,\tTPU,technology,TPU is a Tensor Processing Unit, a hardware designed by Google to speed up tensor computations within neural networks.<SEP>TPU is a type of hardware accelerator designed for machine learning workloads.<SEP>TPU is a type of hardware accelerator used for machine learning computations.,4,UNKNOWN\n7,\tGoogle,organization,Google is the company that designs and provides TPUs, which are used to speed up tensor computations within neural networks.,3,UNKNOWN\n    ```\n    -----Relationships-----\n    ```csv\n    id,\tsource,\ttarget,\tdescription,\tkeywords,\tweight,\trank,\tcreated_at\n1,\tTPU,XLA,XLA compiles TensorFlow graphs into executable code for TPU hardware.<SEP>XLA is used to optimize code for TPU hardware.,compilation, hardware acceleration<SEP>compiler, hardware optimization,36.0,10,2025-03-24 13:18:20\n2,\tGoogle,TPU,Google designs and provides TPUs, which are used to speed up tensor computations within neural networks.,hardware design, acceleration,18.0,7,2025-03-24 13:18:20\n3,\tColab,TPU,Colab provides access to a free TPU for users.,platform, hardware acceleration,16.0,7,2025-03-24 13:18:20\n4,\tTPU,XLA,XLA compiles TensorFlow graphs into executable code for TPU hardware.<SEP>XLA is used to optimize code for TPU hardware.,compilation, hardware acceleration<SEP>compiler, hardware optimization,36.0,10,UNKNOWN\n5,\tGoogle,TPU,Google designs and provides TPUs, which are used to speed up tensor computations within neural networks.,hardware design, acceleration,18.0,7,UNKNOWN\n6,\tColab,TPU,Colab provides access to a free TPU for users.,platform, hardware acceleration,16.0,7,UNKNOWN\n7,\tXLA,jit_compile,jit_compile is a technique used in XLA to compile TensorFlow graphs into executable code.,compilation technique, XLA support,3.0,7,UNKNOWN\n8,\tColab,Google,Colab is a cloud-based platform provided by Google for data science and machine learning.,platform provision, cloud computing,16.0,6,UNKNOWN\n9,\tGoogle Cloud,TPU,Google Cloud provides infrastructure and services for building and deploying machine learning models, including TPU hardware.,infrastructure provision, hardware acceleration,14.0,5,UNKNOWN\n10,\tGoogle,Kaggle Kernels,Kaggle Kernels is a cloud-based platform provided by Google for data science and machine learning competitions.,platform provision, cloud computing,16.0,4,UNKNOWN\n    ```\n    -----Sources-----\n    ```csv\n    id,\tcontent\n1,\t(for example, a v3-32), your TPU fleet is referred to as a **pod slice.**\n\nWhen you access a free TPU via Colab, you generally get a single v2-8 TPU.\n\n### I keep hearing about this XLA thing. What\u2019s XLA, and how does it relate to TPUs?\n\nXLA is an optimizing compiler, used by both TensorFlow and JAX. In JAX it is the only compiler, whereas in TensorFlow it is optional (but mandatory on TPU!). The easiest way to enable it when training a Keras model is to pass the argument `jit_compile=True` to `model.compile()`. If you don\u2019t get any errors and performance is good, that\u2019s a great sign that you\u2019re ready to move to TPU!\n\nDebugging on TPU is generally a bit harder than on CPU/GPU, so we recommend getting your code running on CPU/GPU with XLA first before trying it on TPU. You don\u2019t have to train for long, of course - just for a few steps to make sure that your model and data pipeline are working like you expect them to.\n\n<Tip>\n\nXLA compiled code is usually faster - so even if you\u2019re not planning to run on TPU, adding `jit_compile=True` can improve your performance. Be sure to note the caveats below about XLA compatibility, though!\n\n</Tip>\n\n<Tip warning={true}>\n\n**Tip born of painful experience:** Although using `jit_compile=True` is a good way to get a speed boost and test if your CPU/GPU code is XLA-compatible, it can actually cause a lot of problems if you leave it in when actually training on TPU. XLA compilation will happen implicitly on TPU, so remember to remove that line before actually running your code on a TPU!\n\n</Tip>\n\n### How do I make my model XLA compatible?\n\nIn many cases, your code is probably XLA-compatible already! However, there are a few things that work in normal TensorFlow that don\u2019t work in XLA. We\u2019ve distilled them into three core rules below:\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** We\u2019ve put a lot of effort into rewriting our TensorFlow models and loss functions to be XLA-compatible. Our models and loss functions generally obey rule #1 and #2 by default, so you can skip over them if you\u2019re using `transformers` models. Don\u2019t forget about these rules when writing your own models and loss functions, though!\n\n</Tip>\n\n#### XLA Rule #1: Your code cannot have \u201cdata-dependent conditionals\u201d\n\nWhat that means is that any `if` statement cannot depend on values inside a `tf.Tensor`. For example, this code block cannot be compiled with XLA!\n\n```python\nif tf.reduce_sum(tensor) > 10:\n    tensor = tensor / 2.0\n```\n\nThis might seem very restrictive at first, but most neural net code doesn\u2019t need to do this. You can often get around this restriction by using `tf.cond` (see the documentation [here](https://www.tensorflow.org/api_docs/python/tf/cond)) or by removing the conditional and finding a clever math trick with indicator variables instead, like so:\n\n```python\nsum_over_10 = tf.cast(tf.reduce_sum(tensor) > 10, tf.float32)\ntensor = tensor / (1.0 + sum_over_10)\n```\n\nThis code has exactly the same effect as the code above, but by avoiding a conditional, we ensure it will compile with XLA without problems!\n\n#### XLA Rule #2: Your code cannot have \u201cdata-dependent shapes\u201d\n\nWhat this means is that the shape of all of the `tf.Tensor` objects in your code cannot depend on their values. For example, the function `tf.unique` cannot be compiled with XLA, because it returns a `tensor` containing one instance of each unique value in the input. The shape of this output will obviously be different depending on how repetitive the input `Tensor` was, and so XLA refuses to handle it!\n\nIn general, most neural network code obeys rule #2 by default. However, there are a few common cases where it becomes a problem. One very common one is when you use **label masking**, setting your labels to a negative value to indicate that those positions should be ignored when computing the loss. If you look at NumPy or PyTorch loss functions that support label masking, you will often see code like this that uses [boolean indexing](https://numpy.org/doc/stable/user/basics.indexing.html#boolean-array-indexing):\n\n```python\nlabel_mask = labels >= 0\nmasked_outputs = outputs[label_mask]\nmasked_labels = labels[label_mask]\nloss = compute_loss(masked_outputs, masked_labels)\nmean_loss = torch.mean(loss)\n```\n\nThis code is totally fine in NumPy or PyTorch, but it breaks in XLA! Why? Because the shape of `masked_outputs` and `masked_labels` depends on how many positions are masked - that makes it a **data-dependent shape.** However, just like for rule #1, we can often rewrite this code to yield exactly the same output without any data-dependent shapes.\n\n```python\nlabel_mask = tf.cast(labels >= 0, tf.float32)\nloss = compute_loss(outputs, labels)\nloss = loss * label_mask  # Set negative label positions to 0\nmean_loss = tf.reduce_sum(loss) / tf.reduce_sum(label_mask)\n```\n\nHere, we avoid data-dependent shapes by computing the loss for every position, but zeroing out the masked positions in both the numerator and denominator when we calculate the mean, which yields exactly the same result as the first block while maintaining XLA compatibility. Note that we use the same trick as in rule #1 - converting a `tf.bool` to `\n2,\tlabel_mask  # Set negative label positions to 0\nmean_loss = tf.reduce_sum(loss) / tf.reduce_sum(label_mask)\n```\n\nHere, we avoid data-dependent shapes by computing the loss for every position, but zeroing out the masked positions in both the numerator and denominator when we calculate the mean, which yields exactly the same result as the first block while maintaining XLA compatibility. Note that we use the same trick as in rule #1 - converting a `tf.bool` to `tf.float32` and using it as an indicator variable. This is a really useful trick, so remember it if you need to convert your own code to XLA!\n\n#### XLA Rule #3: XLA will need to recompile your model for every different input shape it sees\n\nThis is the big one. What this means is that if your input shapes are very variable, XLA will have to recompile your model over and over, which will create huge performance problems. This commonly arises in NLP models, where input texts have variable lengths after tokenization. In other modalities, static shapes are more common and this rule is much less of a problem.\n\nHow can you get around rule #3? The key is **padding** - if you pad all your inputs to the same length, and then use an `attention_mask`, you can get the same results as you\u2019d get from variable shapes, but without any XLA issues. However, excessive padding can cause severe slowdown too - if you pad all your samples to the maximum length in the whole dataset, you might end up with batches consisting endless padding tokens, which will waste a lot of compute and memory!\n\nThere isn\u2019t a perfect solution to this problem. However, you can try some tricks. One very useful trick is to **pad batches of samples up to a multiple of a number like 32 or 64 tokens.** This often only increases the number of tokens by a small amount, but it hugely reduces the number of unique input shapes, because every input shape now has to be a multiple of 32 or 64. Fewer unique input shapes means fewer XLA compilations!\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** Our tokenizers and data collators have methods that can help you here. You can use `padding=\"max_length\"` or `padding=\"longest\"` when calling tokenizers to get them to output padded data. Our tokenizers and data collators also have a `pad_to_multiple_of` argument that you can use to reduce the number of unique input shapes you see!\n\n</Tip>\n\n### How do I actually train my model on TPU?\n\nOnce your training is XLA-compatible and (if you\u2019re using TPU Node / Colab) your dataset has been prepared appropriately, running on TPU is surprisingly easy! All you really need to change in your code is to add a few lines to initialize your TPU, and to ensure that your model and dataset are created inside a `TPUStrategy` scope. Take a look at [our TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) to see this in action!\n\n### Summary\n\nThere was a lot in here, so let\u2019s summarize with a quick checklist you can follow when you want to get your model ready for TPU training:\n\n- Make sure your code follows the three rules of XLA\n- Compile your model with `jit_compile=True` on CPU/GPU and confirm that you can train it with XLA\n- Either load your dataset into memory or use a TPU-compatible dataset loading approach (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Migrate your code either to Colab (with accelerator set to \u201cTPU\u201d) or a TPU VM on Google Cloud\n- Add TPU initializer code (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Create your `TPUStrategy` and make sure dataset loading and model creation are inside the `strategy.scope()` (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Don\u2019t forget to take `jit_compile=True` out again when you move to TPU!\n- \ud83d\ude4f\ud83d\ude4f\ud83d\ude4f\ud83e\udd7a\ud83e\udd7a\ud83e\udd7a\n- Call model.fit()\n- You did it!\n3,\t!--Copyright 2023 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\nthe License. You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under the License is distributed on\nan \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n\n\u26a0\ufe0f Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be\nrendered properly in your Markdown viewer.\n\n-->\n\n# Training on TPU with TensorFlow\n\n<Tip>\n\nIf you don't need long explanations and just want TPU code samples to get started with, check out [our TPU example notebook!](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb)\n\n</Tip>\n\n### What is a TPU?\n\nA TPU is a **Tensor Processing Unit.** They are hardware designed by Google, which are used to greatly speed up the tensor computations within neural networks, much like GPUs. They can be used for both network training and inference. They are generally accessed through Google\u2019s cloud services, but small TPUs can also be accessed directly for free through Google Colab and Kaggle Kernels.\n\nBecause [all TensorFlow models in \ud83e\udd17 Transformers are Keras models](https://huggingface.co/blog/tensorflow-philosophy), most of the methods in this document are generally applicable to TPU training for any Keras model! However, there are a few points that are specific to the HuggingFace ecosystem (hug-o-system?) of Transformers and Datasets, and we\u2019ll make sure to flag them up when we get to them.\n\n### What kinds of TPU are available?\n\nNew users are often very confused by the range of TPUs, and the different ways to access them. The first key distinction to understand is the difference between **TPU Nodes** and **TPU VMs.**\n\nWhen you use a **TPU Node**, you are effectively indirectly accessing a remote TPU. You will need a separate VM, which will initialize your network and data pipeline and then forward them to the remote node. When you use a TPU on Google Colab, you are accessing it in the **TPU Node** style.\n\nUsing TPU Nodes can have some quite unexpected behaviour for people who aren\u2019t used to them! In particular, because the TPU is located on a physically different system to the machine you\u2019re running your Python code on, your data cannot be local to your machine - any data pipeline that loads from your machine\u2019s internal storage will totally fail! Instead, data must be stored in Google Cloud Storage where your data pipeline can still access it, even when the pipeline is running on the remote TPU node.\n\n<Tip>\n\nIf you can fit all your data in memory as `np.ndarray` or `tf.Tensor`, then you can `fit()` on that data even when using Colab or a TPU Node, without needing to upload it to Google Cloud Storage.\n\n</Tip>\n\n<Tip>\n\n**\ud83e\udd17Specific Hugging Face Tip\ud83e\udd17:** The methods `Dataset.to_tf_dataset()` and its higher-level wrapper `model.prepare_tf_dataset()` , which you will see throughout our TF code examples, will both fail on a TPU Node. The reason for this is that even though they create a `tf.data.Dataset` it is not a \u201cpure\u201d `tf.data` pipeline and uses `tf.numpy_function` or `Dataset.from_generator()` to stream data from the underlying HuggingFace `Dataset`. This HuggingFace `Dataset` is backed by data that is on a local disc and which the remote TPU Node will not be able to read.\n\n</Tip>\n\nThe second way to access a TPU is via a **TPU VM.** When using a TPU VM, you connect directly to the machine that the TPU is attached to, much like training on a GPU VM. TPU VMs are generally easier to work with, particularly when it comes to your data pipeline. All of the above warnings do not apply to TPU VMs!\n\nThis is an opinionated document, so here\u2019s our opinion: **Avoid using TPU Node if possible.** It is more confusing and more difficult to debug than TPU VMs. It is also likely to be unsupported in future - Google\u2019s latest TPU, TPUv4, can only be accessed as a TPU VM, which suggests that TPU Nodes are increasingly going to become a \u201clegacy\u201d access method. However, we understand that the only free TPU access is on Colab and Kaggle Kernels, which uses TPU Node - so we\u2019ll try to explain how to handle it if you have to! Check the [TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) for code samples that explain this in more detail.\n\n### What sizes of TPU are available?\n\nA single TPU (a v2-8/v3-8/v4-8) runs 8 replicas. TPUs exist in **pods** that can run hundreds or thousands of replicas simultaneously. When you use more than a single TPU but less than a whole pod (for example, a v3-32), your TPU fleet is referred to as a **pod slice.**\n\nWhen you access a free TPU via Colab, you generally get a single v2-8 TPU.\n\n### I keep hearing about this XLA thing. What\u2019s XLA, and how does it relate to TPUs?\n\nXLA is an optimizing compiler, used by both TensorFlow and JAX. In JAX it is the only compiler, whereas in TensorFlow it is optional\n    ```",
            "vector_context": "[Created at: 2025-03-24 13:17:32]\n(for example, a v3-32), your TPU fleet is referred to as a **pod slice.**\n\nWhen you access a free TPU via Colab, you generally get a single v2-8 TPU.\n\n### I keep hearing about this XLA thing. What\u2019s XLA, and how does it relate to TPUs?\n\nXLA is an optimizing compiler, used by both TensorFlow and JAX. In JAX it is the only compiler, whereas in TensorFlow it is optional (but mandatory on TPU!). The easiest way to enable it when training a Keras model is to pass the argument `jit_compile=True` to `model.compile()`. If you don\u2019t get any errors and performance is good, that\u2019s a great sign that you\u2019re ready to move to TPU!\n\nDebugging on TPU is generally a bit harder than on CPU/GPU, so we recommend getting your code running on CPU/GPU with XLA first before trying it on TPU. You don\u2019t have to train for long, of course - just for a few steps to make sure that your model and data pipeline are working like you expect them to.\n\n<Tip>\n\nXLA compiled code is usually faster - so even if you\u2019re not planning to run on TPU, adding `jit_compile=True` can improve your performance. Be sure to note the caveats below about XLA compatibility, though!\n\n</Tip>\n\n<Tip warning={true}>\n\n**Tip born of painful experience:** Although using `jit_compile=True` is a good way to get a speed boost and test if your CPU/GPU code is XLA-compatible, it can actually cause a lot of problems if you leave it in when actually training on TPU. XLA compilation will happen implicitly on TPU, so remember to remove that line before actually running your code on a TPU!\n\n</Tip>\n\n### How do I make my model XLA compatible?\n\nIn many cases, your code is probably XLA-compatible already! However, there are a few things that work in normal TensorFlow that don\u2019t work in XLA. We\u2019ve distilled them into three core rules below:\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** We\u2019ve put a lot of effort into rewriting our TensorFlow models and loss functions to be XLA-compatible. Our models and loss functions generally obey rule #1 and #2 by default, so you can skip over them if you\u2019re using `transformers` models. Don\u2019t forget about these rules when writing your own models and loss functions, though!\n\n</Tip>\n\n#### XLA Rule #1: Your code cannot have \u201cdata-dependent conditionals\u201d\n\nWhat that means is that any `if` statement cannot depend on values inside a `tf.Tensor`. For example, this code block cannot be compiled with XLA!\n\n```python\nif tf.reduce_sum(tensor) > 10:\n    tensor = tensor / 2.0\n```\n\nThis might seem very restrictive at first, but most neural net code doesn\u2019t need to do this. You can often get around this restriction by using `tf.cond` (see the documentation [here](https://www.tensorflow.org/api_docs/python/tf/cond)) or by removing the conditional and finding a clever math trick with indicator variables instead, like so:\n\n```python\nsum_over_10 = tf.cast(tf.reduce_sum(tensor) > 10, tf.float32)\ntensor = tensor / (1.0 + sum_over_10)\n```\n\nThis code has exactly the same effect as the code above, but by avoiding a conditional, we ensure it will compile with XLA without problems!\n\n#### XLA Rule #2: Your code cannot have \u201cdata-dependent shapes\u201d\n\nWhat this means is that the shape of all of the `tf.Tensor` objects in your code cannot depend on their values. For example, the function `tf.unique` cannot be compiled with XLA, because it returns a `tensor` containing one instance of each unique value in the input. The shape of this output will obviously be different depending on how repetitive the input `Tensor` was, and so XLA refuses to handle it!\n\nIn general, most neural network code obeys rule #2 by default. However, there are a few common cases where it becomes a problem. One very common one is when you use **label masking**, setting your labels to a negative value to indicate that those positions should be ignored when computing the loss. If you look at NumPy or PyTorch loss functions that support label masking, you will often see code like this that uses [boolean indexing](https://numpy.org/doc/stable/user/basics.indexing.html#boolean-array-indexing):\n\n```python\nlabel_mask = labels >= 0\nmasked_outputs = outputs[label_mask]\nmasked_labels = labels[label_mask]\nloss = compute_loss(masked_outputs, masked_labels)\nmean_loss = torch.mean(loss)\n```\n\nThis code is totally fine in NumPy or PyTorch, but it breaks in XLA! Why? Because the shape of `masked_outputs` and `masked_labels` depends on how many positions are masked - that makes it a **data-dependent shape.** However, just like for rule #1, we can often rewrite this code to yield exactly the same output without any data-dependent shapes.\n\n```python\nlabel_mask = tf.cast(labels >= 0, tf.float32)\nloss = compute_loss(outputs, labels)\nloss = loss * label_mask  # Set negative label positions to 0\nmean_loss = tf.reduce_sum(loss) / tf.reduce_sum(label_mask)\n```\n\nHere, we avoid data-dependent shapes by computing the loss for every position, but zeroing out the masked positions in both the numerator and denominator when we calculate the mean, which yields exactly the same result as the first block while maintaining XLA compatibility. Note that we use the same trick as in rule #1 - converting a `tf.bool` to `\n--New Chunk--\n[Created at: 2025-03-24 13:17:32]\n!--Copyright 2023 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\nthe License. You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under the License is distributed on\nan \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n\n\u26a0\ufe0f Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be\nrendered properly in your Markdown viewer.\n\n-->\n\n# Training on TPU with TensorFlow\n\n<Tip>\n\nIf you don't need long explanations and just want TPU code samples to get started with, check out [our TPU example notebook!](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb)\n\n</Tip>\n\n### What is a TPU?\n\nA TPU is a **Tensor Processing Unit.** They are hardware designed by Google, which are used to greatly speed up the tensor computations within neural networks, much like GPUs. They can be used for both network training and inference. They are generally accessed through Google\u2019s cloud services, but small TPUs can also be accessed directly for free through Google Colab and Kaggle Kernels.\n\nBecause [all TensorFlow models in \ud83e\udd17 Transformers are Keras models](https://huggingface.co/blog/tensorflow-philosophy), most of the methods in this document are generally applicable to TPU training for any Keras model! However, there are a few points that are specific to the HuggingFace ecosystem (hug-o-system?) of Transformers and Datasets, and we\u2019ll make sure to flag them up when we get to them.\n\n### What kinds of TPU are available?\n\nNew users are often very confused by the range of TPUs, and the different ways to access them. The first key distinction to understand is the difference between **TPU Nodes** and **TPU VMs.**\n\nWhen you use a **TPU Node**, you are effectively indirectly accessing a remote TPU. You will need a separate VM, which will initialize your network and data pipeline and then forward them to the remote node. When you use a TPU on Google Colab, you are accessing it in the **TPU Node** style.\n\nUsing TPU Nodes can have some quite unexpected behaviour for people who aren\u2019t used to them! In particular, because the TPU is located on a physically different system to the machine you\u2019re running your Python code on, your data cannot be local to your machine - any data pipeline that loads from your machine\u2019s internal storage will totally fail! Instead, data must be stored in Google Cloud Storage where your data pipeline can still access it, even when the pipeline is running on the remote TPU node.\n\n<Tip>\n\nIf you can fit all your data in memory as `np.ndarray` or `tf.Tensor`, then you can `fit()` on that data even when using Colab or a TPU Node, without needing to upload it to Google Cloud Storage.\n\n</Tip>\n\n<Tip>\n\n**\ud83e\udd17Specific Hugging Face Tip\ud83e\udd17:** The methods `Dataset.to_tf_dataset()` and its higher-level wrapper `model.prepare_tf_dataset()` , which you will see throughout our TF code examples, will both fail on a TPU Node. The reason for this is that even though they create a `tf.data.Dataset` it is not a \u201cpure\u201d `tf.data` pipeline and uses `tf.numpy_function` or `Dataset.from_generator()` to stream data from the underlying HuggingFace `Dataset`. This HuggingFace `Dataset` is backed by data that is on a local disc and which the remote TPU Node will not be able to read.\n\n</Tip>\n\nThe second way to access a TPU is via a **TPU VM.** When using a TPU VM, you connect directly to the machine that the TPU is attached to, much like training on a GPU VM. TPU VMs are generally easier to work with, particularly when it comes to your data pipeline. All of the above warnings do not apply to TPU VMs!\n\nThis is an opinionated document, so here\u2019s our opinion: **Avoid using TPU Node if possible.** It is more confusing and more difficult to debug than TPU VMs. It is also likely to be unsupported in future - Google\u2019s latest TPU, TPUv4, can only be accessed as a TPU VM, which suggests that TPU Nodes are increasingly going to become a \u201clegacy\u201d access method. However, we understand that the only free TPU access is on Colab and Kaggle Kernels, which uses TPU Node - so we\u2019ll try to explain how to handle it if you have to! Check the [TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) for code samples that explain this in more detail.\n\n### What sizes of TPU are available?\n\nA single TPU (a v2-8/v3-8/v4-8) runs 8 replicas. TPUs exist in **pods** that can run hundreds or thousands of replicas simultaneously. When you use more than a single TPU but less than a whole pod (for example, a v3-32), your TPU fleet is referred to as a **pod slice.**\n\nWhen you access a free TPU via Colab, you generally get a single v2-8 TPU.\n\n### I keep hearing about this XLA thing. What\u2019s XLA, and how does it relate to TPUs?\n\nXLA is an optimizing compiler, used by both TensorFlow and JAX. In JAX it is the only compiler, whereas in TensorFlow it is optional\n--New Chunk--\n[Created at: 2025-03-24 13:17:32]\nlabel_mask  # Set negative label positions to 0\nmean_loss = tf.reduce_sum(loss) / tf.reduce_sum(label_mask)\n```\n\nHere, we avoid data-dependent shapes by computing the loss for every position, but zeroing out the masked positions in both the numerator and denominator when we calculate the mean, which yields exactly the same result as the first block while maintaining XLA compatibility. Note that we use the same trick as in rule #1 - converting a `tf.bool` to `tf.float32` and using it as an indicator variable. This is a really useful trick, so remember it if you need to convert your own code to XLA!\n\n#### XLA Rule #3: XLA will need to recompile your model for every different input shape it sees\n\nThis is the big one. What this means is that if your input shapes are very variable, XLA will have to recompile your model over and over, which will create huge performance problems. This commonly arises in NLP models, where input texts have variable lengths after tokenization. In other modalities, static shapes are more common and this rule is much less of a problem.\n\nHow can you get around rule #3? The key is **padding** - if you pad all your inputs to the same length, and then use an `attention_mask`, you can get the same results as you\u2019d get from variable shapes, but without any XLA issues. However, excessive padding can cause severe slowdown too - if you pad all your samples to the maximum length in the whole dataset, you might end up with batches consisting endless padding tokens, which will waste a lot of compute and memory!\n\nThere isn\u2019t a perfect solution to this problem. However, you can try some tricks. One very useful trick is to **pad batches of samples up to a multiple of a number like 32 or 64 tokens.** This often only increases the number of tokens by a small amount, but it hugely reduces the number of unique input shapes, because every input shape now has to be a multiple of 32 or 64. Fewer unique input shapes means fewer XLA compilations!\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** Our tokenizers and data collators have methods that can help you here. You can use `padding=\"max_length\"` or `padding=\"longest\"` when calling tokenizers to get them to output padded data. Our tokenizers and data collators also have a `pad_to_multiple_of` argument that you can use to reduce the number of unique input shapes you see!\n\n</Tip>\n\n### How do I actually train my model on TPU?\n\nOnce your training is XLA-compatible and (if you\u2019re using TPU Node / Colab) your dataset has been prepared appropriately, running on TPU is surprisingly easy! All you really need to change in your code is to add a few lines to initialize your TPU, and to ensure that your model and dataset are created inside a `TPUStrategy` scope. Take a look at [our TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) to see this in action!\n\n### Summary\n\nThere was a lot in here, so let\u2019s summarize with a quick checklist you can follow when you want to get your model ready for TPU training:\n\n- Make sure your code follows the three rules of XLA\n- Compile your model with `jit_compile=True` on CPU/GPU and confirm that you can train it with XLA\n- Either load your dataset into memory or use a TPU-compatible dataset loading approach (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Migrate your code either to Colab (with accelerator set to \u201cTPU\u201d) or a TPU VM on Google Cloud\n- Add TPU initializer code (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Create your `TPUStrategy` and make sure dataset loading and model creation are inside the `strategy.scope()` (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Don\u2019t forget to take `jit_compile=True` out again when you move to TPU!\n- \ud83d\ude4f\ud83d\ude4f\ud83d\ude4f\ud83e\udd7a\ud83e\udd7a\ud83e\udd7a\n- Call model.fit()\n- You did it!"
        }
    },
    {
        "sample_idx": 83,
        "question": "What is the final step to train a model on TPU?",
        "answer": "Call model.fit().",
        "rag_answer": "### How do I actually train my model on TPU?\n\nOnce your training is XLA-compatible and (if you\u2019re using TPU Node / Colab) your dataset has been prepared appropriately, running on TPU is surprisingly easy! All you really need to change in your code is to add a few lines to initialize your TPU, and to ensure that your model and dataset are created inside a `TPUStrategy` scope. Take a look at [our TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples",
        "rag_score": null,
        "rag_feedback": null,
        "rag_context": {
            "kg_context": "-----Entities-----\n    ```csv\n    id,\tentity,\ttype,\tdescription,\trankcreated_at\n1,\tTPU,technology,TPU is a Tensor Processing Unit, a hardware designed by Google to speed up tensor computations within neural networks.<SEP>TPU is a type of hardware accelerator designed for machine learning workloads.<SEP>TPU is a type of hardware accelerator used for machine learning computations.,4,2025-03-24 13:18:20\n2,\tXLA,technology,XLA is a technology that compiles TensorFlow graphs into executable code for various platforms.<SEP>XLA is an optimizing compiler used by TensorFlow and JAX to improve performance.<SEP>XLA is an optimizing compiler, used by both TensorFlow and JAX to optimize computations.,6,2025-03-24 13:18:20\n3,\tGoogle,organization,Google is the company that designs and provides TPUs, which are used to speed up tensor computations within neural networks.,3,2025-03-24 13:18:20\n4,\tGoogle Cloud,organization,Google Cloud is a cloud computing platform that provides infrastructure and services for building and deploying machine learning models.,1,2025-03-24 13:18:20\n5,\tTPU,technology,TPU is a Tensor Processing Unit, a hardware designed by Google to speed up tensor computations within neural networks.<SEP>TPU is a type of hardware accelerator designed for machine learning workloads.<SEP>TPU is a type of hardware accelerator used for machine learning computations.,4,UNKNOWN\n6,\tTPUv4,category,TPUv4 is a type of TPU, a hardware designed by Google to speed up tensor computations within neural networks.,0,UNKNOWN\n7,\tv3-32 TPU,category,v3-32 TPU is a type of TPU, a hardware designed by Google to speed up tensor computations within neural networks.,0,UNKNOWN\n    ```\n    -----Relationships-----\n    ```csv\n    id,\tsource,\ttarget,\tdescription,\tkeywords,\tweight,\trank,\tcreated_at\n1,\tTPU,XLA,XLA compiles TensorFlow graphs into executable code for TPU hardware.<SEP>XLA is used to optimize code for TPU hardware.,compilation, hardware acceleration<SEP>compiler, hardware optimization,36.0,10,2025-03-24 13:18:20\n2,\tGoogle,TPU,Google designs and provides TPUs, which are used to speed up tensor computations within neural networks.,hardware design, acceleration,18.0,7,2025-03-24 13:18:20\n3,\tGoogle Cloud,TPU,Google Cloud provides infrastructure and services for building and deploying machine learning models, including TPU hardware.,infrastructure provision, hardware acceleration,14.0,5,2025-03-24 13:18:20\n4,\tTPU,XLA,XLA compiles TensorFlow graphs into executable code for TPU hardware.<SEP>XLA is used to optimize code for TPU hardware.,compilation, hardware acceleration<SEP>compiler, hardware optimization,36.0,10,UNKNOWN\n5,\tGoogle,TPU,Google designs and provides TPUs, which are used to speed up tensor computations within neural networks.,hardware design, acceleration,18.0,7,UNKNOWN\n6,\tColab,TPU,Colab provides access to a free TPU for users.,platform, hardware acceleration,16.0,7,UNKNOWN\n7,\tGoogle Cloud,TPU,Google Cloud provides infrastructure and services for building and deploying machine learning models, including TPU hardware.,infrastructure provision, hardware acceleration,14.0,5,UNKNOWN\n    ```\n    -----Sources-----\n    ```csv\n    id,\tcontent\n1,\t(for example, a v3-32), your TPU fleet is referred to as a **pod slice.**\n\nWhen you access a free TPU via Colab, you generally get a single v2-8 TPU.\n\n### I keep hearing about this XLA thing. What\u2019s XLA, and how does it relate to TPUs?\n\nXLA is an optimizing compiler, used by both TensorFlow and JAX. In JAX it is the only compiler, whereas in TensorFlow it is optional (but mandatory on TPU!). The easiest way to enable it when training a Keras model is to pass the argument `jit_compile=True` to `model.compile()`. If you don\u2019t get any errors and performance is good, that\u2019s a great sign that you\u2019re ready to move to TPU!\n\nDebugging on TPU is generally a bit harder than on CPU/GPU, so we recommend getting your code running on CPU/GPU with XLA first before trying it on TPU. You don\u2019t have to train for long, of course - just for a few steps to make sure that your model and data pipeline are working like you expect them to.\n\n<Tip>\n\nXLA compiled code is usually faster - so even if you\u2019re not planning to run on TPU, adding `jit_compile=True` can improve your performance. Be sure to note the caveats below about XLA compatibility, though!\n\n</Tip>\n\n<Tip warning={true}>\n\n**Tip born of painful experience:** Although using `jit_compile=True` is a good way to get a speed boost and test if your CPU/GPU code is XLA-compatible, it can actually cause a lot of problems if you leave it in when actually training on TPU. XLA compilation will happen implicitly on TPU, so remember to remove that line before actually running your code on a TPU!\n\n</Tip>\n\n### How do I make my model XLA compatible?\n\nIn many cases, your code is probably XLA-compatible already! However, there are a few things that work in normal TensorFlow that don\u2019t work in XLA. We\u2019ve distilled them into three core rules below:\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** We\u2019ve put a lot of effort into rewriting our TensorFlow models and loss functions to be XLA-compatible. Our models and loss functions generally obey rule #1 and #2 by default, so you can skip over them if you\u2019re using `transformers` models. Don\u2019t forget about these rules when writing your own models and loss functions, though!\n\n</Tip>\n\n#### XLA Rule #1: Your code cannot have \u201cdata-dependent conditionals\u201d\n\nWhat that means is that any `if` statement cannot depend on values inside a `tf.Tensor`. For example, this code block cannot be compiled with XLA!\n\n```python\nif tf.reduce_sum(tensor) > 10:\n    tensor = tensor / 2.0\n```\n\nThis might seem very restrictive at first, but most neural net code doesn\u2019t need to do this. You can often get around this restriction by using `tf.cond` (see the documentation [here](https://www.tensorflow.org/api_docs/python/tf/cond)) or by removing the conditional and finding a clever math trick with indicator variables instead, like so:\n\n```python\nsum_over_10 = tf.cast(tf.reduce_sum(tensor) > 10, tf.float32)\ntensor = tensor / (1.0 + sum_over_10)\n```\n\nThis code has exactly the same effect as the code above, but by avoiding a conditional, we ensure it will compile with XLA without problems!\n\n#### XLA Rule #2: Your code cannot have \u201cdata-dependent shapes\u201d\n\nWhat this means is that the shape of all of the `tf.Tensor` objects in your code cannot depend on their values. For example, the function `tf.unique` cannot be compiled with XLA, because it returns a `tensor` containing one instance of each unique value in the input. The shape of this output will obviously be different depending on how repetitive the input `Tensor` was, and so XLA refuses to handle it!\n\nIn general, most neural network code obeys rule #2 by default. However, there are a few common cases where it becomes a problem. One very common one is when you use **label masking**, setting your labels to a negative value to indicate that those positions should be ignored when computing the loss. If you look at NumPy or PyTorch loss functions that support label masking, you will often see code like this that uses [boolean indexing](https://numpy.org/doc/stable/user/basics.indexing.html#boolean-array-indexing):\n\n```python\nlabel_mask = labels >= 0\nmasked_outputs = outputs[label_mask]\nmasked_labels = labels[label_mask]\nloss = compute_loss(masked_outputs, masked_labels)\nmean_loss = torch.mean(loss)\n```\n\nThis code is totally fine in NumPy or PyTorch, but it breaks in XLA! Why? Because the shape of `masked_outputs` and `masked_labels` depends on how many positions are masked - that makes it a **data-dependent shape.** However, just like for rule #1, we can often rewrite this code to yield exactly the same output without any data-dependent shapes.\n\n```python\nlabel_mask = tf.cast(labels >= 0, tf.float32)\nloss = compute_loss(outputs, labels)\nloss = loss * label_mask  # Set negative label positions to 0\nmean_loss = tf.reduce_sum(loss) / tf.reduce_sum(label_mask)\n```\n\nHere, we avoid data-dependent shapes by computing the loss for every position, but zeroing out the masked positions in both the numerator and denominator when we calculate the mean, which yields exactly the same result as the first block while maintaining XLA compatibility. Note that we use the same trick as in rule #1 - converting a `tf.bool` to `\n2,\tlabel_mask  # Set negative label positions to 0\nmean_loss = tf.reduce_sum(loss) / tf.reduce_sum(label_mask)\n```\n\nHere, we avoid data-dependent shapes by computing the loss for every position, but zeroing out the masked positions in both the numerator and denominator when we calculate the mean, which yields exactly the same result as the first block while maintaining XLA compatibility. Note that we use the same trick as in rule #1 - converting a `tf.bool` to `tf.float32` and using it as an indicator variable. This is a really useful trick, so remember it if you need to convert your own code to XLA!\n\n#### XLA Rule #3: XLA will need to recompile your model for every different input shape it sees\n\nThis is the big one. What this means is that if your input shapes are very variable, XLA will have to recompile your model over and over, which will create huge performance problems. This commonly arises in NLP models, where input texts have variable lengths after tokenization. In other modalities, static shapes are more common and this rule is much less of a problem.\n\nHow can you get around rule #3? The key is **padding** - if you pad all your inputs to the same length, and then use an `attention_mask`, you can get the same results as you\u2019d get from variable shapes, but without any XLA issues. However, excessive padding can cause severe slowdown too - if you pad all your samples to the maximum length in the whole dataset, you might end up with batches consisting endless padding tokens, which will waste a lot of compute and memory!\n\nThere isn\u2019t a perfect solution to this problem. However, you can try some tricks. One very useful trick is to **pad batches of samples up to a multiple of a number like 32 or 64 tokens.** This often only increases the number of tokens by a small amount, but it hugely reduces the number of unique input shapes, because every input shape now has to be a multiple of 32 or 64. Fewer unique input shapes means fewer XLA compilations!\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** Our tokenizers and data collators have methods that can help you here. You can use `padding=\"max_length\"` or `padding=\"longest\"` when calling tokenizers to get them to output padded data. Our tokenizers and data collators also have a `pad_to_multiple_of` argument that you can use to reduce the number of unique input shapes you see!\n\n</Tip>\n\n### How do I actually train my model on TPU?\n\nOnce your training is XLA-compatible and (if you\u2019re using TPU Node / Colab) your dataset has been prepared appropriately, running on TPU is surprisingly easy! All you really need to change in your code is to add a few lines to initialize your TPU, and to ensure that your model and dataset are created inside a `TPUStrategy` scope. Take a look at [our TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) to see this in action!\n\n### Summary\n\nThere was a lot in here, so let\u2019s summarize with a quick checklist you can follow when you want to get your model ready for TPU training:\n\n- Make sure your code follows the three rules of XLA\n- Compile your model with `jit_compile=True` on CPU/GPU and confirm that you can train it with XLA\n- Either load your dataset into memory or use a TPU-compatible dataset loading approach (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Migrate your code either to Colab (with accelerator set to \u201cTPU\u201d) or a TPU VM on Google Cloud\n- Add TPU initializer code (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Create your `TPUStrategy` and make sure dataset loading and model creation are inside the `strategy.scope()` (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Don\u2019t forget to take `jit_compile=True` out again when you move to TPU!\n- \ud83d\ude4f\ud83d\ude4f\ud83d\ude4f\ud83e\udd7a\ud83e\udd7a\ud83e\udd7a\n- Call model.fit()\n- You did it!\n3,\t!--Copyright 2023 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\nthe License. You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under the License is distributed on\nan \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n\n\u26a0\ufe0f Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be\nrendered properly in your Markdown viewer.\n\n-->\n\n# Training on TPU with TensorFlow\n\n<Tip>\n\nIf you don't need long explanations and just want TPU code samples to get started with, check out [our TPU example notebook!](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb)\n\n</Tip>\n\n### What is a TPU?\n\nA TPU is a **Tensor Processing Unit.** They are hardware designed by Google, which are used to greatly speed up the tensor computations within neural networks, much like GPUs. They can be used for both network training and inference. They are generally accessed through Google\u2019s cloud services, but small TPUs can also be accessed directly for free through Google Colab and Kaggle Kernels.\n\nBecause [all TensorFlow models in \ud83e\udd17 Transformers are Keras models](https://huggingface.co/blog/tensorflow-philosophy), most of the methods in this document are generally applicable to TPU training for any Keras model! However, there are a few points that are specific to the HuggingFace ecosystem (hug-o-system?) of Transformers and Datasets, and we\u2019ll make sure to flag them up when we get to them.\n\n### What kinds of TPU are available?\n\nNew users are often very confused by the range of TPUs, and the different ways to access them. The first key distinction to understand is the difference between **TPU Nodes** and **TPU VMs.**\n\nWhen you use a **TPU Node**, you are effectively indirectly accessing a remote TPU. You will need a separate VM, which will initialize your network and data pipeline and then forward them to the remote node. When you use a TPU on Google Colab, you are accessing it in the **TPU Node** style.\n\nUsing TPU Nodes can have some quite unexpected behaviour for people who aren\u2019t used to them! In particular, because the TPU is located on a physically different system to the machine you\u2019re running your Python code on, your data cannot be local to your machine - any data pipeline that loads from your machine\u2019s internal storage will totally fail! Instead, data must be stored in Google Cloud Storage where your data pipeline can still access it, even when the pipeline is running on the remote TPU node.\n\n<Tip>\n\nIf you can fit all your data in memory as `np.ndarray` or `tf.Tensor`, then you can `fit()` on that data even when using Colab or a TPU Node, without needing to upload it to Google Cloud Storage.\n\n</Tip>\n\n<Tip>\n\n**\ud83e\udd17Specific Hugging Face Tip\ud83e\udd17:** The methods `Dataset.to_tf_dataset()` and its higher-level wrapper `model.prepare_tf_dataset()` , which you will see throughout our TF code examples, will both fail on a TPU Node. The reason for this is that even though they create a `tf.data.Dataset` it is not a \u201cpure\u201d `tf.data` pipeline and uses `tf.numpy_function` or `Dataset.from_generator()` to stream data from the underlying HuggingFace `Dataset`. This HuggingFace `Dataset` is backed by data that is on a local disc and which the remote TPU Node will not be able to read.\n\n</Tip>\n\nThe second way to access a TPU is via a **TPU VM.** When using a TPU VM, you connect directly to the machine that the TPU is attached to, much like training on a GPU VM. TPU VMs are generally easier to work with, particularly when it comes to your data pipeline. All of the above warnings do not apply to TPU VMs!\n\nThis is an opinionated document, so here\u2019s our opinion: **Avoid using TPU Node if possible.** It is more confusing and more difficult to debug than TPU VMs. It is also likely to be unsupported in future - Google\u2019s latest TPU, TPUv4, can only be accessed as a TPU VM, which suggests that TPU Nodes are increasingly going to become a \u201clegacy\u201d access method. However, we understand that the only free TPU access is on Colab and Kaggle Kernels, which uses TPU Node - so we\u2019ll try to explain how to handle it if you have to! Check the [TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) for code samples that explain this in more detail.\n\n### What sizes of TPU are available?\n\nA single TPU (a v2-8/v3-8/v4-8) runs 8 replicas. TPUs exist in **pods** that can run hundreds or thousands of replicas simultaneously. When you use more than a single TPU but less than a whole pod (for example, a v3-32), your TPU fleet is referred to as a **pod slice.**\n\nWhen you access a free TPU via Colab, you generally get a single v2-8 TPU.\n\n### I keep hearing about this XLA thing. What\u2019s XLA, and how does it relate to TPUs?\n\nXLA is an optimizing compiler, used by both TensorFlow and JAX. In JAX it is the only compiler, whereas in TensorFlow it is optional\n    ```",
            "vector_context": "[Created at: 2025-03-24 13:17:32]\nlabel_mask  # Set negative label positions to 0\nmean_loss = tf.reduce_sum(loss) / tf.reduce_sum(label_mask)\n```\n\nHere, we avoid data-dependent shapes by computing the loss for every position, but zeroing out the masked positions in both the numerator and denominator when we calculate the mean, which yields exactly the same result as the first block while maintaining XLA compatibility. Note that we use the same trick as in rule #1 - converting a `tf.bool` to `tf.float32` and using it as an indicator variable. This is a really useful trick, so remember it if you need to convert your own code to XLA!\n\n#### XLA Rule #3: XLA will need to recompile your model for every different input shape it sees\n\nThis is the big one. What this means is that if your input shapes are very variable, XLA will have to recompile your model over and over, which will create huge performance problems. This commonly arises in NLP models, where input texts have variable lengths after tokenization. In other modalities, static shapes are more common and this rule is much less of a problem.\n\nHow can you get around rule #3? The key is **padding** - if you pad all your inputs to the same length, and then use an `attention_mask`, you can get the same results as you\u2019d get from variable shapes, but without any XLA issues. However, excessive padding can cause severe slowdown too - if you pad all your samples to the maximum length in the whole dataset, you might end up with batches consisting endless padding tokens, which will waste a lot of compute and memory!\n\nThere isn\u2019t a perfect solution to this problem. However, you can try some tricks. One very useful trick is to **pad batches of samples up to a multiple of a number like 32 or 64 tokens.** This often only increases the number of tokens by a small amount, but it hugely reduces the number of unique input shapes, because every input shape now has to be a multiple of 32 or 64. Fewer unique input shapes means fewer XLA compilations!\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** Our tokenizers and data collators have methods that can help you here. You can use `padding=\"max_length\"` or `padding=\"longest\"` when calling tokenizers to get them to output padded data. Our tokenizers and data collators also have a `pad_to_multiple_of` argument that you can use to reduce the number of unique input shapes you see!\n\n</Tip>\n\n### How do I actually train my model on TPU?\n\nOnce your training is XLA-compatible and (if you\u2019re using TPU Node / Colab) your dataset has been prepared appropriately, running on TPU is surprisingly easy! All you really need to change in your code is to add a few lines to initialize your TPU, and to ensure that your model and dataset are created inside a `TPUStrategy` scope. Take a look at [our TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) to see this in action!\n\n### Summary\n\nThere was a lot in here, so let\u2019s summarize with a quick checklist you can follow when you want to get your model ready for TPU training:\n\n- Make sure your code follows the three rules of XLA\n- Compile your model with `jit_compile=True` on CPU/GPU and confirm that you can train it with XLA\n- Either load your dataset into memory or use a TPU-compatible dataset loading approach (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Migrate your code either to Colab (with accelerator set to \u201cTPU\u201d) or a TPU VM on Google Cloud\n- Add TPU initializer code (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Create your `TPUStrategy` and make sure dataset loading and model creation are inside the `strategy.scope()` (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Don\u2019t forget to take `jit_compile=True` out again when you move to TPU!\n- \ud83d\ude4f\ud83d\ude4f\ud83d\ude4f\ud83e\udd7a\ud83e\udd7a\ud83e\udd7a\n- Call model.fit()\n- You did it!\n--New Chunk--\n[Created at: 2025-03-24 13:17:32]\n!--Copyright 2023 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\nthe License. You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under the License is distributed on\nan \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n\n\u26a0\ufe0f Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be\nrendered properly in your Markdown viewer.\n\n-->\n\n# Training on TPU with TensorFlow\n\n<Tip>\n\nIf you don't need long explanations and just want TPU code samples to get started with, check out [our TPU example notebook!](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb)\n\n</Tip>\n\n### What is a TPU?\n\nA TPU is a **Tensor Processing Unit.** They are hardware designed by Google, which are used to greatly speed up the tensor computations within neural networks, much like GPUs. They can be used for both network training and inference. They are generally accessed through Google\u2019s cloud services, but small TPUs can also be accessed directly for free through Google Colab and Kaggle Kernels.\n\nBecause [all TensorFlow models in \ud83e\udd17 Transformers are Keras models](https://huggingface.co/blog/tensorflow-philosophy), most of the methods in this document are generally applicable to TPU training for any Keras model! However, there are a few points that are specific to the HuggingFace ecosystem (hug-o-system?) of Transformers and Datasets, and we\u2019ll make sure to flag them up when we get to them.\n\n### What kinds of TPU are available?\n\nNew users are often very confused by the range of TPUs, and the different ways to access them. The first key distinction to understand is the difference between **TPU Nodes** and **TPU VMs.**\n\nWhen you use a **TPU Node**, you are effectively indirectly accessing a remote TPU. You will need a separate VM, which will initialize your network and data pipeline and then forward them to the remote node. When you use a TPU on Google Colab, you are accessing it in the **TPU Node** style.\n\nUsing TPU Nodes can have some quite unexpected behaviour for people who aren\u2019t used to them! In particular, because the TPU is located on a physically different system to the machine you\u2019re running your Python code on, your data cannot be local to your machine - any data pipeline that loads from your machine\u2019s internal storage will totally fail! Instead, data must be stored in Google Cloud Storage where your data pipeline can still access it, even when the pipeline is running on the remote TPU node.\n\n<Tip>\n\nIf you can fit all your data in memory as `np.ndarray` or `tf.Tensor`, then you can `fit()` on that data even when using Colab or a TPU Node, without needing to upload it to Google Cloud Storage.\n\n</Tip>\n\n<Tip>\n\n**\ud83e\udd17Specific Hugging Face Tip\ud83e\udd17:** The methods `Dataset.to_tf_dataset()` and its higher-level wrapper `model.prepare_tf_dataset()` , which you will see throughout our TF code examples, will both fail on a TPU Node. The reason for this is that even though they create a `tf.data.Dataset` it is not a \u201cpure\u201d `tf.data` pipeline and uses `tf.numpy_function` or `Dataset.from_generator()` to stream data from the underlying HuggingFace `Dataset`. This HuggingFace `Dataset` is backed by data that is on a local disc and which the remote TPU Node will not be able to read.\n\n</Tip>\n\nThe second way to access a TPU is via a **TPU VM.** When using a TPU VM, you connect directly to the machine that the TPU is attached to, much like training on a GPU VM. TPU VMs are generally easier to work with, particularly when it comes to your data pipeline. All of the above warnings do not apply to TPU VMs!\n\nThis is an opinionated document, so here\u2019s our opinion: **Avoid using TPU Node if possible.** It is more confusing and more difficult to debug than TPU VMs. It is also likely to be unsupported in future - Google\u2019s latest TPU, TPUv4, can only be accessed as a TPU VM, which suggests that TPU Nodes are increasingly going to become a \u201clegacy\u201d access method. However, we understand that the only free TPU access is on Colab and Kaggle Kernels, which uses TPU Node - so we\u2019ll try to explain how to handle it if you have to! Check the [TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) for code samples that explain this in more detail.\n\n### What sizes of TPU are available?\n\nA single TPU (a v2-8/v3-8/v4-8) runs 8 replicas. TPUs exist in **pods** that can run hundreds or thousands of replicas simultaneously. When you use more than a single TPU but less than a whole pod (for example, a v3-32), your TPU fleet is referred to as a **pod slice.**\n\nWhen you access a free TPU via Colab, you generally get a single v2-8 TPU.\n\n### I keep hearing about this XLA thing. What\u2019s XLA, and how does it relate to TPUs?\n\nXLA is an optimizing compiler, used by both TensorFlow and JAX. In JAX it is the only compiler, whereas in TensorFlow it is optional\n--New Chunk--\n[Created at: 2025-03-24 13:17:32]\n(for example, a v3-32), your TPU fleet is referred to as a **pod slice.**\n\nWhen you access a free TPU via Colab, you generally get a single v2-8 TPU.\n\n### I keep hearing about this XLA thing. What\u2019s XLA, and how does it relate to TPUs?\n\nXLA is an optimizing compiler, used by both TensorFlow and JAX. In JAX it is the only compiler, whereas in TensorFlow it is optional (but mandatory on TPU!). The easiest way to enable it when training a Keras model is to pass the argument `jit_compile=True` to `model.compile()`. If you don\u2019t get any errors and performance is good, that\u2019s a great sign that you\u2019re ready to move to TPU!\n\nDebugging on TPU is generally a bit harder than on CPU/GPU, so we recommend getting your code running on CPU/GPU with XLA first before trying it on TPU. You don\u2019t have to train for long, of course - just for a few steps to make sure that your model and data pipeline are working like you expect them to.\n\n<Tip>\n\nXLA compiled code is usually faster - so even if you\u2019re not planning to run on TPU, adding `jit_compile=True` can improve your performance. Be sure to note the caveats below about XLA compatibility, though!\n\n</Tip>\n\n<Tip warning={true}>\n\n**Tip born of painful experience:** Although using `jit_compile=True` is a good way to get a speed boost and test if your CPU/GPU code is XLA-compatible, it can actually cause a lot of problems if you leave it in when actually training on TPU. XLA compilation will happen implicitly on TPU, so remember to remove that line before actually running your code on a TPU!\n\n</Tip>\n\n### How do I make my model XLA compatible?\n\nIn many cases, your code is probably XLA-compatible already! However, there are a few things that work in normal TensorFlow that don\u2019t work in XLA. We\u2019ve distilled them into three core rules below:\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** We\u2019ve put a lot of effort into rewriting our TensorFlow models and loss functions to be XLA-compatible. Our models and loss functions generally obey rule #1 and #2 by default, so you can skip over them if you\u2019re using `transformers` models. Don\u2019t forget about these rules when writing your own models and loss functions, though!\n\n</Tip>\n\n#### XLA Rule #1: Your code cannot have \u201cdata-dependent conditionals\u201d\n\nWhat that means is that any `if` statement cannot depend on values inside a `tf.Tensor`. For example, this code block cannot be compiled with XLA!\n\n```python\nif tf.reduce_sum(tensor) > 10:\n    tensor = tensor / 2.0\n```\n\nThis might seem very restrictive at first, but most neural net code doesn\u2019t need to do this. You can often get around this restriction by using `tf.cond` (see the documentation [here](https://www.tensorflow.org/api_docs/python/tf/cond)) or by removing the conditional and finding a clever math trick with indicator variables instead, like so:\n\n```python\nsum_over_10 = tf.cast(tf.reduce_sum(tensor) > 10, tf.float32)\ntensor = tensor / (1.0 + sum_over_10)\n```\n\nThis code has exactly the same effect as the code above, but by avoiding a conditional, we ensure it will compile with XLA without problems!\n\n#### XLA Rule #2: Your code cannot have \u201cdata-dependent shapes\u201d\n\nWhat this means is that the shape of all of the `tf.Tensor` objects in your code cannot depend on their values. For example, the function `tf.unique` cannot be compiled with XLA, because it returns a `tensor` containing one instance of each unique value in the input. The shape of this output will obviously be different depending on how repetitive the input `Tensor` was, and so XLA refuses to handle it!\n\nIn general, most neural network code obeys rule #2 by default. However, there are a few common cases where it becomes a problem. One very common one is when you use **label masking**, setting your labels to a negative value to indicate that those positions should be ignored when computing the loss. If you look at NumPy or PyTorch loss functions that support label masking, you will often see code like this that uses [boolean indexing](https://numpy.org/doc/stable/user/basics.indexing.html#boolean-array-indexing):\n\n```python\nlabel_mask = labels >= 0\nmasked_outputs = outputs[label_mask]\nmasked_labels = labels[label_mask]\nloss = compute_loss(masked_outputs, masked_labels)\nmean_loss = torch.mean(loss)\n```\n\nThis code is totally fine in NumPy or PyTorch, but it breaks in XLA! Why? Because the shape of `masked_outputs` and `masked_labels` depends on how many positions are masked - that makes it a **data-dependent shape.** However, just like for rule #1, we can often rewrite this code to yield exactly the same output without any data-dependent shapes.\n\n```python\nlabel_mask = tf.cast(labels >= 0, tf.float32)\nloss = compute_loss(outputs, labels)\nloss = loss * label_mask  # Set negative label positions to 0\nmean_loss = tf.reduce_sum(loss) / tf.reduce_sum(label_mask)\n```\n\nHere, we avoid data-dependent shapes by computing the loss for every position, but zeroing out the masked positions in both the numerator and denominator when we calculate the mean, which yields exactly the same result as the first block while maintaining XLA compatibility. Note that we use the same trick as in rule #1 - converting a `tf.bool` to `"
        }
    },
    {
        "sample_idx": 84,
        "question": "What is the minimum value of the 'Random Slider (Input 1)' in the Gradio demo?",
        "answer": "The minimum value is 100.",
        "rag_answer": "The minimum value of the 'Random Slider (Input 1)' in the Gradio demo is 100.",
        "rag_score": 5,
        "rag_feedback": "The system's response is completely correct, accurate, and factual. It directly answers the question by stating that the minimum value of the 'Random Slider (Input 1)' in the Gradio demo is 100, which is supported by the provided code snippet.",
        "rag_context": {
            "kg_context": "-----Entities-----\n    ```csv\n    id,\tentity,\ttype,\tdescription,\trankcreated_at\n1,\tGradio Demo,event,Gradio Demo is an event that showcases the functionality of Gradio's blocks_random_slider.,8,2025-03-24 13:18:47\n2,\tslider_1,technology,slider_1 is a specific slider used in Gradio's demo to create interactive interfaces.,1,2025-03-24 13:18:47\n3,\tslider_2,technology,slider_2 is a specific slider used in Gradio's demo to create interactive interfaces.,1,2025-03-24 13:18:47\n4,\tslider_3,technology,slider_3 is a specific slider used in Gradio's demo to create interactive interfaces.,1,2025-03-24 13:18:47\n5,\tslider_1,technology,slider_1 is a specific slider used in Gradio's demo to create interactive interfaces.,1,UNKNOWN\n6,\tblocks_random_slider,category,blocks_random_slider is a category of demo provided by Gradio, which includes interactive sliders.,1,UNKNOWN\n7,\tslider_3,technology,slider_3 is a specific slider used in Gradio's demo to create interactive interfaces.,1,UNKNOWN\n    ```\n    -----Relationships-----\n    ```csv\n    id,\tsource,\ttarget,\tdescription,\tkeywords,\tweight,\trank,\tcreated_at\n1,\tGradio Demo,slider_1,slider_1 is used in Gradio Demo to create interactive interfaces.,technology, event,6.0,9,2025-03-24 13:18:47\n2,\tGradio Demo,slider_2,slider_2 is used in Gradio Demo to create interactive interfaces.,technology, event,6.0,9,2025-03-24 13:18:47\n3,\tGradio Demo,slider_3,slider_3 is used in Gradio Demo to create interactive interfaces.,technology, event,6.0,9,2025-03-24 13:18:47\n4,\tGradio Demo,blocks_random_slider,Gradio Demo is an event that showcases the functionality of blocks_random_slider.,event, category,18.0,9,UNKNOWN\n5,\tGradio Demo,slider_1,slider_1 is used in Gradio Demo to create interactive interfaces.,technology, event,6.0,9,UNKNOWN\n6,\tGradio Demo,slider_3,slider_3 is used in Gradio Demo to create interactive interfaces.,technology, event,6.0,9,UNKNOWN\n    ```\n    -----Sources-----\n    ```csv\n    id,\tcontent\n1,\tGradio Demo: blocks_random_slider\n\n\n```\n!pip install -q gradio \n```\n\n\n```\n\nimport gradio as gr\n\n\ndef func(slider_1, slider_2):\n    return slider_1 * 5 + slider_2\n\n\nwith gr.Blocks() as demo:\n    slider = gr.Slider(minimum=-10.2, maximum=15, label=\"Random Slider (Static)\", randomize=True)\n    slider_1 = gr.Slider(minimum=100, maximum=200, label=\"Random Slider (Input 1)\", randomize=True)\n    slider_2 = gr.Slider(minimum=10, maximum=23.2, label=\"Random Slider (Input 2)\", randomize=True)\n    slider_3 = gr.Slider(value=3, label=\"Non random slider\")\n    btn = gr.Button(\"Run\")\n    btn.click(func, inputs=[slider_1, slider_2], outputs=gr.Number())\n\nif __name__ == \"__main__\":\n    demo.launch()\n\n```\n    ```",
            "vector_context": "[Created at: 2025-03-24 13:18:21]\nGradio Demo: blocks_random_slider\n\n\n```\n!pip install -q gradio \n```\n\n\n```\n\nimport gradio as gr\n\n\ndef func(slider_1, slider_2):\n    return slider_1 * 5 + slider_2\n\n\nwith gr.Blocks() as demo:\n    slider = gr.Slider(minimum=-10.2, maximum=15, label=\"Random Slider (Static)\", randomize=True)\n    slider_1 = gr.Slider(minimum=100, maximum=200, label=\"Random Slider (Input 1)\", randomize=True)\n    slider_2 = gr.Slider(minimum=10, maximum=23.2, label=\"Random Slider (Input 2)\", randomize=True)\n    slider_3 = gr.Slider(value=3, label=\"Non random slider\")\n    btn = gr.Button(\"Run\")\n    btn.click(func, inputs=[slider_1, slider_2], outputs=gr.Number())\n\nif __name__ == \"__main__\":\n    demo.launch()\n\n```\n--New Chunk--\n[Created at: 2025-03-24 13:16:48]\n\u4e3b\u8981\u7279\u70b9\n\n\u8ba9\u6211\u4eec\u6765\u4ecb\u7ecd\u4e00\u4e0b Gradio \u6700\u53d7\u6b22\u8fce\u7684\u4e00\u4e9b\u529f\u80fd\uff01\u8fd9\u91cc\u662f Gradio \u7684\u4e3b\u8981\u7279\u70b9\uff1a\n\n1. [\u6dfb\u52a0\u793a\u4f8b\u8f93\u5165](#example-inputs)\n2. [\u4f20\u9012\u81ea\u5b9a\u4e49\u9519\u8bef\u6d88\u606f](#errors)\n3. [\u6dfb\u52a0\u63cf\u8ff0\u5185\u5bb9](#descriptive-content)\n4. [\u8bbe\u7f6e\u65d7\u6807](#flagging)\n5. [\u9884\u5904\u7406\u548c\u540e\u5904\u7406](#preprocessing-and-postprocessing)\n6. [\u6837\u5f0f\u5316\u6f14\u793a](#styling)\n7. [\u6392\u961f\u7528\u6237](#queuing)\n8. [\u8fed\u4ee3\u8f93\u51fa](#iterative-outputs)\n9. [\u8fdb\u5ea6\u6761](#progress-bars)\n10. [\u6279\u5904\u7406\u51fd\u6570](#batch-functions)\n11. [\u5728\u534f\u4f5c\u7b14\u8bb0\u672c\u4e0a\u8fd0\u884c](#colab-notebooks)\n\n## \u793a\u4f8b\u8f93\u5165\n\n\u60a8\u53ef\u4ee5\u63d0\u4f9b\u7528\u6237\u53ef\u4ee5\u8f7b\u677e\u52a0\u8f7d\u5230 \"Interface\" \u4e2d\u7684\u793a\u4f8b\u6570\u636e\u3002\u8fd9\u5bf9\u4e8e\u6f14\u793a\u6a21\u578b\u671f\u671b\u7684\u8f93\u5165\u7c7b\u578b\u4ee5\u53ca\u6f14\u793a\u6570\u636e\u96c6\u548c\u6a21\u578b\u4e00\u8d77\u63a2\u7d22\u7684\u65b9\u5f0f\u975e\u5e38\u6709\u5e2e\u52a9\u3002\u8981\u52a0\u8f7d\u793a\u4f8b\u6570\u636e\uff0c\u60a8\u53ef\u4ee5\u5c06\u5d4c\u5957\u5217\u8868\u63d0\u4f9b\u7ed9 Interface \u6784\u9020\u51fd\u6570\u7684 `examples=` \u5173\u952e\u5b57\u53c2\u6570\u3002\u5916\u90e8\u5217\u8868\u4e2d\u7684\u6bcf\u4e2a\u5b50\u5217\u8868\u8868\u793a\u4e00\u4e2a\u6570\u636e\u6837\u672c\uff0c\u5b50\u5217\u8868\u4e2d\u7684\u6bcf\u4e2a\u5143\u7d20\u8868\u793a\u6bcf\u4e2a\u8f93\u5165\u7ec4\u4ef6\u7684\u8f93\u5165\u3002\u6709\u5173\u6bcf\u4e2a\u7ec4\u4ef6\u7684\u793a\u4f8b\u6570\u636e\u683c\u5f0f\u5728[Docs](https://gradio.app/docs#components)\u4e2d\u6709\u8bf4\u660e\u3002\n\n$code_calculator\n$demo_calculator\n\n\u60a8\u53ef\u4ee5\u5c06\u5927\u578b\u6570\u636e\u96c6\u52a0\u8f7d\u5230\u793a\u4f8b\u4e2d\uff0c\u901a\u8fc7 Gradio \u6d4f\u89c8\u548c\u4e0e\u6570\u636e\u96c6\u8fdb\u884c\u4ea4\u4e92\u3002\u793a\u4f8b\u5c06\u81ea\u52a8\u5206\u9875\uff08\u53ef\u4ee5\u901a\u8fc7 Interface \u7684 `examples_per_page` \u53c2\u6570\u8fdb\u884c\u914d\u7f6e\uff09\u3002\n\n\u7ee7\u7eed\u4e86\u89e3\u793a\u4f8b\uff0c\u8bf7\u53c2\u9605[\u66f4\u591a\u793a\u4f8b](https://gradio.app/more-on-examples)\u6307\u5357\u3002\n\n## \u9519\u8bef\n\n\u60a8\u5e0c\u671b\u5411\u7528\u6237\u4f20\u9012\u81ea\u5b9a\u4e49\u9519\u8bef\u6d88\u606f\u3002\u4e3a\u6b64\uff0cwith `gr.Error(\"custom message\")` \u6765\u663e\u793a\u9519\u8bef\u6d88\u606f\u3002\u5982\u679c\u5728\u4e0a\u9762\u7684\u8ba1\u7b97\u5668\u793a\u4f8b\u4e2d\u5c1d\u8bd5\u9664\u4ee5\u96f6\uff0c\u5c06\u663e\u793a\u81ea\u5b9a\u4e49\u9519\u8bef\u6d88\u606f\u7684\u5f39\u51fa\u6a21\u6001\u7a97\u53e3\u3002\u4e86\u89e3\u6709\u5173\u9519\u8bef\u7684\u66f4\u591a\u4fe1\u606f\uff0c\u8bf7\u53c2\u9605[\u6587\u6863](https://gradio.app/docs#error)\u3002\n\n## \u63cf\u8ff0\u6027\u5185\u5bb9\n\n\u5728\u524d\u9762\u7684\u793a\u4f8b\u4e2d\uff0c\u60a8\u53ef\u80fd\u5df2\u7ecf\u6ce8\u610f\u5230 Interface \u6784\u9020\u51fd\u6570\u4e2d\u7684 `title=` \u548c `description=` \u5173\u952e\u5b57\u53c2\u6570\uff0c\u5e2e\u52a9\u7528\u6237\u4e86\u89e3\u60a8\u7684\u5e94\u7528\u7a0b\u5e8f\u3002\n\nInterface \u6784\u9020\u51fd\u6570\u4e2d\u6709\u4e09\u4e2a\u53c2\u6570\u7528\u4e8e\u6307\u5b9a\u6b64\u5185\u5bb9\u5e94\u653e\u7f6e\u5728\u54ea\u91cc\uff1a\n\n- `title`\uff1a\u63a5\u53d7\u6587\u672c\uff0c\u5e76\u53ef\u4ee5\u5c06\u5176\u663e\u793a\u5728\u754c\u9762\u7684\u9876\u90e8\uff0c\u4e5f\u5c06\u6210\u4e3a\u9875\u9762\u6807\u9898\u3002\n- `description`\uff1a\u63a5\u53d7\u6587\u672c\u3001Markdown \u6216 HTML\uff0c\u5e76\u5c06\u5176\u653e\u7f6e\u5728\u6807\u9898\u6b63\u4e0b\u65b9\u3002\n- `article`\uff1a\u4e5f\u63a5\u53d7\u6587\u672c\u3001Markdown \u6216 HTML\uff0c\u5e76\u5c06\u5176\u653e\u7f6e\u5728\u754c\u9762\u4e0b\u65b9\u3002\n\n![annotated](/assets/guides/annotated.png)\n\n\u5982\u679c\u60a8\u4f7f\u7528\u7684\u662f `Blocks` API\uff0c\u5219\u53ef\u4ee5 with `gr.Markdown(...)` \u6216 `gr.HTML(...)` \u7ec4\u4ef6\u5728\u4efb\u4f55\u4f4d\u7f6e\u63d2\u5165\u6587\u672c\u3001Markdown \u6216 HTML\uff0c\u5176\u4e2d\u63cf\u8ff0\u6027\u5185\u5bb9\u4f4d\u4e8e `Component` \u6784\u9020\u51fd\u6570\u5185\u90e8\u3002\n\n\u53e6\u4e00\u4e2a\u6709\u7528\u7684\u5173\u952e\u5b57\u53c2\u6570\u662f `label=`\uff0c\u5b83\u5b58\u5728\u4e8e\u6bcf\u4e2a `Component` \u4e2d\u3002\u8fd9\u4fee\u6539\u4e86\u6bcf\u4e2a `Component` \u9876\u90e8\u7684\u6807\u7b7e\u6587\u672c\u3002\u8fd8\u53ef\u4ee5\u4e3a\u8bf8\u5982 `Textbox` \u6216 `Radio` \u4e4b\u7c7b\u7684\u8868\u5355\u5143\u7d20\u6dfb\u52a0 `info=` \u5173\u952e\u5b57\u53c2\u6570\uff0c\u4ee5\u63d0\u4f9b\u6709\u5173\u5176\u7528\u6cd5\u7684\u8fdb\u4e00\u6b65\u4fe1\u606f\u3002\n\n```python\ngr.Number(label='\u5e74\u9f84', info='\u4ee5\u5e74\u4e3a\u5355\u4f4d\uff0c\u5fc5\u987b\u5927\u4e8e0')\n```\n\n## \u65d7\u6807\n\n\u9ed8\u8ba4\u60c5\u51b5\u4e0b\uff0c\"Interface\" \u5c06\u6709\u4e00\u4e2a \"Flag\" \u6309\u94ae\u3002\u5f53\u7528\u6237\u6d4b\u8bd5\u60a8\u7684 `Interface` \u65f6\uff0c\u5982\u679c\u770b\u5230\u6709\u8da3\u7684\u8f93\u51fa\uff0c\u4f8b\u5982\u9519\u8bef\u6216\u610f\u5916\u7684\u6a21\u578b\u884c\u4e3a\uff0c\u4ed6\u4eec\u53ef\u4ee5\u5c06\u8f93\u5165\u6807\u8bb0\u4e3a\u60a8\u8fdb\u884c\u67e5\u770b\u3002\u5728\u7531 `Interface` \u6784\u9020\u51fd\u6570\u7684 `flagging_dir=` \u53c2\u6570\u63d0\u4f9b\u7684\u76ee\u5f55\u4e2d\uff0c\u5c06\u8bb0\u5f55\u6807\u8bb0\u7684\u8f93\u5165\u5230\u4e00\u4e2a CSV \u6587\u4ef6\u4e2d\u3002\u5982\u679c\u754c\u9762\u6d89\u53ca\u6587\u4ef6\u6570\u636e\uff0c\u4f8b\u5982\u56fe\u50cf\u548c\u97f3\u9891\u7ec4\u4ef6\uff0c\u5c06\u521b\u5efa\u6587\u4ef6\u5939\u6765\u5b58\u50a8\u8fd9\u4e9b\u6807\u8bb0\u7684\u6570\u636e\u3002\n\n\u4f8b\u5982\uff0c\u5bf9\u4e8e\u4e0a\u9762\u663e\u793a\u7684\u8ba1\u7b97\u5668\u754c\u9762\uff0c\u6211\u4eec\u5c06\u5728\u4e0b\u9762\u7684\u65d7\u6807\u76ee\u5f55\u4e2d\u5b58\u50a8\u6807\u8bb0\u7684\u6570\u636e\uff1a\n\n```directory\n+-- calculator.py\n+-- flagged/\n|   +-- logs.csv\n```\n\n_flagged/logs.csv_\n\n```csv\nnum1,operation,num2,Output\n5,add,7,12\n6,subtract,1.5,4.5\n```\n\n\u4e0e\u65e9\u671f\u663e\u793a\u7684\u51b7\u8272\u754c\u9762\u76f8\u5bf9\u5e94\uff0c\u6211\u4eec\u5c06\u5728\u4e0b\u9762\u7684\u65d7\u6807\u76ee\u5f55\u4e2d\u5b58\u50a8\u6807\u8bb0\u7684\u6570\u636e\uff1a\n\n```directory\n+-- sepia.py\n+-- flagged/\n|   +-- logs.csv\n|   +-- im/\n|   |   +-- 0.png\n|   |   +-- 1.png\n|   +-- Output/\n|   |   +-- 0.png\n|   |   +-- 1.png\n```\n\n_flagged/logs.csv_\n\n```csv\nim,Output\nim/0.png,Output/0.png\nim/1.png,Output/1.png\n```\n\n\u5982\u679c\u60a8\u5e0c\u671b\u7528\u6237\u63d0\u4f9b\u65d7\u6807\u539f\u56e0\uff0c\u53ef\u4ee5\u5c06\u5b57\u7b26\u4e32\u5217\u8868\u4f20\u9012\u7ed9 Interface \u7684 `flagging_options` \u53c2\u6570\u3002\u7528\u6237\u5728\u8fdb\u884c\u65d7\u6807\u65f6\u5fc5\u987b\u9009\u62e9\u5176\u4e2d\u4e00\u4e2a\u5b57\u7b26\u4e32\uff0c\u8fd9\u5c06\u4f5c\u4e3a\u9644\u52a0\u5217\u4fdd\u5b58\u5230 CSV \u4e2d\u3002\n\n## \u9884\u5904\u7406\u548c\u540e\u5904\u7406 (Preprocessing and Postprocessing)\n\n![annotated](/assets/img/dataflow.svg)\n\n\u5982\u60a8\u6240\u89c1\uff0cGradio \u5305\u62ec\u53ef\u4ee5\u5904\u7406\u5404\u79cd\u4e0d\u540c\u6570\u636e\u7c7b\u578b\u7684\u7ec4\u4ef6\uff0c\u4f8b\u5982\u56fe\u50cf\u3001\u97f3\u9891\u548c\u89c6\u9891\u3002\u5927\u591a\u6570\u7ec4\u4ef6\u90fd\u53ef\u4ee5\u7528\u4f5c\u8f93\u5165\u6216\u8f93\u51fa\u3002\n\n\u5f53\u7ec4\u4ef6\u7528\u4f5c\u8f93\u5165\u65f6\uff0cGradio \u81ea\u52a8\u5904\u7406*\u9884\u5904\u7406*\uff0c\u5c06\u6570\u636e\u4ece\u7528\u6237\n--New Chunk--\n[Created at: 2025-03-24 13:16:48]\n\u4e0e\u5e38\u89c4\u51fd\u6570\u76f8\u540c\u7684\u65b9\u5f0f\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio\u3002\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\uff08\u865a\u62df\u7684\uff09\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5b83\u5728\u8f93\u51fa\u56fe\u50cf\u4e4b\u524d\u751f\u6210\u6570\u4e2a\u6b65\u9aa4\u7684\u566a\u97f3\uff1a\n\n$code_fake_diffusion\n$demo_fake_diffusion\n\n\u8bf7\u6ce8\u610f\uff0c\u6211\u4eec\u5728\u8fed\u4ee3\u5668\u4e2d\u6dfb\u52a0\u4e86 `time.sleep(1)`\uff0c\u4ee5\u521b\u5efa\u6b65\u9aa4\u4e4b\u95f4\u7684\u4eba\u5de5\u6682\u505c\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u89c2\u5bdf\u8fed\u4ee3\u5668\u7684\u6b65\u9aa4\uff08\u5728\u771f\u5b9e\u7684\u56fe\u50cf\u751f\u6210\u6a21\u578b\u4e2d\uff0c\u8fd9\u53ef\u80fd\u662f\u4e0d\u5fc5\u8981\u7684\uff09\u3002\n\n\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio **\u9700\u8981**\u5728\u5e95\u5c42 Interface \u6216 Blocks \u4e2d\u542f\u7528\u961f\u5217\uff08\u8bf7\u53c2\u9605\u4e0a\u9762\u7684\u961f\u5217\u90e8\u5206\uff09\u3002\n\n## \u8fdb\u5ea6\u6761\n\nGradio \u652f\u6301\u521b\u5efa\u81ea\u5b9a\u4e49\u8fdb\u5ea6\u6761\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u81ea\u5b9a\u4e49\u548c\u63a7\u5236\u5411\u7528\u6237\u663e\u793a\u7684\u8fdb\u5ea6\u66f4\u65b0\u3002\u8981\u542f\u7528\u6b64\u529f\u80fd\uff0c\u53ea\u9700\u4e3a\u65b9\u6cd5\u6dfb\u52a0\u4e00\u4e2a\u9ed8\u8ba4\u503c\u4e3a `gr.Progress` \u5b9e\u4f8b\u7684\u53c2\u6570\u5373\u53ef\u3002\u7136\u540e\uff0c\u60a8\u53ef\u4ee5\u76f4\u63a5\u8c03\u7528\u6b64\u5b9e\u4f8b\u5e76\u4f20\u5165 0 \u5230 1 \u4e4b\u95f4\u7684\u6d6e\u70b9\u6570\u6765\u66f4\u65b0\u8fdb\u5ea6\u7ea7\u522b\uff0c\u6216\u8005 with `Progress` \u5b9e\u4f8b\u7684 `tqdm()` \u65b9\u6cd5\u6765\u8ddf\u8e2a\u53ef\u8fed\u4ee3\u5bf9\u8c61\u4e0a\u7684\u8fdb\u5ea6\uff0c\u5982\u4e0b\u6240\u793a\u3002\u5fc5\u987b\u542f\u7528\u961f\u5217\u4ee5\u8fdb\u884c\u8fdb\u5ea6\u66f4\u65b0\u3002\n\n$code_progress_simple\n$demo_progress_simple\n\n\u5982\u679c\u60a8 with `tqdm` \u5e93\uff0c\u5e76\u4e14\u5e0c\u671b\u4ece\u51fd\u6570\u5185\u90e8\u7684\u4efb\u4f55 `tqdm.tqdm` \u81ea\u52a8\u62a5\u544a\u8fdb\u5ea6\u66f4\u65b0\uff0c\u8bf7\u5c06\u9ed8\u8ba4\u53c2\u6570\u8bbe\u7f6e\u4e3a `gr.Progress(track_tqdm=True)`\uff01\n\n## \u6279\u5904\u7406\u51fd\u6570 (Batch Functions)\n\nGradio \u652f\u6301\u4f20\u9012*\u6279\u5904\u7406*\u51fd\u6570\u3002\u6279\u5904\u7406\u51fd\u6570\u53ea\u662f\u63a5\u53d7\u8f93\u5165\u5217\u8868\u5e76\u8fd4\u56de\u9884\u6d4b\u5217\u8868\u7684\u51fd\u6570\u3002\n\n\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\u6279\u5904\u7406\u51fd\u6570\uff0c\u5b83\u63a5\u53d7\u4e24\u4e2a\u8f93\u5165\u5217\u8868\uff08\u4e00\u4e2a\u5355\u8bcd\u5217\u8868\u548c\u4e00\u4e2a\u6574\u6570\u5217\u8868\uff09\uff0c\u5e76\u8fd4\u56de\u4fee\u526a\u8fc7\u7684\u5355\u8bcd\u5217\u8868\u4f5c\u4e3a\u8f93\u51fa\uff1a\n\n```python\nimport time\n\ndef trim_words(words, lens):\n    trimmed_words = []\n    time.sleep(5)\n    for w, l in zip(words, lens):\n        trimmed_words.append(w[:int(l)])\n    return [trimmed_words]\n    for w, l in zip(words, lens):\n```\n\n\u4f7f\u7528\u6279\u5904\u7406\u51fd\u6570\u7684\u4f18\u70b9\u662f\uff0c\u5982\u679c\u542f\u7528\u4e86\u961f\u5217\uff0cGradio \u670d\u52a1\u5668\u53ef\u4ee5\u81ea\u52a8*\u6279\u5904\u7406*\u4f20\u5165\u7684\u8bf7\u6c42\u5e76\u5e76\u884c\u5904\u7406\u5b83\u4eec\uff0c\u4ece\u800c\u53ef\u80fd\u52a0\u5feb\u6f14\u793a\u901f\u5ea6\u3002\u4ee5\u4e0b\u662f Gradio \u4ee3\u7801\u7684\u793a\u4f8b\uff08\u8bf7\u6ce8\u610f `batch=True` \u548c `max_batch_size=16` - \u8fd9\u4e24\u4e2a\u53c2\u6570\u90fd\u53ef\u4ee5\u4f20\u9012\u7ed9\u4e8b\u4ef6\u89e6\u53d1\u5668\u6216 `Interface` \u7c7b\uff09\n\nwith `Interface`\uff1a\n\n```python\ndemo = gr.Interface(trim_words, [\"textbox\", \"number\"], [\"output\"],\n                    batch=True, max_batch_size=16)\ndemo.queue()\ndemo.launch()\n```\n\nwith `Blocks`\uff1a\n\n```python\nimport gradio as gr\n\nwith gr.Blocks() as demo:\n    with gr.Row():\n        word = gr.Textbox(label=\"word\")\n        leng = gr.Number(label=\"leng\")\n        output = gr.Textbox(label=\"Output\")\n    with gr.Row():\n        run = gr.Button()\n\n    event = run.click(trim_words, [word, leng], output, batch=True, max_batch_size=16)\n\ndemo.queue()\ndemo.launch()\n```\n\n\u5728\u4e0a\u9762\u7684\u793a\u4f8b\u4e2d\uff0c\u53ef\u4ee5\u5e76\u884c\u5904\u7406 16 \u4e2a\u8bf7\u6c42\uff08\u603b\u63a8\u7406\u65f6\u95f4\u4e3a 5 \u79d2\uff09\uff0c\u800c\u4e0d\u662f\u5206\u522b\u5904\u7406\u6bcf\u4e2a\u8bf7\u6c42\uff08\u603b\u63a8\u7406\u65f6\u95f4\u4e3a 80 \u79d2\uff09\u3002\u8bb8\u591a Hugging Face \u7684 `transformers` \u548c `diffusers` \u6a21\u578b\u5728 Gradio \u7684\u6279\u5904\u7406\u6a21\u5f0f\u4e0b\u81ea\u7136\u5de5\u4f5c\uff1a\u8fd9\u662f[\u4f7f\u7528\u6279\u5904\u7406\u751f\u6210\u56fe\u50cf\u7684\u793a\u4f8b\u6f14\u793a](https://github.com/gradio-app/gradio/blob/main/demo/diffusers_with_batching/run.py)\n\n\u6ce8\u610f\uff1a\u4f7f\u7528 Gradio \u7684\u6279\u5904\u7406\u51fd\u6570 **requires** \u5728\u5e95\u5c42 Interface \u6216 Blocks \u4e2d\u542f\u7528\u961f\u5217\uff08\u8bf7\u53c2\u9605\u4e0a\u9762\u7684\u961f\u5217\u90e8\u5206\uff09\u3002\n\n## Gradio \u7b14\u8bb0\u672c (Colab Notebooks)\n\nGradio \u53ef\u4ee5\u5728\u4efb\u4f55\u8fd0\u884c Python \u7684\u5730\u65b9\u8fd0\u884c\uff0c\u5305\u62ec\u672c\u5730 Jupyter \u7b14\u8bb0\u672c\u548c\u534f\u4f5c\u7b14\u8bb0\u672c\uff0c\u5982[Google Colab](https://colab.research.google.com/)\u3002\u5bf9\u4e8e\u672c\u5730 Jupyter \u7b14\u8bb0\u672c\u548c Google Colab \u7b14\u8bb0\u672c\uff0cGradio \u5728\u672c\u5730\u670d\u52a1\u5668\u4e0a\u8fd0\u884c\uff0c\u60a8\u53ef\u4ee5\u5728\u6d4f\u89c8\u5668\u4e2d\u4e0e\u4e4b\u4ea4\u4e92\u3002\uff08\u6ce8\u610f\uff1a\u5bf9\u4e8e Google Colab\uff0c\u8fd9\u662f\u901a\u8fc7[\u670d\u52a1\u5de5\u4f5c\u5668\u96a7\u9053](https://github.com/tensorflow/tensorboard/blob/master/docs/design/colab_integration.md)\u5b9e\u73b0\u7684\uff0c\u60a8\u7684\u6d4f\u89c8\u5668\u9700\u8981\u542f\u7528 cookies\u3002\uff09\u5bf9\u4e8e\u5176\u4ed6\u8fdc\u7a0b\u7b14\u8bb0\u672c\uff0cGradio \u4e5f\u5c06\u5728\u670d\u52a1\u5668\u4e0a\u8fd0\u884c\uff0c\u4f46\u60a8\u9700\u8981\u4f7f\u7528[SSH \u96a7\u9053](https://coderwall.com/p/ohk6cg/remote-access-to-ipython-notebooks-via-ssh)\u5728\u672c\u5730\u6d4f\u89c8\u5668\u4e2d\u67e5\u770b\u5e94\u7528\u7a0b\u5e8f\u3002\u901a\u5e38\uff0c\u66f4\u7b80\u5355\u7684\u9009\u62e9\u662f\u4f7f\u7528 Gradio \u5185\u7f6e\u7684\u516c\u5171\u94fe\u63a5\uff0c[\u5728\u4e0b\u4e00\u7bc7\u6307\u5357\u4e2d\u8ba8\u8bba](/sharing-your-app/#sharing-demos)\u3002"
        }
    },
    {
        "sample_idx": 85,
        "question": "What is the maximum value of the 'Random Slider (Static)' in the Gradio demo?",
        "answer": "The maximum value is 15.",
        "rag_answer": "The maximum value of the 'Random Slider (Static)' in the Gradio demo is 15.",
        "rag_score": 5,
        "rag_feedback": "The system's response is completely correct, accurate, and factual. It directly answers the question by stating the maximum value of the 'Random Slider (Static)' in the Gradio demo, which is 15.",
        "rag_context": {
            "kg_context": "-----Entities-----\n    ```csv\n    id,\tentity,\ttype,\tdescription,\trankcreated_at\n1,\tGradio,organization,Gradio is a platform that supports state in Blocks, providing features such as global state and session state.<SEP>Gradio is an interface that provides various features for demonstrating models, including adding example inputs, custom error messages, descriptive content, flagging, and more.<SEP>Gradio is an organization that provides a platform for building and deploying machine learning models.<SEP>Gradio is an organization that provides a platform for creating and deploying machine learning models.<SEP>Gradio is an organization that provides a demo for blocks_random_slider, and its library is used to create interactive interfaces.,36,2025-03-24 13:18:47\n2,\tdemo,organization,Demo refers to a demonstration or example of a Gradio application.<SEP>demo is an organization that provides an interface for Gradio's blocks_random_slider.,1,2025-03-24 13:18:47\n3,\tGradio Demo,event,Gradio Demo is an event that showcases the functionality of Gradio's blocks_random_slider.,8,2025-03-24 13:18:47\n4,\tslider_1,technology,slider_1 is a specific slider used in Gradio's demo to create interactive interfaces.,1,2025-03-24 13:18:47\n5,\tslider_2,technology,slider_2 is a specific slider used in Gradio's demo to create interactive interfaces.,1,2025-03-24 13:18:47\n6,\tslider_1,technology,slider_1 is a specific slider used in Gradio's demo to create interactive interfaces.,1,UNKNOWN\n7,\tblocks_random_slider,category,blocks_random_slider is a category of demo provided by Gradio, which includes interactive sliders.,1,UNKNOWN\n8,\tslider_2,technology,slider_2 is a specific slider used in Gradio's demo to create interactive interfaces.,1,UNKNOWN\n    ```\n    -----Relationships-----\n    ```csv\n    id,\tsource,\ttarget,\tdescription,\tkeywords,\tweight,\trank,\tcreated_at\n1,\tGradio,demo,Demos are used in Gradio to demonstrate applications.<SEP>demo is an interface provided by Gradio for blocks_random_slider.,demo, application demonstration<SEP>organization, interface,21.0,37,2025-03-24 13:18:47\n2,\tGradio Demo,slider_1,slider_1 is used in Gradio Demo to create interactive interfaces.,technology, event,6.0,9,2025-03-24 13:18:47\n3,\tGradio Demo,slider_2,slider_2 is used in Gradio Demo to create interactive interfaces.,technology, event,6.0,9,2025-03-24 13:18:47\n4,\tGradio Demo,blocks_random_slider,Gradio Demo is an event that showcases the functionality of blocks_random_slider.,event, category,18.0,9,UNKNOWN\n5,\tGradio Demo,slider_1,slider_1 is used in Gradio Demo to create interactive interfaces.,technology, event,6.0,9,UNKNOWN\n6,\tGradio Demo,slider_2,slider_2 is used in Gradio Demo to create interactive interfaces.,technology, event,6.0,9,UNKNOWN\n    ```\n    -----Sources-----\n    ```csv\n    id,\tcontent\n1,\t\u4e0e\u5e38\u89c4\u51fd\u6570\u76f8\u540c\u7684\u65b9\u5f0f\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio\u3002\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\uff08\u865a\u62df\u7684\uff09\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5b83\u5728\u8f93\u51fa\u56fe\u50cf\u4e4b\u524d\u751f\u6210\u6570\u4e2a\u6b65\u9aa4\u7684\u566a\u97f3\uff1a\n\n$code_fake_diffusion\n$demo_fake_diffusion\n\n\u8bf7\u6ce8\u610f\uff0c\u6211\u4eec\u5728\u8fed\u4ee3\u5668\u4e2d\u6dfb\u52a0\u4e86 `time.sleep(1)`\uff0c\u4ee5\u521b\u5efa\u6b65\u9aa4\u4e4b\u95f4\u7684\u4eba\u5de5\u6682\u505c\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u89c2\u5bdf\u8fed\u4ee3\u5668\u7684\u6b65\u9aa4\uff08\u5728\u771f\u5b9e\u7684\u56fe\u50cf\u751f\u6210\u6a21\u578b\u4e2d\uff0c\u8fd9\u53ef\u80fd\u662f\u4e0d\u5fc5\u8981\u7684\uff09\u3002\n\n\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio **\u9700\u8981**\u5728\u5e95\u5c42 Interface \u6216 Blocks \u4e2d\u542f\u7528\u961f\u5217\uff08\u8bf7\u53c2\u9605\u4e0a\u9762\u7684\u961f\u5217\u90e8\u5206\uff09\u3002\n\n## \u8fdb\u5ea6\u6761\n\nGradio \u652f\u6301\u521b\u5efa\u81ea\u5b9a\u4e49\u8fdb\u5ea6\u6761\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u81ea\u5b9a\u4e49\u548c\u63a7\u5236\u5411\u7528\u6237\u663e\u793a\u7684\u8fdb\u5ea6\u66f4\u65b0\u3002\u8981\u542f\u7528\u6b64\u529f\u80fd\uff0c\u53ea\u9700\u4e3a\u65b9\u6cd5\u6dfb\u52a0\u4e00\u4e2a\u9ed8\u8ba4\u503c\u4e3a `gr.Progress` \u5b9e\u4f8b\u7684\u53c2\u6570\u5373\u53ef\u3002\u7136\u540e\uff0c\u60a8\u53ef\u4ee5\u76f4\u63a5\u8c03\u7528\u6b64\u5b9e\u4f8b\u5e76\u4f20\u5165 0 \u5230 1 \u4e4b\u95f4\u7684\u6d6e\u70b9\u6570\u6765\u66f4\u65b0\u8fdb\u5ea6\u7ea7\u522b\uff0c\u6216\u8005 with `Progress` \u5b9e\u4f8b\u7684 `tqdm()` \u65b9\u6cd5\u6765\u8ddf\u8e2a\u53ef\u8fed\u4ee3\u5bf9\u8c61\u4e0a\u7684\u8fdb\u5ea6\uff0c\u5982\u4e0b\u6240\u793a\u3002\u5fc5\u987b\u542f\u7528\u961f\u5217\u4ee5\u8fdb\u884c\u8fdb\u5ea6\u66f4\u65b0\u3002\n\n$code_progress_simple\n$demo_progress_simple\n\n\u5982\u679c\u60a8 with `tqdm` \u5e93\uff0c\u5e76\u4e14\u5e0c\u671b\u4ece\u51fd\u6570\u5185\u90e8\u7684\u4efb\u4f55 `tqdm.tqdm` \u81ea\u52a8\u62a5\u544a\u8fdb\u5ea6\u66f4\u65b0\uff0c\u8bf7\u5c06\u9ed8\u8ba4\u53c2\u6570\u8bbe\u7f6e\u4e3a `gr.Progress(track_tqdm=True)`\uff01\n\n## \u6279\u5904\u7406\u51fd\u6570 (Batch Functions)\n\nGradio \u652f\u6301\u4f20\u9012*\u6279\u5904\u7406*\u51fd\u6570\u3002\u6279\u5904\u7406\u51fd\u6570\u53ea\u662f\u63a5\u53d7\u8f93\u5165\u5217\u8868\u5e76\u8fd4\u56de\u9884\u6d4b\u5217\u8868\u7684\u51fd\u6570\u3002\n\n\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\u6279\u5904\u7406\u51fd\u6570\uff0c\u5b83\u63a5\u53d7\u4e24\u4e2a\u8f93\u5165\u5217\u8868\uff08\u4e00\u4e2a\u5355\u8bcd\u5217\u8868\u548c\u4e00\u4e2a\u6574\u6570\u5217\u8868\uff09\uff0c\u5e76\u8fd4\u56de\u4fee\u526a\u8fc7\u7684\u5355\u8bcd\u5217\u8868\u4f5c\u4e3a\u8f93\u51fa\uff1a\n\n```python\nimport time\n\ndef trim_words(words, lens):\n    trimmed_words = []\n    time.sleep(5)\n    for w, l in zip(words, lens):\n        trimmed_words.append(w[:int(l)])\n    return [trimmed_words]\n    for w, l in zip(words, lens):\n```\n\n\u4f7f\u7528\u6279\u5904\u7406\u51fd\u6570\u7684\u4f18\u70b9\u662f\uff0c\u5982\u679c\u542f\u7528\u4e86\u961f\u5217\uff0cGradio \u670d\u52a1\u5668\u53ef\u4ee5\u81ea\u52a8*\u6279\u5904\u7406*\u4f20\u5165\u7684\u8bf7\u6c42\u5e76\u5e76\u884c\u5904\u7406\u5b83\u4eec\uff0c\u4ece\u800c\u53ef\u80fd\u52a0\u5feb\u6f14\u793a\u901f\u5ea6\u3002\u4ee5\u4e0b\u662f Gradio \u4ee3\u7801\u7684\u793a\u4f8b\uff08\u8bf7\u6ce8\u610f `batch=True` \u548c `max_batch_size=16` - \u8fd9\u4e24\u4e2a\u53c2\u6570\u90fd\u53ef\u4ee5\u4f20\u9012\u7ed9\u4e8b\u4ef6\u89e6\u53d1\u5668\u6216 `Interface` \u7c7b\uff09\n\nwith `Interface`\uff1a\n\n```python\ndemo = gr.Interface(trim_words, [\"textbox\", \"number\"], [\"output\"],\n                    batch=True, max_batch_size=16)\ndemo.queue()\ndemo.launch()\n```\n\nwith `Blocks`\uff1a\n\n```python\nimport gradio as gr\n\nwith gr.Blocks() as demo:\n    with gr.Row():\n        word = gr.Textbox(label=\"word\")\n        leng = gr.Number(label=\"leng\")\n        output = gr.Textbox(label=\"Output\")\n    with gr.Row():\n        run = gr.Button()\n\n    event = run.click(trim_words, [word, leng], output, batch=True, max_batch_size=16)\n\ndemo.queue()\ndemo.launch()\n```\n\n\u5728\u4e0a\u9762\u7684\u793a\u4f8b\u4e2d\uff0c\u53ef\u4ee5\u5e76\u884c\u5904\u7406 16 \u4e2a\u8bf7\u6c42\uff08\u603b\u63a8\u7406\u65f6\u95f4\u4e3a 5 \u79d2\uff09\uff0c\u800c\u4e0d\u662f\u5206\u522b\u5904\u7406\u6bcf\u4e2a\u8bf7\u6c42\uff08\u603b\u63a8\u7406\u65f6\u95f4\u4e3a 80 \u79d2\uff09\u3002\u8bb8\u591a Hugging Face \u7684 `transformers` \u548c `diffusers` \u6a21\u578b\u5728 Gradio \u7684\u6279\u5904\u7406\u6a21\u5f0f\u4e0b\u81ea\u7136\u5de5\u4f5c\uff1a\u8fd9\u662f[\u4f7f\u7528\u6279\u5904\u7406\u751f\u6210\u56fe\u50cf\u7684\u793a\u4f8b\u6f14\u793a](https://github.com/gradio-app/gradio/blob/main/demo/diffusers_with_batching/run.py)\n\n\u6ce8\u610f\uff1a\u4f7f\u7528 Gradio \u7684\u6279\u5904\u7406\u51fd\u6570 **requires** \u5728\u5e95\u5c42 Interface \u6216 Blocks \u4e2d\u542f\u7528\u961f\u5217\uff08\u8bf7\u53c2\u9605\u4e0a\u9762\u7684\u961f\u5217\u90e8\u5206\uff09\u3002\n\n## Gradio \u7b14\u8bb0\u672c (Colab Notebooks)\n\nGradio \u53ef\u4ee5\u5728\u4efb\u4f55\u8fd0\u884c Python \u7684\u5730\u65b9\u8fd0\u884c\uff0c\u5305\u62ec\u672c\u5730 Jupyter \u7b14\u8bb0\u672c\u548c\u534f\u4f5c\u7b14\u8bb0\u672c\uff0c\u5982[Google Colab](https://colab.research.google.com/)\u3002\u5bf9\u4e8e\u672c\u5730 Jupyter \u7b14\u8bb0\u672c\u548c Google Colab \u7b14\u8bb0\u672c\uff0cGradio \u5728\u672c\u5730\u670d\u52a1\u5668\u4e0a\u8fd0\u884c\uff0c\u60a8\u53ef\u4ee5\u5728\u6d4f\u89c8\u5668\u4e2d\u4e0e\u4e4b\u4ea4\u4e92\u3002\uff08\u6ce8\u610f\uff1a\u5bf9\u4e8e Google Colab\uff0c\u8fd9\u662f\u901a\u8fc7[\u670d\u52a1\u5de5\u4f5c\u5668\u96a7\u9053](https://github.com/tensorflow/tensorboard/blob/master/docs/design/colab_integration.md)\u5b9e\u73b0\u7684\uff0c\u60a8\u7684\u6d4f\u89c8\u5668\u9700\u8981\u542f\u7528 cookies\u3002\uff09\u5bf9\u4e8e\u5176\u4ed6\u8fdc\u7a0b\u7b14\u8bb0\u672c\uff0cGradio \u4e5f\u5c06\u5728\u670d\u52a1\u5668\u4e0a\u8fd0\u884c\uff0c\u4f46\u60a8\u9700\u8981\u4f7f\u7528[SSH \u96a7\u9053](https://coderwall.com/p/ohk6cg/remote-access-to-ipython-notebooks-via-ssh)\u5728\u672c\u5730\u6d4f\u89c8\u5668\u4e2d\u67e5\u770b\u5e94\u7528\u7a0b\u5e8f\u3002\u901a\u5e38\uff0c\u66f4\u7b80\u5355\u7684\u9009\u62e9\u662f\u4f7f\u7528 Gradio \u5185\u7f6e\u7684\u516c\u5171\u94fe\u63a5\uff0c[\u5728\u4e0b\u4e00\u7bc7\u6307\u5357\u4e2d\u8ba8\u8bba](/sharing-your-app/#sharing-demos)\u3002\n2,\tGradio Demo: blocks_random_slider\n\n\n```\n!pip install -q gradio \n```\n\n\n```\n\nimport gradio as gr\n\n\ndef func(slider_1, slider_2):\n    return slider_1 * 5 + slider_2\n\n\nwith gr.Blocks() as demo:\n    slider = gr.Slider(minimum=-10.2, maximum=15, label=\"Random Slider (Static)\", randomize=True)\n    slider_1 = gr.Slider(minimum=100, maximum=200, label=\"Random Slider (Input 1)\", randomize=True)\n    slider_2 = gr.Slider(minimum=10, maximum=23.2, label=\"Random Slider (Input 2)\", randomize=True)\n    slider_3 = gr.Slider(value=3, label=\"Non random slider\")\n    btn = gr.Button(\"Run\")\n    btn.click(func, inputs=[slider_1, slider_2], outputs=gr.Number())\n\nif __name__ == \"__main__\":\n    demo.launch()\n\n```\n    ```",
            "vector_context": "[Created at: 2025-03-24 13:18:21]\nGradio Demo: blocks_random_slider\n\n\n```\n!pip install -q gradio \n```\n\n\n```\n\nimport gradio as gr\n\n\ndef func(slider_1, slider_2):\n    return slider_1 * 5 + slider_2\n\n\nwith gr.Blocks() as demo:\n    slider = gr.Slider(minimum=-10.2, maximum=15, label=\"Random Slider (Static)\", randomize=True)\n    slider_1 = gr.Slider(minimum=100, maximum=200, label=\"Random Slider (Input 1)\", randomize=True)\n    slider_2 = gr.Slider(minimum=10, maximum=23.2, label=\"Random Slider (Input 2)\", randomize=True)\n    slider_3 = gr.Slider(value=3, label=\"Non random slider\")\n    btn = gr.Button(\"Run\")\n    btn.click(func, inputs=[slider_1, slider_2], outputs=gr.Number())\n\nif __name__ == \"__main__\":\n    demo.launch()\n\n```\n--New Chunk--\n[Created at: 2025-03-24 13:16:48]\n\u4e3b\u8981\u7279\u70b9\n\n\u8ba9\u6211\u4eec\u6765\u4ecb\u7ecd\u4e00\u4e0b Gradio \u6700\u53d7\u6b22\u8fce\u7684\u4e00\u4e9b\u529f\u80fd\uff01\u8fd9\u91cc\u662f Gradio \u7684\u4e3b\u8981\u7279\u70b9\uff1a\n\n1. [\u6dfb\u52a0\u793a\u4f8b\u8f93\u5165](#example-inputs)\n2. [\u4f20\u9012\u81ea\u5b9a\u4e49\u9519\u8bef\u6d88\u606f](#errors)\n3. [\u6dfb\u52a0\u63cf\u8ff0\u5185\u5bb9](#descriptive-content)\n4. [\u8bbe\u7f6e\u65d7\u6807](#flagging)\n5. [\u9884\u5904\u7406\u548c\u540e\u5904\u7406](#preprocessing-and-postprocessing)\n6. [\u6837\u5f0f\u5316\u6f14\u793a](#styling)\n7. [\u6392\u961f\u7528\u6237](#queuing)\n8. [\u8fed\u4ee3\u8f93\u51fa](#iterative-outputs)\n9. [\u8fdb\u5ea6\u6761](#progress-bars)\n10. [\u6279\u5904\u7406\u51fd\u6570](#batch-functions)\n11. [\u5728\u534f\u4f5c\u7b14\u8bb0\u672c\u4e0a\u8fd0\u884c](#colab-notebooks)\n\n## \u793a\u4f8b\u8f93\u5165\n\n\u60a8\u53ef\u4ee5\u63d0\u4f9b\u7528\u6237\u53ef\u4ee5\u8f7b\u677e\u52a0\u8f7d\u5230 \"Interface\" \u4e2d\u7684\u793a\u4f8b\u6570\u636e\u3002\u8fd9\u5bf9\u4e8e\u6f14\u793a\u6a21\u578b\u671f\u671b\u7684\u8f93\u5165\u7c7b\u578b\u4ee5\u53ca\u6f14\u793a\u6570\u636e\u96c6\u548c\u6a21\u578b\u4e00\u8d77\u63a2\u7d22\u7684\u65b9\u5f0f\u975e\u5e38\u6709\u5e2e\u52a9\u3002\u8981\u52a0\u8f7d\u793a\u4f8b\u6570\u636e\uff0c\u60a8\u53ef\u4ee5\u5c06\u5d4c\u5957\u5217\u8868\u63d0\u4f9b\u7ed9 Interface \u6784\u9020\u51fd\u6570\u7684 `examples=` \u5173\u952e\u5b57\u53c2\u6570\u3002\u5916\u90e8\u5217\u8868\u4e2d\u7684\u6bcf\u4e2a\u5b50\u5217\u8868\u8868\u793a\u4e00\u4e2a\u6570\u636e\u6837\u672c\uff0c\u5b50\u5217\u8868\u4e2d\u7684\u6bcf\u4e2a\u5143\u7d20\u8868\u793a\u6bcf\u4e2a\u8f93\u5165\u7ec4\u4ef6\u7684\u8f93\u5165\u3002\u6709\u5173\u6bcf\u4e2a\u7ec4\u4ef6\u7684\u793a\u4f8b\u6570\u636e\u683c\u5f0f\u5728[Docs](https://gradio.app/docs#components)\u4e2d\u6709\u8bf4\u660e\u3002\n\n$code_calculator\n$demo_calculator\n\n\u60a8\u53ef\u4ee5\u5c06\u5927\u578b\u6570\u636e\u96c6\u52a0\u8f7d\u5230\u793a\u4f8b\u4e2d\uff0c\u901a\u8fc7 Gradio \u6d4f\u89c8\u548c\u4e0e\u6570\u636e\u96c6\u8fdb\u884c\u4ea4\u4e92\u3002\u793a\u4f8b\u5c06\u81ea\u52a8\u5206\u9875\uff08\u53ef\u4ee5\u901a\u8fc7 Interface \u7684 `examples_per_page` \u53c2\u6570\u8fdb\u884c\u914d\u7f6e\uff09\u3002\n\n\u7ee7\u7eed\u4e86\u89e3\u793a\u4f8b\uff0c\u8bf7\u53c2\u9605[\u66f4\u591a\u793a\u4f8b](https://gradio.app/more-on-examples)\u6307\u5357\u3002\n\n## \u9519\u8bef\n\n\u60a8\u5e0c\u671b\u5411\u7528\u6237\u4f20\u9012\u81ea\u5b9a\u4e49\u9519\u8bef\u6d88\u606f\u3002\u4e3a\u6b64\uff0cwith `gr.Error(\"custom message\")` \u6765\u663e\u793a\u9519\u8bef\u6d88\u606f\u3002\u5982\u679c\u5728\u4e0a\u9762\u7684\u8ba1\u7b97\u5668\u793a\u4f8b\u4e2d\u5c1d\u8bd5\u9664\u4ee5\u96f6\uff0c\u5c06\u663e\u793a\u81ea\u5b9a\u4e49\u9519\u8bef\u6d88\u606f\u7684\u5f39\u51fa\u6a21\u6001\u7a97\u53e3\u3002\u4e86\u89e3\u6709\u5173\u9519\u8bef\u7684\u66f4\u591a\u4fe1\u606f\uff0c\u8bf7\u53c2\u9605[\u6587\u6863](https://gradio.app/docs#error)\u3002\n\n## \u63cf\u8ff0\u6027\u5185\u5bb9\n\n\u5728\u524d\u9762\u7684\u793a\u4f8b\u4e2d\uff0c\u60a8\u53ef\u80fd\u5df2\u7ecf\u6ce8\u610f\u5230 Interface \u6784\u9020\u51fd\u6570\u4e2d\u7684 `title=` \u548c `description=` \u5173\u952e\u5b57\u53c2\u6570\uff0c\u5e2e\u52a9\u7528\u6237\u4e86\u89e3\u60a8\u7684\u5e94\u7528\u7a0b\u5e8f\u3002\n\nInterface \u6784\u9020\u51fd\u6570\u4e2d\u6709\u4e09\u4e2a\u53c2\u6570\u7528\u4e8e\u6307\u5b9a\u6b64\u5185\u5bb9\u5e94\u653e\u7f6e\u5728\u54ea\u91cc\uff1a\n\n- `title`\uff1a\u63a5\u53d7\u6587\u672c\uff0c\u5e76\u53ef\u4ee5\u5c06\u5176\u663e\u793a\u5728\u754c\u9762\u7684\u9876\u90e8\uff0c\u4e5f\u5c06\u6210\u4e3a\u9875\u9762\u6807\u9898\u3002\n- `description`\uff1a\u63a5\u53d7\u6587\u672c\u3001Markdown \u6216 HTML\uff0c\u5e76\u5c06\u5176\u653e\u7f6e\u5728\u6807\u9898\u6b63\u4e0b\u65b9\u3002\n- `article`\uff1a\u4e5f\u63a5\u53d7\u6587\u672c\u3001Markdown \u6216 HTML\uff0c\u5e76\u5c06\u5176\u653e\u7f6e\u5728\u754c\u9762\u4e0b\u65b9\u3002\n\n![annotated](/assets/guides/annotated.png)\n\n\u5982\u679c\u60a8\u4f7f\u7528\u7684\u662f `Blocks` API\uff0c\u5219\u53ef\u4ee5 with `gr.Markdown(...)` \u6216 `gr.HTML(...)` \u7ec4\u4ef6\u5728\u4efb\u4f55\u4f4d\u7f6e\u63d2\u5165\u6587\u672c\u3001Markdown \u6216 HTML\uff0c\u5176\u4e2d\u63cf\u8ff0\u6027\u5185\u5bb9\u4f4d\u4e8e `Component` \u6784\u9020\u51fd\u6570\u5185\u90e8\u3002\n\n\u53e6\u4e00\u4e2a\u6709\u7528\u7684\u5173\u952e\u5b57\u53c2\u6570\u662f `label=`\uff0c\u5b83\u5b58\u5728\u4e8e\u6bcf\u4e2a `Component` \u4e2d\u3002\u8fd9\u4fee\u6539\u4e86\u6bcf\u4e2a `Component` \u9876\u90e8\u7684\u6807\u7b7e\u6587\u672c\u3002\u8fd8\u53ef\u4ee5\u4e3a\u8bf8\u5982 `Textbox` \u6216 `Radio` \u4e4b\u7c7b\u7684\u8868\u5355\u5143\u7d20\u6dfb\u52a0 `info=` \u5173\u952e\u5b57\u53c2\u6570\uff0c\u4ee5\u63d0\u4f9b\u6709\u5173\u5176\u7528\u6cd5\u7684\u8fdb\u4e00\u6b65\u4fe1\u606f\u3002\n\n```python\ngr.Number(label='\u5e74\u9f84', info='\u4ee5\u5e74\u4e3a\u5355\u4f4d\uff0c\u5fc5\u987b\u5927\u4e8e0')\n```\n\n## \u65d7\u6807\n\n\u9ed8\u8ba4\u60c5\u51b5\u4e0b\uff0c\"Interface\" \u5c06\u6709\u4e00\u4e2a \"Flag\" \u6309\u94ae\u3002\u5f53\u7528\u6237\u6d4b\u8bd5\u60a8\u7684 `Interface` \u65f6\uff0c\u5982\u679c\u770b\u5230\u6709\u8da3\u7684\u8f93\u51fa\uff0c\u4f8b\u5982\u9519\u8bef\u6216\u610f\u5916\u7684\u6a21\u578b\u884c\u4e3a\uff0c\u4ed6\u4eec\u53ef\u4ee5\u5c06\u8f93\u5165\u6807\u8bb0\u4e3a\u60a8\u8fdb\u884c\u67e5\u770b\u3002\u5728\u7531 `Interface` \u6784\u9020\u51fd\u6570\u7684 `flagging_dir=` \u53c2\u6570\u63d0\u4f9b\u7684\u76ee\u5f55\u4e2d\uff0c\u5c06\u8bb0\u5f55\u6807\u8bb0\u7684\u8f93\u5165\u5230\u4e00\u4e2a CSV \u6587\u4ef6\u4e2d\u3002\u5982\u679c\u754c\u9762\u6d89\u53ca\u6587\u4ef6\u6570\u636e\uff0c\u4f8b\u5982\u56fe\u50cf\u548c\u97f3\u9891\u7ec4\u4ef6\uff0c\u5c06\u521b\u5efa\u6587\u4ef6\u5939\u6765\u5b58\u50a8\u8fd9\u4e9b\u6807\u8bb0\u7684\u6570\u636e\u3002\n\n\u4f8b\u5982\uff0c\u5bf9\u4e8e\u4e0a\u9762\u663e\u793a\u7684\u8ba1\u7b97\u5668\u754c\u9762\uff0c\u6211\u4eec\u5c06\u5728\u4e0b\u9762\u7684\u65d7\u6807\u76ee\u5f55\u4e2d\u5b58\u50a8\u6807\u8bb0\u7684\u6570\u636e\uff1a\n\n```directory\n+-- calculator.py\n+-- flagged/\n|   +-- logs.csv\n```\n\n_flagged/logs.csv_\n\n```csv\nnum1,operation,num2,Output\n5,add,7,12\n6,subtract,1.5,4.5\n```\n\n\u4e0e\u65e9\u671f\u663e\u793a\u7684\u51b7\u8272\u754c\u9762\u76f8\u5bf9\u5e94\uff0c\u6211\u4eec\u5c06\u5728\u4e0b\u9762\u7684\u65d7\u6807\u76ee\u5f55\u4e2d\u5b58\u50a8\u6807\u8bb0\u7684\u6570\u636e\uff1a\n\n```directory\n+-- sepia.py\n+-- flagged/\n|   +-- logs.csv\n|   +-- im/\n|   |   +-- 0.png\n|   |   +-- 1.png\n|   +-- Output/\n|   |   +-- 0.png\n|   |   +-- 1.png\n```\n\n_flagged/logs.csv_\n\n```csv\nim,Output\nim/0.png,Output/0.png\nim/1.png,Output/1.png\n```\n\n\u5982\u679c\u60a8\u5e0c\u671b\u7528\u6237\u63d0\u4f9b\u65d7\u6807\u539f\u56e0\uff0c\u53ef\u4ee5\u5c06\u5b57\u7b26\u4e32\u5217\u8868\u4f20\u9012\u7ed9 Interface \u7684 `flagging_options` \u53c2\u6570\u3002\u7528\u6237\u5728\u8fdb\u884c\u65d7\u6807\u65f6\u5fc5\u987b\u9009\u62e9\u5176\u4e2d\u4e00\u4e2a\u5b57\u7b26\u4e32\uff0c\u8fd9\u5c06\u4f5c\u4e3a\u9644\u52a0\u5217\u4fdd\u5b58\u5230 CSV \u4e2d\u3002\n\n## \u9884\u5904\u7406\u548c\u540e\u5904\u7406 (Preprocessing and Postprocessing)\n\n![annotated](/assets/img/dataflow.svg)\n\n\u5982\u60a8\u6240\u89c1\uff0cGradio \u5305\u62ec\u53ef\u4ee5\u5904\u7406\u5404\u79cd\u4e0d\u540c\u6570\u636e\u7c7b\u578b\u7684\u7ec4\u4ef6\uff0c\u4f8b\u5982\u56fe\u50cf\u3001\u97f3\u9891\u548c\u89c6\u9891\u3002\u5927\u591a\u6570\u7ec4\u4ef6\u90fd\u53ef\u4ee5\u7528\u4f5c\u8f93\u5165\u6216\u8f93\u51fa\u3002\n\n\u5f53\u7ec4\u4ef6\u7528\u4f5c\u8f93\u5165\u65f6\uff0cGradio \u81ea\u52a8\u5904\u7406*\u9884\u5904\u7406*\uff0c\u5c06\u6570\u636e\u4ece\u7528\u6237\n--New Chunk--\n[Created at: 2025-03-24 13:16:48]\n\u4e0e\u5e38\u89c4\u51fd\u6570\u76f8\u540c\u7684\u65b9\u5f0f\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio\u3002\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\uff08\u865a\u62df\u7684\uff09\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5b83\u5728\u8f93\u51fa\u56fe\u50cf\u4e4b\u524d\u751f\u6210\u6570\u4e2a\u6b65\u9aa4\u7684\u566a\u97f3\uff1a\n\n$code_fake_diffusion\n$demo_fake_diffusion\n\n\u8bf7\u6ce8\u610f\uff0c\u6211\u4eec\u5728\u8fed\u4ee3\u5668\u4e2d\u6dfb\u52a0\u4e86 `time.sleep(1)`\uff0c\u4ee5\u521b\u5efa\u6b65\u9aa4\u4e4b\u95f4\u7684\u4eba\u5de5\u6682\u505c\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u89c2\u5bdf\u8fed\u4ee3\u5668\u7684\u6b65\u9aa4\uff08\u5728\u771f\u5b9e\u7684\u56fe\u50cf\u751f\u6210\u6a21\u578b\u4e2d\uff0c\u8fd9\u53ef\u80fd\u662f\u4e0d\u5fc5\u8981\u7684\uff09\u3002\n\n\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio **\u9700\u8981**\u5728\u5e95\u5c42 Interface \u6216 Blocks \u4e2d\u542f\u7528\u961f\u5217\uff08\u8bf7\u53c2\u9605\u4e0a\u9762\u7684\u961f\u5217\u90e8\u5206\uff09\u3002\n\n## \u8fdb\u5ea6\u6761\n\nGradio \u652f\u6301\u521b\u5efa\u81ea\u5b9a\u4e49\u8fdb\u5ea6\u6761\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u81ea\u5b9a\u4e49\u548c\u63a7\u5236\u5411\u7528\u6237\u663e\u793a\u7684\u8fdb\u5ea6\u66f4\u65b0\u3002\u8981\u542f\u7528\u6b64\u529f\u80fd\uff0c\u53ea\u9700\u4e3a\u65b9\u6cd5\u6dfb\u52a0\u4e00\u4e2a\u9ed8\u8ba4\u503c\u4e3a `gr.Progress` \u5b9e\u4f8b\u7684\u53c2\u6570\u5373\u53ef\u3002\u7136\u540e\uff0c\u60a8\u53ef\u4ee5\u76f4\u63a5\u8c03\u7528\u6b64\u5b9e\u4f8b\u5e76\u4f20\u5165 0 \u5230 1 \u4e4b\u95f4\u7684\u6d6e\u70b9\u6570\u6765\u66f4\u65b0\u8fdb\u5ea6\u7ea7\u522b\uff0c\u6216\u8005 with `Progress` \u5b9e\u4f8b\u7684 `tqdm()` \u65b9\u6cd5\u6765\u8ddf\u8e2a\u53ef\u8fed\u4ee3\u5bf9\u8c61\u4e0a\u7684\u8fdb\u5ea6\uff0c\u5982\u4e0b\u6240\u793a\u3002\u5fc5\u987b\u542f\u7528\u961f\u5217\u4ee5\u8fdb\u884c\u8fdb\u5ea6\u66f4\u65b0\u3002\n\n$code_progress_simple\n$demo_progress_simple\n\n\u5982\u679c\u60a8 with `tqdm` \u5e93\uff0c\u5e76\u4e14\u5e0c\u671b\u4ece\u51fd\u6570\u5185\u90e8\u7684\u4efb\u4f55 `tqdm.tqdm` \u81ea\u52a8\u62a5\u544a\u8fdb\u5ea6\u66f4\u65b0\uff0c\u8bf7\u5c06\u9ed8\u8ba4\u53c2\u6570\u8bbe\u7f6e\u4e3a `gr.Progress(track_tqdm=True)`\uff01\n\n## \u6279\u5904\u7406\u51fd\u6570 (Batch Functions)\n\nGradio \u652f\u6301\u4f20\u9012*\u6279\u5904\u7406*\u51fd\u6570\u3002\u6279\u5904\u7406\u51fd\u6570\u53ea\u662f\u63a5\u53d7\u8f93\u5165\u5217\u8868\u5e76\u8fd4\u56de\u9884\u6d4b\u5217\u8868\u7684\u51fd\u6570\u3002\n\n\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\u6279\u5904\u7406\u51fd\u6570\uff0c\u5b83\u63a5\u53d7\u4e24\u4e2a\u8f93\u5165\u5217\u8868\uff08\u4e00\u4e2a\u5355\u8bcd\u5217\u8868\u548c\u4e00\u4e2a\u6574\u6570\u5217\u8868\uff09\uff0c\u5e76\u8fd4\u56de\u4fee\u526a\u8fc7\u7684\u5355\u8bcd\u5217\u8868\u4f5c\u4e3a\u8f93\u51fa\uff1a\n\n```python\nimport time\n\ndef trim_words(words, lens):\n    trimmed_words = []\n    time.sleep(5)\n    for w, l in zip(words, lens):\n        trimmed_words.append(w[:int(l)])\n    return [trimmed_words]\n    for w, l in zip(words, lens):\n```\n\n\u4f7f\u7528\u6279\u5904\u7406\u51fd\u6570\u7684\u4f18\u70b9\u662f\uff0c\u5982\u679c\u542f\u7528\u4e86\u961f\u5217\uff0cGradio \u670d\u52a1\u5668\u53ef\u4ee5\u81ea\u52a8*\u6279\u5904\u7406*\u4f20\u5165\u7684\u8bf7\u6c42\u5e76\u5e76\u884c\u5904\u7406\u5b83\u4eec\uff0c\u4ece\u800c\u53ef\u80fd\u52a0\u5feb\u6f14\u793a\u901f\u5ea6\u3002\u4ee5\u4e0b\u662f Gradio \u4ee3\u7801\u7684\u793a\u4f8b\uff08\u8bf7\u6ce8\u610f `batch=True` \u548c `max_batch_size=16` - \u8fd9\u4e24\u4e2a\u53c2\u6570\u90fd\u53ef\u4ee5\u4f20\u9012\u7ed9\u4e8b\u4ef6\u89e6\u53d1\u5668\u6216 `Interface` \u7c7b\uff09\n\nwith `Interface`\uff1a\n\n```python\ndemo = gr.Interface(trim_words, [\"textbox\", \"number\"], [\"output\"],\n                    batch=True, max_batch_size=16)\ndemo.queue()\ndemo.launch()\n```\n\nwith `Blocks`\uff1a\n\n```python\nimport gradio as gr\n\nwith gr.Blocks() as demo:\n    with gr.Row():\n        word = gr.Textbox(label=\"word\")\n        leng = gr.Number(label=\"leng\")\n        output = gr.Textbox(label=\"Output\")\n    with gr.Row():\n        run = gr.Button()\n\n    event = run.click(trim_words, [word, leng], output, batch=True, max_batch_size=16)\n\ndemo.queue()\ndemo.launch()\n```\n\n\u5728\u4e0a\u9762\u7684\u793a\u4f8b\u4e2d\uff0c\u53ef\u4ee5\u5e76\u884c\u5904\u7406 16 \u4e2a\u8bf7\u6c42\uff08\u603b\u63a8\u7406\u65f6\u95f4\u4e3a 5 \u79d2\uff09\uff0c\u800c\u4e0d\u662f\u5206\u522b\u5904\u7406\u6bcf\u4e2a\u8bf7\u6c42\uff08\u603b\u63a8\u7406\u65f6\u95f4\u4e3a 80 \u79d2\uff09\u3002\u8bb8\u591a Hugging Face \u7684 `transformers` \u548c `diffusers` \u6a21\u578b\u5728 Gradio \u7684\u6279\u5904\u7406\u6a21\u5f0f\u4e0b\u81ea\u7136\u5de5\u4f5c\uff1a\u8fd9\u662f[\u4f7f\u7528\u6279\u5904\u7406\u751f\u6210\u56fe\u50cf\u7684\u793a\u4f8b\u6f14\u793a](https://github.com/gradio-app/gradio/blob/main/demo/diffusers_with_batching/run.py)\n\n\u6ce8\u610f\uff1a\u4f7f\u7528 Gradio \u7684\u6279\u5904\u7406\u51fd\u6570 **requires** \u5728\u5e95\u5c42 Interface \u6216 Blocks \u4e2d\u542f\u7528\u961f\u5217\uff08\u8bf7\u53c2\u9605\u4e0a\u9762\u7684\u961f\u5217\u90e8\u5206\uff09\u3002\n\n## Gradio \u7b14\u8bb0\u672c (Colab Notebooks)\n\nGradio \u53ef\u4ee5\u5728\u4efb\u4f55\u8fd0\u884c Python \u7684\u5730\u65b9\u8fd0\u884c\uff0c\u5305\u62ec\u672c\u5730 Jupyter \u7b14\u8bb0\u672c\u548c\u534f\u4f5c\u7b14\u8bb0\u672c\uff0c\u5982[Google Colab](https://colab.research.google.com/)\u3002\u5bf9\u4e8e\u672c\u5730 Jupyter \u7b14\u8bb0\u672c\u548c Google Colab \u7b14\u8bb0\u672c\uff0cGradio \u5728\u672c\u5730\u670d\u52a1\u5668\u4e0a\u8fd0\u884c\uff0c\u60a8\u53ef\u4ee5\u5728\u6d4f\u89c8\u5668\u4e2d\u4e0e\u4e4b\u4ea4\u4e92\u3002\uff08\u6ce8\u610f\uff1a\u5bf9\u4e8e Google Colab\uff0c\u8fd9\u662f\u901a\u8fc7[\u670d\u52a1\u5de5\u4f5c\u5668\u96a7\u9053](https://github.com/tensorflow/tensorboard/blob/master/docs/design/colab_integration.md)\u5b9e\u73b0\u7684\uff0c\u60a8\u7684\u6d4f\u89c8\u5668\u9700\u8981\u542f\u7528 cookies\u3002\uff09\u5bf9\u4e8e\u5176\u4ed6\u8fdc\u7a0b\u7b14\u8bb0\u672c\uff0cGradio \u4e5f\u5c06\u5728\u670d\u52a1\u5668\u4e0a\u8fd0\u884c\uff0c\u4f46\u60a8\u9700\u8981\u4f7f\u7528[SSH \u96a7\u9053](https://coderwall.com/p/ohk6cg/remote-access-to-ipython-notebooks-via-ssh)\u5728\u672c\u5730\u6d4f\u89c8\u5668\u4e2d\u67e5\u770b\u5e94\u7528\u7a0b\u5e8f\u3002\u901a\u5e38\uff0c\u66f4\u7b80\u5355\u7684\u9009\u62e9\u662f\u4f7f\u7528 Gradio \u5185\u7f6e\u7684\u516c\u5171\u94fe\u63a5\uff0c[\u5728\u4e0b\u4e00\u7bc7\u6307\u5357\u4e2d\u8ba8\u8bba](/sharing-your-app/#sharing-demos)\u3002"
        }
    },
    {
        "sample_idx": 86,
        "question": "What is the label of the non-random slider in the Gradio demo?",
        "answer": "The label is 'Non random slider'.",
        "rag_answer": "The label of the non-random slider in the Gradio demo is \"Non random slider\".",
        "rag_score": 5,
        "rag_feedback": "The system's response is completely correct, accurate, and factual. It directly answers the question by stating the label of the non-random slider in the Gradio demo, which is 'Non random slider'. The response is clear and concise, and it matches the expected answer.",
        "rag_context": {
            "kg_context": "-----Entities-----\n    ```csv\n    id,\tentity,\ttype,\tdescription,\trankcreated_at\n1,\tGradio Demo,event,Gradio Demo is an event that showcases the functionality of Gradio's blocks_random_slider.,8,2025-03-24 13:18:47\n2,\tslider_1,technology,slider_1 is a specific slider used in Gradio's demo to create interactive interfaces.,1,2025-03-24 13:18:47\n3,\tslider_2,technology,slider_2 is a specific slider used in Gradio's demo to create interactive interfaces.,1,2025-03-24 13:18:47\n4,\tslider_3,technology,slider_3 is a specific slider used in Gradio's demo to create interactive interfaces.,1,2025-03-24 13:18:47\n5,\tslider_1,technology,slider_1 is a specific slider used in Gradio's demo to create interactive interfaces.,1,UNKNOWN\n6,\tslider_2,technology,slider_2 is a specific slider used in Gradio's demo to create interactive interfaces.,1,UNKNOWN\n7,\tslider_3,technology,slider_3 is a specific slider used in Gradio's demo to create interactive interfaces.,1,UNKNOWN\n    ```\n    -----Relationships-----\n    ```csv\n    id,\tsource,\ttarget,\tdescription,\tkeywords,\tweight,\trank,\tcreated_at\n1,\tGradio Demo,slider_1,slider_1 is used in Gradio Demo to create interactive interfaces.,technology, event,6.0,9,2025-03-24 13:18:47\n2,\tGradio Demo,slider_2,slider_2 is used in Gradio Demo to create interactive interfaces.,technology, event,6.0,9,2025-03-24 13:18:47\n3,\tGradio Demo,slider_3,slider_3 is used in Gradio Demo to create interactive interfaces.,technology, event,6.0,9,2025-03-24 13:18:47\n4,\tGradio Demo,slider_1,slider_1 is used in Gradio Demo to create interactive interfaces.,technology, event,6.0,9,UNKNOWN\n5,\tGradio Demo,slider_2,slider_2 is used in Gradio Demo to create interactive interfaces.,technology, event,6.0,9,UNKNOWN\n6,\tGradio Demo,slider_3,slider_3 is used in Gradio Demo to create interactive interfaces.,technology, event,6.0,9,UNKNOWN\n    ```\n    -----Sources-----\n    ```csv\n    id,\tcontent\n1,\tGradio Demo: blocks_random_slider\n\n\n```\n!pip install -q gradio \n```\n\n\n```\n\nimport gradio as gr\n\n\ndef func(slider_1, slider_2):\n    return slider_1 * 5 + slider_2\n\n\nwith gr.Blocks() as demo:\n    slider = gr.Slider(minimum=-10.2, maximum=15, label=\"Random Slider (Static)\", randomize=True)\n    slider_1 = gr.Slider(minimum=100, maximum=200, label=\"Random Slider (Input 1)\", randomize=True)\n    slider_2 = gr.Slider(minimum=10, maximum=23.2, label=\"Random Slider (Input 2)\", randomize=True)\n    slider_3 = gr.Slider(value=3, label=\"Non random slider\")\n    btn = gr.Button(\"Run\")\n    btn.click(func, inputs=[slider_1, slider_2], outputs=gr.Number())\n\nif __name__ == \"__main__\":\n    demo.launch()\n\n```\n    ```",
            "vector_context": "[Created at: 2025-03-24 13:18:21]\nGradio Demo: blocks_random_slider\n\n\n```\n!pip install -q gradio \n```\n\n\n```\n\nimport gradio as gr\n\n\ndef func(slider_1, slider_2):\n    return slider_1 * 5 + slider_2\n\n\nwith gr.Blocks() as demo:\n    slider = gr.Slider(minimum=-10.2, maximum=15, label=\"Random Slider (Static)\", randomize=True)\n    slider_1 = gr.Slider(minimum=100, maximum=200, label=\"Random Slider (Input 1)\", randomize=True)\n    slider_2 = gr.Slider(minimum=10, maximum=23.2, label=\"Random Slider (Input 2)\", randomize=True)\n    slider_3 = gr.Slider(value=3, label=\"Non random slider\")\n    btn = gr.Button(\"Run\")\n    btn.click(func, inputs=[slider_1, slider_2], outputs=gr.Number())\n\nif __name__ == \"__main__\":\n    demo.launch()\n\n```\n--New Chunk--\n[Created at: 2025-03-24 13:16:48]\n\u4e3b\u8981\u7279\u70b9\n\n\u8ba9\u6211\u4eec\u6765\u4ecb\u7ecd\u4e00\u4e0b Gradio \u6700\u53d7\u6b22\u8fce\u7684\u4e00\u4e9b\u529f\u80fd\uff01\u8fd9\u91cc\u662f Gradio \u7684\u4e3b\u8981\u7279\u70b9\uff1a\n\n1. [\u6dfb\u52a0\u793a\u4f8b\u8f93\u5165](#example-inputs)\n2. [\u4f20\u9012\u81ea\u5b9a\u4e49\u9519\u8bef\u6d88\u606f](#errors)\n3. [\u6dfb\u52a0\u63cf\u8ff0\u5185\u5bb9](#descriptive-content)\n4. [\u8bbe\u7f6e\u65d7\u6807](#flagging)\n5. [\u9884\u5904\u7406\u548c\u540e\u5904\u7406](#preprocessing-and-postprocessing)\n6. [\u6837\u5f0f\u5316\u6f14\u793a](#styling)\n7. [\u6392\u961f\u7528\u6237](#queuing)\n8. [\u8fed\u4ee3\u8f93\u51fa](#iterative-outputs)\n9. [\u8fdb\u5ea6\u6761](#progress-bars)\n10. [\u6279\u5904\u7406\u51fd\u6570](#batch-functions)\n11. [\u5728\u534f\u4f5c\u7b14\u8bb0\u672c\u4e0a\u8fd0\u884c](#colab-notebooks)\n\n## \u793a\u4f8b\u8f93\u5165\n\n\u60a8\u53ef\u4ee5\u63d0\u4f9b\u7528\u6237\u53ef\u4ee5\u8f7b\u677e\u52a0\u8f7d\u5230 \"Interface\" \u4e2d\u7684\u793a\u4f8b\u6570\u636e\u3002\u8fd9\u5bf9\u4e8e\u6f14\u793a\u6a21\u578b\u671f\u671b\u7684\u8f93\u5165\u7c7b\u578b\u4ee5\u53ca\u6f14\u793a\u6570\u636e\u96c6\u548c\u6a21\u578b\u4e00\u8d77\u63a2\u7d22\u7684\u65b9\u5f0f\u975e\u5e38\u6709\u5e2e\u52a9\u3002\u8981\u52a0\u8f7d\u793a\u4f8b\u6570\u636e\uff0c\u60a8\u53ef\u4ee5\u5c06\u5d4c\u5957\u5217\u8868\u63d0\u4f9b\u7ed9 Interface \u6784\u9020\u51fd\u6570\u7684 `examples=` \u5173\u952e\u5b57\u53c2\u6570\u3002\u5916\u90e8\u5217\u8868\u4e2d\u7684\u6bcf\u4e2a\u5b50\u5217\u8868\u8868\u793a\u4e00\u4e2a\u6570\u636e\u6837\u672c\uff0c\u5b50\u5217\u8868\u4e2d\u7684\u6bcf\u4e2a\u5143\u7d20\u8868\u793a\u6bcf\u4e2a\u8f93\u5165\u7ec4\u4ef6\u7684\u8f93\u5165\u3002\u6709\u5173\u6bcf\u4e2a\u7ec4\u4ef6\u7684\u793a\u4f8b\u6570\u636e\u683c\u5f0f\u5728[Docs](https://gradio.app/docs#components)\u4e2d\u6709\u8bf4\u660e\u3002\n\n$code_calculator\n$demo_calculator\n\n\u60a8\u53ef\u4ee5\u5c06\u5927\u578b\u6570\u636e\u96c6\u52a0\u8f7d\u5230\u793a\u4f8b\u4e2d\uff0c\u901a\u8fc7 Gradio \u6d4f\u89c8\u548c\u4e0e\u6570\u636e\u96c6\u8fdb\u884c\u4ea4\u4e92\u3002\u793a\u4f8b\u5c06\u81ea\u52a8\u5206\u9875\uff08\u53ef\u4ee5\u901a\u8fc7 Interface \u7684 `examples_per_page` \u53c2\u6570\u8fdb\u884c\u914d\u7f6e\uff09\u3002\n\n\u7ee7\u7eed\u4e86\u89e3\u793a\u4f8b\uff0c\u8bf7\u53c2\u9605[\u66f4\u591a\u793a\u4f8b](https://gradio.app/more-on-examples)\u6307\u5357\u3002\n\n## \u9519\u8bef\n\n\u60a8\u5e0c\u671b\u5411\u7528\u6237\u4f20\u9012\u81ea\u5b9a\u4e49\u9519\u8bef\u6d88\u606f\u3002\u4e3a\u6b64\uff0cwith `gr.Error(\"custom message\")` \u6765\u663e\u793a\u9519\u8bef\u6d88\u606f\u3002\u5982\u679c\u5728\u4e0a\u9762\u7684\u8ba1\u7b97\u5668\u793a\u4f8b\u4e2d\u5c1d\u8bd5\u9664\u4ee5\u96f6\uff0c\u5c06\u663e\u793a\u81ea\u5b9a\u4e49\u9519\u8bef\u6d88\u606f\u7684\u5f39\u51fa\u6a21\u6001\u7a97\u53e3\u3002\u4e86\u89e3\u6709\u5173\u9519\u8bef\u7684\u66f4\u591a\u4fe1\u606f\uff0c\u8bf7\u53c2\u9605[\u6587\u6863](https://gradio.app/docs#error)\u3002\n\n## \u63cf\u8ff0\u6027\u5185\u5bb9\n\n\u5728\u524d\u9762\u7684\u793a\u4f8b\u4e2d\uff0c\u60a8\u53ef\u80fd\u5df2\u7ecf\u6ce8\u610f\u5230 Interface \u6784\u9020\u51fd\u6570\u4e2d\u7684 `title=` \u548c `description=` \u5173\u952e\u5b57\u53c2\u6570\uff0c\u5e2e\u52a9\u7528\u6237\u4e86\u89e3\u60a8\u7684\u5e94\u7528\u7a0b\u5e8f\u3002\n\nInterface \u6784\u9020\u51fd\u6570\u4e2d\u6709\u4e09\u4e2a\u53c2\u6570\u7528\u4e8e\u6307\u5b9a\u6b64\u5185\u5bb9\u5e94\u653e\u7f6e\u5728\u54ea\u91cc\uff1a\n\n- `title`\uff1a\u63a5\u53d7\u6587\u672c\uff0c\u5e76\u53ef\u4ee5\u5c06\u5176\u663e\u793a\u5728\u754c\u9762\u7684\u9876\u90e8\uff0c\u4e5f\u5c06\u6210\u4e3a\u9875\u9762\u6807\u9898\u3002\n- `description`\uff1a\u63a5\u53d7\u6587\u672c\u3001Markdown \u6216 HTML\uff0c\u5e76\u5c06\u5176\u653e\u7f6e\u5728\u6807\u9898\u6b63\u4e0b\u65b9\u3002\n- `article`\uff1a\u4e5f\u63a5\u53d7\u6587\u672c\u3001Markdown \u6216 HTML\uff0c\u5e76\u5c06\u5176\u653e\u7f6e\u5728\u754c\u9762\u4e0b\u65b9\u3002\n\n![annotated](/assets/guides/annotated.png)\n\n\u5982\u679c\u60a8\u4f7f\u7528\u7684\u662f `Blocks` API\uff0c\u5219\u53ef\u4ee5 with `gr.Markdown(...)` \u6216 `gr.HTML(...)` \u7ec4\u4ef6\u5728\u4efb\u4f55\u4f4d\u7f6e\u63d2\u5165\u6587\u672c\u3001Markdown \u6216 HTML\uff0c\u5176\u4e2d\u63cf\u8ff0\u6027\u5185\u5bb9\u4f4d\u4e8e `Component` \u6784\u9020\u51fd\u6570\u5185\u90e8\u3002\n\n\u53e6\u4e00\u4e2a\u6709\u7528\u7684\u5173\u952e\u5b57\u53c2\u6570\u662f `label=`\uff0c\u5b83\u5b58\u5728\u4e8e\u6bcf\u4e2a `Component` \u4e2d\u3002\u8fd9\u4fee\u6539\u4e86\u6bcf\u4e2a `Component` \u9876\u90e8\u7684\u6807\u7b7e\u6587\u672c\u3002\u8fd8\u53ef\u4ee5\u4e3a\u8bf8\u5982 `Textbox` \u6216 `Radio` \u4e4b\u7c7b\u7684\u8868\u5355\u5143\u7d20\u6dfb\u52a0 `info=` \u5173\u952e\u5b57\u53c2\u6570\uff0c\u4ee5\u63d0\u4f9b\u6709\u5173\u5176\u7528\u6cd5\u7684\u8fdb\u4e00\u6b65\u4fe1\u606f\u3002\n\n```python\ngr.Number(label='\u5e74\u9f84', info='\u4ee5\u5e74\u4e3a\u5355\u4f4d\uff0c\u5fc5\u987b\u5927\u4e8e0')\n```\n\n## \u65d7\u6807\n\n\u9ed8\u8ba4\u60c5\u51b5\u4e0b\uff0c\"Interface\" \u5c06\u6709\u4e00\u4e2a \"Flag\" \u6309\u94ae\u3002\u5f53\u7528\u6237\u6d4b\u8bd5\u60a8\u7684 `Interface` \u65f6\uff0c\u5982\u679c\u770b\u5230\u6709\u8da3\u7684\u8f93\u51fa\uff0c\u4f8b\u5982\u9519\u8bef\u6216\u610f\u5916\u7684\u6a21\u578b\u884c\u4e3a\uff0c\u4ed6\u4eec\u53ef\u4ee5\u5c06\u8f93\u5165\u6807\u8bb0\u4e3a\u60a8\u8fdb\u884c\u67e5\u770b\u3002\u5728\u7531 `Interface` \u6784\u9020\u51fd\u6570\u7684 `flagging_dir=` \u53c2\u6570\u63d0\u4f9b\u7684\u76ee\u5f55\u4e2d\uff0c\u5c06\u8bb0\u5f55\u6807\u8bb0\u7684\u8f93\u5165\u5230\u4e00\u4e2a CSV \u6587\u4ef6\u4e2d\u3002\u5982\u679c\u754c\u9762\u6d89\u53ca\u6587\u4ef6\u6570\u636e\uff0c\u4f8b\u5982\u56fe\u50cf\u548c\u97f3\u9891\u7ec4\u4ef6\uff0c\u5c06\u521b\u5efa\u6587\u4ef6\u5939\u6765\u5b58\u50a8\u8fd9\u4e9b\u6807\u8bb0\u7684\u6570\u636e\u3002\n\n\u4f8b\u5982\uff0c\u5bf9\u4e8e\u4e0a\u9762\u663e\u793a\u7684\u8ba1\u7b97\u5668\u754c\u9762\uff0c\u6211\u4eec\u5c06\u5728\u4e0b\u9762\u7684\u65d7\u6807\u76ee\u5f55\u4e2d\u5b58\u50a8\u6807\u8bb0\u7684\u6570\u636e\uff1a\n\n```directory\n+-- calculator.py\n+-- flagged/\n|   +-- logs.csv\n```\n\n_flagged/logs.csv_\n\n```csv\nnum1,operation,num2,Output\n5,add,7,12\n6,subtract,1.5,4.5\n```\n\n\u4e0e\u65e9\u671f\u663e\u793a\u7684\u51b7\u8272\u754c\u9762\u76f8\u5bf9\u5e94\uff0c\u6211\u4eec\u5c06\u5728\u4e0b\u9762\u7684\u65d7\u6807\u76ee\u5f55\u4e2d\u5b58\u50a8\u6807\u8bb0\u7684\u6570\u636e\uff1a\n\n```directory\n+-- sepia.py\n+-- flagged/\n|   +-- logs.csv\n|   +-- im/\n|   |   +-- 0.png\n|   |   +-- 1.png\n|   +-- Output/\n|   |   +-- 0.png\n|   |   +-- 1.png\n```\n\n_flagged/logs.csv_\n\n```csv\nim,Output\nim/0.png,Output/0.png\nim/1.png,Output/1.png\n```\n\n\u5982\u679c\u60a8\u5e0c\u671b\u7528\u6237\u63d0\u4f9b\u65d7\u6807\u539f\u56e0\uff0c\u53ef\u4ee5\u5c06\u5b57\u7b26\u4e32\u5217\u8868\u4f20\u9012\u7ed9 Interface \u7684 `flagging_options` \u53c2\u6570\u3002\u7528\u6237\u5728\u8fdb\u884c\u65d7\u6807\u65f6\u5fc5\u987b\u9009\u62e9\u5176\u4e2d\u4e00\u4e2a\u5b57\u7b26\u4e32\uff0c\u8fd9\u5c06\u4f5c\u4e3a\u9644\u52a0\u5217\u4fdd\u5b58\u5230 CSV \u4e2d\u3002\n\n## \u9884\u5904\u7406\u548c\u540e\u5904\u7406 (Preprocessing and Postprocessing)\n\n![annotated](/assets/img/dataflow.svg)\n\n\u5982\u60a8\u6240\u89c1\uff0cGradio \u5305\u62ec\u53ef\u4ee5\u5904\u7406\u5404\u79cd\u4e0d\u540c\u6570\u636e\u7c7b\u578b\u7684\u7ec4\u4ef6\uff0c\u4f8b\u5982\u56fe\u50cf\u3001\u97f3\u9891\u548c\u89c6\u9891\u3002\u5927\u591a\u6570\u7ec4\u4ef6\u90fd\u53ef\u4ee5\u7528\u4f5c\u8f93\u5165\u6216\u8f93\u51fa\u3002\n\n\u5f53\u7ec4\u4ef6\u7528\u4f5c\u8f93\u5165\u65f6\uff0cGradio \u81ea\u52a8\u5904\u7406*\u9884\u5904\u7406*\uff0c\u5c06\u6570\u636e\u4ece\u7528\u6237\n--New Chunk--\n[Created at: 2025-03-24 13:16:48]\n\u4e0e\u5e38\u89c4\u51fd\u6570\u76f8\u540c\u7684\u65b9\u5f0f\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio\u3002\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\uff08\u865a\u62df\u7684\uff09\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5b83\u5728\u8f93\u51fa\u56fe\u50cf\u4e4b\u524d\u751f\u6210\u6570\u4e2a\u6b65\u9aa4\u7684\u566a\u97f3\uff1a\n\n$code_fake_diffusion\n$demo_fake_diffusion\n\n\u8bf7\u6ce8\u610f\uff0c\u6211\u4eec\u5728\u8fed\u4ee3\u5668\u4e2d\u6dfb\u52a0\u4e86 `time.sleep(1)`\uff0c\u4ee5\u521b\u5efa\u6b65\u9aa4\u4e4b\u95f4\u7684\u4eba\u5de5\u6682\u505c\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u89c2\u5bdf\u8fed\u4ee3\u5668\u7684\u6b65\u9aa4\uff08\u5728\u771f\u5b9e\u7684\u56fe\u50cf\u751f\u6210\u6a21\u578b\u4e2d\uff0c\u8fd9\u53ef\u80fd\u662f\u4e0d\u5fc5\u8981\u7684\uff09\u3002\n\n\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio **\u9700\u8981**\u5728\u5e95\u5c42 Interface \u6216 Blocks \u4e2d\u542f\u7528\u961f\u5217\uff08\u8bf7\u53c2\u9605\u4e0a\u9762\u7684\u961f\u5217\u90e8\u5206\uff09\u3002\n\n## \u8fdb\u5ea6\u6761\n\nGradio \u652f\u6301\u521b\u5efa\u81ea\u5b9a\u4e49\u8fdb\u5ea6\u6761\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u81ea\u5b9a\u4e49\u548c\u63a7\u5236\u5411\u7528\u6237\u663e\u793a\u7684\u8fdb\u5ea6\u66f4\u65b0\u3002\u8981\u542f\u7528\u6b64\u529f\u80fd\uff0c\u53ea\u9700\u4e3a\u65b9\u6cd5\u6dfb\u52a0\u4e00\u4e2a\u9ed8\u8ba4\u503c\u4e3a `gr.Progress` \u5b9e\u4f8b\u7684\u53c2\u6570\u5373\u53ef\u3002\u7136\u540e\uff0c\u60a8\u53ef\u4ee5\u76f4\u63a5\u8c03\u7528\u6b64\u5b9e\u4f8b\u5e76\u4f20\u5165 0 \u5230 1 \u4e4b\u95f4\u7684\u6d6e\u70b9\u6570\u6765\u66f4\u65b0\u8fdb\u5ea6\u7ea7\u522b\uff0c\u6216\u8005 with `Progress` \u5b9e\u4f8b\u7684 `tqdm()` \u65b9\u6cd5\u6765\u8ddf\u8e2a\u53ef\u8fed\u4ee3\u5bf9\u8c61\u4e0a\u7684\u8fdb\u5ea6\uff0c\u5982\u4e0b\u6240\u793a\u3002\u5fc5\u987b\u542f\u7528\u961f\u5217\u4ee5\u8fdb\u884c\u8fdb\u5ea6\u66f4\u65b0\u3002\n\n$code_progress_simple\n$demo_progress_simple\n\n\u5982\u679c\u60a8 with `tqdm` \u5e93\uff0c\u5e76\u4e14\u5e0c\u671b\u4ece\u51fd\u6570\u5185\u90e8\u7684\u4efb\u4f55 `tqdm.tqdm` \u81ea\u52a8\u62a5\u544a\u8fdb\u5ea6\u66f4\u65b0\uff0c\u8bf7\u5c06\u9ed8\u8ba4\u53c2\u6570\u8bbe\u7f6e\u4e3a `gr.Progress(track_tqdm=True)`\uff01\n\n## \u6279\u5904\u7406\u51fd\u6570 (Batch Functions)\n\nGradio \u652f\u6301\u4f20\u9012*\u6279\u5904\u7406*\u51fd\u6570\u3002\u6279\u5904\u7406\u51fd\u6570\u53ea\u662f\u63a5\u53d7\u8f93\u5165\u5217\u8868\u5e76\u8fd4\u56de\u9884\u6d4b\u5217\u8868\u7684\u51fd\u6570\u3002\n\n\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\u6279\u5904\u7406\u51fd\u6570\uff0c\u5b83\u63a5\u53d7\u4e24\u4e2a\u8f93\u5165\u5217\u8868\uff08\u4e00\u4e2a\u5355\u8bcd\u5217\u8868\u548c\u4e00\u4e2a\u6574\u6570\u5217\u8868\uff09\uff0c\u5e76\u8fd4\u56de\u4fee\u526a\u8fc7\u7684\u5355\u8bcd\u5217\u8868\u4f5c\u4e3a\u8f93\u51fa\uff1a\n\n```python\nimport time\n\ndef trim_words(words, lens):\n    trimmed_words = []\n    time.sleep(5)\n    for w, l in zip(words, lens):\n        trimmed_words.append(w[:int(l)])\n    return [trimmed_words]\n    for w, l in zip(words, lens):\n```\n\n\u4f7f\u7528\u6279\u5904\u7406\u51fd\u6570\u7684\u4f18\u70b9\u662f\uff0c\u5982\u679c\u542f\u7528\u4e86\u961f\u5217\uff0cGradio \u670d\u52a1\u5668\u53ef\u4ee5\u81ea\u52a8*\u6279\u5904\u7406*\u4f20\u5165\u7684\u8bf7\u6c42\u5e76\u5e76\u884c\u5904\u7406\u5b83\u4eec\uff0c\u4ece\u800c\u53ef\u80fd\u52a0\u5feb\u6f14\u793a\u901f\u5ea6\u3002\u4ee5\u4e0b\u662f Gradio \u4ee3\u7801\u7684\u793a\u4f8b\uff08\u8bf7\u6ce8\u610f `batch=True` \u548c `max_batch_size=16` - \u8fd9\u4e24\u4e2a\u53c2\u6570\u90fd\u53ef\u4ee5\u4f20\u9012\u7ed9\u4e8b\u4ef6\u89e6\u53d1\u5668\u6216 `Interface` \u7c7b\uff09\n\nwith `Interface`\uff1a\n\n```python\ndemo = gr.Interface(trim_words, [\"textbox\", \"number\"], [\"output\"],\n                    batch=True, max_batch_size=16)\ndemo.queue()\ndemo.launch()\n```\n\nwith `Blocks`\uff1a\n\n```python\nimport gradio as gr\n\nwith gr.Blocks() as demo:\n    with gr.Row():\n        word = gr.Textbox(label=\"word\")\n        leng = gr.Number(label=\"leng\")\n        output = gr.Textbox(label=\"Output\")\n    with gr.Row():\n        run = gr.Button()\n\n    event = run.click(trim_words, [word, leng], output, batch=True, max_batch_size=16)\n\ndemo.queue()\ndemo.launch()\n```\n\n\u5728\u4e0a\u9762\u7684\u793a\u4f8b\u4e2d\uff0c\u53ef\u4ee5\u5e76\u884c\u5904\u7406 16 \u4e2a\u8bf7\u6c42\uff08\u603b\u63a8\u7406\u65f6\u95f4\u4e3a 5 \u79d2\uff09\uff0c\u800c\u4e0d\u662f\u5206\u522b\u5904\u7406\u6bcf\u4e2a\u8bf7\u6c42\uff08\u603b\u63a8\u7406\u65f6\u95f4\u4e3a 80 \u79d2\uff09\u3002\u8bb8\u591a Hugging Face \u7684 `transformers` \u548c `diffusers` \u6a21\u578b\u5728 Gradio \u7684\u6279\u5904\u7406\u6a21\u5f0f\u4e0b\u81ea\u7136\u5de5\u4f5c\uff1a\u8fd9\u662f[\u4f7f\u7528\u6279\u5904\u7406\u751f\u6210\u56fe\u50cf\u7684\u793a\u4f8b\u6f14\u793a](https://github.com/gradio-app/gradio/blob/main/demo/diffusers_with_batching/run.py)\n\n\u6ce8\u610f\uff1a\u4f7f\u7528 Gradio \u7684\u6279\u5904\u7406\u51fd\u6570 **requires** \u5728\u5e95\u5c42 Interface \u6216 Blocks \u4e2d\u542f\u7528\u961f\u5217\uff08\u8bf7\u53c2\u9605\u4e0a\u9762\u7684\u961f\u5217\u90e8\u5206\uff09\u3002\n\n## Gradio \u7b14\u8bb0\u672c (Colab Notebooks)\n\nGradio \u53ef\u4ee5\u5728\u4efb\u4f55\u8fd0\u884c Python \u7684\u5730\u65b9\u8fd0\u884c\uff0c\u5305\u62ec\u672c\u5730 Jupyter \u7b14\u8bb0\u672c\u548c\u534f\u4f5c\u7b14\u8bb0\u672c\uff0c\u5982[Google Colab](https://colab.research.google.com/)\u3002\u5bf9\u4e8e\u672c\u5730 Jupyter \u7b14\u8bb0\u672c\u548c Google Colab \u7b14\u8bb0\u672c\uff0cGradio \u5728\u672c\u5730\u670d\u52a1\u5668\u4e0a\u8fd0\u884c\uff0c\u60a8\u53ef\u4ee5\u5728\u6d4f\u89c8\u5668\u4e2d\u4e0e\u4e4b\u4ea4\u4e92\u3002\uff08\u6ce8\u610f\uff1a\u5bf9\u4e8e Google Colab\uff0c\u8fd9\u662f\u901a\u8fc7[\u670d\u52a1\u5de5\u4f5c\u5668\u96a7\u9053](https://github.com/tensorflow/tensorboard/blob/master/docs/design/colab_integration.md)\u5b9e\u73b0\u7684\uff0c\u60a8\u7684\u6d4f\u89c8\u5668\u9700\u8981\u542f\u7528 cookies\u3002\uff09\u5bf9\u4e8e\u5176\u4ed6\u8fdc\u7a0b\u7b14\u8bb0\u672c\uff0cGradio \u4e5f\u5c06\u5728\u670d\u52a1\u5668\u4e0a\u8fd0\u884c\uff0c\u4f46\u60a8\u9700\u8981\u4f7f\u7528[SSH \u96a7\u9053](https://coderwall.com/p/ohk6cg/remote-access-to-ipython-notebooks-via-ssh)\u5728\u672c\u5730\u6d4f\u89c8\u5668\u4e2d\u67e5\u770b\u5e94\u7528\u7a0b\u5e8f\u3002\u901a\u5e38\uff0c\u66f4\u7b80\u5355\u7684\u9009\u62e9\u662f\u4f7f\u7528 Gradio \u5185\u7f6e\u7684\u516c\u5171\u94fe\u63a5\uff0c[\u5728\u4e0b\u4e00\u7bc7\u6307\u5357\u4e2d\u8ba8\u8bba](/sharing-your-app/#sharing-demos)\u3002"
        }
    },
    {
        "sample_idx": 87,
        "question": "What is the default value of the 'Non random slider' in the Gradio demo?",
        "answer": "The default value is 3.",
        "rag_answer": "The default value of the 'Non random slider' in the Gradio demo is 3.",
        "rag_score": 5,
        "rag_feedback": "The system's response is completely correct, accurate, and factual. It directly answers the question by stating that the default value of the 'Non random slider' in the Gradio demo is 3, which is supported by the provided code snippet.",
        "rag_context": {
            "kg_context": "-----Entities-----\n    ```csv\n    id,\tentity,\ttype,\tdescription,\trankcreated_at\n1,\tGradio,organization,Gradio is a platform that supports state in Blocks, providing features such as global state and session state.<SEP>Gradio is an interface that provides various features for demonstrating models, including adding example inputs, custom error messages, descriptive content, flagging, and more.<SEP>Gradio is an organization that provides a platform for building and deploying machine learning models.<SEP>Gradio is an organization that provides a platform for creating and deploying machine learning models.<SEP>Gradio is an organization that provides a demo for blocks_random_slider, and its library is used to create interactive interfaces.,36,2025-03-24 13:18:47\n2,\tGradio Demo,event,Gradio Demo is an event that showcases the functionality of Gradio's blocks_random_slider.,8,2025-03-24 13:18:47\n3,\tblocks_random_slider,category,blocks_random_slider is a category of demo provided by Gradio, which includes interactive sliders.,1,2025-03-24 13:18:47\n4,\tslider_1,technology,slider_1 is a specific slider used in Gradio's demo to create interactive interfaces.,1,2025-03-24 13:18:47\n5,\tslider_1,technology,slider_1 is a specific slider used in Gradio's demo to create interactive interfaces.,1,UNKNOWN\n6,\tslider_2,technology,slider_2 is a specific slider used in Gradio's demo to create interactive interfaces.,1,UNKNOWN\n7,\tslider_3,technology,slider_3 is a specific slider used in Gradio's demo to create interactive interfaces.,1,UNKNOWN\n    ```\n    -----Relationships-----\n    ```csv\n    id,\tsource,\ttarget,\tdescription,\tkeywords,\tweight,\trank,\tcreated_at\n1,\tGradio,Gradio Demo,Gradio provides a demo for blocks_random_slider, which showcases its functionality.,organization, event,16.0,44,2025-03-24 13:18:47\n2,\tGradio Demo,blocks_random_slider,Gradio Demo is an event that showcases the functionality of blocks_random_slider.,event, category,18.0,9,2025-03-24 13:18:47\n3,\tGradio Demo,slider_1,slider_1 is used in Gradio Demo to create interactive interfaces.,technology, event,6.0,9,2025-03-24 13:18:47\n4,\tGradio Demo,slider_1,slider_1 is used in Gradio Demo to create interactive interfaces.,technology, event,6.0,9,UNKNOWN\n5,\tGradio Demo,slider_2,slider_2 is used in Gradio Demo to create interactive interfaces.,technology, event,6.0,9,UNKNOWN\n6,\tGradio Demo,slider_3,slider_3 is used in Gradio Demo to create interactive interfaces.,technology, event,6.0,9,UNKNOWN\n    ```\n    -----Sources-----\n    ```csv\n    id,\tcontent\n1,\tGradio Demo: blocks_random_slider\n\n\n```\n!pip install -q gradio \n```\n\n\n```\n\nimport gradio as gr\n\n\ndef func(slider_1, slider_2):\n    return slider_1 * 5 + slider_2\n\n\nwith gr.Blocks() as demo:\n    slider = gr.Slider(minimum=-10.2, maximum=15, label=\"Random Slider (Static)\", randomize=True)\n    slider_1 = gr.Slider(minimum=100, maximum=200, label=\"Random Slider (Input 1)\", randomize=True)\n    slider_2 = gr.Slider(minimum=10, maximum=23.2, label=\"Random Slider (Input 2)\", randomize=True)\n    slider_3 = gr.Slider(value=3, label=\"Non random slider\")\n    btn = gr.Button(\"Run\")\n    btn.click(func, inputs=[slider_1, slider_2], outputs=gr.Number())\n\nif __name__ == \"__main__\":\n    demo.launch()\n\n```\n    ```",
            "vector_context": "[Created at: 2025-03-24 13:18:21]\nGradio Demo: blocks_random_slider\n\n\n```\n!pip install -q gradio \n```\n\n\n```\n\nimport gradio as gr\n\n\ndef func(slider_1, slider_2):\n    return slider_1 * 5 + slider_2\n\n\nwith gr.Blocks() as demo:\n    slider = gr.Slider(minimum=-10.2, maximum=15, label=\"Random Slider (Static)\", randomize=True)\n    slider_1 = gr.Slider(minimum=100, maximum=200, label=\"Random Slider (Input 1)\", randomize=True)\n    slider_2 = gr.Slider(minimum=10, maximum=23.2, label=\"Random Slider (Input 2)\", randomize=True)\n    slider_3 = gr.Slider(value=3, label=\"Non random slider\")\n    btn = gr.Button(\"Run\")\n    btn.click(func, inputs=[slider_1, slider_2], outputs=gr.Number())\n\nif __name__ == \"__main__\":\n    demo.launch()\n\n```\n--New Chunk--\n[Created at: 2025-03-24 13:16:48]\n\u4e3b\u8981\u7279\u70b9\n\n\u8ba9\u6211\u4eec\u6765\u4ecb\u7ecd\u4e00\u4e0b Gradio \u6700\u53d7\u6b22\u8fce\u7684\u4e00\u4e9b\u529f\u80fd\uff01\u8fd9\u91cc\u662f Gradio \u7684\u4e3b\u8981\u7279\u70b9\uff1a\n\n1. [\u6dfb\u52a0\u793a\u4f8b\u8f93\u5165](#example-inputs)\n2. [\u4f20\u9012\u81ea\u5b9a\u4e49\u9519\u8bef\u6d88\u606f](#errors)\n3. [\u6dfb\u52a0\u63cf\u8ff0\u5185\u5bb9](#descriptive-content)\n4. [\u8bbe\u7f6e\u65d7\u6807](#flagging)\n5. [\u9884\u5904\u7406\u548c\u540e\u5904\u7406](#preprocessing-and-postprocessing)\n6. [\u6837\u5f0f\u5316\u6f14\u793a](#styling)\n7. [\u6392\u961f\u7528\u6237](#queuing)\n8. [\u8fed\u4ee3\u8f93\u51fa](#iterative-outputs)\n9. [\u8fdb\u5ea6\u6761](#progress-bars)\n10. [\u6279\u5904\u7406\u51fd\u6570](#batch-functions)\n11. [\u5728\u534f\u4f5c\u7b14\u8bb0\u672c\u4e0a\u8fd0\u884c](#colab-notebooks)\n\n## \u793a\u4f8b\u8f93\u5165\n\n\u60a8\u53ef\u4ee5\u63d0\u4f9b\u7528\u6237\u53ef\u4ee5\u8f7b\u677e\u52a0\u8f7d\u5230 \"Interface\" \u4e2d\u7684\u793a\u4f8b\u6570\u636e\u3002\u8fd9\u5bf9\u4e8e\u6f14\u793a\u6a21\u578b\u671f\u671b\u7684\u8f93\u5165\u7c7b\u578b\u4ee5\u53ca\u6f14\u793a\u6570\u636e\u96c6\u548c\u6a21\u578b\u4e00\u8d77\u63a2\u7d22\u7684\u65b9\u5f0f\u975e\u5e38\u6709\u5e2e\u52a9\u3002\u8981\u52a0\u8f7d\u793a\u4f8b\u6570\u636e\uff0c\u60a8\u53ef\u4ee5\u5c06\u5d4c\u5957\u5217\u8868\u63d0\u4f9b\u7ed9 Interface \u6784\u9020\u51fd\u6570\u7684 `examples=` \u5173\u952e\u5b57\u53c2\u6570\u3002\u5916\u90e8\u5217\u8868\u4e2d\u7684\u6bcf\u4e2a\u5b50\u5217\u8868\u8868\u793a\u4e00\u4e2a\u6570\u636e\u6837\u672c\uff0c\u5b50\u5217\u8868\u4e2d\u7684\u6bcf\u4e2a\u5143\u7d20\u8868\u793a\u6bcf\u4e2a\u8f93\u5165\u7ec4\u4ef6\u7684\u8f93\u5165\u3002\u6709\u5173\u6bcf\u4e2a\u7ec4\u4ef6\u7684\u793a\u4f8b\u6570\u636e\u683c\u5f0f\u5728[Docs](https://gradio.app/docs#components)\u4e2d\u6709\u8bf4\u660e\u3002\n\n$code_calculator\n$demo_calculator\n\n\u60a8\u53ef\u4ee5\u5c06\u5927\u578b\u6570\u636e\u96c6\u52a0\u8f7d\u5230\u793a\u4f8b\u4e2d\uff0c\u901a\u8fc7 Gradio \u6d4f\u89c8\u548c\u4e0e\u6570\u636e\u96c6\u8fdb\u884c\u4ea4\u4e92\u3002\u793a\u4f8b\u5c06\u81ea\u52a8\u5206\u9875\uff08\u53ef\u4ee5\u901a\u8fc7 Interface \u7684 `examples_per_page` \u53c2\u6570\u8fdb\u884c\u914d\u7f6e\uff09\u3002\n\n\u7ee7\u7eed\u4e86\u89e3\u793a\u4f8b\uff0c\u8bf7\u53c2\u9605[\u66f4\u591a\u793a\u4f8b](https://gradio.app/more-on-examples)\u6307\u5357\u3002\n\n## \u9519\u8bef\n\n\u60a8\u5e0c\u671b\u5411\u7528\u6237\u4f20\u9012\u81ea\u5b9a\u4e49\u9519\u8bef\u6d88\u606f\u3002\u4e3a\u6b64\uff0cwith `gr.Error(\"custom message\")` \u6765\u663e\u793a\u9519\u8bef\u6d88\u606f\u3002\u5982\u679c\u5728\u4e0a\u9762\u7684\u8ba1\u7b97\u5668\u793a\u4f8b\u4e2d\u5c1d\u8bd5\u9664\u4ee5\u96f6\uff0c\u5c06\u663e\u793a\u81ea\u5b9a\u4e49\u9519\u8bef\u6d88\u606f\u7684\u5f39\u51fa\u6a21\u6001\u7a97\u53e3\u3002\u4e86\u89e3\u6709\u5173\u9519\u8bef\u7684\u66f4\u591a\u4fe1\u606f\uff0c\u8bf7\u53c2\u9605[\u6587\u6863](https://gradio.app/docs#error)\u3002\n\n## \u63cf\u8ff0\u6027\u5185\u5bb9\n\n\u5728\u524d\u9762\u7684\u793a\u4f8b\u4e2d\uff0c\u60a8\u53ef\u80fd\u5df2\u7ecf\u6ce8\u610f\u5230 Interface \u6784\u9020\u51fd\u6570\u4e2d\u7684 `title=` \u548c `description=` \u5173\u952e\u5b57\u53c2\u6570\uff0c\u5e2e\u52a9\u7528\u6237\u4e86\u89e3\u60a8\u7684\u5e94\u7528\u7a0b\u5e8f\u3002\n\nInterface \u6784\u9020\u51fd\u6570\u4e2d\u6709\u4e09\u4e2a\u53c2\u6570\u7528\u4e8e\u6307\u5b9a\u6b64\u5185\u5bb9\u5e94\u653e\u7f6e\u5728\u54ea\u91cc\uff1a\n\n- `title`\uff1a\u63a5\u53d7\u6587\u672c\uff0c\u5e76\u53ef\u4ee5\u5c06\u5176\u663e\u793a\u5728\u754c\u9762\u7684\u9876\u90e8\uff0c\u4e5f\u5c06\u6210\u4e3a\u9875\u9762\u6807\u9898\u3002\n- `description`\uff1a\u63a5\u53d7\u6587\u672c\u3001Markdown \u6216 HTML\uff0c\u5e76\u5c06\u5176\u653e\u7f6e\u5728\u6807\u9898\u6b63\u4e0b\u65b9\u3002\n- `article`\uff1a\u4e5f\u63a5\u53d7\u6587\u672c\u3001Markdown \u6216 HTML\uff0c\u5e76\u5c06\u5176\u653e\u7f6e\u5728\u754c\u9762\u4e0b\u65b9\u3002\n\n![annotated](/assets/guides/annotated.png)\n\n\u5982\u679c\u60a8\u4f7f\u7528\u7684\u662f `Blocks` API\uff0c\u5219\u53ef\u4ee5 with `gr.Markdown(...)` \u6216 `gr.HTML(...)` \u7ec4\u4ef6\u5728\u4efb\u4f55\u4f4d\u7f6e\u63d2\u5165\u6587\u672c\u3001Markdown \u6216 HTML\uff0c\u5176\u4e2d\u63cf\u8ff0\u6027\u5185\u5bb9\u4f4d\u4e8e `Component` \u6784\u9020\u51fd\u6570\u5185\u90e8\u3002\n\n\u53e6\u4e00\u4e2a\u6709\u7528\u7684\u5173\u952e\u5b57\u53c2\u6570\u662f `label=`\uff0c\u5b83\u5b58\u5728\u4e8e\u6bcf\u4e2a `Component` \u4e2d\u3002\u8fd9\u4fee\u6539\u4e86\u6bcf\u4e2a `Component` \u9876\u90e8\u7684\u6807\u7b7e\u6587\u672c\u3002\u8fd8\u53ef\u4ee5\u4e3a\u8bf8\u5982 `Textbox` \u6216 `Radio` \u4e4b\u7c7b\u7684\u8868\u5355\u5143\u7d20\u6dfb\u52a0 `info=` \u5173\u952e\u5b57\u53c2\u6570\uff0c\u4ee5\u63d0\u4f9b\u6709\u5173\u5176\u7528\u6cd5\u7684\u8fdb\u4e00\u6b65\u4fe1\u606f\u3002\n\n```python\ngr.Number(label='\u5e74\u9f84', info='\u4ee5\u5e74\u4e3a\u5355\u4f4d\uff0c\u5fc5\u987b\u5927\u4e8e0')\n```\n\n## \u65d7\u6807\n\n\u9ed8\u8ba4\u60c5\u51b5\u4e0b\uff0c\"Interface\" \u5c06\u6709\u4e00\u4e2a \"Flag\" \u6309\u94ae\u3002\u5f53\u7528\u6237\u6d4b\u8bd5\u60a8\u7684 `Interface` \u65f6\uff0c\u5982\u679c\u770b\u5230\u6709\u8da3\u7684\u8f93\u51fa\uff0c\u4f8b\u5982\u9519\u8bef\u6216\u610f\u5916\u7684\u6a21\u578b\u884c\u4e3a\uff0c\u4ed6\u4eec\u53ef\u4ee5\u5c06\u8f93\u5165\u6807\u8bb0\u4e3a\u60a8\u8fdb\u884c\u67e5\u770b\u3002\u5728\u7531 `Interface` \u6784\u9020\u51fd\u6570\u7684 `flagging_dir=` \u53c2\u6570\u63d0\u4f9b\u7684\u76ee\u5f55\u4e2d\uff0c\u5c06\u8bb0\u5f55\u6807\u8bb0\u7684\u8f93\u5165\u5230\u4e00\u4e2a CSV \u6587\u4ef6\u4e2d\u3002\u5982\u679c\u754c\u9762\u6d89\u53ca\u6587\u4ef6\u6570\u636e\uff0c\u4f8b\u5982\u56fe\u50cf\u548c\u97f3\u9891\u7ec4\u4ef6\uff0c\u5c06\u521b\u5efa\u6587\u4ef6\u5939\u6765\u5b58\u50a8\u8fd9\u4e9b\u6807\u8bb0\u7684\u6570\u636e\u3002\n\n\u4f8b\u5982\uff0c\u5bf9\u4e8e\u4e0a\u9762\u663e\u793a\u7684\u8ba1\u7b97\u5668\u754c\u9762\uff0c\u6211\u4eec\u5c06\u5728\u4e0b\u9762\u7684\u65d7\u6807\u76ee\u5f55\u4e2d\u5b58\u50a8\u6807\u8bb0\u7684\u6570\u636e\uff1a\n\n```directory\n+-- calculator.py\n+-- flagged/\n|   +-- logs.csv\n```\n\n_flagged/logs.csv_\n\n```csv\nnum1,operation,num2,Output\n5,add,7,12\n6,subtract,1.5,4.5\n```\n\n\u4e0e\u65e9\u671f\u663e\u793a\u7684\u51b7\u8272\u754c\u9762\u76f8\u5bf9\u5e94\uff0c\u6211\u4eec\u5c06\u5728\u4e0b\u9762\u7684\u65d7\u6807\u76ee\u5f55\u4e2d\u5b58\u50a8\u6807\u8bb0\u7684\u6570\u636e\uff1a\n\n```directory\n+-- sepia.py\n+-- flagged/\n|   +-- logs.csv\n|   +-- im/\n|   |   +-- 0.png\n|   |   +-- 1.png\n|   +-- Output/\n|   |   +-- 0.png\n|   |   +-- 1.png\n```\n\n_flagged/logs.csv_\n\n```csv\nim,Output\nim/0.png,Output/0.png\nim/1.png,Output/1.png\n```\n\n\u5982\u679c\u60a8\u5e0c\u671b\u7528\u6237\u63d0\u4f9b\u65d7\u6807\u539f\u56e0\uff0c\u53ef\u4ee5\u5c06\u5b57\u7b26\u4e32\u5217\u8868\u4f20\u9012\u7ed9 Interface \u7684 `flagging_options` \u53c2\u6570\u3002\u7528\u6237\u5728\u8fdb\u884c\u65d7\u6807\u65f6\u5fc5\u987b\u9009\u62e9\u5176\u4e2d\u4e00\u4e2a\u5b57\u7b26\u4e32\uff0c\u8fd9\u5c06\u4f5c\u4e3a\u9644\u52a0\u5217\u4fdd\u5b58\u5230 CSV \u4e2d\u3002\n\n## \u9884\u5904\u7406\u548c\u540e\u5904\u7406 (Preprocessing and Postprocessing)\n\n![annotated](/assets/img/dataflow.svg)\n\n\u5982\u60a8\u6240\u89c1\uff0cGradio \u5305\u62ec\u53ef\u4ee5\u5904\u7406\u5404\u79cd\u4e0d\u540c\u6570\u636e\u7c7b\u578b\u7684\u7ec4\u4ef6\uff0c\u4f8b\u5982\u56fe\u50cf\u3001\u97f3\u9891\u548c\u89c6\u9891\u3002\u5927\u591a\u6570\u7ec4\u4ef6\u90fd\u53ef\u4ee5\u7528\u4f5c\u8f93\u5165\u6216\u8f93\u51fa\u3002\n\n\u5f53\u7ec4\u4ef6\u7528\u4f5c\u8f93\u5165\u65f6\uff0cGradio \u81ea\u52a8\u5904\u7406*\u9884\u5904\u7406*\uff0c\u5c06\u6570\u636e\u4ece\u7528\u6237\n--New Chunk--\n[Created at: 2025-03-24 13:16:48]\n\u4e0e\u5e38\u89c4\u51fd\u6570\u76f8\u540c\u7684\u65b9\u5f0f\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio\u3002\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\uff08\u865a\u62df\u7684\uff09\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5b83\u5728\u8f93\u51fa\u56fe\u50cf\u4e4b\u524d\u751f\u6210\u6570\u4e2a\u6b65\u9aa4\u7684\u566a\u97f3\uff1a\n\n$code_fake_diffusion\n$demo_fake_diffusion\n\n\u8bf7\u6ce8\u610f\uff0c\u6211\u4eec\u5728\u8fed\u4ee3\u5668\u4e2d\u6dfb\u52a0\u4e86 `time.sleep(1)`\uff0c\u4ee5\u521b\u5efa\u6b65\u9aa4\u4e4b\u95f4\u7684\u4eba\u5de5\u6682\u505c\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u89c2\u5bdf\u8fed\u4ee3\u5668\u7684\u6b65\u9aa4\uff08\u5728\u771f\u5b9e\u7684\u56fe\u50cf\u751f\u6210\u6a21\u578b\u4e2d\uff0c\u8fd9\u53ef\u80fd\u662f\u4e0d\u5fc5\u8981\u7684\uff09\u3002\n\n\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio **\u9700\u8981**\u5728\u5e95\u5c42 Interface \u6216 Blocks \u4e2d\u542f\u7528\u961f\u5217\uff08\u8bf7\u53c2\u9605\u4e0a\u9762\u7684\u961f\u5217\u90e8\u5206\uff09\u3002\n\n## \u8fdb\u5ea6\u6761\n\nGradio \u652f\u6301\u521b\u5efa\u81ea\u5b9a\u4e49\u8fdb\u5ea6\u6761\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u81ea\u5b9a\u4e49\u548c\u63a7\u5236\u5411\u7528\u6237\u663e\u793a\u7684\u8fdb\u5ea6\u66f4\u65b0\u3002\u8981\u542f\u7528\u6b64\u529f\u80fd\uff0c\u53ea\u9700\u4e3a\u65b9\u6cd5\u6dfb\u52a0\u4e00\u4e2a\u9ed8\u8ba4\u503c\u4e3a `gr.Progress` \u5b9e\u4f8b\u7684\u53c2\u6570\u5373\u53ef\u3002\u7136\u540e\uff0c\u60a8\u53ef\u4ee5\u76f4\u63a5\u8c03\u7528\u6b64\u5b9e\u4f8b\u5e76\u4f20\u5165 0 \u5230 1 \u4e4b\u95f4\u7684\u6d6e\u70b9\u6570\u6765\u66f4\u65b0\u8fdb\u5ea6\u7ea7\u522b\uff0c\u6216\u8005 with `Progress` \u5b9e\u4f8b\u7684 `tqdm()` \u65b9\u6cd5\u6765\u8ddf\u8e2a\u53ef\u8fed\u4ee3\u5bf9\u8c61\u4e0a\u7684\u8fdb\u5ea6\uff0c\u5982\u4e0b\u6240\u793a\u3002\u5fc5\u987b\u542f\u7528\u961f\u5217\u4ee5\u8fdb\u884c\u8fdb\u5ea6\u66f4\u65b0\u3002\n\n$code_progress_simple\n$demo_progress_simple\n\n\u5982\u679c\u60a8 with `tqdm` \u5e93\uff0c\u5e76\u4e14\u5e0c\u671b\u4ece\u51fd\u6570\u5185\u90e8\u7684\u4efb\u4f55 `tqdm.tqdm` \u81ea\u52a8\u62a5\u544a\u8fdb\u5ea6\u66f4\u65b0\uff0c\u8bf7\u5c06\u9ed8\u8ba4\u53c2\u6570\u8bbe\u7f6e\u4e3a `gr.Progress(track_tqdm=True)`\uff01\n\n## \u6279\u5904\u7406\u51fd\u6570 (Batch Functions)\n\nGradio \u652f\u6301\u4f20\u9012*\u6279\u5904\u7406*\u51fd\u6570\u3002\u6279\u5904\u7406\u51fd\u6570\u53ea\u662f\u63a5\u53d7\u8f93\u5165\u5217\u8868\u5e76\u8fd4\u56de\u9884\u6d4b\u5217\u8868\u7684\u51fd\u6570\u3002\n\n\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\u6279\u5904\u7406\u51fd\u6570\uff0c\u5b83\u63a5\u53d7\u4e24\u4e2a\u8f93\u5165\u5217\u8868\uff08\u4e00\u4e2a\u5355\u8bcd\u5217\u8868\u548c\u4e00\u4e2a\u6574\u6570\u5217\u8868\uff09\uff0c\u5e76\u8fd4\u56de\u4fee\u526a\u8fc7\u7684\u5355\u8bcd\u5217\u8868\u4f5c\u4e3a\u8f93\u51fa\uff1a\n\n```python\nimport time\n\ndef trim_words(words, lens):\n    trimmed_words = []\n    time.sleep(5)\n    for w, l in zip(words, lens):\n        trimmed_words.append(w[:int(l)])\n    return [trimmed_words]\n    for w, l in zip(words, lens):\n```\n\n\u4f7f\u7528\u6279\u5904\u7406\u51fd\u6570\u7684\u4f18\u70b9\u662f\uff0c\u5982\u679c\u542f\u7528\u4e86\u961f\u5217\uff0cGradio \u670d\u52a1\u5668\u53ef\u4ee5\u81ea\u52a8*\u6279\u5904\u7406*\u4f20\u5165\u7684\u8bf7\u6c42\u5e76\u5e76\u884c\u5904\u7406\u5b83\u4eec\uff0c\u4ece\u800c\u53ef\u80fd\u52a0\u5feb\u6f14\u793a\u901f\u5ea6\u3002\u4ee5\u4e0b\u662f Gradio \u4ee3\u7801\u7684\u793a\u4f8b\uff08\u8bf7\u6ce8\u610f `batch=True` \u548c `max_batch_size=16` - \u8fd9\u4e24\u4e2a\u53c2\u6570\u90fd\u53ef\u4ee5\u4f20\u9012\u7ed9\u4e8b\u4ef6\u89e6\u53d1\u5668\u6216 `Interface` \u7c7b\uff09\n\nwith `Interface`\uff1a\n\n```python\ndemo = gr.Interface(trim_words, [\"textbox\", \"number\"], [\"output\"],\n                    batch=True, max_batch_size=16)\ndemo.queue()\ndemo.launch()\n```\n\nwith `Blocks`\uff1a\n\n```python\nimport gradio as gr\n\nwith gr.Blocks() as demo:\n    with gr.Row():\n        word = gr.Textbox(label=\"word\")\n        leng = gr.Number(label=\"leng\")\n        output = gr.Textbox(label=\"Output\")\n    with gr.Row():\n        run = gr.Button()\n\n    event = run.click(trim_words, [word, leng], output, batch=True, max_batch_size=16)\n\ndemo.queue()\ndemo.launch()\n```\n\n\u5728\u4e0a\u9762\u7684\u793a\u4f8b\u4e2d\uff0c\u53ef\u4ee5\u5e76\u884c\u5904\u7406 16 \u4e2a\u8bf7\u6c42\uff08\u603b\u63a8\u7406\u65f6\u95f4\u4e3a 5 \u79d2\uff09\uff0c\u800c\u4e0d\u662f\u5206\u522b\u5904\u7406\u6bcf\u4e2a\u8bf7\u6c42\uff08\u603b\u63a8\u7406\u65f6\u95f4\u4e3a 80 \u79d2\uff09\u3002\u8bb8\u591a Hugging Face \u7684 `transformers` \u548c `diffusers` \u6a21\u578b\u5728 Gradio \u7684\u6279\u5904\u7406\u6a21\u5f0f\u4e0b\u81ea\u7136\u5de5\u4f5c\uff1a\u8fd9\u662f[\u4f7f\u7528\u6279\u5904\u7406\u751f\u6210\u56fe\u50cf\u7684\u793a\u4f8b\u6f14\u793a](https://github.com/gradio-app/gradio/blob/main/demo/diffusers_with_batching/run.py)\n\n\u6ce8\u610f\uff1a\u4f7f\u7528 Gradio \u7684\u6279\u5904\u7406\u51fd\u6570 **requires** \u5728\u5e95\u5c42 Interface \u6216 Blocks \u4e2d\u542f\u7528\u961f\u5217\uff08\u8bf7\u53c2\u9605\u4e0a\u9762\u7684\u961f\u5217\u90e8\u5206\uff09\u3002\n\n## Gradio \u7b14\u8bb0\u672c (Colab Notebooks)\n\nGradio \u53ef\u4ee5\u5728\u4efb\u4f55\u8fd0\u884c Python \u7684\u5730\u65b9\u8fd0\u884c\uff0c\u5305\u62ec\u672c\u5730 Jupyter \u7b14\u8bb0\u672c\u548c\u534f\u4f5c\u7b14\u8bb0\u672c\uff0c\u5982[Google Colab](https://colab.research.google.com/)\u3002\u5bf9\u4e8e\u672c\u5730 Jupyter \u7b14\u8bb0\u672c\u548c Google Colab \u7b14\u8bb0\u672c\uff0cGradio \u5728\u672c\u5730\u670d\u52a1\u5668\u4e0a\u8fd0\u884c\uff0c\u60a8\u53ef\u4ee5\u5728\u6d4f\u89c8\u5668\u4e2d\u4e0e\u4e4b\u4ea4\u4e92\u3002\uff08\u6ce8\u610f\uff1a\u5bf9\u4e8e Google Colab\uff0c\u8fd9\u662f\u901a\u8fc7[\u670d\u52a1\u5de5\u4f5c\u5668\u96a7\u9053](https://github.com/tensorflow/tensorboard/blob/master/docs/design/colab_integration.md)\u5b9e\u73b0\u7684\uff0c\u60a8\u7684\u6d4f\u89c8\u5668\u9700\u8981\u542f\u7528 cookies\u3002\uff09\u5bf9\u4e8e\u5176\u4ed6\u8fdc\u7a0b\u7b14\u8bb0\u672c\uff0cGradio \u4e5f\u5c06\u5728\u670d\u52a1\u5668\u4e0a\u8fd0\u884c\uff0c\u4f46\u60a8\u9700\u8981\u4f7f\u7528[SSH \u96a7\u9053](https://coderwall.com/p/ohk6cg/remote-access-to-ipython-notebooks-via-ssh)\u5728\u672c\u5730\u6d4f\u89c8\u5668\u4e2d\u67e5\u770b\u5e94\u7528\u7a0b\u5e8f\u3002\u901a\u5e38\uff0c\u66f4\u7b80\u5355\u7684\u9009\u62e9\u662f\u4f7f\u7528 Gradio \u5185\u7f6e\u7684\u516c\u5171\u94fe\u63a5\uff0c[\u5728\u4e0b\u4e00\u7bc7\u6307\u5357\u4e2d\u8ba8\u8bba](/sharing-your-app/#sharing-demos)\u3002"
        }
    },
    {
        "sample_idx": 88,
        "question": "What is the maximum value of the 'Random Slider (Input 2)' in the Gradio demo?",
        "answer": "The maximum value is 23.2.",
        "rag_answer": "The maximum value of the 'Random Slider (Input 2)' in the Gradio demo is 23.2.",
        "rag_score": 5,
        "rag_feedback": "The system's response is completely correct, accurate, and factual. It directly answers the question by stating 'The maximum value of the 'Random Slider (Input 2)' in the Gradio demo is 23.2.', which matches the expected answer.",
        "rag_context": {
            "kg_context": "-----Entities-----\n    ```csv\n    id,\tentity,\ttype,\tdescription,\trankcreated_at\n1,\tGradio Demo,event,Gradio Demo is an event that showcases the functionality of Gradio's blocks_random_slider.,8,2025-03-24 13:18:47\n2,\tslider_1,technology,slider_1 is a specific slider used in Gradio's demo to create interactive interfaces.,1,2025-03-24 13:18:47\n3,\tslider_2,technology,slider_2 is a specific slider used in Gradio's demo to create interactive interfaces.,1,2025-03-24 13:18:47\n4,\tslider_3,technology,slider_3 is a specific slider used in Gradio's demo to create interactive interfaces.,1,2025-03-24 13:18:47\n5,\tslider_2,technology,slider_2 is a specific slider used in Gradio's demo to create interactive interfaces.,1,UNKNOWN\n6,\tblocks_random_slider,category,blocks_random_slider is a category of demo provided by Gradio, which includes interactive sliders.,1,UNKNOWN\n7,\tslider_1,technology,slider_1 is a specific slider used in Gradio's demo to create interactive interfaces.,1,UNKNOWN\n    ```\n    -----Relationships-----\n    ```csv\n    id,\tsource,\ttarget,\tdescription,\tkeywords,\tweight,\trank,\tcreated_at\n1,\tGradio Demo,slider_1,slider_1 is used in Gradio Demo to create interactive interfaces.,technology, event,6.0,9,2025-03-24 13:18:47\n2,\tGradio Demo,slider_2,slider_2 is used in Gradio Demo to create interactive interfaces.,technology, event,6.0,9,2025-03-24 13:18:47\n3,\tGradio Demo,slider_3,slider_3 is used in Gradio Demo to create interactive interfaces.,technology, event,6.0,9,2025-03-24 13:18:47\n4,\tGradio Demo,blocks_random_slider,Gradio Demo is an event that showcases the functionality of blocks_random_slider.,event, category,18.0,9,UNKNOWN\n5,\tGradio Demo,slider_2,slider_2 is used in Gradio Demo to create interactive interfaces.,technology, event,6.0,9,UNKNOWN\n6,\tGradio Demo,slider_1,slider_1 is used in Gradio Demo to create interactive interfaces.,technology, event,6.0,9,UNKNOWN\n    ```\n    -----Sources-----\n    ```csv\n    id,\tcontent\n1,\tGradio Demo: blocks_random_slider\n\n\n```\n!pip install -q gradio \n```\n\n\n```\n\nimport gradio as gr\n\n\ndef func(slider_1, slider_2):\n    return slider_1 * 5 + slider_2\n\n\nwith gr.Blocks() as demo:\n    slider = gr.Slider(minimum=-10.2, maximum=15, label=\"Random Slider (Static)\", randomize=True)\n    slider_1 = gr.Slider(minimum=100, maximum=200, label=\"Random Slider (Input 1)\", randomize=True)\n    slider_2 = gr.Slider(minimum=10, maximum=23.2, label=\"Random Slider (Input 2)\", randomize=True)\n    slider_3 = gr.Slider(value=3, label=\"Non random slider\")\n    btn = gr.Button(\"Run\")\n    btn.click(func, inputs=[slider_1, slider_2], outputs=gr.Number())\n\nif __name__ == \"__main__\":\n    demo.launch()\n\n```\n    ```",
            "vector_context": "[Created at: 2025-03-24 13:18:21]\nGradio Demo: blocks_random_slider\n\n\n```\n!pip install -q gradio \n```\n\n\n```\n\nimport gradio as gr\n\n\ndef func(slider_1, slider_2):\n    return slider_1 * 5 + slider_2\n\n\nwith gr.Blocks() as demo:\n    slider = gr.Slider(minimum=-10.2, maximum=15, label=\"Random Slider (Static)\", randomize=True)\n    slider_1 = gr.Slider(minimum=100, maximum=200, label=\"Random Slider (Input 1)\", randomize=True)\n    slider_2 = gr.Slider(minimum=10, maximum=23.2, label=\"Random Slider (Input 2)\", randomize=True)\n    slider_3 = gr.Slider(value=3, label=\"Non random slider\")\n    btn = gr.Button(\"Run\")\n    btn.click(func, inputs=[slider_1, slider_2], outputs=gr.Number())\n\nif __name__ == \"__main__\":\n    demo.launch()\n\n```\n--New Chunk--\n[Created at: 2025-03-24 13:16:48]\n\u4e3b\u8981\u7279\u70b9\n\n\u8ba9\u6211\u4eec\u6765\u4ecb\u7ecd\u4e00\u4e0b Gradio \u6700\u53d7\u6b22\u8fce\u7684\u4e00\u4e9b\u529f\u80fd\uff01\u8fd9\u91cc\u662f Gradio \u7684\u4e3b\u8981\u7279\u70b9\uff1a\n\n1. [\u6dfb\u52a0\u793a\u4f8b\u8f93\u5165](#example-inputs)\n2. [\u4f20\u9012\u81ea\u5b9a\u4e49\u9519\u8bef\u6d88\u606f](#errors)\n3. [\u6dfb\u52a0\u63cf\u8ff0\u5185\u5bb9](#descriptive-content)\n4. [\u8bbe\u7f6e\u65d7\u6807](#flagging)\n5. [\u9884\u5904\u7406\u548c\u540e\u5904\u7406](#preprocessing-and-postprocessing)\n6. [\u6837\u5f0f\u5316\u6f14\u793a](#styling)\n7. [\u6392\u961f\u7528\u6237](#queuing)\n8. [\u8fed\u4ee3\u8f93\u51fa](#iterative-outputs)\n9. [\u8fdb\u5ea6\u6761](#progress-bars)\n10. [\u6279\u5904\u7406\u51fd\u6570](#batch-functions)\n11. [\u5728\u534f\u4f5c\u7b14\u8bb0\u672c\u4e0a\u8fd0\u884c](#colab-notebooks)\n\n## \u793a\u4f8b\u8f93\u5165\n\n\u60a8\u53ef\u4ee5\u63d0\u4f9b\u7528\u6237\u53ef\u4ee5\u8f7b\u677e\u52a0\u8f7d\u5230 \"Interface\" \u4e2d\u7684\u793a\u4f8b\u6570\u636e\u3002\u8fd9\u5bf9\u4e8e\u6f14\u793a\u6a21\u578b\u671f\u671b\u7684\u8f93\u5165\u7c7b\u578b\u4ee5\u53ca\u6f14\u793a\u6570\u636e\u96c6\u548c\u6a21\u578b\u4e00\u8d77\u63a2\u7d22\u7684\u65b9\u5f0f\u975e\u5e38\u6709\u5e2e\u52a9\u3002\u8981\u52a0\u8f7d\u793a\u4f8b\u6570\u636e\uff0c\u60a8\u53ef\u4ee5\u5c06\u5d4c\u5957\u5217\u8868\u63d0\u4f9b\u7ed9 Interface \u6784\u9020\u51fd\u6570\u7684 `examples=` \u5173\u952e\u5b57\u53c2\u6570\u3002\u5916\u90e8\u5217\u8868\u4e2d\u7684\u6bcf\u4e2a\u5b50\u5217\u8868\u8868\u793a\u4e00\u4e2a\u6570\u636e\u6837\u672c\uff0c\u5b50\u5217\u8868\u4e2d\u7684\u6bcf\u4e2a\u5143\u7d20\u8868\u793a\u6bcf\u4e2a\u8f93\u5165\u7ec4\u4ef6\u7684\u8f93\u5165\u3002\u6709\u5173\u6bcf\u4e2a\u7ec4\u4ef6\u7684\u793a\u4f8b\u6570\u636e\u683c\u5f0f\u5728[Docs](https://gradio.app/docs#components)\u4e2d\u6709\u8bf4\u660e\u3002\n\n$code_calculator\n$demo_calculator\n\n\u60a8\u53ef\u4ee5\u5c06\u5927\u578b\u6570\u636e\u96c6\u52a0\u8f7d\u5230\u793a\u4f8b\u4e2d\uff0c\u901a\u8fc7 Gradio \u6d4f\u89c8\u548c\u4e0e\u6570\u636e\u96c6\u8fdb\u884c\u4ea4\u4e92\u3002\u793a\u4f8b\u5c06\u81ea\u52a8\u5206\u9875\uff08\u53ef\u4ee5\u901a\u8fc7 Interface \u7684 `examples_per_page` \u53c2\u6570\u8fdb\u884c\u914d\u7f6e\uff09\u3002\n\n\u7ee7\u7eed\u4e86\u89e3\u793a\u4f8b\uff0c\u8bf7\u53c2\u9605[\u66f4\u591a\u793a\u4f8b](https://gradio.app/more-on-examples)\u6307\u5357\u3002\n\n## \u9519\u8bef\n\n\u60a8\u5e0c\u671b\u5411\u7528\u6237\u4f20\u9012\u81ea\u5b9a\u4e49\u9519\u8bef\u6d88\u606f\u3002\u4e3a\u6b64\uff0cwith `gr.Error(\"custom message\")` \u6765\u663e\u793a\u9519\u8bef\u6d88\u606f\u3002\u5982\u679c\u5728\u4e0a\u9762\u7684\u8ba1\u7b97\u5668\u793a\u4f8b\u4e2d\u5c1d\u8bd5\u9664\u4ee5\u96f6\uff0c\u5c06\u663e\u793a\u81ea\u5b9a\u4e49\u9519\u8bef\u6d88\u606f\u7684\u5f39\u51fa\u6a21\u6001\u7a97\u53e3\u3002\u4e86\u89e3\u6709\u5173\u9519\u8bef\u7684\u66f4\u591a\u4fe1\u606f\uff0c\u8bf7\u53c2\u9605[\u6587\u6863](https://gradio.app/docs#error)\u3002\n\n## \u63cf\u8ff0\u6027\u5185\u5bb9\n\n\u5728\u524d\u9762\u7684\u793a\u4f8b\u4e2d\uff0c\u60a8\u53ef\u80fd\u5df2\u7ecf\u6ce8\u610f\u5230 Interface \u6784\u9020\u51fd\u6570\u4e2d\u7684 `title=` \u548c `description=` \u5173\u952e\u5b57\u53c2\u6570\uff0c\u5e2e\u52a9\u7528\u6237\u4e86\u89e3\u60a8\u7684\u5e94\u7528\u7a0b\u5e8f\u3002\n\nInterface \u6784\u9020\u51fd\u6570\u4e2d\u6709\u4e09\u4e2a\u53c2\u6570\u7528\u4e8e\u6307\u5b9a\u6b64\u5185\u5bb9\u5e94\u653e\u7f6e\u5728\u54ea\u91cc\uff1a\n\n- `title`\uff1a\u63a5\u53d7\u6587\u672c\uff0c\u5e76\u53ef\u4ee5\u5c06\u5176\u663e\u793a\u5728\u754c\u9762\u7684\u9876\u90e8\uff0c\u4e5f\u5c06\u6210\u4e3a\u9875\u9762\u6807\u9898\u3002\n- `description`\uff1a\u63a5\u53d7\u6587\u672c\u3001Markdown \u6216 HTML\uff0c\u5e76\u5c06\u5176\u653e\u7f6e\u5728\u6807\u9898\u6b63\u4e0b\u65b9\u3002\n- `article`\uff1a\u4e5f\u63a5\u53d7\u6587\u672c\u3001Markdown \u6216 HTML\uff0c\u5e76\u5c06\u5176\u653e\u7f6e\u5728\u754c\u9762\u4e0b\u65b9\u3002\n\n![annotated](/assets/guides/annotated.png)\n\n\u5982\u679c\u60a8\u4f7f\u7528\u7684\u662f `Blocks` API\uff0c\u5219\u53ef\u4ee5 with `gr.Markdown(...)` \u6216 `gr.HTML(...)` \u7ec4\u4ef6\u5728\u4efb\u4f55\u4f4d\u7f6e\u63d2\u5165\u6587\u672c\u3001Markdown \u6216 HTML\uff0c\u5176\u4e2d\u63cf\u8ff0\u6027\u5185\u5bb9\u4f4d\u4e8e `Component` \u6784\u9020\u51fd\u6570\u5185\u90e8\u3002\n\n\u53e6\u4e00\u4e2a\u6709\u7528\u7684\u5173\u952e\u5b57\u53c2\u6570\u662f `label=`\uff0c\u5b83\u5b58\u5728\u4e8e\u6bcf\u4e2a `Component` \u4e2d\u3002\u8fd9\u4fee\u6539\u4e86\u6bcf\u4e2a `Component` \u9876\u90e8\u7684\u6807\u7b7e\u6587\u672c\u3002\u8fd8\u53ef\u4ee5\u4e3a\u8bf8\u5982 `Textbox` \u6216 `Radio` \u4e4b\u7c7b\u7684\u8868\u5355\u5143\u7d20\u6dfb\u52a0 `info=` \u5173\u952e\u5b57\u53c2\u6570\uff0c\u4ee5\u63d0\u4f9b\u6709\u5173\u5176\u7528\u6cd5\u7684\u8fdb\u4e00\u6b65\u4fe1\u606f\u3002\n\n```python\ngr.Number(label='\u5e74\u9f84', info='\u4ee5\u5e74\u4e3a\u5355\u4f4d\uff0c\u5fc5\u987b\u5927\u4e8e0')\n```\n\n## \u65d7\u6807\n\n\u9ed8\u8ba4\u60c5\u51b5\u4e0b\uff0c\"Interface\" \u5c06\u6709\u4e00\u4e2a \"Flag\" \u6309\u94ae\u3002\u5f53\u7528\u6237\u6d4b\u8bd5\u60a8\u7684 `Interface` \u65f6\uff0c\u5982\u679c\u770b\u5230\u6709\u8da3\u7684\u8f93\u51fa\uff0c\u4f8b\u5982\u9519\u8bef\u6216\u610f\u5916\u7684\u6a21\u578b\u884c\u4e3a\uff0c\u4ed6\u4eec\u53ef\u4ee5\u5c06\u8f93\u5165\u6807\u8bb0\u4e3a\u60a8\u8fdb\u884c\u67e5\u770b\u3002\u5728\u7531 `Interface` \u6784\u9020\u51fd\u6570\u7684 `flagging_dir=` \u53c2\u6570\u63d0\u4f9b\u7684\u76ee\u5f55\u4e2d\uff0c\u5c06\u8bb0\u5f55\u6807\u8bb0\u7684\u8f93\u5165\u5230\u4e00\u4e2a CSV \u6587\u4ef6\u4e2d\u3002\u5982\u679c\u754c\u9762\u6d89\u53ca\u6587\u4ef6\u6570\u636e\uff0c\u4f8b\u5982\u56fe\u50cf\u548c\u97f3\u9891\u7ec4\u4ef6\uff0c\u5c06\u521b\u5efa\u6587\u4ef6\u5939\u6765\u5b58\u50a8\u8fd9\u4e9b\u6807\u8bb0\u7684\u6570\u636e\u3002\n\n\u4f8b\u5982\uff0c\u5bf9\u4e8e\u4e0a\u9762\u663e\u793a\u7684\u8ba1\u7b97\u5668\u754c\u9762\uff0c\u6211\u4eec\u5c06\u5728\u4e0b\u9762\u7684\u65d7\u6807\u76ee\u5f55\u4e2d\u5b58\u50a8\u6807\u8bb0\u7684\u6570\u636e\uff1a\n\n```directory\n+-- calculator.py\n+-- flagged/\n|   +-- logs.csv\n```\n\n_flagged/logs.csv_\n\n```csv\nnum1,operation,num2,Output\n5,add,7,12\n6,subtract,1.5,4.5\n```\n\n\u4e0e\u65e9\u671f\u663e\u793a\u7684\u51b7\u8272\u754c\u9762\u76f8\u5bf9\u5e94\uff0c\u6211\u4eec\u5c06\u5728\u4e0b\u9762\u7684\u65d7\u6807\u76ee\u5f55\u4e2d\u5b58\u50a8\u6807\u8bb0\u7684\u6570\u636e\uff1a\n\n```directory\n+-- sepia.py\n+-- flagged/\n|   +-- logs.csv\n|   +-- im/\n|   |   +-- 0.png\n|   |   +-- 1.png\n|   +-- Output/\n|   |   +-- 0.png\n|   |   +-- 1.png\n```\n\n_flagged/logs.csv_\n\n```csv\nim,Output\nim/0.png,Output/0.png\nim/1.png,Output/1.png\n```\n\n\u5982\u679c\u60a8\u5e0c\u671b\u7528\u6237\u63d0\u4f9b\u65d7\u6807\u539f\u56e0\uff0c\u53ef\u4ee5\u5c06\u5b57\u7b26\u4e32\u5217\u8868\u4f20\u9012\u7ed9 Interface \u7684 `flagging_options` \u53c2\u6570\u3002\u7528\u6237\u5728\u8fdb\u884c\u65d7\u6807\u65f6\u5fc5\u987b\u9009\u62e9\u5176\u4e2d\u4e00\u4e2a\u5b57\u7b26\u4e32\uff0c\u8fd9\u5c06\u4f5c\u4e3a\u9644\u52a0\u5217\u4fdd\u5b58\u5230 CSV \u4e2d\u3002\n\n## \u9884\u5904\u7406\u548c\u540e\u5904\u7406 (Preprocessing and Postprocessing)\n\n![annotated](/assets/img/dataflow.svg)\n\n\u5982\u60a8\u6240\u89c1\uff0cGradio \u5305\u62ec\u53ef\u4ee5\u5904\u7406\u5404\u79cd\u4e0d\u540c\u6570\u636e\u7c7b\u578b\u7684\u7ec4\u4ef6\uff0c\u4f8b\u5982\u56fe\u50cf\u3001\u97f3\u9891\u548c\u89c6\u9891\u3002\u5927\u591a\u6570\u7ec4\u4ef6\u90fd\u53ef\u4ee5\u7528\u4f5c\u8f93\u5165\u6216\u8f93\u51fa\u3002\n\n\u5f53\u7ec4\u4ef6\u7528\u4f5c\u8f93\u5165\u65f6\uff0cGradio \u81ea\u52a8\u5904\u7406*\u9884\u5904\u7406*\uff0c\u5c06\u6570\u636e\u4ece\u7528\u6237\n--New Chunk--\n[Created at: 2025-03-24 13:16:48]\n\u4e0e\u5e38\u89c4\u51fd\u6570\u76f8\u540c\u7684\u65b9\u5f0f\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio\u3002\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\uff08\u865a\u62df\u7684\uff09\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5b83\u5728\u8f93\u51fa\u56fe\u50cf\u4e4b\u524d\u751f\u6210\u6570\u4e2a\u6b65\u9aa4\u7684\u566a\u97f3\uff1a\n\n$code_fake_diffusion\n$demo_fake_diffusion\n\n\u8bf7\u6ce8\u610f\uff0c\u6211\u4eec\u5728\u8fed\u4ee3\u5668\u4e2d\u6dfb\u52a0\u4e86 `time.sleep(1)`\uff0c\u4ee5\u521b\u5efa\u6b65\u9aa4\u4e4b\u95f4\u7684\u4eba\u5de5\u6682\u505c\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u89c2\u5bdf\u8fed\u4ee3\u5668\u7684\u6b65\u9aa4\uff08\u5728\u771f\u5b9e\u7684\u56fe\u50cf\u751f\u6210\u6a21\u578b\u4e2d\uff0c\u8fd9\u53ef\u80fd\u662f\u4e0d\u5fc5\u8981\u7684\uff09\u3002\n\n\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio **\u9700\u8981**\u5728\u5e95\u5c42 Interface \u6216 Blocks \u4e2d\u542f\u7528\u961f\u5217\uff08\u8bf7\u53c2\u9605\u4e0a\u9762\u7684\u961f\u5217\u90e8\u5206\uff09\u3002\n\n## \u8fdb\u5ea6\u6761\n\nGradio \u652f\u6301\u521b\u5efa\u81ea\u5b9a\u4e49\u8fdb\u5ea6\u6761\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u81ea\u5b9a\u4e49\u548c\u63a7\u5236\u5411\u7528\u6237\u663e\u793a\u7684\u8fdb\u5ea6\u66f4\u65b0\u3002\u8981\u542f\u7528\u6b64\u529f\u80fd\uff0c\u53ea\u9700\u4e3a\u65b9\u6cd5\u6dfb\u52a0\u4e00\u4e2a\u9ed8\u8ba4\u503c\u4e3a `gr.Progress` \u5b9e\u4f8b\u7684\u53c2\u6570\u5373\u53ef\u3002\u7136\u540e\uff0c\u60a8\u53ef\u4ee5\u76f4\u63a5\u8c03\u7528\u6b64\u5b9e\u4f8b\u5e76\u4f20\u5165 0 \u5230 1 \u4e4b\u95f4\u7684\u6d6e\u70b9\u6570\u6765\u66f4\u65b0\u8fdb\u5ea6\u7ea7\u522b\uff0c\u6216\u8005 with `Progress` \u5b9e\u4f8b\u7684 `tqdm()` \u65b9\u6cd5\u6765\u8ddf\u8e2a\u53ef\u8fed\u4ee3\u5bf9\u8c61\u4e0a\u7684\u8fdb\u5ea6\uff0c\u5982\u4e0b\u6240\u793a\u3002\u5fc5\u987b\u542f\u7528\u961f\u5217\u4ee5\u8fdb\u884c\u8fdb\u5ea6\u66f4\u65b0\u3002\n\n$code_progress_simple\n$demo_progress_simple\n\n\u5982\u679c\u60a8 with `tqdm` \u5e93\uff0c\u5e76\u4e14\u5e0c\u671b\u4ece\u51fd\u6570\u5185\u90e8\u7684\u4efb\u4f55 `tqdm.tqdm` \u81ea\u52a8\u62a5\u544a\u8fdb\u5ea6\u66f4\u65b0\uff0c\u8bf7\u5c06\u9ed8\u8ba4\u53c2\u6570\u8bbe\u7f6e\u4e3a `gr.Progress(track_tqdm=True)`\uff01\n\n## \u6279\u5904\u7406\u51fd\u6570 (Batch Functions)\n\nGradio \u652f\u6301\u4f20\u9012*\u6279\u5904\u7406*\u51fd\u6570\u3002\u6279\u5904\u7406\u51fd\u6570\u53ea\u662f\u63a5\u53d7\u8f93\u5165\u5217\u8868\u5e76\u8fd4\u56de\u9884\u6d4b\u5217\u8868\u7684\u51fd\u6570\u3002\n\n\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\u6279\u5904\u7406\u51fd\u6570\uff0c\u5b83\u63a5\u53d7\u4e24\u4e2a\u8f93\u5165\u5217\u8868\uff08\u4e00\u4e2a\u5355\u8bcd\u5217\u8868\u548c\u4e00\u4e2a\u6574\u6570\u5217\u8868\uff09\uff0c\u5e76\u8fd4\u56de\u4fee\u526a\u8fc7\u7684\u5355\u8bcd\u5217\u8868\u4f5c\u4e3a\u8f93\u51fa\uff1a\n\n```python\nimport time\n\ndef trim_words(words, lens):\n    trimmed_words = []\n    time.sleep(5)\n    for w, l in zip(words, lens):\n        trimmed_words.append(w[:int(l)])\n    return [trimmed_words]\n    for w, l in zip(words, lens):\n```\n\n\u4f7f\u7528\u6279\u5904\u7406\u51fd\u6570\u7684\u4f18\u70b9\u662f\uff0c\u5982\u679c\u542f\u7528\u4e86\u961f\u5217\uff0cGradio \u670d\u52a1\u5668\u53ef\u4ee5\u81ea\u52a8*\u6279\u5904\u7406*\u4f20\u5165\u7684\u8bf7\u6c42\u5e76\u5e76\u884c\u5904\u7406\u5b83\u4eec\uff0c\u4ece\u800c\u53ef\u80fd\u52a0\u5feb\u6f14\u793a\u901f\u5ea6\u3002\u4ee5\u4e0b\u662f Gradio \u4ee3\u7801\u7684\u793a\u4f8b\uff08\u8bf7\u6ce8\u610f `batch=True` \u548c `max_batch_size=16` - \u8fd9\u4e24\u4e2a\u53c2\u6570\u90fd\u53ef\u4ee5\u4f20\u9012\u7ed9\u4e8b\u4ef6\u89e6\u53d1\u5668\u6216 `Interface` \u7c7b\uff09\n\nwith `Interface`\uff1a\n\n```python\ndemo = gr.Interface(trim_words, [\"textbox\", \"number\"], [\"output\"],\n                    batch=True, max_batch_size=16)\ndemo.queue()\ndemo.launch()\n```\n\nwith `Blocks`\uff1a\n\n```python\nimport gradio as gr\n\nwith gr.Blocks() as demo:\n    with gr.Row():\n        word = gr.Textbox(label=\"word\")\n        leng = gr.Number(label=\"leng\")\n        output = gr.Textbox(label=\"Output\")\n    with gr.Row():\n        run = gr.Button()\n\n    event = run.click(trim_words, [word, leng], output, batch=True, max_batch_size=16)\n\ndemo.queue()\ndemo.launch()\n```\n\n\u5728\u4e0a\u9762\u7684\u793a\u4f8b\u4e2d\uff0c\u53ef\u4ee5\u5e76\u884c\u5904\u7406 16 \u4e2a\u8bf7\u6c42\uff08\u603b\u63a8\u7406\u65f6\u95f4\u4e3a 5 \u79d2\uff09\uff0c\u800c\u4e0d\u662f\u5206\u522b\u5904\u7406\u6bcf\u4e2a\u8bf7\u6c42\uff08\u603b\u63a8\u7406\u65f6\u95f4\u4e3a 80 \u79d2\uff09\u3002\u8bb8\u591a Hugging Face \u7684 `transformers` \u548c `diffusers` \u6a21\u578b\u5728 Gradio \u7684\u6279\u5904\u7406\u6a21\u5f0f\u4e0b\u81ea\u7136\u5de5\u4f5c\uff1a\u8fd9\u662f[\u4f7f\u7528\u6279\u5904\u7406\u751f\u6210\u56fe\u50cf\u7684\u793a\u4f8b\u6f14\u793a](https://github.com/gradio-app/gradio/blob/main/demo/diffusers_with_batching/run.py)\n\n\u6ce8\u610f\uff1a\u4f7f\u7528 Gradio \u7684\u6279\u5904\u7406\u51fd\u6570 **requires** \u5728\u5e95\u5c42 Interface \u6216 Blocks \u4e2d\u542f\u7528\u961f\u5217\uff08\u8bf7\u53c2\u9605\u4e0a\u9762\u7684\u961f\u5217\u90e8\u5206\uff09\u3002\n\n## Gradio \u7b14\u8bb0\u672c (Colab Notebooks)\n\nGradio \u53ef\u4ee5\u5728\u4efb\u4f55\u8fd0\u884c Python \u7684\u5730\u65b9\u8fd0\u884c\uff0c\u5305\u62ec\u672c\u5730 Jupyter \u7b14\u8bb0\u672c\u548c\u534f\u4f5c\u7b14\u8bb0\u672c\uff0c\u5982[Google Colab](https://colab.research.google.com/)\u3002\u5bf9\u4e8e\u672c\u5730 Jupyter \u7b14\u8bb0\u672c\u548c Google Colab \u7b14\u8bb0\u672c\uff0cGradio \u5728\u672c\u5730\u670d\u52a1\u5668\u4e0a\u8fd0\u884c\uff0c\u60a8\u53ef\u4ee5\u5728\u6d4f\u89c8\u5668\u4e2d\u4e0e\u4e4b\u4ea4\u4e92\u3002\uff08\u6ce8\u610f\uff1a\u5bf9\u4e8e Google Colab\uff0c\u8fd9\u662f\u901a\u8fc7[\u670d\u52a1\u5de5\u4f5c\u5668\u96a7\u9053](https://github.com/tensorflow/tensorboard/blob/master/docs/design/colab_integration.md)\u5b9e\u73b0\u7684\uff0c\u60a8\u7684\u6d4f\u89c8\u5668\u9700\u8981\u542f\u7528 cookies\u3002\uff09\u5bf9\u4e8e\u5176\u4ed6\u8fdc\u7a0b\u7b14\u8bb0\u672c\uff0cGradio \u4e5f\u5c06\u5728\u670d\u52a1\u5668\u4e0a\u8fd0\u884c\uff0c\u4f46\u60a8\u9700\u8981\u4f7f\u7528[SSH \u96a7\u9053](https://coderwall.com/p/ohk6cg/remote-access-to-ipython-notebooks-via-ssh)\u5728\u672c\u5730\u6d4f\u89c8\u5668\u4e2d\u67e5\u770b\u5e94\u7528\u7a0b\u5e8f\u3002\u901a\u5e38\uff0c\u66f4\u7b80\u5355\u7684\u9009\u62e9\u662f\u4f7f\u7528 Gradio \u5185\u7f6e\u7684\u516c\u5171\u94fe\u63a5\uff0c[\u5728\u4e0b\u4e00\u7bc7\u6307\u5357\u4e2d\u8ba8\u8bba](/sharing-your-app/#sharing-demos)\u3002"
        }
    },
    {
        "sample_idx": 89,
        "question": "What is the minimum value of the 'Random Slider (Static)' in the Gradio demo?",
        "answer": "The minimum value is -10.2.",
        "rag_answer": "The minimum value of the 'Random Slider (Static)' in the Gradio demo is -10.2.",
        "rag_score": 5,
        "rag_feedback": "The system's response is completely correct, accurate, and factual. It directly answers the question by stating 'The minimum value of the 'Random Slider (Static)' in the Gradio demo is -10.2.' which is supported by the provided code snippet.",
        "rag_context": {
            "kg_context": "-----Entities-----\n    ```csv\n    id,\tentity,\ttype,\tdescription,\trankcreated_at\n1,\tGradio Demo,event,Gradio Demo is an event that showcases the functionality of Gradio's blocks_random_slider.,8,2025-03-24 13:18:47\n2,\tslider_1,technology,slider_1 is a specific slider used in Gradio's demo to create interactive interfaces.,1,2025-03-24 13:18:47\n3,\tslider_2,technology,slider_2 is a specific slider used in Gradio's demo to create interactive interfaces.,1,2025-03-24 13:18:47\n4,\tslider_3,technology,slider_3 is a specific slider used in Gradio's demo to create interactive interfaces.,1,2025-03-24 13:18:47\n5,\tslider_1,technology,slider_1 is a specific slider used in Gradio's demo to create interactive interfaces.,1,UNKNOWN\n6,\tblocks_random_slider,category,blocks_random_slider is a category of demo provided by Gradio, which includes interactive sliders.,1,UNKNOWN\n7,\tslider_3,technology,slider_3 is a specific slider used in Gradio's demo to create interactive interfaces.,1,UNKNOWN\n    ```\n    -----Relationships-----\n    ```csv\n    id,\tsource,\ttarget,\tdescription,\tkeywords,\tweight,\trank,\tcreated_at\n1,\tGradio Demo,slider_1,slider_1 is used in Gradio Demo to create interactive interfaces.,technology, event,6.0,9,2025-03-24 13:18:47\n2,\tGradio Demo,slider_2,slider_2 is used in Gradio Demo to create interactive interfaces.,technology, event,6.0,9,2025-03-24 13:18:47\n3,\tGradio Demo,slider_3,slider_3 is used in Gradio Demo to create interactive interfaces.,technology, event,6.0,9,2025-03-24 13:18:47\n4,\tGradio Demo,blocks_random_slider,Gradio Demo is an event that showcases the functionality of blocks_random_slider.,event, category,18.0,9,UNKNOWN\n5,\tGradio Demo,slider_1,slider_1 is used in Gradio Demo to create interactive interfaces.,technology, event,6.0,9,UNKNOWN\n6,\tGradio Demo,slider_3,slider_3 is used in Gradio Demo to create interactive interfaces.,technology, event,6.0,9,UNKNOWN\n    ```\n    -----Sources-----\n    ```csv\n    id,\tcontent\n1,\tGradio Demo: blocks_random_slider\n\n\n```\n!pip install -q gradio \n```\n\n\n```\n\nimport gradio as gr\n\n\ndef func(slider_1, slider_2):\n    return slider_1 * 5 + slider_2\n\n\nwith gr.Blocks() as demo:\n    slider = gr.Slider(minimum=-10.2, maximum=15, label=\"Random Slider (Static)\", randomize=True)\n    slider_1 = gr.Slider(minimum=100, maximum=200, label=\"Random Slider (Input 1)\", randomize=True)\n    slider_2 = gr.Slider(minimum=10, maximum=23.2, label=\"Random Slider (Input 2)\", randomize=True)\n    slider_3 = gr.Slider(value=3, label=\"Non random slider\")\n    btn = gr.Button(\"Run\")\n    btn.click(func, inputs=[slider_1, slider_2], outputs=gr.Number())\n\nif __name__ == \"__main__\":\n    demo.launch()\n\n```\n    ```",
            "vector_context": "[Created at: 2025-03-24 13:18:21]\nGradio Demo: blocks_random_slider\n\n\n```\n!pip install -q gradio \n```\n\n\n```\n\nimport gradio as gr\n\n\ndef func(slider_1, slider_2):\n    return slider_1 * 5 + slider_2\n\n\nwith gr.Blocks() as demo:\n    slider = gr.Slider(minimum=-10.2, maximum=15, label=\"Random Slider (Static)\", randomize=True)\n    slider_1 = gr.Slider(minimum=100, maximum=200, label=\"Random Slider (Input 1)\", randomize=True)\n    slider_2 = gr.Slider(minimum=10, maximum=23.2, label=\"Random Slider (Input 2)\", randomize=True)\n    slider_3 = gr.Slider(value=3, label=\"Non random slider\")\n    btn = gr.Button(\"Run\")\n    btn.click(func, inputs=[slider_1, slider_2], outputs=gr.Number())\n\nif __name__ == \"__main__\":\n    demo.launch()\n\n```\n--New Chunk--\n[Created at: 2025-03-24 13:16:48]\n\u4e3b\u8981\u7279\u70b9\n\n\u8ba9\u6211\u4eec\u6765\u4ecb\u7ecd\u4e00\u4e0b Gradio \u6700\u53d7\u6b22\u8fce\u7684\u4e00\u4e9b\u529f\u80fd\uff01\u8fd9\u91cc\u662f Gradio \u7684\u4e3b\u8981\u7279\u70b9\uff1a\n\n1. [\u6dfb\u52a0\u793a\u4f8b\u8f93\u5165](#example-inputs)\n2. [\u4f20\u9012\u81ea\u5b9a\u4e49\u9519\u8bef\u6d88\u606f](#errors)\n3. [\u6dfb\u52a0\u63cf\u8ff0\u5185\u5bb9](#descriptive-content)\n4. [\u8bbe\u7f6e\u65d7\u6807](#flagging)\n5. [\u9884\u5904\u7406\u548c\u540e\u5904\u7406](#preprocessing-and-postprocessing)\n6. [\u6837\u5f0f\u5316\u6f14\u793a](#styling)\n7. [\u6392\u961f\u7528\u6237](#queuing)\n8. [\u8fed\u4ee3\u8f93\u51fa](#iterative-outputs)\n9. [\u8fdb\u5ea6\u6761](#progress-bars)\n10. [\u6279\u5904\u7406\u51fd\u6570](#batch-functions)\n11. [\u5728\u534f\u4f5c\u7b14\u8bb0\u672c\u4e0a\u8fd0\u884c](#colab-notebooks)\n\n## \u793a\u4f8b\u8f93\u5165\n\n\u60a8\u53ef\u4ee5\u63d0\u4f9b\u7528\u6237\u53ef\u4ee5\u8f7b\u677e\u52a0\u8f7d\u5230 \"Interface\" \u4e2d\u7684\u793a\u4f8b\u6570\u636e\u3002\u8fd9\u5bf9\u4e8e\u6f14\u793a\u6a21\u578b\u671f\u671b\u7684\u8f93\u5165\u7c7b\u578b\u4ee5\u53ca\u6f14\u793a\u6570\u636e\u96c6\u548c\u6a21\u578b\u4e00\u8d77\u63a2\u7d22\u7684\u65b9\u5f0f\u975e\u5e38\u6709\u5e2e\u52a9\u3002\u8981\u52a0\u8f7d\u793a\u4f8b\u6570\u636e\uff0c\u60a8\u53ef\u4ee5\u5c06\u5d4c\u5957\u5217\u8868\u63d0\u4f9b\u7ed9 Interface \u6784\u9020\u51fd\u6570\u7684 `examples=` \u5173\u952e\u5b57\u53c2\u6570\u3002\u5916\u90e8\u5217\u8868\u4e2d\u7684\u6bcf\u4e2a\u5b50\u5217\u8868\u8868\u793a\u4e00\u4e2a\u6570\u636e\u6837\u672c\uff0c\u5b50\u5217\u8868\u4e2d\u7684\u6bcf\u4e2a\u5143\u7d20\u8868\u793a\u6bcf\u4e2a\u8f93\u5165\u7ec4\u4ef6\u7684\u8f93\u5165\u3002\u6709\u5173\u6bcf\u4e2a\u7ec4\u4ef6\u7684\u793a\u4f8b\u6570\u636e\u683c\u5f0f\u5728[Docs](https://gradio.app/docs#components)\u4e2d\u6709\u8bf4\u660e\u3002\n\n$code_calculator\n$demo_calculator\n\n\u60a8\u53ef\u4ee5\u5c06\u5927\u578b\u6570\u636e\u96c6\u52a0\u8f7d\u5230\u793a\u4f8b\u4e2d\uff0c\u901a\u8fc7 Gradio \u6d4f\u89c8\u548c\u4e0e\u6570\u636e\u96c6\u8fdb\u884c\u4ea4\u4e92\u3002\u793a\u4f8b\u5c06\u81ea\u52a8\u5206\u9875\uff08\u53ef\u4ee5\u901a\u8fc7 Interface \u7684 `examples_per_page` \u53c2\u6570\u8fdb\u884c\u914d\u7f6e\uff09\u3002\n\n\u7ee7\u7eed\u4e86\u89e3\u793a\u4f8b\uff0c\u8bf7\u53c2\u9605[\u66f4\u591a\u793a\u4f8b](https://gradio.app/more-on-examples)\u6307\u5357\u3002\n\n## \u9519\u8bef\n\n\u60a8\u5e0c\u671b\u5411\u7528\u6237\u4f20\u9012\u81ea\u5b9a\u4e49\u9519\u8bef\u6d88\u606f\u3002\u4e3a\u6b64\uff0cwith `gr.Error(\"custom message\")` \u6765\u663e\u793a\u9519\u8bef\u6d88\u606f\u3002\u5982\u679c\u5728\u4e0a\u9762\u7684\u8ba1\u7b97\u5668\u793a\u4f8b\u4e2d\u5c1d\u8bd5\u9664\u4ee5\u96f6\uff0c\u5c06\u663e\u793a\u81ea\u5b9a\u4e49\u9519\u8bef\u6d88\u606f\u7684\u5f39\u51fa\u6a21\u6001\u7a97\u53e3\u3002\u4e86\u89e3\u6709\u5173\u9519\u8bef\u7684\u66f4\u591a\u4fe1\u606f\uff0c\u8bf7\u53c2\u9605[\u6587\u6863](https://gradio.app/docs#error)\u3002\n\n## \u63cf\u8ff0\u6027\u5185\u5bb9\n\n\u5728\u524d\u9762\u7684\u793a\u4f8b\u4e2d\uff0c\u60a8\u53ef\u80fd\u5df2\u7ecf\u6ce8\u610f\u5230 Interface \u6784\u9020\u51fd\u6570\u4e2d\u7684 `title=` \u548c `description=` \u5173\u952e\u5b57\u53c2\u6570\uff0c\u5e2e\u52a9\u7528\u6237\u4e86\u89e3\u60a8\u7684\u5e94\u7528\u7a0b\u5e8f\u3002\n\nInterface \u6784\u9020\u51fd\u6570\u4e2d\u6709\u4e09\u4e2a\u53c2\u6570\u7528\u4e8e\u6307\u5b9a\u6b64\u5185\u5bb9\u5e94\u653e\u7f6e\u5728\u54ea\u91cc\uff1a\n\n- `title`\uff1a\u63a5\u53d7\u6587\u672c\uff0c\u5e76\u53ef\u4ee5\u5c06\u5176\u663e\u793a\u5728\u754c\u9762\u7684\u9876\u90e8\uff0c\u4e5f\u5c06\u6210\u4e3a\u9875\u9762\u6807\u9898\u3002\n- `description`\uff1a\u63a5\u53d7\u6587\u672c\u3001Markdown \u6216 HTML\uff0c\u5e76\u5c06\u5176\u653e\u7f6e\u5728\u6807\u9898\u6b63\u4e0b\u65b9\u3002\n- `article`\uff1a\u4e5f\u63a5\u53d7\u6587\u672c\u3001Markdown \u6216 HTML\uff0c\u5e76\u5c06\u5176\u653e\u7f6e\u5728\u754c\u9762\u4e0b\u65b9\u3002\n\n![annotated](/assets/guides/annotated.png)\n\n\u5982\u679c\u60a8\u4f7f\u7528\u7684\u662f `Blocks` API\uff0c\u5219\u53ef\u4ee5 with `gr.Markdown(...)` \u6216 `gr.HTML(...)` \u7ec4\u4ef6\u5728\u4efb\u4f55\u4f4d\u7f6e\u63d2\u5165\u6587\u672c\u3001Markdown \u6216 HTML\uff0c\u5176\u4e2d\u63cf\u8ff0\u6027\u5185\u5bb9\u4f4d\u4e8e `Component` \u6784\u9020\u51fd\u6570\u5185\u90e8\u3002\n\n\u53e6\u4e00\u4e2a\u6709\u7528\u7684\u5173\u952e\u5b57\u53c2\u6570\u662f `label=`\uff0c\u5b83\u5b58\u5728\u4e8e\u6bcf\u4e2a `Component` \u4e2d\u3002\u8fd9\u4fee\u6539\u4e86\u6bcf\u4e2a `Component` \u9876\u90e8\u7684\u6807\u7b7e\u6587\u672c\u3002\u8fd8\u53ef\u4ee5\u4e3a\u8bf8\u5982 `Textbox` \u6216 `Radio` \u4e4b\u7c7b\u7684\u8868\u5355\u5143\u7d20\u6dfb\u52a0 `info=` \u5173\u952e\u5b57\u53c2\u6570\uff0c\u4ee5\u63d0\u4f9b\u6709\u5173\u5176\u7528\u6cd5\u7684\u8fdb\u4e00\u6b65\u4fe1\u606f\u3002\n\n```python\ngr.Number(label='\u5e74\u9f84', info='\u4ee5\u5e74\u4e3a\u5355\u4f4d\uff0c\u5fc5\u987b\u5927\u4e8e0')\n```\n\n## \u65d7\u6807\n\n\u9ed8\u8ba4\u60c5\u51b5\u4e0b\uff0c\"Interface\" \u5c06\u6709\u4e00\u4e2a \"Flag\" \u6309\u94ae\u3002\u5f53\u7528\u6237\u6d4b\u8bd5\u60a8\u7684 `Interface` \u65f6\uff0c\u5982\u679c\u770b\u5230\u6709\u8da3\u7684\u8f93\u51fa\uff0c\u4f8b\u5982\u9519\u8bef\u6216\u610f\u5916\u7684\u6a21\u578b\u884c\u4e3a\uff0c\u4ed6\u4eec\u53ef\u4ee5\u5c06\u8f93\u5165\u6807\u8bb0\u4e3a\u60a8\u8fdb\u884c\u67e5\u770b\u3002\u5728\u7531 `Interface` \u6784\u9020\u51fd\u6570\u7684 `flagging_dir=` \u53c2\u6570\u63d0\u4f9b\u7684\u76ee\u5f55\u4e2d\uff0c\u5c06\u8bb0\u5f55\u6807\u8bb0\u7684\u8f93\u5165\u5230\u4e00\u4e2a CSV \u6587\u4ef6\u4e2d\u3002\u5982\u679c\u754c\u9762\u6d89\u53ca\u6587\u4ef6\u6570\u636e\uff0c\u4f8b\u5982\u56fe\u50cf\u548c\u97f3\u9891\u7ec4\u4ef6\uff0c\u5c06\u521b\u5efa\u6587\u4ef6\u5939\u6765\u5b58\u50a8\u8fd9\u4e9b\u6807\u8bb0\u7684\u6570\u636e\u3002\n\n\u4f8b\u5982\uff0c\u5bf9\u4e8e\u4e0a\u9762\u663e\u793a\u7684\u8ba1\u7b97\u5668\u754c\u9762\uff0c\u6211\u4eec\u5c06\u5728\u4e0b\u9762\u7684\u65d7\u6807\u76ee\u5f55\u4e2d\u5b58\u50a8\u6807\u8bb0\u7684\u6570\u636e\uff1a\n\n```directory\n+-- calculator.py\n+-- flagged/\n|   +-- logs.csv\n```\n\n_flagged/logs.csv_\n\n```csv\nnum1,operation,num2,Output\n5,add,7,12\n6,subtract,1.5,4.5\n```\n\n\u4e0e\u65e9\u671f\u663e\u793a\u7684\u51b7\u8272\u754c\u9762\u76f8\u5bf9\u5e94\uff0c\u6211\u4eec\u5c06\u5728\u4e0b\u9762\u7684\u65d7\u6807\u76ee\u5f55\u4e2d\u5b58\u50a8\u6807\u8bb0\u7684\u6570\u636e\uff1a\n\n```directory\n+-- sepia.py\n+-- flagged/\n|   +-- logs.csv\n|   +-- im/\n|   |   +-- 0.png\n|   |   +-- 1.png\n|   +-- Output/\n|   |   +-- 0.png\n|   |   +-- 1.png\n```\n\n_flagged/logs.csv_\n\n```csv\nim,Output\nim/0.png,Output/0.png\nim/1.png,Output/1.png\n```\n\n\u5982\u679c\u60a8\u5e0c\u671b\u7528\u6237\u63d0\u4f9b\u65d7\u6807\u539f\u56e0\uff0c\u53ef\u4ee5\u5c06\u5b57\u7b26\u4e32\u5217\u8868\u4f20\u9012\u7ed9 Interface \u7684 `flagging_options` \u53c2\u6570\u3002\u7528\u6237\u5728\u8fdb\u884c\u65d7\u6807\u65f6\u5fc5\u987b\u9009\u62e9\u5176\u4e2d\u4e00\u4e2a\u5b57\u7b26\u4e32\uff0c\u8fd9\u5c06\u4f5c\u4e3a\u9644\u52a0\u5217\u4fdd\u5b58\u5230 CSV \u4e2d\u3002\n\n## \u9884\u5904\u7406\u548c\u540e\u5904\u7406 (Preprocessing and Postprocessing)\n\n![annotated](/assets/img/dataflow.svg)\n\n\u5982\u60a8\u6240\u89c1\uff0cGradio \u5305\u62ec\u53ef\u4ee5\u5904\u7406\u5404\u79cd\u4e0d\u540c\u6570\u636e\u7c7b\u578b\u7684\u7ec4\u4ef6\uff0c\u4f8b\u5982\u56fe\u50cf\u3001\u97f3\u9891\u548c\u89c6\u9891\u3002\u5927\u591a\u6570\u7ec4\u4ef6\u90fd\u53ef\u4ee5\u7528\u4f5c\u8f93\u5165\u6216\u8f93\u51fa\u3002\n\n\u5f53\u7ec4\u4ef6\u7528\u4f5c\u8f93\u5165\u65f6\uff0cGradio \u81ea\u52a8\u5904\u7406*\u9884\u5904\u7406*\uff0c\u5c06\u6570\u636e\u4ece\u7528\u6237\n--New Chunk--\n[Created at: 2025-03-24 13:16:48]\n\u4e0e\u5e38\u89c4\u51fd\u6570\u76f8\u540c\u7684\u65b9\u5f0f\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio\u3002\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\uff08\u865a\u62df\u7684\uff09\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5b83\u5728\u8f93\u51fa\u56fe\u50cf\u4e4b\u524d\u751f\u6210\u6570\u4e2a\u6b65\u9aa4\u7684\u566a\u97f3\uff1a\n\n$code_fake_diffusion\n$demo_fake_diffusion\n\n\u8bf7\u6ce8\u610f\uff0c\u6211\u4eec\u5728\u8fed\u4ee3\u5668\u4e2d\u6dfb\u52a0\u4e86 `time.sleep(1)`\uff0c\u4ee5\u521b\u5efa\u6b65\u9aa4\u4e4b\u95f4\u7684\u4eba\u5de5\u6682\u505c\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u89c2\u5bdf\u8fed\u4ee3\u5668\u7684\u6b65\u9aa4\uff08\u5728\u771f\u5b9e\u7684\u56fe\u50cf\u751f\u6210\u6a21\u578b\u4e2d\uff0c\u8fd9\u53ef\u80fd\u662f\u4e0d\u5fc5\u8981\u7684\uff09\u3002\n\n\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio **\u9700\u8981**\u5728\u5e95\u5c42 Interface \u6216 Blocks \u4e2d\u542f\u7528\u961f\u5217\uff08\u8bf7\u53c2\u9605\u4e0a\u9762\u7684\u961f\u5217\u90e8\u5206\uff09\u3002\n\n## \u8fdb\u5ea6\u6761\n\nGradio \u652f\u6301\u521b\u5efa\u81ea\u5b9a\u4e49\u8fdb\u5ea6\u6761\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u81ea\u5b9a\u4e49\u548c\u63a7\u5236\u5411\u7528\u6237\u663e\u793a\u7684\u8fdb\u5ea6\u66f4\u65b0\u3002\u8981\u542f\u7528\u6b64\u529f\u80fd\uff0c\u53ea\u9700\u4e3a\u65b9\u6cd5\u6dfb\u52a0\u4e00\u4e2a\u9ed8\u8ba4\u503c\u4e3a `gr.Progress` \u5b9e\u4f8b\u7684\u53c2\u6570\u5373\u53ef\u3002\u7136\u540e\uff0c\u60a8\u53ef\u4ee5\u76f4\u63a5\u8c03\u7528\u6b64\u5b9e\u4f8b\u5e76\u4f20\u5165 0 \u5230 1 \u4e4b\u95f4\u7684\u6d6e\u70b9\u6570\u6765\u66f4\u65b0\u8fdb\u5ea6\u7ea7\u522b\uff0c\u6216\u8005 with `Progress` \u5b9e\u4f8b\u7684 `tqdm()` \u65b9\u6cd5\u6765\u8ddf\u8e2a\u53ef\u8fed\u4ee3\u5bf9\u8c61\u4e0a\u7684\u8fdb\u5ea6\uff0c\u5982\u4e0b\u6240\u793a\u3002\u5fc5\u987b\u542f\u7528\u961f\u5217\u4ee5\u8fdb\u884c\u8fdb\u5ea6\u66f4\u65b0\u3002\n\n$code_progress_simple\n$demo_progress_simple\n\n\u5982\u679c\u60a8 with `tqdm` \u5e93\uff0c\u5e76\u4e14\u5e0c\u671b\u4ece\u51fd\u6570\u5185\u90e8\u7684\u4efb\u4f55 `tqdm.tqdm` \u81ea\u52a8\u62a5\u544a\u8fdb\u5ea6\u66f4\u65b0\uff0c\u8bf7\u5c06\u9ed8\u8ba4\u53c2\u6570\u8bbe\u7f6e\u4e3a `gr.Progress(track_tqdm=True)`\uff01\n\n## \u6279\u5904\u7406\u51fd\u6570 (Batch Functions)\n\nGradio \u652f\u6301\u4f20\u9012*\u6279\u5904\u7406*\u51fd\u6570\u3002\u6279\u5904\u7406\u51fd\u6570\u53ea\u662f\u63a5\u53d7\u8f93\u5165\u5217\u8868\u5e76\u8fd4\u56de\u9884\u6d4b\u5217\u8868\u7684\u51fd\u6570\u3002\n\n\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\u6279\u5904\u7406\u51fd\u6570\uff0c\u5b83\u63a5\u53d7\u4e24\u4e2a\u8f93\u5165\u5217\u8868\uff08\u4e00\u4e2a\u5355\u8bcd\u5217\u8868\u548c\u4e00\u4e2a\u6574\u6570\u5217\u8868\uff09\uff0c\u5e76\u8fd4\u56de\u4fee\u526a\u8fc7\u7684\u5355\u8bcd\u5217\u8868\u4f5c\u4e3a\u8f93\u51fa\uff1a\n\n```python\nimport time\n\ndef trim_words(words, lens):\n    trimmed_words = []\n    time.sleep(5)\n    for w, l in zip(words, lens):\n        trimmed_words.append(w[:int(l)])\n    return [trimmed_words]\n    for w, l in zip(words, lens):\n```\n\n\u4f7f\u7528\u6279\u5904\u7406\u51fd\u6570\u7684\u4f18\u70b9\u662f\uff0c\u5982\u679c\u542f\u7528\u4e86\u961f\u5217\uff0cGradio \u670d\u52a1\u5668\u53ef\u4ee5\u81ea\u52a8*\u6279\u5904\u7406*\u4f20\u5165\u7684\u8bf7\u6c42\u5e76\u5e76\u884c\u5904\u7406\u5b83\u4eec\uff0c\u4ece\u800c\u53ef\u80fd\u52a0\u5feb\u6f14\u793a\u901f\u5ea6\u3002\u4ee5\u4e0b\u662f Gradio \u4ee3\u7801\u7684\u793a\u4f8b\uff08\u8bf7\u6ce8\u610f `batch=True` \u548c `max_batch_size=16` - \u8fd9\u4e24\u4e2a\u53c2\u6570\u90fd\u53ef\u4ee5\u4f20\u9012\u7ed9\u4e8b\u4ef6\u89e6\u53d1\u5668\u6216 `Interface` \u7c7b\uff09\n\nwith `Interface`\uff1a\n\n```python\ndemo = gr.Interface(trim_words, [\"textbox\", \"number\"], [\"output\"],\n                    batch=True, max_batch_size=16)\ndemo.queue()\ndemo.launch()\n```\n\nwith `Blocks`\uff1a\n\n```python\nimport gradio as gr\n\nwith gr.Blocks() as demo:\n    with gr.Row():\n        word = gr.Textbox(label=\"word\")\n        leng = gr.Number(label=\"leng\")\n        output = gr.Textbox(label=\"Output\")\n    with gr.Row():\n        run = gr.Button()\n\n    event = run.click(trim_words, [word, leng], output, batch=True, max_batch_size=16)\n\ndemo.queue()\ndemo.launch()\n```\n\n\u5728\u4e0a\u9762\u7684\u793a\u4f8b\u4e2d\uff0c\u53ef\u4ee5\u5e76\u884c\u5904\u7406 16 \u4e2a\u8bf7\u6c42\uff08\u603b\u63a8\u7406\u65f6\u95f4\u4e3a 5 \u79d2\uff09\uff0c\u800c\u4e0d\u662f\u5206\u522b\u5904\u7406\u6bcf\u4e2a\u8bf7\u6c42\uff08\u603b\u63a8\u7406\u65f6\u95f4\u4e3a 80 \u79d2\uff09\u3002\u8bb8\u591a Hugging Face \u7684 `transformers` \u548c `diffusers` \u6a21\u578b\u5728 Gradio \u7684\u6279\u5904\u7406\u6a21\u5f0f\u4e0b\u81ea\u7136\u5de5\u4f5c\uff1a\u8fd9\u662f[\u4f7f\u7528\u6279\u5904\u7406\u751f\u6210\u56fe\u50cf\u7684\u793a\u4f8b\u6f14\u793a](https://github.com/gradio-app/gradio/blob/main/demo/diffusers_with_batching/run.py)\n\n\u6ce8\u610f\uff1a\u4f7f\u7528 Gradio \u7684\u6279\u5904\u7406\u51fd\u6570 **requires** \u5728\u5e95\u5c42 Interface \u6216 Blocks \u4e2d\u542f\u7528\u961f\u5217\uff08\u8bf7\u53c2\u9605\u4e0a\u9762\u7684\u961f\u5217\u90e8\u5206\uff09\u3002\n\n## Gradio \u7b14\u8bb0\u672c (Colab Notebooks)\n\nGradio \u53ef\u4ee5\u5728\u4efb\u4f55\u8fd0\u884c Python \u7684\u5730\u65b9\u8fd0\u884c\uff0c\u5305\u62ec\u672c\u5730 Jupyter \u7b14\u8bb0\u672c\u548c\u534f\u4f5c\u7b14\u8bb0\u672c\uff0c\u5982[Google Colab](https://colab.research.google.com/)\u3002\u5bf9\u4e8e\u672c\u5730 Jupyter \u7b14\u8bb0\u672c\u548c Google Colab \u7b14\u8bb0\u672c\uff0cGradio \u5728\u672c\u5730\u670d\u52a1\u5668\u4e0a\u8fd0\u884c\uff0c\u60a8\u53ef\u4ee5\u5728\u6d4f\u89c8\u5668\u4e2d\u4e0e\u4e4b\u4ea4\u4e92\u3002\uff08\u6ce8\u610f\uff1a\u5bf9\u4e8e Google Colab\uff0c\u8fd9\u662f\u901a\u8fc7[\u670d\u52a1\u5de5\u4f5c\u5668\u96a7\u9053](https://github.com/tensorflow/tensorboard/blob/master/docs/design/colab_integration.md)\u5b9e\u73b0\u7684\uff0c\u60a8\u7684\u6d4f\u89c8\u5668\u9700\u8981\u542f\u7528 cookies\u3002\uff09\u5bf9\u4e8e\u5176\u4ed6\u8fdc\u7a0b\u7b14\u8bb0\u672c\uff0cGradio \u4e5f\u5c06\u5728\u670d\u52a1\u5668\u4e0a\u8fd0\u884c\uff0c\u4f46\u60a8\u9700\u8981\u4f7f\u7528[SSH \u96a7\u9053](https://coderwall.com/p/ohk6cg/remote-access-to-ipython-notebooks-via-ssh)\u5728\u672c\u5730\u6d4f\u89c8\u5668\u4e2d\u67e5\u770b\u5e94\u7528\u7a0b\u5e8f\u3002\u901a\u5e38\uff0c\u66f4\u7b80\u5355\u7684\u9009\u62e9\u662f\u4f7f\u7528 Gradio \u5185\u7f6e\u7684\u516c\u5171\u94fe\u63a5\uff0c[\u5728\u4e0b\u4e00\u7bc7\u6307\u5357\u4e2d\u8ba8\u8bba](/sharing-your-app/#sharing-demos)\u3002"
        }
    },
    {
        "sample_idx": 90,
        "question": "Where are SSH keys usually located on Mac and Linux?",
        "answer": "SSH keys are usually located under ~/.ssh on Mac & Linux.",
        "rag_answer": "SSH keys are usually located under `~/.ssh` on Mac and Linux.",
        "rag_score": 5,
        "rag_feedback": "The system's response is completely correct, accurate, and factual. It matches the expected answer exactly, stating that SSH keys are usually located under ~/.ssh on Mac and Linux.",
        "rag_context": {
            "kg_context": "-----Entities-----\n    ```csv\n    id,\tentity,\ttype,\tdescription,\trankcreated_at\n1,\tSSH,category,Gradio can be run on remote servers using SSH.<SEP>SSH is a secure protocol used for authentication and data transfer.,6,2025-03-24 13:19:17\n2,\tWindows,geo,Windows is a type of operating system.,1,2025-03-24 13:19:17\n3,\tLinux,geo,Linux is a type of operating system.,1,2025-03-24 13:19:17\n4,\tprivate key,category,Private key is a secure key used for SSH authentication.,1,2025-03-24 13:19:17\n5,\tpublic key,category,Public key is a secure key used for SSH authentication.,1,2025-03-24 13:19:17\n6,\t~/.ssh,geo,~/.ssh is a directory where SSH keys are usually stored on Mac and Linux.,0,UNKNOWN\n7,\tC:\\\\Users\\\\<username>\\\\.ssh,geo,C:\\\\Users\\\\<username>\\\\.ssh is a directory where SSH keys are usually stored on Windows.,0,UNKNOWN\n8,\t SSH,category,SSH is a protocol for secure remote access to computers.,0,UNKNOWN\n    ```\n    -----Relationships-----\n    ```csv\n    id,\tsource,\ttarget,\tdescription,\tkeywords,\tweight,\trank,\tcreated_at\n1,\tSSH,Windows,Windows is a platform that uses SSH for authentication.,platform, authentication,12.0,7,2025-03-24 13:19:17\n2,\tLinux,SSH,Linux is a platform that uses SSH for authentication.,platform, authentication,12.0,7,2025-03-24 13:19:17\n3,\tprivate key,public key,Private key is used to generate a public key for SSH authentication.,key generation, authentication,8.0,2,2025-03-24 13:19:17\n    ```\n    -----Sources-----\n    ```csv\n    id,\tcontent\n1,\tGit over SSH\n\nYou can access and write data in repositories on huggingface.co using SSH (Secure Shell Protocol). When you connect via SSH, you authenticate using a private key file on your local machine.\n\nSome actions, such as pushing changes, or cloning private repositories, will require you to upload your SSH public key to your account on huggingface.co.\n\nYou can use a pre-existing SSH key, or generate a new one specifically for huggingface.co.\n\n## Checking for existing SSH keys\n\nIf you have an existing SSH key, you can use that key to authenticate Git operations over SSH.\n\nSSH keys are usually located under `~/.ssh` on Mac & Linux, and under `C:\\\\Users\\\\<username>\\\\.ssh` on Windows. List files under that directory and look for files of the form:\n\n- id_rsa.pub\n- id_ecdsa.pub\n- id_ed25519.pub\n\nThose files contain your SSH public key.\n\nIf you don't have such file under `~/.ssh`, you will have to [generate a new key](#generating-a-new-ssh-keypair). Otherwise, you can [add your existing SSH public key(s) to your huggingface.co account](#add-a-ssh-key-to-your-account).\n\n## Generating a new SSH keypair\n\nIf you don't have any SSH keys on your machine, you can use `ssh-keygen` to generate a new SSH key pair (public + private keys):\n\n```\n$ ssh-keygen -t ed25519 -C \"your.email@example.co\"\n```\n\nWe recommend entering a passphrase when you are prompted to. A passphrase is an extra layer of security: it is a password that will be prompted whenever you use your SSH key.\n\nOnce your new key is generated, add it to your SSH agent with `ssh-add`:\n\n```\n$ ssh-add ~/.ssh/id_ed25519\n```\n\nIf you chose a different location than the default to store your SSH key, you would have to replace `~/.ssh/id_ed25519` with the file location you used.\n\n## Add a SSH key to your account\n\nTo access private repositories with SSH, or to push changes via SSH, you will need to add your SSH public key to your huggingface.co account. You can manage your SSH keys [in your user settings](https://huggingface.co/settings/keys).\n\nTo add a SSH key to your account, click on the \"Add SSH key\" button.\n\nThen, enter a name for this key (for example, \"Personal computer\"), and copy and paste the content of your **public** SSH key in the area below. The public key is located in the `~/.ssh/id_XXXX.pub` file you found or generated in the previous steps.\n\nClick on \"Add key\", and voil\u00e0! You have added a SSH key to your huggingface.co account.\n\n\n## Testing your SSH authentication\n\nOnce you have added your SSH key to your huggingface.co account, you can test that the connection works as expected.\n\nIn a terminal, run:\n```\n$ ssh -T git@hf.co\n```\n\nIf you see a message with your username, congrats! Everything went well, you are ready to use git over SSH.\n\nOtherwise, if the message states something like the following, make sure your SSH key is actually used by your SSH agent.\n```\nHi anonymous, welcome to Hugging Face.\n```\n2,\t\u4e0e\u5e38\u89c4\u51fd\u6570\u76f8\u540c\u7684\u65b9\u5f0f\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio\u3002\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\uff08\u865a\u62df\u7684\uff09\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5b83\u5728\u8f93\u51fa\u56fe\u50cf\u4e4b\u524d\u751f\u6210\u6570\u4e2a\u6b65\u9aa4\u7684\u566a\u97f3\uff1a\n\n$code_fake_diffusion\n$demo_fake_diffusion\n\n\u8bf7\u6ce8\u610f\uff0c\u6211\u4eec\u5728\u8fed\u4ee3\u5668\u4e2d\u6dfb\u52a0\u4e86 `time.sleep(1)`\uff0c\u4ee5\u521b\u5efa\u6b65\u9aa4\u4e4b\u95f4\u7684\u4eba\u5de5\u6682\u505c\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u89c2\u5bdf\u8fed\u4ee3\u5668\u7684\u6b65\u9aa4\uff08\u5728\u771f\u5b9e\u7684\u56fe\u50cf\u751f\u6210\u6a21\u578b\u4e2d\uff0c\u8fd9\u53ef\u80fd\u662f\u4e0d\u5fc5\u8981\u7684\uff09\u3002\n\n\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio **\u9700\u8981**\u5728\u5e95\u5c42 Interface \u6216 Blocks \u4e2d\u542f\u7528\u961f\u5217\uff08\u8bf7\u53c2\u9605\u4e0a\u9762\u7684\u961f\u5217\u90e8\u5206\uff09\u3002\n\n## \u8fdb\u5ea6\u6761\n\nGradio \u652f\u6301\u521b\u5efa\u81ea\u5b9a\u4e49\u8fdb\u5ea6\u6761\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u81ea\u5b9a\u4e49\u548c\u63a7\u5236\u5411\u7528\u6237\u663e\u793a\u7684\u8fdb\u5ea6\u66f4\u65b0\u3002\u8981\u542f\u7528\u6b64\u529f\u80fd\uff0c\u53ea\u9700\u4e3a\u65b9\u6cd5\u6dfb\u52a0\u4e00\u4e2a\u9ed8\u8ba4\u503c\u4e3a `gr.Progress` \u5b9e\u4f8b\u7684\u53c2\u6570\u5373\u53ef\u3002\u7136\u540e\uff0c\u60a8\u53ef\u4ee5\u76f4\u63a5\u8c03\u7528\u6b64\u5b9e\u4f8b\u5e76\u4f20\u5165 0 \u5230 1 \u4e4b\u95f4\u7684\u6d6e\u70b9\u6570\u6765\u66f4\u65b0\u8fdb\u5ea6\u7ea7\u522b\uff0c\u6216\u8005 with `Progress` \u5b9e\u4f8b\u7684 `tqdm()` \u65b9\u6cd5\u6765\u8ddf\u8e2a\u53ef\u8fed\u4ee3\u5bf9\u8c61\u4e0a\u7684\u8fdb\u5ea6\uff0c\u5982\u4e0b\u6240\u793a\u3002\u5fc5\u987b\u542f\u7528\u961f\u5217\u4ee5\u8fdb\u884c\u8fdb\u5ea6\u66f4\u65b0\u3002\n\n$code_progress_simple\n$demo_progress_simple\n\n\u5982\u679c\u60a8 with `tqdm` \u5e93\uff0c\u5e76\u4e14\u5e0c\u671b\u4ece\u51fd\u6570\u5185\u90e8\u7684\u4efb\u4f55 `tqdm.tqdm` \u81ea\u52a8\u62a5\u544a\u8fdb\u5ea6\u66f4\u65b0\uff0c\u8bf7\u5c06\u9ed8\u8ba4\u53c2\u6570\u8bbe\u7f6e\u4e3a `gr.Progress(track_tqdm=True)`\uff01\n\n## \u6279\u5904\u7406\u51fd\u6570 (Batch Functions)\n\nGradio \u652f\u6301\u4f20\u9012*\u6279\u5904\u7406*\u51fd\u6570\u3002\u6279\u5904\u7406\u51fd\u6570\u53ea\u662f\u63a5\u53d7\u8f93\u5165\u5217\u8868\u5e76\u8fd4\u56de\u9884\u6d4b\u5217\u8868\u7684\u51fd\u6570\u3002\n\n\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\u6279\u5904\u7406\u51fd\u6570\uff0c\u5b83\u63a5\u53d7\u4e24\u4e2a\u8f93\u5165\u5217\u8868\uff08\u4e00\u4e2a\u5355\u8bcd\u5217\u8868\u548c\u4e00\u4e2a\u6574\u6570\u5217\u8868\uff09\uff0c\u5e76\u8fd4\u56de\u4fee\u526a\u8fc7\u7684\u5355\u8bcd\u5217\u8868\u4f5c\u4e3a\u8f93\u51fa\uff1a\n\n```python\nimport time\n\ndef trim_words(words, lens):\n    trimmed_words = []\n    time.sleep(5)\n    for w, l in zip(words, lens):\n        trimmed_words.append(w[:int(l)])\n    return [trimmed_words]\n    for w, l in zip(words, lens):\n```\n\n\u4f7f\u7528\u6279\u5904\u7406\u51fd\u6570\u7684\u4f18\u70b9\u662f\uff0c\u5982\u679c\u542f\u7528\u4e86\u961f\u5217\uff0cGradio \u670d\u52a1\u5668\u53ef\u4ee5\u81ea\u52a8*\u6279\u5904\u7406*\u4f20\u5165\u7684\u8bf7\u6c42\u5e76\u5e76\u884c\u5904\u7406\u5b83\u4eec\uff0c\u4ece\u800c\u53ef\u80fd\u52a0\u5feb\u6f14\u793a\u901f\u5ea6\u3002\u4ee5\u4e0b\u662f Gradio \u4ee3\u7801\u7684\u793a\u4f8b\uff08\u8bf7\u6ce8\u610f `batch=True` \u548c `max_batch_size=16` - \u8fd9\u4e24\u4e2a\u53c2\u6570\u90fd\u53ef\u4ee5\u4f20\u9012\u7ed9\u4e8b\u4ef6\u89e6\u53d1\u5668\u6216 `Interface` \u7c7b\uff09\n\nwith `Interface`\uff1a\n\n```python\ndemo = gr.Interface(trim_words, [\"textbox\", \"number\"], [\"output\"],\n                    batch=True, max_batch_size=16)\ndemo.queue()\ndemo.launch()\n```\n\nwith `Blocks`\uff1a\n\n```python\nimport gradio as gr\n\nwith gr.Blocks() as demo:\n    with gr.Row():\n        word = gr.Textbox(label=\"word\")\n        leng = gr.Number(label=\"leng\")\n        output = gr.Textbox(label=\"Output\")\n    with gr.Row():\n        run = gr.Button()\n\n    event = run.click(trim_words, [word, leng], output, batch=True, max_batch_size=16)\n\ndemo.queue()\ndemo.launch()\n```\n\n\u5728\u4e0a\u9762\u7684\u793a\u4f8b\u4e2d\uff0c\u53ef\u4ee5\u5e76\u884c\u5904\u7406 16 \u4e2a\u8bf7\u6c42\uff08\u603b\u63a8\u7406\u65f6\u95f4\u4e3a 5 \u79d2\uff09\uff0c\u800c\u4e0d\u662f\u5206\u522b\u5904\u7406\u6bcf\u4e2a\u8bf7\u6c42\uff08\u603b\u63a8\u7406\u65f6\u95f4\u4e3a 80 \u79d2\uff09\u3002\u8bb8\u591a Hugging Face \u7684 `transformers` \u548c `diffusers` \u6a21\u578b\u5728 Gradio \u7684\u6279\u5904\u7406\u6a21\u5f0f\u4e0b\u81ea\u7136\u5de5\u4f5c\uff1a\u8fd9\u662f[\u4f7f\u7528\u6279\u5904\u7406\u751f\u6210\u56fe\u50cf\u7684\u793a\u4f8b\u6f14\u793a](https://github.com/gradio-app/gradio/blob/main/demo/diffusers_with_batching/run.py)\n\n\u6ce8\u610f\uff1a\u4f7f\u7528 Gradio \u7684\u6279\u5904\u7406\u51fd\u6570 **requires** \u5728\u5e95\u5c42 Interface \u6216 Blocks \u4e2d\u542f\u7528\u961f\u5217\uff08\u8bf7\u53c2\u9605\u4e0a\u9762\u7684\u961f\u5217\u90e8\u5206\uff09\u3002\n\n## Gradio \u7b14\u8bb0\u672c (Colab Notebooks)\n\nGradio \u53ef\u4ee5\u5728\u4efb\u4f55\u8fd0\u884c Python \u7684\u5730\u65b9\u8fd0\u884c\uff0c\u5305\u62ec\u672c\u5730 Jupyter \u7b14\u8bb0\u672c\u548c\u534f\u4f5c\u7b14\u8bb0\u672c\uff0c\u5982[Google Colab](https://colab.research.google.com/)\u3002\u5bf9\u4e8e\u672c\u5730 Jupyter \u7b14\u8bb0\u672c\u548c Google Colab \u7b14\u8bb0\u672c\uff0cGradio \u5728\u672c\u5730\u670d\u52a1\u5668\u4e0a\u8fd0\u884c\uff0c\u60a8\u53ef\u4ee5\u5728\u6d4f\u89c8\u5668\u4e2d\u4e0e\u4e4b\u4ea4\u4e92\u3002\uff08\u6ce8\u610f\uff1a\u5bf9\u4e8e Google Colab\uff0c\u8fd9\u662f\u901a\u8fc7[\u670d\u52a1\u5de5\u4f5c\u5668\u96a7\u9053](https://github.com/tensorflow/tensorboard/blob/master/docs/design/colab_integration.md)\u5b9e\u73b0\u7684\uff0c\u60a8\u7684\u6d4f\u89c8\u5668\u9700\u8981\u542f\u7528 cookies\u3002\uff09\u5bf9\u4e8e\u5176\u4ed6\u8fdc\u7a0b\u7b14\u8bb0\u672c\uff0cGradio \u4e5f\u5c06\u5728\u670d\u52a1\u5668\u4e0a\u8fd0\u884c\uff0c\u4f46\u60a8\u9700\u8981\u4f7f\u7528[SSH \u96a7\u9053](https://coderwall.com/p/ohk6cg/remote-access-to-ipython-notebooks-via-ssh)\u5728\u672c\u5730\u6d4f\u89c8\u5668\u4e2d\u67e5\u770b\u5e94\u7528\u7a0b\u5e8f\u3002\u901a\u5e38\uff0c\u66f4\u7b80\u5355\u7684\u9009\u62e9\u662f\u4f7f\u7528 Gradio \u5185\u7f6e\u7684\u516c\u5171\u94fe\u63a5\uff0c[\u5728\u4e0b\u4e00\u7bc7\u6307\u5357\u4e2d\u8ba8\u8bba](/sharing-your-app/#sharing-demos)\u3002\n    ```",
            "vector_context": "[Created at: 2025-03-24 13:18:47]\nGit over SSH\n\nYou can access and write data in repositories on huggingface.co using SSH (Secure Shell Protocol). When you connect via SSH, you authenticate using a private key file on your local machine.\n\nSome actions, such as pushing changes, or cloning private repositories, will require you to upload your SSH public key to your account on huggingface.co.\n\nYou can use a pre-existing SSH key, or generate a new one specifically for huggingface.co.\n\n## Checking for existing SSH keys\n\nIf you have an existing SSH key, you can use that key to authenticate Git operations over SSH.\n\nSSH keys are usually located under `~/.ssh` on Mac & Linux, and under `C:\\\\Users\\\\<username>\\\\.ssh` on Windows. List files under that directory and look for files of the form:\n\n- id_rsa.pub\n- id_ecdsa.pub\n- id_ed25519.pub\n\nThose files contain your SSH public key.\n\nIf you don't have such file under `~/.ssh`, you will have to [generate a new key](#generating-a-new-ssh-keypair). Otherwise, you can [add your existing SSH public key(s) to your huggingface.co account](#add-a-ssh-key-to-your-account).\n\n## Generating a new SSH keypair\n\nIf you don't have any SSH keys on your machine, you can use `ssh-keygen` to generate a new SSH key pair (public + private keys):\n\n```\n$ ssh-keygen -t ed25519 -C \"your.email@example.co\"\n```\n\nWe recommend entering a passphrase when you are prompted to. A passphrase is an extra layer of security: it is a password that will be prompted whenever you use your SSH key.\n\nOnce your new key is generated, add it to your SSH agent with `ssh-add`:\n\n```\n$ ssh-add ~/.ssh/id_ed25519\n```\n\nIf you chose a different location than the default to store your SSH key, you would have to replace `~/.ssh/id_ed25519` with the file location you used.\n\n## Add a SSH key to your account\n\nTo access private repositories with SSH, or to push changes via SSH, you will need to add your SSH public key to your huggingface.co account. You can manage your SSH keys [in your user settings](https://huggingface.co/settings/keys).\n\nTo add a SSH key to your account, click on the \"Add SSH key\" button.\n\nThen, enter a name for this key (for example, \"Personal computer\"), and copy and paste the content of your **public** SSH key in the area below. The public key is located in the `~/.ssh/id_XXXX.pub` file you found or generated in the previous steps.\n\nClick on \"Add key\", and voil\u00e0! You have added a SSH key to your huggingface.co account.\n\n\n## Testing your SSH authentication\n\nOnce you have added your SSH key to your huggingface.co account, you can test that the connection works as expected.\n\nIn a terminal, run:\n```\n$ ssh -T git@hf.co\n```\n\nIf you see a message with your username, congrats! Everything went well, you are ready to use git over SSH.\n\nOtherwise, if the message states something like the following, make sure your SSH key is actually used by your SSH agent.\n```\nHi anonymous, welcome to Hugging Face.\n```\n--New Chunk--\n[Created at: 2025-03-24 13:15:42]\nCreate an Endpoint\n\nAfter your first login, you will be directed to the [Endpoint creation page](https://ui.endpoints.huggingface.co/new). As an example, this guide will go through the steps to deploy [distilbert-base-uncased-finetuned-sst-2-english](https://huggingface.co/distilbert-base-uncased-finetuned-sst-2-english) for text classification. \n\n## 1. Enter the Hugging Face Repository ID and your desired endpoint name:\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_repository.png\" alt=\"select repository\" />\n\n## 2. Select your Cloud Provider and region. Initially, only AWS will be available as a Cloud Provider with the `us-east-1` and `eu-west-1` regions. We will add Azure soon, and if you need to test Endpoints with other Cloud Providers or regions, please let us know.\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_region.png\" alt=\"select region\" />\n\n## 3. Define the [Security Level](security) for the Endpoint:\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_security.png\" alt=\"define security\" />\n\n## 4. Create your Endpoint by clicking **Create Endpoint**. By default, your Endpoint is created with a medium CPU (2 x 4GB vCPUs with Intel Xeon Ice Lake) The cost estimate assumes the Endpoint will be up for an entire month, and does not take autoscaling into account.\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_create_cost.png\" alt=\"create endpoint\" />\n\n## 5. Wait for the Endpoint to build, initialize and run which can take between 1 to 5 minutes.\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/overview.png\" alt=\"overview\" />\n\n## 6. Test your Endpoint in the overview with the Inference widget \ud83c\udfc1 \ud83c\udf89!\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_inference.png\" alt=\"run inference\" />\n--New Chunk--\n[Created at: 2025-03-24 13:19:17]\n!---\nCopyright 2022 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n-->\n\n# Token classification with LayoutLMv3 (PyTorch version)\n\nThis directory contains a script, `run_funsd_cord.py`, that can be used to fine-tune (or evaluate) LayoutLMv3 on form understanding datasets, such as [FUNSD](https://guillaumejaume.github.io/FUNSD/) and [CORD](https://github.com/clovaai/cord).\n\nThe script `run_funsd_cord.py` leverages the \ud83e\udd17 Datasets library and the Trainer API. You can easily customize it to your needs.\n\n## Fine-tuning on FUNSD\n\nFine-tuning LayoutLMv3 for token classification on [FUNSD](https://guillaumejaume.github.io/FUNSD/) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name funsd \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 1e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-funsd\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd. By specifying the `push_to_hub` flag, the model gets uploaded automatically to the hub (regularly), together with a model card, which includes metrics such as precision, recall and F1. Note that you can easily update the model card, as it's just a README file of the respective repo on the hub.\n\nThere's also the \"Training metrics\" [tab](https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd/tensorboard), which shows Tensorboard logs over the course of training. Pretty neat, huh?\n\n## Fine-tuning on CORD\n\nFine-tuning LayoutLMv3 for token classification on [CORD](https://github.com/clovaai/cord) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name cord \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 5e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-cord\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-cord. Note that a model card gets generated automatically in case you specify the `push_to_hub` flag."
        }
    },
    {
        "sample_idx": 91,
        "question": "Where are SSH keys usually located on Windows?",
        "answer": "SSH keys are usually located under C:\\Users\\<username>\\.ssh on Windows.",
        "rag_answer": "SSH keys are usually located under `C:\\\\Users\\\\<username>\\\\.ssh` on Windows.",
        "rag_score": 5,
        "rag_feedback": "The system's response is completely correct, accurate, and factual. It provides the exact location of SSH keys on Windows, which is under C:\\\\Users\\\\<username>\\\\.ssh.",
        "rag_context": {
            "kg_context": "-----Entities-----\n    ```csv\n    id,\tentity,\ttype,\tdescription,\trankcreated_at\n1,\tGradio,organization,Gradio is a platform that supports state in Blocks, providing features such as global state and session state.<SEP>Gradio is an interface that provides various features for demonstrating models, including adding example inputs, custom error messages, descriptive content, flagging, and more.<SEP>Gradio is an organization that provides a platform for building and deploying machine learning models.<SEP>Gradio is an organization that provides a platform for creating and deploying machine learning models.<SEP>Gradio is an organization that provides a demo for blocks_random_slider, and its library is used to create interactive interfaces.,36,2025-03-24 13:19:17\n2,\tSSH,category,Gradio can be run on remote servers using SSH.<SEP>SSH is a secure protocol used for authentication and data transfer.,6,2025-03-24 13:19:17\n3,\tWindows,geo,Windows is a type of operating system.,1,2025-03-24 13:19:17\n4,\tprivate key,category,Private key is a secure key used for SSH authentication.,1,2025-03-24 13:19:17\n5,\tpublic key,category,Public key is a secure key used for SSH authentication.,1,2025-03-24 13:19:17\n6,\tC:\\\\Users\\\\<username>\\\\.ssh,geo,C:\\\\Users\\\\<username>\\\\.ssh is a directory where SSH keys are usually stored on Windows.,0,UNKNOWN\n7,\t~/.ssh,geo,~/.ssh is a directory where SSH keys are usually stored on Mac and Linux.,0,UNKNOWN\n8,\tuser settings,category,user settings is a section on the huggingface.co platform where users can manage their SSH keys.,1,UNKNOWN\n    ```\n    -----Relationships-----\n    ```csv\n    id,\tsource,\ttarget,\tdescription,\tkeywords,\tweight,\trank,\tcreated_at\n1,\tGradio,SSH,Gradio can be run on remote servers using SSH.,remote access, security,7.0,42,2025-03-24 13:17:31\n2,\tSSH,Windows,Windows is a platform that uses SSH for authentication.,platform, authentication,12.0,7,2025-03-24 13:19:17\n3,\tprivate key,public key,Private key is used to generate a public key for SSH authentication.,key generation, authentication,8.0,2,2025-03-24 13:19:17\n4,\thuggingface.co account,user settings,user settings is a section on the huggingface.co platform where users can manage their SSH keys.,account management, settings,6.0,3,UNKNOWN\n    ```\n    -----Sources-----\n    ```csv\n    id,\tcontent\n1,\t\u4e0e\u5e38\u89c4\u51fd\u6570\u76f8\u540c\u7684\u65b9\u5f0f\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio\u3002\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\uff08\u865a\u62df\u7684\uff09\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5b83\u5728\u8f93\u51fa\u56fe\u50cf\u4e4b\u524d\u751f\u6210\u6570\u4e2a\u6b65\u9aa4\u7684\u566a\u97f3\uff1a\n\n$code_fake_diffusion\n$demo_fake_diffusion\n\n\u8bf7\u6ce8\u610f\uff0c\u6211\u4eec\u5728\u8fed\u4ee3\u5668\u4e2d\u6dfb\u52a0\u4e86 `time.sleep(1)`\uff0c\u4ee5\u521b\u5efa\u6b65\u9aa4\u4e4b\u95f4\u7684\u4eba\u5de5\u6682\u505c\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u89c2\u5bdf\u8fed\u4ee3\u5668\u7684\u6b65\u9aa4\uff08\u5728\u771f\u5b9e\u7684\u56fe\u50cf\u751f\u6210\u6a21\u578b\u4e2d\uff0c\u8fd9\u53ef\u80fd\u662f\u4e0d\u5fc5\u8981\u7684\uff09\u3002\n\n\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio **\u9700\u8981**\u5728\u5e95\u5c42 Interface \u6216 Blocks \u4e2d\u542f\u7528\u961f\u5217\uff08\u8bf7\u53c2\u9605\u4e0a\u9762\u7684\u961f\u5217\u90e8\u5206\uff09\u3002\n\n## \u8fdb\u5ea6\u6761\n\nGradio \u652f\u6301\u521b\u5efa\u81ea\u5b9a\u4e49\u8fdb\u5ea6\u6761\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u81ea\u5b9a\u4e49\u548c\u63a7\u5236\u5411\u7528\u6237\u663e\u793a\u7684\u8fdb\u5ea6\u66f4\u65b0\u3002\u8981\u542f\u7528\u6b64\u529f\u80fd\uff0c\u53ea\u9700\u4e3a\u65b9\u6cd5\u6dfb\u52a0\u4e00\u4e2a\u9ed8\u8ba4\u503c\u4e3a `gr.Progress` \u5b9e\u4f8b\u7684\u53c2\u6570\u5373\u53ef\u3002\u7136\u540e\uff0c\u60a8\u53ef\u4ee5\u76f4\u63a5\u8c03\u7528\u6b64\u5b9e\u4f8b\u5e76\u4f20\u5165 0 \u5230 1 \u4e4b\u95f4\u7684\u6d6e\u70b9\u6570\u6765\u66f4\u65b0\u8fdb\u5ea6\u7ea7\u522b\uff0c\u6216\u8005 with `Progress` \u5b9e\u4f8b\u7684 `tqdm()` \u65b9\u6cd5\u6765\u8ddf\u8e2a\u53ef\u8fed\u4ee3\u5bf9\u8c61\u4e0a\u7684\u8fdb\u5ea6\uff0c\u5982\u4e0b\u6240\u793a\u3002\u5fc5\u987b\u542f\u7528\u961f\u5217\u4ee5\u8fdb\u884c\u8fdb\u5ea6\u66f4\u65b0\u3002\n\n$code_progress_simple\n$demo_progress_simple\n\n\u5982\u679c\u60a8 with `tqdm` \u5e93\uff0c\u5e76\u4e14\u5e0c\u671b\u4ece\u51fd\u6570\u5185\u90e8\u7684\u4efb\u4f55 `tqdm.tqdm` \u81ea\u52a8\u62a5\u544a\u8fdb\u5ea6\u66f4\u65b0\uff0c\u8bf7\u5c06\u9ed8\u8ba4\u53c2\u6570\u8bbe\u7f6e\u4e3a `gr.Progress(track_tqdm=True)`\uff01\n\n## \u6279\u5904\u7406\u51fd\u6570 (Batch Functions)\n\nGradio \u652f\u6301\u4f20\u9012*\u6279\u5904\u7406*\u51fd\u6570\u3002\u6279\u5904\u7406\u51fd\u6570\u53ea\u662f\u63a5\u53d7\u8f93\u5165\u5217\u8868\u5e76\u8fd4\u56de\u9884\u6d4b\u5217\u8868\u7684\u51fd\u6570\u3002\n\n\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\u6279\u5904\u7406\u51fd\u6570\uff0c\u5b83\u63a5\u53d7\u4e24\u4e2a\u8f93\u5165\u5217\u8868\uff08\u4e00\u4e2a\u5355\u8bcd\u5217\u8868\u548c\u4e00\u4e2a\u6574\u6570\u5217\u8868\uff09\uff0c\u5e76\u8fd4\u56de\u4fee\u526a\u8fc7\u7684\u5355\u8bcd\u5217\u8868\u4f5c\u4e3a\u8f93\u51fa\uff1a\n\n```python\nimport time\n\ndef trim_words(words, lens):\n    trimmed_words = []\n    time.sleep(5)\n    for w, l in zip(words, lens):\n        trimmed_words.append(w[:int(l)])\n    return [trimmed_words]\n    for w, l in zip(words, lens):\n```\n\n\u4f7f\u7528\u6279\u5904\u7406\u51fd\u6570\u7684\u4f18\u70b9\u662f\uff0c\u5982\u679c\u542f\u7528\u4e86\u961f\u5217\uff0cGradio \u670d\u52a1\u5668\u53ef\u4ee5\u81ea\u52a8*\u6279\u5904\u7406*\u4f20\u5165\u7684\u8bf7\u6c42\u5e76\u5e76\u884c\u5904\u7406\u5b83\u4eec\uff0c\u4ece\u800c\u53ef\u80fd\u52a0\u5feb\u6f14\u793a\u901f\u5ea6\u3002\u4ee5\u4e0b\u662f Gradio \u4ee3\u7801\u7684\u793a\u4f8b\uff08\u8bf7\u6ce8\u610f `batch=True` \u548c `max_batch_size=16` - \u8fd9\u4e24\u4e2a\u53c2\u6570\u90fd\u53ef\u4ee5\u4f20\u9012\u7ed9\u4e8b\u4ef6\u89e6\u53d1\u5668\u6216 `Interface` \u7c7b\uff09\n\nwith `Interface`\uff1a\n\n```python\ndemo = gr.Interface(trim_words, [\"textbox\", \"number\"], [\"output\"],\n                    batch=True, max_batch_size=16)\ndemo.queue()\ndemo.launch()\n```\n\nwith `Blocks`\uff1a\n\n```python\nimport gradio as gr\n\nwith gr.Blocks() as demo:\n    with gr.Row():\n        word = gr.Textbox(label=\"word\")\n        leng = gr.Number(label=\"leng\")\n        output = gr.Textbox(label=\"Output\")\n    with gr.Row():\n        run = gr.Button()\n\n    event = run.click(trim_words, [word, leng], output, batch=True, max_batch_size=16)\n\ndemo.queue()\ndemo.launch()\n```\n\n\u5728\u4e0a\u9762\u7684\u793a\u4f8b\u4e2d\uff0c\u53ef\u4ee5\u5e76\u884c\u5904\u7406 16 \u4e2a\u8bf7\u6c42\uff08\u603b\u63a8\u7406\u65f6\u95f4\u4e3a 5 \u79d2\uff09\uff0c\u800c\u4e0d\u662f\u5206\u522b\u5904\u7406\u6bcf\u4e2a\u8bf7\u6c42\uff08\u603b\u63a8\u7406\u65f6\u95f4\u4e3a 80 \u79d2\uff09\u3002\u8bb8\u591a Hugging Face \u7684 `transformers` \u548c `diffusers` \u6a21\u578b\u5728 Gradio \u7684\u6279\u5904\u7406\u6a21\u5f0f\u4e0b\u81ea\u7136\u5de5\u4f5c\uff1a\u8fd9\u662f[\u4f7f\u7528\u6279\u5904\u7406\u751f\u6210\u56fe\u50cf\u7684\u793a\u4f8b\u6f14\u793a](https://github.com/gradio-app/gradio/blob/main/demo/diffusers_with_batching/run.py)\n\n\u6ce8\u610f\uff1a\u4f7f\u7528 Gradio \u7684\u6279\u5904\u7406\u51fd\u6570 **requires** \u5728\u5e95\u5c42 Interface \u6216 Blocks \u4e2d\u542f\u7528\u961f\u5217\uff08\u8bf7\u53c2\u9605\u4e0a\u9762\u7684\u961f\u5217\u90e8\u5206\uff09\u3002\n\n## Gradio \u7b14\u8bb0\u672c (Colab Notebooks)\n\nGradio \u53ef\u4ee5\u5728\u4efb\u4f55\u8fd0\u884c Python \u7684\u5730\u65b9\u8fd0\u884c\uff0c\u5305\u62ec\u672c\u5730 Jupyter \u7b14\u8bb0\u672c\u548c\u534f\u4f5c\u7b14\u8bb0\u672c\uff0c\u5982[Google Colab](https://colab.research.google.com/)\u3002\u5bf9\u4e8e\u672c\u5730 Jupyter \u7b14\u8bb0\u672c\u548c Google Colab \u7b14\u8bb0\u672c\uff0cGradio \u5728\u672c\u5730\u670d\u52a1\u5668\u4e0a\u8fd0\u884c\uff0c\u60a8\u53ef\u4ee5\u5728\u6d4f\u89c8\u5668\u4e2d\u4e0e\u4e4b\u4ea4\u4e92\u3002\uff08\u6ce8\u610f\uff1a\u5bf9\u4e8e Google Colab\uff0c\u8fd9\u662f\u901a\u8fc7[\u670d\u52a1\u5de5\u4f5c\u5668\u96a7\u9053](https://github.com/tensorflow/tensorboard/blob/master/docs/design/colab_integration.md)\u5b9e\u73b0\u7684\uff0c\u60a8\u7684\u6d4f\u89c8\u5668\u9700\u8981\u542f\u7528 cookies\u3002\uff09\u5bf9\u4e8e\u5176\u4ed6\u8fdc\u7a0b\u7b14\u8bb0\u672c\uff0cGradio \u4e5f\u5c06\u5728\u670d\u52a1\u5668\u4e0a\u8fd0\u884c\uff0c\u4f46\u60a8\u9700\u8981\u4f7f\u7528[SSH \u96a7\u9053](https://coderwall.com/p/ohk6cg/remote-access-to-ipython-notebooks-via-ssh)\u5728\u672c\u5730\u6d4f\u89c8\u5668\u4e2d\u67e5\u770b\u5e94\u7528\u7a0b\u5e8f\u3002\u901a\u5e38\uff0c\u66f4\u7b80\u5355\u7684\u9009\u62e9\u662f\u4f7f\u7528 Gradio \u5185\u7f6e\u7684\u516c\u5171\u94fe\u63a5\uff0c[\u5728\u4e0b\u4e00\u7bc7\u6307\u5357\u4e2d\u8ba8\u8bba](/sharing-your-app/#sharing-demos)\u3002\n2,\tGit over SSH\n\nYou can access and write data in repositories on huggingface.co using SSH (Secure Shell Protocol). When you connect via SSH, you authenticate using a private key file on your local machine.\n\nSome actions, such as pushing changes, or cloning private repositories, will require you to upload your SSH public key to your account on huggingface.co.\n\nYou can use a pre-existing SSH key, or generate a new one specifically for huggingface.co.\n\n## Checking for existing SSH keys\n\nIf you have an existing SSH key, you can use that key to authenticate Git operations over SSH.\n\nSSH keys are usually located under `~/.ssh` on Mac & Linux, and under `C:\\\\Users\\\\<username>\\\\.ssh` on Windows. List files under that directory and look for files of the form:\n\n- id_rsa.pub\n- id_ecdsa.pub\n- id_ed25519.pub\n\nThose files contain your SSH public key.\n\nIf you don't have such file under `~/.ssh`, you will have to [generate a new key](#generating-a-new-ssh-keypair). Otherwise, you can [add your existing SSH public key(s) to your huggingface.co account](#add-a-ssh-key-to-your-account).\n\n## Generating a new SSH keypair\n\nIf you don't have any SSH keys on your machine, you can use `ssh-keygen` to generate a new SSH key pair (public + private keys):\n\n```\n$ ssh-keygen -t ed25519 -C \"your.email@example.co\"\n```\n\nWe recommend entering a passphrase when you are prompted to. A passphrase is an extra layer of security: it is a password that will be prompted whenever you use your SSH key.\n\nOnce your new key is generated, add it to your SSH agent with `ssh-add`:\n\n```\n$ ssh-add ~/.ssh/id_ed25519\n```\n\nIf you chose a different location than the default to store your SSH key, you would have to replace `~/.ssh/id_ed25519` with the file location you used.\n\n## Add a SSH key to your account\n\nTo access private repositories with SSH, or to push changes via SSH, you will need to add your SSH public key to your huggingface.co account. You can manage your SSH keys [in your user settings](https://huggingface.co/settings/keys).\n\nTo add a SSH key to your account, click on the \"Add SSH key\" button.\n\nThen, enter a name for this key (for example, \"Personal computer\"), and copy and paste the content of your **public** SSH key in the area below. The public key is located in the `~/.ssh/id_XXXX.pub` file you found or generated in the previous steps.\n\nClick on \"Add key\", and voil\u00e0! You have added a SSH key to your huggingface.co account.\n\n\n## Testing your SSH authentication\n\nOnce you have added your SSH key to your huggingface.co account, you can test that the connection works as expected.\n\nIn a terminal, run:\n```\n$ ssh -T git@hf.co\n```\n\nIf you see a message with your username, congrats! Everything went well, you are ready to use git over SSH.\n\nOtherwise, if the message states something like the following, make sure your SSH key is actually used by your SSH agent.\n```\nHi anonymous, welcome to Hugging Face.\n```\n    ```",
            "vector_context": "[Created at: 2025-03-24 13:18:47]\nGit over SSH\n\nYou can access and write data in repositories on huggingface.co using SSH (Secure Shell Protocol). When you connect via SSH, you authenticate using a private key file on your local machine.\n\nSome actions, such as pushing changes, or cloning private repositories, will require you to upload your SSH public key to your account on huggingface.co.\n\nYou can use a pre-existing SSH key, or generate a new one specifically for huggingface.co.\n\n## Checking for existing SSH keys\n\nIf you have an existing SSH key, you can use that key to authenticate Git operations over SSH.\n\nSSH keys are usually located under `~/.ssh` on Mac & Linux, and under `C:\\\\Users\\\\<username>\\\\.ssh` on Windows. List files under that directory and look for files of the form:\n\n- id_rsa.pub\n- id_ecdsa.pub\n- id_ed25519.pub\n\nThose files contain your SSH public key.\n\nIf you don't have such file under `~/.ssh`, you will have to [generate a new key](#generating-a-new-ssh-keypair). Otherwise, you can [add your existing SSH public key(s) to your huggingface.co account](#add-a-ssh-key-to-your-account).\n\n## Generating a new SSH keypair\n\nIf you don't have any SSH keys on your machine, you can use `ssh-keygen` to generate a new SSH key pair (public + private keys):\n\n```\n$ ssh-keygen -t ed25519 -C \"your.email@example.co\"\n```\n\nWe recommend entering a passphrase when you are prompted to. A passphrase is an extra layer of security: it is a password that will be prompted whenever you use your SSH key.\n\nOnce your new key is generated, add it to your SSH agent with `ssh-add`:\n\n```\n$ ssh-add ~/.ssh/id_ed25519\n```\n\nIf you chose a different location than the default to store your SSH key, you would have to replace `~/.ssh/id_ed25519` with the file location you used.\n\n## Add a SSH key to your account\n\nTo access private repositories with SSH, or to push changes via SSH, you will need to add your SSH public key to your huggingface.co account. You can manage your SSH keys [in your user settings](https://huggingface.co/settings/keys).\n\nTo add a SSH key to your account, click on the \"Add SSH key\" button.\n\nThen, enter a name for this key (for example, \"Personal computer\"), and copy and paste the content of your **public** SSH key in the area below. The public key is located in the `~/.ssh/id_XXXX.pub` file you found or generated in the previous steps.\n\nClick on \"Add key\", and voil\u00e0! You have added a SSH key to your huggingface.co account.\n\n\n## Testing your SSH authentication\n\nOnce you have added your SSH key to your huggingface.co account, you can test that the connection works as expected.\n\nIn a terminal, run:\n```\n$ ssh -T git@hf.co\n```\n\nIf you see a message with your username, congrats! Everything went well, you are ready to use git over SSH.\n\nOtherwise, if the message states something like the following, make sure your SSH key is actually used by your SSH agent.\n```\nHi anonymous, welcome to Hugging Face.\n```\n--New Chunk--\n[Created at: 2025-03-24 13:15:42]\nCreate an Endpoint\n\nAfter your first login, you will be directed to the [Endpoint creation page](https://ui.endpoints.huggingface.co/new). As an example, this guide will go through the steps to deploy [distilbert-base-uncased-finetuned-sst-2-english](https://huggingface.co/distilbert-base-uncased-finetuned-sst-2-english) for text classification. \n\n## 1. Enter the Hugging Face Repository ID and your desired endpoint name:\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_repository.png\" alt=\"select repository\" />\n\n## 2. Select your Cloud Provider and region. Initially, only AWS will be available as a Cloud Provider with the `us-east-1` and `eu-west-1` regions. We will add Azure soon, and if you need to test Endpoints with other Cloud Providers or regions, please let us know.\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_region.png\" alt=\"select region\" />\n\n## 3. Define the [Security Level](security) for the Endpoint:\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_security.png\" alt=\"define security\" />\n\n## 4. Create your Endpoint by clicking **Create Endpoint**. By default, your Endpoint is created with a medium CPU (2 x 4GB vCPUs with Intel Xeon Ice Lake) The cost estimate assumes the Endpoint will be up for an entire month, and does not take autoscaling into account.\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_create_cost.png\" alt=\"create endpoint\" />\n\n## 5. Wait for the Endpoint to build, initialize and run which can take between 1 to 5 minutes.\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/overview.png\" alt=\"overview\" />\n\n## 6. Test your Endpoint in the overview with the Inference widget \ud83c\udfc1 \ud83c\udf89!\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_inference.png\" alt=\"run inference\" />\n--New Chunk--\n[Created at: 2025-03-24 13:19:17]\n!---\nCopyright 2022 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n-->\n\n# Token classification with LayoutLMv3 (PyTorch version)\n\nThis directory contains a script, `run_funsd_cord.py`, that can be used to fine-tune (or evaluate) LayoutLMv3 on form understanding datasets, such as [FUNSD](https://guillaumejaume.github.io/FUNSD/) and [CORD](https://github.com/clovaai/cord).\n\nThe script `run_funsd_cord.py` leverages the \ud83e\udd17 Datasets library and the Trainer API. You can easily customize it to your needs.\n\n## Fine-tuning on FUNSD\n\nFine-tuning LayoutLMv3 for token classification on [FUNSD](https://guillaumejaume.github.io/FUNSD/) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name funsd \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 1e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-funsd\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd. By specifying the `push_to_hub` flag, the model gets uploaded automatically to the hub (regularly), together with a model card, which includes metrics such as precision, recall and F1. Note that you can easily update the model card, as it's just a README file of the respective repo on the hub.\n\nThere's also the \"Training metrics\" [tab](https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd/tensorboard), which shows Tensorboard logs over the course of training. Pretty neat, huh?\n\n## Fine-tuning on CORD\n\nFine-tuning LayoutLMv3 for token classification on [CORD](https://github.com/clovaai/cord) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name cord \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 5e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-cord\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-cord. Note that a model card gets generated automatically in case you specify the `push_to_hub` flag."
        }
    },
    {
        "sample_idx": 92,
        "question": "What is the command to generate a new SSH key pair?",
        "answer": "The command to generate a new SSH key pair is ssh-keygen -t ed25519 -C \"your.email@example.co\".",
        "rag_answer": "The command to generate a new SSH key pair is:\n\n`$ ssh-keygen -t ed25519 -C \"your.email@example.co\"`\n\nThis command uses `ssh-keygen` to generate a new SSH key pair, specifically an Ed25519 key, and includes a comment with your email address.",
        "rag_score": null,
        "rag_feedback": null,
        "rag_context": {
            "kg_context": "-----Entities-----\n    ```csv\n    id,\tentity,\ttype,\tdescription,\trankcreated_at\n1,\tLinux,geo,Linux is a type of operating system.,1,2025-03-24 13:19:17\n2,\tSSH,category,Gradio can be run on remote servers using SSH.<SEP>SSH is a secure protocol used for authentication and data transfer.,6,2025-03-24 13:19:17\n3,\tMac,geo,Mac is a type of operating system.,1,2025-03-24 13:19:17\n4,\tprivate key,category,Private key is a secure key used for SSH authentication.,1,2025-03-24 13:19:17\n5,\tpublic key,category,Public key is a secure key used for SSH authentication.,1,2025-03-24 13:19:17\n6,\tprivate key,category,Private key is a secure key used for SSH authentication.,1,UNKNOWN\n7,\tssh-keygen,category,ssh-keygen is a command used to generate a new SSH key pair.,0,UNKNOWN\n8,\tpublic key,category,Public key is a secure key used for SSH authentication.,1,UNKNOWN\n    ```\n    -----Relationships-----\n    ```csv\n    id,\tsource,\ttarget,\tdescription,\tkeywords,\tweight,\trank,\tcreated_at\n1,\tLinux,SSH,Linux is a platform that uses SSH for authentication.,platform, authentication,12.0,7,2025-03-24 13:19:17\n2,\tMac,SSH,Mac is a platform that uses SSH for authentication.,platform, authentication,12.0,7,2025-03-24 13:19:17\n3,\tprivate key,public key,Private key is used to generate a public key for SSH authentication.,key generation, authentication,8.0,2,2025-03-24 13:19:17\n4,\tprivate key,public key,Private key is used to generate a public key for SSH authentication.,key generation, authentication,8.0,2,UNKNOWN\n    ```\n    -----Sources-----\n    ```csv\n    id,\tcontent\n1,\tGit over SSH\n\nYou can access and write data in repositories on huggingface.co using SSH (Secure Shell Protocol). When you connect via SSH, you authenticate using a private key file on your local machine.\n\nSome actions, such as pushing changes, or cloning private repositories, will require you to upload your SSH public key to your account on huggingface.co.\n\nYou can use a pre-existing SSH key, or generate a new one specifically for huggingface.co.\n\n## Checking for existing SSH keys\n\nIf you have an existing SSH key, you can use that key to authenticate Git operations over SSH.\n\nSSH keys are usually located under `~/.ssh` on Mac & Linux, and under `C:\\\\Users\\\\<username>\\\\.ssh` on Windows. List files under that directory and look for files of the form:\n\n- id_rsa.pub\n- id_ecdsa.pub\n- id_ed25519.pub\n\nThose files contain your SSH public key.\n\nIf you don't have such file under `~/.ssh`, you will have to [generate a new key](#generating-a-new-ssh-keypair). Otherwise, you can [add your existing SSH public key(s) to your huggingface.co account](#add-a-ssh-key-to-your-account).\n\n## Generating a new SSH keypair\n\nIf you don't have any SSH keys on your machine, you can use `ssh-keygen` to generate a new SSH key pair (public + private keys):\n\n```\n$ ssh-keygen -t ed25519 -C \"your.email@example.co\"\n```\n\nWe recommend entering a passphrase when you are prompted to. A passphrase is an extra layer of security: it is a password that will be prompted whenever you use your SSH key.\n\nOnce your new key is generated, add it to your SSH agent with `ssh-add`:\n\n```\n$ ssh-add ~/.ssh/id_ed25519\n```\n\nIf you chose a different location than the default to store your SSH key, you would have to replace `~/.ssh/id_ed25519` with the file location you used.\n\n## Add a SSH key to your account\n\nTo access private repositories with SSH, or to push changes via SSH, you will need to add your SSH public key to your huggingface.co account. You can manage your SSH keys [in your user settings](https://huggingface.co/settings/keys).\n\nTo add a SSH key to your account, click on the \"Add SSH key\" button.\n\nThen, enter a name for this key (for example, \"Personal computer\"), and copy and paste the content of your **public** SSH key in the area below. The public key is located in the `~/.ssh/id_XXXX.pub` file you found or generated in the previous steps.\n\nClick on \"Add key\", and voil\u00e0! You have added a SSH key to your huggingface.co account.\n\n\n## Testing your SSH authentication\n\nOnce you have added your SSH key to your huggingface.co account, you can test that the connection works as expected.\n\nIn a terminal, run:\n```\n$ ssh -T git@hf.co\n```\n\nIf you see a message with your username, congrats! Everything went well, you are ready to use git over SSH.\n\nOtherwise, if the message states something like the following, make sure your SSH key is actually used by your SSH agent.\n```\nHi anonymous, welcome to Hugging Face.\n```\n    ```",
            "vector_context": "[Created at: 2025-03-24 13:18:47]\nGit over SSH\n\nYou can access and write data in repositories on huggingface.co using SSH (Secure Shell Protocol). When you connect via SSH, you authenticate using a private key file on your local machine.\n\nSome actions, such as pushing changes, or cloning private repositories, will require you to upload your SSH public key to your account on huggingface.co.\n\nYou can use a pre-existing SSH key, or generate a new one specifically for huggingface.co.\n\n## Checking for existing SSH keys\n\nIf you have an existing SSH key, you can use that key to authenticate Git operations over SSH.\n\nSSH keys are usually located under `~/.ssh` on Mac & Linux, and under `C:\\\\Users\\\\<username>\\\\.ssh` on Windows. List files under that directory and look for files of the form:\n\n- id_rsa.pub\n- id_ecdsa.pub\n- id_ed25519.pub\n\nThose files contain your SSH public key.\n\nIf you don't have such file under `~/.ssh`, you will have to [generate a new key](#generating-a-new-ssh-keypair). Otherwise, you can [add your existing SSH public key(s) to your huggingface.co account](#add-a-ssh-key-to-your-account).\n\n## Generating a new SSH keypair\n\nIf you don't have any SSH keys on your machine, you can use `ssh-keygen` to generate a new SSH key pair (public + private keys):\n\n```\n$ ssh-keygen -t ed25519 -C \"your.email@example.co\"\n```\n\nWe recommend entering a passphrase when you are prompted to. A passphrase is an extra layer of security: it is a password that will be prompted whenever you use your SSH key.\n\nOnce your new key is generated, add it to your SSH agent with `ssh-add`:\n\n```\n$ ssh-add ~/.ssh/id_ed25519\n```\n\nIf you chose a different location than the default to store your SSH key, you would have to replace `~/.ssh/id_ed25519` with the file location you used.\n\n## Add a SSH key to your account\n\nTo access private repositories with SSH, or to push changes via SSH, you will need to add your SSH public key to your huggingface.co account. You can manage your SSH keys [in your user settings](https://huggingface.co/settings/keys).\n\nTo add a SSH key to your account, click on the \"Add SSH key\" button.\n\nThen, enter a name for this key (for example, \"Personal computer\"), and copy and paste the content of your **public** SSH key in the area below. The public key is located in the `~/.ssh/id_XXXX.pub` file you found or generated in the previous steps.\n\nClick on \"Add key\", and voil\u00e0! You have added a SSH key to your huggingface.co account.\n\n\n## Testing your SSH authentication\n\nOnce you have added your SSH key to your huggingface.co account, you can test that the connection works as expected.\n\nIn a terminal, run:\n```\n$ ssh -T git@hf.co\n```\n\nIf you see a message with your username, congrats! Everything went well, you are ready to use git over SSH.\n\nOtherwise, if the message states something like the following, make sure your SSH key is actually used by your SSH agent.\n```\nHi anonymous, welcome to Hugging Face.\n```\n--New Chunk--\n[Created at: 2025-03-24 13:15:42]\nCreate an Endpoint\n\nAfter your first login, you will be directed to the [Endpoint creation page](https://ui.endpoints.huggingface.co/new). As an example, this guide will go through the steps to deploy [distilbert-base-uncased-finetuned-sst-2-english](https://huggingface.co/distilbert-base-uncased-finetuned-sst-2-english) for text classification. \n\n## 1. Enter the Hugging Face Repository ID and your desired endpoint name:\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_repository.png\" alt=\"select repository\" />\n\n## 2. Select your Cloud Provider and region. Initially, only AWS will be available as a Cloud Provider with the `us-east-1` and `eu-west-1` regions. We will add Azure soon, and if you need to test Endpoints with other Cloud Providers or regions, please let us know.\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_region.png\" alt=\"select region\" />\n\n## 3. Define the [Security Level](security) for the Endpoint:\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_security.png\" alt=\"define security\" />\n\n## 4. Create your Endpoint by clicking **Create Endpoint**. By default, your Endpoint is created with a medium CPU (2 x 4GB vCPUs with Intel Xeon Ice Lake) The cost estimate assumes the Endpoint will be up for an entire month, and does not take autoscaling into account.\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_create_cost.png\" alt=\"create endpoint\" />\n\n## 5. Wait for the Endpoint to build, initialize and run which can take between 1 to 5 minutes.\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/overview.png\" alt=\"overview\" />\n\n## 6. Test your Endpoint in the overview with the Inference widget \ud83c\udfc1 \ud83c\udf89!\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_inference.png\" alt=\"run inference\" />\n--New Chunk--\n[Created at: 2025-03-24 13:16:48]\n\u4e0e\u5e38\u89c4\u51fd\u6570\u76f8\u540c\u7684\u65b9\u5f0f\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio\u3002\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\uff08\u865a\u62df\u7684\uff09\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5b83\u5728\u8f93\u51fa\u56fe\u50cf\u4e4b\u524d\u751f\u6210\u6570\u4e2a\u6b65\u9aa4\u7684\u566a\u97f3\uff1a\n\n$code_fake_diffusion\n$demo_fake_diffusion\n\n\u8bf7\u6ce8\u610f\uff0c\u6211\u4eec\u5728\u8fed\u4ee3\u5668\u4e2d\u6dfb\u52a0\u4e86 `time.sleep(1)`\uff0c\u4ee5\u521b\u5efa\u6b65\u9aa4\u4e4b\u95f4\u7684\u4eba\u5de5\u6682\u505c\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u89c2\u5bdf\u8fed\u4ee3\u5668\u7684\u6b65\u9aa4\uff08\u5728\u771f\u5b9e\u7684\u56fe\u50cf\u751f\u6210\u6a21\u578b\u4e2d\uff0c\u8fd9\u53ef\u80fd\u662f\u4e0d\u5fc5\u8981\u7684\uff09\u3002\n\n\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio **\u9700\u8981**\u5728\u5e95\u5c42 Interface \u6216 Blocks \u4e2d\u542f\u7528\u961f\u5217\uff08\u8bf7\u53c2\u9605\u4e0a\u9762\u7684\u961f\u5217\u90e8\u5206\uff09\u3002\n\n## \u8fdb\u5ea6\u6761\n\nGradio \u652f\u6301\u521b\u5efa\u81ea\u5b9a\u4e49\u8fdb\u5ea6\u6761\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u81ea\u5b9a\u4e49\u548c\u63a7\u5236\u5411\u7528\u6237\u663e\u793a\u7684\u8fdb\u5ea6\u66f4\u65b0\u3002\u8981\u542f\u7528\u6b64\u529f\u80fd\uff0c\u53ea\u9700\u4e3a\u65b9\u6cd5\u6dfb\u52a0\u4e00\u4e2a\u9ed8\u8ba4\u503c\u4e3a `gr.Progress` \u5b9e\u4f8b\u7684\u53c2\u6570\u5373\u53ef\u3002\u7136\u540e\uff0c\u60a8\u53ef\u4ee5\u76f4\u63a5\u8c03\u7528\u6b64\u5b9e\u4f8b\u5e76\u4f20\u5165 0 \u5230 1 \u4e4b\u95f4\u7684\u6d6e\u70b9\u6570\u6765\u66f4\u65b0\u8fdb\u5ea6\u7ea7\u522b\uff0c\u6216\u8005 with `Progress` \u5b9e\u4f8b\u7684 `tqdm()` \u65b9\u6cd5\u6765\u8ddf\u8e2a\u53ef\u8fed\u4ee3\u5bf9\u8c61\u4e0a\u7684\u8fdb\u5ea6\uff0c\u5982\u4e0b\u6240\u793a\u3002\u5fc5\u987b\u542f\u7528\u961f\u5217\u4ee5\u8fdb\u884c\u8fdb\u5ea6\u66f4\u65b0\u3002\n\n$code_progress_simple\n$demo_progress_simple\n\n\u5982\u679c\u60a8 with `tqdm` \u5e93\uff0c\u5e76\u4e14\u5e0c\u671b\u4ece\u51fd\u6570\u5185\u90e8\u7684\u4efb\u4f55 `tqdm.tqdm` \u81ea\u52a8\u62a5\u544a\u8fdb\u5ea6\u66f4\u65b0\uff0c\u8bf7\u5c06\u9ed8\u8ba4\u53c2\u6570\u8bbe\u7f6e\u4e3a `gr.Progress(track_tqdm=True)`\uff01\n\n## \u6279\u5904\u7406\u51fd\u6570 (Batch Functions)\n\nGradio \u652f\u6301\u4f20\u9012*\u6279\u5904\u7406*\u51fd\u6570\u3002\u6279\u5904\u7406\u51fd\u6570\u53ea\u662f\u63a5\u53d7\u8f93\u5165\u5217\u8868\u5e76\u8fd4\u56de\u9884\u6d4b\u5217\u8868\u7684\u51fd\u6570\u3002\n\n\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\u6279\u5904\u7406\u51fd\u6570\uff0c\u5b83\u63a5\u53d7\u4e24\u4e2a\u8f93\u5165\u5217\u8868\uff08\u4e00\u4e2a\u5355\u8bcd\u5217\u8868\u548c\u4e00\u4e2a\u6574\u6570\u5217\u8868\uff09\uff0c\u5e76\u8fd4\u56de\u4fee\u526a\u8fc7\u7684\u5355\u8bcd\u5217\u8868\u4f5c\u4e3a\u8f93\u51fa\uff1a\n\n```python\nimport time\n\ndef trim_words(words, lens):\n    trimmed_words = []\n    time.sleep(5)\n    for w, l in zip(words, lens):\n        trimmed_words.append(w[:int(l)])\n    return [trimmed_words]\n    for w, l in zip(words, lens):\n```\n\n\u4f7f\u7528\u6279\u5904\u7406\u51fd\u6570\u7684\u4f18\u70b9\u662f\uff0c\u5982\u679c\u542f\u7528\u4e86\u961f\u5217\uff0cGradio \u670d\u52a1\u5668\u53ef\u4ee5\u81ea\u52a8*\u6279\u5904\u7406*\u4f20\u5165\u7684\u8bf7\u6c42\u5e76\u5e76\u884c\u5904\u7406\u5b83\u4eec\uff0c\u4ece\u800c\u53ef\u80fd\u52a0\u5feb\u6f14\u793a\u901f\u5ea6\u3002\u4ee5\u4e0b\u662f Gradio \u4ee3\u7801\u7684\u793a\u4f8b\uff08\u8bf7\u6ce8\u610f `batch=True` \u548c `max_batch_size=16` - \u8fd9\u4e24\u4e2a\u53c2\u6570\u90fd\u53ef\u4ee5\u4f20\u9012\u7ed9\u4e8b\u4ef6\u89e6\u53d1\u5668\u6216 `Interface` \u7c7b\uff09\n\nwith `Interface`\uff1a\n\n```python\ndemo = gr.Interface(trim_words, [\"textbox\", \"number\"], [\"output\"],\n                    batch=True, max_batch_size=16)\ndemo.queue()\ndemo.launch()\n```\n\nwith `Blocks`\uff1a\n\n```python\nimport gradio as gr\n\nwith gr.Blocks() as demo:\n    with gr.Row():\n        word = gr.Textbox(label=\"word\")\n        leng = gr.Number(label=\"leng\")\n        output = gr.Textbox(label=\"Output\")\n    with gr.Row():\n        run = gr.Button()\n\n    event = run.click(trim_words, [word, leng], output, batch=True, max_batch_size=16)\n\ndemo.queue()\ndemo.launch()\n```\n\n\u5728\u4e0a\u9762\u7684\u793a\u4f8b\u4e2d\uff0c\u53ef\u4ee5\u5e76\u884c\u5904\u7406 16 \u4e2a\u8bf7\u6c42\uff08\u603b\u63a8\u7406\u65f6\u95f4\u4e3a 5 \u79d2\uff09\uff0c\u800c\u4e0d\u662f\u5206\u522b\u5904\u7406\u6bcf\u4e2a\u8bf7\u6c42\uff08\u603b\u63a8\u7406\u65f6\u95f4\u4e3a 80 \u79d2\uff09\u3002\u8bb8\u591a Hugging Face \u7684 `transformers` \u548c `diffusers` \u6a21\u578b\u5728 Gradio \u7684\u6279\u5904\u7406\u6a21\u5f0f\u4e0b\u81ea\u7136\u5de5\u4f5c\uff1a\u8fd9\u662f[\u4f7f\u7528\u6279\u5904\u7406\u751f\u6210\u56fe\u50cf\u7684\u793a\u4f8b\u6f14\u793a](https://github.com/gradio-app/gradio/blob/main/demo/diffusers_with_batching/run.py)\n\n\u6ce8\u610f\uff1a\u4f7f\u7528 Gradio \u7684\u6279\u5904\u7406\u51fd\u6570 **requires** \u5728\u5e95\u5c42 Interface \u6216 Blocks \u4e2d\u542f\u7528\u961f\u5217\uff08\u8bf7\u53c2\u9605\u4e0a\u9762\u7684\u961f\u5217\u90e8\u5206\uff09\u3002\n\n## Gradio \u7b14\u8bb0\u672c (Colab Notebooks)\n\nGradio \u53ef\u4ee5\u5728\u4efb\u4f55\u8fd0\u884c Python \u7684\u5730\u65b9\u8fd0\u884c\uff0c\u5305\u62ec\u672c\u5730 Jupyter \u7b14\u8bb0\u672c\u548c\u534f\u4f5c\u7b14\u8bb0\u672c\uff0c\u5982[Google Colab](https://colab.research.google.com/)\u3002\u5bf9\u4e8e\u672c\u5730 Jupyter \u7b14\u8bb0\u672c\u548c Google Colab \u7b14\u8bb0\u672c\uff0cGradio \u5728\u672c\u5730\u670d\u52a1\u5668\u4e0a\u8fd0\u884c\uff0c\u60a8\u53ef\u4ee5\u5728\u6d4f\u89c8\u5668\u4e2d\u4e0e\u4e4b\u4ea4\u4e92\u3002\uff08\u6ce8\u610f\uff1a\u5bf9\u4e8e Google Colab\uff0c\u8fd9\u662f\u901a\u8fc7[\u670d\u52a1\u5de5\u4f5c\u5668\u96a7\u9053](https://github.com/tensorflow/tensorboard/blob/master/docs/design/colab_integration.md)\u5b9e\u73b0\u7684\uff0c\u60a8\u7684\u6d4f\u89c8\u5668\u9700\u8981\u542f\u7528 cookies\u3002\uff09\u5bf9\u4e8e\u5176\u4ed6\u8fdc\u7a0b\u7b14\u8bb0\u672c\uff0cGradio \u4e5f\u5c06\u5728\u670d\u52a1\u5668\u4e0a\u8fd0\u884c\uff0c\u4f46\u60a8\u9700\u8981\u4f7f\u7528[SSH \u96a7\u9053](https://coderwall.com/p/ohk6cg/remote-access-to-ipython-notebooks-via-ssh)\u5728\u672c\u5730\u6d4f\u89c8\u5668\u4e2d\u67e5\u770b\u5e94\u7528\u7a0b\u5e8f\u3002\u901a\u5e38\uff0c\u66f4\u7b80\u5355\u7684\u9009\u62e9\u662f\u4f7f\u7528 Gradio \u5185\u7f6e\u7684\u516c\u5171\u94fe\u63a5\uff0c[\u5728\u4e0b\u4e00\u7bc7\u6307\u5357\u4e2d\u8ba8\u8bba](/sharing-your-app/#sharing-demos)\u3002"
        }
    },
    {
        "sample_idx": 93,
        "question": "What is the purpose of a passphrase when generating an SSH key?",
        "answer": "A passphrase is an extra layer of security: it is a password that will be prompted whenever you use your SSH key.",
        "rag_answer": "The purpose of a passphrase when generating an SSH key is to add an extra layer of security. When you generate an SSH key pair, you have the option to enter a passphrase, which is a password that will be required to use the private key. This means that even if someone gains access to your private key, they will not be able to use it without the passphrase.\n\nIn other words, the passphrase protects your private key from unauthorized use, even if it is compromised. This is especially important when using SSH keys for authentication, as they grant access to your account and data.\n\n[KG] Private key is a secure key used for SSH authentication.\n[DC] We recommend entering a passphrase when you are prompted to. A passphrase is an extra layer of security: it is a password that will be prompted whenever you use your SSH key.",
        "rag_score": 5,
        "rag_feedback": "The system's response is completely correct, accurate, and factual. It provides a detailed explanation of the purpose of a passphrase when generating an SSH key, including the benefits of adding an extra layer of security and protecting the private key from unauthorized use.",
        "rag_context": {
            "kg_context": "-----Entities-----\n    ```csv\n    id,\tentity,\ttype,\tdescription,\trankcreated_at\n1,\tLinux,geo,Linux is a type of operating system.,1,2025-03-24 13:19:17\n2,\tSSH,category,Gradio can be run on remote servers using SSH.<SEP>SSH is a secure protocol used for authentication and data transfer.,6,2025-03-24 13:19:17\n3,\tMac,geo,Mac is a type of operating system.,1,2025-03-24 13:19:17\n4,\tprivate key,category,Private key is a secure key used for SSH authentication.,1,2025-03-24 13:19:17\n5,\tpublic key,category,Public key is a secure key used for SSH authentication.,1,2025-03-24 13:19:17\n6,\tpublic key,category,Public key is a secure key used for SSH authentication.,1,UNKNOWN\n7,\tprivate key,category,Private key is a secure key used for SSH authentication.,1,UNKNOWN\n8,\t SSH,category,SSH is a protocol for secure remote access to computers.,0,UNKNOWN\n    ```\n    -----Relationships-----\n    ```csv\n    id,\tsource,\ttarget,\tdescription,\tkeywords,\tweight,\trank,\tcreated_at\n1,\tLinux,SSH,Linux is a platform that uses SSH for authentication.,platform, authentication,12.0,7,2025-03-24 13:19:17\n2,\tMac,SSH,Mac is a platform that uses SSH for authentication.,platform, authentication,12.0,7,2025-03-24 13:19:17\n3,\tprivate key,public key,Private key is used to generate a public key for SSH authentication.,key generation, authentication,8.0,2,2025-03-24 13:19:17\n4,\tprivate key,public key,Private key is used to generate a public key for SSH authentication.,key generation, authentication,8.0,2,UNKNOWN\n    ```\n    -----Sources-----\n    ```csv\n    id,\tcontent\n1,\tGit over SSH\n\nYou can access and write data in repositories on huggingface.co using SSH (Secure Shell Protocol). When you connect via SSH, you authenticate using a private key file on your local machine.\n\nSome actions, such as pushing changes, or cloning private repositories, will require you to upload your SSH public key to your account on huggingface.co.\n\nYou can use a pre-existing SSH key, or generate a new one specifically for huggingface.co.\n\n## Checking for existing SSH keys\n\nIf you have an existing SSH key, you can use that key to authenticate Git operations over SSH.\n\nSSH keys are usually located under `~/.ssh` on Mac & Linux, and under `C:\\\\Users\\\\<username>\\\\.ssh` on Windows. List files under that directory and look for files of the form:\n\n- id_rsa.pub\n- id_ecdsa.pub\n- id_ed25519.pub\n\nThose files contain your SSH public key.\n\nIf you don't have such file under `~/.ssh`, you will have to [generate a new key](#generating-a-new-ssh-keypair). Otherwise, you can [add your existing SSH public key(s) to your huggingface.co account](#add-a-ssh-key-to-your-account).\n\n## Generating a new SSH keypair\n\nIf you don't have any SSH keys on your machine, you can use `ssh-keygen` to generate a new SSH key pair (public + private keys):\n\n```\n$ ssh-keygen -t ed25519 -C \"your.email@example.co\"\n```\n\nWe recommend entering a passphrase when you are prompted to. A passphrase is an extra layer of security: it is a password that will be prompted whenever you use your SSH key.\n\nOnce your new key is generated, add it to your SSH agent with `ssh-add`:\n\n```\n$ ssh-add ~/.ssh/id_ed25519\n```\n\nIf you chose a different location than the default to store your SSH key, you would have to replace `~/.ssh/id_ed25519` with the file location you used.\n\n## Add a SSH key to your account\n\nTo access private repositories with SSH, or to push changes via SSH, you will need to add your SSH public key to your huggingface.co account. You can manage your SSH keys [in your user settings](https://huggingface.co/settings/keys).\n\nTo add a SSH key to your account, click on the \"Add SSH key\" button.\n\nThen, enter a name for this key (for example, \"Personal computer\"), and copy and paste the content of your **public** SSH key in the area below. The public key is located in the `~/.ssh/id_XXXX.pub` file you found or generated in the previous steps.\n\nClick on \"Add key\", and voil\u00e0! You have added a SSH key to your huggingface.co account.\n\n\n## Testing your SSH authentication\n\nOnce you have added your SSH key to your huggingface.co account, you can test that the connection works as expected.\n\nIn a terminal, run:\n```\n$ ssh -T git@hf.co\n```\n\nIf you see a message with your username, congrats! Everything went well, you are ready to use git over SSH.\n\nOtherwise, if the message states something like the following, make sure your SSH key is actually used by your SSH agent.\n```\nHi anonymous, welcome to Hugging Face.\n```\n2,\t\u4e0e\u5e38\u89c4\u51fd\u6570\u76f8\u540c\u7684\u65b9\u5f0f\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio\u3002\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\uff08\u865a\u62df\u7684\uff09\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5b83\u5728\u8f93\u51fa\u56fe\u50cf\u4e4b\u524d\u751f\u6210\u6570\u4e2a\u6b65\u9aa4\u7684\u566a\u97f3\uff1a\n\n$code_fake_diffusion\n$demo_fake_diffusion\n\n\u8bf7\u6ce8\u610f\uff0c\u6211\u4eec\u5728\u8fed\u4ee3\u5668\u4e2d\u6dfb\u52a0\u4e86 `time.sleep(1)`\uff0c\u4ee5\u521b\u5efa\u6b65\u9aa4\u4e4b\u95f4\u7684\u4eba\u5de5\u6682\u505c\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u89c2\u5bdf\u8fed\u4ee3\u5668\u7684\u6b65\u9aa4\uff08\u5728\u771f\u5b9e\u7684\u56fe\u50cf\u751f\u6210\u6a21\u578b\u4e2d\uff0c\u8fd9\u53ef\u80fd\u662f\u4e0d\u5fc5\u8981\u7684\uff09\u3002\n\n\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio **\u9700\u8981**\u5728\u5e95\u5c42 Interface \u6216 Blocks \u4e2d\u542f\u7528\u961f\u5217\uff08\u8bf7\u53c2\u9605\u4e0a\u9762\u7684\u961f\u5217\u90e8\u5206\uff09\u3002\n\n## \u8fdb\u5ea6\u6761\n\nGradio \u652f\u6301\u521b\u5efa\u81ea\u5b9a\u4e49\u8fdb\u5ea6\u6761\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u81ea\u5b9a\u4e49\u548c\u63a7\u5236\u5411\u7528\u6237\u663e\u793a\u7684\u8fdb\u5ea6\u66f4\u65b0\u3002\u8981\u542f\u7528\u6b64\u529f\u80fd\uff0c\u53ea\u9700\u4e3a\u65b9\u6cd5\u6dfb\u52a0\u4e00\u4e2a\u9ed8\u8ba4\u503c\u4e3a `gr.Progress` \u5b9e\u4f8b\u7684\u53c2\u6570\u5373\u53ef\u3002\u7136\u540e\uff0c\u60a8\u53ef\u4ee5\u76f4\u63a5\u8c03\u7528\u6b64\u5b9e\u4f8b\u5e76\u4f20\u5165 0 \u5230 1 \u4e4b\u95f4\u7684\u6d6e\u70b9\u6570\u6765\u66f4\u65b0\u8fdb\u5ea6\u7ea7\u522b\uff0c\u6216\u8005 with `Progress` \u5b9e\u4f8b\u7684 `tqdm()` \u65b9\u6cd5\u6765\u8ddf\u8e2a\u53ef\u8fed\u4ee3\u5bf9\u8c61\u4e0a\u7684\u8fdb\u5ea6\uff0c\u5982\u4e0b\u6240\u793a\u3002\u5fc5\u987b\u542f\u7528\u961f\u5217\u4ee5\u8fdb\u884c\u8fdb\u5ea6\u66f4\u65b0\u3002\n\n$code_progress_simple\n$demo_progress_simple\n\n\u5982\u679c\u60a8 with `tqdm` \u5e93\uff0c\u5e76\u4e14\u5e0c\u671b\u4ece\u51fd\u6570\u5185\u90e8\u7684\u4efb\u4f55 `tqdm.tqdm` \u81ea\u52a8\u62a5\u544a\u8fdb\u5ea6\u66f4\u65b0\uff0c\u8bf7\u5c06\u9ed8\u8ba4\u53c2\u6570\u8bbe\u7f6e\u4e3a `gr.Progress(track_tqdm=True)`\uff01\n\n## \u6279\u5904\u7406\u51fd\u6570 (Batch Functions)\n\nGradio \u652f\u6301\u4f20\u9012*\u6279\u5904\u7406*\u51fd\u6570\u3002\u6279\u5904\u7406\u51fd\u6570\u53ea\u662f\u63a5\u53d7\u8f93\u5165\u5217\u8868\u5e76\u8fd4\u56de\u9884\u6d4b\u5217\u8868\u7684\u51fd\u6570\u3002\n\n\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\u6279\u5904\u7406\u51fd\u6570\uff0c\u5b83\u63a5\u53d7\u4e24\u4e2a\u8f93\u5165\u5217\u8868\uff08\u4e00\u4e2a\u5355\u8bcd\u5217\u8868\u548c\u4e00\u4e2a\u6574\u6570\u5217\u8868\uff09\uff0c\u5e76\u8fd4\u56de\u4fee\u526a\u8fc7\u7684\u5355\u8bcd\u5217\u8868\u4f5c\u4e3a\u8f93\u51fa\uff1a\n\n```python\nimport time\n\ndef trim_words(words, lens):\n    trimmed_words = []\n    time.sleep(5)\n    for w, l in zip(words, lens):\n        trimmed_words.append(w[:int(l)])\n    return [trimmed_words]\n    for w, l in zip(words, lens):\n```\n\n\u4f7f\u7528\u6279\u5904\u7406\u51fd\u6570\u7684\u4f18\u70b9\u662f\uff0c\u5982\u679c\u542f\u7528\u4e86\u961f\u5217\uff0cGradio \u670d\u52a1\u5668\u53ef\u4ee5\u81ea\u52a8*\u6279\u5904\u7406*\u4f20\u5165\u7684\u8bf7\u6c42\u5e76\u5e76\u884c\u5904\u7406\u5b83\u4eec\uff0c\u4ece\u800c\u53ef\u80fd\u52a0\u5feb\u6f14\u793a\u901f\u5ea6\u3002\u4ee5\u4e0b\u662f Gradio \u4ee3\u7801\u7684\u793a\u4f8b\uff08\u8bf7\u6ce8\u610f `batch=True` \u548c `max_batch_size=16` - \u8fd9\u4e24\u4e2a\u53c2\u6570\u90fd\u53ef\u4ee5\u4f20\u9012\u7ed9\u4e8b\u4ef6\u89e6\u53d1\u5668\u6216 `Interface` \u7c7b\uff09\n\nwith `Interface`\uff1a\n\n```python\ndemo = gr.Interface(trim_words, [\"textbox\", \"number\"], [\"output\"],\n                    batch=True, max_batch_size=16)\ndemo.queue()\ndemo.launch()\n```\n\nwith `Blocks`\uff1a\n\n```python\nimport gradio as gr\n\nwith gr.Blocks() as demo:\n    with gr.Row():\n        word = gr.Textbox(label=\"word\")\n        leng = gr.Number(label=\"leng\")\n        output = gr.Textbox(label=\"Output\")\n    with gr.Row():\n        run = gr.Button()\n\n    event = run.click(trim_words, [word, leng], output, batch=True, max_batch_size=16)\n\ndemo.queue()\ndemo.launch()\n```\n\n\u5728\u4e0a\u9762\u7684\u793a\u4f8b\u4e2d\uff0c\u53ef\u4ee5\u5e76\u884c\u5904\u7406 16 \u4e2a\u8bf7\u6c42\uff08\u603b\u63a8\u7406\u65f6\u95f4\u4e3a 5 \u79d2\uff09\uff0c\u800c\u4e0d\u662f\u5206\u522b\u5904\u7406\u6bcf\u4e2a\u8bf7\u6c42\uff08\u603b\u63a8\u7406\u65f6\u95f4\u4e3a 80 \u79d2\uff09\u3002\u8bb8\u591a Hugging Face \u7684 `transformers` \u548c `diffusers` \u6a21\u578b\u5728 Gradio \u7684\u6279\u5904\u7406\u6a21\u5f0f\u4e0b\u81ea\u7136\u5de5\u4f5c\uff1a\u8fd9\u662f[\u4f7f\u7528\u6279\u5904\u7406\u751f\u6210\u56fe\u50cf\u7684\u793a\u4f8b\u6f14\u793a](https://github.com/gradio-app/gradio/blob/main/demo/diffusers_with_batching/run.py)\n\n\u6ce8\u610f\uff1a\u4f7f\u7528 Gradio \u7684\u6279\u5904\u7406\u51fd\u6570 **requires** \u5728\u5e95\u5c42 Interface \u6216 Blocks \u4e2d\u542f\u7528\u961f\u5217\uff08\u8bf7\u53c2\u9605\u4e0a\u9762\u7684\u961f\u5217\u90e8\u5206\uff09\u3002\n\n## Gradio \u7b14\u8bb0\u672c (Colab Notebooks)\n\nGradio \u53ef\u4ee5\u5728\u4efb\u4f55\u8fd0\u884c Python \u7684\u5730\u65b9\u8fd0\u884c\uff0c\u5305\u62ec\u672c\u5730 Jupyter \u7b14\u8bb0\u672c\u548c\u534f\u4f5c\u7b14\u8bb0\u672c\uff0c\u5982[Google Colab](https://colab.research.google.com/)\u3002\u5bf9\u4e8e\u672c\u5730 Jupyter \u7b14\u8bb0\u672c\u548c Google Colab \u7b14\u8bb0\u672c\uff0cGradio \u5728\u672c\u5730\u670d\u52a1\u5668\u4e0a\u8fd0\u884c\uff0c\u60a8\u53ef\u4ee5\u5728\u6d4f\u89c8\u5668\u4e2d\u4e0e\u4e4b\u4ea4\u4e92\u3002\uff08\u6ce8\u610f\uff1a\u5bf9\u4e8e Google Colab\uff0c\u8fd9\u662f\u901a\u8fc7[\u670d\u52a1\u5de5\u4f5c\u5668\u96a7\u9053](https://github.com/tensorflow/tensorboard/blob/master/docs/design/colab_integration.md)\u5b9e\u73b0\u7684\uff0c\u60a8\u7684\u6d4f\u89c8\u5668\u9700\u8981\u542f\u7528 cookies\u3002\uff09\u5bf9\u4e8e\u5176\u4ed6\u8fdc\u7a0b\u7b14\u8bb0\u672c\uff0cGradio \u4e5f\u5c06\u5728\u670d\u52a1\u5668\u4e0a\u8fd0\u884c\uff0c\u4f46\u60a8\u9700\u8981\u4f7f\u7528[SSH \u96a7\u9053](https://coderwall.com/p/ohk6cg/remote-access-to-ipython-notebooks-via-ssh)\u5728\u672c\u5730\u6d4f\u89c8\u5668\u4e2d\u67e5\u770b\u5e94\u7528\u7a0b\u5e8f\u3002\u901a\u5e38\uff0c\u66f4\u7b80\u5355\u7684\u9009\u62e9\u662f\u4f7f\u7528 Gradio \u5185\u7f6e\u7684\u516c\u5171\u94fe\u63a5\uff0c[\u5728\u4e0b\u4e00\u7bc7\u6307\u5357\u4e2d\u8ba8\u8bba](/sharing-your-app/#sharing-demos)\u3002\n    ```",
            "vector_context": "[Created at: 2025-03-24 13:18:47]\nGit over SSH\n\nYou can access and write data in repositories on huggingface.co using SSH (Secure Shell Protocol). When you connect via SSH, you authenticate using a private key file on your local machine.\n\nSome actions, such as pushing changes, or cloning private repositories, will require you to upload your SSH public key to your account on huggingface.co.\n\nYou can use a pre-existing SSH key, or generate a new one specifically for huggingface.co.\n\n## Checking for existing SSH keys\n\nIf you have an existing SSH key, you can use that key to authenticate Git operations over SSH.\n\nSSH keys are usually located under `~/.ssh` on Mac & Linux, and under `C:\\\\Users\\\\<username>\\\\.ssh` on Windows. List files under that directory and look for files of the form:\n\n- id_rsa.pub\n- id_ecdsa.pub\n- id_ed25519.pub\n\nThose files contain your SSH public key.\n\nIf you don't have such file under `~/.ssh`, you will have to [generate a new key](#generating-a-new-ssh-keypair). Otherwise, you can [add your existing SSH public key(s) to your huggingface.co account](#add-a-ssh-key-to-your-account).\n\n## Generating a new SSH keypair\n\nIf you don't have any SSH keys on your machine, you can use `ssh-keygen` to generate a new SSH key pair (public + private keys):\n\n```\n$ ssh-keygen -t ed25519 -C \"your.email@example.co\"\n```\n\nWe recommend entering a passphrase when you are prompted to. A passphrase is an extra layer of security: it is a password that will be prompted whenever you use your SSH key.\n\nOnce your new key is generated, add it to your SSH agent with `ssh-add`:\n\n```\n$ ssh-add ~/.ssh/id_ed25519\n```\n\nIf you chose a different location than the default to store your SSH key, you would have to replace `~/.ssh/id_ed25519` with the file location you used.\n\n## Add a SSH key to your account\n\nTo access private repositories with SSH, or to push changes via SSH, you will need to add your SSH public key to your huggingface.co account. You can manage your SSH keys [in your user settings](https://huggingface.co/settings/keys).\n\nTo add a SSH key to your account, click on the \"Add SSH key\" button.\n\nThen, enter a name for this key (for example, \"Personal computer\"), and copy and paste the content of your **public** SSH key in the area below. The public key is located in the `~/.ssh/id_XXXX.pub` file you found or generated in the previous steps.\n\nClick on \"Add key\", and voil\u00e0! You have added a SSH key to your huggingface.co account.\n\n\n## Testing your SSH authentication\n\nOnce you have added your SSH key to your huggingface.co account, you can test that the connection works as expected.\n\nIn a terminal, run:\n```\n$ ssh -T git@hf.co\n```\n\nIf you see a message with your username, congrats! Everything went well, you are ready to use git over SSH.\n\nOtherwise, if the message states something like the following, make sure your SSH key is actually used by your SSH agent.\n```\nHi anonymous, welcome to Hugging Face.\n```\n--New Chunk--\n[Created at: 2025-03-24 13:15:42]\nCreate an Endpoint\n\nAfter your first login, you will be directed to the [Endpoint creation page](https://ui.endpoints.huggingface.co/new). As an example, this guide will go through the steps to deploy [distilbert-base-uncased-finetuned-sst-2-english](https://huggingface.co/distilbert-base-uncased-finetuned-sst-2-english) for text classification. \n\n## 1. Enter the Hugging Face Repository ID and your desired endpoint name:\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_repository.png\" alt=\"select repository\" />\n\n## 2. Select your Cloud Provider and region. Initially, only AWS will be available as a Cloud Provider with the `us-east-1` and `eu-west-1` regions. We will add Azure soon, and if you need to test Endpoints with other Cloud Providers or regions, please let us know.\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_region.png\" alt=\"select region\" />\n\n## 3. Define the [Security Level](security) for the Endpoint:\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_security.png\" alt=\"define security\" />\n\n## 4. Create your Endpoint by clicking **Create Endpoint**. By default, your Endpoint is created with a medium CPU (2 x 4GB vCPUs with Intel Xeon Ice Lake) The cost estimate assumes the Endpoint will be up for an entire month, and does not take autoscaling into account.\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_create_cost.png\" alt=\"create endpoint\" />\n\n## 5. Wait for the Endpoint to build, initialize and run which can take between 1 to 5 minutes.\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/overview.png\" alt=\"overview\" />\n\n## 6. Test your Endpoint in the overview with the Inference widget \ud83c\udfc1 \ud83c\udf89!\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_inference.png\" alt=\"run inference\" />\n--New Chunk--\n[Created at: 2025-03-24 13:16:48]\n\u4e0e\u5e38\u89c4\u51fd\u6570\u76f8\u540c\u7684\u65b9\u5f0f\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio\u3002\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\uff08\u865a\u62df\u7684\uff09\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5b83\u5728\u8f93\u51fa\u56fe\u50cf\u4e4b\u524d\u751f\u6210\u6570\u4e2a\u6b65\u9aa4\u7684\u566a\u97f3\uff1a\n\n$code_fake_diffusion\n$demo_fake_diffusion\n\n\u8bf7\u6ce8\u610f\uff0c\u6211\u4eec\u5728\u8fed\u4ee3\u5668\u4e2d\u6dfb\u52a0\u4e86 `time.sleep(1)`\uff0c\u4ee5\u521b\u5efa\u6b65\u9aa4\u4e4b\u95f4\u7684\u4eba\u5de5\u6682\u505c\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u89c2\u5bdf\u8fed\u4ee3\u5668\u7684\u6b65\u9aa4\uff08\u5728\u771f\u5b9e\u7684\u56fe\u50cf\u751f\u6210\u6a21\u578b\u4e2d\uff0c\u8fd9\u53ef\u80fd\u662f\u4e0d\u5fc5\u8981\u7684\uff09\u3002\n\n\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio **\u9700\u8981**\u5728\u5e95\u5c42 Interface \u6216 Blocks \u4e2d\u542f\u7528\u961f\u5217\uff08\u8bf7\u53c2\u9605\u4e0a\u9762\u7684\u961f\u5217\u90e8\u5206\uff09\u3002\n\n## \u8fdb\u5ea6\u6761\n\nGradio \u652f\u6301\u521b\u5efa\u81ea\u5b9a\u4e49\u8fdb\u5ea6\u6761\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u81ea\u5b9a\u4e49\u548c\u63a7\u5236\u5411\u7528\u6237\u663e\u793a\u7684\u8fdb\u5ea6\u66f4\u65b0\u3002\u8981\u542f\u7528\u6b64\u529f\u80fd\uff0c\u53ea\u9700\u4e3a\u65b9\u6cd5\u6dfb\u52a0\u4e00\u4e2a\u9ed8\u8ba4\u503c\u4e3a `gr.Progress` \u5b9e\u4f8b\u7684\u53c2\u6570\u5373\u53ef\u3002\u7136\u540e\uff0c\u60a8\u53ef\u4ee5\u76f4\u63a5\u8c03\u7528\u6b64\u5b9e\u4f8b\u5e76\u4f20\u5165 0 \u5230 1 \u4e4b\u95f4\u7684\u6d6e\u70b9\u6570\u6765\u66f4\u65b0\u8fdb\u5ea6\u7ea7\u522b\uff0c\u6216\u8005 with `Progress` \u5b9e\u4f8b\u7684 `tqdm()` \u65b9\u6cd5\u6765\u8ddf\u8e2a\u53ef\u8fed\u4ee3\u5bf9\u8c61\u4e0a\u7684\u8fdb\u5ea6\uff0c\u5982\u4e0b\u6240\u793a\u3002\u5fc5\u987b\u542f\u7528\u961f\u5217\u4ee5\u8fdb\u884c\u8fdb\u5ea6\u66f4\u65b0\u3002\n\n$code_progress_simple\n$demo_progress_simple\n\n\u5982\u679c\u60a8 with `tqdm` \u5e93\uff0c\u5e76\u4e14\u5e0c\u671b\u4ece\u51fd\u6570\u5185\u90e8\u7684\u4efb\u4f55 `tqdm.tqdm` \u81ea\u52a8\u62a5\u544a\u8fdb\u5ea6\u66f4\u65b0\uff0c\u8bf7\u5c06\u9ed8\u8ba4\u53c2\u6570\u8bbe\u7f6e\u4e3a `gr.Progress(track_tqdm=True)`\uff01\n\n## \u6279\u5904\u7406\u51fd\u6570 (Batch Functions)\n\nGradio \u652f\u6301\u4f20\u9012*\u6279\u5904\u7406*\u51fd\u6570\u3002\u6279\u5904\u7406\u51fd\u6570\u53ea\u662f\u63a5\u53d7\u8f93\u5165\u5217\u8868\u5e76\u8fd4\u56de\u9884\u6d4b\u5217\u8868\u7684\u51fd\u6570\u3002\n\n\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\u6279\u5904\u7406\u51fd\u6570\uff0c\u5b83\u63a5\u53d7\u4e24\u4e2a\u8f93\u5165\u5217\u8868\uff08\u4e00\u4e2a\u5355\u8bcd\u5217\u8868\u548c\u4e00\u4e2a\u6574\u6570\u5217\u8868\uff09\uff0c\u5e76\u8fd4\u56de\u4fee\u526a\u8fc7\u7684\u5355\u8bcd\u5217\u8868\u4f5c\u4e3a\u8f93\u51fa\uff1a\n\n```python\nimport time\n\ndef trim_words(words, lens):\n    trimmed_words = []\n    time.sleep(5)\n    for w, l in zip(words, lens):\n        trimmed_words.append(w[:int(l)])\n    return [trimmed_words]\n    for w, l in zip(words, lens):\n```\n\n\u4f7f\u7528\u6279\u5904\u7406\u51fd\u6570\u7684\u4f18\u70b9\u662f\uff0c\u5982\u679c\u542f\u7528\u4e86\u961f\u5217\uff0cGradio \u670d\u52a1\u5668\u53ef\u4ee5\u81ea\u52a8*\u6279\u5904\u7406*\u4f20\u5165\u7684\u8bf7\u6c42\u5e76\u5e76\u884c\u5904\u7406\u5b83\u4eec\uff0c\u4ece\u800c\u53ef\u80fd\u52a0\u5feb\u6f14\u793a\u901f\u5ea6\u3002\u4ee5\u4e0b\u662f Gradio \u4ee3\u7801\u7684\u793a\u4f8b\uff08\u8bf7\u6ce8\u610f `batch=True` \u548c `max_batch_size=16` - \u8fd9\u4e24\u4e2a\u53c2\u6570\u90fd\u53ef\u4ee5\u4f20\u9012\u7ed9\u4e8b\u4ef6\u89e6\u53d1\u5668\u6216 `Interface` \u7c7b\uff09\n\nwith `Interface`\uff1a\n\n```python\ndemo = gr.Interface(trim_words, [\"textbox\", \"number\"], [\"output\"],\n                    batch=True, max_batch_size=16)\ndemo.queue()\ndemo.launch()\n```\n\nwith `Blocks`\uff1a\n\n```python\nimport gradio as gr\n\nwith gr.Blocks() as demo:\n    with gr.Row():\n        word = gr.Textbox(label=\"word\")\n        leng = gr.Number(label=\"leng\")\n        output = gr.Textbox(label=\"Output\")\n    with gr.Row():\n        run = gr.Button()\n\n    event = run.click(trim_words, [word, leng], output, batch=True, max_batch_size=16)\n\ndemo.queue()\ndemo.launch()\n```\n\n\u5728\u4e0a\u9762\u7684\u793a\u4f8b\u4e2d\uff0c\u53ef\u4ee5\u5e76\u884c\u5904\u7406 16 \u4e2a\u8bf7\u6c42\uff08\u603b\u63a8\u7406\u65f6\u95f4\u4e3a 5 \u79d2\uff09\uff0c\u800c\u4e0d\u662f\u5206\u522b\u5904\u7406\u6bcf\u4e2a\u8bf7\u6c42\uff08\u603b\u63a8\u7406\u65f6\u95f4\u4e3a 80 \u79d2\uff09\u3002\u8bb8\u591a Hugging Face \u7684 `transformers` \u548c `diffusers` \u6a21\u578b\u5728 Gradio \u7684\u6279\u5904\u7406\u6a21\u5f0f\u4e0b\u81ea\u7136\u5de5\u4f5c\uff1a\u8fd9\u662f[\u4f7f\u7528\u6279\u5904\u7406\u751f\u6210\u56fe\u50cf\u7684\u793a\u4f8b\u6f14\u793a](https://github.com/gradio-app/gradio/blob/main/demo/diffusers_with_batching/run.py)\n\n\u6ce8\u610f\uff1a\u4f7f\u7528 Gradio \u7684\u6279\u5904\u7406\u51fd\u6570 **requires** \u5728\u5e95\u5c42 Interface \u6216 Blocks \u4e2d\u542f\u7528\u961f\u5217\uff08\u8bf7\u53c2\u9605\u4e0a\u9762\u7684\u961f\u5217\u90e8\u5206\uff09\u3002\n\n## Gradio \u7b14\u8bb0\u672c (Colab Notebooks)\n\nGradio \u53ef\u4ee5\u5728\u4efb\u4f55\u8fd0\u884c Python \u7684\u5730\u65b9\u8fd0\u884c\uff0c\u5305\u62ec\u672c\u5730 Jupyter \u7b14\u8bb0\u672c\u548c\u534f\u4f5c\u7b14\u8bb0\u672c\uff0c\u5982[Google Colab](https://colab.research.google.com/)\u3002\u5bf9\u4e8e\u672c\u5730 Jupyter \u7b14\u8bb0\u672c\u548c Google Colab \u7b14\u8bb0\u672c\uff0cGradio \u5728\u672c\u5730\u670d\u52a1\u5668\u4e0a\u8fd0\u884c\uff0c\u60a8\u53ef\u4ee5\u5728\u6d4f\u89c8\u5668\u4e2d\u4e0e\u4e4b\u4ea4\u4e92\u3002\uff08\u6ce8\u610f\uff1a\u5bf9\u4e8e Google Colab\uff0c\u8fd9\u662f\u901a\u8fc7[\u670d\u52a1\u5de5\u4f5c\u5668\u96a7\u9053](https://github.com/tensorflow/tensorboard/blob/master/docs/design/colab_integration.md)\u5b9e\u73b0\u7684\uff0c\u60a8\u7684\u6d4f\u89c8\u5668\u9700\u8981\u542f\u7528 cookies\u3002\uff09\u5bf9\u4e8e\u5176\u4ed6\u8fdc\u7a0b\u7b14\u8bb0\u672c\uff0cGradio \u4e5f\u5c06\u5728\u670d\u52a1\u5668\u4e0a\u8fd0\u884c\uff0c\u4f46\u60a8\u9700\u8981\u4f7f\u7528[SSH \u96a7\u9053](https://coderwall.com/p/ohk6cg/remote-access-to-ipython-notebooks-via-ssh)\u5728\u672c\u5730\u6d4f\u89c8\u5668\u4e2d\u67e5\u770b\u5e94\u7528\u7a0b\u5e8f\u3002\u901a\u5e38\uff0c\u66f4\u7b80\u5355\u7684\u9009\u62e9\u662f\u4f7f\u7528 Gradio \u5185\u7f6e\u7684\u516c\u5171\u94fe\u63a5\uff0c[\u5728\u4e0b\u4e00\u7bc7\u6307\u5357\u4e2d\u8ba8\u8bba](/sharing-your-app/#sharing-demos)\u3002"
        }
    },
    {
        "sample_idx": 94,
        "question": "What command is used to add a new SSH key to the SSH agent?",
        "answer": "The command ssh-add is used to add a new SSH key to the SSH agent.",
        "rag_answer": "The command used to add a new SSH key to the SSH agent is `ssh-add`. Specifically, you would use the command `ssh-add ~/.ssh/id_ed25519` to add the new key to the SSH agent, assuming the key is located in the default location `~/.ssh/id_ed25519`.",
        "rag_score": 5,
        "rag_feedback": "The response is completely correct, accurate, and factual. It provides the correct command 'ssh-add' to add a new SSH key to the SSH agent and also provides additional information about how to use the command with the correct file location.",
        "rag_context": {
            "kg_context": "-----Entities-----\n    ```csv\n    id,\tentity,\ttype,\tdescription,\trankcreated_at\n1,\tLinux,geo,Linux is a type of operating system.,1,2025-03-24 13:19:17\n2,\tSSH,category,Gradio can be run on remote servers using SSH.<SEP>SSH is a secure protocol used for authentication and data transfer.,6,2025-03-24 13:19:17\n3,\tMac,geo,Mac is a type of operating system.,1,2025-03-24 13:19:17\n4,\tprivate key,category,Private key is a secure key used for SSH authentication.,1,2025-03-24 13:19:17\n5,\tpublic key,category,Public key is a secure key used for SSH authentication.,1,2025-03-24 13:19:17\n6,\tssh-add,category,ssh-add is a command used to add a SSH key to the SSH agent.,0,UNKNOWN\n7,\t SSH,category,SSH is a protocol for secure remote access to computers.,0,UNKNOWN\n8,\tssh-keygen,category,ssh-keygen is a command used to generate a new SSH key pair.,0,UNKNOWN\n    ```\n    -----Relationships-----\n    ```csv\n    id,\tsource,\ttarget,\tdescription,\tkeywords,\tweight,\trank,\tcreated_at\n1,\tLinux,SSH,Linux is a platform that uses SSH for authentication.,platform, authentication,12.0,7,2025-03-24 13:19:17\n2,\tMac,SSH,Mac is a platform that uses SSH for authentication.,platform, authentication,12.0,7,2025-03-24 13:19:17\n3,\tprivate key,public key,Private key is used to generate a public key for SSH authentication.,key generation, authentication,8.0,2,2025-03-24 13:19:17\n    ```\n    -----Sources-----\n    ```csv\n    id,\tcontent\n1,\tGit over SSH\n\nYou can access and write data in repositories on huggingface.co using SSH (Secure Shell Protocol). When you connect via SSH, you authenticate using a private key file on your local machine.\n\nSome actions, such as pushing changes, or cloning private repositories, will require you to upload your SSH public key to your account on huggingface.co.\n\nYou can use a pre-existing SSH key, or generate a new one specifically for huggingface.co.\n\n## Checking for existing SSH keys\n\nIf you have an existing SSH key, you can use that key to authenticate Git operations over SSH.\n\nSSH keys are usually located under `~/.ssh` on Mac & Linux, and under `C:\\\\Users\\\\<username>\\\\.ssh` on Windows. List files under that directory and look for files of the form:\n\n- id_rsa.pub\n- id_ecdsa.pub\n- id_ed25519.pub\n\nThose files contain your SSH public key.\n\nIf you don't have such file under `~/.ssh`, you will have to [generate a new key](#generating-a-new-ssh-keypair). Otherwise, you can [add your existing SSH public key(s) to your huggingface.co account](#add-a-ssh-key-to-your-account).\n\n## Generating a new SSH keypair\n\nIf you don't have any SSH keys on your machine, you can use `ssh-keygen` to generate a new SSH key pair (public + private keys):\n\n```\n$ ssh-keygen -t ed25519 -C \"your.email@example.co\"\n```\n\nWe recommend entering a passphrase when you are prompted to. A passphrase is an extra layer of security: it is a password that will be prompted whenever you use your SSH key.\n\nOnce your new key is generated, add it to your SSH agent with `ssh-add`:\n\n```\n$ ssh-add ~/.ssh/id_ed25519\n```\n\nIf you chose a different location than the default to store your SSH key, you would have to replace `~/.ssh/id_ed25519` with the file location you used.\n\n## Add a SSH key to your account\n\nTo access private repositories with SSH, or to push changes via SSH, you will need to add your SSH public key to your huggingface.co account. You can manage your SSH keys [in your user settings](https://huggingface.co/settings/keys).\n\nTo add a SSH key to your account, click on the \"Add SSH key\" button.\n\nThen, enter a name for this key (for example, \"Personal computer\"), and copy and paste the content of your **public** SSH key in the area below. The public key is located in the `~/.ssh/id_XXXX.pub` file you found or generated in the previous steps.\n\nClick on \"Add key\", and voil\u00e0! You have added a SSH key to your huggingface.co account.\n\n\n## Testing your SSH authentication\n\nOnce you have added your SSH key to your huggingface.co account, you can test that the connection works as expected.\n\nIn a terminal, run:\n```\n$ ssh -T git@hf.co\n```\n\nIf you see a message with your username, congrats! Everything went well, you are ready to use git over SSH.\n\nOtherwise, if the message states something like the following, make sure your SSH key is actually used by your SSH agent.\n```\nHi anonymous, welcome to Hugging Face.\n```\n2,\t\u4e0e\u5e38\u89c4\u51fd\u6570\u76f8\u540c\u7684\u65b9\u5f0f\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio\u3002\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\uff08\u865a\u62df\u7684\uff09\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5b83\u5728\u8f93\u51fa\u56fe\u50cf\u4e4b\u524d\u751f\u6210\u6570\u4e2a\u6b65\u9aa4\u7684\u566a\u97f3\uff1a\n\n$code_fake_diffusion\n$demo_fake_diffusion\n\n\u8bf7\u6ce8\u610f\uff0c\u6211\u4eec\u5728\u8fed\u4ee3\u5668\u4e2d\u6dfb\u52a0\u4e86 `time.sleep(1)`\uff0c\u4ee5\u521b\u5efa\u6b65\u9aa4\u4e4b\u95f4\u7684\u4eba\u5de5\u6682\u505c\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u89c2\u5bdf\u8fed\u4ee3\u5668\u7684\u6b65\u9aa4\uff08\u5728\u771f\u5b9e\u7684\u56fe\u50cf\u751f\u6210\u6a21\u578b\u4e2d\uff0c\u8fd9\u53ef\u80fd\u662f\u4e0d\u5fc5\u8981\u7684\uff09\u3002\n\n\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio **\u9700\u8981**\u5728\u5e95\u5c42 Interface \u6216 Blocks \u4e2d\u542f\u7528\u961f\u5217\uff08\u8bf7\u53c2\u9605\u4e0a\u9762\u7684\u961f\u5217\u90e8\u5206\uff09\u3002\n\n## \u8fdb\u5ea6\u6761\n\nGradio \u652f\u6301\u521b\u5efa\u81ea\u5b9a\u4e49\u8fdb\u5ea6\u6761\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u81ea\u5b9a\u4e49\u548c\u63a7\u5236\u5411\u7528\u6237\u663e\u793a\u7684\u8fdb\u5ea6\u66f4\u65b0\u3002\u8981\u542f\u7528\u6b64\u529f\u80fd\uff0c\u53ea\u9700\u4e3a\u65b9\u6cd5\u6dfb\u52a0\u4e00\u4e2a\u9ed8\u8ba4\u503c\u4e3a `gr.Progress` \u5b9e\u4f8b\u7684\u53c2\u6570\u5373\u53ef\u3002\u7136\u540e\uff0c\u60a8\u53ef\u4ee5\u76f4\u63a5\u8c03\u7528\u6b64\u5b9e\u4f8b\u5e76\u4f20\u5165 0 \u5230 1 \u4e4b\u95f4\u7684\u6d6e\u70b9\u6570\u6765\u66f4\u65b0\u8fdb\u5ea6\u7ea7\u522b\uff0c\u6216\u8005 with `Progress` \u5b9e\u4f8b\u7684 `tqdm()` \u65b9\u6cd5\u6765\u8ddf\u8e2a\u53ef\u8fed\u4ee3\u5bf9\u8c61\u4e0a\u7684\u8fdb\u5ea6\uff0c\u5982\u4e0b\u6240\u793a\u3002\u5fc5\u987b\u542f\u7528\u961f\u5217\u4ee5\u8fdb\u884c\u8fdb\u5ea6\u66f4\u65b0\u3002\n\n$code_progress_simple\n$demo_progress_simple\n\n\u5982\u679c\u60a8 with `tqdm` \u5e93\uff0c\u5e76\u4e14\u5e0c\u671b\u4ece\u51fd\u6570\u5185\u90e8\u7684\u4efb\u4f55 `tqdm.tqdm` \u81ea\u52a8\u62a5\u544a\u8fdb\u5ea6\u66f4\u65b0\uff0c\u8bf7\u5c06\u9ed8\u8ba4\u53c2\u6570\u8bbe\u7f6e\u4e3a `gr.Progress(track_tqdm=True)`\uff01\n\n## \u6279\u5904\u7406\u51fd\u6570 (Batch Functions)\n\nGradio \u652f\u6301\u4f20\u9012*\u6279\u5904\u7406*\u51fd\u6570\u3002\u6279\u5904\u7406\u51fd\u6570\u53ea\u662f\u63a5\u53d7\u8f93\u5165\u5217\u8868\u5e76\u8fd4\u56de\u9884\u6d4b\u5217\u8868\u7684\u51fd\u6570\u3002\n\n\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\u6279\u5904\u7406\u51fd\u6570\uff0c\u5b83\u63a5\u53d7\u4e24\u4e2a\u8f93\u5165\u5217\u8868\uff08\u4e00\u4e2a\u5355\u8bcd\u5217\u8868\u548c\u4e00\u4e2a\u6574\u6570\u5217\u8868\uff09\uff0c\u5e76\u8fd4\u56de\u4fee\u526a\u8fc7\u7684\u5355\u8bcd\u5217\u8868\u4f5c\u4e3a\u8f93\u51fa\uff1a\n\n```python\nimport time\n\ndef trim_words(words, lens):\n    trimmed_words = []\n    time.sleep(5)\n    for w, l in zip(words, lens):\n        trimmed_words.append(w[:int(l)])\n    return [trimmed_words]\n    for w, l in zip(words, lens):\n```\n\n\u4f7f\u7528\u6279\u5904\u7406\u51fd\u6570\u7684\u4f18\u70b9\u662f\uff0c\u5982\u679c\u542f\u7528\u4e86\u961f\u5217\uff0cGradio \u670d\u52a1\u5668\u53ef\u4ee5\u81ea\u52a8*\u6279\u5904\u7406*\u4f20\u5165\u7684\u8bf7\u6c42\u5e76\u5e76\u884c\u5904\u7406\u5b83\u4eec\uff0c\u4ece\u800c\u53ef\u80fd\u52a0\u5feb\u6f14\u793a\u901f\u5ea6\u3002\u4ee5\u4e0b\u662f Gradio \u4ee3\u7801\u7684\u793a\u4f8b\uff08\u8bf7\u6ce8\u610f `batch=True` \u548c `max_batch_size=16` - \u8fd9\u4e24\u4e2a\u53c2\u6570\u90fd\u53ef\u4ee5\u4f20\u9012\u7ed9\u4e8b\u4ef6\u89e6\u53d1\u5668\u6216 `Interface` \u7c7b\uff09\n\nwith `Interface`\uff1a\n\n```python\ndemo = gr.Interface(trim_words, [\"textbox\", \"number\"], [\"output\"],\n                    batch=True, max_batch_size=16)\ndemo.queue()\ndemo.launch()\n```\n\nwith `Blocks`\uff1a\n\n```python\nimport gradio as gr\n\nwith gr.Blocks() as demo:\n    with gr.Row():\n        word = gr.Textbox(label=\"word\")\n        leng = gr.Number(label=\"leng\")\n        output = gr.Textbox(label=\"Output\")\n    with gr.Row():\n        run = gr.Button()\n\n    event = run.click(trim_words, [word, leng], output, batch=True, max_batch_size=16)\n\ndemo.queue()\ndemo.launch()\n```\n\n\u5728\u4e0a\u9762\u7684\u793a\u4f8b\u4e2d\uff0c\u53ef\u4ee5\u5e76\u884c\u5904\u7406 16 \u4e2a\u8bf7\u6c42\uff08\u603b\u63a8\u7406\u65f6\u95f4\u4e3a 5 \u79d2\uff09\uff0c\u800c\u4e0d\u662f\u5206\u522b\u5904\u7406\u6bcf\u4e2a\u8bf7\u6c42\uff08\u603b\u63a8\u7406\u65f6\u95f4\u4e3a 80 \u79d2\uff09\u3002\u8bb8\u591a Hugging Face \u7684 `transformers` \u548c `diffusers` \u6a21\u578b\u5728 Gradio \u7684\u6279\u5904\u7406\u6a21\u5f0f\u4e0b\u81ea\u7136\u5de5\u4f5c\uff1a\u8fd9\u662f[\u4f7f\u7528\u6279\u5904\u7406\u751f\u6210\u56fe\u50cf\u7684\u793a\u4f8b\u6f14\u793a](https://github.com/gradio-app/gradio/blob/main/demo/diffusers_with_batching/run.py)\n\n\u6ce8\u610f\uff1a\u4f7f\u7528 Gradio \u7684\u6279\u5904\u7406\u51fd\u6570 **requires** \u5728\u5e95\u5c42 Interface \u6216 Blocks \u4e2d\u542f\u7528\u961f\u5217\uff08\u8bf7\u53c2\u9605\u4e0a\u9762\u7684\u961f\u5217\u90e8\u5206\uff09\u3002\n\n## Gradio \u7b14\u8bb0\u672c (Colab Notebooks)\n\nGradio \u53ef\u4ee5\u5728\u4efb\u4f55\u8fd0\u884c Python \u7684\u5730\u65b9\u8fd0\u884c\uff0c\u5305\u62ec\u672c\u5730 Jupyter \u7b14\u8bb0\u672c\u548c\u534f\u4f5c\u7b14\u8bb0\u672c\uff0c\u5982[Google Colab](https://colab.research.google.com/)\u3002\u5bf9\u4e8e\u672c\u5730 Jupyter \u7b14\u8bb0\u672c\u548c Google Colab \u7b14\u8bb0\u672c\uff0cGradio \u5728\u672c\u5730\u670d\u52a1\u5668\u4e0a\u8fd0\u884c\uff0c\u60a8\u53ef\u4ee5\u5728\u6d4f\u89c8\u5668\u4e2d\u4e0e\u4e4b\u4ea4\u4e92\u3002\uff08\u6ce8\u610f\uff1a\u5bf9\u4e8e Google Colab\uff0c\u8fd9\u662f\u901a\u8fc7[\u670d\u52a1\u5de5\u4f5c\u5668\u96a7\u9053](https://github.com/tensorflow/tensorboard/blob/master/docs/design/colab_integration.md)\u5b9e\u73b0\u7684\uff0c\u60a8\u7684\u6d4f\u89c8\u5668\u9700\u8981\u542f\u7528 cookies\u3002\uff09\u5bf9\u4e8e\u5176\u4ed6\u8fdc\u7a0b\u7b14\u8bb0\u672c\uff0cGradio \u4e5f\u5c06\u5728\u670d\u52a1\u5668\u4e0a\u8fd0\u884c\uff0c\u4f46\u60a8\u9700\u8981\u4f7f\u7528[SSH \u96a7\u9053](https://coderwall.com/p/ohk6cg/remote-access-to-ipython-notebooks-via-ssh)\u5728\u672c\u5730\u6d4f\u89c8\u5668\u4e2d\u67e5\u770b\u5e94\u7528\u7a0b\u5e8f\u3002\u901a\u5e38\uff0c\u66f4\u7b80\u5355\u7684\u9009\u62e9\u662f\u4f7f\u7528 Gradio \u5185\u7f6e\u7684\u516c\u5171\u94fe\u63a5\uff0c[\u5728\u4e0b\u4e00\u7bc7\u6307\u5357\u4e2d\u8ba8\u8bba](/sharing-your-app/#sharing-demos)\u3002\n    ```",
            "vector_context": "[Created at: 2025-03-24 13:18:47]\nGit over SSH\n\nYou can access and write data in repositories on huggingface.co using SSH (Secure Shell Protocol). When you connect via SSH, you authenticate using a private key file on your local machine.\n\nSome actions, such as pushing changes, or cloning private repositories, will require you to upload your SSH public key to your account on huggingface.co.\n\nYou can use a pre-existing SSH key, or generate a new one specifically for huggingface.co.\n\n## Checking for existing SSH keys\n\nIf you have an existing SSH key, you can use that key to authenticate Git operations over SSH.\n\nSSH keys are usually located under `~/.ssh` on Mac & Linux, and under `C:\\\\Users\\\\<username>\\\\.ssh` on Windows. List files under that directory and look for files of the form:\n\n- id_rsa.pub\n- id_ecdsa.pub\n- id_ed25519.pub\n\nThose files contain your SSH public key.\n\nIf you don't have such file under `~/.ssh`, you will have to [generate a new key](#generating-a-new-ssh-keypair). Otherwise, you can [add your existing SSH public key(s) to your huggingface.co account](#add-a-ssh-key-to-your-account).\n\n## Generating a new SSH keypair\n\nIf you don't have any SSH keys on your machine, you can use `ssh-keygen` to generate a new SSH key pair (public + private keys):\n\n```\n$ ssh-keygen -t ed25519 -C \"your.email@example.co\"\n```\n\nWe recommend entering a passphrase when you are prompted to. A passphrase is an extra layer of security: it is a password that will be prompted whenever you use your SSH key.\n\nOnce your new key is generated, add it to your SSH agent with `ssh-add`:\n\n```\n$ ssh-add ~/.ssh/id_ed25519\n```\n\nIf you chose a different location than the default to store your SSH key, you would have to replace `~/.ssh/id_ed25519` with the file location you used.\n\n## Add a SSH key to your account\n\nTo access private repositories with SSH, or to push changes via SSH, you will need to add your SSH public key to your huggingface.co account. You can manage your SSH keys [in your user settings](https://huggingface.co/settings/keys).\n\nTo add a SSH key to your account, click on the \"Add SSH key\" button.\n\nThen, enter a name for this key (for example, \"Personal computer\"), and copy and paste the content of your **public** SSH key in the area below. The public key is located in the `~/.ssh/id_XXXX.pub` file you found or generated in the previous steps.\n\nClick on \"Add key\", and voil\u00e0! You have added a SSH key to your huggingface.co account.\n\n\n## Testing your SSH authentication\n\nOnce you have added your SSH key to your huggingface.co account, you can test that the connection works as expected.\n\nIn a terminal, run:\n```\n$ ssh -T git@hf.co\n```\n\nIf you see a message with your username, congrats! Everything went well, you are ready to use git over SSH.\n\nOtherwise, if the message states something like the following, make sure your SSH key is actually used by your SSH agent.\n```\nHi anonymous, welcome to Hugging Face.\n```\n--New Chunk--\n[Created at: 2025-03-24 13:15:42]\nCreate an Endpoint\n\nAfter your first login, you will be directed to the [Endpoint creation page](https://ui.endpoints.huggingface.co/new). As an example, this guide will go through the steps to deploy [distilbert-base-uncased-finetuned-sst-2-english](https://huggingface.co/distilbert-base-uncased-finetuned-sst-2-english) for text classification. \n\n## 1. Enter the Hugging Face Repository ID and your desired endpoint name:\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_repository.png\" alt=\"select repository\" />\n\n## 2. Select your Cloud Provider and region. Initially, only AWS will be available as a Cloud Provider with the `us-east-1` and `eu-west-1` regions. We will add Azure soon, and if you need to test Endpoints with other Cloud Providers or regions, please let us know.\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_region.png\" alt=\"select region\" />\n\n## 3. Define the [Security Level](security) for the Endpoint:\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_security.png\" alt=\"define security\" />\n\n## 4. Create your Endpoint by clicking **Create Endpoint**. By default, your Endpoint is created with a medium CPU (2 x 4GB vCPUs with Intel Xeon Ice Lake) The cost estimate assumes the Endpoint will be up for an entire month, and does not take autoscaling into account.\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_create_cost.png\" alt=\"create endpoint\" />\n\n## 5. Wait for the Endpoint to build, initialize and run which can take between 1 to 5 minutes.\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/overview.png\" alt=\"overview\" />\n\n## 6. Test your Endpoint in the overview with the Inference widget \ud83c\udfc1 \ud83c\udf89!\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_inference.png\" alt=\"run inference\" />\n--New Chunk--\n[Created at: 2025-03-24 13:17:32]\n!--Copyright 2023 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\nthe License. You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under the License is distributed on\nan \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n\n\u26a0\ufe0f Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be\nrendered properly in your Markdown viewer.\n\n-->\n\n# Training on TPU with TensorFlow\n\n<Tip>\n\nIf you don't need long explanations and just want TPU code samples to get started with, check out [our TPU example notebook!](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb)\n\n</Tip>\n\n### What is a TPU?\n\nA TPU is a **Tensor Processing Unit.** They are hardware designed by Google, which are used to greatly speed up the tensor computations within neural networks, much like GPUs. They can be used for both network training and inference. They are generally accessed through Google\u2019s cloud services, but small TPUs can also be accessed directly for free through Google Colab and Kaggle Kernels.\n\nBecause [all TensorFlow models in \ud83e\udd17 Transformers are Keras models](https://huggingface.co/blog/tensorflow-philosophy), most of the methods in this document are generally applicable to TPU training for any Keras model! However, there are a few points that are specific to the HuggingFace ecosystem (hug-o-system?) of Transformers and Datasets, and we\u2019ll make sure to flag them up when we get to them.\n\n### What kinds of TPU are available?\n\nNew users are often very confused by the range of TPUs, and the different ways to access them. The first key distinction to understand is the difference between **TPU Nodes** and **TPU VMs.**\n\nWhen you use a **TPU Node**, you are effectively indirectly accessing a remote TPU. You will need a separate VM, which will initialize your network and data pipeline and then forward them to the remote node. When you use a TPU on Google Colab, you are accessing it in the **TPU Node** style.\n\nUsing TPU Nodes can have some quite unexpected behaviour for people who aren\u2019t used to them! In particular, because the TPU is located on a physically different system to the machine you\u2019re running your Python code on, your data cannot be local to your machine - any data pipeline that loads from your machine\u2019s internal storage will totally fail! Instead, data must be stored in Google Cloud Storage where your data pipeline can still access it, even when the pipeline is running on the remote TPU node.\n\n<Tip>\n\nIf you can fit all your data in memory as `np.ndarray` or `tf.Tensor`, then you can `fit()` on that data even when using Colab or a TPU Node, without needing to upload it to Google Cloud Storage.\n\n</Tip>\n\n<Tip>\n\n**\ud83e\udd17Specific Hugging Face Tip\ud83e\udd17:** The methods `Dataset.to_tf_dataset()` and its higher-level wrapper `model.prepare_tf_dataset()` , which you will see throughout our TF code examples, will both fail on a TPU Node. The reason for this is that even though they create a `tf.data.Dataset` it is not a \u201cpure\u201d `tf.data` pipeline and uses `tf.numpy_function` or `Dataset.from_generator()` to stream data from the underlying HuggingFace `Dataset`. This HuggingFace `Dataset` is backed by data that is on a local disc and which the remote TPU Node will not be able to read.\n\n</Tip>\n\nThe second way to access a TPU is via a **TPU VM.** When using a TPU VM, you connect directly to the machine that the TPU is attached to, much like training on a GPU VM. TPU VMs are generally easier to work with, particularly when it comes to your data pipeline. All of the above warnings do not apply to TPU VMs!\n\nThis is an opinionated document, so here\u2019s our opinion: **Avoid using TPU Node if possible.** It is more confusing and more difficult to debug than TPU VMs. It is also likely to be unsupported in future - Google\u2019s latest TPU, TPUv4, can only be accessed as a TPU VM, which suggests that TPU Nodes are increasingly going to become a \u201clegacy\u201d access method. However, we understand that the only free TPU access is on Colab and Kaggle Kernels, which uses TPU Node - so we\u2019ll try to explain how to handle it if you have to! Check the [TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) for code samples that explain this in more detail.\n\n### What sizes of TPU are available?\n\nA single TPU (a v2-8/v3-8/v4-8) runs 8 replicas. TPUs exist in **pods** that can run hundreds or thousands of replicas simultaneously. When you use more than a single TPU but less than a whole pod (for example, a v3-32), your TPU fleet is referred to as a **pod slice.**\n\nWhen you access a free TPU via Colab, you generally get a single v2-8 TPU.\n\n### I keep hearing about this XLA thing. What\u2019s XLA, and how does it relate to TPUs?\n\nXLA is an optimizing compiler, used by both TensorFlow and JAX. In JAX it is the only compiler, whereas in TensorFlow it is optional"
        }
    },
    {
        "sample_idx": 95,
        "question": "Where is the public SSH key located?",
        "answer": "The public key is located in the ~/.ssh/id_XXXX.pub file.",
        "rag_answer": "The public SSH key is usually located under `~/.ssh` on Mac & Linux, and under `C:\\\\Users\\\\<username>\\\\.ssh` on Windows. The files containing the SSH public key are typically named `id_rsa.pub`, `id_ecdsa.pub`, or `id_ed25519.pub`.",
        "rag_score": 4,
        "rag_feedback": "The system's response is mostly correct, accurate, and factual. It provides detailed information about the location of SSH keys on different operating systems, including Mac, Linux, and Windows. The response also mentions the typical file names of SSH public keys, such as id_rsa.pub, id_ecdsa.pub, and id_ed25519.pub. However, the response is a bit lengthy and includes some unnecessary information, which makes it somewhat difficult to extract the relevant answer to the question.",
        "rag_context": {
            "kg_context": "-----Entities-----\n    ```csv\n    id,\tentity,\ttype,\tdescription,\trankcreated_at\n1,\tGradio,organization,Gradio is a platform that supports state in Blocks, providing features such as global state and session state.<SEP>Gradio is an interface that provides various features for demonstrating models, including adding example inputs, custom error messages, descriptive content, flagging, and more.<SEP>Gradio is an organization that provides a platform for building and deploying machine learning models.<SEP>Gradio is an organization that provides a platform for creating and deploying machine learning models.<SEP>Gradio is an organization that provides a demo for blocks_random_slider, and its library is used to create interactive interfaces.,36,2025-03-24 13:19:17\n2,\tSSH,category,Gradio can be run on remote servers using SSH.<SEP>SSH is a secure protocol used for authentication and data transfer.,6,2025-03-24 13:19:17\n3,\tWindows,geo,Windows is a type of operating system.,1,2025-03-24 13:19:17\n4,\tLinux,geo,Linux is a type of operating system.,1,2025-03-24 13:19:17\n5,\t~/.ssh,geo,~/.ssh is a directory where SSH keys are usually stored on Mac and Linux.,0,UNKNOWN\n6,\tC:\\\\Users\\\\<username>\\\\.ssh,geo,C:\\\\Users\\\\<username>\\\\.ssh is a directory where SSH keys are usually stored on Windows.,0,UNKNOWN\n7,\tprivate key,category,Private key is a secure key used for SSH authentication.,1,UNKNOWN\n    ```\n    -----Relationships-----\n    ```csv\n    id,\tsource,\ttarget,\tdescription,\tkeywords,\tweight,\trank,\tcreated_at\n1,\tGradio,SSH,Gradio can be run on remote servers using SSH.,remote access, security,7.0,42,2025-03-24 13:17:31\n2,\tSSH,Windows,Windows is a platform that uses SSH for authentication.,platform, authentication,12.0,7,2025-03-24 13:19:17\n3,\tLinux,SSH,Linux is a platform that uses SSH for authentication.,platform, authentication,12.0,7,2025-03-24 13:19:17\n4,\tprivate key,public key,Private key is used to generate a public key for SSH authentication.,key generation, authentication,8.0,2,UNKNOWN\n    ```\n    -----Sources-----\n    ```csv\n    id,\tcontent\n1,\t\u4e0e\u5e38\u89c4\u51fd\u6570\u76f8\u540c\u7684\u65b9\u5f0f\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio\u3002\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\uff08\u865a\u62df\u7684\uff09\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5b83\u5728\u8f93\u51fa\u56fe\u50cf\u4e4b\u524d\u751f\u6210\u6570\u4e2a\u6b65\u9aa4\u7684\u566a\u97f3\uff1a\n\n$code_fake_diffusion\n$demo_fake_diffusion\n\n\u8bf7\u6ce8\u610f\uff0c\u6211\u4eec\u5728\u8fed\u4ee3\u5668\u4e2d\u6dfb\u52a0\u4e86 `time.sleep(1)`\uff0c\u4ee5\u521b\u5efa\u6b65\u9aa4\u4e4b\u95f4\u7684\u4eba\u5de5\u6682\u505c\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u89c2\u5bdf\u8fed\u4ee3\u5668\u7684\u6b65\u9aa4\uff08\u5728\u771f\u5b9e\u7684\u56fe\u50cf\u751f\u6210\u6a21\u578b\u4e2d\uff0c\u8fd9\u53ef\u80fd\u662f\u4e0d\u5fc5\u8981\u7684\uff09\u3002\n\n\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio **\u9700\u8981**\u5728\u5e95\u5c42 Interface \u6216 Blocks \u4e2d\u542f\u7528\u961f\u5217\uff08\u8bf7\u53c2\u9605\u4e0a\u9762\u7684\u961f\u5217\u90e8\u5206\uff09\u3002\n\n## \u8fdb\u5ea6\u6761\n\nGradio \u652f\u6301\u521b\u5efa\u81ea\u5b9a\u4e49\u8fdb\u5ea6\u6761\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u81ea\u5b9a\u4e49\u548c\u63a7\u5236\u5411\u7528\u6237\u663e\u793a\u7684\u8fdb\u5ea6\u66f4\u65b0\u3002\u8981\u542f\u7528\u6b64\u529f\u80fd\uff0c\u53ea\u9700\u4e3a\u65b9\u6cd5\u6dfb\u52a0\u4e00\u4e2a\u9ed8\u8ba4\u503c\u4e3a `gr.Progress` \u5b9e\u4f8b\u7684\u53c2\u6570\u5373\u53ef\u3002\u7136\u540e\uff0c\u60a8\u53ef\u4ee5\u76f4\u63a5\u8c03\u7528\u6b64\u5b9e\u4f8b\u5e76\u4f20\u5165 0 \u5230 1 \u4e4b\u95f4\u7684\u6d6e\u70b9\u6570\u6765\u66f4\u65b0\u8fdb\u5ea6\u7ea7\u522b\uff0c\u6216\u8005 with `Progress` \u5b9e\u4f8b\u7684 `tqdm()` \u65b9\u6cd5\u6765\u8ddf\u8e2a\u53ef\u8fed\u4ee3\u5bf9\u8c61\u4e0a\u7684\u8fdb\u5ea6\uff0c\u5982\u4e0b\u6240\u793a\u3002\u5fc5\u987b\u542f\u7528\u961f\u5217\u4ee5\u8fdb\u884c\u8fdb\u5ea6\u66f4\u65b0\u3002\n\n$code_progress_simple\n$demo_progress_simple\n\n\u5982\u679c\u60a8 with `tqdm` \u5e93\uff0c\u5e76\u4e14\u5e0c\u671b\u4ece\u51fd\u6570\u5185\u90e8\u7684\u4efb\u4f55 `tqdm.tqdm` \u81ea\u52a8\u62a5\u544a\u8fdb\u5ea6\u66f4\u65b0\uff0c\u8bf7\u5c06\u9ed8\u8ba4\u53c2\u6570\u8bbe\u7f6e\u4e3a `gr.Progress(track_tqdm=True)`\uff01\n\n## \u6279\u5904\u7406\u51fd\u6570 (Batch Functions)\n\nGradio \u652f\u6301\u4f20\u9012*\u6279\u5904\u7406*\u51fd\u6570\u3002\u6279\u5904\u7406\u51fd\u6570\u53ea\u662f\u63a5\u53d7\u8f93\u5165\u5217\u8868\u5e76\u8fd4\u56de\u9884\u6d4b\u5217\u8868\u7684\u51fd\u6570\u3002\n\n\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\u6279\u5904\u7406\u51fd\u6570\uff0c\u5b83\u63a5\u53d7\u4e24\u4e2a\u8f93\u5165\u5217\u8868\uff08\u4e00\u4e2a\u5355\u8bcd\u5217\u8868\u548c\u4e00\u4e2a\u6574\u6570\u5217\u8868\uff09\uff0c\u5e76\u8fd4\u56de\u4fee\u526a\u8fc7\u7684\u5355\u8bcd\u5217\u8868\u4f5c\u4e3a\u8f93\u51fa\uff1a\n\n```python\nimport time\n\ndef trim_words(words, lens):\n    trimmed_words = []\n    time.sleep(5)\n    for w, l in zip(words, lens):\n        trimmed_words.append(w[:int(l)])\n    return [trimmed_words]\n    for w, l in zip(words, lens):\n```\n\n\u4f7f\u7528\u6279\u5904\u7406\u51fd\u6570\u7684\u4f18\u70b9\u662f\uff0c\u5982\u679c\u542f\u7528\u4e86\u961f\u5217\uff0cGradio \u670d\u52a1\u5668\u53ef\u4ee5\u81ea\u52a8*\u6279\u5904\u7406*\u4f20\u5165\u7684\u8bf7\u6c42\u5e76\u5e76\u884c\u5904\u7406\u5b83\u4eec\uff0c\u4ece\u800c\u53ef\u80fd\u52a0\u5feb\u6f14\u793a\u901f\u5ea6\u3002\u4ee5\u4e0b\u662f Gradio \u4ee3\u7801\u7684\u793a\u4f8b\uff08\u8bf7\u6ce8\u610f `batch=True` \u548c `max_batch_size=16` - \u8fd9\u4e24\u4e2a\u53c2\u6570\u90fd\u53ef\u4ee5\u4f20\u9012\u7ed9\u4e8b\u4ef6\u89e6\u53d1\u5668\u6216 `Interface` \u7c7b\uff09\n\nwith `Interface`\uff1a\n\n```python\ndemo = gr.Interface(trim_words, [\"textbox\", \"number\"], [\"output\"],\n                    batch=True, max_batch_size=16)\ndemo.queue()\ndemo.launch()\n```\n\nwith `Blocks`\uff1a\n\n```python\nimport gradio as gr\n\nwith gr.Blocks() as demo:\n    with gr.Row():\n        word = gr.Textbox(label=\"word\")\n        leng = gr.Number(label=\"leng\")\n        output = gr.Textbox(label=\"Output\")\n    with gr.Row():\n        run = gr.Button()\n\n    event = run.click(trim_words, [word, leng], output, batch=True, max_batch_size=16)\n\ndemo.queue()\ndemo.launch()\n```\n\n\u5728\u4e0a\u9762\u7684\u793a\u4f8b\u4e2d\uff0c\u53ef\u4ee5\u5e76\u884c\u5904\u7406 16 \u4e2a\u8bf7\u6c42\uff08\u603b\u63a8\u7406\u65f6\u95f4\u4e3a 5 \u79d2\uff09\uff0c\u800c\u4e0d\u662f\u5206\u522b\u5904\u7406\u6bcf\u4e2a\u8bf7\u6c42\uff08\u603b\u63a8\u7406\u65f6\u95f4\u4e3a 80 \u79d2\uff09\u3002\u8bb8\u591a Hugging Face \u7684 `transformers` \u548c `diffusers` \u6a21\u578b\u5728 Gradio \u7684\u6279\u5904\u7406\u6a21\u5f0f\u4e0b\u81ea\u7136\u5de5\u4f5c\uff1a\u8fd9\u662f[\u4f7f\u7528\u6279\u5904\u7406\u751f\u6210\u56fe\u50cf\u7684\u793a\u4f8b\u6f14\u793a](https://github.com/gradio-app/gradio/blob/main/demo/diffusers_with_batching/run.py)\n\n\u6ce8\u610f\uff1a\u4f7f\u7528 Gradio \u7684\u6279\u5904\u7406\u51fd\u6570 **requires** \u5728\u5e95\u5c42 Interface \u6216 Blocks \u4e2d\u542f\u7528\u961f\u5217\uff08\u8bf7\u53c2\u9605\u4e0a\u9762\u7684\u961f\u5217\u90e8\u5206\uff09\u3002\n\n## Gradio \u7b14\u8bb0\u672c (Colab Notebooks)\n\nGradio \u53ef\u4ee5\u5728\u4efb\u4f55\u8fd0\u884c Python \u7684\u5730\u65b9\u8fd0\u884c\uff0c\u5305\u62ec\u672c\u5730 Jupyter \u7b14\u8bb0\u672c\u548c\u534f\u4f5c\u7b14\u8bb0\u672c\uff0c\u5982[Google Colab](https://colab.research.google.com/)\u3002\u5bf9\u4e8e\u672c\u5730 Jupyter \u7b14\u8bb0\u672c\u548c Google Colab \u7b14\u8bb0\u672c\uff0cGradio \u5728\u672c\u5730\u670d\u52a1\u5668\u4e0a\u8fd0\u884c\uff0c\u60a8\u53ef\u4ee5\u5728\u6d4f\u89c8\u5668\u4e2d\u4e0e\u4e4b\u4ea4\u4e92\u3002\uff08\u6ce8\u610f\uff1a\u5bf9\u4e8e Google Colab\uff0c\u8fd9\u662f\u901a\u8fc7[\u670d\u52a1\u5de5\u4f5c\u5668\u96a7\u9053](https://github.com/tensorflow/tensorboard/blob/master/docs/design/colab_integration.md)\u5b9e\u73b0\u7684\uff0c\u60a8\u7684\u6d4f\u89c8\u5668\u9700\u8981\u542f\u7528 cookies\u3002\uff09\u5bf9\u4e8e\u5176\u4ed6\u8fdc\u7a0b\u7b14\u8bb0\u672c\uff0cGradio \u4e5f\u5c06\u5728\u670d\u52a1\u5668\u4e0a\u8fd0\u884c\uff0c\u4f46\u60a8\u9700\u8981\u4f7f\u7528[SSH \u96a7\u9053](https://coderwall.com/p/ohk6cg/remote-access-to-ipython-notebooks-via-ssh)\u5728\u672c\u5730\u6d4f\u89c8\u5668\u4e2d\u67e5\u770b\u5e94\u7528\u7a0b\u5e8f\u3002\u901a\u5e38\uff0c\u66f4\u7b80\u5355\u7684\u9009\u62e9\u662f\u4f7f\u7528 Gradio \u5185\u7f6e\u7684\u516c\u5171\u94fe\u63a5\uff0c[\u5728\u4e0b\u4e00\u7bc7\u6307\u5357\u4e2d\u8ba8\u8bba](/sharing-your-app/#sharing-demos)\u3002\n2,\tGit over SSH\n\nYou can access and write data in repositories on huggingface.co using SSH (Secure Shell Protocol). When you connect via SSH, you authenticate using a private key file on your local machine.\n\nSome actions, such as pushing changes, or cloning private repositories, will require you to upload your SSH public key to your account on huggingface.co.\n\nYou can use a pre-existing SSH key, or generate a new one specifically for huggingface.co.\n\n## Checking for existing SSH keys\n\nIf you have an existing SSH key, you can use that key to authenticate Git operations over SSH.\n\nSSH keys are usually located under `~/.ssh` on Mac & Linux, and under `C:\\\\Users\\\\<username>\\\\.ssh` on Windows. List files under that directory and look for files of the form:\n\n- id_rsa.pub\n- id_ecdsa.pub\n- id_ed25519.pub\n\nThose files contain your SSH public key.\n\nIf you don't have such file under `~/.ssh`, you will have to [generate a new key](#generating-a-new-ssh-keypair). Otherwise, you can [add your existing SSH public key(s) to your huggingface.co account](#add-a-ssh-key-to-your-account).\n\n## Generating a new SSH keypair\n\nIf you don't have any SSH keys on your machine, you can use `ssh-keygen` to generate a new SSH key pair (public + private keys):\n\n```\n$ ssh-keygen -t ed25519 -C \"your.email@example.co\"\n```\n\nWe recommend entering a passphrase when you are prompted to. A passphrase is an extra layer of security: it is a password that will be prompted whenever you use your SSH key.\n\nOnce your new key is generated, add it to your SSH agent with `ssh-add`:\n\n```\n$ ssh-add ~/.ssh/id_ed25519\n```\n\nIf you chose a different location than the default to store your SSH key, you would have to replace `~/.ssh/id_ed25519` with the file location you used.\n\n## Add a SSH key to your account\n\nTo access private repositories with SSH, or to push changes via SSH, you will need to add your SSH public key to your huggingface.co account. You can manage your SSH keys [in your user settings](https://huggingface.co/settings/keys).\n\nTo add a SSH key to your account, click on the \"Add SSH key\" button.\n\nThen, enter a name for this key (for example, \"Personal computer\"), and copy and paste the content of your **public** SSH key in the area below. The public key is located in the `~/.ssh/id_XXXX.pub` file you found or generated in the previous steps.\n\nClick on \"Add key\", and voil\u00e0! You have added a SSH key to your huggingface.co account.\n\n\n## Testing your SSH authentication\n\nOnce you have added your SSH key to your huggingface.co account, you can test that the connection works as expected.\n\nIn a terminal, run:\n```\n$ ssh -T git@hf.co\n```\n\nIf you see a message with your username, congrats! Everything went well, you are ready to use git over SSH.\n\nOtherwise, if the message states something like the following, make sure your SSH key is actually used by your SSH agent.\n```\nHi anonymous, welcome to Hugging Face.\n```\n    ```",
            "vector_context": "[Created at: 2025-03-24 13:18:47]\nGit over SSH\n\nYou can access and write data in repositories on huggingface.co using SSH (Secure Shell Protocol). When you connect via SSH, you authenticate using a private key file on your local machine.\n\nSome actions, such as pushing changes, or cloning private repositories, will require you to upload your SSH public key to your account on huggingface.co.\n\nYou can use a pre-existing SSH key, or generate a new one specifically for huggingface.co.\n\n## Checking for existing SSH keys\n\nIf you have an existing SSH key, you can use that key to authenticate Git operations over SSH.\n\nSSH keys are usually located under `~/.ssh` on Mac & Linux, and under `C:\\\\Users\\\\<username>\\\\.ssh` on Windows. List files under that directory and look for files of the form:\n\n- id_rsa.pub\n- id_ecdsa.pub\n- id_ed25519.pub\n\nThose files contain your SSH public key.\n\nIf you don't have such file under `~/.ssh`, you will have to [generate a new key](#generating-a-new-ssh-keypair). Otherwise, you can [add your existing SSH public key(s) to your huggingface.co account](#add-a-ssh-key-to-your-account).\n\n## Generating a new SSH keypair\n\nIf you don't have any SSH keys on your machine, you can use `ssh-keygen` to generate a new SSH key pair (public + private keys):\n\n```\n$ ssh-keygen -t ed25519 -C \"your.email@example.co\"\n```\n\nWe recommend entering a passphrase when you are prompted to. A passphrase is an extra layer of security: it is a password that will be prompted whenever you use your SSH key.\n\nOnce your new key is generated, add it to your SSH agent with `ssh-add`:\n\n```\n$ ssh-add ~/.ssh/id_ed25519\n```\n\nIf you chose a different location than the default to store your SSH key, you would have to replace `~/.ssh/id_ed25519` with the file location you used.\n\n## Add a SSH key to your account\n\nTo access private repositories with SSH, or to push changes via SSH, you will need to add your SSH public key to your huggingface.co account. You can manage your SSH keys [in your user settings](https://huggingface.co/settings/keys).\n\nTo add a SSH key to your account, click on the \"Add SSH key\" button.\n\nThen, enter a name for this key (for example, \"Personal computer\"), and copy and paste the content of your **public** SSH key in the area below. The public key is located in the `~/.ssh/id_XXXX.pub` file you found or generated in the previous steps.\n\nClick on \"Add key\", and voil\u00e0! You have added a SSH key to your huggingface.co account.\n\n\n## Testing your SSH authentication\n\nOnce you have added your SSH key to your huggingface.co account, you can test that the connection works as expected.\n\nIn a terminal, run:\n```\n$ ssh -T git@hf.co\n```\n\nIf you see a message with your username, congrats! Everything went well, you are ready to use git over SSH.\n\nOtherwise, if the message states something like the following, make sure your SSH key is actually used by your SSH agent.\n```\nHi anonymous, welcome to Hugging Face.\n```\n--New Chunk--\n[Created at: 2025-03-24 13:15:42]\nCreate an Endpoint\n\nAfter your first login, you will be directed to the [Endpoint creation page](https://ui.endpoints.huggingface.co/new). As an example, this guide will go through the steps to deploy [distilbert-base-uncased-finetuned-sst-2-english](https://huggingface.co/distilbert-base-uncased-finetuned-sst-2-english) for text classification. \n\n## 1. Enter the Hugging Face Repository ID and your desired endpoint name:\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_repository.png\" alt=\"select repository\" />\n\n## 2. Select your Cloud Provider and region. Initially, only AWS will be available as a Cloud Provider with the `us-east-1` and `eu-west-1` regions. We will add Azure soon, and if you need to test Endpoints with other Cloud Providers or regions, please let us know.\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_region.png\" alt=\"select region\" />\n\n## 3. Define the [Security Level](security) for the Endpoint:\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_security.png\" alt=\"define security\" />\n\n## 4. Create your Endpoint by clicking **Create Endpoint**. By default, your Endpoint is created with a medium CPU (2 x 4GB vCPUs with Intel Xeon Ice Lake) The cost estimate assumes the Endpoint will be up for an entire month, and does not take autoscaling into account.\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_create_cost.png\" alt=\"create endpoint\" />\n\n## 5. Wait for the Endpoint to build, initialize and run which can take between 1 to 5 minutes.\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/overview.png\" alt=\"overview\" />\n\n## 6. Test your Endpoint in the overview with the Inference widget \ud83c\udfc1 \ud83c\udf89!\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_inference.png\" alt=\"run inference\" />\n--New Chunk--\n[Created at: 2025-03-24 13:17:32]\n!--Copyright 2023 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\nthe License. You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under the License is distributed on\nan \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n\n\u26a0\ufe0f Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be\nrendered properly in your Markdown viewer.\n\n-->\n\n# Training on TPU with TensorFlow\n\n<Tip>\n\nIf you don't need long explanations and just want TPU code samples to get started with, check out [our TPU example notebook!](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb)\n\n</Tip>\n\n### What is a TPU?\n\nA TPU is a **Tensor Processing Unit.** They are hardware designed by Google, which are used to greatly speed up the tensor computations within neural networks, much like GPUs. They can be used for both network training and inference. They are generally accessed through Google\u2019s cloud services, but small TPUs can also be accessed directly for free through Google Colab and Kaggle Kernels.\n\nBecause [all TensorFlow models in \ud83e\udd17 Transformers are Keras models](https://huggingface.co/blog/tensorflow-philosophy), most of the methods in this document are generally applicable to TPU training for any Keras model! However, there are a few points that are specific to the HuggingFace ecosystem (hug-o-system?) of Transformers and Datasets, and we\u2019ll make sure to flag them up when we get to them.\n\n### What kinds of TPU are available?\n\nNew users are often very confused by the range of TPUs, and the different ways to access them. The first key distinction to understand is the difference between **TPU Nodes** and **TPU VMs.**\n\nWhen you use a **TPU Node**, you are effectively indirectly accessing a remote TPU. You will need a separate VM, which will initialize your network and data pipeline and then forward them to the remote node. When you use a TPU on Google Colab, you are accessing it in the **TPU Node** style.\n\nUsing TPU Nodes can have some quite unexpected behaviour for people who aren\u2019t used to them! In particular, because the TPU is located on a physically different system to the machine you\u2019re running your Python code on, your data cannot be local to your machine - any data pipeline that loads from your machine\u2019s internal storage will totally fail! Instead, data must be stored in Google Cloud Storage where your data pipeline can still access it, even when the pipeline is running on the remote TPU node.\n\n<Tip>\n\nIf you can fit all your data in memory as `np.ndarray` or `tf.Tensor`, then you can `fit()` on that data even when using Colab or a TPU Node, without needing to upload it to Google Cloud Storage.\n\n</Tip>\n\n<Tip>\n\n**\ud83e\udd17Specific Hugging Face Tip\ud83e\udd17:** The methods `Dataset.to_tf_dataset()` and its higher-level wrapper `model.prepare_tf_dataset()` , which you will see throughout our TF code examples, will both fail on a TPU Node. The reason for this is that even though they create a `tf.data.Dataset` it is not a \u201cpure\u201d `tf.data` pipeline and uses `tf.numpy_function` or `Dataset.from_generator()` to stream data from the underlying HuggingFace `Dataset`. This HuggingFace `Dataset` is backed by data that is on a local disc and which the remote TPU Node will not be able to read.\n\n</Tip>\n\nThe second way to access a TPU is via a **TPU VM.** When using a TPU VM, you connect directly to the machine that the TPU is attached to, much like training on a GPU VM. TPU VMs are generally easier to work with, particularly when it comes to your data pipeline. All of the above warnings do not apply to TPU VMs!\n\nThis is an opinionated document, so here\u2019s our opinion: **Avoid using TPU Node if possible.** It is more confusing and more difficult to debug than TPU VMs. It is also likely to be unsupported in future - Google\u2019s latest TPU, TPUv4, can only be accessed as a TPU VM, which suggests that TPU Nodes are increasingly going to become a \u201clegacy\u201d access method. However, we understand that the only free TPU access is on Colab and Kaggle Kernels, which uses TPU Node - so we\u2019ll try to explain how to handle it if you have to! Check the [TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) for code samples that explain this in more detail.\n\n### What sizes of TPU are available?\n\nA single TPU (a v2-8/v3-8/v4-8) runs 8 replicas. TPUs exist in **pods** that can run hundreds or thousands of replicas simultaneously. When you use more than a single TPU but less than a whole pod (for example, a v3-32), your TPU fleet is referred to as a **pod slice.**\n\nWhen you access a free TPU via Colab, you generally get a single v2-8 TPU.\n\n### I keep hearing about this XLA thing. What\u2019s XLA, and how does it relate to TPUs?\n\nXLA is an optimizing compiler, used by both TensorFlow and JAX. In JAX it is the only compiler, whereas in TensorFlow it is optional"
        }
    },
    {
        "sample_idx": 96,
        "question": "What command should you run in a terminal to test SSH authentication?",
        "answer": "You should run $ ssh -T git@hf.co.",
        "rag_answer": "According to the provided information, to test SSH authentication, you should run the following command in a terminal:\n```\n$ ssh -T git@hf.co\n```\nIf you see a message with your username, it means everything went well, and you are ready to use Git over SSH. Otherwise, make sure your SSH key is actually used by your SSH agent.\n\nReferences:\n[DC] Git over SSH",
        "rag_score": 5,
        "rag_feedback": "The system's response is completely correct, accurate, and factual. It provides a detailed explanation of how to test SSH authentication, including the command to run in a terminal, and what to expect as a result. The response is well-structured and easy to follow.",
        "rag_context": {
            "kg_context": "-----Entities-----\n    ```csv\n    id,\tentity,\ttype,\tdescription,\trankcreated_at\n1,\tGradio,organization,Gradio is a platform that supports state in Blocks, providing features such as global state and session state.<SEP>Gradio is an interface that provides various features for demonstrating models, including adding example inputs, custom error messages, descriptive content, flagging, and more.<SEP>Gradio is an organization that provides a platform for building and deploying machine learning models.<SEP>Gradio is an organization that provides a platform for creating and deploying machine learning models.<SEP>Gradio is an organization that provides a demo for blocks_random_slider, and its library is used to create interactive interfaces.,36,2025-03-24 13:19:17\n2,\tSSH,category,Gradio can be run on remote servers using SSH.<SEP>SSH is a secure protocol used for authentication and data transfer.,6,2025-03-24 13:19:17\n3,\tLinux,geo,Linux is a type of operating system.,1,2025-03-24 13:19:17\n4,\tMac,geo,Mac is a type of operating system.,1,2025-03-24 13:19:17\n5,\tprivate key,category,Private key is a secure key used for SSH authentication.,1,UNKNOWN\n6,\tpublic key,category,Public key is a secure key used for SSH authentication.,1,UNKNOWN\n7,\t SSH,category,SSH is a protocol for secure remote access to computers.,0,UNKNOWN\n    ```\n    -----Relationships-----\n    ```csv\n    id,\tsource,\ttarget,\tdescription,\tkeywords,\tweight,\trank,\tcreated_at\n1,\tGradio,SSH,Gradio can be run on remote servers using SSH.,remote access, security,7.0,42,2025-03-24 13:17:31\n2,\tLinux,SSH,Linux is a platform that uses SSH for authentication.,platform, authentication,12.0,7,2025-03-24 13:19:17\n3,\tMac,SSH,Mac is a platform that uses SSH for authentication.,platform, authentication,12.0,7,2025-03-24 13:19:17\n4,\tprivate key,public key,Private key is used to generate a public key for SSH authentication.,key generation, authentication,8.0,2,UNKNOWN\n    ```\n    -----Sources-----\n    ```csv\n    id,\tcontent\n1,\t\u4e0e\u5e38\u89c4\u51fd\u6570\u76f8\u540c\u7684\u65b9\u5f0f\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio\u3002\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\uff08\u865a\u62df\u7684\uff09\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5b83\u5728\u8f93\u51fa\u56fe\u50cf\u4e4b\u524d\u751f\u6210\u6570\u4e2a\u6b65\u9aa4\u7684\u566a\u97f3\uff1a\n\n$code_fake_diffusion\n$demo_fake_diffusion\n\n\u8bf7\u6ce8\u610f\uff0c\u6211\u4eec\u5728\u8fed\u4ee3\u5668\u4e2d\u6dfb\u52a0\u4e86 `time.sleep(1)`\uff0c\u4ee5\u521b\u5efa\u6b65\u9aa4\u4e4b\u95f4\u7684\u4eba\u5de5\u6682\u505c\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u89c2\u5bdf\u8fed\u4ee3\u5668\u7684\u6b65\u9aa4\uff08\u5728\u771f\u5b9e\u7684\u56fe\u50cf\u751f\u6210\u6a21\u578b\u4e2d\uff0c\u8fd9\u53ef\u80fd\u662f\u4e0d\u5fc5\u8981\u7684\uff09\u3002\n\n\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio **\u9700\u8981**\u5728\u5e95\u5c42 Interface \u6216 Blocks \u4e2d\u542f\u7528\u961f\u5217\uff08\u8bf7\u53c2\u9605\u4e0a\u9762\u7684\u961f\u5217\u90e8\u5206\uff09\u3002\n\n## \u8fdb\u5ea6\u6761\n\nGradio \u652f\u6301\u521b\u5efa\u81ea\u5b9a\u4e49\u8fdb\u5ea6\u6761\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u81ea\u5b9a\u4e49\u548c\u63a7\u5236\u5411\u7528\u6237\u663e\u793a\u7684\u8fdb\u5ea6\u66f4\u65b0\u3002\u8981\u542f\u7528\u6b64\u529f\u80fd\uff0c\u53ea\u9700\u4e3a\u65b9\u6cd5\u6dfb\u52a0\u4e00\u4e2a\u9ed8\u8ba4\u503c\u4e3a `gr.Progress` \u5b9e\u4f8b\u7684\u53c2\u6570\u5373\u53ef\u3002\u7136\u540e\uff0c\u60a8\u53ef\u4ee5\u76f4\u63a5\u8c03\u7528\u6b64\u5b9e\u4f8b\u5e76\u4f20\u5165 0 \u5230 1 \u4e4b\u95f4\u7684\u6d6e\u70b9\u6570\u6765\u66f4\u65b0\u8fdb\u5ea6\u7ea7\u522b\uff0c\u6216\u8005 with `Progress` \u5b9e\u4f8b\u7684 `tqdm()` \u65b9\u6cd5\u6765\u8ddf\u8e2a\u53ef\u8fed\u4ee3\u5bf9\u8c61\u4e0a\u7684\u8fdb\u5ea6\uff0c\u5982\u4e0b\u6240\u793a\u3002\u5fc5\u987b\u542f\u7528\u961f\u5217\u4ee5\u8fdb\u884c\u8fdb\u5ea6\u66f4\u65b0\u3002\n\n$code_progress_simple\n$demo_progress_simple\n\n\u5982\u679c\u60a8 with `tqdm` \u5e93\uff0c\u5e76\u4e14\u5e0c\u671b\u4ece\u51fd\u6570\u5185\u90e8\u7684\u4efb\u4f55 `tqdm.tqdm` \u81ea\u52a8\u62a5\u544a\u8fdb\u5ea6\u66f4\u65b0\uff0c\u8bf7\u5c06\u9ed8\u8ba4\u53c2\u6570\u8bbe\u7f6e\u4e3a `gr.Progress(track_tqdm=True)`\uff01\n\n## \u6279\u5904\u7406\u51fd\u6570 (Batch Functions)\n\nGradio \u652f\u6301\u4f20\u9012*\u6279\u5904\u7406*\u51fd\u6570\u3002\u6279\u5904\u7406\u51fd\u6570\u53ea\u662f\u63a5\u53d7\u8f93\u5165\u5217\u8868\u5e76\u8fd4\u56de\u9884\u6d4b\u5217\u8868\u7684\u51fd\u6570\u3002\n\n\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\u6279\u5904\u7406\u51fd\u6570\uff0c\u5b83\u63a5\u53d7\u4e24\u4e2a\u8f93\u5165\u5217\u8868\uff08\u4e00\u4e2a\u5355\u8bcd\u5217\u8868\u548c\u4e00\u4e2a\u6574\u6570\u5217\u8868\uff09\uff0c\u5e76\u8fd4\u56de\u4fee\u526a\u8fc7\u7684\u5355\u8bcd\u5217\u8868\u4f5c\u4e3a\u8f93\u51fa\uff1a\n\n```python\nimport time\n\ndef trim_words(words, lens):\n    trimmed_words = []\n    time.sleep(5)\n    for w, l in zip(words, lens):\n        trimmed_words.append(w[:int(l)])\n    return [trimmed_words]\n    for w, l in zip(words, lens):\n```\n\n\u4f7f\u7528\u6279\u5904\u7406\u51fd\u6570\u7684\u4f18\u70b9\u662f\uff0c\u5982\u679c\u542f\u7528\u4e86\u961f\u5217\uff0cGradio \u670d\u52a1\u5668\u53ef\u4ee5\u81ea\u52a8*\u6279\u5904\u7406*\u4f20\u5165\u7684\u8bf7\u6c42\u5e76\u5e76\u884c\u5904\u7406\u5b83\u4eec\uff0c\u4ece\u800c\u53ef\u80fd\u52a0\u5feb\u6f14\u793a\u901f\u5ea6\u3002\u4ee5\u4e0b\u662f Gradio \u4ee3\u7801\u7684\u793a\u4f8b\uff08\u8bf7\u6ce8\u610f `batch=True` \u548c `max_batch_size=16` - \u8fd9\u4e24\u4e2a\u53c2\u6570\u90fd\u53ef\u4ee5\u4f20\u9012\u7ed9\u4e8b\u4ef6\u89e6\u53d1\u5668\u6216 `Interface` \u7c7b\uff09\n\nwith `Interface`\uff1a\n\n```python\ndemo = gr.Interface(trim_words, [\"textbox\", \"number\"], [\"output\"],\n                    batch=True, max_batch_size=16)\ndemo.queue()\ndemo.launch()\n```\n\nwith `Blocks`\uff1a\n\n```python\nimport gradio as gr\n\nwith gr.Blocks() as demo:\n    with gr.Row():\n        word = gr.Textbox(label=\"word\")\n        leng = gr.Number(label=\"leng\")\n        output = gr.Textbox(label=\"Output\")\n    with gr.Row():\n        run = gr.Button()\n\n    event = run.click(trim_words, [word, leng], output, batch=True, max_batch_size=16)\n\ndemo.queue()\ndemo.launch()\n```\n\n\u5728\u4e0a\u9762\u7684\u793a\u4f8b\u4e2d\uff0c\u53ef\u4ee5\u5e76\u884c\u5904\u7406 16 \u4e2a\u8bf7\u6c42\uff08\u603b\u63a8\u7406\u65f6\u95f4\u4e3a 5 \u79d2\uff09\uff0c\u800c\u4e0d\u662f\u5206\u522b\u5904\u7406\u6bcf\u4e2a\u8bf7\u6c42\uff08\u603b\u63a8\u7406\u65f6\u95f4\u4e3a 80 \u79d2\uff09\u3002\u8bb8\u591a Hugging Face \u7684 `transformers` \u548c `diffusers` \u6a21\u578b\u5728 Gradio \u7684\u6279\u5904\u7406\u6a21\u5f0f\u4e0b\u81ea\u7136\u5de5\u4f5c\uff1a\u8fd9\u662f[\u4f7f\u7528\u6279\u5904\u7406\u751f\u6210\u56fe\u50cf\u7684\u793a\u4f8b\u6f14\u793a](https://github.com/gradio-app/gradio/blob/main/demo/diffusers_with_batching/run.py)\n\n\u6ce8\u610f\uff1a\u4f7f\u7528 Gradio \u7684\u6279\u5904\u7406\u51fd\u6570 **requires** \u5728\u5e95\u5c42 Interface \u6216 Blocks \u4e2d\u542f\u7528\u961f\u5217\uff08\u8bf7\u53c2\u9605\u4e0a\u9762\u7684\u961f\u5217\u90e8\u5206\uff09\u3002\n\n## Gradio \u7b14\u8bb0\u672c (Colab Notebooks)\n\nGradio \u53ef\u4ee5\u5728\u4efb\u4f55\u8fd0\u884c Python \u7684\u5730\u65b9\u8fd0\u884c\uff0c\u5305\u62ec\u672c\u5730 Jupyter \u7b14\u8bb0\u672c\u548c\u534f\u4f5c\u7b14\u8bb0\u672c\uff0c\u5982[Google Colab](https://colab.research.google.com/)\u3002\u5bf9\u4e8e\u672c\u5730 Jupyter \u7b14\u8bb0\u672c\u548c Google Colab \u7b14\u8bb0\u672c\uff0cGradio \u5728\u672c\u5730\u670d\u52a1\u5668\u4e0a\u8fd0\u884c\uff0c\u60a8\u53ef\u4ee5\u5728\u6d4f\u89c8\u5668\u4e2d\u4e0e\u4e4b\u4ea4\u4e92\u3002\uff08\u6ce8\u610f\uff1a\u5bf9\u4e8e Google Colab\uff0c\u8fd9\u662f\u901a\u8fc7[\u670d\u52a1\u5de5\u4f5c\u5668\u96a7\u9053](https://github.com/tensorflow/tensorboard/blob/master/docs/design/colab_integration.md)\u5b9e\u73b0\u7684\uff0c\u60a8\u7684\u6d4f\u89c8\u5668\u9700\u8981\u542f\u7528 cookies\u3002\uff09\u5bf9\u4e8e\u5176\u4ed6\u8fdc\u7a0b\u7b14\u8bb0\u672c\uff0cGradio \u4e5f\u5c06\u5728\u670d\u52a1\u5668\u4e0a\u8fd0\u884c\uff0c\u4f46\u60a8\u9700\u8981\u4f7f\u7528[SSH \u96a7\u9053](https://coderwall.com/p/ohk6cg/remote-access-to-ipython-notebooks-via-ssh)\u5728\u672c\u5730\u6d4f\u89c8\u5668\u4e2d\u67e5\u770b\u5e94\u7528\u7a0b\u5e8f\u3002\u901a\u5e38\uff0c\u66f4\u7b80\u5355\u7684\u9009\u62e9\u662f\u4f7f\u7528 Gradio \u5185\u7f6e\u7684\u516c\u5171\u94fe\u63a5\uff0c[\u5728\u4e0b\u4e00\u7bc7\u6307\u5357\u4e2d\u8ba8\u8bba](/sharing-your-app/#sharing-demos)\u3002\n2,\tGit over SSH\n\nYou can access and write data in repositories on huggingface.co using SSH (Secure Shell Protocol). When you connect via SSH, you authenticate using a private key file on your local machine.\n\nSome actions, such as pushing changes, or cloning private repositories, will require you to upload your SSH public key to your account on huggingface.co.\n\nYou can use a pre-existing SSH key, or generate a new one specifically for huggingface.co.\n\n## Checking for existing SSH keys\n\nIf you have an existing SSH key, you can use that key to authenticate Git operations over SSH.\n\nSSH keys are usually located under `~/.ssh` on Mac & Linux, and under `C:\\\\Users\\\\<username>\\\\.ssh` on Windows. List files under that directory and look for files of the form:\n\n- id_rsa.pub\n- id_ecdsa.pub\n- id_ed25519.pub\n\nThose files contain your SSH public key.\n\nIf you don't have such file under `~/.ssh`, you will have to [generate a new key](#generating-a-new-ssh-keypair). Otherwise, you can [add your existing SSH public key(s) to your huggingface.co account](#add-a-ssh-key-to-your-account).\n\n## Generating a new SSH keypair\n\nIf you don't have any SSH keys on your machine, you can use `ssh-keygen` to generate a new SSH key pair (public + private keys):\n\n```\n$ ssh-keygen -t ed25519 -C \"your.email@example.co\"\n```\n\nWe recommend entering a passphrase when you are prompted to. A passphrase is an extra layer of security: it is a password that will be prompted whenever you use your SSH key.\n\nOnce your new key is generated, add it to your SSH agent with `ssh-add`:\n\n```\n$ ssh-add ~/.ssh/id_ed25519\n```\n\nIf you chose a different location than the default to store your SSH key, you would have to replace `~/.ssh/id_ed25519` with the file location you used.\n\n## Add a SSH key to your account\n\nTo access private repositories with SSH, or to push changes via SSH, you will need to add your SSH public key to your huggingface.co account. You can manage your SSH keys [in your user settings](https://huggingface.co/settings/keys).\n\nTo add a SSH key to your account, click on the \"Add SSH key\" button.\n\nThen, enter a name for this key (for example, \"Personal computer\"), and copy and paste the content of your **public** SSH key in the area below. The public key is located in the `~/.ssh/id_XXXX.pub` file you found or generated in the previous steps.\n\nClick on \"Add key\", and voil\u00e0! You have added a SSH key to your huggingface.co account.\n\n\n## Testing your SSH authentication\n\nOnce you have added your SSH key to your huggingface.co account, you can test that the connection works as expected.\n\nIn a terminal, run:\n```\n$ ssh -T git@hf.co\n```\n\nIf you see a message with your username, congrats! Everything went well, you are ready to use git over SSH.\n\nOtherwise, if the message states something like the following, make sure your SSH key is actually used by your SSH agent.\n```\nHi anonymous, welcome to Hugging Face.\n```\n    ```",
            "vector_context": "[Created at: 2025-03-24 13:18:47]\nGit over SSH\n\nYou can access and write data in repositories on huggingface.co using SSH (Secure Shell Protocol). When you connect via SSH, you authenticate using a private key file on your local machine.\n\nSome actions, such as pushing changes, or cloning private repositories, will require you to upload your SSH public key to your account on huggingface.co.\n\nYou can use a pre-existing SSH key, or generate a new one specifically for huggingface.co.\n\n## Checking for existing SSH keys\n\nIf you have an existing SSH key, you can use that key to authenticate Git operations over SSH.\n\nSSH keys are usually located under `~/.ssh` on Mac & Linux, and under `C:\\\\Users\\\\<username>\\\\.ssh` on Windows. List files under that directory and look for files of the form:\n\n- id_rsa.pub\n- id_ecdsa.pub\n- id_ed25519.pub\n\nThose files contain your SSH public key.\n\nIf you don't have such file under `~/.ssh`, you will have to [generate a new key](#generating-a-new-ssh-keypair). Otherwise, you can [add your existing SSH public key(s) to your huggingface.co account](#add-a-ssh-key-to-your-account).\n\n## Generating a new SSH keypair\n\nIf you don't have any SSH keys on your machine, you can use `ssh-keygen` to generate a new SSH key pair (public + private keys):\n\n```\n$ ssh-keygen -t ed25519 -C \"your.email@example.co\"\n```\n\nWe recommend entering a passphrase when you are prompted to. A passphrase is an extra layer of security: it is a password that will be prompted whenever you use your SSH key.\n\nOnce your new key is generated, add it to your SSH agent with `ssh-add`:\n\n```\n$ ssh-add ~/.ssh/id_ed25519\n```\n\nIf you chose a different location than the default to store your SSH key, you would have to replace `~/.ssh/id_ed25519` with the file location you used.\n\n## Add a SSH key to your account\n\nTo access private repositories with SSH, or to push changes via SSH, you will need to add your SSH public key to your huggingface.co account. You can manage your SSH keys [in your user settings](https://huggingface.co/settings/keys).\n\nTo add a SSH key to your account, click on the \"Add SSH key\" button.\n\nThen, enter a name for this key (for example, \"Personal computer\"), and copy and paste the content of your **public** SSH key in the area below. The public key is located in the `~/.ssh/id_XXXX.pub` file you found or generated in the previous steps.\n\nClick on \"Add key\", and voil\u00e0! You have added a SSH key to your huggingface.co account.\n\n\n## Testing your SSH authentication\n\nOnce you have added your SSH key to your huggingface.co account, you can test that the connection works as expected.\n\nIn a terminal, run:\n```\n$ ssh -T git@hf.co\n```\n\nIf you see a message with your username, congrats! Everything went well, you are ready to use git over SSH.\n\nOtherwise, if the message states something like the following, make sure your SSH key is actually used by your SSH agent.\n```\nHi anonymous, welcome to Hugging Face.\n```\n--New Chunk--\n[Created at: 2025-03-24 13:15:42]\nCreate an Endpoint\n\nAfter your first login, you will be directed to the [Endpoint creation page](https://ui.endpoints.huggingface.co/new). As an example, this guide will go through the steps to deploy [distilbert-base-uncased-finetuned-sst-2-english](https://huggingface.co/distilbert-base-uncased-finetuned-sst-2-english) for text classification. \n\n## 1. Enter the Hugging Face Repository ID and your desired endpoint name:\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_repository.png\" alt=\"select repository\" />\n\n## 2. Select your Cloud Provider and region. Initially, only AWS will be available as a Cloud Provider with the `us-east-1` and `eu-west-1` regions. We will add Azure soon, and if you need to test Endpoints with other Cloud Providers or regions, please let us know.\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_region.png\" alt=\"select region\" />\n\n## 3. Define the [Security Level](security) for the Endpoint:\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_security.png\" alt=\"define security\" />\n\n## 4. Create your Endpoint by clicking **Create Endpoint**. By default, your Endpoint is created with a medium CPU (2 x 4GB vCPUs with Intel Xeon Ice Lake) The cost estimate assumes the Endpoint will be up for an entire month, and does not take autoscaling into account.\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_create_cost.png\" alt=\"create endpoint\" />\n\n## 5. Wait for the Endpoint to build, initialize and run which can take between 1 to 5 minutes.\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/overview.png\" alt=\"overview\" />\n\n## 6. Test your Endpoint in the overview with the Inference widget \ud83c\udfc1 \ud83c\udf89!\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_inference.png\" alt=\"run inference\" />\n--New Chunk--\n[Created at: 2025-03-24 13:19:17]\n!---\nCopyright 2022 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n-->\n\n# Token classification with LayoutLMv3 (PyTorch version)\n\nThis directory contains a script, `run_funsd_cord.py`, that can be used to fine-tune (or evaluate) LayoutLMv3 on form understanding datasets, such as [FUNSD](https://guillaumejaume.github.io/FUNSD/) and [CORD](https://github.com/clovaai/cord).\n\nThe script `run_funsd_cord.py` leverages the \ud83e\udd17 Datasets library and the Trainer API. You can easily customize it to your needs.\n\n## Fine-tuning on FUNSD\n\nFine-tuning LayoutLMv3 for token classification on [FUNSD](https://guillaumejaume.github.io/FUNSD/) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name funsd \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 1e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-funsd\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd. By specifying the `push_to_hub` flag, the model gets uploaded automatically to the hub (regularly), together with a model card, which includes metrics such as precision, recall and F1. Note that you can easily update the model card, as it's just a README file of the respective repo on the hub.\n\nThere's also the \"Training metrics\" [tab](https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd/tensorboard), which shows Tensorboard logs over the course of training. Pretty neat, huh?\n\n## Fine-tuning on CORD\n\nFine-tuning LayoutLMv3 for token classification on [CORD](https://github.com/clovaai/cord) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name cord \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 5e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-cord\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-cord. Note that a model card gets generated automatically in case you specify the `push_to_hub` flag."
        }
    },
    {
        "sample_idx": 97,
        "question": "What does it mean if you see a message with your username after running the SSH authentication test?",
        "answer": "It means everything went well, you are ready to use git over SSH.",
        "rag_answer": "According to the provided data sources, if you see a message with your username after running the SSH authentication test, it means that everything went well, and you are ready to use Git over SSH.",
        "rag_score": 5,
        "rag_feedback": "The system's response is completely correct, accurate, and factual. It directly answers the question by stating that if you see a message with your username after running the SSH authentication test, it means everything went well, and you are ready to use Git over SSH.",
        "rag_context": {
            "kg_context": "-----Entities-----\n    ```csv\n    id,\tentity,\ttype,\tdescription,\trankcreated_at\n1,\tLinux,geo,Linux is a type of operating system.,1,2025-03-24 13:19:17\n2,\tSSH,category,Gradio can be run on remote servers using SSH.<SEP>SSH is a secure protocol used for authentication and data transfer.,6,2025-03-24 13:19:17\n3,\tMac,geo,Mac is a type of operating system.,1,2025-03-24 13:19:17\n4,\tWindows,geo,Windows is a type of operating system.,1,2025-03-24 13:19:17\n5,\t SSH,category,SSH is a protocol for secure remote access to computers.,0,UNKNOWN\n6,\tpublic key,category,Public key is a secure key used for SSH authentication.,1,UNKNOWN\n7,\tprivate key,category,Private key is a secure key used for SSH authentication.,1,UNKNOWN\n    ```\n    -----Relationships-----\n    ```csv\n    id,\tsource,\ttarget,\tdescription,\tkeywords,\tweight,\trank,\tcreated_at\n1,\tLinux,SSH,Linux is a platform that uses SSH for authentication.,platform, authentication,12.0,7,2025-03-24 13:19:17\n2,\tMac,SSH,Mac is a platform that uses SSH for authentication.,platform, authentication,12.0,7,2025-03-24 13:19:17\n3,\tSSH,Windows,Windows is a platform that uses SSH for authentication.,platform, authentication,12.0,7,2025-03-24 13:19:17\n4,\tprivate key,public key,Private key is used to generate a public key for SSH authentication.,key generation, authentication,8.0,2,UNKNOWN\n    ```\n    -----Sources-----\n    ```csv\n    id,\tcontent\n1,\tGit over SSH\n\nYou can access and write data in repositories on huggingface.co using SSH (Secure Shell Protocol). When you connect via SSH, you authenticate using a private key file on your local machine.\n\nSome actions, such as pushing changes, or cloning private repositories, will require you to upload your SSH public key to your account on huggingface.co.\n\nYou can use a pre-existing SSH key, or generate a new one specifically for huggingface.co.\n\n## Checking for existing SSH keys\n\nIf you have an existing SSH key, you can use that key to authenticate Git operations over SSH.\n\nSSH keys are usually located under `~/.ssh` on Mac & Linux, and under `C:\\\\Users\\\\<username>\\\\.ssh` on Windows. List files under that directory and look for files of the form:\n\n- id_rsa.pub\n- id_ecdsa.pub\n- id_ed25519.pub\n\nThose files contain your SSH public key.\n\nIf you don't have such file under `~/.ssh`, you will have to [generate a new key](#generating-a-new-ssh-keypair). Otherwise, you can [add your existing SSH public key(s) to your huggingface.co account](#add-a-ssh-key-to-your-account).\n\n## Generating a new SSH keypair\n\nIf you don't have any SSH keys on your machine, you can use `ssh-keygen` to generate a new SSH key pair (public + private keys):\n\n```\n$ ssh-keygen -t ed25519 -C \"your.email@example.co\"\n```\n\nWe recommend entering a passphrase when you are prompted to. A passphrase is an extra layer of security: it is a password that will be prompted whenever you use your SSH key.\n\nOnce your new key is generated, add it to your SSH agent with `ssh-add`:\n\n```\n$ ssh-add ~/.ssh/id_ed25519\n```\n\nIf you chose a different location than the default to store your SSH key, you would have to replace `~/.ssh/id_ed25519` with the file location you used.\n\n## Add a SSH key to your account\n\nTo access private repositories with SSH, or to push changes via SSH, you will need to add your SSH public key to your huggingface.co account. You can manage your SSH keys [in your user settings](https://huggingface.co/settings/keys).\n\nTo add a SSH key to your account, click on the \"Add SSH key\" button.\n\nThen, enter a name for this key (for example, \"Personal computer\"), and copy and paste the content of your **public** SSH key in the area below. The public key is located in the `~/.ssh/id_XXXX.pub` file you found or generated in the previous steps.\n\nClick on \"Add key\", and voil\u00e0! You have added a SSH key to your huggingface.co account.\n\n\n## Testing your SSH authentication\n\nOnce you have added your SSH key to your huggingface.co account, you can test that the connection works as expected.\n\nIn a terminal, run:\n```\n$ ssh -T git@hf.co\n```\n\nIf you see a message with your username, congrats! Everything went well, you are ready to use git over SSH.\n\nOtherwise, if the message states something like the following, make sure your SSH key is actually used by your SSH agent.\n```\nHi anonymous, welcome to Hugging Face.\n```\n2,\t\u4e0e\u5e38\u89c4\u51fd\u6570\u76f8\u540c\u7684\u65b9\u5f0f\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio\u3002\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\uff08\u865a\u62df\u7684\uff09\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5b83\u5728\u8f93\u51fa\u56fe\u50cf\u4e4b\u524d\u751f\u6210\u6570\u4e2a\u6b65\u9aa4\u7684\u566a\u97f3\uff1a\n\n$code_fake_diffusion\n$demo_fake_diffusion\n\n\u8bf7\u6ce8\u610f\uff0c\u6211\u4eec\u5728\u8fed\u4ee3\u5668\u4e2d\u6dfb\u52a0\u4e86 `time.sleep(1)`\uff0c\u4ee5\u521b\u5efa\u6b65\u9aa4\u4e4b\u95f4\u7684\u4eba\u5de5\u6682\u505c\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u89c2\u5bdf\u8fed\u4ee3\u5668\u7684\u6b65\u9aa4\uff08\u5728\u771f\u5b9e\u7684\u56fe\u50cf\u751f\u6210\u6a21\u578b\u4e2d\uff0c\u8fd9\u53ef\u80fd\u662f\u4e0d\u5fc5\u8981\u7684\uff09\u3002\n\n\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio **\u9700\u8981**\u5728\u5e95\u5c42 Interface \u6216 Blocks \u4e2d\u542f\u7528\u961f\u5217\uff08\u8bf7\u53c2\u9605\u4e0a\u9762\u7684\u961f\u5217\u90e8\u5206\uff09\u3002\n\n## \u8fdb\u5ea6\u6761\n\nGradio \u652f\u6301\u521b\u5efa\u81ea\u5b9a\u4e49\u8fdb\u5ea6\u6761\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u81ea\u5b9a\u4e49\u548c\u63a7\u5236\u5411\u7528\u6237\u663e\u793a\u7684\u8fdb\u5ea6\u66f4\u65b0\u3002\u8981\u542f\u7528\u6b64\u529f\u80fd\uff0c\u53ea\u9700\u4e3a\u65b9\u6cd5\u6dfb\u52a0\u4e00\u4e2a\u9ed8\u8ba4\u503c\u4e3a `gr.Progress` \u5b9e\u4f8b\u7684\u53c2\u6570\u5373\u53ef\u3002\u7136\u540e\uff0c\u60a8\u53ef\u4ee5\u76f4\u63a5\u8c03\u7528\u6b64\u5b9e\u4f8b\u5e76\u4f20\u5165 0 \u5230 1 \u4e4b\u95f4\u7684\u6d6e\u70b9\u6570\u6765\u66f4\u65b0\u8fdb\u5ea6\u7ea7\u522b\uff0c\u6216\u8005 with `Progress` \u5b9e\u4f8b\u7684 `tqdm()` \u65b9\u6cd5\u6765\u8ddf\u8e2a\u53ef\u8fed\u4ee3\u5bf9\u8c61\u4e0a\u7684\u8fdb\u5ea6\uff0c\u5982\u4e0b\u6240\u793a\u3002\u5fc5\u987b\u542f\u7528\u961f\u5217\u4ee5\u8fdb\u884c\u8fdb\u5ea6\u66f4\u65b0\u3002\n\n$code_progress_simple\n$demo_progress_simple\n\n\u5982\u679c\u60a8 with `tqdm` \u5e93\uff0c\u5e76\u4e14\u5e0c\u671b\u4ece\u51fd\u6570\u5185\u90e8\u7684\u4efb\u4f55 `tqdm.tqdm` \u81ea\u52a8\u62a5\u544a\u8fdb\u5ea6\u66f4\u65b0\uff0c\u8bf7\u5c06\u9ed8\u8ba4\u53c2\u6570\u8bbe\u7f6e\u4e3a `gr.Progress(track_tqdm=True)`\uff01\n\n## \u6279\u5904\u7406\u51fd\u6570 (Batch Functions)\n\nGradio \u652f\u6301\u4f20\u9012*\u6279\u5904\u7406*\u51fd\u6570\u3002\u6279\u5904\u7406\u51fd\u6570\u53ea\u662f\u63a5\u53d7\u8f93\u5165\u5217\u8868\u5e76\u8fd4\u56de\u9884\u6d4b\u5217\u8868\u7684\u51fd\u6570\u3002\n\n\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\u6279\u5904\u7406\u51fd\u6570\uff0c\u5b83\u63a5\u53d7\u4e24\u4e2a\u8f93\u5165\u5217\u8868\uff08\u4e00\u4e2a\u5355\u8bcd\u5217\u8868\u548c\u4e00\u4e2a\u6574\u6570\u5217\u8868\uff09\uff0c\u5e76\u8fd4\u56de\u4fee\u526a\u8fc7\u7684\u5355\u8bcd\u5217\u8868\u4f5c\u4e3a\u8f93\u51fa\uff1a\n\n```python\nimport time\n\ndef trim_words(words, lens):\n    trimmed_words = []\n    time.sleep(5)\n    for w, l in zip(words, lens):\n        trimmed_words.append(w[:int(l)])\n    return [trimmed_words]\n    for w, l in zip(words, lens):\n```\n\n\u4f7f\u7528\u6279\u5904\u7406\u51fd\u6570\u7684\u4f18\u70b9\u662f\uff0c\u5982\u679c\u542f\u7528\u4e86\u961f\u5217\uff0cGradio \u670d\u52a1\u5668\u53ef\u4ee5\u81ea\u52a8*\u6279\u5904\u7406*\u4f20\u5165\u7684\u8bf7\u6c42\u5e76\u5e76\u884c\u5904\u7406\u5b83\u4eec\uff0c\u4ece\u800c\u53ef\u80fd\u52a0\u5feb\u6f14\u793a\u901f\u5ea6\u3002\u4ee5\u4e0b\u662f Gradio \u4ee3\u7801\u7684\u793a\u4f8b\uff08\u8bf7\u6ce8\u610f `batch=True` \u548c `max_batch_size=16` - \u8fd9\u4e24\u4e2a\u53c2\u6570\u90fd\u53ef\u4ee5\u4f20\u9012\u7ed9\u4e8b\u4ef6\u89e6\u53d1\u5668\u6216 `Interface` \u7c7b\uff09\n\nwith `Interface`\uff1a\n\n```python\ndemo = gr.Interface(trim_words, [\"textbox\", \"number\"], [\"output\"],\n                    batch=True, max_batch_size=16)\ndemo.queue()\ndemo.launch()\n```\n\nwith `Blocks`\uff1a\n\n```python\nimport gradio as gr\n\nwith gr.Blocks() as demo:\n    with gr.Row():\n        word = gr.Textbox(label=\"word\")\n        leng = gr.Number(label=\"leng\")\n        output = gr.Textbox(label=\"Output\")\n    with gr.Row():\n        run = gr.Button()\n\n    event = run.click(trim_words, [word, leng], output, batch=True, max_batch_size=16)\n\ndemo.queue()\ndemo.launch()\n```\n\n\u5728\u4e0a\u9762\u7684\u793a\u4f8b\u4e2d\uff0c\u53ef\u4ee5\u5e76\u884c\u5904\u7406 16 \u4e2a\u8bf7\u6c42\uff08\u603b\u63a8\u7406\u65f6\u95f4\u4e3a 5 \u79d2\uff09\uff0c\u800c\u4e0d\u662f\u5206\u522b\u5904\u7406\u6bcf\u4e2a\u8bf7\u6c42\uff08\u603b\u63a8\u7406\u65f6\u95f4\u4e3a 80 \u79d2\uff09\u3002\u8bb8\u591a Hugging Face \u7684 `transformers` \u548c `diffusers` \u6a21\u578b\u5728 Gradio \u7684\u6279\u5904\u7406\u6a21\u5f0f\u4e0b\u81ea\u7136\u5de5\u4f5c\uff1a\u8fd9\u662f[\u4f7f\u7528\u6279\u5904\u7406\u751f\u6210\u56fe\u50cf\u7684\u793a\u4f8b\u6f14\u793a](https://github.com/gradio-app/gradio/blob/main/demo/diffusers_with_batching/run.py)\n\n\u6ce8\u610f\uff1a\u4f7f\u7528 Gradio \u7684\u6279\u5904\u7406\u51fd\u6570 **requires** \u5728\u5e95\u5c42 Interface \u6216 Blocks \u4e2d\u542f\u7528\u961f\u5217\uff08\u8bf7\u53c2\u9605\u4e0a\u9762\u7684\u961f\u5217\u90e8\u5206\uff09\u3002\n\n## Gradio \u7b14\u8bb0\u672c (Colab Notebooks)\n\nGradio \u53ef\u4ee5\u5728\u4efb\u4f55\u8fd0\u884c Python \u7684\u5730\u65b9\u8fd0\u884c\uff0c\u5305\u62ec\u672c\u5730 Jupyter \u7b14\u8bb0\u672c\u548c\u534f\u4f5c\u7b14\u8bb0\u672c\uff0c\u5982[Google Colab](https://colab.research.google.com/)\u3002\u5bf9\u4e8e\u672c\u5730 Jupyter \u7b14\u8bb0\u672c\u548c Google Colab \u7b14\u8bb0\u672c\uff0cGradio \u5728\u672c\u5730\u670d\u52a1\u5668\u4e0a\u8fd0\u884c\uff0c\u60a8\u53ef\u4ee5\u5728\u6d4f\u89c8\u5668\u4e2d\u4e0e\u4e4b\u4ea4\u4e92\u3002\uff08\u6ce8\u610f\uff1a\u5bf9\u4e8e Google Colab\uff0c\u8fd9\u662f\u901a\u8fc7[\u670d\u52a1\u5de5\u4f5c\u5668\u96a7\u9053](https://github.com/tensorflow/tensorboard/blob/master/docs/design/colab_integration.md)\u5b9e\u73b0\u7684\uff0c\u60a8\u7684\u6d4f\u89c8\u5668\u9700\u8981\u542f\u7528 cookies\u3002\uff09\u5bf9\u4e8e\u5176\u4ed6\u8fdc\u7a0b\u7b14\u8bb0\u672c\uff0cGradio \u4e5f\u5c06\u5728\u670d\u52a1\u5668\u4e0a\u8fd0\u884c\uff0c\u4f46\u60a8\u9700\u8981\u4f7f\u7528[SSH \u96a7\u9053](https://coderwall.com/p/ohk6cg/remote-access-to-ipython-notebooks-via-ssh)\u5728\u672c\u5730\u6d4f\u89c8\u5668\u4e2d\u67e5\u770b\u5e94\u7528\u7a0b\u5e8f\u3002\u901a\u5e38\uff0c\u66f4\u7b80\u5355\u7684\u9009\u62e9\u662f\u4f7f\u7528 Gradio \u5185\u7f6e\u7684\u516c\u5171\u94fe\u63a5\uff0c[\u5728\u4e0b\u4e00\u7bc7\u6307\u5357\u4e2d\u8ba8\u8bba](/sharing-your-app/#sharing-demos)\u3002\n    ```",
            "vector_context": "[Created at: 2025-03-24 13:18:47]\nGit over SSH\n\nYou can access and write data in repositories on huggingface.co using SSH (Secure Shell Protocol). When you connect via SSH, you authenticate using a private key file on your local machine.\n\nSome actions, such as pushing changes, or cloning private repositories, will require you to upload your SSH public key to your account on huggingface.co.\n\nYou can use a pre-existing SSH key, or generate a new one specifically for huggingface.co.\n\n## Checking for existing SSH keys\n\nIf you have an existing SSH key, you can use that key to authenticate Git operations over SSH.\n\nSSH keys are usually located under `~/.ssh` on Mac & Linux, and under `C:\\\\Users\\\\<username>\\\\.ssh` on Windows. List files under that directory and look for files of the form:\n\n- id_rsa.pub\n- id_ecdsa.pub\n- id_ed25519.pub\n\nThose files contain your SSH public key.\n\nIf you don't have such file under `~/.ssh`, you will have to [generate a new key](#generating-a-new-ssh-keypair). Otherwise, you can [add your existing SSH public key(s) to your huggingface.co account](#add-a-ssh-key-to-your-account).\n\n## Generating a new SSH keypair\n\nIf you don't have any SSH keys on your machine, you can use `ssh-keygen` to generate a new SSH key pair (public + private keys):\n\n```\n$ ssh-keygen -t ed25519 -C \"your.email@example.co\"\n```\n\nWe recommend entering a passphrase when you are prompted to. A passphrase is an extra layer of security: it is a password that will be prompted whenever you use your SSH key.\n\nOnce your new key is generated, add it to your SSH agent with `ssh-add`:\n\n```\n$ ssh-add ~/.ssh/id_ed25519\n```\n\nIf you chose a different location than the default to store your SSH key, you would have to replace `~/.ssh/id_ed25519` with the file location you used.\n\n## Add a SSH key to your account\n\nTo access private repositories with SSH, or to push changes via SSH, you will need to add your SSH public key to your huggingface.co account. You can manage your SSH keys [in your user settings](https://huggingface.co/settings/keys).\n\nTo add a SSH key to your account, click on the \"Add SSH key\" button.\n\nThen, enter a name for this key (for example, \"Personal computer\"), and copy and paste the content of your **public** SSH key in the area below. The public key is located in the `~/.ssh/id_XXXX.pub` file you found or generated in the previous steps.\n\nClick on \"Add key\", and voil\u00e0! You have added a SSH key to your huggingface.co account.\n\n\n## Testing your SSH authentication\n\nOnce you have added your SSH key to your huggingface.co account, you can test that the connection works as expected.\n\nIn a terminal, run:\n```\n$ ssh -T git@hf.co\n```\n\nIf you see a message with your username, congrats! Everything went well, you are ready to use git over SSH.\n\nOtherwise, if the message states something like the following, make sure your SSH key is actually used by your SSH agent.\n```\nHi anonymous, welcome to Hugging Face.\n```\n--New Chunk--\n[Created at: 2025-03-24 13:19:17]\n!---\nCopyright 2022 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n-->\n\n# Token classification with LayoutLMv3 (PyTorch version)\n\nThis directory contains a script, `run_funsd_cord.py`, that can be used to fine-tune (or evaluate) LayoutLMv3 on form understanding datasets, such as [FUNSD](https://guillaumejaume.github.io/FUNSD/) and [CORD](https://github.com/clovaai/cord).\n\nThe script `run_funsd_cord.py` leverages the \ud83e\udd17 Datasets library and the Trainer API. You can easily customize it to your needs.\n\n## Fine-tuning on FUNSD\n\nFine-tuning LayoutLMv3 for token classification on [FUNSD](https://guillaumejaume.github.io/FUNSD/) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name funsd \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 1e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-funsd\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd. By specifying the `push_to_hub` flag, the model gets uploaded automatically to the hub (regularly), together with a model card, which includes metrics such as precision, recall and F1. Note that you can easily update the model card, as it's just a README file of the respective repo on the hub.\n\nThere's also the \"Training metrics\" [tab](https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd/tensorboard), which shows Tensorboard logs over the course of training. Pretty neat, huh?\n\n## Fine-tuning on CORD\n\nFine-tuning LayoutLMv3 for token classification on [CORD](https://github.com/clovaai/cord) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name cord \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 5e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-cord\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-cord. Note that a model card gets generated automatically in case you specify the `push_to_hub` flag.\n--New Chunk--\n[Created at: 2025-03-24 13:15:42]\nCreate an Endpoint\n\nAfter your first login, you will be directed to the [Endpoint creation page](https://ui.endpoints.huggingface.co/new). As an example, this guide will go through the steps to deploy [distilbert-base-uncased-finetuned-sst-2-english](https://huggingface.co/distilbert-base-uncased-finetuned-sst-2-english) for text classification. \n\n## 1. Enter the Hugging Face Repository ID and your desired endpoint name:\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_repository.png\" alt=\"select repository\" />\n\n## 2. Select your Cloud Provider and region. Initially, only AWS will be available as a Cloud Provider with the `us-east-1` and `eu-west-1` regions. We will add Azure soon, and if you need to test Endpoints with other Cloud Providers or regions, please let us know.\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_region.png\" alt=\"select region\" />\n\n## 3. Define the [Security Level](security) for the Endpoint:\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_security.png\" alt=\"define security\" />\n\n## 4. Create your Endpoint by clicking **Create Endpoint**. By default, your Endpoint is created with a medium CPU (2 x 4GB vCPUs with Intel Xeon Ice Lake) The cost estimate assumes the Endpoint will be up for an entire month, and does not take autoscaling into account.\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_create_cost.png\" alt=\"create endpoint\" />\n\n## 5. Wait for the Endpoint to build, initialize and run which can take between 1 to 5 minutes.\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/overview.png\" alt=\"overview\" />\n\n## 6. Test your Endpoint in the overview with the Inference widget \ud83c\udfc1 \ud83c\udf89!\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_inference.png\" alt=\"run inference\" />"
        }
    },
    {
        "sample_idx": 98,
        "question": "What does it mean if you see the message 'Hi anonymous, welcome to Hugging Face.' after running the SSH authentication test?",
        "answer": "It means your SSH key is not actually used by your SSH agent.",
        "rag_answer": "If you see the message 'Hi anonymous, welcome to Hugging Face.' after running the SSH authentication test, it means that your SSH key is not being used by your SSH agent. This indicates that the authentication process did not work as expected, and you are not successfully connected to your Hugging Face account using SSH.\n\nTo resolve this issue, ensure that your SSH key is properly configured and added to your SSH agent. You can try running the `ssh-add` command to add your SSH key to the agent, and then retry the SSH authentication test.\n\nHere's an example of the `ssh-add` command:\n```\n$ ssh-add ~/.ssh/id_ed25519\n```\nReplace `~/.ssh/id_ed25519` with the path to your SSH key file.\n\nAfter adding your SSH key to the agent, retry the SSH authentication test by running:\n```\n$ ssh -T git@hf.co\n```\nIf everything is set up correctly, you should see a message with your username, indicating that the connection works as expected.\n\nReferences:\n[DC] Git over SSH (Document Chunk)",
        "rag_score": 5,
        "rag_feedback": "The system's response is completely correct, accurate, and factual. It provides a detailed explanation of the issue, including the cause and the solution. The response is well-structured and easy to follow, with clear instructions on how to resolve the problem.",
        "rag_context": {
            "kg_context": "-----Entities-----\n    ```csv\n    id,\tentity,\ttype,\tdescription,\trankcreated_at\n1,\tSSH,category,Gradio can be run on remote servers using SSH.<SEP>SSH is a secure protocol used for authentication and data transfer.,6,2025-03-24 13:19:17\n2,\thuggingface.co,organization,huggingface.co is a platform that allows users to access and write data in repositories using SSH.,2,2025-03-24 13:19:17\n3,\tLinux,geo,Linux is a type of operating system.,1,2025-03-24 13:19:17\n4,\tSSH key,UNKNOWN,huggingface.co account uses SSH keys for authentication.,1,2025-03-24 13:19:17\n5,\thuggingface.co account,organization,huggingface.co account is a user account on the huggingface.co platform.,2,2025-03-24 13:19:17\n6,\thuggingface.co,organization,huggingface.co is a platform that allows users to access and write data in repositories using SSH.,2,UNKNOWN\n7,\t SSH,category,SSH is a protocol for secure remote access to computers.,0,UNKNOWN\n8,\tuser settings,category,user settings is a section on the huggingface.co platform where users can manage their SSH keys.,1,UNKNOWN\n    ```\n    -----Relationships-----\n    ```csv\n    id,\tsource,\ttarget,\tdescription,\tkeywords,\tweight,\trank,\tcreated_at\n1,\tSSH,huggingface.co,huggingface.co uses SSH for authentication and data transfer.,authentication, data transfer,18.0,8,2025-03-24 13:19:17\n2,\tLinux,SSH,Linux is a platform that uses SSH for authentication.,platform, authentication,12.0,7,2025-03-24 13:19:17\n3,\tSSH key,huggingface.co account,huggingface.co account uses SSH keys for authentication.,authentication, account management,7.0,3,2025-03-24 13:19:17\n4,\tSSH,huggingface.co,huggingface.co uses SSH for authentication and data transfer.,authentication, data transfer,18.0,8,UNKNOWN\n5,\tGit,huggingface.co,huggingface.co uses Git for version control, and Git uses SSH for authentication.,version control, authentication,16.0,4,UNKNOWN\n6,\thuggingface.co account,user settings,user settings is a section on the huggingface.co platform where users can manage their SSH keys.,account management, settings,6.0,3,UNKNOWN\n    ```\n    -----Sources-----\n    ```csv\n    id,\tcontent\n1,\tGit over SSH\n\nYou can access and write data in repositories on huggingface.co using SSH (Secure Shell Protocol). When you connect via SSH, you authenticate using a private key file on your local machine.\n\nSome actions, such as pushing changes, or cloning private repositories, will require you to upload your SSH public key to your account on huggingface.co.\n\nYou can use a pre-existing SSH key, or generate a new one specifically for huggingface.co.\n\n## Checking for existing SSH keys\n\nIf you have an existing SSH key, you can use that key to authenticate Git operations over SSH.\n\nSSH keys are usually located under `~/.ssh` on Mac & Linux, and under `C:\\\\Users\\\\<username>\\\\.ssh` on Windows. List files under that directory and look for files of the form:\n\n- id_rsa.pub\n- id_ecdsa.pub\n- id_ed25519.pub\n\nThose files contain your SSH public key.\n\nIf you don't have such file under `~/.ssh`, you will have to [generate a new key](#generating-a-new-ssh-keypair). Otherwise, you can [add your existing SSH public key(s) to your huggingface.co account](#add-a-ssh-key-to-your-account).\n\n## Generating a new SSH keypair\n\nIf you don't have any SSH keys on your machine, you can use `ssh-keygen` to generate a new SSH key pair (public + private keys):\n\n```\n$ ssh-keygen -t ed25519 -C \"your.email@example.co\"\n```\n\nWe recommend entering a passphrase when you are prompted to. A passphrase is an extra layer of security: it is a password that will be prompted whenever you use your SSH key.\n\nOnce your new key is generated, add it to your SSH agent with `ssh-add`:\n\n```\n$ ssh-add ~/.ssh/id_ed25519\n```\n\nIf you chose a different location than the default to store your SSH key, you would have to replace `~/.ssh/id_ed25519` with the file location you used.\n\n## Add a SSH key to your account\n\nTo access private repositories with SSH, or to push changes via SSH, you will need to add your SSH public key to your huggingface.co account. You can manage your SSH keys [in your user settings](https://huggingface.co/settings/keys).\n\nTo add a SSH key to your account, click on the \"Add SSH key\" button.\n\nThen, enter a name for this key (for example, \"Personal computer\"), and copy and paste the content of your **public** SSH key in the area below. The public key is located in the `~/.ssh/id_XXXX.pub` file you found or generated in the previous steps.\n\nClick on \"Add key\", and voil\u00e0! You have added a SSH key to your huggingface.co account.\n\n\n## Testing your SSH authentication\n\nOnce you have added your SSH key to your huggingface.co account, you can test that the connection works as expected.\n\nIn a terminal, run:\n```\n$ ssh -T git@hf.co\n```\n\nIf you see a message with your username, congrats! Everything went well, you are ready to use git over SSH.\n\nOtherwise, if the message states something like the following, make sure your SSH key is actually used by your SSH agent.\n```\nHi anonymous, welcome to Hugging Face.\n```\n2,\t\u4e0e\u5e38\u89c4\u51fd\u6570\u76f8\u540c\u7684\u65b9\u5f0f\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio\u3002\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\uff08\u865a\u62df\u7684\uff09\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5b83\u5728\u8f93\u51fa\u56fe\u50cf\u4e4b\u524d\u751f\u6210\u6570\u4e2a\u6b65\u9aa4\u7684\u566a\u97f3\uff1a\n\n$code_fake_diffusion\n$demo_fake_diffusion\n\n\u8bf7\u6ce8\u610f\uff0c\u6211\u4eec\u5728\u8fed\u4ee3\u5668\u4e2d\u6dfb\u52a0\u4e86 `time.sleep(1)`\uff0c\u4ee5\u521b\u5efa\u6b65\u9aa4\u4e4b\u95f4\u7684\u4eba\u5de5\u6682\u505c\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u89c2\u5bdf\u8fed\u4ee3\u5668\u7684\u6b65\u9aa4\uff08\u5728\u771f\u5b9e\u7684\u56fe\u50cf\u751f\u6210\u6a21\u578b\u4e2d\uff0c\u8fd9\u53ef\u80fd\u662f\u4e0d\u5fc5\u8981\u7684\uff09\u3002\n\n\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio **\u9700\u8981**\u5728\u5e95\u5c42 Interface \u6216 Blocks \u4e2d\u542f\u7528\u961f\u5217\uff08\u8bf7\u53c2\u9605\u4e0a\u9762\u7684\u961f\u5217\u90e8\u5206\uff09\u3002\n\n## \u8fdb\u5ea6\u6761\n\nGradio \u652f\u6301\u521b\u5efa\u81ea\u5b9a\u4e49\u8fdb\u5ea6\u6761\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u81ea\u5b9a\u4e49\u548c\u63a7\u5236\u5411\u7528\u6237\u663e\u793a\u7684\u8fdb\u5ea6\u66f4\u65b0\u3002\u8981\u542f\u7528\u6b64\u529f\u80fd\uff0c\u53ea\u9700\u4e3a\u65b9\u6cd5\u6dfb\u52a0\u4e00\u4e2a\u9ed8\u8ba4\u503c\u4e3a `gr.Progress` \u5b9e\u4f8b\u7684\u53c2\u6570\u5373\u53ef\u3002\u7136\u540e\uff0c\u60a8\u53ef\u4ee5\u76f4\u63a5\u8c03\u7528\u6b64\u5b9e\u4f8b\u5e76\u4f20\u5165 0 \u5230 1 \u4e4b\u95f4\u7684\u6d6e\u70b9\u6570\u6765\u66f4\u65b0\u8fdb\u5ea6\u7ea7\u522b\uff0c\u6216\u8005 with `Progress` \u5b9e\u4f8b\u7684 `tqdm()` \u65b9\u6cd5\u6765\u8ddf\u8e2a\u53ef\u8fed\u4ee3\u5bf9\u8c61\u4e0a\u7684\u8fdb\u5ea6\uff0c\u5982\u4e0b\u6240\u793a\u3002\u5fc5\u987b\u542f\u7528\u961f\u5217\u4ee5\u8fdb\u884c\u8fdb\u5ea6\u66f4\u65b0\u3002\n\n$code_progress_simple\n$demo_progress_simple\n\n\u5982\u679c\u60a8 with `tqdm` \u5e93\uff0c\u5e76\u4e14\u5e0c\u671b\u4ece\u51fd\u6570\u5185\u90e8\u7684\u4efb\u4f55 `tqdm.tqdm` \u81ea\u52a8\u62a5\u544a\u8fdb\u5ea6\u66f4\u65b0\uff0c\u8bf7\u5c06\u9ed8\u8ba4\u53c2\u6570\u8bbe\u7f6e\u4e3a `gr.Progress(track_tqdm=True)`\uff01\n\n## \u6279\u5904\u7406\u51fd\u6570 (Batch Functions)\n\nGradio \u652f\u6301\u4f20\u9012*\u6279\u5904\u7406*\u51fd\u6570\u3002\u6279\u5904\u7406\u51fd\u6570\u53ea\u662f\u63a5\u53d7\u8f93\u5165\u5217\u8868\u5e76\u8fd4\u56de\u9884\u6d4b\u5217\u8868\u7684\u51fd\u6570\u3002\n\n\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\u6279\u5904\u7406\u51fd\u6570\uff0c\u5b83\u63a5\u53d7\u4e24\u4e2a\u8f93\u5165\u5217\u8868\uff08\u4e00\u4e2a\u5355\u8bcd\u5217\u8868\u548c\u4e00\u4e2a\u6574\u6570\u5217\u8868\uff09\uff0c\u5e76\u8fd4\u56de\u4fee\u526a\u8fc7\u7684\u5355\u8bcd\u5217\u8868\u4f5c\u4e3a\u8f93\u51fa\uff1a\n\n```python\nimport time\n\ndef trim_words(words, lens):\n    trimmed_words = []\n    time.sleep(5)\n    for w, l in zip(words, lens):\n        trimmed_words.append(w[:int(l)])\n    return [trimmed_words]\n    for w, l in zip(words, lens):\n```\n\n\u4f7f\u7528\u6279\u5904\u7406\u51fd\u6570\u7684\u4f18\u70b9\u662f\uff0c\u5982\u679c\u542f\u7528\u4e86\u961f\u5217\uff0cGradio \u670d\u52a1\u5668\u53ef\u4ee5\u81ea\u52a8*\u6279\u5904\u7406*\u4f20\u5165\u7684\u8bf7\u6c42\u5e76\u5e76\u884c\u5904\u7406\u5b83\u4eec\uff0c\u4ece\u800c\u53ef\u80fd\u52a0\u5feb\u6f14\u793a\u901f\u5ea6\u3002\u4ee5\u4e0b\u662f Gradio \u4ee3\u7801\u7684\u793a\u4f8b\uff08\u8bf7\u6ce8\u610f `batch=True` \u548c `max_batch_size=16` - \u8fd9\u4e24\u4e2a\u53c2\u6570\u90fd\u53ef\u4ee5\u4f20\u9012\u7ed9\u4e8b\u4ef6\u89e6\u53d1\u5668\u6216 `Interface` \u7c7b\uff09\n\nwith `Interface`\uff1a\n\n```python\ndemo = gr.Interface(trim_words, [\"textbox\", \"number\"], [\"output\"],\n                    batch=True, max_batch_size=16)\ndemo.queue()\ndemo.launch()\n```\n\nwith `Blocks`\uff1a\n\n```python\nimport gradio as gr\n\nwith gr.Blocks() as demo:\n    with gr.Row():\n        word = gr.Textbox(label=\"word\")\n        leng = gr.Number(label=\"leng\")\n        output = gr.Textbox(label=\"Output\")\n    with gr.Row():\n        run = gr.Button()\n\n    event = run.click(trim_words, [word, leng], output, batch=True, max_batch_size=16)\n\ndemo.queue()\ndemo.launch()\n```\n\n\u5728\u4e0a\u9762\u7684\u793a\u4f8b\u4e2d\uff0c\u53ef\u4ee5\u5e76\u884c\u5904\u7406 16 \u4e2a\u8bf7\u6c42\uff08\u603b\u63a8\u7406\u65f6\u95f4\u4e3a 5 \u79d2\uff09\uff0c\u800c\u4e0d\u662f\u5206\u522b\u5904\u7406\u6bcf\u4e2a\u8bf7\u6c42\uff08\u603b\u63a8\u7406\u65f6\u95f4\u4e3a 80 \u79d2\uff09\u3002\u8bb8\u591a Hugging Face \u7684 `transformers` \u548c `diffusers` \u6a21\u578b\u5728 Gradio \u7684\u6279\u5904\u7406\u6a21\u5f0f\u4e0b\u81ea\u7136\u5de5\u4f5c\uff1a\u8fd9\u662f[\u4f7f\u7528\u6279\u5904\u7406\u751f\u6210\u56fe\u50cf\u7684\u793a\u4f8b\u6f14\u793a](https://github.com/gradio-app/gradio/blob/main/demo/diffusers_with_batching/run.py)\n\n\u6ce8\u610f\uff1a\u4f7f\u7528 Gradio \u7684\u6279\u5904\u7406\u51fd\u6570 **requires** \u5728\u5e95\u5c42 Interface \u6216 Blocks \u4e2d\u542f\u7528\u961f\u5217\uff08\u8bf7\u53c2\u9605\u4e0a\u9762\u7684\u961f\u5217\u90e8\u5206\uff09\u3002\n\n## Gradio \u7b14\u8bb0\u672c (Colab Notebooks)\n\nGradio \u53ef\u4ee5\u5728\u4efb\u4f55\u8fd0\u884c Python \u7684\u5730\u65b9\u8fd0\u884c\uff0c\u5305\u62ec\u672c\u5730 Jupyter \u7b14\u8bb0\u672c\u548c\u534f\u4f5c\u7b14\u8bb0\u672c\uff0c\u5982[Google Colab](https://colab.research.google.com/)\u3002\u5bf9\u4e8e\u672c\u5730 Jupyter \u7b14\u8bb0\u672c\u548c Google Colab \u7b14\u8bb0\u672c\uff0cGradio \u5728\u672c\u5730\u670d\u52a1\u5668\u4e0a\u8fd0\u884c\uff0c\u60a8\u53ef\u4ee5\u5728\u6d4f\u89c8\u5668\u4e2d\u4e0e\u4e4b\u4ea4\u4e92\u3002\uff08\u6ce8\u610f\uff1a\u5bf9\u4e8e Google Colab\uff0c\u8fd9\u662f\u901a\u8fc7[\u670d\u52a1\u5de5\u4f5c\u5668\u96a7\u9053](https://github.com/tensorflow/tensorboard/blob/master/docs/design/colab_integration.md)\u5b9e\u73b0\u7684\uff0c\u60a8\u7684\u6d4f\u89c8\u5668\u9700\u8981\u542f\u7528 cookies\u3002\uff09\u5bf9\u4e8e\u5176\u4ed6\u8fdc\u7a0b\u7b14\u8bb0\u672c\uff0cGradio \u4e5f\u5c06\u5728\u670d\u52a1\u5668\u4e0a\u8fd0\u884c\uff0c\u4f46\u60a8\u9700\u8981\u4f7f\u7528[SSH \u96a7\u9053](https://coderwall.com/p/ohk6cg/remote-access-to-ipython-notebooks-via-ssh)\u5728\u672c\u5730\u6d4f\u89c8\u5668\u4e2d\u67e5\u770b\u5e94\u7528\u7a0b\u5e8f\u3002\u901a\u5e38\uff0c\u66f4\u7b80\u5355\u7684\u9009\u62e9\u662f\u4f7f\u7528 Gradio \u5185\u7f6e\u7684\u516c\u5171\u94fe\u63a5\uff0c[\u5728\u4e0b\u4e00\u7bc7\u6307\u5357\u4e2d\u8ba8\u8bba](/sharing-your-app/#sharing-demos)\u3002\n    ```",
            "vector_context": "[Created at: 2025-03-24 13:18:47]\nGit over SSH\n\nYou can access and write data in repositories on huggingface.co using SSH (Secure Shell Protocol). When you connect via SSH, you authenticate using a private key file on your local machine.\n\nSome actions, such as pushing changes, or cloning private repositories, will require you to upload your SSH public key to your account on huggingface.co.\n\nYou can use a pre-existing SSH key, or generate a new one specifically for huggingface.co.\n\n## Checking for existing SSH keys\n\nIf you have an existing SSH key, you can use that key to authenticate Git operations over SSH.\n\nSSH keys are usually located under `~/.ssh` on Mac & Linux, and under `C:\\\\Users\\\\<username>\\\\.ssh` on Windows. List files under that directory and look for files of the form:\n\n- id_rsa.pub\n- id_ecdsa.pub\n- id_ed25519.pub\n\nThose files contain your SSH public key.\n\nIf you don't have such file under `~/.ssh`, you will have to [generate a new key](#generating-a-new-ssh-keypair). Otherwise, you can [add your existing SSH public key(s) to your huggingface.co account](#add-a-ssh-key-to-your-account).\n\n## Generating a new SSH keypair\n\nIf you don't have any SSH keys on your machine, you can use `ssh-keygen` to generate a new SSH key pair (public + private keys):\n\n```\n$ ssh-keygen -t ed25519 -C \"your.email@example.co\"\n```\n\nWe recommend entering a passphrase when you are prompted to. A passphrase is an extra layer of security: it is a password that will be prompted whenever you use your SSH key.\n\nOnce your new key is generated, add it to your SSH agent with `ssh-add`:\n\n```\n$ ssh-add ~/.ssh/id_ed25519\n```\n\nIf you chose a different location than the default to store your SSH key, you would have to replace `~/.ssh/id_ed25519` with the file location you used.\n\n## Add a SSH key to your account\n\nTo access private repositories with SSH, or to push changes via SSH, you will need to add your SSH public key to your huggingface.co account. You can manage your SSH keys [in your user settings](https://huggingface.co/settings/keys).\n\nTo add a SSH key to your account, click on the \"Add SSH key\" button.\n\nThen, enter a name for this key (for example, \"Personal computer\"), and copy and paste the content of your **public** SSH key in the area below. The public key is located in the `~/.ssh/id_XXXX.pub` file you found or generated in the previous steps.\n\nClick on \"Add key\", and voil\u00e0! You have added a SSH key to your huggingface.co account.\n\n\n## Testing your SSH authentication\n\nOnce you have added your SSH key to your huggingface.co account, you can test that the connection works as expected.\n\nIn a terminal, run:\n```\n$ ssh -T git@hf.co\n```\n\nIf you see a message with your username, congrats! Everything went well, you are ready to use git over SSH.\n\nOtherwise, if the message states something like the following, make sure your SSH key is actually used by your SSH agent.\n```\nHi anonymous, welcome to Hugging Face.\n```\n--New Chunk--\n[Created at: 2025-03-24 13:19:17]\n!---\nCopyright 2022 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n-->\n\n# Token classification with LayoutLMv3 (PyTorch version)\n\nThis directory contains a script, `run_funsd_cord.py`, that can be used to fine-tune (or evaluate) LayoutLMv3 on form understanding datasets, such as [FUNSD](https://guillaumejaume.github.io/FUNSD/) and [CORD](https://github.com/clovaai/cord).\n\nThe script `run_funsd_cord.py` leverages the \ud83e\udd17 Datasets library and the Trainer API. You can easily customize it to your needs.\n\n## Fine-tuning on FUNSD\n\nFine-tuning LayoutLMv3 for token classification on [FUNSD](https://guillaumejaume.github.io/FUNSD/) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name funsd \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 1e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-funsd\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd. By specifying the `push_to_hub` flag, the model gets uploaded automatically to the hub (regularly), together with a model card, which includes metrics such as precision, recall and F1. Note that you can easily update the model card, as it's just a README file of the respective repo on the hub.\n\nThere's also the \"Training metrics\" [tab](https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd/tensorboard), which shows Tensorboard logs over the course of training. Pretty neat, huh?\n\n## Fine-tuning on CORD\n\nFine-tuning LayoutLMv3 for token classification on [CORD](https://github.com/clovaai/cord) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name cord \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 5e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-cord\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-cord. Note that a model card gets generated automatically in case you specify the `push_to_hub` flag.\n--New Chunk--\n[Created at: 2025-03-24 13:15:42]\nCreate an Endpoint\n\nAfter your first login, you will be directed to the [Endpoint creation page](https://ui.endpoints.huggingface.co/new). As an example, this guide will go through the steps to deploy [distilbert-base-uncased-finetuned-sst-2-english](https://huggingface.co/distilbert-base-uncased-finetuned-sst-2-english) for text classification. \n\n## 1. Enter the Hugging Face Repository ID and your desired endpoint name:\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_repository.png\" alt=\"select repository\" />\n\n## 2. Select your Cloud Provider and region. Initially, only AWS will be available as a Cloud Provider with the `us-east-1` and `eu-west-1` regions. We will add Azure soon, and if you need to test Endpoints with other Cloud Providers or regions, please let us know.\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_region.png\" alt=\"select region\" />\n\n## 3. Define the [Security Level](security) for the Endpoint:\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_security.png\" alt=\"define security\" />\n\n## 4. Create your Endpoint by clicking **Create Endpoint**. By default, your Endpoint is created with a medium CPU (2 x 4GB vCPUs with Intel Xeon Ice Lake) The cost estimate assumes the Endpoint will be up for an entire month, and does not take autoscaling into account.\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_create_cost.png\" alt=\"create endpoint\" />\n\n## 5. Wait for the Endpoint to build, initialize and run which can take between 1 to 5 minutes.\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/overview.png\" alt=\"overview\" />\n\n## 6. Test your Endpoint in the overview with the Inference widget \ud83c\udfc1 \ud83c\udf89!\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_inference.png\" alt=\"run inference\" />"
        }
    },
    {
        "sample_idx": 99,
        "question": "What is the license under which the file is licensed?",
        "answer": "The file is licensed under the Apache License, Version 2.0.",
        "rag_answer": "The license under which the file is licensed is the Apache License, Version 2.0.",
        "rag_score": 5,
        "rag_feedback": "The response is completely correct, accurate, and factual. It correctly answers the question about the license under which the file is licensed, which is the Apache License, Version 2.0.",
        "rag_context": {
            "kg_context": "-----Entities-----\n    ```csv\n    id,\tentity,\ttype,\tdescription,\trankcreated_at\n1,\tGit,category,Git is a version control system that uses SSH for authentication.,2,2025-03-24 13:19:57\n2,\tSSH,category,Gradio can be run on remote servers using SSH.<SEP>SSH is a secure protocol used for authentication and data transfer.,6,2025-03-24 13:19:57\n3,\thuggingface.co,organization,huggingface.co is a platform that allows users to access and write data in repositories using SSH.,2,2025-03-24 13:19:57\n4,\tApache,organization,Apache is the organization that provides the Apache License, Version 2.0, under which the software is distributed.<SEP>Apache is the organization that provides the Apache License, Version 2.0, under which the software is licensed.,1,2025-03-24 13:19:57\n5,\tThe HuggingFace Team,organization,The HuggingFace Team is the copyright holder of the software and is responsible for licensing it under the Apache License.<SEP>The HuggingFace Team is the entity that owns the copyright to the file and is responsible for the Apache License.,1,2025-03-24 13:19:57\n6,\tThe HuggingFace Team,organization,The HuggingFace Team is the copyright holder of the software and is responsible for licensing it under the Apache License.<SEP>The HuggingFace Team is the entity that owns the copyright to the file and is responsible for the Apache License.,1,UNKNOWN\n7,\tgr,organization,gr is an organization that provides the Gradio library used in the demo.,1,UNKNOWN\n8,\tdocs,geo,docs is a location where more information about Gradio's state can be found.,1,UNKNOWN\n    ```\n    -----Relationships-----\n    ```csv\n    id,\tsource,\ttarget,\tdescription,\tkeywords,\tweight,\trank,\tcreated_at\n1,\tGit,SSH,Git uses SSH for authentication.,authentication, version control,16.0,8,2025-03-24 13:19:17\n2,\tGit,huggingface.co,huggingface.co uses Git for version control, and Git uses SSH for authentication.,version control, authentication,16.0,4,2025-03-24 13:19:17\n3,\tApache,The HuggingFace Team,The HuggingFace Team licenses their software under the Apache License.<SEP>The HuggingFace Team uses the Apache License, Version 2.0, for software distribution.,licensing, collaboration<SEP>licensing, software distribution,32.0,2,2025-03-24 13:19:57\n4,\tGradio,gr,gr is the organization that provides the Gradio library used in the demo.,organization, organization,9.0,37,UNKNOWN\n5,\tGradio,docs,The Gradio docs provide more information about state.,documentation, platform information,8.0,37,UNKNOWN\n6,\tApache,The HuggingFace Team,The HuggingFace Team licenses their software under the Apache License.<SEP>The HuggingFace Team uses the Apache License, Version 2.0, for software distribution.,licensing, collaboration<SEP>licensing, software distribution,32.0,2,UNKNOWN\n    ```\n    -----Sources-----\n    ```csv\n    id,\tcontent\n1,\tGit over SSH\n\nYou can access and write data in repositories on huggingface.co using SSH (Secure Shell Protocol). When you connect via SSH, you authenticate using a private key file on your local machine.\n\nSome actions, such as pushing changes, or cloning private repositories, will require you to upload your SSH public key to your account on huggingface.co.\n\nYou can use a pre-existing SSH key, or generate a new one specifically for huggingface.co.\n\n## Checking for existing SSH keys\n\nIf you have an existing SSH key, you can use that key to authenticate Git operations over SSH.\n\nSSH keys are usually located under `~/.ssh` on Mac & Linux, and under `C:\\\\Users\\\\<username>\\\\.ssh` on Windows. List files under that directory and look for files of the form:\n\n- id_rsa.pub\n- id_ecdsa.pub\n- id_ed25519.pub\n\nThose files contain your SSH public key.\n\nIf you don't have such file under `~/.ssh`, you will have to [generate a new key](#generating-a-new-ssh-keypair). Otherwise, you can [add your existing SSH public key(s) to your huggingface.co account](#add-a-ssh-key-to-your-account).\n\n## Generating a new SSH keypair\n\nIf you don't have any SSH keys on your machine, you can use `ssh-keygen` to generate a new SSH key pair (public + private keys):\n\n```\n$ ssh-keygen -t ed25519 -C \"your.email@example.co\"\n```\n\nWe recommend entering a passphrase when you are prompted to. A passphrase is an extra layer of security: it is a password that will be prompted whenever you use your SSH key.\n\nOnce your new key is generated, add it to your SSH agent with `ssh-add`:\n\n```\n$ ssh-add ~/.ssh/id_ed25519\n```\n\nIf you chose a different location than the default to store your SSH key, you would have to replace `~/.ssh/id_ed25519` with the file location you used.\n\n## Add a SSH key to your account\n\nTo access private repositories with SSH, or to push changes via SSH, you will need to add your SSH public key to your huggingface.co account. You can manage your SSH keys [in your user settings](https://huggingface.co/settings/keys).\n\nTo add a SSH key to your account, click on the \"Add SSH key\" button.\n\nThen, enter a name for this key (for example, \"Personal computer\"), and copy and paste the content of your **public** SSH key in the area below. The public key is located in the `~/.ssh/id_XXXX.pub` file you found or generated in the previous steps.\n\nClick on \"Add key\", and voil\u00e0! You have added a SSH key to your huggingface.co account.\n\n\n## Testing your SSH authentication\n\nOnce you have added your SSH key to your huggingface.co account, you can test that the connection works as expected.\n\nIn a terminal, run:\n```\n$ ssh -T git@hf.co\n```\n\nIf you see a message with your username, congrats! Everything went well, you are ready to use git over SSH.\n\nOtherwise, if the message states something like the following, make sure your SSH key is actually used by your SSH agent.\n```\nHi anonymous, welcome to Hugging Face.\n```\n2,\t!--Copyright 2023 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\nthe License. You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under the License is distributed on\nan \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n\n\u26a0\ufe0f Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be\nrendered properly in your Markdown viewer.\n\n-->\n\n# Training on TPU with TensorFlow\n\n<Tip>\n\nIf you don't need long explanations and just want TPU code samples to get started with, check out [our TPU example notebook!](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb)\n\n</Tip>\n\n### What is a TPU?\n\nA TPU is a **Tensor Processing Unit.** They are hardware designed by Google, which are used to greatly speed up the tensor computations within neural networks, much like GPUs. They can be used for both network training and inference. They are generally accessed through Google\u2019s cloud services, but small TPUs can also be accessed directly for free through Google Colab and Kaggle Kernels.\n\nBecause [all TensorFlow models in \ud83e\udd17 Transformers are Keras models](https://huggingface.co/blog/tensorflow-philosophy), most of the methods in this document are generally applicable to TPU training for any Keras model! However, there are a few points that are specific to the HuggingFace ecosystem (hug-o-system?) of Transformers and Datasets, and we\u2019ll make sure to flag them up when we get to them.\n\n### What kinds of TPU are available?\n\nNew users are often very confused by the range of TPUs, and the different ways to access them. The first key distinction to understand is the difference between **TPU Nodes** and **TPU VMs.**\n\nWhen you use a **TPU Node**, you are effectively indirectly accessing a remote TPU. You will need a separate VM, which will initialize your network and data pipeline and then forward them to the remote node. When you use a TPU on Google Colab, you are accessing it in the **TPU Node** style.\n\nUsing TPU Nodes can have some quite unexpected behaviour for people who aren\u2019t used to them! In particular, because the TPU is located on a physically different system to the machine you\u2019re running your Python code on, your data cannot be local to your machine - any data pipeline that loads from your machine\u2019s internal storage will totally fail! Instead, data must be stored in Google Cloud Storage where your data pipeline can still access it, even when the pipeline is running on the remote TPU node.\n\n<Tip>\n\nIf you can fit all your data in memory as `np.ndarray` or `tf.Tensor`, then you can `fit()` on that data even when using Colab or a TPU Node, without needing to upload it to Google Cloud Storage.\n\n</Tip>\n\n<Tip>\n\n**\ud83e\udd17Specific Hugging Face Tip\ud83e\udd17:** The methods `Dataset.to_tf_dataset()` and its higher-level wrapper `model.prepare_tf_dataset()` , which you will see throughout our TF code examples, will both fail on a TPU Node. The reason for this is that even though they create a `tf.data.Dataset` it is not a \u201cpure\u201d `tf.data` pipeline and uses `tf.numpy_function` or `Dataset.from_generator()` to stream data from the underlying HuggingFace `Dataset`. This HuggingFace `Dataset` is backed by data that is on a local disc and which the remote TPU Node will not be able to read.\n\n</Tip>\n\nThe second way to access a TPU is via a **TPU VM.** When using a TPU VM, you connect directly to the machine that the TPU is attached to, much like training on a GPU VM. TPU VMs are generally easier to work with, particularly when it comes to your data pipeline. All of the above warnings do not apply to TPU VMs!\n\nThis is an opinionated document, so here\u2019s our opinion: **Avoid using TPU Node if possible.** It is more confusing and more difficult to debug than TPU VMs. It is also likely to be unsupported in future - Google\u2019s latest TPU, TPUv4, can only be accessed as a TPU VM, which suggests that TPU Nodes are increasingly going to become a \u201clegacy\u201d access method. However, we understand that the only free TPU access is on Colab and Kaggle Kernels, which uses TPU Node - so we\u2019ll try to explain how to handle it if you have to! Check the [TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) for code samples that explain this in more detail.\n\n### What sizes of TPU are available?\n\nA single TPU (a v2-8/v3-8/v4-8) runs 8 replicas. TPUs exist in **pods** that can run hundreds or thousands of replicas simultaneously. When you use more than a single TPU but less than a whole pod (for example, a v3-32), your TPU fleet is referred to as a **pod slice.**\n\nWhen you access a free TPU via Colab, you generally get a single v2-8 TPU.\n\n### I keep hearing about this XLA thing. What\u2019s XLA, and how does it relate to TPUs?\n\nXLA is an optimizing compiler, used by both TensorFlow and JAX. In JAX it is the only compiler, whereas in TensorFlow it is optional\n3,\t!---\nCopyright 2022 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n-->\n\n# Token classification with LayoutLMv3 (PyTorch version)\n\nThis directory contains a script, `run_funsd_cord.py`, that can be used to fine-tune (or evaluate) LayoutLMv3 on form understanding datasets, such as [FUNSD](https://guillaumejaume.github.io/FUNSD/) and [CORD](https://github.com/clovaai/cord).\n\nThe script `run_funsd_cord.py` leverages the \ud83e\udd17 Datasets library and the Trainer API. You can easily customize it to your needs.\n\n## Fine-tuning on FUNSD\n\nFine-tuning LayoutLMv3 for token classification on [FUNSD](https://guillaumejaume.github.io/FUNSD/) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name funsd \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 1e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-funsd\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd. By specifying the `push_to_hub` flag, the model gets uploaded automatically to the hub (regularly), together with a model card, which includes metrics such as precision, recall and F1. Note that you can easily update the model card, as it's just a README file of the respective repo on the hub.\n\nThere's also the \"Training metrics\" [tab](https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd/tensorboard), which shows Tensorboard logs over the course of training. Pretty neat, huh?\n\n## Fine-tuning on CORD\n\nFine-tuning LayoutLMv3 for token classification on [CORD](https://github.com/clovaai/cord) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name cord \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 5e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-cord\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-cord. Note that a model card gets generated automatically in case you specify the `push_to_hub` flag.\n4,\tGradio Demo: blocks_random_slider\n\n\n```\n!pip install -q gradio \n```\n\n\n```\n\nimport gradio as gr\n\n\ndef func(slider_1, slider_2):\n    return slider_1 * 5 + slider_2\n\n\nwith gr.Blocks() as demo:\n    slider = gr.Slider(minimum=-10.2, maximum=15, label=\"Random Slider (Static)\", randomize=True)\n    slider_1 = gr.Slider(minimum=100, maximum=200, label=\"Random Slider (Input 1)\", randomize=True)\n    slider_2 = gr.Slider(minimum=10, maximum=23.2, label=\"Random Slider (Input 2)\", randomize=True)\n    slider_3 = gr.Slider(value=3, label=\"Non random slider\")\n    btn = gr.Button(\"Run\")\n    btn.click(func, inputs=[slider_1, slider_2], outputs=gr.Number())\n\nif __name__ == \"__main__\":\n    demo.launch()\n\n```\n5,\tState in Blocks\n\nWe covered [State in Interfaces](https://gradio.app/interface-state), this guide takes a look at state in Blocks, which works mostly the same.\n\n## Global State\n\nGlobal state in Blocks works the same as in Interface. Any variable created outside a function call is a reference shared between all users.\n\n## Session State\n\nGradio supports session **state**, where data persists across multiple submits within a page session, in Blocks apps as well. To reiterate, session data is _not_ shared between different users of your model. To store data in a session state, you need to do three things:\n\n1. Create a `gr.State()` object. If there is a default value to this stateful object, pass that into the constructor.\n2. In the event listener, put the `State` object as an input and output.\n3. In the event listener function, add the variable to the input parameters and the return value.\n\nLet's take a look at a game of hangman.\n\n$code_hangman\n$demo_hangman\n\nLet's see how we do each of the 3 steps listed above in this game:\n\n1. We store the used letters in `used_letters_var`. In the constructor of `State`, we set the initial value of this to `[]`, an empty list.\n2. In `btn.click()`, we have a reference to `used_letters_var` in both the inputs and outputs.\n3. In `guess_letter`, we pass the value of this `State` to `used_letters`, and then return an updated value of this `State` in the return statement.\n\nWith more complex apps, you will likely have many State variables storing session state in a single Blocks app.\n\nLearn more about `State` in the [docs](https://gradio.app/docs#state).\n    ```",
            "vector_context": "[Created at: 2025-03-24 13:16:13]\n=predictions, references=references)\n>>> results\n{'exact_match': 100.0, 'f1': 100.0}\n```\n\nYou can find examples of dataset structures by consulting the \"Dataset Preview\" function or the dataset card for a given dataset, and you can see how to use its dedicated evaluation function based on the metric card.\n--New Chunk--\n[Created at: 2025-03-24 13:16:48]\n\u65f6\u5fc5\u987b\u9009\u62e9\u5176\u4e2d\u4e00\u4e2a\u5b57\u7b26\u4e32\uff0c\u8fd9\u5c06\u4f5c\u4e3a\u9644\u52a0\u5217\u4fdd\u5b58\u5230 CSV \u4e2d\u3002\n\n## \u9884\u5904\u7406\u548c\u540e\u5904\u7406 (Preprocessing and Postprocessing)\n\n![annotated](/assets/img/dataflow.svg)\n\n\u5982\u60a8\u6240\u89c1\uff0cGradio \u5305\u62ec\u53ef\u4ee5\u5904\u7406\u5404\u79cd\u4e0d\u540c\u6570\u636e\u7c7b\u578b\u7684\u7ec4\u4ef6\uff0c\u4f8b\u5982\u56fe\u50cf\u3001\u97f3\u9891\u548c\u89c6\u9891\u3002\u5927\u591a\u6570\u7ec4\u4ef6\u90fd\u53ef\u4ee5\u7528\u4f5c\u8f93\u5165\u6216\u8f93\u51fa\u3002\n\n\u5f53\u7ec4\u4ef6\u7528\u4f5c\u8f93\u5165\u65f6\uff0cGradio \u81ea\u52a8\u5904\u7406*\u9884\u5904\u7406*\uff0c\u5c06\u6570\u636e\u4ece\u7528\u6237\u6d4f\u89c8\u5668\u53d1\u9001\u7684\u7c7b\u578b\uff08\u4f8b\u5982\u7f51\u7edc\u6444\u50cf\u5934\u5feb\u7167\u7684 base64 \u8868\u793a\uff09\u8f6c\u6362\u4e3a\u60a8\u7684\u51fd\u6570\u53ef\u4ee5\u63a5\u53d7\u7684\u5f62\u5f0f\uff08\u4f8b\u5982 `numpy` \u6570\u7ec4\uff09\u3002\n\n\u540c\u6837\uff0c\u5f53\u7ec4\u4ef6\u7528\u4f5c\u8f93\u51fa\u65f6\uff0cGradio \u81ea\u52a8\u5904\u7406*\u540e\u5904\u7406*\uff0c\u5c06\u6570\u636e\u4ece\u51fd\u6570\u8fd4\u56de\u7684\u5f62\u5f0f\uff08\u4f8b\u5982\u56fe\u50cf\u8def\u5f84\u5217\u8868\uff09\u8f6c\u6362\u4e3a\u53ef\u4ee5\u5728\u7528\u6237\u6d4f\u89c8\u5668\u4e2d\u663e\u793a\u7684\u5f62\u5f0f\uff08\u4f8b\u5982\u4ee5 base64 \u683c\u5f0f\u663e\u793a\u56fe\u50cf\u7684 `Gallery`\uff09\u3002\n\n\u60a8\u53ef\u4ee5\u4f7f\u7528\u6784\u5efa\u56fe\u50cf\u7ec4\u4ef6\u65f6\u7684\u53c2\u6570\u63a7\u5236*\u9884\u5904\u7406*\u3002\u4f8b\u5982\uff0c\u5982\u679c\u60a8\u4f7f\u7528\u4ee5\u4e0b\u53c2\u6570\u5b9e\u4f8b\u5316 `Image` \u7ec4\u4ef6\uff0c\u5b83\u5c06\u5c06\u56fe\u50cf\u8f6c\u6362\u4e3a `PIL` \u7c7b\u578b\uff0c\u5e76\u5c06\u5176\u91cd\u5851\u4e3a`(100, 100)`\uff0c\u800c\u4e0d\u7ba1\u63d0\u4ea4\u65f6\u7684\u539f\u59cb\u5927\u5c0f\u5982\u4f55\uff1a\n\n```py\nimg = gr.Image(shape=(100, 100), type=\"pil\")\n```\n\n\u76f8\u53cd\uff0c\u8fd9\u91cc\u6211\u4eec\u4fdd\u7559\u56fe\u50cf\u7684\u539f\u59cb\u5927\u5c0f\uff0c\u4f46\u5728\u5c06\u5176\u8f6c\u6362\u4e3a numpy \u6570\u7ec4\u4e4b\u524d\u53cd\u8f6c\u989c\u8272\uff1a\n\n```py\nimg = gr.Image(invert_colors=True, type=\"numpy\")\n```\n\n\u540e\u5904\u7406\u8981\u5bb9\u6613\u5f97\u591a\uff01Gradio \u81ea\u52a8\u8bc6\u522b\u8fd4\u56de\u6570\u636e\u7684\u683c\u5f0f\uff08\u4f8b\u5982 `Image` \u662f `numpy` \u6570\u7ec4\u8fd8\u662f `str` \u6587\u4ef6\u8def\u5f84\uff1f\uff09\uff0c\u5e76\u5c06\u5176\u540e\u5904\u7406\u4e3a\u53ef\u4ee5\u7531\u6d4f\u89c8\u5668\u663e\u793a\u7684\u683c\u5f0f\u3002\n\n\u8bf7\u67e5\u770b[\u6587\u6863](https://gradio.app/docs)\uff0c\u4e86\u89e3\u6bcf\u4e2a\u7ec4\u4ef6\u7684\u6240\u6709\u4e0e\u9884\u5904\u7406\u76f8\u5173\u7684\u53c2\u6570\u3002\n\n## \u6837\u5f0f (Styling)\n\nGradio \u4e3b\u9898\u662f\u81ea\u5b9a\u4e49\u5e94\u7528\u7a0b\u5e8f\u5916\u89c2\u548c\u611f\u89c9\u7684\u6700\u7b80\u5355\u65b9\u6cd5\u3002\u60a8\u53ef\u4ee5\u9009\u62e9\u591a\u79cd\u4e3b\u9898\u6216\u521b\u5efa\u81ea\u5df1\u7684\u4e3b\u9898\u3002\u8981\u8fd9\u6837\u505a\uff0c\u8bf7\u5c06 `theme=` \u53c2\u6570\u4f20\u9012\u7ed9 `Interface` \u6784\u9020\u51fd\u6570\u3002\u4f8b\u5982\uff1a\n\n```python\ndemo = gr.Interface(..., theme=gr.themes.Monochrome())\n```\n\nGradio \u5e26\u6709\u4e00\u7ec4\u9884\u5148\u6784\u5efa\u7684\u4e3b\u9898\uff0c\u60a8\u53ef\u4ee5\u4ece `gr.themes.*` \u52a0\u8f7d\u3002\u60a8\u53ef\u4ee5\u6269\u5c55\u8fd9\u4e9b\u4e3b\u9898\u6216\u4ece\u5934\u5f00\u59cb\u521b\u5efa\u81ea\u5df1\u7684\u4e3b\u9898 - \u6709\u5173\u66f4\u591a\u8be6\u7ec6\u4fe1\u606f\uff0c\u8bf7\u53c2\u9605[\u4e3b\u9898\u6307\u5357](https://gradio.app/theming-guide)\u3002\n\n\u8981\u589e\u52a0\u989d\u5916\u7684\u6837\u5f0f\u80fd\u529b\uff0c\u60a8\u53ef\u4ee5 with `css=` \u5173\u952e\u5b57\u5c06\u4efb\u4f55 CSS \u4f20\u9012\u7ed9\u60a8\u7684\u5e94\u7528\u7a0b\u5e8f\u3002\nGradio \u5e94\u7528\u7a0b\u5e8f\u7684\u57fa\u7c7b\u662f `gradio-container`\uff0c\u56e0\u6b64\u4ee5\u4e0b\u662f\u4e00\u4e2a\u66f4\u6539 Gradio \u5e94\u7528\u7a0b\u5e8f\u80cc\u666f\u989c\u8272\u7684\u793a\u4f8b\uff1a\n\n```python\nwith `gr.Interface(css=\".gradio-container {background-color: red}\") as demo:\n    ...\n```\n\n## \u961f\u5217 (Queuing)\n\n\u5982\u679c\u60a8\u7684\u5e94\u7528\u7a0b\u5e8f\u9884\u8ba1\u4f1a\u6709\u5927\u91cf\u6d41\u91cf\uff0c\u8bf7 with `queue()` \u65b9\u6cd5\u6765\u63a7\u5236\u5904\u7406\u901f\u7387\u3002\u8fd9\u5c06\u6392\u961f\u5904\u7406\u8c03\u7528\uff0c\u56e0\u6b64\u4e00\u6b21\u53ea\u5904\u7406\u4e00\u5b9a\u6570\u91cf\u7684\u8bf7\u6c42\u3002\u961f\u5217\u4f7f\u7528 Websockets\uff0c\u8fd8\u53ef\u4ee5\u9632\u6b62\u7f51\u7edc\u8d85\u65f6\uff0c\u56e0\u6b64\u5982\u679c\u60a8\u7684\u51fd\u6570\u7684\u63a8\u7406\u65f6\u95f4\u5f88\u957f\uff08> 1 \u5206\u949f\uff09\uff0c\u5e94\u4f7f\u7528\u961f\u5217\u3002\n\nwith `Interface`\uff1a\n\n```python\ndemo = gr.Interface(...).queue()\ndemo.launch()\n```\n\nwith `Blocks`\uff1a\n\n```python\nwith gr.Blocks() as demo\uff1a\n    #...\ndemo.queue()\ndemo.launch()\n```\n\n\u60a8\u53ef\u4ee5\u901a\u8fc7\u4ee5\u4e0b\u65b9\u5f0f\u63a7\u5236\u4e00\u6b21\u5904\u7406\u7684\u8bf7\u6c42\u6570\u91cf\uff1a\n\n```python\ndemo.queue(concurrency_count=3)\n```\n\n\u67e5\u770b\u6709\u5173\u914d\u7f6e\u5176\u4ed6\u961f\u5217\u53c2\u6570\u7684[\u961f\u5217\u6587\u6863](/docs/#queue)\u3002\n\n\u5728 Blocks \u4e2d\u6307\u5b9a\u4ec5\u5bf9\u67d0\u4e9b\u51fd\u6570\u8fdb\u884c\u6392\u961f\uff1a\n\n```python\nwith gr.Blocks() as demo2\uff1a\n    num1 = gr.Number()\n    num2 = gr.Number()\n    output = gr.Number()\n    gr.Button(\"Add\").click(\n        lambda a, b: a + b, [num1, num2], output)\n    gr.Button(\"Multiply\").click(\n        lambda a, b: a * b, [num1, num2], output, queue=True)\ndemo2.launch()\n```\n\n## \u8fed\u4ee3\u8f93\u51fa (Iterative Outputs)\n\n\u5728\u67d0\u4e9b\u60c5\u51b5\u4e0b\uff0c\u60a8\u53ef\u80fd\u9700\u8981\u4f20\u8f93\u4e00\u7cfb\u5217\u8f93\u51fa\u800c\u4e0d\u662f\u4e00\u6b21\u663e\u793a\u5355\u4e2a\u8f93\u51fa\u3002\u4f8b\u5982\uff0c\u60a8\u53ef\u80fd\u6709\u4e00\u4e2a\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5e0c\u671b\u663e\u793a\u751f\u6210\u7684\u6bcf\u4e2a\u6b65\u9aa4\u7684\u56fe\u50cf\uff0c\u76f4\u5230\u6700\u7ec8\u56fe\u50cf\u3002\u6216\u8005\u60a8\u53ef\u80fd\u6709\u4e00\u4e2a\u804a\u5929\u673a\u5668\u4eba\uff0c\u5b83\u9010\u5b57\u9010\u53e5\u5730\u6d41\u5f0f\u4f20\u8f93\u54cd\u5e94\uff0c\u800c\u4e0d\u662f\u4e00\u6b21\u8fd4\u56de\u5168\u90e8\u54cd\u5e94\u3002\n\n\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u60a8\u53ef\u4ee5\u5c06**\u751f\u6210\u5668**\u51fd\u6570\u63d0\u4f9b\u7ed9 Gradio\uff0c\u800c\u4e0d\u662f\u5e38\u89c4\u51fd\u6570\u3002\u5728 Python \u4e2d\u521b\u5efa\u751f\u6210\u5668\u975e\u5e38\u7b80\u5355\uff1a\u51fd\u6570\u4e0d\u5e94\u8be5\u6709\u4e00\u4e2a\u5355\u72ec\u7684 `return` \u503c\uff0c\u800c\u662f\u5e94\u8be5 with `yield` \u8fde\u7eed\u8fd4\u56de\u4e00\u7cfb\u5217\u503c\u3002\u901a\u5e38\uff0c`yield` \u8bed\u53e5\u653e\u7f6e\u5728\u67d0\u79cd\u5faa\u73af\u4e2d\u3002\u4e0b\u9762\u662f\u4e00\u4e2a\u7b80\u5355\u793a\u4f8b\uff0c\u751f\u6210\u5668\u53ea\u662f\u7b80\u5355\u8ba1\u6570\u5230\u7ed9\u5b9a\u6570\u5b57\uff1a\n\n```python\ndef my_generator(x):\n    for i in range(x):\n        yield i\n```\n\n\u60a8\u4ee5\u4e0e\u5e38\u89c4\u51fd\u6570\u76f8\u540c\u7684\u65b9\u5f0f\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio\u3002\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\uff08\u865a\u62df\u7684\uff09\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5b83\u5728\u8f93\u51fa\u56fe\u50cf\u4e4b\u524d\u751f\u6210\u6570\u4e2a\u6b65\u9aa4\u7684\u566a\u97f3\uff1a\n\n$code_fake_diffusion\n$demo_fake_diffusion\n\n\u8bf7\u6ce8\u610f\uff0c\u6211\u4eec\u5728\u8fed\u4ee3\u5668\u4e2d\u6dfb\u52a0\u4e86 `time.sleep(1)`\uff0c\u4ee5\u521b\u5efa\u6b65\u9aa4\u4e4b\u95f4\u7684\u4eba\u5de5\u6682\u505c\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u89c2\u5bdf\u8fed\u4ee3\u5668\u7684\u6b65\u9aa4\uff08\u5728\u771f\u5b9e\u7684\u56fe\u50cf\u751f\u6210\u6a21\u578b\u4e2d\uff0c\u8fd9\n--New Chunk--\n[Created at: 2025-03-24 13:18:47]\nGit over SSH\n\nYou can access and write data in repositories on huggingface.co using SSH (Secure Shell Protocol). When you connect via SSH, you authenticate using a private key file on your local machine.\n\nSome actions, such as pushing changes, or cloning private repositories, will require you to upload your SSH public key to your account on huggingface.co.\n\nYou can use a pre-existing SSH key, or generate a new one specifically for huggingface.co.\n\n## Checking for existing SSH keys\n\nIf you have an existing SSH key, you can use that key to authenticate Git operations over SSH.\n\nSSH keys are usually located under `~/.ssh` on Mac & Linux, and under `C:\\\\Users\\\\<username>\\\\.ssh` on Windows. List files under that directory and look for files of the form:\n\n- id_rsa.pub\n- id_ecdsa.pub\n- id_ed25519.pub\n\nThose files contain your SSH public key.\n\nIf you don't have such file under `~/.ssh`, you will have to [generate a new key](#generating-a-new-ssh-keypair). Otherwise, you can [add your existing SSH public key(s) to your huggingface.co account](#add-a-ssh-key-to-your-account).\n\n## Generating a new SSH keypair\n\nIf you don't have any SSH keys on your machine, you can use `ssh-keygen` to generate a new SSH key pair (public + private keys):\n\n```\n$ ssh-keygen -t ed25519 -C \"your.email@example.co\"\n```\n\nWe recommend entering a passphrase when you are prompted to. A passphrase is an extra layer of security: it is a password that will be prompted whenever you use your SSH key.\n\nOnce your new key is generated, add it to your SSH agent with `ssh-add`:\n\n```\n$ ssh-add ~/.ssh/id_ed25519\n```\n\nIf you chose a different location than the default to store your SSH key, you would have to replace `~/.ssh/id_ed25519` with the file location you used.\n\n## Add a SSH key to your account\n\nTo access private repositories with SSH, or to push changes via SSH, you will need to add your SSH public key to your huggingface.co account. You can manage your SSH keys [in your user settings](https://huggingface.co/settings/keys).\n\nTo add a SSH key to your account, click on the \"Add SSH key\" button.\n\nThen, enter a name for this key (for example, \"Personal computer\"), and copy and paste the content of your **public** SSH key in the area below. The public key is located in the `~/.ssh/id_XXXX.pub` file you found or generated in the previous steps.\n\nClick on \"Add key\", and voil\u00e0! You have added a SSH key to your huggingface.co account.\n\n\n## Testing your SSH authentication\n\nOnce you have added your SSH key to your huggingface.co account, you can test that the connection works as expected.\n\nIn a terminal, run:\n```\n$ ssh -T git@hf.co\n```\n\nIf you see a message with your username, congrats! Everything went well, you are ready to use git over SSH.\n\nOtherwise, if the message states something like the following, make sure your SSH key is actually used by your SSH agent.\n```\nHi anonymous, welcome to Hugging Face.\n```"
        }
    },
    {
        "sample_idx": 100,
        "question": "What is the purpose of the script run_funsd_cord.py?",
        "answer": "The script run_funsd_cord.py is used to fine-tune or evaluate LayoutLMv3 on form understanding datasets.",
        "rag_answer": "The script `run_funsd_cord.py` is used to fine-tune the LayoutLMv3 model on form understanding datasets, such as FUNSD and CORD. It leverages the \ud83e\udd17 Datasets library and the Trainer API, allowing for easy customization to suit specific needs.",
        "rag_score": 5,
        "rag_feedback": "The system's response is completely correct, accurate, and factual. It provides a detailed explanation of the script run_funsd_cord.py, including its purpose, usage, and examples of fine-tuning LayoutLMv3 on form understanding datasets such as FUNSD and CORD.",
        "rag_context": {
            "kg_context": "-----Entities-----\n    ```csv\n    id,\tentity,\ttype,\tdescription,\trankcreated_at\n1,\tLayoutLMv3,technology,LayoutLMv3 is a model used for token classification and form understanding tasks.,11,2025-03-24 13:20:24\n2,\trun_funsd_cord.py,UNKNOWN,run_funsd_cord.py is a script used for fine-tuning the LayoutLMv3 model.,1,2025-03-24 13:20:24\n3,\tKeras,category,Keras is a high-level neural networks API, used for building and training neural networks.<SEP>Keras is a machine learning framework that uses XLA for optimization.,2,2025-03-24 13:20:24\n4,\tXLA,technology,XLA is a technology that compiles TensorFlow graphs into executable code for various platforms.<SEP>XLA is an optimizing compiler used by TensorFlow and JAX to improve performance.<SEP>XLA is an optimizing compiler, used by both TensorFlow and JAX to optimize computations.,6,2025-03-24 13:20:24\n5,\tguess_letter,event,guess_letter is a function in the hangman game that updates the state of used letters.,2,2025-03-24 13:20:24\n6,\tused_letters_var,category,used_letters_var is a variable that stores the used letters in the hangman game.,1,2025-03-24 13:20:24\n7,\t run_funsd_cord.py,event,run_funsd_cord.py is a script used for fine-tuning the LayoutLMv3 model.,0,UNKNOWN\n8,\tfunc,event,func is an event that occurs when the button is clicked, executing a specific function.,1,UNKNOWN\n9,\tCORD,geo,CORD is a form understanding dataset used for fine-tuning LayoutLMv3.,1,UNKNOWN\n    ```\n    -----Relationships-----\n    ```csv\n    id,\tsource,\ttarget,\tdescription,\tkeywords,\tweight,\trank,\tcreated_at\n1,\tLayoutLMv3,run_funsd_cord.py,run_funsd_cord.py is a script used for fine-tuning the LayoutLMv3 model.,script, model fine-tuning,7.0,12,2025-03-24 13:19:57\n2,\tKeras,XLA,Keras uses XLA for optimization.,compiler, performance optimization,8.0,8,2025-03-24 13:18:20\n3,\tguess_letter,used_letters_var,used_letters_var is updated by the guess_letter function.,variable update, game logic,8.0,3,2025-03-24 13:20:24\n4,\tCORD,LayoutLMv3,CORD is a dataset used for fine-tuning the LayoutLMv3 model.,dataset, model training,14.0,12,UNKNOWN\n5,\tGradio Demo,func,func is an event that occurs in Gradio Demo when the button is clicked.,event, event,8.0,9,UNKNOWN\n    ```\n    -----Sources-----\n    ```csv\n    id,\tcontent\n1,\t!---\nCopyright 2022 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n-->\n\n# Token classification with LayoutLMv3 (PyTorch version)\n\nThis directory contains a script, `run_funsd_cord.py`, that can be used to fine-tune (or evaluate) LayoutLMv3 on form understanding datasets, such as [FUNSD](https://guillaumejaume.github.io/FUNSD/) and [CORD](https://github.com/clovaai/cord).\n\nThe script `run_funsd_cord.py` leverages the \ud83e\udd17 Datasets library and the Trainer API. You can easily customize it to your needs.\n\n## Fine-tuning on FUNSD\n\nFine-tuning LayoutLMv3 for token classification on [FUNSD](https://guillaumejaume.github.io/FUNSD/) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name funsd \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 1e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-funsd\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd. By specifying the `push_to_hub` flag, the model gets uploaded automatically to the hub (regularly), together with a model card, which includes metrics such as precision, recall and F1. Note that you can easily update the model card, as it's just a README file of the respective repo on the hub.\n\nThere's also the \"Training metrics\" [tab](https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd/tensorboard), which shows Tensorboard logs over the course of training. Pretty neat, huh?\n\n## Fine-tuning on CORD\n\nFine-tuning LayoutLMv3 for token classification on [CORD](https://github.com/clovaai/cord) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name cord \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 5e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-cord\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-cord. Note that a model card gets generated automatically in case you specify the `push_to_hub` flag.\n2,\t(for example, a v3-32), your TPU fleet is referred to as a **pod slice.**\n\nWhen you access a free TPU via Colab, you generally get a single v2-8 TPU.\n\n### I keep hearing about this XLA thing. What\u2019s XLA, and how does it relate to TPUs?\n\nXLA is an optimizing compiler, used by both TensorFlow and JAX. In JAX it is the only compiler, whereas in TensorFlow it is optional (but mandatory on TPU!). The easiest way to enable it when training a Keras model is to pass the argument `jit_compile=True` to `model.compile()`. If you don\u2019t get any errors and performance is good, that\u2019s a great sign that you\u2019re ready to move to TPU!\n\nDebugging on TPU is generally a bit harder than on CPU/GPU, so we recommend getting your code running on CPU/GPU with XLA first before trying it on TPU. You don\u2019t have to train for long, of course - just for a few steps to make sure that your model and data pipeline are working like you expect them to.\n\n<Tip>\n\nXLA compiled code is usually faster - so even if you\u2019re not planning to run on TPU, adding `jit_compile=True` can improve your performance. Be sure to note the caveats below about XLA compatibility, though!\n\n</Tip>\n\n<Tip warning={true}>\n\n**Tip born of painful experience:** Although using `jit_compile=True` is a good way to get a speed boost and test if your CPU/GPU code is XLA-compatible, it can actually cause a lot of problems if you leave it in when actually training on TPU. XLA compilation will happen implicitly on TPU, so remember to remove that line before actually running your code on a TPU!\n\n</Tip>\n\n### How do I make my model XLA compatible?\n\nIn many cases, your code is probably XLA-compatible already! However, there are a few things that work in normal TensorFlow that don\u2019t work in XLA. We\u2019ve distilled them into three core rules below:\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** We\u2019ve put a lot of effort into rewriting our TensorFlow models and loss functions to be XLA-compatible. Our models and loss functions generally obey rule #1 and #2 by default, so you can skip over them if you\u2019re using `transformers` models. Don\u2019t forget about these rules when writing your own models and loss functions, though!\n\n</Tip>\n\n#### XLA Rule #1: Your code cannot have \u201cdata-dependent conditionals\u201d\n\nWhat that means is that any `if` statement cannot depend on values inside a `tf.Tensor`. For example, this code block cannot be compiled with XLA!\n\n```python\nif tf.reduce_sum(tensor) > 10:\n    tensor = tensor / 2.0\n```\n\nThis might seem very restrictive at first, but most neural net code doesn\u2019t need to do this. You can often get around this restriction by using `tf.cond` (see the documentation [here](https://www.tensorflow.org/api_docs/python/tf/cond)) or by removing the conditional and finding a clever math trick with indicator variables instead, like so:\n\n```python\nsum_over_10 = tf.cast(tf.reduce_sum(tensor) > 10, tf.float32)\ntensor = tensor / (1.0 + sum_over_10)\n```\n\nThis code has exactly the same effect as the code above, but by avoiding a conditional, we ensure it will compile with XLA without problems!\n\n#### XLA Rule #2: Your code cannot have \u201cdata-dependent shapes\u201d\n\nWhat this means is that the shape of all of the `tf.Tensor` objects in your code cannot depend on their values. For example, the function `tf.unique` cannot be compiled with XLA, because it returns a `tensor` containing one instance of each unique value in the input. The shape of this output will obviously be different depending on how repetitive the input `Tensor` was, and so XLA refuses to handle it!\n\nIn general, most neural network code obeys rule #2 by default. However, there are a few common cases where it becomes a problem. One very common one is when you use **label masking**, setting your labels to a negative value to indicate that those positions should be ignored when computing the loss. If you look at NumPy or PyTorch loss functions that support label masking, you will often see code like this that uses [boolean indexing](https://numpy.org/doc/stable/user/basics.indexing.html#boolean-array-indexing):\n\n```python\nlabel_mask = labels >= 0\nmasked_outputs = outputs[label_mask]\nmasked_labels = labels[label_mask]\nloss = compute_loss(masked_outputs, masked_labels)\nmean_loss = torch.mean(loss)\n```\n\nThis code is totally fine in NumPy or PyTorch, but it breaks in XLA! Why? Because the shape of `masked_outputs` and `masked_labels` depends on how many positions are masked - that makes it a **data-dependent shape.** However, just like for rule #1, we can often rewrite this code to yield exactly the same output without any data-dependent shapes.\n\n```python\nlabel_mask = tf.cast(labels >= 0, tf.float32)\nloss = compute_loss(outputs, labels)\nloss = loss * label_mask  # Set negative label positions to 0\nmean_loss = tf.reduce_sum(loss) / tf.reduce_sum(label_mask)\n```\n\nHere, we avoid data-dependent shapes by computing the loss for every position, but zeroing out the masked positions in both the numerator and denominator when we calculate the mean, which yields exactly the same result as the first block while maintaining XLA compatibility. Note that we use the same trick as in rule #1 - converting a `tf.bool` to `\n3,\tState in Blocks\n\nWe covered [State in Interfaces](https://gradio.app/interface-state), this guide takes a look at state in Blocks, which works mostly the same.\n\n## Global State\n\nGlobal state in Blocks works the same as in Interface. Any variable created outside a function call is a reference shared between all users.\n\n## Session State\n\nGradio supports session **state**, where data persists across multiple submits within a page session, in Blocks apps as well. To reiterate, session data is _not_ shared between different users of your model. To store data in a session state, you need to do three things:\n\n1. Create a `gr.State()` object. If there is a default value to this stateful object, pass that into the constructor.\n2. In the event listener, put the `State` object as an input and output.\n3. In the event listener function, add the variable to the input parameters and the return value.\n\nLet's take a look at a game of hangman.\n\n$code_hangman\n$demo_hangman\n\nLet's see how we do each of the 3 steps listed above in this game:\n\n1. We store the used letters in `used_letters_var`. In the constructor of `State`, we set the initial value of this to `[]`, an empty list.\n2. In `btn.click()`, we have a reference to `used_letters_var` in both the inputs and outputs.\n3. In `guess_letter`, we pass the value of this `State` to `used_letters`, and then return an updated value of this `State` in the return statement.\n\nWith more complex apps, you will likely have many State variables storing session state in a single Blocks app.\n\nLearn more about `State` in the [docs](https://gradio.app/docs#state).\n4,\tGradio Demo: blocks_random_slider\n\n\n```\n!pip install -q gradio \n```\n\n\n```\n\nimport gradio as gr\n\n\ndef func(slider_1, slider_2):\n    return slider_1 * 5 + slider_2\n\n\nwith gr.Blocks() as demo:\n    slider = gr.Slider(minimum=-10.2, maximum=15, label=\"Random Slider (Static)\", randomize=True)\n    slider_1 = gr.Slider(minimum=100, maximum=200, label=\"Random Slider (Input 1)\", randomize=True)\n    slider_2 = gr.Slider(minimum=10, maximum=23.2, label=\"Random Slider (Input 2)\", randomize=True)\n    slider_3 = gr.Slider(value=3, label=\"Non random slider\")\n    btn = gr.Button(\"Run\")\n    btn.click(func, inputs=[slider_1, slider_2], outputs=gr.Number())\n\nif __name__ == \"__main__\":\n    demo.launch()\n\n```\n    ```",
            "vector_context": "[Created at: 2025-03-24 13:19:17]\n!---\nCopyright 2022 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n-->\n\n# Token classification with LayoutLMv3 (PyTorch version)\n\nThis directory contains a script, `run_funsd_cord.py`, that can be used to fine-tune (or evaluate) LayoutLMv3 on form understanding datasets, such as [FUNSD](https://guillaumejaume.github.io/FUNSD/) and [CORD](https://github.com/clovaai/cord).\n\nThe script `run_funsd_cord.py` leverages the \ud83e\udd17 Datasets library and the Trainer API. You can easily customize it to your needs.\n\n## Fine-tuning on FUNSD\n\nFine-tuning LayoutLMv3 for token classification on [FUNSD](https://guillaumejaume.github.io/FUNSD/) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name funsd \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 1e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-funsd\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd. By specifying the `push_to_hub` flag, the model gets uploaded automatically to the hub (regularly), together with a model card, which includes metrics such as precision, recall and F1. Note that you can easily update the model card, as it's just a README file of the respective repo on the hub.\n\nThere's also the \"Training metrics\" [tab](https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd/tensorboard), which shows Tensorboard logs over the course of training. Pretty neat, huh?\n\n## Fine-tuning on CORD\n\nFine-tuning LayoutLMv3 for token classification on [CORD](https://github.com/clovaai/cord) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name cord \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 5e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-cord\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-cord. Note that a model card gets generated automatically in case you specify the `push_to_hub` flag.\n--New Chunk--\n[Created at: 2025-03-24 13:18:21]\nGradio Demo: blocks_random_slider\n\n\n```\n!pip install -q gradio \n```\n\n\n```\n\nimport gradio as gr\n\n\ndef func(slider_1, slider_2):\n    return slider_1 * 5 + slider_2\n\n\nwith gr.Blocks() as demo:\n    slider = gr.Slider(minimum=-10.2, maximum=15, label=\"Random Slider (Static)\", randomize=True)\n    slider_1 = gr.Slider(minimum=100, maximum=200, label=\"Random Slider (Input 1)\", randomize=True)\n    slider_2 = gr.Slider(minimum=10, maximum=23.2, label=\"Random Slider (Input 2)\", randomize=True)\n    slider_3 = gr.Slider(value=3, label=\"Non random slider\")\n    btn = gr.Button(\"Run\")\n    btn.click(func, inputs=[slider_1, slider_2], outputs=gr.Number())\n\nif __name__ == \"__main__\":\n    demo.launch()\n\n```\n--New Chunk--\n[Created at: 2025-03-24 13:16:48]\n\u4e0e\u5e38\u89c4\u51fd\u6570\u76f8\u540c\u7684\u65b9\u5f0f\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio\u3002\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\uff08\u865a\u62df\u7684\uff09\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5b83\u5728\u8f93\u51fa\u56fe\u50cf\u4e4b\u524d\u751f\u6210\u6570\u4e2a\u6b65\u9aa4\u7684\u566a\u97f3\uff1a\n\n$code_fake_diffusion\n$demo_fake_diffusion\n\n\u8bf7\u6ce8\u610f\uff0c\u6211\u4eec\u5728\u8fed\u4ee3\u5668\u4e2d\u6dfb\u52a0\u4e86 `time.sleep(1)`\uff0c\u4ee5\u521b\u5efa\u6b65\u9aa4\u4e4b\u95f4\u7684\u4eba\u5de5\u6682\u505c\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u89c2\u5bdf\u8fed\u4ee3\u5668\u7684\u6b65\u9aa4\uff08\u5728\u771f\u5b9e\u7684\u56fe\u50cf\u751f\u6210\u6a21\u578b\u4e2d\uff0c\u8fd9\u53ef\u80fd\u662f\u4e0d\u5fc5\u8981\u7684\uff09\u3002\n\n\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio **\u9700\u8981**\u5728\u5e95\u5c42 Interface \u6216 Blocks \u4e2d\u542f\u7528\u961f\u5217\uff08\u8bf7\u53c2\u9605\u4e0a\u9762\u7684\u961f\u5217\u90e8\u5206\uff09\u3002\n\n## \u8fdb\u5ea6\u6761\n\nGradio \u652f\u6301\u521b\u5efa\u81ea\u5b9a\u4e49\u8fdb\u5ea6\u6761\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u81ea\u5b9a\u4e49\u548c\u63a7\u5236\u5411\u7528\u6237\u663e\u793a\u7684\u8fdb\u5ea6\u66f4\u65b0\u3002\u8981\u542f\u7528\u6b64\u529f\u80fd\uff0c\u53ea\u9700\u4e3a\u65b9\u6cd5\u6dfb\u52a0\u4e00\u4e2a\u9ed8\u8ba4\u503c\u4e3a `gr.Progress` \u5b9e\u4f8b\u7684\u53c2\u6570\u5373\u53ef\u3002\u7136\u540e\uff0c\u60a8\u53ef\u4ee5\u76f4\u63a5\u8c03\u7528\u6b64\u5b9e\u4f8b\u5e76\u4f20\u5165 0 \u5230 1 \u4e4b\u95f4\u7684\u6d6e\u70b9\u6570\u6765\u66f4\u65b0\u8fdb\u5ea6\u7ea7\u522b\uff0c\u6216\u8005 with `Progress` \u5b9e\u4f8b\u7684 `tqdm()` \u65b9\u6cd5\u6765\u8ddf\u8e2a\u53ef\u8fed\u4ee3\u5bf9\u8c61\u4e0a\u7684\u8fdb\u5ea6\uff0c\u5982\u4e0b\u6240\u793a\u3002\u5fc5\u987b\u542f\u7528\u961f\u5217\u4ee5\u8fdb\u884c\u8fdb\u5ea6\u66f4\u65b0\u3002\n\n$code_progress_simple\n$demo_progress_simple\n\n\u5982\u679c\u60a8 with `tqdm` \u5e93\uff0c\u5e76\u4e14\u5e0c\u671b\u4ece\u51fd\u6570\u5185\u90e8\u7684\u4efb\u4f55 `tqdm.tqdm` \u81ea\u52a8\u62a5\u544a\u8fdb\u5ea6\u66f4\u65b0\uff0c\u8bf7\u5c06\u9ed8\u8ba4\u53c2\u6570\u8bbe\u7f6e\u4e3a `gr.Progress(track_tqdm=True)`\uff01\n\n## \u6279\u5904\u7406\u51fd\u6570 (Batch Functions)\n\nGradio \u652f\u6301\u4f20\u9012*\u6279\u5904\u7406*\u51fd\u6570\u3002\u6279\u5904\u7406\u51fd\u6570\u53ea\u662f\u63a5\u53d7\u8f93\u5165\u5217\u8868\u5e76\u8fd4\u56de\u9884\u6d4b\u5217\u8868\u7684\u51fd\u6570\u3002\n\n\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\u6279\u5904\u7406\u51fd\u6570\uff0c\u5b83\u63a5\u53d7\u4e24\u4e2a\u8f93\u5165\u5217\u8868\uff08\u4e00\u4e2a\u5355\u8bcd\u5217\u8868\u548c\u4e00\u4e2a\u6574\u6570\u5217\u8868\uff09\uff0c\u5e76\u8fd4\u56de\u4fee\u526a\u8fc7\u7684\u5355\u8bcd\u5217\u8868\u4f5c\u4e3a\u8f93\u51fa\uff1a\n\n```python\nimport time\n\ndef trim_words(words, lens):\n    trimmed_words = []\n    time.sleep(5)\n    for w, l in zip(words, lens):\n        trimmed_words.append(w[:int(l)])\n    return [trimmed_words]\n    for w, l in zip(words, lens):\n```\n\n\u4f7f\u7528\u6279\u5904\u7406\u51fd\u6570\u7684\u4f18\u70b9\u662f\uff0c\u5982\u679c\u542f\u7528\u4e86\u961f\u5217\uff0cGradio \u670d\u52a1\u5668\u53ef\u4ee5\u81ea\u52a8*\u6279\u5904\u7406*\u4f20\u5165\u7684\u8bf7\u6c42\u5e76\u5e76\u884c\u5904\u7406\u5b83\u4eec\uff0c\u4ece\u800c\u53ef\u80fd\u52a0\u5feb\u6f14\u793a\u901f\u5ea6\u3002\u4ee5\u4e0b\u662f Gradio \u4ee3\u7801\u7684\u793a\u4f8b\uff08\u8bf7\u6ce8\u610f `batch=True` \u548c `max_batch_size=16` - \u8fd9\u4e24\u4e2a\u53c2\u6570\u90fd\u53ef\u4ee5\u4f20\u9012\u7ed9\u4e8b\u4ef6\u89e6\u53d1\u5668\u6216 `Interface` \u7c7b\uff09\n\nwith `Interface`\uff1a\n\n```python\ndemo = gr.Interface(trim_words, [\"textbox\", \"number\"], [\"output\"],\n                    batch=True, max_batch_size=16)\ndemo.queue()\ndemo.launch()\n```\n\nwith `Blocks`\uff1a\n\n```python\nimport gradio as gr\n\nwith gr.Blocks() as demo:\n    with gr.Row():\n        word = gr.Textbox(label=\"word\")\n        leng = gr.Number(label=\"leng\")\n        output = gr.Textbox(label=\"Output\")\n    with gr.Row():\n        run = gr.Button()\n\n    event = run.click(trim_words, [word, leng], output, batch=True, max_batch_size=16)\n\ndemo.queue()\ndemo.launch()\n```\n\n\u5728\u4e0a\u9762\u7684\u793a\u4f8b\u4e2d\uff0c\u53ef\u4ee5\u5e76\u884c\u5904\u7406 16 \u4e2a\u8bf7\u6c42\uff08\u603b\u63a8\u7406\u65f6\u95f4\u4e3a 5 \u79d2\uff09\uff0c\u800c\u4e0d\u662f\u5206\u522b\u5904\u7406\u6bcf\u4e2a\u8bf7\u6c42\uff08\u603b\u63a8\u7406\u65f6\u95f4\u4e3a 80 \u79d2\uff09\u3002\u8bb8\u591a Hugging Face \u7684 `transformers` \u548c `diffusers` \u6a21\u578b\u5728 Gradio \u7684\u6279\u5904\u7406\u6a21\u5f0f\u4e0b\u81ea\u7136\u5de5\u4f5c\uff1a\u8fd9\u662f[\u4f7f\u7528\u6279\u5904\u7406\u751f\u6210\u56fe\u50cf\u7684\u793a\u4f8b\u6f14\u793a](https://github.com/gradio-app/gradio/blob/main/demo/diffusers_with_batching/run.py)\n\n\u6ce8\u610f\uff1a\u4f7f\u7528 Gradio \u7684\u6279\u5904\u7406\u51fd\u6570 **requires** \u5728\u5e95\u5c42 Interface \u6216 Blocks \u4e2d\u542f\u7528\u961f\u5217\uff08\u8bf7\u53c2\u9605\u4e0a\u9762\u7684\u961f\u5217\u90e8\u5206\uff09\u3002\n\n## Gradio \u7b14\u8bb0\u672c (Colab Notebooks)\n\nGradio \u53ef\u4ee5\u5728\u4efb\u4f55\u8fd0\u884c Python \u7684\u5730\u65b9\u8fd0\u884c\uff0c\u5305\u62ec\u672c\u5730 Jupyter \u7b14\u8bb0\u672c\u548c\u534f\u4f5c\u7b14\u8bb0\u672c\uff0c\u5982[Google Colab](https://colab.research.google.com/)\u3002\u5bf9\u4e8e\u672c\u5730 Jupyter \u7b14\u8bb0\u672c\u548c Google Colab \u7b14\u8bb0\u672c\uff0cGradio \u5728\u672c\u5730\u670d\u52a1\u5668\u4e0a\u8fd0\u884c\uff0c\u60a8\u53ef\u4ee5\u5728\u6d4f\u89c8\u5668\u4e2d\u4e0e\u4e4b\u4ea4\u4e92\u3002\uff08\u6ce8\u610f\uff1a\u5bf9\u4e8e Google Colab\uff0c\u8fd9\u662f\u901a\u8fc7[\u670d\u52a1\u5de5\u4f5c\u5668\u96a7\u9053](https://github.com/tensorflow/tensorboard/blob/master/docs/design/colab_integration.md)\u5b9e\u73b0\u7684\uff0c\u60a8\u7684\u6d4f\u89c8\u5668\u9700\u8981\u542f\u7528 cookies\u3002\uff09\u5bf9\u4e8e\u5176\u4ed6\u8fdc\u7a0b\u7b14\u8bb0\u672c\uff0cGradio \u4e5f\u5c06\u5728\u670d\u52a1\u5668\u4e0a\u8fd0\u884c\uff0c\u4f46\u60a8\u9700\u8981\u4f7f\u7528[SSH \u96a7\u9053](https://coderwall.com/p/ohk6cg/remote-access-to-ipython-notebooks-via-ssh)\u5728\u672c\u5730\u6d4f\u89c8\u5668\u4e2d\u67e5\u770b\u5e94\u7528\u7a0b\u5e8f\u3002\u901a\u5e38\uff0c\u66f4\u7b80\u5355\u7684\u9009\u62e9\u662f\u4f7f\u7528 Gradio \u5185\u7f6e\u7684\u516c\u5171\u94fe\u63a5\uff0c[\u5728\u4e0b\u4e00\u7bc7\u6307\u5357\u4e2d\u8ba8\u8bba](/sharing-your-app/#sharing-demos)\u3002"
        }
    },
    {
        "sample_idx": 101,
        "question": "What datasets can the script run_funsd_cord.py be used with?",
        "answer": "The script run_funsd_cord.py can be used with form understanding datasets such as FUNSD and CORD.",
        "rag_answer": "The script `run_funsd_cord.py` can be used to fine-tune (or evaluate) LayoutLMv3 on form understanding datasets, specifically [FUNSD](https://guillaumejaume.github.io/FUNSD/) and [CORD](https://github.com/clovaai/cord).",
        "rag_score": null,
        "rag_feedback": null,
        "rag_context": {
            "kg_context": "-----Entities-----\n    ```csv\n    id,\tentity,\ttype,\tdescription,\trankcreated_at\n1,\tBatch Functions,category,Batch Functions is a category of functions in Gradio that enables the processing of batches of inputs.,1,2025-03-24 13:17:31\n2,\tGradio,organization,Gradio is a platform that supports state in Blocks, providing features such as global state and session state.<SEP>Gradio is an interface that provides various features for demonstrating models, including adding example inputs, custom error messages, descriptive content, flagging, and more.<SEP>Gradio is an organization that provides a platform for building and deploying machine learning models.<SEP>Gradio is an organization that provides a platform for creating and deploying machine learning models.<SEP>Gradio is an organization that provides a demo for blocks_random_slider, and its library is used to create interactive interfaces.,36,2025-03-24 13:17:31\n3,\tnumpy,technology,numpy is a type of numerical computing library that can be used with Gradio components.,1,2025-03-24 13:17:31\n4,\tPreprocessing and Postprocessing,category,Preprocessing and Postprocessing are features in Gradio that allow users to process data before and after it is input into a model.,1,2025-03-24 13:17:31\n5,\t run_funsd_cord.py,event,run_funsd_cord.py is a script used for fine-tuning the LayoutLMv3 model.,0,UNKNOWN\n6,\tCORD,geo,CORD is a form understanding dataset used for fine-tuning LayoutLMv3.,1,UNKNOWN\n7,\tFUNSD,geo,FUNSD is a form understanding dataset used for fine-tuning LayoutLMv3.,1,UNKNOWN\n    ```\n    -----Relationships-----\n    ```csv\n    id,\tsource,\ttarget,\tdescription,\tkeywords,\tweight,\trank,\tcreated_at\n1,\tBatch Functions,Gradio,Gradio supports batch processing of inputs using batch functions.,functionality, batch processing,18.0,37,2025-03-24 13:17:31\n2,\tGradio,numpy,Gradio can use numpy library for numerical computing.,library integration, numerical computing,14.0,37,2025-03-24 13:17:31\n3,\tGradio,Preprocessing and Postprocessing,Gradio provides features for preprocessing and postprocessing data.,data processing, interface feature,8.0,37,2025-03-24 13:17:31\n4,\tCORD,LayoutLMv3,CORD is a dataset used for fine-tuning the LayoutLMv3 model.,dataset, model training,14.0,12,UNKNOWN\n5,\tFUNSD,LayoutLMv3,FUNSD is a dataset used for fine-tuning the LayoutLMv3 model.,dataset, model training,14.0,12,UNKNOWN\n    ```\n    -----Sources-----\n    ```csv\n    id,\tcontent\n1,\t\u4e0e\u5e38\u89c4\u51fd\u6570\u76f8\u540c\u7684\u65b9\u5f0f\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio\u3002\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\uff08\u865a\u62df\u7684\uff09\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5b83\u5728\u8f93\u51fa\u56fe\u50cf\u4e4b\u524d\u751f\u6210\u6570\u4e2a\u6b65\u9aa4\u7684\u566a\u97f3\uff1a\n\n$code_fake_diffusion\n$demo_fake_diffusion\n\n\u8bf7\u6ce8\u610f\uff0c\u6211\u4eec\u5728\u8fed\u4ee3\u5668\u4e2d\u6dfb\u52a0\u4e86 `time.sleep(1)`\uff0c\u4ee5\u521b\u5efa\u6b65\u9aa4\u4e4b\u95f4\u7684\u4eba\u5de5\u6682\u505c\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u89c2\u5bdf\u8fed\u4ee3\u5668\u7684\u6b65\u9aa4\uff08\u5728\u771f\u5b9e\u7684\u56fe\u50cf\u751f\u6210\u6a21\u578b\u4e2d\uff0c\u8fd9\u53ef\u80fd\u662f\u4e0d\u5fc5\u8981\u7684\uff09\u3002\n\n\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio **\u9700\u8981**\u5728\u5e95\u5c42 Interface \u6216 Blocks \u4e2d\u542f\u7528\u961f\u5217\uff08\u8bf7\u53c2\u9605\u4e0a\u9762\u7684\u961f\u5217\u90e8\u5206\uff09\u3002\n\n## \u8fdb\u5ea6\u6761\n\nGradio \u652f\u6301\u521b\u5efa\u81ea\u5b9a\u4e49\u8fdb\u5ea6\u6761\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u81ea\u5b9a\u4e49\u548c\u63a7\u5236\u5411\u7528\u6237\u663e\u793a\u7684\u8fdb\u5ea6\u66f4\u65b0\u3002\u8981\u542f\u7528\u6b64\u529f\u80fd\uff0c\u53ea\u9700\u4e3a\u65b9\u6cd5\u6dfb\u52a0\u4e00\u4e2a\u9ed8\u8ba4\u503c\u4e3a `gr.Progress` \u5b9e\u4f8b\u7684\u53c2\u6570\u5373\u53ef\u3002\u7136\u540e\uff0c\u60a8\u53ef\u4ee5\u76f4\u63a5\u8c03\u7528\u6b64\u5b9e\u4f8b\u5e76\u4f20\u5165 0 \u5230 1 \u4e4b\u95f4\u7684\u6d6e\u70b9\u6570\u6765\u66f4\u65b0\u8fdb\u5ea6\u7ea7\u522b\uff0c\u6216\u8005 with `Progress` \u5b9e\u4f8b\u7684 `tqdm()` \u65b9\u6cd5\u6765\u8ddf\u8e2a\u53ef\u8fed\u4ee3\u5bf9\u8c61\u4e0a\u7684\u8fdb\u5ea6\uff0c\u5982\u4e0b\u6240\u793a\u3002\u5fc5\u987b\u542f\u7528\u961f\u5217\u4ee5\u8fdb\u884c\u8fdb\u5ea6\u66f4\u65b0\u3002\n\n$code_progress_simple\n$demo_progress_simple\n\n\u5982\u679c\u60a8 with `tqdm` \u5e93\uff0c\u5e76\u4e14\u5e0c\u671b\u4ece\u51fd\u6570\u5185\u90e8\u7684\u4efb\u4f55 `tqdm.tqdm` \u81ea\u52a8\u62a5\u544a\u8fdb\u5ea6\u66f4\u65b0\uff0c\u8bf7\u5c06\u9ed8\u8ba4\u53c2\u6570\u8bbe\u7f6e\u4e3a `gr.Progress(track_tqdm=True)`\uff01\n\n## \u6279\u5904\u7406\u51fd\u6570 (Batch Functions)\n\nGradio \u652f\u6301\u4f20\u9012*\u6279\u5904\u7406*\u51fd\u6570\u3002\u6279\u5904\u7406\u51fd\u6570\u53ea\u662f\u63a5\u53d7\u8f93\u5165\u5217\u8868\u5e76\u8fd4\u56de\u9884\u6d4b\u5217\u8868\u7684\u51fd\u6570\u3002\n\n\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\u6279\u5904\u7406\u51fd\u6570\uff0c\u5b83\u63a5\u53d7\u4e24\u4e2a\u8f93\u5165\u5217\u8868\uff08\u4e00\u4e2a\u5355\u8bcd\u5217\u8868\u548c\u4e00\u4e2a\u6574\u6570\u5217\u8868\uff09\uff0c\u5e76\u8fd4\u56de\u4fee\u526a\u8fc7\u7684\u5355\u8bcd\u5217\u8868\u4f5c\u4e3a\u8f93\u51fa\uff1a\n\n```python\nimport time\n\ndef trim_words(words, lens):\n    trimmed_words = []\n    time.sleep(5)\n    for w, l in zip(words, lens):\n        trimmed_words.append(w[:int(l)])\n    return [trimmed_words]\n    for w, l in zip(words, lens):\n```\n\n\u4f7f\u7528\u6279\u5904\u7406\u51fd\u6570\u7684\u4f18\u70b9\u662f\uff0c\u5982\u679c\u542f\u7528\u4e86\u961f\u5217\uff0cGradio \u670d\u52a1\u5668\u53ef\u4ee5\u81ea\u52a8*\u6279\u5904\u7406*\u4f20\u5165\u7684\u8bf7\u6c42\u5e76\u5e76\u884c\u5904\u7406\u5b83\u4eec\uff0c\u4ece\u800c\u53ef\u80fd\u52a0\u5feb\u6f14\u793a\u901f\u5ea6\u3002\u4ee5\u4e0b\u662f Gradio \u4ee3\u7801\u7684\u793a\u4f8b\uff08\u8bf7\u6ce8\u610f `batch=True` \u548c `max_batch_size=16` - \u8fd9\u4e24\u4e2a\u53c2\u6570\u90fd\u53ef\u4ee5\u4f20\u9012\u7ed9\u4e8b\u4ef6\u89e6\u53d1\u5668\u6216 `Interface` \u7c7b\uff09\n\nwith `Interface`\uff1a\n\n```python\ndemo = gr.Interface(trim_words, [\"textbox\", \"number\"], [\"output\"],\n                    batch=True, max_batch_size=16)\ndemo.queue()\ndemo.launch()\n```\n\nwith `Blocks`\uff1a\n\n```python\nimport gradio as gr\n\nwith gr.Blocks() as demo:\n    with gr.Row():\n        word = gr.Textbox(label=\"word\")\n        leng = gr.Number(label=\"leng\")\n        output = gr.Textbox(label=\"Output\")\n    with gr.Row():\n        run = gr.Button()\n\n    event = run.click(trim_words, [word, leng], output, batch=True, max_batch_size=16)\n\ndemo.queue()\ndemo.launch()\n```\n\n\u5728\u4e0a\u9762\u7684\u793a\u4f8b\u4e2d\uff0c\u53ef\u4ee5\u5e76\u884c\u5904\u7406 16 \u4e2a\u8bf7\u6c42\uff08\u603b\u63a8\u7406\u65f6\u95f4\u4e3a 5 \u79d2\uff09\uff0c\u800c\u4e0d\u662f\u5206\u522b\u5904\u7406\u6bcf\u4e2a\u8bf7\u6c42\uff08\u603b\u63a8\u7406\u65f6\u95f4\u4e3a 80 \u79d2\uff09\u3002\u8bb8\u591a Hugging Face \u7684 `transformers` \u548c `diffusers` \u6a21\u578b\u5728 Gradio \u7684\u6279\u5904\u7406\u6a21\u5f0f\u4e0b\u81ea\u7136\u5de5\u4f5c\uff1a\u8fd9\u662f[\u4f7f\u7528\u6279\u5904\u7406\u751f\u6210\u56fe\u50cf\u7684\u793a\u4f8b\u6f14\u793a](https://github.com/gradio-app/gradio/blob/main/demo/diffusers_with_batching/run.py)\n\n\u6ce8\u610f\uff1a\u4f7f\u7528 Gradio \u7684\u6279\u5904\u7406\u51fd\u6570 **requires** \u5728\u5e95\u5c42 Interface \u6216 Blocks \u4e2d\u542f\u7528\u961f\u5217\uff08\u8bf7\u53c2\u9605\u4e0a\u9762\u7684\u961f\u5217\u90e8\u5206\uff09\u3002\n\n## Gradio \u7b14\u8bb0\u672c (Colab Notebooks)\n\nGradio \u53ef\u4ee5\u5728\u4efb\u4f55\u8fd0\u884c Python \u7684\u5730\u65b9\u8fd0\u884c\uff0c\u5305\u62ec\u672c\u5730 Jupyter \u7b14\u8bb0\u672c\u548c\u534f\u4f5c\u7b14\u8bb0\u672c\uff0c\u5982[Google Colab](https://colab.research.google.com/)\u3002\u5bf9\u4e8e\u672c\u5730 Jupyter \u7b14\u8bb0\u672c\u548c Google Colab \u7b14\u8bb0\u672c\uff0cGradio \u5728\u672c\u5730\u670d\u52a1\u5668\u4e0a\u8fd0\u884c\uff0c\u60a8\u53ef\u4ee5\u5728\u6d4f\u89c8\u5668\u4e2d\u4e0e\u4e4b\u4ea4\u4e92\u3002\uff08\u6ce8\u610f\uff1a\u5bf9\u4e8e Google Colab\uff0c\u8fd9\u662f\u901a\u8fc7[\u670d\u52a1\u5de5\u4f5c\u5668\u96a7\u9053](https://github.com/tensorflow/tensorboard/blob/master/docs/design/colab_integration.md)\u5b9e\u73b0\u7684\uff0c\u60a8\u7684\u6d4f\u89c8\u5668\u9700\u8981\u542f\u7528 cookies\u3002\uff09\u5bf9\u4e8e\u5176\u4ed6\u8fdc\u7a0b\u7b14\u8bb0\u672c\uff0cGradio \u4e5f\u5c06\u5728\u670d\u52a1\u5668\u4e0a\u8fd0\u884c\uff0c\u4f46\u60a8\u9700\u8981\u4f7f\u7528[SSH \u96a7\u9053](https://coderwall.com/p/ohk6cg/remote-access-to-ipython-notebooks-via-ssh)\u5728\u672c\u5730\u6d4f\u89c8\u5668\u4e2d\u67e5\u770b\u5e94\u7528\u7a0b\u5e8f\u3002\u901a\u5e38\uff0c\u66f4\u7b80\u5355\u7684\u9009\u62e9\u662f\u4f7f\u7528 Gradio \u5185\u7f6e\u7684\u516c\u5171\u94fe\u63a5\uff0c[\u5728\u4e0b\u4e00\u7bc7\u6307\u5357\u4e2d\u8ba8\u8bba](/sharing-your-app/#sharing-demos)\u3002\n2,\t\u65f6\u5fc5\u987b\u9009\u62e9\u5176\u4e2d\u4e00\u4e2a\u5b57\u7b26\u4e32\uff0c\u8fd9\u5c06\u4f5c\u4e3a\u9644\u52a0\u5217\u4fdd\u5b58\u5230 CSV \u4e2d\u3002\n\n## \u9884\u5904\u7406\u548c\u540e\u5904\u7406 (Preprocessing and Postprocessing)\n\n![annotated](/assets/img/dataflow.svg)\n\n\u5982\u60a8\u6240\u89c1\uff0cGradio \u5305\u62ec\u53ef\u4ee5\u5904\u7406\u5404\u79cd\u4e0d\u540c\u6570\u636e\u7c7b\u578b\u7684\u7ec4\u4ef6\uff0c\u4f8b\u5982\u56fe\u50cf\u3001\u97f3\u9891\u548c\u89c6\u9891\u3002\u5927\u591a\u6570\u7ec4\u4ef6\u90fd\u53ef\u4ee5\u7528\u4f5c\u8f93\u5165\u6216\u8f93\u51fa\u3002\n\n\u5f53\u7ec4\u4ef6\u7528\u4f5c\u8f93\u5165\u65f6\uff0cGradio \u81ea\u52a8\u5904\u7406*\u9884\u5904\u7406*\uff0c\u5c06\u6570\u636e\u4ece\u7528\u6237\u6d4f\u89c8\u5668\u53d1\u9001\u7684\u7c7b\u578b\uff08\u4f8b\u5982\u7f51\u7edc\u6444\u50cf\u5934\u5feb\u7167\u7684 base64 \u8868\u793a\uff09\u8f6c\u6362\u4e3a\u60a8\u7684\u51fd\u6570\u53ef\u4ee5\u63a5\u53d7\u7684\u5f62\u5f0f\uff08\u4f8b\u5982 `numpy` \u6570\u7ec4\uff09\u3002\n\n\u540c\u6837\uff0c\u5f53\u7ec4\u4ef6\u7528\u4f5c\u8f93\u51fa\u65f6\uff0cGradio \u81ea\u52a8\u5904\u7406*\u540e\u5904\u7406*\uff0c\u5c06\u6570\u636e\u4ece\u51fd\u6570\u8fd4\u56de\u7684\u5f62\u5f0f\uff08\u4f8b\u5982\u56fe\u50cf\u8def\u5f84\u5217\u8868\uff09\u8f6c\u6362\u4e3a\u53ef\u4ee5\u5728\u7528\u6237\u6d4f\u89c8\u5668\u4e2d\u663e\u793a\u7684\u5f62\u5f0f\uff08\u4f8b\u5982\u4ee5 base64 \u683c\u5f0f\u663e\u793a\u56fe\u50cf\u7684 `Gallery`\uff09\u3002\n\n\u60a8\u53ef\u4ee5\u4f7f\u7528\u6784\u5efa\u56fe\u50cf\u7ec4\u4ef6\u65f6\u7684\u53c2\u6570\u63a7\u5236*\u9884\u5904\u7406*\u3002\u4f8b\u5982\uff0c\u5982\u679c\u60a8\u4f7f\u7528\u4ee5\u4e0b\u53c2\u6570\u5b9e\u4f8b\u5316 `Image` \u7ec4\u4ef6\uff0c\u5b83\u5c06\u5c06\u56fe\u50cf\u8f6c\u6362\u4e3a `PIL` \u7c7b\u578b\uff0c\u5e76\u5c06\u5176\u91cd\u5851\u4e3a`(100, 100)`\uff0c\u800c\u4e0d\u7ba1\u63d0\u4ea4\u65f6\u7684\u539f\u59cb\u5927\u5c0f\u5982\u4f55\uff1a\n\n```py\nimg = gr.Image(shape=(100, 100), type=\"pil\")\n```\n\n\u76f8\u53cd\uff0c\u8fd9\u91cc\u6211\u4eec\u4fdd\u7559\u56fe\u50cf\u7684\u539f\u59cb\u5927\u5c0f\uff0c\u4f46\u5728\u5c06\u5176\u8f6c\u6362\u4e3a numpy \u6570\u7ec4\u4e4b\u524d\u53cd\u8f6c\u989c\u8272\uff1a\n\n```py\nimg = gr.Image(invert_colors=True, type=\"numpy\")\n```\n\n\u540e\u5904\u7406\u8981\u5bb9\u6613\u5f97\u591a\uff01Gradio \u81ea\u52a8\u8bc6\u522b\u8fd4\u56de\u6570\u636e\u7684\u683c\u5f0f\uff08\u4f8b\u5982 `Image` \u662f `numpy` \u6570\u7ec4\u8fd8\u662f `str` \u6587\u4ef6\u8def\u5f84\uff1f\uff09\uff0c\u5e76\u5c06\u5176\u540e\u5904\u7406\u4e3a\u53ef\u4ee5\u7531\u6d4f\u89c8\u5668\u663e\u793a\u7684\u683c\u5f0f\u3002\n\n\u8bf7\u67e5\u770b[\u6587\u6863](https://gradio.app/docs)\uff0c\u4e86\u89e3\u6bcf\u4e2a\u7ec4\u4ef6\u7684\u6240\u6709\u4e0e\u9884\u5904\u7406\u76f8\u5173\u7684\u53c2\u6570\u3002\n\n## \u6837\u5f0f (Styling)\n\nGradio \u4e3b\u9898\u662f\u81ea\u5b9a\u4e49\u5e94\u7528\u7a0b\u5e8f\u5916\u89c2\u548c\u611f\u89c9\u7684\u6700\u7b80\u5355\u65b9\u6cd5\u3002\u60a8\u53ef\u4ee5\u9009\u62e9\u591a\u79cd\u4e3b\u9898\u6216\u521b\u5efa\u81ea\u5df1\u7684\u4e3b\u9898\u3002\u8981\u8fd9\u6837\u505a\uff0c\u8bf7\u5c06 `theme=` \u53c2\u6570\u4f20\u9012\u7ed9 `Interface` \u6784\u9020\u51fd\u6570\u3002\u4f8b\u5982\uff1a\n\n```python\ndemo = gr.Interface(..., theme=gr.themes.Monochrome())\n```\n\nGradio \u5e26\u6709\u4e00\u7ec4\u9884\u5148\u6784\u5efa\u7684\u4e3b\u9898\uff0c\u60a8\u53ef\u4ee5\u4ece `gr.themes.*` \u52a0\u8f7d\u3002\u60a8\u53ef\u4ee5\u6269\u5c55\u8fd9\u4e9b\u4e3b\u9898\u6216\u4ece\u5934\u5f00\u59cb\u521b\u5efa\u81ea\u5df1\u7684\u4e3b\u9898 - \u6709\u5173\u66f4\u591a\u8be6\u7ec6\u4fe1\u606f\uff0c\u8bf7\u53c2\u9605[\u4e3b\u9898\u6307\u5357](https://gradio.app/theming-guide)\u3002\n\n\u8981\u589e\u52a0\u989d\u5916\u7684\u6837\u5f0f\u80fd\u529b\uff0c\u60a8\u53ef\u4ee5 with `css=` \u5173\u952e\u5b57\u5c06\u4efb\u4f55 CSS \u4f20\u9012\u7ed9\u60a8\u7684\u5e94\u7528\u7a0b\u5e8f\u3002\nGradio \u5e94\u7528\u7a0b\u5e8f\u7684\u57fa\u7c7b\u662f `gradio-container`\uff0c\u56e0\u6b64\u4ee5\u4e0b\u662f\u4e00\u4e2a\u66f4\u6539 Gradio \u5e94\u7528\u7a0b\u5e8f\u80cc\u666f\u989c\u8272\u7684\u793a\u4f8b\uff1a\n\n```python\nwith `gr.Interface(css=\".gradio-container {background-color: red}\") as demo:\n    ...\n```\n\n## \u961f\u5217 (Queuing)\n\n\u5982\u679c\u60a8\u7684\u5e94\u7528\u7a0b\u5e8f\u9884\u8ba1\u4f1a\u6709\u5927\u91cf\u6d41\u91cf\uff0c\u8bf7 with `queue()` \u65b9\u6cd5\u6765\u63a7\u5236\u5904\u7406\u901f\u7387\u3002\u8fd9\u5c06\u6392\u961f\u5904\u7406\u8c03\u7528\uff0c\u56e0\u6b64\u4e00\u6b21\u53ea\u5904\u7406\u4e00\u5b9a\u6570\u91cf\u7684\u8bf7\u6c42\u3002\u961f\u5217\u4f7f\u7528 Websockets\uff0c\u8fd8\u53ef\u4ee5\u9632\u6b62\u7f51\u7edc\u8d85\u65f6\uff0c\u56e0\u6b64\u5982\u679c\u60a8\u7684\u51fd\u6570\u7684\u63a8\u7406\u65f6\u95f4\u5f88\u957f\uff08> 1 \u5206\u949f\uff09\uff0c\u5e94\u4f7f\u7528\u961f\u5217\u3002\n\nwith `Interface`\uff1a\n\n```python\ndemo = gr.Interface(...).queue()\ndemo.launch()\n```\n\nwith `Blocks`\uff1a\n\n```python\nwith gr.Blocks() as demo\uff1a\n    #...\ndemo.queue()\ndemo.launch()\n```\n\n\u60a8\u53ef\u4ee5\u901a\u8fc7\u4ee5\u4e0b\u65b9\u5f0f\u63a7\u5236\u4e00\u6b21\u5904\u7406\u7684\u8bf7\u6c42\u6570\u91cf\uff1a\n\n```python\ndemo.queue(concurrency_count=3)\n```\n\n\u67e5\u770b\u6709\u5173\u914d\u7f6e\u5176\u4ed6\u961f\u5217\u53c2\u6570\u7684[\u961f\u5217\u6587\u6863](/docs/#queue)\u3002\n\n\u5728 Blocks \u4e2d\u6307\u5b9a\u4ec5\u5bf9\u67d0\u4e9b\u51fd\u6570\u8fdb\u884c\u6392\u961f\uff1a\n\n```python\nwith gr.Blocks() as demo2\uff1a\n    num1 = gr.Number()\n    num2 = gr.Number()\n    output = gr.Number()\n    gr.Button(\"Add\").click(\n        lambda a, b: a + b, [num1, num2], output)\n    gr.Button(\"Multiply\").click(\n        lambda a, b: a * b, [num1, num2], output, queue=True)\ndemo2.launch()\n```\n\n## \u8fed\u4ee3\u8f93\u51fa (Iterative Outputs)\n\n\u5728\u67d0\u4e9b\u60c5\u51b5\u4e0b\uff0c\u60a8\u53ef\u80fd\u9700\u8981\u4f20\u8f93\u4e00\u7cfb\u5217\u8f93\u51fa\u800c\u4e0d\u662f\u4e00\u6b21\u663e\u793a\u5355\u4e2a\u8f93\u51fa\u3002\u4f8b\u5982\uff0c\u60a8\u53ef\u80fd\u6709\u4e00\u4e2a\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5e0c\u671b\u663e\u793a\u751f\u6210\u7684\u6bcf\u4e2a\u6b65\u9aa4\u7684\u56fe\u50cf\uff0c\u76f4\u5230\u6700\u7ec8\u56fe\u50cf\u3002\u6216\u8005\u60a8\u53ef\u80fd\u6709\u4e00\u4e2a\u804a\u5929\u673a\u5668\u4eba\uff0c\u5b83\u9010\u5b57\u9010\u53e5\u5730\u6d41\u5f0f\u4f20\u8f93\u54cd\u5e94\uff0c\u800c\u4e0d\u662f\u4e00\u6b21\u8fd4\u56de\u5168\u90e8\u54cd\u5e94\u3002\n\n\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u60a8\u53ef\u4ee5\u5c06**\u751f\u6210\u5668**\u51fd\u6570\u63d0\u4f9b\u7ed9 Gradio\uff0c\u800c\u4e0d\u662f\u5e38\u89c4\u51fd\u6570\u3002\u5728 Python \u4e2d\u521b\u5efa\u751f\u6210\u5668\u975e\u5e38\u7b80\u5355\uff1a\u51fd\u6570\u4e0d\u5e94\u8be5\u6709\u4e00\u4e2a\u5355\u72ec\u7684 `return` \u503c\uff0c\u800c\u662f\u5e94\u8be5 with `yield` \u8fde\u7eed\u8fd4\u56de\u4e00\u7cfb\u5217\u503c\u3002\u901a\u5e38\uff0c`yield` \u8bed\u53e5\u653e\u7f6e\u5728\u67d0\u79cd\u5faa\u73af\u4e2d\u3002\u4e0b\u9762\u662f\u4e00\u4e2a\u7b80\u5355\u793a\u4f8b\uff0c\u751f\u6210\u5668\u53ea\u662f\u7b80\u5355\u8ba1\u6570\u5230\u7ed9\u5b9a\u6570\u5b57\uff1a\n\n```python\ndef my_generator(x):\n    for i in range(x):\n        yield i\n```\n\n\u60a8\u4ee5\u4e0e\u5e38\u89c4\u51fd\u6570\u76f8\u540c\u7684\u65b9\u5f0f\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio\u3002\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\uff08\u865a\u62df\u7684\uff09\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5b83\u5728\u8f93\u51fa\u56fe\u50cf\u4e4b\u524d\u751f\u6210\u6570\u4e2a\u6b65\u9aa4\u7684\u566a\u97f3\uff1a\n\n$code_fake_diffusion\n$demo_fake_diffusion\n\n\u8bf7\u6ce8\u610f\uff0c\u6211\u4eec\u5728\u8fed\u4ee3\u5668\u4e2d\u6dfb\u52a0\u4e86 `time.sleep(1)`\uff0c\u4ee5\u521b\u5efa\u6b65\u9aa4\u4e4b\u95f4\u7684\u4eba\u5de5\u6682\u505c\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u89c2\u5bdf\u8fed\u4ee3\u5668\u7684\u6b65\u9aa4\uff08\u5728\u771f\u5b9e\u7684\u56fe\u50cf\u751f\u6210\u6a21\u578b\u4e2d\uff0c\u8fd9\n3,\t\u4e3b\u8981\u7279\u70b9\n\n\u8ba9\u6211\u4eec\u6765\u4ecb\u7ecd\u4e00\u4e0b Gradio \u6700\u53d7\u6b22\u8fce\u7684\u4e00\u4e9b\u529f\u80fd\uff01\u8fd9\u91cc\u662f Gradio \u7684\u4e3b\u8981\u7279\u70b9\uff1a\n\n1. [\u6dfb\u52a0\u793a\u4f8b\u8f93\u5165](#example-inputs)\n2. [\u4f20\u9012\u81ea\u5b9a\u4e49\u9519\u8bef\u6d88\u606f](#errors)\n3. [\u6dfb\u52a0\u63cf\u8ff0\u5185\u5bb9](#descriptive-content)\n4. [\u8bbe\u7f6e\u65d7\u6807](#flagging)\n5. [\u9884\u5904\u7406\u548c\u540e\u5904\u7406](#preprocessing-and-postprocessing)\n6. [\u6837\u5f0f\u5316\u6f14\u793a](#styling)\n7. [\u6392\u961f\u7528\u6237](#queuing)\n8. [\u8fed\u4ee3\u8f93\u51fa](#iterative-outputs)\n9. [\u8fdb\u5ea6\u6761](#progress-bars)\n10. [\u6279\u5904\u7406\u51fd\u6570](#batch-functions)\n11. [\u5728\u534f\u4f5c\u7b14\u8bb0\u672c\u4e0a\u8fd0\u884c](#colab-notebooks)\n\n## \u793a\u4f8b\u8f93\u5165\n\n\u60a8\u53ef\u4ee5\u63d0\u4f9b\u7528\u6237\u53ef\u4ee5\u8f7b\u677e\u52a0\u8f7d\u5230 \"Interface\" \u4e2d\u7684\u793a\u4f8b\u6570\u636e\u3002\u8fd9\u5bf9\u4e8e\u6f14\u793a\u6a21\u578b\u671f\u671b\u7684\u8f93\u5165\u7c7b\u578b\u4ee5\u53ca\u6f14\u793a\u6570\u636e\u96c6\u548c\u6a21\u578b\u4e00\u8d77\u63a2\u7d22\u7684\u65b9\u5f0f\u975e\u5e38\u6709\u5e2e\u52a9\u3002\u8981\u52a0\u8f7d\u793a\u4f8b\u6570\u636e\uff0c\u60a8\u53ef\u4ee5\u5c06\u5d4c\u5957\u5217\u8868\u63d0\u4f9b\u7ed9 Interface \u6784\u9020\u51fd\u6570\u7684 `examples=` \u5173\u952e\u5b57\u53c2\u6570\u3002\u5916\u90e8\u5217\u8868\u4e2d\u7684\u6bcf\u4e2a\u5b50\u5217\u8868\u8868\u793a\u4e00\u4e2a\u6570\u636e\u6837\u672c\uff0c\u5b50\u5217\u8868\u4e2d\u7684\u6bcf\u4e2a\u5143\u7d20\u8868\u793a\u6bcf\u4e2a\u8f93\u5165\u7ec4\u4ef6\u7684\u8f93\u5165\u3002\u6709\u5173\u6bcf\u4e2a\u7ec4\u4ef6\u7684\u793a\u4f8b\u6570\u636e\u683c\u5f0f\u5728[Docs](https://gradio.app/docs#components)\u4e2d\u6709\u8bf4\u660e\u3002\n\n$code_calculator\n$demo_calculator\n\n\u60a8\u53ef\u4ee5\u5c06\u5927\u578b\u6570\u636e\u96c6\u52a0\u8f7d\u5230\u793a\u4f8b\u4e2d\uff0c\u901a\u8fc7 Gradio \u6d4f\u89c8\u548c\u4e0e\u6570\u636e\u96c6\u8fdb\u884c\u4ea4\u4e92\u3002\u793a\u4f8b\u5c06\u81ea\u52a8\u5206\u9875\uff08\u53ef\u4ee5\u901a\u8fc7 Interface \u7684 `examples_per_page` \u53c2\u6570\u8fdb\u884c\u914d\u7f6e\uff09\u3002\n\n\u7ee7\u7eed\u4e86\u89e3\u793a\u4f8b\uff0c\u8bf7\u53c2\u9605[\u66f4\u591a\u793a\u4f8b](https://gradio.app/more-on-examples)\u6307\u5357\u3002\n\n## \u9519\u8bef\n\n\u60a8\u5e0c\u671b\u5411\u7528\u6237\u4f20\u9012\u81ea\u5b9a\u4e49\u9519\u8bef\u6d88\u606f\u3002\u4e3a\u6b64\uff0cwith `gr.Error(\"custom message\")` \u6765\u663e\u793a\u9519\u8bef\u6d88\u606f\u3002\u5982\u679c\u5728\u4e0a\u9762\u7684\u8ba1\u7b97\u5668\u793a\u4f8b\u4e2d\u5c1d\u8bd5\u9664\u4ee5\u96f6\uff0c\u5c06\u663e\u793a\u81ea\u5b9a\u4e49\u9519\u8bef\u6d88\u606f\u7684\u5f39\u51fa\u6a21\u6001\u7a97\u53e3\u3002\u4e86\u89e3\u6709\u5173\u9519\u8bef\u7684\u66f4\u591a\u4fe1\u606f\uff0c\u8bf7\u53c2\u9605[\u6587\u6863](https://gradio.app/docs#error)\u3002\n\n## \u63cf\u8ff0\u6027\u5185\u5bb9\n\n\u5728\u524d\u9762\u7684\u793a\u4f8b\u4e2d\uff0c\u60a8\u53ef\u80fd\u5df2\u7ecf\u6ce8\u610f\u5230 Interface \u6784\u9020\u51fd\u6570\u4e2d\u7684 `title=` \u548c `description=` \u5173\u952e\u5b57\u53c2\u6570\uff0c\u5e2e\u52a9\u7528\u6237\u4e86\u89e3\u60a8\u7684\u5e94\u7528\u7a0b\u5e8f\u3002\n\nInterface \u6784\u9020\u51fd\u6570\u4e2d\u6709\u4e09\u4e2a\u53c2\u6570\u7528\u4e8e\u6307\u5b9a\u6b64\u5185\u5bb9\u5e94\u653e\u7f6e\u5728\u54ea\u91cc\uff1a\n\n- `title`\uff1a\u63a5\u53d7\u6587\u672c\uff0c\u5e76\u53ef\u4ee5\u5c06\u5176\u663e\u793a\u5728\u754c\u9762\u7684\u9876\u90e8\uff0c\u4e5f\u5c06\u6210\u4e3a\u9875\u9762\u6807\u9898\u3002\n- `description`\uff1a\u63a5\u53d7\u6587\u672c\u3001Markdown \u6216 HTML\uff0c\u5e76\u5c06\u5176\u653e\u7f6e\u5728\u6807\u9898\u6b63\u4e0b\u65b9\u3002\n- `article`\uff1a\u4e5f\u63a5\u53d7\u6587\u672c\u3001Markdown \u6216 HTML\uff0c\u5e76\u5c06\u5176\u653e\u7f6e\u5728\u754c\u9762\u4e0b\u65b9\u3002\n\n![annotated](/assets/guides/annotated.png)\n\n\u5982\u679c\u60a8\u4f7f\u7528\u7684\u662f `Blocks` API\uff0c\u5219\u53ef\u4ee5 with `gr.Markdown(...)` \u6216 `gr.HTML(...)` \u7ec4\u4ef6\u5728\u4efb\u4f55\u4f4d\u7f6e\u63d2\u5165\u6587\u672c\u3001Markdown \u6216 HTML\uff0c\u5176\u4e2d\u63cf\u8ff0\u6027\u5185\u5bb9\u4f4d\u4e8e `Component` \u6784\u9020\u51fd\u6570\u5185\u90e8\u3002\n\n\u53e6\u4e00\u4e2a\u6709\u7528\u7684\u5173\u952e\u5b57\u53c2\u6570\u662f `label=`\uff0c\u5b83\u5b58\u5728\u4e8e\u6bcf\u4e2a `Component` \u4e2d\u3002\u8fd9\u4fee\u6539\u4e86\u6bcf\u4e2a `Component` \u9876\u90e8\u7684\u6807\u7b7e\u6587\u672c\u3002\u8fd8\u53ef\u4ee5\u4e3a\u8bf8\u5982 `Textbox` \u6216 `Radio` \u4e4b\u7c7b\u7684\u8868\u5355\u5143\u7d20\u6dfb\u52a0 `info=` \u5173\u952e\u5b57\u53c2\u6570\uff0c\u4ee5\u63d0\u4f9b\u6709\u5173\u5176\u7528\u6cd5\u7684\u8fdb\u4e00\u6b65\u4fe1\u606f\u3002\n\n```python\ngr.Number(label='\u5e74\u9f84', info='\u4ee5\u5e74\u4e3a\u5355\u4f4d\uff0c\u5fc5\u987b\u5927\u4e8e0')\n```\n\n## \u65d7\u6807\n\n\u9ed8\u8ba4\u60c5\u51b5\u4e0b\uff0c\"Interface\" \u5c06\u6709\u4e00\u4e2a \"Flag\" \u6309\u94ae\u3002\u5f53\u7528\u6237\u6d4b\u8bd5\u60a8\u7684 `Interface` \u65f6\uff0c\u5982\u679c\u770b\u5230\u6709\u8da3\u7684\u8f93\u51fa\uff0c\u4f8b\u5982\u9519\u8bef\u6216\u610f\u5916\u7684\u6a21\u578b\u884c\u4e3a\uff0c\u4ed6\u4eec\u53ef\u4ee5\u5c06\u8f93\u5165\u6807\u8bb0\u4e3a\u60a8\u8fdb\u884c\u67e5\u770b\u3002\u5728\u7531 `Interface` \u6784\u9020\u51fd\u6570\u7684 `flagging_dir=` \u53c2\u6570\u63d0\u4f9b\u7684\u76ee\u5f55\u4e2d\uff0c\u5c06\u8bb0\u5f55\u6807\u8bb0\u7684\u8f93\u5165\u5230\u4e00\u4e2a CSV \u6587\u4ef6\u4e2d\u3002\u5982\u679c\u754c\u9762\u6d89\u53ca\u6587\u4ef6\u6570\u636e\uff0c\u4f8b\u5982\u56fe\u50cf\u548c\u97f3\u9891\u7ec4\u4ef6\uff0c\u5c06\u521b\u5efa\u6587\u4ef6\u5939\u6765\u5b58\u50a8\u8fd9\u4e9b\u6807\u8bb0\u7684\u6570\u636e\u3002\n\n\u4f8b\u5982\uff0c\u5bf9\u4e8e\u4e0a\u9762\u663e\u793a\u7684\u8ba1\u7b97\u5668\u754c\u9762\uff0c\u6211\u4eec\u5c06\u5728\u4e0b\u9762\u7684\u65d7\u6807\u76ee\u5f55\u4e2d\u5b58\u50a8\u6807\u8bb0\u7684\u6570\u636e\uff1a\n\n```directory\n+-- calculator.py\n+-- flagged/\n|   +-- logs.csv\n```\n\n_flagged/logs.csv_\n\n```csv\nnum1,operation,num2,Output\n5,add,7,12\n6,subtract,1.5,4.5\n```\n\n\u4e0e\u65e9\u671f\u663e\u793a\u7684\u51b7\u8272\u754c\u9762\u76f8\u5bf9\u5e94\uff0c\u6211\u4eec\u5c06\u5728\u4e0b\u9762\u7684\u65d7\u6807\u76ee\u5f55\u4e2d\u5b58\u50a8\u6807\u8bb0\u7684\u6570\u636e\uff1a\n\n```directory\n+-- sepia.py\n+-- flagged/\n|   +-- logs.csv\n|   +-- im/\n|   |   +-- 0.png\n|   |   +-- 1.png\n|   +-- Output/\n|   |   +-- 0.png\n|   |   +-- 1.png\n```\n\n_flagged/logs.csv_\n\n```csv\nim,Output\nim/0.png,Output/0.png\nim/1.png,Output/1.png\n```\n\n\u5982\u679c\u60a8\u5e0c\u671b\u7528\u6237\u63d0\u4f9b\u65d7\u6807\u539f\u56e0\uff0c\u53ef\u4ee5\u5c06\u5b57\u7b26\u4e32\u5217\u8868\u4f20\u9012\u7ed9 Interface \u7684 `flagging_options` \u53c2\u6570\u3002\u7528\u6237\u5728\u8fdb\u884c\u65d7\u6807\u65f6\u5fc5\u987b\u9009\u62e9\u5176\u4e2d\u4e00\u4e2a\u5b57\u7b26\u4e32\uff0c\u8fd9\u5c06\u4f5c\u4e3a\u9644\u52a0\u5217\u4fdd\u5b58\u5230 CSV \u4e2d\u3002\n\n## \u9884\u5904\u7406\u548c\u540e\u5904\u7406 (Preprocessing and Postprocessing)\n\n![annotated](/assets/img/dataflow.svg)\n\n\u5982\u60a8\u6240\u89c1\uff0cGradio \u5305\u62ec\u53ef\u4ee5\u5904\u7406\u5404\u79cd\u4e0d\u540c\u6570\u636e\u7c7b\u578b\u7684\u7ec4\u4ef6\uff0c\u4f8b\u5982\u56fe\u50cf\u3001\u97f3\u9891\u548c\u89c6\u9891\u3002\u5927\u591a\u6570\u7ec4\u4ef6\u90fd\u53ef\u4ee5\u7528\u4f5c\u8f93\u5165\u6216\u8f93\u51fa\u3002\n\n\u5f53\u7ec4\u4ef6\u7528\u4f5c\u8f93\u5165\u65f6\uff0cGradio \u81ea\u52a8\u5904\u7406*\u9884\u5904\u7406*\uff0c\u5c06\u6570\u636e\u4ece\u7528\u6237\n4,\t!---\nCopyright 2022 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n-->\n\n# Token classification with LayoutLMv3 (PyTorch version)\n\nThis directory contains a script, `run_funsd_cord.py`, that can be used to fine-tune (or evaluate) LayoutLMv3 on form understanding datasets, such as [FUNSD](https://guillaumejaume.github.io/FUNSD/) and [CORD](https://github.com/clovaai/cord).\n\nThe script `run_funsd_cord.py` leverages the \ud83e\udd17 Datasets library and the Trainer API. You can easily customize it to your needs.\n\n## Fine-tuning on FUNSD\n\nFine-tuning LayoutLMv3 for token classification on [FUNSD](https://guillaumejaume.github.io/FUNSD/) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name funsd \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 1e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-funsd\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd. By specifying the `push_to_hub` flag, the model gets uploaded automatically to the hub (regularly), together with a model card, which includes metrics such as precision, recall and F1. Note that you can easily update the model card, as it's just a README file of the respective repo on the hub.\n\nThere's also the \"Training metrics\" [tab](https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd/tensorboard), which shows Tensorboard logs over the course of training. Pretty neat, huh?\n\n## Fine-tuning on CORD\n\nFine-tuning LayoutLMv3 for token classification on [CORD](https://github.com/clovaai/cord) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name cord \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 5e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-cord\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-cord. Note that a model card gets generated automatically in case you specify the `push_to_hub` flag.\n    ```",
            "vector_context": "[Created at: 2025-03-24 13:19:17]\n!---\nCopyright 2022 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n-->\n\n# Token classification with LayoutLMv3 (PyTorch version)\n\nThis directory contains a script, `run_funsd_cord.py`, that can be used to fine-tune (or evaluate) LayoutLMv3 on form understanding datasets, such as [FUNSD](https://guillaumejaume.github.io/FUNSD/) and [CORD](https://github.com/clovaai/cord).\n\nThe script `run_funsd_cord.py` leverages the \ud83e\udd17 Datasets library and the Trainer API. You can easily customize it to your needs.\n\n## Fine-tuning on FUNSD\n\nFine-tuning LayoutLMv3 for token classification on [FUNSD](https://guillaumejaume.github.io/FUNSD/) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name funsd \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 1e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-funsd\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd. By specifying the `push_to_hub` flag, the model gets uploaded automatically to the hub (regularly), together with a model card, which includes metrics such as precision, recall and F1. Note that you can easily update the model card, as it's just a README file of the respective repo on the hub.\n\nThere's also the \"Training metrics\" [tab](https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd/tensorboard), which shows Tensorboard logs over the course of training. Pretty neat, huh?\n\n## Fine-tuning on CORD\n\nFine-tuning LayoutLMv3 for token classification on [CORD](https://github.com/clovaai/cord) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name cord \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 5e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-cord\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-cord. Note that a model card gets generated automatically in case you specify the `push_to_hub` flag.\n--New Chunk--\n[Created at: 2025-03-24 13:16:13]\n=predictions, references=references)\n>>> results\n{'exact_match': 100.0, 'f1': 100.0}\n```\n\nYou can find examples of dataset structures by consulting the \"Dataset Preview\" function or the dataset card for a given dataset, and you can see how to use its dedicated evaluation function based on the metric card.\n--New Chunk--\n[Created at: 2025-03-24 13:17:32]\n!--Copyright 2023 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\nthe License. You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under the License is distributed on\nan \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n\n\u26a0\ufe0f Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be\nrendered properly in your Markdown viewer.\n\n-->\n\n# Training on TPU with TensorFlow\n\n<Tip>\n\nIf you don't need long explanations and just want TPU code samples to get started with, check out [our TPU example notebook!](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb)\n\n</Tip>\n\n### What is a TPU?\n\nA TPU is a **Tensor Processing Unit.** They are hardware designed by Google, which are used to greatly speed up the tensor computations within neural networks, much like GPUs. They can be used for both network training and inference. They are generally accessed through Google\u2019s cloud services, but small TPUs can also be accessed directly for free through Google Colab and Kaggle Kernels.\n\nBecause [all TensorFlow models in \ud83e\udd17 Transformers are Keras models](https://huggingface.co/blog/tensorflow-philosophy), most of the methods in this document are generally applicable to TPU training for any Keras model! However, there are a few points that are specific to the HuggingFace ecosystem (hug-o-system?) of Transformers and Datasets, and we\u2019ll make sure to flag them up when we get to them.\n\n### What kinds of TPU are available?\n\nNew users are often very confused by the range of TPUs, and the different ways to access them. The first key distinction to understand is the difference between **TPU Nodes** and **TPU VMs.**\n\nWhen you use a **TPU Node**, you are effectively indirectly accessing a remote TPU. You will need a separate VM, which will initialize your network and data pipeline and then forward them to the remote node. When you use a TPU on Google Colab, you are accessing it in the **TPU Node** style.\n\nUsing TPU Nodes can have some quite unexpected behaviour for people who aren\u2019t used to them! In particular, because the TPU is located on a physically different system to the machine you\u2019re running your Python code on, your data cannot be local to your machine - any data pipeline that loads from your machine\u2019s internal storage will totally fail! Instead, data must be stored in Google Cloud Storage where your data pipeline can still access it, even when the pipeline is running on the remote TPU node.\n\n<Tip>\n\nIf you can fit all your data in memory as `np.ndarray` or `tf.Tensor`, then you can `fit()` on that data even when using Colab or a TPU Node, without needing to upload it to Google Cloud Storage.\n\n</Tip>\n\n<Tip>\n\n**\ud83e\udd17Specific Hugging Face Tip\ud83e\udd17:** The methods `Dataset.to_tf_dataset()` and its higher-level wrapper `model.prepare_tf_dataset()` , which you will see throughout our TF code examples, will both fail on a TPU Node. The reason for this is that even though they create a `tf.data.Dataset` it is not a \u201cpure\u201d `tf.data` pipeline and uses `tf.numpy_function` or `Dataset.from_generator()` to stream data from the underlying HuggingFace `Dataset`. This HuggingFace `Dataset` is backed by data that is on a local disc and which the remote TPU Node will not be able to read.\n\n</Tip>\n\nThe second way to access a TPU is via a **TPU VM.** When using a TPU VM, you connect directly to the machine that the TPU is attached to, much like training on a GPU VM. TPU VMs are generally easier to work with, particularly when it comes to your data pipeline. All of the above warnings do not apply to TPU VMs!\n\nThis is an opinionated document, so here\u2019s our opinion: **Avoid using TPU Node if possible.** It is more confusing and more difficult to debug than TPU VMs. It is also likely to be unsupported in future - Google\u2019s latest TPU, TPUv4, can only be accessed as a TPU VM, which suggests that TPU Nodes are increasingly going to become a \u201clegacy\u201d access method. However, we understand that the only free TPU access is on Colab and Kaggle Kernels, which uses TPU Node - so we\u2019ll try to explain how to handle it if you have to! Check the [TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) for code samples that explain this in more detail.\n\n### What sizes of TPU are available?\n\nA single TPU (a v2-8/v3-8/v4-8) runs 8 replicas. TPUs exist in **pods** that can run hundreds or thousands of replicas simultaneously. When you use more than a single TPU but less than a whole pod (for example, a v3-32), your TPU fleet is referred to as a **pod slice.**\n\nWhen you access a free TPU via Colab, you generally get a single v2-8 TPU.\n\n### I keep hearing about this XLA thing. What\u2019s XLA, and how does it relate to TPUs?\n\nXLA is an optimizing compiler, used by both TensorFlow and JAX. In JAX it is the only compiler, whereas in TensorFlow it is optional"
        }
    },
    {
        "sample_idx": 102,
        "question": "What is the name of the model that can be fine-tuned for token classification on FUNSD?",
        "answer": "The model that can be fine-tuned for token classification on FUNSD is LayoutLMv3-base.",
        "rag_answer": "The model that can be fine-tuned for token classification on FUNSD is LayoutLMv3.",
        "rag_score": 4,
        "rag_feedback": "The response is mostly correct, accurate, and factual. It provides a detailed explanation of how to fine-tune LayoutLMv3 for token classification on FUNSD, including the script and parameters to use. However, it also includes a lot of extraneous information from the context, such as the license and copyright notice, and explanations of generic metrics and task-specific metrics, which are not directly relevant to the question.",
        "rag_context": {
            "kg_context": "-----Entities-----\n    ```csv\n    id,\tentity,\ttype,\tdescription,\trankcreated_at\n1,\tFUNSD,geo,FUNSD is a form understanding dataset used for fine-tuning LayoutLMv3.,1,2025-03-24 13:18:20\n2,\tLayoutLMv3,technology,LayoutLMv3 is a model used for token classification and form understanding tasks.,11,2025-03-24 13:18:20\n3,\tMachine Learning,category,Machine Learning is a field of study that involves training models to make predictions.,5,2025-03-24 13:18:20\n4,\tModel,category,Model refers to a machine learning model being evaluated.,3,2025-03-24 13:18:20\n5,\tKeras,category,Keras is a high-level neural networks API, used for building and training neural networks.<SEP>Keras is a machine learning framework that uses XLA for optimization.,2,2025-03-24 13:18:20\n6,\tXLA,technology,XLA is a technology that compiles TensorFlow graphs into executable code for various platforms.<SEP>XLA is an optimizing compiler used by TensorFlow and JAX to improve performance.<SEP>XLA is an optimizing compiler, used by both TensorFlow and JAX to optimize computations.,6,2025-03-24 13:18:20\n7,\tNamed Entity Recognition,event,Named Entity Recognition is an event or task in natural language processing.,1,UNKNOWN\n8,\tFUNSD,geo,FUNSD is a form understanding dataset used for fine-tuning LayoutLMv3.,1,UNKNOWN\n9,\tdistilbert-base-uncased-finetuned-sst-2-english,category,distilbert-base-uncased-finetuned-sst-2-english is a specific AI model for text classification.,1,UNKNOWN\n    ```\n    -----Relationships-----\n    ```csv\n    id,\tsource,\ttarget,\tdescription,\tkeywords,\tweight,\trank,\tcreated_at\n1,\tFUNSD,LayoutLMv3,FUNSD is a dataset used for fine-tuning the LayoutLMv3 model.,dataset, model training,14.0,12,2025-03-24 13:19:57\n2,\tMachine Learning,Model,Machine Learning involves training models to make predictions.,field of study, model training,9.0,8,2025-03-24 13:16:48\n3,\tKeras,XLA,Keras uses XLA for optimization.,compiler, performance optimization,8.0,8,2025-03-24 13:18:20\n4,\tFUNSD,LayoutLMv3,FUNSD is a dataset used for fine-tuning the LayoutLMv3 model.,dataset, model training,14.0,12,UNKNOWN\n5,\tHugging Face,distilbert-base-uncased-finetuned-sst-2-english,Hugging Face provides a platform for deploying the distilbert-base-uncased-finetuned-sst-2-english model.,platform, model deployment,18.0,9,UNKNOWN\n6,\tNamed Entity Recognition,seqeval,seqeval is a metric used to evaluate named entity recognition models.,evaluation metric, task,9.0,2,UNKNOWN\n    ```\n    -----Sources-----\n    ```csv\n    id,\tcontent\n1,\t!---\nCopyright 2022 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n-->\n\n# Token classification with LayoutLMv3 (PyTorch version)\n\nThis directory contains a script, `run_funsd_cord.py`, that can be used to fine-tune (or evaluate) LayoutLMv3 on form understanding datasets, such as [FUNSD](https://guillaumejaume.github.io/FUNSD/) and [CORD](https://github.com/clovaai/cord).\n\nThe script `run_funsd_cord.py` leverages the \ud83e\udd17 Datasets library and the Trainer API. You can easily customize it to your needs.\n\n## Fine-tuning on FUNSD\n\nFine-tuning LayoutLMv3 for token classification on [FUNSD](https://guillaumejaume.github.io/FUNSD/) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name funsd \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 1e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-funsd\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd. By specifying the `push_to_hub` flag, the model gets uploaded automatically to the hub (regularly), together with a model card, which includes metrics such as precision, recall and F1. Note that you can easily update the model card, as it's just a README file of the respective repo on the hub.\n\nThere's also the \"Training metrics\" [tab](https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd/tensorboard), which shows Tensorboard logs over the course of training. Pretty neat, huh?\n\n## Fine-tuning on CORD\n\nFine-tuning LayoutLMv3 for token classification on [CORD](https://github.com/clovaai/cord) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name cord \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 5e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-cord\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-cord. Note that a model card gets generated automatically in case you specify the `push_to_hub` flag.\n2,\t=predictions, references=references)\n>>> results\n{'exact_match': 100.0, 'f1': 100.0}\n```\n\nYou can find examples of dataset structures by consulting the \"Dataset Preview\" function or the dataset card for a given dataset, and you can see how to use its dedicated evaluation function based on the metric card.\n3,\t(for example, a v3-32), your TPU fleet is referred to as a **pod slice.**\n\nWhen you access a free TPU via Colab, you generally get a single v2-8 TPU.\n\n### I keep hearing about this XLA thing. What\u2019s XLA, and how does it relate to TPUs?\n\nXLA is an optimizing compiler, used by both TensorFlow and JAX. In JAX it is the only compiler, whereas in TensorFlow it is optional (but mandatory on TPU!). The easiest way to enable it when training a Keras model is to pass the argument `jit_compile=True` to `model.compile()`. If you don\u2019t get any errors and performance is good, that\u2019s a great sign that you\u2019re ready to move to TPU!\n\nDebugging on TPU is generally a bit harder than on CPU/GPU, so we recommend getting your code running on CPU/GPU with XLA first before trying it on TPU. You don\u2019t have to train for long, of course - just for a few steps to make sure that your model and data pipeline are working like you expect them to.\n\n<Tip>\n\nXLA compiled code is usually faster - so even if you\u2019re not planning to run on TPU, adding `jit_compile=True` can improve your performance. Be sure to note the caveats below about XLA compatibility, though!\n\n</Tip>\n\n<Tip warning={true}>\n\n**Tip born of painful experience:** Although using `jit_compile=True` is a good way to get a speed boost and test if your CPU/GPU code is XLA-compatible, it can actually cause a lot of problems if you leave it in when actually training on TPU. XLA compilation will happen implicitly on TPU, so remember to remove that line before actually running your code on a TPU!\n\n</Tip>\n\n### How do I make my model XLA compatible?\n\nIn many cases, your code is probably XLA-compatible already! However, there are a few things that work in normal TensorFlow that don\u2019t work in XLA. We\u2019ve distilled them into three core rules below:\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** We\u2019ve put a lot of effort into rewriting our TensorFlow models and loss functions to be XLA-compatible. Our models and loss functions generally obey rule #1 and #2 by default, so you can skip over them if you\u2019re using `transformers` models. Don\u2019t forget about these rules when writing your own models and loss functions, though!\n\n</Tip>\n\n#### XLA Rule #1: Your code cannot have \u201cdata-dependent conditionals\u201d\n\nWhat that means is that any `if` statement cannot depend on values inside a `tf.Tensor`. For example, this code block cannot be compiled with XLA!\n\n```python\nif tf.reduce_sum(tensor) > 10:\n    tensor = tensor / 2.0\n```\n\nThis might seem very restrictive at first, but most neural net code doesn\u2019t need to do this. You can often get around this restriction by using `tf.cond` (see the documentation [here](https://www.tensorflow.org/api_docs/python/tf/cond)) or by removing the conditional and finding a clever math trick with indicator variables instead, like so:\n\n```python\nsum_over_10 = tf.cast(tf.reduce_sum(tensor) > 10, tf.float32)\ntensor = tensor / (1.0 + sum_over_10)\n```\n\nThis code has exactly the same effect as the code above, but by avoiding a conditional, we ensure it will compile with XLA without problems!\n\n#### XLA Rule #2: Your code cannot have \u201cdata-dependent shapes\u201d\n\nWhat this means is that the shape of all of the `tf.Tensor` objects in your code cannot depend on their values. For example, the function `tf.unique` cannot be compiled with XLA, because it returns a `tensor` containing one instance of each unique value in the input. The shape of this output will obviously be different depending on how repetitive the input `Tensor` was, and so XLA refuses to handle it!\n\nIn general, most neural network code obeys rule #2 by default. However, there are a few common cases where it becomes a problem. One very common one is when you use **label masking**, setting your labels to a negative value to indicate that those positions should be ignored when computing the loss. If you look at NumPy or PyTorch loss functions that support label masking, you will often see code like this that uses [boolean indexing](https://numpy.org/doc/stable/user/basics.indexing.html#boolean-array-indexing):\n\n```python\nlabel_mask = labels >= 0\nmasked_outputs = outputs[label_mask]\nmasked_labels = labels[label_mask]\nloss = compute_loss(masked_outputs, masked_labels)\nmean_loss = torch.mean(loss)\n```\n\nThis code is totally fine in NumPy or PyTorch, but it breaks in XLA! Why? Because the shape of `masked_outputs` and `masked_labels` depends on how many positions are masked - that makes it a **data-dependent shape.** However, just like for rule #1, we can often rewrite this code to yield exactly the same output without any data-dependent shapes.\n\n```python\nlabel_mask = tf.cast(labels >= 0, tf.float32)\nloss = compute_loss(outputs, labels)\nloss = loss * label_mask  # Set negative label positions to 0\nmean_loss = tf.reduce_sum(loss) / tf.reduce_sum(label_mask)\n```\n\nHere, we avoid data-dependent shapes by computing the loss for every position, but zeroing out the masked positions in both the numerator and denominator when we calculate the mean, which yields exactly the same result as the first block while maintaining XLA compatibility. Note that we use the same trick as in rule #1 - converting a `tf.bool` to `\n4,\tChoosing a metric for your task\n\n**So you've trained your model and want to see how well it\u2019s doing on a dataset of your choice. Where do you start?**\n\nThere is no \u201cone size fits all\u201d approach to choosing an evaluation metric, but some good guidelines to keep in mind are:\n\n## Categories of metrics\n\nThere are 3 high-level categories of metrics:\n\n1. *Generic metrics*, which can be applied to a variety of situations and datasets, such as precision and accuracy.\n2. *Task-specific metrics*, which are limited to a given task, such as Machine Translation (often evaluated using metrics [BLEU](https://huggingface.co/metrics/bleu) or [ROUGE](https://huggingface.co/metrics/rouge)) or Named Entity Recognition (often evaluated with [seqeval](https://huggingface.co/metrics/seqeval)).\n3. *Dataset-specific metrics*, which aim to measure model performance on specific benchmarks: for instance, the [GLUE benchmark](https://huggingface.co/datasets/glue) has a dedicated [evaluation metric](https://huggingface.co/metrics/glue).\n\nLet's look at each of these three cases:\n\n### Generic metrics\n\nMany of the metrics used in the Machine Learning community are quite generic and can be applied in a variety of tasks and datasets.\n\nThis is the case for metrics like [accuracy](https://huggingface.co/metrics/accuracy) and [precision](https://huggingface.co/metrics/precision), which can be used for evaluating labeled (supervised) datasets, as well as [perplexity](https://huggingface.co/metrics/perplexity), which can be used for evaluating different kinds of (unsupervised) generative tasks.\n\nTo see the input structure of a given metric, you can look at its metric card. For example, in the case of [precision](https://huggingface.co/metrics/precision), the format is:\n```\n>>> precision_metric = evaluate.load(\"precision\")\n>>> results = precision_metric.compute(references=[0, 1], predictions=[0, 1])\n>>> print(results)\n{'precision': 1.0}\n```\n\n### Task-specific metrics\n\nPopular ML tasks like Machine Translation and Named Entity Recognition have specific metrics that can be used to compare models. For example, a series of different metrics have been proposed for text generation, ranging from [BLEU](https://huggingface.co/metrics/bleu) and its derivatives such as [GoogleBLEU](https://huggingface.co/metrics/google_bleu) and [GLEU](https://huggingface.co/metrics/gleu), but also [ROUGE](https://huggingface.co/metrics/rouge), [MAUVE](https://huggingface.co/metrics/mauve), etc.\n\nYou can find the right metric for your task by:\n\n- **Looking at the [Task pages](https://huggingface.co/tasks)** to see what metrics can be used for evaluating models for a given task.\n- **Checking out leaderboards** on sites like [Papers With Code](https://paperswithcode.com/) (you can search by task and by dataset).\n-  **Reading the metric cards** for the relevant metrics and see which ones are a good fit for your use case. For example, see the [BLEU metric card](https://github.com/huggingface/evaluate/tree/main/metrics/bleu) or [SQuaD metric card](https://github.com/huggingface/evaluate/tree/main/metrics/squad).\n- **Looking at papers and blog posts** published on the topic and see what metrics they report. This can change over time, so try to pick papers from the last couple of years!\n\n### Dataset-specific metrics\n\nSome datasets have specific metrics associated with them -- this is especially in the case of popular benchmarks like [GLUE](https://huggingface.co/metrics/glue) and [SQuAD](https://huggingface.co/metrics/squad).\n\n<Tip warning={true}>\n\ud83d\udca1\nGLUE is actually a collection of different subsets on different tasks, so first you need to choose the one that corresponds to the NLI task, such as mnli, which is described as \u201ccrowdsourced collection of sentence pairs with textual entailment annotations\u201d\n</Tip>\n\n\nIf you are evaluating your model on a benchmark dataset like the ones mentioned above, you can use its dedicated evaluation metric. Make sure you respect the format that they require. For example, to evaluate your model on the [SQuAD](https://huggingface.co/datasets/squad) dataset, you need to feed the `question` and `context` into your model and return the `prediction_text`, which should be compared with the `references` (based on matching the `id` of the question) :\n\n```\n>>> from evaluate import load\n>>> squad_metric = load(\"squad\")\n>>> predictions = [{'prediction_text': '1976', 'id': '56e10a3be3433e1400422b22'}]\n>>> references = [{'answers': {'answer_start': [97], 'text': ['1976']}, 'id': '56e10a3be3433e1400422b22'}]\n>>> results = squad_metric.compute(predictions=predictions, references=references)\n>>> results\n{'exact_match': 100.0, 'f1': 100.0}\n```\n\nYou can find examples of dataset structures by consulting the \"Dataset Preview\" function or the dataset card for a given dataset, and you can see how to use its dedicated evaluation function based on the metric card.\n5,\tCreate an Endpoint\n\nAfter your first login, you will be directed to the [Endpoint creation page](https://ui.endpoints.huggingface.co/new). As an example, this guide will go through the steps to deploy [distilbert-base-uncased-finetuned-sst-2-english](https://huggingface.co/distilbert-base-uncased-finetuned-sst-2-english) for text classification. \n\n## 1. Enter the Hugging Face Repository ID and your desired endpoint name:\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_repository.png\" alt=\"select repository\" />\n\n## 2. Select your Cloud Provider and region. Initially, only AWS will be available as a Cloud Provider with the `us-east-1` and `eu-west-1` regions. We will add Azure soon, and if you need to test Endpoints with other Cloud Providers or regions, please let us know.\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_region.png\" alt=\"select region\" />\n\n## 3. Define the [Security Level](security) for the Endpoint:\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_security.png\" alt=\"define security\" />\n\n## 4. Create your Endpoint by clicking **Create Endpoint**. By default, your Endpoint is created with a medium CPU (2 x 4GB vCPUs with Intel Xeon Ice Lake) The cost estimate assumes the Endpoint will be up for an entire month, and does not take autoscaling into account.\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_create_cost.png\" alt=\"create endpoint\" />\n\n## 5. Wait for the Endpoint to build, initialize and run which can take between 1 to 5 minutes.\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/overview.png\" alt=\"overview\" />\n\n## 6. Test your Endpoint in the overview with the Inference widget \ud83c\udfc1 \ud83c\udf89!\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_inference.png\" alt=\"run inference\" />\n    ```",
            "vector_context": "[Created at: 2025-03-24 13:19:17]\n!---\nCopyright 2022 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n-->\n\n# Token classification with LayoutLMv3 (PyTorch version)\n\nThis directory contains a script, `run_funsd_cord.py`, that can be used to fine-tune (or evaluate) LayoutLMv3 on form understanding datasets, such as [FUNSD](https://guillaumejaume.github.io/FUNSD/) and [CORD](https://github.com/clovaai/cord).\n\nThe script `run_funsd_cord.py` leverages the \ud83e\udd17 Datasets library and the Trainer API. You can easily customize it to your needs.\n\n## Fine-tuning on FUNSD\n\nFine-tuning LayoutLMv3 for token classification on [FUNSD](https://guillaumejaume.github.io/FUNSD/) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name funsd \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 1e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-funsd\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd. By specifying the `push_to_hub` flag, the model gets uploaded automatically to the hub (regularly), together with a model card, which includes metrics such as precision, recall and F1. Note that you can easily update the model card, as it's just a README file of the respective repo on the hub.\n\nThere's also the \"Training metrics\" [tab](https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd/tensorboard), which shows Tensorboard logs over the course of training. Pretty neat, huh?\n\n## Fine-tuning on CORD\n\nFine-tuning LayoutLMv3 for token classification on [CORD](https://github.com/clovaai/cord) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name cord \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 5e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-cord\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-cord. Note that a model card gets generated automatically in case you specify the `push_to_hub` flag.\n--New Chunk--\n[Created at: 2025-03-24 13:16:13]\nChoosing a metric for your task\n\n**So you've trained your model and want to see how well it\u2019s doing on a dataset of your choice. Where do you start?**\n\nThere is no \u201cone size fits all\u201d approach to choosing an evaluation metric, but some good guidelines to keep in mind are:\n\n## Categories of metrics\n\nThere are 3 high-level categories of metrics:\n\n1. *Generic metrics*, which can be applied to a variety of situations and datasets, such as precision and accuracy.\n2. *Task-specific metrics*, which are limited to a given task, such as Machine Translation (often evaluated using metrics [BLEU](https://huggingface.co/metrics/bleu) or [ROUGE](https://huggingface.co/metrics/rouge)) or Named Entity Recognition (often evaluated with [seqeval](https://huggingface.co/metrics/seqeval)).\n3. *Dataset-specific metrics*, which aim to measure model performance on specific benchmarks: for instance, the [GLUE benchmark](https://huggingface.co/datasets/glue) has a dedicated [evaluation metric](https://huggingface.co/metrics/glue).\n\nLet's look at each of these three cases:\n\n### Generic metrics\n\nMany of the metrics used in the Machine Learning community are quite generic and can be applied in a variety of tasks and datasets.\n\nThis is the case for metrics like [accuracy](https://huggingface.co/metrics/accuracy) and [precision](https://huggingface.co/metrics/precision), which can be used for evaluating labeled (supervised) datasets, as well as [perplexity](https://huggingface.co/metrics/perplexity), which can be used for evaluating different kinds of (unsupervised) generative tasks.\n\nTo see the input structure of a given metric, you can look at its metric card. For example, in the case of [precision](https://huggingface.co/metrics/precision), the format is:\n```\n>>> precision_metric = evaluate.load(\"precision\")\n>>> results = precision_metric.compute(references=[0, 1], predictions=[0, 1])\n>>> print(results)\n{'precision': 1.0}\n```\n\n### Task-specific metrics\n\nPopular ML tasks like Machine Translation and Named Entity Recognition have specific metrics that can be used to compare models. For example, a series of different metrics have been proposed for text generation, ranging from [BLEU](https://huggingface.co/metrics/bleu) and its derivatives such as [GoogleBLEU](https://huggingface.co/metrics/google_bleu) and [GLEU](https://huggingface.co/metrics/gleu), but also [ROUGE](https://huggingface.co/metrics/rouge), [MAUVE](https://huggingface.co/metrics/mauve), etc.\n\nYou can find the right metric for your task by:\n\n- **Looking at the [Task pages](https://huggingface.co/tasks)** to see what metrics can be used for evaluating models for a given task.\n- **Checking out leaderboards** on sites like [Papers With Code](https://paperswithcode.com/) (you can search by task and by dataset).\n-  **Reading the metric cards** for the relevant metrics and see which ones are a good fit for your use case. For example, see the [BLEU metric card](https://github.com/huggingface/evaluate/tree/main/metrics/bleu) or [SQuaD metric card](https://github.com/huggingface/evaluate/tree/main/metrics/squad).\n- **Looking at papers and blog posts** published on the topic and see what metrics they report. This can change over time, so try to pick papers from the last couple of years!\n\n### Dataset-specific metrics\n\nSome datasets have specific metrics associated with them -- this is especially in the case of popular benchmarks like [GLUE](https://huggingface.co/metrics/glue) and [SQuAD](https://huggingface.co/metrics/squad).\n\n<Tip warning={true}>\n\ud83d\udca1\nGLUE is actually a collection of different subsets on different tasks, so first you need to choose the one that corresponds to the NLI task, such as mnli, which is described as \u201ccrowdsourced collection of sentence pairs with textual entailment annotations\u201d\n</Tip>\n\n\nIf you are evaluating your model on a benchmark dataset like the ones mentioned above, you can use its dedicated evaluation metric. Make sure you respect the format that they require. For example, to evaluate your model on the [SQuAD](https://huggingface.co/datasets/squad) dataset, you need to feed the `question` and `context` into your model and return the `prediction_text`, which should be compared with the `references` (based on matching the `id` of the question) :\n\n```\n>>> from evaluate import load\n>>> squad_metric = load(\"squad\")\n>>> predictions = [{'prediction_text': '1976', 'id': '56e10a3be3433e1400422b22'}]\n>>> references = [{'answers': {'answer_start': [97], 'text': ['1976']}, 'id': '56e10a3be3433e1400422b22'}]\n>>> results = squad_metric.compute(predictions=predictions, references=references)\n>>> results\n{'exact_match': 100.0, 'f1': 100.0}\n```\n\nYou can find examples of dataset structures by consulting the \"Dataset Preview\" function or the dataset card for a given dataset, and you can see how to use its dedicated evaluation function based on the metric card.\n--New Chunk--\n[Created at: 2025-03-24 13:15:42]\nCreate an Endpoint\n\nAfter your first login, you will be directed to the [Endpoint creation page](https://ui.endpoints.huggingface.co/new). As an example, this guide will go through the steps to deploy [distilbert-base-uncased-finetuned-sst-2-english](https://huggingface.co/distilbert-base-uncased-finetuned-sst-2-english) for text classification. \n\n## 1. Enter the Hugging Face Repository ID and your desired endpoint name:\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_repository.png\" alt=\"select repository\" />\n\n## 2. Select your Cloud Provider and region. Initially, only AWS will be available as a Cloud Provider with the `us-east-1` and `eu-west-1` regions. We will add Azure soon, and if you need to test Endpoints with other Cloud Providers or regions, please let us know.\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_region.png\" alt=\"select region\" />\n\n## 3. Define the [Security Level](security) for the Endpoint:\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_security.png\" alt=\"define security\" />\n\n## 4. Create your Endpoint by clicking **Create Endpoint**. By default, your Endpoint is created with a medium CPU (2 x 4GB vCPUs with Intel Xeon Ice Lake) The cost estimate assumes the Endpoint will be up for an entire month, and does not take autoscaling into account.\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_create_cost.png\" alt=\"create endpoint\" />\n\n## 5. Wait for the Endpoint to build, initialize and run which can take between 1 to 5 minutes.\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/overview.png\" alt=\"overview\" />\n\n## 6. Test your Endpoint in the overview with the Inference widget \ud83c\udfc1 \ud83c\udf89!\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_inference.png\" alt=\"run inference\" />"
        }
    },
    {
        "sample_idx": 103,
        "question": "Where can the resulting model be found?",
        "answer": "The resulting model can be found at https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd.",
        "rag_answer": "The resulting model can be found at https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd and https://huggingface.co/nielsr/layoutlmv3-finetuned-cord.",
        "rag_score": 4,
        "rag_feedback": "The system's response is mostly correct, accurate, and factual. It provides additional information that is not requested, but it does contain the correct answer to the question. The correct answer is 'The resulting model can be found at https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd and https://huggingface.co/nielsr/layoutlmv3-finetuned-cord.'",
        "rag_context": {
            "kg_context": "-----Entities-----\n    ```csv\n    id,\tentity,\ttype,\tdescription,\trankcreated_at\n1,\tDatasets library,technology,Datasets library is a tool used for fine-tuning the LayoutLMv3 model.,1,2025-03-24 13:16:48\n2,\tLayoutLMv3,technology,LayoutLMv3 is a model used for token classification and form understanding tasks.,11,2025-03-24 13:16:48\n3,\tHugging Face,organization,Hugging Face is an organization that provides a platform for deploying and managing endpoints for text classification and other AI models.<SEP>Hugging Face is an organization that provides a platform for evaluating and comparing machine learning models.<SEP>Hugging Face is an organization that provides a range of machine learning models and tools.,8,2025-03-24 13:16:48\n4,\tdistilbert-base-uncased-finetuned-sst-2-english,category,distilbert-base-uncased-finetuned-sst-2-english is a specific AI model for text classification.,1,2025-03-24 13:16:48\n5,\tModel,category,Model refers to a machine learning model being evaluated.,3,2025-03-24 13:16:48\n6,\tPredictions,category,Predictions are the outcome of a model's performance.,2,2025-03-24 13:16:48\n7,\tGoogle Cloud Storage,geo,Google Cloud Storage is a cloud-based storage service provided by Google.,0,UNKNOWN\n8,\tGoogle Cloud,organization,Google Cloud is a cloud computing platform that provides infrastructure and services for building and deploying machine learning models.,1,UNKNOWN\n9,\tCloud Services,category,Cloud Services are online services provided by companies such as Google, used for data storage and processing.,0,UNKNOWN\n    ```\n    -----Relationships-----\n    ```csv\n    id,\tsource,\ttarget,\tdescription,\tkeywords,\tweight,\trank,\tcreated_at\n1,\tDatasets library,LayoutLMv3,Datasets library is a tool used for fine-tuning the LayoutLMv3 model.,tool, model fine-tuning,7.0,12,2025-03-24 13:19:57\n2,\tHugging Face,distilbert-base-uncased-finetuned-sst-2-english,Hugging Face provides a platform for deploying the distilbert-base-uncased-finetuned-sst-2-english model.,platform, model deployment,18.0,9,2025-03-24 13:16:13\n3,\tModel,Predictions,The model makes predictions based on the input data.,model output, predictions,8.0,5,2025-03-24 13:16:48\n4,\tGoogle Cloud,TPU,Google Cloud provides infrastructure and services for building and deploying machine learning models, including TPU hardware.,infrastructure provision, hardware acceleration,14.0,5,UNKNOWN\n    ```\n    -----Sources-----\n    ```csv\n    id,\tcontent\n1,\t!---\nCopyright 2022 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n-->\n\n# Token classification with LayoutLMv3 (PyTorch version)\n\nThis directory contains a script, `run_funsd_cord.py`, that can be used to fine-tune (or evaluate) LayoutLMv3 on form understanding datasets, such as [FUNSD](https://guillaumejaume.github.io/FUNSD/) and [CORD](https://github.com/clovaai/cord).\n\nThe script `run_funsd_cord.py` leverages the \ud83e\udd17 Datasets library and the Trainer API. You can easily customize it to your needs.\n\n## Fine-tuning on FUNSD\n\nFine-tuning LayoutLMv3 for token classification on [FUNSD](https://guillaumejaume.github.io/FUNSD/) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name funsd \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 1e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-funsd\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd. By specifying the `push_to_hub` flag, the model gets uploaded automatically to the hub (regularly), together with a model card, which includes metrics such as precision, recall and F1. Note that you can easily update the model card, as it's just a README file of the respective repo on the hub.\n\nThere's also the \"Training metrics\" [tab](https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd/tensorboard), which shows Tensorboard logs over the course of training. Pretty neat, huh?\n\n## Fine-tuning on CORD\n\nFine-tuning LayoutLMv3 for token classification on [CORD](https://github.com/clovaai/cord) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name cord \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 5e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-cord\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-cord. Note that a model card gets generated automatically in case you specify the `push_to_hub` flag.\n2,\tCreate an Endpoint\n\nAfter your first login, you will be directed to the [Endpoint creation page](https://ui.endpoints.huggingface.co/new). As an example, this guide will go through the steps to deploy [distilbert-base-uncased-finetuned-sst-2-english](https://huggingface.co/distilbert-base-uncased-finetuned-sst-2-english) for text classification. \n\n## 1. Enter the Hugging Face Repository ID and your desired endpoint name:\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_repository.png\" alt=\"select repository\" />\n\n## 2. Select your Cloud Provider and region. Initially, only AWS will be available as a Cloud Provider with the `us-east-1` and `eu-west-1` regions. We will add Azure soon, and if you need to test Endpoints with other Cloud Providers or regions, please let us know.\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_region.png\" alt=\"select region\" />\n\n## 3. Define the [Security Level](security) for the Endpoint:\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_security.png\" alt=\"define security\" />\n\n## 4. Create your Endpoint by clicking **Create Endpoint**. By default, your Endpoint is created with a medium CPU (2 x 4GB vCPUs with Intel Xeon Ice Lake) The cost estimate assumes the Endpoint will be up for an entire month, and does not take autoscaling into account.\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_create_cost.png\" alt=\"create endpoint\" />\n\n## 5. Wait for the Endpoint to build, initialize and run which can take between 1 to 5 minutes.\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/overview.png\" alt=\"overview\" />\n\n## 6. Test your Endpoint in the overview with the Inference widget \ud83c\udfc1 \ud83c\udf89!\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_inference.png\" alt=\"run inference\" />\n3,\t=predictions, references=references)\n>>> results\n{'exact_match': 100.0, 'f1': 100.0}\n```\n\nYou can find examples of dataset structures by consulting the \"Dataset Preview\" function or the dataset card for a given dataset, and you can see how to use its dedicated evaluation function based on the metric card.\n4,\tlabel_mask  # Set negative label positions to 0\nmean_loss = tf.reduce_sum(loss) / tf.reduce_sum(label_mask)\n```\n\nHere, we avoid data-dependent shapes by computing the loss for every position, but zeroing out the masked positions in both the numerator and denominator when we calculate the mean, which yields exactly the same result as the first block while maintaining XLA compatibility. Note that we use the same trick as in rule #1 - converting a `tf.bool` to `tf.float32` and using it as an indicator variable. This is a really useful trick, so remember it if you need to convert your own code to XLA!\n\n#### XLA Rule #3: XLA will need to recompile your model for every different input shape it sees\n\nThis is the big one. What this means is that if your input shapes are very variable, XLA will have to recompile your model over and over, which will create huge performance problems. This commonly arises in NLP models, where input texts have variable lengths after tokenization. In other modalities, static shapes are more common and this rule is much less of a problem.\n\nHow can you get around rule #3? The key is **padding** - if you pad all your inputs to the same length, and then use an `attention_mask`, you can get the same results as you\u2019d get from variable shapes, but without any XLA issues. However, excessive padding can cause severe slowdown too - if you pad all your samples to the maximum length in the whole dataset, you might end up with batches consisting endless padding tokens, which will waste a lot of compute and memory!\n\nThere isn\u2019t a perfect solution to this problem. However, you can try some tricks. One very useful trick is to **pad batches of samples up to a multiple of a number like 32 or 64 tokens.** This often only increases the number of tokens by a small amount, but it hugely reduces the number of unique input shapes, because every input shape now has to be a multiple of 32 or 64. Fewer unique input shapes means fewer XLA compilations!\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** Our tokenizers and data collators have methods that can help you here. You can use `padding=\"max_length\"` or `padding=\"longest\"` when calling tokenizers to get them to output padded data. Our tokenizers and data collators also have a `pad_to_multiple_of` argument that you can use to reduce the number of unique input shapes you see!\n\n</Tip>\n\n### How do I actually train my model on TPU?\n\nOnce your training is XLA-compatible and (if you\u2019re using TPU Node / Colab) your dataset has been prepared appropriately, running on TPU is surprisingly easy! All you really need to change in your code is to add a few lines to initialize your TPU, and to ensure that your model and dataset are created inside a `TPUStrategy` scope. Take a look at [our TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) to see this in action!\n\n### Summary\n\nThere was a lot in here, so let\u2019s summarize with a quick checklist you can follow when you want to get your model ready for TPU training:\n\n- Make sure your code follows the three rules of XLA\n- Compile your model with `jit_compile=True` on CPU/GPU and confirm that you can train it with XLA\n- Either load your dataset into memory or use a TPU-compatible dataset loading approach (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Migrate your code either to Colab (with accelerator set to \u201cTPU\u201d) or a TPU VM on Google Cloud\n- Add TPU initializer code (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Create your `TPUStrategy` and make sure dataset loading and model creation are inside the `strategy.scope()` (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Don\u2019t forget to take `jit_compile=True` out again when you move to TPU!\n- \ud83d\ude4f\ud83d\ude4f\ud83d\ude4f\ud83e\udd7a\ud83e\udd7a\ud83e\udd7a\n- Call model.fit()\n- You did it!\n5,\t!--Copyright 2023 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\nthe License. You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under the License is distributed on\nan \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n\n\u26a0\ufe0f Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be\nrendered properly in your Markdown viewer.\n\n-->\n\n# Training on TPU with TensorFlow\n\n<Tip>\n\nIf you don't need long explanations and just want TPU code samples to get started with, check out [our TPU example notebook!](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb)\n\n</Tip>\n\n### What is a TPU?\n\nA TPU is a **Tensor Processing Unit.** They are hardware designed by Google, which are used to greatly speed up the tensor computations within neural networks, much like GPUs. They can be used for both network training and inference. They are generally accessed through Google\u2019s cloud services, but small TPUs can also be accessed directly for free through Google Colab and Kaggle Kernels.\n\nBecause [all TensorFlow models in \ud83e\udd17 Transformers are Keras models](https://huggingface.co/blog/tensorflow-philosophy), most of the methods in this document are generally applicable to TPU training for any Keras model! However, there are a few points that are specific to the HuggingFace ecosystem (hug-o-system?) of Transformers and Datasets, and we\u2019ll make sure to flag them up when we get to them.\n\n### What kinds of TPU are available?\n\nNew users are often very confused by the range of TPUs, and the different ways to access them. The first key distinction to understand is the difference between **TPU Nodes** and **TPU VMs.**\n\nWhen you use a **TPU Node**, you are effectively indirectly accessing a remote TPU. You will need a separate VM, which will initialize your network and data pipeline and then forward them to the remote node. When you use a TPU on Google Colab, you are accessing it in the **TPU Node** style.\n\nUsing TPU Nodes can have some quite unexpected behaviour for people who aren\u2019t used to them! In particular, because the TPU is located on a physically different system to the machine you\u2019re running your Python code on, your data cannot be local to your machine - any data pipeline that loads from your machine\u2019s internal storage will totally fail! Instead, data must be stored in Google Cloud Storage where your data pipeline can still access it, even when the pipeline is running on the remote TPU node.\n\n<Tip>\n\nIf you can fit all your data in memory as `np.ndarray` or `tf.Tensor`, then you can `fit()` on that data even when using Colab or a TPU Node, without needing to upload it to Google Cloud Storage.\n\n</Tip>\n\n<Tip>\n\n**\ud83e\udd17Specific Hugging Face Tip\ud83e\udd17:** The methods `Dataset.to_tf_dataset()` and its higher-level wrapper `model.prepare_tf_dataset()` , which you will see throughout our TF code examples, will both fail on a TPU Node. The reason for this is that even though they create a `tf.data.Dataset` it is not a \u201cpure\u201d `tf.data` pipeline and uses `tf.numpy_function` or `Dataset.from_generator()` to stream data from the underlying HuggingFace `Dataset`. This HuggingFace `Dataset` is backed by data that is on a local disc and which the remote TPU Node will not be able to read.\n\n</Tip>\n\nThe second way to access a TPU is via a **TPU VM.** When using a TPU VM, you connect directly to the machine that the TPU is attached to, much like training on a GPU VM. TPU VMs are generally easier to work with, particularly when it comes to your data pipeline. All of the above warnings do not apply to TPU VMs!\n\nThis is an opinionated document, so here\u2019s our opinion: **Avoid using TPU Node if possible.** It is more confusing and more difficult to debug than TPU VMs. It is also likely to be unsupported in future - Google\u2019s latest TPU, TPUv4, can only be accessed as a TPU VM, which suggests that TPU Nodes are increasingly going to become a \u201clegacy\u201d access method. However, we understand that the only free TPU access is on Colab and Kaggle Kernels, which uses TPU Node - so we\u2019ll try to explain how to handle it if you have to! Check the [TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) for code samples that explain this in more detail.\n\n### What sizes of TPU are available?\n\nA single TPU (a v2-8/v3-8/v4-8) runs 8 replicas. TPUs exist in **pods** that can run hundreds or thousands of replicas simultaneously. When you use more than a single TPU but less than a whole pod (for example, a v3-32), your TPU fleet is referred to as a **pod slice.**\n\nWhen you access a free TPU via Colab, you generally get a single v2-8 TPU.\n\n### I keep hearing about this XLA thing. What\u2019s XLA, and how does it relate to TPUs?\n\nXLA is an optimizing compiler, used by both TensorFlow and JAX. In JAX it is the only compiler, whereas in TensorFlow it is optional\n    ```",
            "vector_context": "[Created at: 2025-03-24 13:16:13]\n=predictions, references=references)\n>>> results\n{'exact_match': 100.0, 'f1': 100.0}\n```\n\nYou can find examples of dataset structures by consulting the \"Dataset Preview\" function or the dataset card for a given dataset, and you can see how to use its dedicated evaluation function based on the metric card.\n--New Chunk--\n[Created at: 2025-03-24 13:19:17]\n!---\nCopyright 2022 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n-->\n\n# Token classification with LayoutLMv3 (PyTorch version)\n\nThis directory contains a script, `run_funsd_cord.py`, that can be used to fine-tune (or evaluate) LayoutLMv3 on form understanding datasets, such as [FUNSD](https://guillaumejaume.github.io/FUNSD/) and [CORD](https://github.com/clovaai/cord).\n\nThe script `run_funsd_cord.py` leverages the \ud83e\udd17 Datasets library and the Trainer API. You can easily customize it to your needs.\n\n## Fine-tuning on FUNSD\n\nFine-tuning LayoutLMv3 for token classification on [FUNSD](https://guillaumejaume.github.io/FUNSD/) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name funsd \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 1e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-funsd\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd. By specifying the `push_to_hub` flag, the model gets uploaded automatically to the hub (regularly), together with a model card, which includes metrics such as precision, recall and F1. Note that you can easily update the model card, as it's just a README file of the respective repo on the hub.\n\nThere's also the \"Training metrics\" [tab](https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd/tensorboard), which shows Tensorboard logs over the course of training. Pretty neat, huh?\n\n## Fine-tuning on CORD\n\nFine-tuning LayoutLMv3 for token classification on [CORD](https://github.com/clovaai/cord) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name cord \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 5e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-cord\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-cord. Note that a model card gets generated automatically in case you specify the `push_to_hub` flag.\n--New Chunk--\n[Created at: 2025-03-24 13:16:48]\n\u4e0e\u5e38\u89c4\u51fd\u6570\u76f8\u540c\u7684\u65b9\u5f0f\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio\u3002\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\uff08\u865a\u62df\u7684\uff09\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5b83\u5728\u8f93\u51fa\u56fe\u50cf\u4e4b\u524d\u751f\u6210\u6570\u4e2a\u6b65\u9aa4\u7684\u566a\u97f3\uff1a\n\n$code_fake_diffusion\n$demo_fake_diffusion\n\n\u8bf7\u6ce8\u610f\uff0c\u6211\u4eec\u5728\u8fed\u4ee3\u5668\u4e2d\u6dfb\u52a0\u4e86 `time.sleep(1)`\uff0c\u4ee5\u521b\u5efa\u6b65\u9aa4\u4e4b\u95f4\u7684\u4eba\u5de5\u6682\u505c\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u89c2\u5bdf\u8fed\u4ee3\u5668\u7684\u6b65\u9aa4\uff08\u5728\u771f\u5b9e\u7684\u56fe\u50cf\u751f\u6210\u6a21\u578b\u4e2d\uff0c\u8fd9\u53ef\u80fd\u662f\u4e0d\u5fc5\u8981\u7684\uff09\u3002\n\n\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio **\u9700\u8981**\u5728\u5e95\u5c42 Interface \u6216 Blocks \u4e2d\u542f\u7528\u961f\u5217\uff08\u8bf7\u53c2\u9605\u4e0a\u9762\u7684\u961f\u5217\u90e8\u5206\uff09\u3002\n\n## \u8fdb\u5ea6\u6761\n\nGradio \u652f\u6301\u521b\u5efa\u81ea\u5b9a\u4e49\u8fdb\u5ea6\u6761\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u81ea\u5b9a\u4e49\u548c\u63a7\u5236\u5411\u7528\u6237\u663e\u793a\u7684\u8fdb\u5ea6\u66f4\u65b0\u3002\u8981\u542f\u7528\u6b64\u529f\u80fd\uff0c\u53ea\u9700\u4e3a\u65b9\u6cd5\u6dfb\u52a0\u4e00\u4e2a\u9ed8\u8ba4\u503c\u4e3a `gr.Progress` \u5b9e\u4f8b\u7684\u53c2\u6570\u5373\u53ef\u3002\u7136\u540e\uff0c\u60a8\u53ef\u4ee5\u76f4\u63a5\u8c03\u7528\u6b64\u5b9e\u4f8b\u5e76\u4f20\u5165 0 \u5230 1 \u4e4b\u95f4\u7684\u6d6e\u70b9\u6570\u6765\u66f4\u65b0\u8fdb\u5ea6\u7ea7\u522b\uff0c\u6216\u8005 with `Progress` \u5b9e\u4f8b\u7684 `tqdm()` \u65b9\u6cd5\u6765\u8ddf\u8e2a\u53ef\u8fed\u4ee3\u5bf9\u8c61\u4e0a\u7684\u8fdb\u5ea6\uff0c\u5982\u4e0b\u6240\u793a\u3002\u5fc5\u987b\u542f\u7528\u961f\u5217\u4ee5\u8fdb\u884c\u8fdb\u5ea6\u66f4\u65b0\u3002\n\n$code_progress_simple\n$demo_progress_simple\n\n\u5982\u679c\u60a8 with `tqdm` \u5e93\uff0c\u5e76\u4e14\u5e0c\u671b\u4ece\u51fd\u6570\u5185\u90e8\u7684\u4efb\u4f55 `tqdm.tqdm` \u81ea\u52a8\u62a5\u544a\u8fdb\u5ea6\u66f4\u65b0\uff0c\u8bf7\u5c06\u9ed8\u8ba4\u53c2\u6570\u8bbe\u7f6e\u4e3a `gr.Progress(track_tqdm=True)`\uff01\n\n## \u6279\u5904\u7406\u51fd\u6570 (Batch Functions)\n\nGradio \u652f\u6301\u4f20\u9012*\u6279\u5904\u7406*\u51fd\u6570\u3002\u6279\u5904\u7406\u51fd\u6570\u53ea\u662f\u63a5\u53d7\u8f93\u5165\u5217\u8868\u5e76\u8fd4\u56de\u9884\u6d4b\u5217\u8868\u7684\u51fd\u6570\u3002\n\n\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\u6279\u5904\u7406\u51fd\u6570\uff0c\u5b83\u63a5\u53d7\u4e24\u4e2a\u8f93\u5165\u5217\u8868\uff08\u4e00\u4e2a\u5355\u8bcd\u5217\u8868\u548c\u4e00\u4e2a\u6574\u6570\u5217\u8868\uff09\uff0c\u5e76\u8fd4\u56de\u4fee\u526a\u8fc7\u7684\u5355\u8bcd\u5217\u8868\u4f5c\u4e3a\u8f93\u51fa\uff1a\n\n```python\nimport time\n\ndef trim_words(words, lens):\n    trimmed_words = []\n    time.sleep(5)\n    for w, l in zip(words, lens):\n        trimmed_words.append(w[:int(l)])\n    return [trimmed_words]\n    for w, l in zip(words, lens):\n```\n\n\u4f7f\u7528\u6279\u5904\u7406\u51fd\u6570\u7684\u4f18\u70b9\u662f\uff0c\u5982\u679c\u542f\u7528\u4e86\u961f\u5217\uff0cGradio \u670d\u52a1\u5668\u53ef\u4ee5\u81ea\u52a8*\u6279\u5904\u7406*\u4f20\u5165\u7684\u8bf7\u6c42\u5e76\u5e76\u884c\u5904\u7406\u5b83\u4eec\uff0c\u4ece\u800c\u53ef\u80fd\u52a0\u5feb\u6f14\u793a\u901f\u5ea6\u3002\u4ee5\u4e0b\u662f Gradio \u4ee3\u7801\u7684\u793a\u4f8b\uff08\u8bf7\u6ce8\u610f `batch=True` \u548c `max_batch_size=16` - \u8fd9\u4e24\u4e2a\u53c2\u6570\u90fd\u53ef\u4ee5\u4f20\u9012\u7ed9\u4e8b\u4ef6\u89e6\u53d1\u5668\u6216 `Interface` \u7c7b\uff09\n\nwith `Interface`\uff1a\n\n```python\ndemo = gr.Interface(trim_words, [\"textbox\", \"number\"], [\"output\"],\n                    batch=True, max_batch_size=16)\ndemo.queue()\ndemo.launch()\n```\n\nwith `Blocks`\uff1a\n\n```python\nimport gradio as gr\n\nwith gr.Blocks() as demo:\n    with gr.Row():\n        word = gr.Textbox(label=\"word\")\n        leng = gr.Number(label=\"leng\")\n        output = gr.Textbox(label=\"Output\")\n    with gr.Row():\n        run = gr.Button()\n\n    event = run.click(trim_words, [word, leng], output, batch=True, max_batch_size=16)\n\ndemo.queue()\ndemo.launch()\n```\n\n\u5728\u4e0a\u9762\u7684\u793a\u4f8b\u4e2d\uff0c\u53ef\u4ee5\u5e76\u884c\u5904\u7406 16 \u4e2a\u8bf7\u6c42\uff08\u603b\u63a8\u7406\u65f6\u95f4\u4e3a 5 \u79d2\uff09\uff0c\u800c\u4e0d\u662f\u5206\u522b\u5904\u7406\u6bcf\u4e2a\u8bf7\u6c42\uff08\u603b\u63a8\u7406\u65f6\u95f4\u4e3a 80 \u79d2\uff09\u3002\u8bb8\u591a Hugging Face \u7684 `transformers` \u548c `diffusers` \u6a21\u578b\u5728 Gradio \u7684\u6279\u5904\u7406\u6a21\u5f0f\u4e0b\u81ea\u7136\u5de5\u4f5c\uff1a\u8fd9\u662f[\u4f7f\u7528\u6279\u5904\u7406\u751f\u6210\u56fe\u50cf\u7684\u793a\u4f8b\u6f14\u793a](https://github.com/gradio-app/gradio/blob/main/demo/diffusers_with_batching/run.py)\n\n\u6ce8\u610f\uff1a\u4f7f\u7528 Gradio \u7684\u6279\u5904\u7406\u51fd\u6570 **requires** \u5728\u5e95\u5c42 Interface \u6216 Blocks \u4e2d\u542f\u7528\u961f\u5217\uff08\u8bf7\u53c2\u9605\u4e0a\u9762\u7684\u961f\u5217\u90e8\u5206\uff09\u3002\n\n## Gradio \u7b14\u8bb0\u672c (Colab Notebooks)\n\nGradio \u53ef\u4ee5\u5728\u4efb\u4f55\u8fd0\u884c Python \u7684\u5730\u65b9\u8fd0\u884c\uff0c\u5305\u62ec\u672c\u5730 Jupyter \u7b14\u8bb0\u672c\u548c\u534f\u4f5c\u7b14\u8bb0\u672c\uff0c\u5982[Google Colab](https://colab.research.google.com/)\u3002\u5bf9\u4e8e\u672c\u5730 Jupyter \u7b14\u8bb0\u672c\u548c Google Colab \u7b14\u8bb0\u672c\uff0cGradio \u5728\u672c\u5730\u670d\u52a1\u5668\u4e0a\u8fd0\u884c\uff0c\u60a8\u53ef\u4ee5\u5728\u6d4f\u89c8\u5668\u4e2d\u4e0e\u4e4b\u4ea4\u4e92\u3002\uff08\u6ce8\u610f\uff1a\u5bf9\u4e8e Google Colab\uff0c\u8fd9\u662f\u901a\u8fc7[\u670d\u52a1\u5de5\u4f5c\u5668\u96a7\u9053](https://github.com/tensorflow/tensorboard/blob/master/docs/design/colab_integration.md)\u5b9e\u73b0\u7684\uff0c\u60a8\u7684\u6d4f\u89c8\u5668\u9700\u8981\u542f\u7528 cookies\u3002\uff09\u5bf9\u4e8e\u5176\u4ed6\u8fdc\u7a0b\u7b14\u8bb0\u672c\uff0cGradio \u4e5f\u5c06\u5728\u670d\u52a1\u5668\u4e0a\u8fd0\u884c\uff0c\u4f46\u60a8\u9700\u8981\u4f7f\u7528[SSH \u96a7\u9053](https://coderwall.com/p/ohk6cg/remote-access-to-ipython-notebooks-via-ssh)\u5728\u672c\u5730\u6d4f\u89c8\u5668\u4e2d\u67e5\u770b\u5e94\u7528\u7a0b\u5e8f\u3002\u901a\u5e38\uff0c\u66f4\u7b80\u5355\u7684\u9009\u62e9\u662f\u4f7f\u7528 Gradio \u5185\u7f6e\u7684\u516c\u5171\u94fe\u63a5\uff0c[\u5728\u4e0b\u4e00\u7bc7\u6307\u5357\u4e2d\u8ba8\u8bba](/sharing-your-app/#sharing-demos)\u3002"
        }
    },
    {
        "sample_idx": 104,
        "question": "What is the name of the tab that shows Tensorboard logs over the course of training?",
        "answer": "The 'Training metrics' tab.",
        "rag_answer": "The tab that shows Tensorboard logs over the course of training is called the \"Training metrics\" tab.",
        "rag_score": 5,
        "rag_feedback": "The system's response is completely correct, accurate, and factual. It correctly identifies the tab that shows Tensorboard logs over the course of training as the 'Training metrics' tab.",
        "rag_context": {
            "kg_context": "-----Entities-----\n    ```csv\n    id,\tentity,\ttype,\tdescription,\trankcreated_at\n1,\tLayoutLMv3,technology,LayoutLMv3 is a model used for token classification and form understanding tasks.,11,2025-03-24 13:18:20\n2,\tTensorboard,technology,Tensorboard is a tool used for visualizing the training metrics of the LayoutLMv3 model.,1,2025-03-24 13:18:20\n3,\tHuggingFace,organization,HuggingFace is a company that provides a range of AI models and tools, including the Transformers and Datasets ecosystem.<SEP>HuggingFace is an organization that provides pre-trained models and loss functions for machine learning.<SEP>HuggingFace is an organization that provides tools and resources for natural language processing and machine learning.,5,2025-03-24 13:18:20\n4,\tTensorFlow,category,TensorFlow is a machine learning framework that uses XLA as an optimizing compiler.<SEP>TensorFlow is a software framework used for building and training neural networks.<SEP>TensorFlow is an open-source machine learning framework.,3,2025-03-24 13:18:20\n5,\tKeras,category,Keras is a high-level neural networks API, used for building and training neural networks.<SEP>Keras is a machine learning framework that uses XLA for optimization.,2,2025-03-24 13:18:20\n6,\tTensorboard,technology,Tensorboard is a tool used for visualizing the training metrics of the LayoutLMv3 model.,1,UNKNOWN\n7,\tTensorFlow,category,TensorFlow is a machine learning framework that uses XLA as an optimizing compiler.<SEP>TensorFlow is a software framework used for building and training neural networks.<SEP>TensorFlow is an open-source machine learning framework.,3,UNKNOWN\n8,\tGoogle,organization,Google is the company that designs and provides TPUs, which are used to speed up tensor computations within neural networks.,3,UNKNOWN\n    ```\n    -----Relationships-----\n    ```csv\n    id,\tsource,\ttarget,\tdescription,\tkeywords,\tweight,\trank,\tcreated_at\n1,\tLayoutLMv3,Tensorboard,Tensorboard is a tool used for visualizing the training metrics of the LayoutLMv3 model.,tool, model visualization,7.0,12,2025-03-24 13:19:57\n2,\tHuggingFace,TensorFlow,HuggingFace provides a range of AI models and tools, including the Transformers and Datasets ecosystem, which are built on top of TensorFlow.,ecosystem integration, AI models,18.0,8,2025-03-24 13:18:20\n3,\tKeras,TensorFlow,TensorFlow uses Keras as a high-level neural networks API.,API integration, neural networks,16.0,5,2025-03-24 13:18:20\n4,\tLayoutLMv3,Tensorboard,Tensorboard is a tool used for visualizing the training metrics of the LayoutLMv3 model.,tool, model visualization,7.0,12,UNKNOWN\n5,\tTensorFlow,XLA,TensorFlow graphs can be compiled into executable code using XLA.<SEP>TensorFlow uses XLA as an optimizing compiler to improve performance.,compilation, framework support<SEP>compiler, performance optimization,23.0,9,UNKNOWN\n6,\tHuggingFace,TensorFlow,HuggingFace provides a range of AI models and tools, including the Transformers and Datasets ecosystem, which are built on top of TensorFlow.,ecosystem integration, AI models,18.0,8,UNKNOWN\n7,\tGoogle,TPU,Google designs and provides TPUs, which are used to speed up tensor computations within neural networks.,hardware design, acceleration,18.0,7,UNKNOWN\n8,\tColab,Google,Colab is a cloud-based platform provided by Google for data science and machine learning.,platform provision, cloud computing,16.0,6,UNKNOWN\n9,\tKeras,TensorFlow,TensorFlow uses Keras as a high-level neural networks API.,API integration, neural networks,16.0,5,UNKNOWN\n10,\tGoogle,Kaggle Kernels,Kaggle Kernels is a cloud-based platform provided by Google for data science and machine learning competitions.,platform provision, cloud computing,16.0,4,UNKNOWN\n    ```\n    -----Sources-----\n    ```csv\n    id,\tcontent\n1,\t!---\nCopyright 2022 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n-->\n\n# Token classification with LayoutLMv3 (PyTorch version)\n\nThis directory contains a script, `run_funsd_cord.py`, that can be used to fine-tune (or evaluate) LayoutLMv3 on form understanding datasets, such as [FUNSD](https://guillaumejaume.github.io/FUNSD/) and [CORD](https://github.com/clovaai/cord).\n\nThe script `run_funsd_cord.py` leverages the \ud83e\udd17 Datasets library and the Trainer API. You can easily customize it to your needs.\n\n## Fine-tuning on FUNSD\n\nFine-tuning LayoutLMv3 for token classification on [FUNSD](https://guillaumejaume.github.io/FUNSD/) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name funsd \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 1e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-funsd\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd. By specifying the `push_to_hub` flag, the model gets uploaded automatically to the hub (regularly), together with a model card, which includes metrics such as precision, recall and F1. Note that you can easily update the model card, as it's just a README file of the respective repo on the hub.\n\nThere's also the \"Training metrics\" [tab](https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd/tensorboard), which shows Tensorboard logs over the course of training. Pretty neat, huh?\n\n## Fine-tuning on CORD\n\nFine-tuning LayoutLMv3 for token classification on [CORD](https://github.com/clovaai/cord) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name cord \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 5e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-cord\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-cord. Note that a model card gets generated automatically in case you specify the `push_to_hub` flag.\n2,\t!--Copyright 2023 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\nthe License. You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under the License is distributed on\nan \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n\n\u26a0\ufe0f Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be\nrendered properly in your Markdown viewer.\n\n-->\n\n# Training on TPU with TensorFlow\n\n<Tip>\n\nIf you don't need long explanations and just want TPU code samples to get started with, check out [our TPU example notebook!](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb)\n\n</Tip>\n\n### What is a TPU?\n\nA TPU is a **Tensor Processing Unit.** They are hardware designed by Google, which are used to greatly speed up the tensor computations within neural networks, much like GPUs. They can be used for both network training and inference. They are generally accessed through Google\u2019s cloud services, but small TPUs can also be accessed directly for free through Google Colab and Kaggle Kernels.\n\nBecause [all TensorFlow models in \ud83e\udd17 Transformers are Keras models](https://huggingface.co/blog/tensorflow-philosophy), most of the methods in this document are generally applicable to TPU training for any Keras model! However, there are a few points that are specific to the HuggingFace ecosystem (hug-o-system?) of Transformers and Datasets, and we\u2019ll make sure to flag them up when we get to them.\n\n### What kinds of TPU are available?\n\nNew users are often very confused by the range of TPUs, and the different ways to access them. The first key distinction to understand is the difference between **TPU Nodes** and **TPU VMs.**\n\nWhen you use a **TPU Node**, you are effectively indirectly accessing a remote TPU. You will need a separate VM, which will initialize your network and data pipeline and then forward them to the remote node. When you use a TPU on Google Colab, you are accessing it in the **TPU Node** style.\n\nUsing TPU Nodes can have some quite unexpected behaviour for people who aren\u2019t used to them! In particular, because the TPU is located on a physically different system to the machine you\u2019re running your Python code on, your data cannot be local to your machine - any data pipeline that loads from your machine\u2019s internal storage will totally fail! Instead, data must be stored in Google Cloud Storage where your data pipeline can still access it, even when the pipeline is running on the remote TPU node.\n\n<Tip>\n\nIf you can fit all your data in memory as `np.ndarray` or `tf.Tensor`, then you can `fit()` on that data even when using Colab or a TPU Node, without needing to upload it to Google Cloud Storage.\n\n</Tip>\n\n<Tip>\n\n**\ud83e\udd17Specific Hugging Face Tip\ud83e\udd17:** The methods `Dataset.to_tf_dataset()` and its higher-level wrapper `model.prepare_tf_dataset()` , which you will see throughout our TF code examples, will both fail on a TPU Node. The reason for this is that even though they create a `tf.data.Dataset` it is not a \u201cpure\u201d `tf.data` pipeline and uses `tf.numpy_function` or `Dataset.from_generator()` to stream data from the underlying HuggingFace `Dataset`. This HuggingFace `Dataset` is backed by data that is on a local disc and which the remote TPU Node will not be able to read.\n\n</Tip>\n\nThe second way to access a TPU is via a **TPU VM.** When using a TPU VM, you connect directly to the machine that the TPU is attached to, much like training on a GPU VM. TPU VMs are generally easier to work with, particularly when it comes to your data pipeline. All of the above warnings do not apply to TPU VMs!\n\nThis is an opinionated document, so here\u2019s our opinion: **Avoid using TPU Node if possible.** It is more confusing and more difficult to debug than TPU VMs. It is also likely to be unsupported in future - Google\u2019s latest TPU, TPUv4, can only be accessed as a TPU VM, which suggests that TPU Nodes are increasingly going to become a \u201clegacy\u201d access method. However, we understand that the only free TPU access is on Colab and Kaggle Kernels, which uses TPU Node - so we\u2019ll try to explain how to handle it if you have to! Check the [TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) for code samples that explain this in more detail.\n\n### What sizes of TPU are available?\n\nA single TPU (a v2-8/v3-8/v4-8) runs 8 replicas. TPUs exist in **pods** that can run hundreds or thousands of replicas simultaneously. When you use more than a single TPU but less than a whole pod (for example, a v3-32), your TPU fleet is referred to as a **pod slice.**\n\nWhen you access a free TPU via Colab, you generally get a single v2-8 TPU.\n\n### I keep hearing about this XLA thing. What\u2019s XLA, and how does it relate to TPUs?\n\nXLA is an optimizing compiler, used by both TensorFlow and JAX. In JAX it is the only compiler, whereas in TensorFlow it is optional\n3,\t(for example, a v3-32), your TPU fleet is referred to as a **pod slice.**\n\nWhen you access a free TPU via Colab, you generally get a single v2-8 TPU.\n\n### I keep hearing about this XLA thing. What\u2019s XLA, and how does it relate to TPUs?\n\nXLA is an optimizing compiler, used by both TensorFlow and JAX. In JAX it is the only compiler, whereas in TensorFlow it is optional (but mandatory on TPU!). The easiest way to enable it when training a Keras model is to pass the argument `jit_compile=True` to `model.compile()`. If you don\u2019t get any errors and performance is good, that\u2019s a great sign that you\u2019re ready to move to TPU!\n\nDebugging on TPU is generally a bit harder than on CPU/GPU, so we recommend getting your code running on CPU/GPU with XLA first before trying it on TPU. You don\u2019t have to train for long, of course - just for a few steps to make sure that your model and data pipeline are working like you expect them to.\n\n<Tip>\n\nXLA compiled code is usually faster - so even if you\u2019re not planning to run on TPU, adding `jit_compile=True` can improve your performance. Be sure to note the caveats below about XLA compatibility, though!\n\n</Tip>\n\n<Tip warning={true}>\n\n**Tip born of painful experience:** Although using `jit_compile=True` is a good way to get a speed boost and test if your CPU/GPU code is XLA-compatible, it can actually cause a lot of problems if you leave it in when actually training on TPU. XLA compilation will happen implicitly on TPU, so remember to remove that line before actually running your code on a TPU!\n\n</Tip>\n\n### How do I make my model XLA compatible?\n\nIn many cases, your code is probably XLA-compatible already! However, there are a few things that work in normal TensorFlow that don\u2019t work in XLA. We\u2019ve distilled them into three core rules below:\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** We\u2019ve put a lot of effort into rewriting our TensorFlow models and loss functions to be XLA-compatible. Our models and loss functions generally obey rule #1 and #2 by default, so you can skip over them if you\u2019re using `transformers` models. Don\u2019t forget about these rules when writing your own models and loss functions, though!\n\n</Tip>\n\n#### XLA Rule #1: Your code cannot have \u201cdata-dependent conditionals\u201d\n\nWhat that means is that any `if` statement cannot depend on values inside a `tf.Tensor`. For example, this code block cannot be compiled with XLA!\n\n```python\nif tf.reduce_sum(tensor) > 10:\n    tensor = tensor / 2.0\n```\n\nThis might seem very restrictive at first, but most neural net code doesn\u2019t need to do this. You can often get around this restriction by using `tf.cond` (see the documentation [here](https://www.tensorflow.org/api_docs/python/tf/cond)) or by removing the conditional and finding a clever math trick with indicator variables instead, like so:\n\n```python\nsum_over_10 = tf.cast(tf.reduce_sum(tensor) > 10, tf.float32)\ntensor = tensor / (1.0 + sum_over_10)\n```\n\nThis code has exactly the same effect as the code above, but by avoiding a conditional, we ensure it will compile with XLA without problems!\n\n#### XLA Rule #2: Your code cannot have \u201cdata-dependent shapes\u201d\n\nWhat this means is that the shape of all of the `tf.Tensor` objects in your code cannot depend on their values. For example, the function `tf.unique` cannot be compiled with XLA, because it returns a `tensor` containing one instance of each unique value in the input. The shape of this output will obviously be different depending on how repetitive the input `Tensor` was, and so XLA refuses to handle it!\n\nIn general, most neural network code obeys rule #2 by default. However, there are a few common cases where it becomes a problem. One very common one is when you use **label masking**, setting your labels to a negative value to indicate that those positions should be ignored when computing the loss. If you look at NumPy or PyTorch loss functions that support label masking, you will often see code like this that uses [boolean indexing](https://numpy.org/doc/stable/user/basics.indexing.html#boolean-array-indexing):\n\n```python\nlabel_mask = labels >= 0\nmasked_outputs = outputs[label_mask]\nmasked_labels = labels[label_mask]\nloss = compute_loss(masked_outputs, masked_labels)\nmean_loss = torch.mean(loss)\n```\n\nThis code is totally fine in NumPy or PyTorch, but it breaks in XLA! Why? Because the shape of `masked_outputs` and `masked_labels` depends on how many positions are masked - that makes it a **data-dependent shape.** However, just like for rule #1, we can often rewrite this code to yield exactly the same output without any data-dependent shapes.\n\n```python\nlabel_mask = tf.cast(labels >= 0, tf.float32)\nloss = compute_loss(outputs, labels)\nloss = loss * label_mask  # Set negative label positions to 0\nmean_loss = tf.reduce_sum(loss) / tf.reduce_sum(label_mask)\n```\n\nHere, we avoid data-dependent shapes by computing the loss for every position, but zeroing out the masked positions in both the numerator and denominator when we calculate the mean, which yields exactly the same result as the first block while maintaining XLA compatibility. Note that we use the same trick as in rule #1 - converting a `tf.bool` to `\n4,\tlabel_mask  # Set negative label positions to 0\nmean_loss = tf.reduce_sum(loss) / tf.reduce_sum(label_mask)\n```\n\nHere, we avoid data-dependent shapes by computing the loss for every position, but zeroing out the masked positions in both the numerator and denominator when we calculate the mean, which yields exactly the same result as the first block while maintaining XLA compatibility. Note that we use the same trick as in rule #1 - converting a `tf.bool` to `tf.float32` and using it as an indicator variable. This is a really useful trick, so remember it if you need to convert your own code to XLA!\n\n#### XLA Rule #3: XLA will need to recompile your model for every different input shape it sees\n\nThis is the big one. What this means is that if your input shapes are very variable, XLA will have to recompile your model over and over, which will create huge performance problems. This commonly arises in NLP models, where input texts have variable lengths after tokenization. In other modalities, static shapes are more common and this rule is much less of a problem.\n\nHow can you get around rule #3? The key is **padding** - if you pad all your inputs to the same length, and then use an `attention_mask`, you can get the same results as you\u2019d get from variable shapes, but without any XLA issues. However, excessive padding can cause severe slowdown too - if you pad all your samples to the maximum length in the whole dataset, you might end up with batches consisting endless padding tokens, which will waste a lot of compute and memory!\n\nThere isn\u2019t a perfect solution to this problem. However, you can try some tricks. One very useful trick is to **pad batches of samples up to a multiple of a number like 32 or 64 tokens.** This often only increases the number of tokens by a small amount, but it hugely reduces the number of unique input shapes, because every input shape now has to be a multiple of 32 or 64. Fewer unique input shapes means fewer XLA compilations!\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** Our tokenizers and data collators have methods that can help you here. You can use `padding=\"max_length\"` or `padding=\"longest\"` when calling tokenizers to get them to output padded data. Our tokenizers and data collators also have a `pad_to_multiple_of` argument that you can use to reduce the number of unique input shapes you see!\n\n</Tip>\n\n### How do I actually train my model on TPU?\n\nOnce your training is XLA-compatible and (if you\u2019re using TPU Node / Colab) your dataset has been prepared appropriately, running on TPU is surprisingly easy! All you really need to change in your code is to add a few lines to initialize your TPU, and to ensure that your model and dataset are created inside a `TPUStrategy` scope. Take a look at [our TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) to see this in action!\n\n### Summary\n\nThere was a lot in here, so let\u2019s summarize with a quick checklist you can follow when you want to get your model ready for TPU training:\n\n- Make sure your code follows the three rules of XLA\n- Compile your model with `jit_compile=True` on CPU/GPU and confirm that you can train it with XLA\n- Either load your dataset into memory or use a TPU-compatible dataset loading approach (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Migrate your code either to Colab (with accelerator set to \u201cTPU\u201d) or a TPU VM on Google Cloud\n- Add TPU initializer code (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Create your `TPUStrategy` and make sure dataset loading and model creation are inside the `strategy.scope()` (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Don\u2019t forget to take `jit_compile=True` out again when you move to TPU!\n- \ud83d\ude4f\ud83d\ude4f\ud83d\ude4f\ud83e\udd7a\ud83e\udd7a\ud83e\udd7a\n- Call model.fit()\n- You did it!\n    ```",
            "vector_context": "[Created at: 2025-03-24 13:19:17]\n!---\nCopyright 2022 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n-->\n\n# Token classification with LayoutLMv3 (PyTorch version)\n\nThis directory contains a script, `run_funsd_cord.py`, that can be used to fine-tune (or evaluate) LayoutLMv3 on form understanding datasets, such as [FUNSD](https://guillaumejaume.github.io/FUNSD/) and [CORD](https://github.com/clovaai/cord).\n\nThe script `run_funsd_cord.py` leverages the \ud83e\udd17 Datasets library and the Trainer API. You can easily customize it to your needs.\n\n## Fine-tuning on FUNSD\n\nFine-tuning LayoutLMv3 for token classification on [FUNSD](https://guillaumejaume.github.io/FUNSD/) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name funsd \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 1e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-funsd\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd. By specifying the `push_to_hub` flag, the model gets uploaded automatically to the hub (regularly), together with a model card, which includes metrics such as precision, recall and F1. Note that you can easily update the model card, as it's just a README file of the respective repo on the hub.\n\nThere's also the \"Training metrics\" [tab](https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd/tensorboard), which shows Tensorboard logs over the course of training. Pretty neat, huh?\n\n## Fine-tuning on CORD\n\nFine-tuning LayoutLMv3 for token classification on [CORD](https://github.com/clovaai/cord) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name cord \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 5e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-cord\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-cord. Note that a model card gets generated automatically in case you specify the `push_to_hub` flag.\n--New Chunk--\n[Created at: 2025-03-24 13:17:32]\n!--Copyright 2023 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\nthe License. You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under the License is distributed on\nan \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n\n\u26a0\ufe0f Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be\nrendered properly in your Markdown viewer.\n\n-->\n\n# Training on TPU with TensorFlow\n\n<Tip>\n\nIf you don't need long explanations and just want TPU code samples to get started with, check out [our TPU example notebook!](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb)\n\n</Tip>\n\n### What is a TPU?\n\nA TPU is a **Tensor Processing Unit.** They are hardware designed by Google, which are used to greatly speed up the tensor computations within neural networks, much like GPUs. They can be used for both network training and inference. They are generally accessed through Google\u2019s cloud services, but small TPUs can also be accessed directly for free through Google Colab and Kaggle Kernels.\n\nBecause [all TensorFlow models in \ud83e\udd17 Transformers are Keras models](https://huggingface.co/blog/tensorflow-philosophy), most of the methods in this document are generally applicable to TPU training for any Keras model! However, there are a few points that are specific to the HuggingFace ecosystem (hug-o-system?) of Transformers and Datasets, and we\u2019ll make sure to flag them up when we get to them.\n\n### What kinds of TPU are available?\n\nNew users are often very confused by the range of TPUs, and the different ways to access them. The first key distinction to understand is the difference between **TPU Nodes** and **TPU VMs.**\n\nWhen you use a **TPU Node**, you are effectively indirectly accessing a remote TPU. You will need a separate VM, which will initialize your network and data pipeline and then forward them to the remote node. When you use a TPU on Google Colab, you are accessing it in the **TPU Node** style.\n\nUsing TPU Nodes can have some quite unexpected behaviour for people who aren\u2019t used to them! In particular, because the TPU is located on a physically different system to the machine you\u2019re running your Python code on, your data cannot be local to your machine - any data pipeline that loads from your machine\u2019s internal storage will totally fail! Instead, data must be stored in Google Cloud Storage where your data pipeline can still access it, even when the pipeline is running on the remote TPU node.\n\n<Tip>\n\nIf you can fit all your data in memory as `np.ndarray` or `tf.Tensor`, then you can `fit()` on that data even when using Colab or a TPU Node, without needing to upload it to Google Cloud Storage.\n\n</Tip>\n\n<Tip>\n\n**\ud83e\udd17Specific Hugging Face Tip\ud83e\udd17:** The methods `Dataset.to_tf_dataset()` and its higher-level wrapper `model.prepare_tf_dataset()` , which you will see throughout our TF code examples, will both fail on a TPU Node. The reason for this is that even though they create a `tf.data.Dataset` it is not a \u201cpure\u201d `tf.data` pipeline and uses `tf.numpy_function` or `Dataset.from_generator()` to stream data from the underlying HuggingFace `Dataset`. This HuggingFace `Dataset` is backed by data that is on a local disc and which the remote TPU Node will not be able to read.\n\n</Tip>\n\nThe second way to access a TPU is via a **TPU VM.** When using a TPU VM, you connect directly to the machine that the TPU is attached to, much like training on a GPU VM. TPU VMs are generally easier to work with, particularly when it comes to your data pipeline. All of the above warnings do not apply to TPU VMs!\n\nThis is an opinionated document, so here\u2019s our opinion: **Avoid using TPU Node if possible.** It is more confusing and more difficult to debug than TPU VMs. It is also likely to be unsupported in future - Google\u2019s latest TPU, TPUv4, can only be accessed as a TPU VM, which suggests that TPU Nodes are increasingly going to become a \u201clegacy\u201d access method. However, we understand that the only free TPU access is on Colab and Kaggle Kernels, which uses TPU Node - so we\u2019ll try to explain how to handle it if you have to! Check the [TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) for code samples that explain this in more detail.\n\n### What sizes of TPU are available?\n\nA single TPU (a v2-8/v3-8/v4-8) runs 8 replicas. TPUs exist in **pods** that can run hundreds or thousands of replicas simultaneously. When you use more than a single TPU but less than a whole pod (for example, a v3-32), your TPU fleet is referred to as a **pod slice.**\n\nWhen you access a free TPU via Colab, you generally get a single v2-8 TPU.\n\n### I keep hearing about this XLA thing. What\u2019s XLA, and how does it relate to TPUs?\n\nXLA is an optimizing compiler, used by both TensorFlow and JAX. In JAX it is the only compiler, whereas in TensorFlow it is optional\n--New Chunk--\n[Created at: 2025-03-24 13:16:13]\n=predictions, references=references)\n>>> results\n{'exact_match': 100.0, 'f1': 100.0}\n```\n\nYou can find examples of dataset structures by consulting the \"Dataset Preview\" function or the dataset card for a given dataset, and you can see how to use its dedicated evaluation function based on the metric card."
        }
    },
    {
        "sample_idx": 105,
        "question": "What is the name of the dataset used for fine-tuning LayoutLMv3 for token classification?",
        "answer": "CORD.",
        "rag_answer": "The datasets used for fine-tuning LayoutLMv3 for token classification are FUNSD and CORD.",
        "rag_score": 5,
        "rag_feedback": "The system's response is completely correct, accurate, and factual. It provides the correct answer to the question, which is CORD, and also provides additional relevant information about fine-tuning LayoutLMv3 for token classification on form understanding datasets, including FUNSD and CORD.",
        "rag_context": {
            "kg_context": "-----Entities-----\n    ```csv\n    id,\tentity,\ttype,\tdescription,\trankcreated_at\n1,\tFUNSD,geo,FUNSD is a form understanding dataset used for fine-tuning LayoutLMv3.,1,2025-03-24 13:19:57\n2,\tLayoutLMv3,technology,LayoutLMv3 is a model used for token classification and form understanding tasks.,11,2025-03-24 13:19:57\n3,\tTensorboard,technology,Tensorboard is a tool used for visualizing the training metrics of the LayoutLMv3 model.,1,2025-03-24 13:19:57\n4,\tTrainer API,technology,Trainer API is a tool used for fine-tuning the LayoutLMv3 model.,1,2025-03-24 13:19:57\n5,\tNLP,category,NLP is a field of study focused on natural language processing and machine learning.,1,UNKNOWN\n6,\tGLUE,dataset,GLUE is a benchmark dataset for evaluating natural language processing models.,1,UNKNOWN\n7,\tMachine Learning,category,Machine Learning is a field of study that involves training models to make predictions.,5,UNKNOWN\n    ```\n    -----Relationships-----\n    ```csv\n    id,\tsource,\ttarget,\tdescription,\tkeywords,\tweight,\trank,\tcreated_at\n1,\tFUNSD,LayoutLMv3,FUNSD is a dataset used for fine-tuning the LayoutLMv3 model.,dataset, model training,14.0,12,2025-03-24 13:19:57\n2,\tLayoutLMv3,Tensorboard,Tensorboard is a tool used for visualizing the training metrics of the LayoutLMv3 model.,tool, model visualization,7.0,12,2025-03-24 13:19:57\n3,\tLayoutLMv3,Trainer API,Trainer API is a tool used for fine-tuning the LayoutLMv3 model.,tool, model fine-tuning,7.0,12,2025-03-24 13:19:57\n4,\tGLUE,Hugging Face,Hugging Face provides a platform for evaluating models on the GLUE benchmark dataset.,evaluation platform, benchmark dataset,16.0,9,UNKNOWN\n5,\tMachine Learning,Model,Machine Learning involves training models to make predictions.,field of study, model training,9.0,8,UNKNOWN\n6,\tHuggingFace,NLP,HuggingFace provides tools and resources for NLP and machine learning.,resource provision, NLP support,16.0,6,UNKNOWN\n7,\tMachine Learning,accuracy,accuracy is a metric used to evaluate machine learning models.,evaluation metric, task,9.0,6,UNKNOWN\n8,\tMachine Learning,precision,precision is a metric used to evaluate machine learning models.,evaluation metric, task,9.0,6,UNKNOWN\n9,\tMachine Learning,perplexity,perplexity is a metric used to evaluate machine learning models.,evaluation metric, task,9.0,6,UNKNOWN\n10,\tMachine Learning,Papers With Code,Papers With Code provides a platform for tracking machine learning papers and their corresponding code.,research platform, machine learning,8.0,6,UNKNOWN\n    ```\n    -----Sources-----\n    ```csv\n    id,\tcontent\n1,\t!---\nCopyright 2022 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n-->\n\n# Token classification with LayoutLMv3 (PyTorch version)\n\nThis directory contains a script, `run_funsd_cord.py`, that can be used to fine-tune (or evaluate) LayoutLMv3 on form understanding datasets, such as [FUNSD](https://guillaumejaume.github.io/FUNSD/) and [CORD](https://github.com/clovaai/cord).\n\nThe script `run_funsd_cord.py` leverages the \ud83e\udd17 Datasets library and the Trainer API. You can easily customize it to your needs.\n\n## Fine-tuning on FUNSD\n\nFine-tuning LayoutLMv3 for token classification on [FUNSD](https://guillaumejaume.github.io/FUNSD/) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name funsd \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 1e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-funsd\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd. By specifying the `push_to_hub` flag, the model gets uploaded automatically to the hub (regularly), together with a model card, which includes metrics such as precision, recall and F1. Note that you can easily update the model card, as it's just a README file of the respective repo on the hub.\n\nThere's also the \"Training metrics\" [tab](https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd/tensorboard), which shows Tensorboard logs over the course of training. Pretty neat, huh?\n\n## Fine-tuning on CORD\n\nFine-tuning LayoutLMv3 for token classification on [CORD](https://github.com/clovaai/cord) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name cord \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 5e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-cord\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-cord. Note that a model card gets generated automatically in case you specify the `push_to_hub` flag.\n2,\tlabel_mask  # Set negative label positions to 0\nmean_loss = tf.reduce_sum(loss) / tf.reduce_sum(label_mask)\n```\n\nHere, we avoid data-dependent shapes by computing the loss for every position, but zeroing out the masked positions in both the numerator and denominator when we calculate the mean, which yields exactly the same result as the first block while maintaining XLA compatibility. Note that we use the same trick as in rule #1 - converting a `tf.bool` to `tf.float32` and using it as an indicator variable. This is a really useful trick, so remember it if you need to convert your own code to XLA!\n\n#### XLA Rule #3: XLA will need to recompile your model for every different input shape it sees\n\nThis is the big one. What this means is that if your input shapes are very variable, XLA will have to recompile your model over and over, which will create huge performance problems. This commonly arises in NLP models, where input texts have variable lengths after tokenization. In other modalities, static shapes are more common and this rule is much less of a problem.\n\nHow can you get around rule #3? The key is **padding** - if you pad all your inputs to the same length, and then use an `attention_mask`, you can get the same results as you\u2019d get from variable shapes, but without any XLA issues. However, excessive padding can cause severe slowdown too - if you pad all your samples to the maximum length in the whole dataset, you might end up with batches consisting endless padding tokens, which will waste a lot of compute and memory!\n\nThere isn\u2019t a perfect solution to this problem. However, you can try some tricks. One very useful trick is to **pad batches of samples up to a multiple of a number like 32 or 64 tokens.** This often only increases the number of tokens by a small amount, but it hugely reduces the number of unique input shapes, because every input shape now has to be a multiple of 32 or 64. Fewer unique input shapes means fewer XLA compilations!\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** Our tokenizers and data collators have methods that can help you here. You can use `padding=\"max_length\"` or `padding=\"longest\"` when calling tokenizers to get them to output padded data. Our tokenizers and data collators also have a `pad_to_multiple_of` argument that you can use to reduce the number of unique input shapes you see!\n\n</Tip>\n\n### How do I actually train my model on TPU?\n\nOnce your training is XLA-compatible and (if you\u2019re using TPU Node / Colab) your dataset has been prepared appropriately, running on TPU is surprisingly easy! All you really need to change in your code is to add a few lines to initialize your TPU, and to ensure that your model and dataset are created inside a `TPUStrategy` scope. Take a look at [our TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) to see this in action!\n\n### Summary\n\nThere was a lot in here, so let\u2019s summarize with a quick checklist you can follow when you want to get your model ready for TPU training:\n\n- Make sure your code follows the three rules of XLA\n- Compile your model with `jit_compile=True` on CPU/GPU and confirm that you can train it with XLA\n- Either load your dataset into memory or use a TPU-compatible dataset loading approach (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Migrate your code either to Colab (with accelerator set to \u201cTPU\u201d) or a TPU VM on Google Cloud\n- Add TPU initializer code (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Create your `TPUStrategy` and make sure dataset loading and model creation are inside the `strategy.scope()` (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Don\u2019t forget to take `jit_compile=True` out again when you move to TPU!\n- \ud83d\ude4f\ud83d\ude4f\ud83d\ude4f\ud83e\udd7a\ud83e\udd7a\ud83e\udd7a\n- Call model.fit()\n- You did it!\n3,\tChoosing a metric for your task\n\n**So you've trained your model and want to see how well it\u2019s doing on a dataset of your choice. Where do you start?**\n\nThere is no \u201cone size fits all\u201d approach to choosing an evaluation metric, but some good guidelines to keep in mind are:\n\n## Categories of metrics\n\nThere are 3 high-level categories of metrics:\n\n1. *Generic metrics*, which can be applied to a variety of situations and datasets, such as precision and accuracy.\n2. *Task-specific metrics*, which are limited to a given task, such as Machine Translation (often evaluated using metrics [BLEU](https://huggingface.co/metrics/bleu) or [ROUGE](https://huggingface.co/metrics/rouge)) or Named Entity Recognition (often evaluated with [seqeval](https://huggingface.co/metrics/seqeval)).\n3. *Dataset-specific metrics*, which aim to measure model performance on specific benchmarks: for instance, the [GLUE benchmark](https://huggingface.co/datasets/glue) has a dedicated [evaluation metric](https://huggingface.co/metrics/glue).\n\nLet's look at each of these three cases:\n\n### Generic metrics\n\nMany of the metrics used in the Machine Learning community are quite generic and can be applied in a variety of tasks and datasets.\n\nThis is the case for metrics like [accuracy](https://huggingface.co/metrics/accuracy) and [precision](https://huggingface.co/metrics/precision), which can be used for evaluating labeled (supervised) datasets, as well as [perplexity](https://huggingface.co/metrics/perplexity), which can be used for evaluating different kinds of (unsupervised) generative tasks.\n\nTo see the input structure of a given metric, you can look at its metric card. For example, in the case of [precision](https://huggingface.co/metrics/precision), the format is:\n```\n>>> precision_metric = evaluate.load(\"precision\")\n>>> results = precision_metric.compute(references=[0, 1], predictions=[0, 1])\n>>> print(results)\n{'precision': 1.0}\n```\n\n### Task-specific metrics\n\nPopular ML tasks like Machine Translation and Named Entity Recognition have specific metrics that can be used to compare models. For example, a series of different metrics have been proposed for text generation, ranging from [BLEU](https://huggingface.co/metrics/bleu) and its derivatives such as [GoogleBLEU](https://huggingface.co/metrics/google_bleu) and [GLEU](https://huggingface.co/metrics/gleu), but also [ROUGE](https://huggingface.co/metrics/rouge), [MAUVE](https://huggingface.co/metrics/mauve), etc.\n\nYou can find the right metric for your task by:\n\n- **Looking at the [Task pages](https://huggingface.co/tasks)** to see what metrics can be used for evaluating models for a given task.\n- **Checking out leaderboards** on sites like [Papers With Code](https://paperswithcode.com/) (you can search by task and by dataset).\n-  **Reading the metric cards** for the relevant metrics and see which ones are a good fit for your use case. For example, see the [BLEU metric card](https://github.com/huggingface/evaluate/tree/main/metrics/bleu) or [SQuaD metric card](https://github.com/huggingface/evaluate/tree/main/metrics/squad).\n- **Looking at papers and blog posts** published on the topic and see what metrics they report. This can change over time, so try to pick papers from the last couple of years!\n\n### Dataset-specific metrics\n\nSome datasets have specific metrics associated with them -- this is especially in the case of popular benchmarks like [GLUE](https://huggingface.co/metrics/glue) and [SQuAD](https://huggingface.co/metrics/squad).\n\n<Tip warning={true}>\n\ud83d\udca1\nGLUE is actually a collection of different subsets on different tasks, so first you need to choose the one that corresponds to the NLI task, such as mnli, which is described as \u201ccrowdsourced collection of sentence pairs with textual entailment annotations\u201d\n</Tip>\n\n\nIf you are evaluating your model on a benchmark dataset like the ones mentioned above, you can use its dedicated evaluation metric. Make sure you respect the format that they require. For example, to evaluate your model on the [SQuAD](https://huggingface.co/datasets/squad) dataset, you need to feed the `question` and `context` into your model and return the `prediction_text`, which should be compared with the `references` (based on matching the `id` of the question) :\n\n```\n>>> from evaluate import load\n>>> squad_metric = load(\"squad\")\n>>> predictions = [{'prediction_text': '1976', 'id': '56e10a3be3433e1400422b22'}]\n>>> references = [{'answers': {'answer_start': [97], 'text': ['1976']}, 'id': '56e10a3be3433e1400422b22'}]\n>>> results = squad_metric.compute(predictions=predictions, references=references)\n>>> results\n{'exact_match': 100.0, 'f1': 100.0}\n```\n\nYou can find examples of dataset structures by consulting the \"Dataset Preview\" function or the dataset card for a given dataset, and you can see how to use its dedicated evaluation function based on the metric card.\n4,\t=predictions, references=references)\n>>> results\n{'exact_match': 100.0, 'f1': 100.0}\n```\n\nYou can find examples of dataset structures by consulting the \"Dataset Preview\" function or the dataset card for a given dataset, and you can see how to use its dedicated evaluation function based on the metric card.\n    ```",
            "vector_context": "[Created at: 2025-03-24 13:19:17]\n!---\nCopyright 2022 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n-->\n\n# Token classification with LayoutLMv3 (PyTorch version)\n\nThis directory contains a script, `run_funsd_cord.py`, that can be used to fine-tune (or evaluate) LayoutLMv3 on form understanding datasets, such as [FUNSD](https://guillaumejaume.github.io/FUNSD/) and [CORD](https://github.com/clovaai/cord).\n\nThe script `run_funsd_cord.py` leverages the \ud83e\udd17 Datasets library and the Trainer API. You can easily customize it to your needs.\n\n## Fine-tuning on FUNSD\n\nFine-tuning LayoutLMv3 for token classification on [FUNSD](https://guillaumejaume.github.io/FUNSD/) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name funsd \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 1e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-funsd\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd. By specifying the `push_to_hub` flag, the model gets uploaded automatically to the hub (regularly), together with a model card, which includes metrics such as precision, recall and F1. Note that you can easily update the model card, as it's just a README file of the respective repo on the hub.\n\nThere's also the \"Training metrics\" [tab](https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd/tensorboard), which shows Tensorboard logs over the course of training. Pretty neat, huh?\n\n## Fine-tuning on CORD\n\nFine-tuning LayoutLMv3 for token classification on [CORD](https://github.com/clovaai/cord) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name cord \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 5e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-cord\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-cord. Note that a model card gets generated automatically in case you specify the `push_to_hub` flag.\n--New Chunk--\n[Created at: 2025-03-24 13:16:13]\nChoosing a metric for your task\n\n**So you've trained your model and want to see how well it\u2019s doing on a dataset of your choice. Where do you start?**\n\nThere is no \u201cone size fits all\u201d approach to choosing an evaluation metric, but some good guidelines to keep in mind are:\n\n## Categories of metrics\n\nThere are 3 high-level categories of metrics:\n\n1. *Generic metrics*, which can be applied to a variety of situations and datasets, such as precision and accuracy.\n2. *Task-specific metrics*, which are limited to a given task, such as Machine Translation (often evaluated using metrics [BLEU](https://huggingface.co/metrics/bleu) or [ROUGE](https://huggingface.co/metrics/rouge)) or Named Entity Recognition (often evaluated with [seqeval](https://huggingface.co/metrics/seqeval)).\n3. *Dataset-specific metrics*, which aim to measure model performance on specific benchmarks: for instance, the [GLUE benchmark](https://huggingface.co/datasets/glue) has a dedicated [evaluation metric](https://huggingface.co/metrics/glue).\n\nLet's look at each of these three cases:\n\n### Generic metrics\n\nMany of the metrics used in the Machine Learning community are quite generic and can be applied in a variety of tasks and datasets.\n\nThis is the case for metrics like [accuracy](https://huggingface.co/metrics/accuracy) and [precision](https://huggingface.co/metrics/precision), which can be used for evaluating labeled (supervised) datasets, as well as [perplexity](https://huggingface.co/metrics/perplexity), which can be used for evaluating different kinds of (unsupervised) generative tasks.\n\nTo see the input structure of a given metric, you can look at its metric card. For example, in the case of [precision](https://huggingface.co/metrics/precision), the format is:\n```\n>>> precision_metric = evaluate.load(\"precision\")\n>>> results = precision_metric.compute(references=[0, 1], predictions=[0, 1])\n>>> print(results)\n{'precision': 1.0}\n```\n\n### Task-specific metrics\n\nPopular ML tasks like Machine Translation and Named Entity Recognition have specific metrics that can be used to compare models. For example, a series of different metrics have been proposed for text generation, ranging from [BLEU](https://huggingface.co/metrics/bleu) and its derivatives such as [GoogleBLEU](https://huggingface.co/metrics/google_bleu) and [GLEU](https://huggingface.co/metrics/gleu), but also [ROUGE](https://huggingface.co/metrics/rouge), [MAUVE](https://huggingface.co/metrics/mauve), etc.\n\nYou can find the right metric for your task by:\n\n- **Looking at the [Task pages](https://huggingface.co/tasks)** to see what metrics can be used for evaluating models for a given task.\n- **Checking out leaderboards** on sites like [Papers With Code](https://paperswithcode.com/) (you can search by task and by dataset).\n-  **Reading the metric cards** for the relevant metrics and see which ones are a good fit for your use case. For example, see the [BLEU metric card](https://github.com/huggingface/evaluate/tree/main/metrics/bleu) or [SQuaD metric card](https://github.com/huggingface/evaluate/tree/main/metrics/squad).\n- **Looking at papers and blog posts** published on the topic and see what metrics they report. This can change over time, so try to pick papers from the last couple of years!\n\n### Dataset-specific metrics\n\nSome datasets have specific metrics associated with them -- this is especially in the case of popular benchmarks like [GLUE](https://huggingface.co/metrics/glue) and [SQuAD](https://huggingface.co/metrics/squad).\n\n<Tip warning={true}>\n\ud83d\udca1\nGLUE is actually a collection of different subsets on different tasks, so first you need to choose the one that corresponds to the NLI task, such as mnli, which is described as \u201ccrowdsourced collection of sentence pairs with textual entailment annotations\u201d\n</Tip>\n\n\nIf you are evaluating your model on a benchmark dataset like the ones mentioned above, you can use its dedicated evaluation metric. Make sure you respect the format that they require. For example, to evaluate your model on the [SQuAD](https://huggingface.co/datasets/squad) dataset, you need to feed the `question` and `context` into your model and return the `prediction_text`, which should be compared with the `references` (based on matching the `id` of the question) :\n\n```\n>>> from evaluate import load\n>>> squad_metric = load(\"squad\")\n>>> predictions = [{'prediction_text': '1976', 'id': '56e10a3be3433e1400422b22'}]\n>>> references = [{'answers': {'answer_start': [97], 'text': ['1976']}, 'id': '56e10a3be3433e1400422b22'}]\n>>> results = squad_metric.compute(predictions=predictions, references=references)\n>>> results\n{'exact_match': 100.0, 'f1': 100.0}\n```\n\nYou can find examples of dataset structures by consulting the \"Dataset Preview\" function or the dataset card for a given dataset, and you can see how to use its dedicated evaluation function based on the metric card.\n--New Chunk--\n[Created at: 2025-03-24 13:16:13]\n=predictions, references=references)\n>>> results\n{'exact_match': 100.0, 'f1': 100.0}\n```\n\nYou can find examples of dataset structures by consulting the \"Dataset Preview\" function or the dataset card for a given dataset, and you can see how to use its dedicated evaluation function based on the metric card."
        }
    },
    {
        "sample_idx": 106,
        "question": "What is the model_id of the resulting model after fine-tuning LayoutLMv3 on CORD?",
        "answer": "layoutlmv3-finetuned-cord.",
        "rag_answer": "The model_id of the resulting model after fine-tuning LayoutLMv3 on CORD is `layoutlmv3-finetuned-cord`.",
        "rag_score": 5,
        "rag_feedback": "The system's response is completely correct, accurate, and factual. It directly answers the question by stating 'The model_id of the resulting model after fine-tuning LayoutLMv3 on CORD is `layoutlmv3-finetuned-cord`.', which matches the expected answer.",
        "rag_context": {
            "kg_context": "-----Entities-----\n    ```csv\n    id,\tentity,\ttype,\tdescription,\trankcreated_at\n1,\tCORD,geo,CORD is a form understanding dataset used for fine-tuning LayoutLMv3.,1,2025-03-24 13:19:57\n2,\tLayoutLMv3,technology,LayoutLMv3 is a model used for token classification and form understanding tasks.,11,2025-03-24 13:19:57\n3,\trun_funsd_cord.py,UNKNOWN,run_funsd_cord.py is a script used for fine-tuning the LayoutLMv3 model.,1,2025-03-24 13:19:57\n4,\tDatasets library,technology,Datasets library is a tool used for fine-tuning the LayoutLMv3 model.,1,2025-03-24 13:19:57\n5,\tModel,category,Model refers to a machine learning model being evaluated.,3,UNKNOWN\n6,\tExact Match,category,Exact Match is a metric used to evaluate the performance of a model.,1,UNKNOWN\n7,\tResults,event,Results are the outcome of evaluating a model, in this case, showing perfect accuracy.,1,UNKNOWN\n    ```\n    -----Relationships-----\n    ```csv\n    id,\tsource,\ttarget,\tdescription,\tkeywords,\tweight,\trank,\tcreated_at\n1,\tCORD,LayoutLMv3,CORD is a dataset used for fine-tuning the LayoutLMv3 model.,dataset, model training,14.0,12,2025-03-24 13:19:57\n2,\tLayoutLMv3,run_funsd_cord.py,run_funsd_cord.py is a script used for fine-tuning the LayoutLMv3 model.,script, model fine-tuning,7.0,12,2025-03-24 13:19:57\n3,\tDatasets library,LayoutLMv3,Datasets library is a tool used for fine-tuning the LayoutLMv3 model.,tool, model fine-tuning,7.0,12,2025-03-24 13:19:57\n4,\tMachine Learning,Model,Machine Learning involves training models to make predictions.,field of study, model training,9.0,8,UNKNOWN\n5,\tEvaluation Function,Model,The evaluation function is used to assess the performance of the model.,model evaluation, performance assessment,18.0,5,UNKNOWN\n6,\tModel,Predictions,The model makes predictions based on the input data.,model output, predictions,8.0,5,UNKNOWN\n7,\tEvaluation Function,Results,The results are obtained by using the evaluation function.,evaluation outcome, accuracy,20.0,3,UNKNOWN\n8,\tExact Match,F1,Exact Match and F1 are both metrics used to evaluate the performance of a model.,evaluation metrics, performance assessment,8.0,2,UNKNOWN\n    ```\n    -----Sources-----\n    ```csv\n    id,\tcontent\n1,\t!---\nCopyright 2022 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n-->\n\n# Token classification with LayoutLMv3 (PyTorch version)\n\nThis directory contains a script, `run_funsd_cord.py`, that can be used to fine-tune (or evaluate) LayoutLMv3 on form understanding datasets, such as [FUNSD](https://guillaumejaume.github.io/FUNSD/) and [CORD](https://github.com/clovaai/cord).\n\nThe script `run_funsd_cord.py` leverages the \ud83e\udd17 Datasets library and the Trainer API. You can easily customize it to your needs.\n\n## Fine-tuning on FUNSD\n\nFine-tuning LayoutLMv3 for token classification on [FUNSD](https://guillaumejaume.github.io/FUNSD/) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name funsd \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 1e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-funsd\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd. By specifying the `push_to_hub` flag, the model gets uploaded automatically to the hub (regularly), together with a model card, which includes metrics such as precision, recall and F1. Note that you can easily update the model card, as it's just a README file of the respective repo on the hub.\n\nThere's also the \"Training metrics\" [tab](https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd/tensorboard), which shows Tensorboard logs over the course of training. Pretty neat, huh?\n\n## Fine-tuning on CORD\n\nFine-tuning LayoutLMv3 for token classification on [CORD](https://github.com/clovaai/cord) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name cord \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 5e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-cord\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-cord. Note that a model card gets generated automatically in case you specify the `push_to_hub` flag.\n2,\t=predictions, references=references)\n>>> results\n{'exact_match': 100.0, 'f1': 100.0}\n```\n\nYou can find examples of dataset structures by consulting the \"Dataset Preview\" function or the dataset card for a given dataset, and you can see how to use its dedicated evaluation function based on the metric card.\n    ```",
            "vector_context": "[Created at: 2025-03-24 13:19:17]\n!---\nCopyright 2022 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n-->\n\n# Token classification with LayoutLMv3 (PyTorch version)\n\nThis directory contains a script, `run_funsd_cord.py`, that can be used to fine-tune (or evaluate) LayoutLMv3 on form understanding datasets, such as [FUNSD](https://guillaumejaume.github.io/FUNSD/) and [CORD](https://github.com/clovaai/cord).\n\nThe script `run_funsd_cord.py` leverages the \ud83e\udd17 Datasets library and the Trainer API. You can easily customize it to your needs.\n\n## Fine-tuning on FUNSD\n\nFine-tuning LayoutLMv3 for token classification on [FUNSD](https://guillaumejaume.github.io/FUNSD/) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name funsd \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 1e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-funsd\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd. By specifying the `push_to_hub` flag, the model gets uploaded automatically to the hub (regularly), together with a model card, which includes metrics such as precision, recall and F1. Note that you can easily update the model card, as it's just a README file of the respective repo on the hub.\n\nThere's also the \"Training metrics\" [tab](https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd/tensorboard), which shows Tensorboard logs over the course of training. Pretty neat, huh?\n\n## Fine-tuning on CORD\n\nFine-tuning LayoutLMv3 for token classification on [CORD](https://github.com/clovaai/cord) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name cord \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 5e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-cord\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-cord. Note that a model card gets generated automatically in case you specify the `push_to_hub` flag.\n--New Chunk--\n[Created at: 2025-03-24 13:17:32]\n(for example, a v3-32), your TPU fleet is referred to as a **pod slice.**\n\nWhen you access a free TPU via Colab, you generally get a single v2-8 TPU.\n\n### I keep hearing about this XLA thing. What\u2019s XLA, and how does it relate to TPUs?\n\nXLA is an optimizing compiler, used by both TensorFlow and JAX. In JAX it is the only compiler, whereas in TensorFlow it is optional (but mandatory on TPU!). The easiest way to enable it when training a Keras model is to pass the argument `jit_compile=True` to `model.compile()`. If you don\u2019t get any errors and performance is good, that\u2019s a great sign that you\u2019re ready to move to TPU!\n\nDebugging on TPU is generally a bit harder than on CPU/GPU, so we recommend getting your code running on CPU/GPU with XLA first before trying it on TPU. You don\u2019t have to train for long, of course - just for a few steps to make sure that your model and data pipeline are working like you expect them to.\n\n<Tip>\n\nXLA compiled code is usually faster - so even if you\u2019re not planning to run on TPU, adding `jit_compile=True` can improve your performance. Be sure to note the caveats below about XLA compatibility, though!\n\n</Tip>\n\n<Tip warning={true}>\n\n**Tip born of painful experience:** Although using `jit_compile=True` is a good way to get a speed boost and test if your CPU/GPU code is XLA-compatible, it can actually cause a lot of problems if you leave it in when actually training on TPU. XLA compilation will happen implicitly on TPU, so remember to remove that line before actually running your code on a TPU!\n\n</Tip>\n\n### How do I make my model XLA compatible?\n\nIn many cases, your code is probably XLA-compatible already! However, there are a few things that work in normal TensorFlow that don\u2019t work in XLA. We\u2019ve distilled them into three core rules below:\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** We\u2019ve put a lot of effort into rewriting our TensorFlow models and loss functions to be XLA-compatible. Our models and loss functions generally obey rule #1 and #2 by default, so you can skip over them if you\u2019re using `transformers` models. Don\u2019t forget about these rules when writing your own models and loss functions, though!\n\n</Tip>\n\n#### XLA Rule #1: Your code cannot have \u201cdata-dependent conditionals\u201d\n\nWhat that means is that any `if` statement cannot depend on values inside a `tf.Tensor`. For example, this code block cannot be compiled with XLA!\n\n```python\nif tf.reduce_sum(tensor) > 10:\n    tensor = tensor / 2.0\n```\n\nThis might seem very restrictive at first, but most neural net code doesn\u2019t need to do this. You can often get around this restriction by using `tf.cond` (see the documentation [here](https://www.tensorflow.org/api_docs/python/tf/cond)) or by removing the conditional and finding a clever math trick with indicator variables instead, like so:\n\n```python\nsum_over_10 = tf.cast(tf.reduce_sum(tensor) > 10, tf.float32)\ntensor = tensor / (1.0 + sum_over_10)\n```\n\nThis code has exactly the same effect as the code above, but by avoiding a conditional, we ensure it will compile with XLA without problems!\n\n#### XLA Rule #2: Your code cannot have \u201cdata-dependent shapes\u201d\n\nWhat this means is that the shape of all of the `tf.Tensor` objects in your code cannot depend on their values. For example, the function `tf.unique` cannot be compiled with XLA, because it returns a `tensor` containing one instance of each unique value in the input. The shape of this output will obviously be different depending on how repetitive the input `Tensor` was, and so XLA refuses to handle it!\n\nIn general, most neural network code obeys rule #2 by default. However, there are a few common cases where it becomes a problem. One very common one is when you use **label masking**, setting your labels to a negative value to indicate that those positions should be ignored when computing the loss. If you look at NumPy or PyTorch loss functions that support label masking, you will often see code like this that uses [boolean indexing](https://numpy.org/doc/stable/user/basics.indexing.html#boolean-array-indexing):\n\n```python\nlabel_mask = labels >= 0\nmasked_outputs = outputs[label_mask]\nmasked_labels = labels[label_mask]\nloss = compute_loss(masked_outputs, masked_labels)\nmean_loss = torch.mean(loss)\n```\n\nThis code is totally fine in NumPy or PyTorch, but it breaks in XLA! Why? Because the shape of `masked_outputs` and `masked_labels` depends on how many positions are masked - that makes it a **data-dependent shape.** However, just like for rule #1, we can often rewrite this code to yield exactly the same output without any data-dependent shapes.\n\n```python\nlabel_mask = tf.cast(labels >= 0, tf.float32)\nloss = compute_loss(outputs, labels)\nloss = loss * label_mask  # Set negative label positions to 0\nmean_loss = tf.reduce_sum(loss) / tf.reduce_sum(label_mask)\n```\n\nHere, we avoid data-dependent shapes by computing the loss for every position, but zeroing out the masked positions in both the numerator and denominator when we calculate the mean, which yields exactly the same result as the first block while maintaining XLA compatibility. Note that we use the same trick as in rule #1 - converting a `tf.bool` to `\n--New Chunk--\n[Created at: 2025-03-24 13:17:32]\n!--Copyright 2023 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\nthe License. You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under the License is distributed on\nan \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n\n\u26a0\ufe0f Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be\nrendered properly in your Markdown viewer.\n\n-->\n\n# Training on TPU with TensorFlow\n\n<Tip>\n\nIf you don't need long explanations and just want TPU code samples to get started with, check out [our TPU example notebook!](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb)\n\n</Tip>\n\n### What is a TPU?\n\nA TPU is a **Tensor Processing Unit.** They are hardware designed by Google, which are used to greatly speed up the tensor computations within neural networks, much like GPUs. They can be used for both network training and inference. They are generally accessed through Google\u2019s cloud services, but small TPUs can also be accessed directly for free through Google Colab and Kaggle Kernels.\n\nBecause [all TensorFlow models in \ud83e\udd17 Transformers are Keras models](https://huggingface.co/blog/tensorflow-philosophy), most of the methods in this document are generally applicable to TPU training for any Keras model! However, there are a few points that are specific to the HuggingFace ecosystem (hug-o-system?) of Transformers and Datasets, and we\u2019ll make sure to flag them up when we get to them.\n\n### What kinds of TPU are available?\n\nNew users are often very confused by the range of TPUs, and the different ways to access them. The first key distinction to understand is the difference between **TPU Nodes** and **TPU VMs.**\n\nWhen you use a **TPU Node**, you are effectively indirectly accessing a remote TPU. You will need a separate VM, which will initialize your network and data pipeline and then forward them to the remote node. When you use a TPU on Google Colab, you are accessing it in the **TPU Node** style.\n\nUsing TPU Nodes can have some quite unexpected behaviour for people who aren\u2019t used to them! In particular, because the TPU is located on a physically different system to the machine you\u2019re running your Python code on, your data cannot be local to your machine - any data pipeline that loads from your machine\u2019s internal storage will totally fail! Instead, data must be stored in Google Cloud Storage where your data pipeline can still access it, even when the pipeline is running on the remote TPU node.\n\n<Tip>\n\nIf you can fit all your data in memory as `np.ndarray` or `tf.Tensor`, then you can `fit()` on that data even when using Colab or a TPU Node, without needing to upload it to Google Cloud Storage.\n\n</Tip>\n\n<Tip>\n\n**\ud83e\udd17Specific Hugging Face Tip\ud83e\udd17:** The methods `Dataset.to_tf_dataset()` and its higher-level wrapper `model.prepare_tf_dataset()` , which you will see throughout our TF code examples, will both fail on a TPU Node. The reason for this is that even though they create a `tf.data.Dataset` it is not a \u201cpure\u201d `tf.data` pipeline and uses `tf.numpy_function` or `Dataset.from_generator()` to stream data from the underlying HuggingFace `Dataset`. This HuggingFace `Dataset` is backed by data that is on a local disc and which the remote TPU Node will not be able to read.\n\n</Tip>\n\nThe second way to access a TPU is via a **TPU VM.** When using a TPU VM, you connect directly to the machine that the TPU is attached to, much like training on a GPU VM. TPU VMs are generally easier to work with, particularly when it comes to your data pipeline. All of the above warnings do not apply to TPU VMs!\n\nThis is an opinionated document, so here\u2019s our opinion: **Avoid using TPU Node if possible.** It is more confusing and more difficult to debug than TPU VMs. It is also likely to be unsupported in future - Google\u2019s latest TPU, TPUv4, can only be accessed as a TPU VM, which suggests that TPU Nodes are increasingly going to become a \u201clegacy\u201d access method. However, we understand that the only free TPU access is on Colab and Kaggle Kernels, which uses TPU Node - so we\u2019ll try to explain how to handle it if you have to! Check the [TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) for code samples that explain this in more detail.\n\n### What sizes of TPU are available?\n\nA single TPU (a v2-8/v3-8/v4-8) runs 8 replicas. TPUs exist in **pods** that can run hundreds or thousands of replicas simultaneously. When you use more than a single TPU but less than a whole pod (for example, a v3-32), your TPU fleet is referred to as a **pod slice.**\n\nWhen you access a free TPU via Colab, you generally get a single v2-8 TPU.\n\n### I keep hearing about this XLA thing. What\u2019s XLA, and how does it relate to TPUs?\n\nXLA is an optimizing compiler, used by both TensorFlow and JAX. In JAX it is the only compiler, whereas in TensorFlow it is optional"
        }
    },
    {
        "sample_idx": 107,
        "question": "What flag needs to be specified to generate a model card automatically?",
        "answer": "The 'push_to_hub' flag.",
        "rag_answer": "According to the provided Data Sources, the `push_to_hub` flag needs to be specified to generate a model card automatically. This is mentioned in the fine-tuning scripts for both FUNSD and CORD datasets.",
        "rag_score": 5,
        "rag_feedback": "The system's response is completely correct, accurate, and factual. It directly answers the question by stating that the 'push_to_hub' flag needs to be specified to generate a model card automatically, and provides additional context from the fine-tuning scripts for both FUNSD and CORD datasets.",
        "rag_context": {
            "kg_context": "-----Entities-----\n    ```csv\n    id,\tentity,\ttype,\tdescription,\trankcreated_at\n1,\tDatasets library,technology,Datasets library is a tool used for fine-tuning the LayoutLMv3 model.,1,2025-03-24 13:19:57\n2,\tLayoutLMv3,technology,LayoutLMv3 is a model used for token classification and form understanding tasks.,11,2025-03-24 13:19:57\n3,\tTrainer API,technology,Trainer API is a tool used for fine-tuning the LayoutLMv3 model.,1,2025-03-24 13:19:57\n4,\trun_funsd_cord.py,UNKNOWN,run_funsd_cord.py is a script used for fine-tuning the LayoutLMv3 model.,1,2025-03-24 13:19:57\n5,\tNielsR,person,NielsR is the user who fine-tuned the LayoutLMv3 model and uploaded it to the hub.,1,UNKNOWN\n6,\tFUNSD,geo,FUNSD is a form understanding dataset used for fine-tuning LayoutLMv3.,1,UNKNOWN\n7,\tModel,category,Model refers to a machine learning model being evaluated.,3,UNKNOWN\n    ```\n    -----Relationships-----\n    ```csv\n    id,\tsource,\ttarget,\tdescription,\tkeywords,\tweight,\trank,\tcreated_at\n1,\tDatasets library,LayoutLMv3,Datasets library is a tool used for fine-tuning the LayoutLMv3 model.,tool, model fine-tuning,7.0,12,2025-03-24 13:19:57\n2,\tLayoutLMv3,Trainer API,Trainer API is a tool used for fine-tuning the LayoutLMv3 model.,tool, model fine-tuning,7.0,12,2025-03-24 13:19:57\n3,\tLayoutLMv3,run_funsd_cord.py,run_funsd_cord.py is a script used for fine-tuning the LayoutLMv3 model.,script, model fine-tuning,7.0,12,2025-03-24 13:19:57\n4,\tLayoutLMv3,NielsR,NielsR fine-tuned the LayoutLMv3 model and uploaded it to the hub.,model fine-tuning, knowledge sharing,16.0,12,UNKNOWN\n5,\tFUNSD,LayoutLMv3,FUNSD is a dataset used for fine-tuning the LayoutLMv3 model.,dataset, model training,14.0,12,UNKNOWN\n6,\tMachine Learning,Model,Machine Learning involves training models to make predictions.,field of study, model training,9.0,8,UNKNOWN\n7,\tEvaluation Function,Model,The evaluation function is used to assess the performance of the model.,model evaluation, performance assessment,18.0,5,UNKNOWN\n8,\tModel,Predictions,The model makes predictions based on the input data.,model output, predictions,8.0,5,UNKNOWN\n    ```\n    -----Sources-----\n    ```csv\n    id,\tcontent\n1,\t!---\nCopyright 2022 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n-->\n\n# Token classification with LayoutLMv3 (PyTorch version)\n\nThis directory contains a script, `run_funsd_cord.py`, that can be used to fine-tune (or evaluate) LayoutLMv3 on form understanding datasets, such as [FUNSD](https://guillaumejaume.github.io/FUNSD/) and [CORD](https://github.com/clovaai/cord).\n\nThe script `run_funsd_cord.py` leverages the \ud83e\udd17 Datasets library and the Trainer API. You can easily customize it to your needs.\n\n## Fine-tuning on FUNSD\n\nFine-tuning LayoutLMv3 for token classification on [FUNSD](https://guillaumejaume.github.io/FUNSD/) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name funsd \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 1e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-funsd\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd. By specifying the `push_to_hub` flag, the model gets uploaded automatically to the hub (regularly), together with a model card, which includes metrics such as precision, recall and F1. Note that you can easily update the model card, as it's just a README file of the respective repo on the hub.\n\nThere's also the \"Training metrics\" [tab](https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd/tensorboard), which shows Tensorboard logs over the course of training. Pretty neat, huh?\n\n## Fine-tuning on CORD\n\nFine-tuning LayoutLMv3 for token classification on [CORD](https://github.com/clovaai/cord) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name cord \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 5e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-cord\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-cord. Note that a model card gets generated automatically in case you specify the `push_to_hub` flag.\n2,\t=predictions, references=references)\n>>> results\n{'exact_match': 100.0, 'f1': 100.0}\n```\n\nYou can find examples of dataset structures by consulting the \"Dataset Preview\" function or the dataset card for a given dataset, and you can see how to use its dedicated evaluation function based on the metric card.\n    ```",
            "vector_context": "[Created at: 2025-03-24 13:19:17]\n!---\nCopyright 2022 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n-->\n\n# Token classification with LayoutLMv3 (PyTorch version)\n\nThis directory contains a script, `run_funsd_cord.py`, that can be used to fine-tune (or evaluate) LayoutLMv3 on form understanding datasets, such as [FUNSD](https://guillaumejaume.github.io/FUNSD/) and [CORD](https://github.com/clovaai/cord).\n\nThe script `run_funsd_cord.py` leverages the \ud83e\udd17 Datasets library and the Trainer API. You can easily customize it to your needs.\n\n## Fine-tuning on FUNSD\n\nFine-tuning LayoutLMv3 for token classification on [FUNSD](https://guillaumejaume.github.io/FUNSD/) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name funsd \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 1e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-funsd\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd. By specifying the `push_to_hub` flag, the model gets uploaded automatically to the hub (regularly), together with a model card, which includes metrics such as precision, recall and F1. Note that you can easily update the model card, as it's just a README file of the respective repo on the hub.\n\nThere's also the \"Training metrics\" [tab](https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd/tensorboard), which shows Tensorboard logs over the course of training. Pretty neat, huh?\n\n## Fine-tuning on CORD\n\nFine-tuning LayoutLMv3 for token classification on [CORD](https://github.com/clovaai/cord) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name cord \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 5e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-cord\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-cord. Note that a model card gets generated automatically in case you specify the `push_to_hub` flag.\n--New Chunk--\n[Created at: 2025-03-24 13:16:13]\n=predictions, references=references)\n>>> results\n{'exact_match': 100.0, 'f1': 100.0}\n```\n\nYou can find examples of dataset structures by consulting the \"Dataset Preview\" function or the dataset card for a given dataset, and you can see how to use its dedicated evaluation function based on the metric card.\n--New Chunk--\n[Created at: 2025-03-24 13:16:48]\n\u4e0e\u5e38\u89c4\u51fd\u6570\u76f8\u540c\u7684\u65b9\u5f0f\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio\u3002\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\uff08\u865a\u62df\u7684\uff09\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5b83\u5728\u8f93\u51fa\u56fe\u50cf\u4e4b\u524d\u751f\u6210\u6570\u4e2a\u6b65\u9aa4\u7684\u566a\u97f3\uff1a\n\n$code_fake_diffusion\n$demo_fake_diffusion\n\n\u8bf7\u6ce8\u610f\uff0c\u6211\u4eec\u5728\u8fed\u4ee3\u5668\u4e2d\u6dfb\u52a0\u4e86 `time.sleep(1)`\uff0c\u4ee5\u521b\u5efa\u6b65\u9aa4\u4e4b\u95f4\u7684\u4eba\u5de5\u6682\u505c\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u89c2\u5bdf\u8fed\u4ee3\u5668\u7684\u6b65\u9aa4\uff08\u5728\u771f\u5b9e\u7684\u56fe\u50cf\u751f\u6210\u6a21\u578b\u4e2d\uff0c\u8fd9\u53ef\u80fd\u662f\u4e0d\u5fc5\u8981\u7684\uff09\u3002\n\n\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio **\u9700\u8981**\u5728\u5e95\u5c42 Interface \u6216 Blocks \u4e2d\u542f\u7528\u961f\u5217\uff08\u8bf7\u53c2\u9605\u4e0a\u9762\u7684\u961f\u5217\u90e8\u5206\uff09\u3002\n\n## \u8fdb\u5ea6\u6761\n\nGradio \u652f\u6301\u521b\u5efa\u81ea\u5b9a\u4e49\u8fdb\u5ea6\u6761\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u81ea\u5b9a\u4e49\u548c\u63a7\u5236\u5411\u7528\u6237\u663e\u793a\u7684\u8fdb\u5ea6\u66f4\u65b0\u3002\u8981\u542f\u7528\u6b64\u529f\u80fd\uff0c\u53ea\u9700\u4e3a\u65b9\u6cd5\u6dfb\u52a0\u4e00\u4e2a\u9ed8\u8ba4\u503c\u4e3a `gr.Progress` \u5b9e\u4f8b\u7684\u53c2\u6570\u5373\u53ef\u3002\u7136\u540e\uff0c\u60a8\u53ef\u4ee5\u76f4\u63a5\u8c03\u7528\u6b64\u5b9e\u4f8b\u5e76\u4f20\u5165 0 \u5230 1 \u4e4b\u95f4\u7684\u6d6e\u70b9\u6570\u6765\u66f4\u65b0\u8fdb\u5ea6\u7ea7\u522b\uff0c\u6216\u8005 with `Progress` \u5b9e\u4f8b\u7684 `tqdm()` \u65b9\u6cd5\u6765\u8ddf\u8e2a\u53ef\u8fed\u4ee3\u5bf9\u8c61\u4e0a\u7684\u8fdb\u5ea6\uff0c\u5982\u4e0b\u6240\u793a\u3002\u5fc5\u987b\u542f\u7528\u961f\u5217\u4ee5\u8fdb\u884c\u8fdb\u5ea6\u66f4\u65b0\u3002\n\n$code_progress_simple\n$demo_progress_simple\n\n\u5982\u679c\u60a8 with `tqdm` \u5e93\uff0c\u5e76\u4e14\u5e0c\u671b\u4ece\u51fd\u6570\u5185\u90e8\u7684\u4efb\u4f55 `tqdm.tqdm` \u81ea\u52a8\u62a5\u544a\u8fdb\u5ea6\u66f4\u65b0\uff0c\u8bf7\u5c06\u9ed8\u8ba4\u53c2\u6570\u8bbe\u7f6e\u4e3a `gr.Progress(track_tqdm=True)`\uff01\n\n## \u6279\u5904\u7406\u51fd\u6570 (Batch Functions)\n\nGradio \u652f\u6301\u4f20\u9012*\u6279\u5904\u7406*\u51fd\u6570\u3002\u6279\u5904\u7406\u51fd\u6570\u53ea\u662f\u63a5\u53d7\u8f93\u5165\u5217\u8868\u5e76\u8fd4\u56de\u9884\u6d4b\u5217\u8868\u7684\u51fd\u6570\u3002\n\n\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\u6279\u5904\u7406\u51fd\u6570\uff0c\u5b83\u63a5\u53d7\u4e24\u4e2a\u8f93\u5165\u5217\u8868\uff08\u4e00\u4e2a\u5355\u8bcd\u5217\u8868\u548c\u4e00\u4e2a\u6574\u6570\u5217\u8868\uff09\uff0c\u5e76\u8fd4\u56de\u4fee\u526a\u8fc7\u7684\u5355\u8bcd\u5217\u8868\u4f5c\u4e3a\u8f93\u51fa\uff1a\n\n```python\nimport time\n\ndef trim_words(words, lens):\n    trimmed_words = []\n    time.sleep(5)\n    for w, l in zip(words, lens):\n        trimmed_words.append(w[:int(l)])\n    return [trimmed_words]\n    for w, l in zip(words, lens):\n```\n\n\u4f7f\u7528\u6279\u5904\u7406\u51fd\u6570\u7684\u4f18\u70b9\u662f\uff0c\u5982\u679c\u542f\u7528\u4e86\u961f\u5217\uff0cGradio \u670d\u52a1\u5668\u53ef\u4ee5\u81ea\u52a8*\u6279\u5904\u7406*\u4f20\u5165\u7684\u8bf7\u6c42\u5e76\u5e76\u884c\u5904\u7406\u5b83\u4eec\uff0c\u4ece\u800c\u53ef\u80fd\u52a0\u5feb\u6f14\u793a\u901f\u5ea6\u3002\u4ee5\u4e0b\u662f Gradio \u4ee3\u7801\u7684\u793a\u4f8b\uff08\u8bf7\u6ce8\u610f `batch=True` \u548c `max_batch_size=16` - \u8fd9\u4e24\u4e2a\u53c2\u6570\u90fd\u53ef\u4ee5\u4f20\u9012\u7ed9\u4e8b\u4ef6\u89e6\u53d1\u5668\u6216 `Interface` \u7c7b\uff09\n\nwith `Interface`\uff1a\n\n```python\ndemo = gr.Interface(trim_words, [\"textbox\", \"number\"], [\"output\"],\n                    batch=True, max_batch_size=16)\ndemo.queue()\ndemo.launch()\n```\n\nwith `Blocks`\uff1a\n\n```python\nimport gradio as gr\n\nwith gr.Blocks() as demo:\n    with gr.Row():\n        word = gr.Textbox(label=\"word\")\n        leng = gr.Number(label=\"leng\")\n        output = gr.Textbox(label=\"Output\")\n    with gr.Row():\n        run = gr.Button()\n\n    event = run.click(trim_words, [word, leng], output, batch=True, max_batch_size=16)\n\ndemo.queue()\ndemo.launch()\n```\n\n\u5728\u4e0a\u9762\u7684\u793a\u4f8b\u4e2d\uff0c\u53ef\u4ee5\u5e76\u884c\u5904\u7406 16 \u4e2a\u8bf7\u6c42\uff08\u603b\u63a8\u7406\u65f6\u95f4\u4e3a 5 \u79d2\uff09\uff0c\u800c\u4e0d\u662f\u5206\u522b\u5904\u7406\u6bcf\u4e2a\u8bf7\u6c42\uff08\u603b\u63a8\u7406\u65f6\u95f4\u4e3a 80 \u79d2\uff09\u3002\u8bb8\u591a Hugging Face \u7684 `transformers` \u548c `diffusers` \u6a21\u578b\u5728 Gradio \u7684\u6279\u5904\u7406\u6a21\u5f0f\u4e0b\u81ea\u7136\u5de5\u4f5c\uff1a\u8fd9\u662f[\u4f7f\u7528\u6279\u5904\u7406\u751f\u6210\u56fe\u50cf\u7684\u793a\u4f8b\u6f14\u793a](https://github.com/gradio-app/gradio/blob/main/demo/diffusers_with_batching/run.py)\n\n\u6ce8\u610f\uff1a\u4f7f\u7528 Gradio \u7684\u6279\u5904\u7406\u51fd\u6570 **requires** \u5728\u5e95\u5c42 Interface \u6216 Blocks \u4e2d\u542f\u7528\u961f\u5217\uff08\u8bf7\u53c2\u9605\u4e0a\u9762\u7684\u961f\u5217\u90e8\u5206\uff09\u3002\n\n## Gradio \u7b14\u8bb0\u672c (Colab Notebooks)\n\nGradio \u53ef\u4ee5\u5728\u4efb\u4f55\u8fd0\u884c Python \u7684\u5730\u65b9\u8fd0\u884c\uff0c\u5305\u62ec\u672c\u5730 Jupyter \u7b14\u8bb0\u672c\u548c\u534f\u4f5c\u7b14\u8bb0\u672c\uff0c\u5982[Google Colab](https://colab.research.google.com/)\u3002\u5bf9\u4e8e\u672c\u5730 Jupyter \u7b14\u8bb0\u672c\u548c Google Colab \u7b14\u8bb0\u672c\uff0cGradio \u5728\u672c\u5730\u670d\u52a1\u5668\u4e0a\u8fd0\u884c\uff0c\u60a8\u53ef\u4ee5\u5728\u6d4f\u89c8\u5668\u4e2d\u4e0e\u4e4b\u4ea4\u4e92\u3002\uff08\u6ce8\u610f\uff1a\u5bf9\u4e8e Google Colab\uff0c\u8fd9\u662f\u901a\u8fc7[\u670d\u52a1\u5de5\u4f5c\u5668\u96a7\u9053](https://github.com/tensorflow/tensorboard/blob/master/docs/design/colab_integration.md)\u5b9e\u73b0\u7684\uff0c\u60a8\u7684\u6d4f\u89c8\u5668\u9700\u8981\u542f\u7528 cookies\u3002\uff09\u5bf9\u4e8e\u5176\u4ed6\u8fdc\u7a0b\u7b14\u8bb0\u672c\uff0cGradio \u4e5f\u5c06\u5728\u670d\u52a1\u5668\u4e0a\u8fd0\u884c\uff0c\u4f46\u60a8\u9700\u8981\u4f7f\u7528[SSH \u96a7\u9053](https://coderwall.com/p/ohk6cg/remote-access-to-ipython-notebooks-via-ssh)\u5728\u672c\u5730\u6d4f\u89c8\u5668\u4e2d\u67e5\u770b\u5e94\u7528\u7a0b\u5e8f\u3002\u901a\u5e38\uff0c\u66f4\u7b80\u5355\u7684\u9009\u62e9\u662f\u4f7f\u7528 Gradio \u5185\u7f6e\u7684\u516c\u5171\u94fe\u63a5\uff0c[\u5728\u4e0b\u4e00\u7bc7\u6307\u5357\u4e2d\u8ba8\u8bba](/sharing-your-app/#sharing-demos)\u3002"
        }
    },
    {
        "sample_idx": 108,
        "question": "How does global state in Blocks work?",
        "answer": "Global state in Blocks works the same as in Interface, where any variable created outside a function call is a reference shared between all users.",
        "rag_answer": "**Global State in Blocks**\n\nGlobal state in Blocks works similarly to global state in Interface. Any variable created outside a function call is a reference shared between all users. This means that if multiple users interact with your Blocks app, they will all be accessing and modifying the same global state.\n\nFor example, if you create a global variable `x` outside a function call, and then modify `x` within a function call, the changes to `x` will be reflected for all users who interact with your app.\n\nHere's an example of how global state works in Blocks:\n```python\nx = 0  # global variable\n\ndef increment_x():\n    global x\n    x += 1\n    return x\n\nwith gr.Blocks() as demo:\n    btn = gr.Button(\"Increment x\")\n    output = gr.Number()\n    btn.click(increment_x, outputs=output)\ndemo.launch()\n```\nIn this example, the global variable `x` is initialized to 0. When the \"Increment x\" button is clicked, the `increment_x` function is called, which increments `x` by 1. The updated value of `x` is then returned and displayed in the output component.\n\nSince `x` is a global variable, all users who interact with this app will be modifying the same `x` variable. If multiple users click the \"Increment x\" button, the value of `x` will be incremented accordingly, and the updated value will be reflected for all users.\n\n**References**\n\n[KG] Gradio Knowledge Graph: Global State\n[DC] Gradio Documentation: State in Blocks",
        "rag_score": 5,
        "rag_feedback": "The system's response is completely correct, accurate, and factual. It provides a detailed explanation of how global state in Blocks works, including examples and references to the Gradio documentation. The response is well-structured and easy to follow, making it a valuable resource for users who want to understand how to use global state in Blocks.",
        "rag_context": {
            "kg_context": "-----Entities-----\n    ```csv\n    id,\tentity,\ttype,\tdescription,\trankcreated_at\n1,\tGradio,organization,Gradio is a platform that supports state in Blocks, providing features such as global state and session state.<SEP>Gradio is an interface that provides various features for demonstrating models, including adding example inputs, custom error messages, descriptive content, flagging, and more.<SEP>Gradio is an organization that provides a platform for building and deploying machine learning models.<SEP>Gradio is an organization that provides a platform for creating and deploying machine learning models.<SEP>Gradio is an organization that provides a demo for blocks_random_slider, and its library is used to create interactive interfaces.,36,2025-03-24 13:20:24\n2,\tState,category,State is a concept in Gradio that refers to the storage of data, including global state and session state.,2,2025-03-24 13:20:24\n3,\tInterface,category,Interface is a category of components in Gradio that enables the creation of custom interfaces.<SEP>Interface is a component of Gradio that allows users to interact with machine learning models.<SEP>Interface is a concept in Gradio that refers to a user interface for demonstrating models.<SEP>Interface is a category related to Gradio, where state works similarly to Blocks.,3,2025-03-24 13:20:24\n4,\tGlobal State,category,Global State is a type of state in Gradio that is shared between all users.,1,2025-03-24 13:20:24\n5,\tSession State,category,Session State is a type of state in Gradio that persists across multiple submits within a page session.,2,2025-03-24 13:20:24\n6,\tBlocks,category,Blocks is a category of components in Gradio that enables the creation of custom interfaces.<SEP>Blocks is a component of Gradio that allows users to build custom interfaces for machine learning models.<SEP>Blocks is a category related to Gradio, where state is used to store data.,2,UNKNOWN\n7,\tHangman,event,Hangman is a game used as an example to demonstrate how to use state in Blocks.,1,UNKNOWN\n8,\tfunc,event,func is an event that occurs when the button is clicked, executing a specific function.,1,UNKNOWN\n    ```\n    -----Relationships-----\n    ```csv\n    id,\tsource,\ttarget,\tdescription,\tkeywords,\tweight,\trank,\tcreated_at\n1,\tGradio,State,Gradio supports state in Blocks, including global state and session state.,platform feature, data storage,18.0,38,2025-03-24 13:20:24\n2,\tInterface,State,State works similarly in Interface and Blocks.,similar concept, data storage,14.0,5,2025-03-24 13:20:24\n3,\tGlobal State,Session State,Global State and Session State are two types of state in Gradio.,state types, data storage,7.0,3,2025-03-24 13:20:24\n4,\tBlocks,Gradio,Gradio provides Blocks components for building custom interfaces.<SEP>Gradio provides the Blocks component for creating custom interfaces.,component relationship, interface creation<SEP>interface building, machine learning,25.0,38,UNKNOWN\n5,\tGradio Demo,func,func is an event that occurs in Gradio Demo when the button is clicked.,event, event,8.0,9,UNKNOWN\n6,\tBlocks,Hangman,Hangman is an example game that uses state in Blocks.,example, game development,16.0,3,UNKNOWN\n    ```\n    -----Sources-----\n    ```csv\n    id,\tcontent\n1,\tState in Blocks\n\nWe covered [State in Interfaces](https://gradio.app/interface-state), this guide takes a look at state in Blocks, which works mostly the same.\n\n## Global State\n\nGlobal state in Blocks works the same as in Interface. Any variable created outside a function call is a reference shared between all users.\n\n## Session State\n\nGradio supports session **state**, where data persists across multiple submits within a page session, in Blocks apps as well. To reiterate, session data is _not_ shared between different users of your model. To store data in a session state, you need to do three things:\n\n1. Create a `gr.State()` object. If there is a default value to this stateful object, pass that into the constructor.\n2. In the event listener, put the `State` object as an input and output.\n3. In the event listener function, add the variable to the input parameters and the return value.\n\nLet's take a look at a game of hangman.\n\n$code_hangman\n$demo_hangman\n\nLet's see how we do each of the 3 steps listed above in this game:\n\n1. We store the used letters in `used_letters_var`. In the constructor of `State`, we set the initial value of this to `[]`, an empty list.\n2. In `btn.click()`, we have a reference to `used_letters_var` in both the inputs and outputs.\n3. In `guess_letter`, we pass the value of this `State` to `used_letters`, and then return an updated value of this `State` in the return statement.\n\nWith more complex apps, you will likely have many State variables storing session state in a single Blocks app.\n\nLearn more about `State` in the [docs](https://gradio.app/docs#state).\n2,\t\u4e0e\u5e38\u89c4\u51fd\u6570\u76f8\u540c\u7684\u65b9\u5f0f\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio\u3002\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\uff08\u865a\u62df\u7684\uff09\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5b83\u5728\u8f93\u51fa\u56fe\u50cf\u4e4b\u524d\u751f\u6210\u6570\u4e2a\u6b65\u9aa4\u7684\u566a\u97f3\uff1a\n\n$code_fake_diffusion\n$demo_fake_diffusion\n\n\u8bf7\u6ce8\u610f\uff0c\u6211\u4eec\u5728\u8fed\u4ee3\u5668\u4e2d\u6dfb\u52a0\u4e86 `time.sleep(1)`\uff0c\u4ee5\u521b\u5efa\u6b65\u9aa4\u4e4b\u95f4\u7684\u4eba\u5de5\u6682\u505c\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u89c2\u5bdf\u8fed\u4ee3\u5668\u7684\u6b65\u9aa4\uff08\u5728\u771f\u5b9e\u7684\u56fe\u50cf\u751f\u6210\u6a21\u578b\u4e2d\uff0c\u8fd9\u53ef\u80fd\u662f\u4e0d\u5fc5\u8981\u7684\uff09\u3002\n\n\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio **\u9700\u8981**\u5728\u5e95\u5c42 Interface \u6216 Blocks \u4e2d\u542f\u7528\u961f\u5217\uff08\u8bf7\u53c2\u9605\u4e0a\u9762\u7684\u961f\u5217\u90e8\u5206\uff09\u3002\n\n## \u8fdb\u5ea6\u6761\n\nGradio \u652f\u6301\u521b\u5efa\u81ea\u5b9a\u4e49\u8fdb\u5ea6\u6761\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u81ea\u5b9a\u4e49\u548c\u63a7\u5236\u5411\u7528\u6237\u663e\u793a\u7684\u8fdb\u5ea6\u66f4\u65b0\u3002\u8981\u542f\u7528\u6b64\u529f\u80fd\uff0c\u53ea\u9700\u4e3a\u65b9\u6cd5\u6dfb\u52a0\u4e00\u4e2a\u9ed8\u8ba4\u503c\u4e3a `gr.Progress` \u5b9e\u4f8b\u7684\u53c2\u6570\u5373\u53ef\u3002\u7136\u540e\uff0c\u60a8\u53ef\u4ee5\u76f4\u63a5\u8c03\u7528\u6b64\u5b9e\u4f8b\u5e76\u4f20\u5165 0 \u5230 1 \u4e4b\u95f4\u7684\u6d6e\u70b9\u6570\u6765\u66f4\u65b0\u8fdb\u5ea6\u7ea7\u522b\uff0c\u6216\u8005 with `Progress` \u5b9e\u4f8b\u7684 `tqdm()` \u65b9\u6cd5\u6765\u8ddf\u8e2a\u53ef\u8fed\u4ee3\u5bf9\u8c61\u4e0a\u7684\u8fdb\u5ea6\uff0c\u5982\u4e0b\u6240\u793a\u3002\u5fc5\u987b\u542f\u7528\u961f\u5217\u4ee5\u8fdb\u884c\u8fdb\u5ea6\u66f4\u65b0\u3002\n\n$code_progress_simple\n$demo_progress_simple\n\n\u5982\u679c\u60a8 with `tqdm` \u5e93\uff0c\u5e76\u4e14\u5e0c\u671b\u4ece\u51fd\u6570\u5185\u90e8\u7684\u4efb\u4f55 `tqdm.tqdm` \u81ea\u52a8\u62a5\u544a\u8fdb\u5ea6\u66f4\u65b0\uff0c\u8bf7\u5c06\u9ed8\u8ba4\u53c2\u6570\u8bbe\u7f6e\u4e3a `gr.Progress(track_tqdm=True)`\uff01\n\n## \u6279\u5904\u7406\u51fd\u6570 (Batch Functions)\n\nGradio \u652f\u6301\u4f20\u9012*\u6279\u5904\u7406*\u51fd\u6570\u3002\u6279\u5904\u7406\u51fd\u6570\u53ea\u662f\u63a5\u53d7\u8f93\u5165\u5217\u8868\u5e76\u8fd4\u56de\u9884\u6d4b\u5217\u8868\u7684\u51fd\u6570\u3002\n\n\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\u6279\u5904\u7406\u51fd\u6570\uff0c\u5b83\u63a5\u53d7\u4e24\u4e2a\u8f93\u5165\u5217\u8868\uff08\u4e00\u4e2a\u5355\u8bcd\u5217\u8868\u548c\u4e00\u4e2a\u6574\u6570\u5217\u8868\uff09\uff0c\u5e76\u8fd4\u56de\u4fee\u526a\u8fc7\u7684\u5355\u8bcd\u5217\u8868\u4f5c\u4e3a\u8f93\u51fa\uff1a\n\n```python\nimport time\n\ndef trim_words(words, lens):\n    trimmed_words = []\n    time.sleep(5)\n    for w, l in zip(words, lens):\n        trimmed_words.append(w[:int(l)])\n    return [trimmed_words]\n    for w, l in zip(words, lens):\n```\n\n\u4f7f\u7528\u6279\u5904\u7406\u51fd\u6570\u7684\u4f18\u70b9\u662f\uff0c\u5982\u679c\u542f\u7528\u4e86\u961f\u5217\uff0cGradio \u670d\u52a1\u5668\u53ef\u4ee5\u81ea\u52a8*\u6279\u5904\u7406*\u4f20\u5165\u7684\u8bf7\u6c42\u5e76\u5e76\u884c\u5904\u7406\u5b83\u4eec\uff0c\u4ece\u800c\u53ef\u80fd\u52a0\u5feb\u6f14\u793a\u901f\u5ea6\u3002\u4ee5\u4e0b\u662f Gradio \u4ee3\u7801\u7684\u793a\u4f8b\uff08\u8bf7\u6ce8\u610f `batch=True` \u548c `max_batch_size=16` - \u8fd9\u4e24\u4e2a\u53c2\u6570\u90fd\u53ef\u4ee5\u4f20\u9012\u7ed9\u4e8b\u4ef6\u89e6\u53d1\u5668\u6216 `Interface` \u7c7b\uff09\n\nwith `Interface`\uff1a\n\n```python\ndemo = gr.Interface(trim_words, [\"textbox\", \"number\"], [\"output\"],\n                    batch=True, max_batch_size=16)\ndemo.queue()\ndemo.launch()\n```\n\nwith `Blocks`\uff1a\n\n```python\nimport gradio as gr\n\nwith gr.Blocks() as demo:\n    with gr.Row():\n        word = gr.Textbox(label=\"word\")\n        leng = gr.Number(label=\"leng\")\n        output = gr.Textbox(label=\"Output\")\n    with gr.Row():\n        run = gr.Button()\n\n    event = run.click(trim_words, [word, leng], output, batch=True, max_batch_size=16)\n\ndemo.queue()\ndemo.launch()\n```\n\n\u5728\u4e0a\u9762\u7684\u793a\u4f8b\u4e2d\uff0c\u53ef\u4ee5\u5e76\u884c\u5904\u7406 16 \u4e2a\u8bf7\u6c42\uff08\u603b\u63a8\u7406\u65f6\u95f4\u4e3a 5 \u79d2\uff09\uff0c\u800c\u4e0d\u662f\u5206\u522b\u5904\u7406\u6bcf\u4e2a\u8bf7\u6c42\uff08\u603b\u63a8\u7406\u65f6\u95f4\u4e3a 80 \u79d2\uff09\u3002\u8bb8\u591a Hugging Face \u7684 `transformers` \u548c `diffusers` \u6a21\u578b\u5728 Gradio \u7684\u6279\u5904\u7406\u6a21\u5f0f\u4e0b\u81ea\u7136\u5de5\u4f5c\uff1a\u8fd9\u662f[\u4f7f\u7528\u6279\u5904\u7406\u751f\u6210\u56fe\u50cf\u7684\u793a\u4f8b\u6f14\u793a](https://github.com/gradio-app/gradio/blob/main/demo/diffusers_with_batching/run.py)\n\n\u6ce8\u610f\uff1a\u4f7f\u7528 Gradio \u7684\u6279\u5904\u7406\u51fd\u6570 **requires** \u5728\u5e95\u5c42 Interface \u6216 Blocks \u4e2d\u542f\u7528\u961f\u5217\uff08\u8bf7\u53c2\u9605\u4e0a\u9762\u7684\u961f\u5217\u90e8\u5206\uff09\u3002\n\n## Gradio \u7b14\u8bb0\u672c (Colab Notebooks)\n\nGradio \u53ef\u4ee5\u5728\u4efb\u4f55\u8fd0\u884c Python \u7684\u5730\u65b9\u8fd0\u884c\uff0c\u5305\u62ec\u672c\u5730 Jupyter \u7b14\u8bb0\u672c\u548c\u534f\u4f5c\u7b14\u8bb0\u672c\uff0c\u5982[Google Colab](https://colab.research.google.com/)\u3002\u5bf9\u4e8e\u672c\u5730 Jupyter \u7b14\u8bb0\u672c\u548c Google Colab \u7b14\u8bb0\u672c\uff0cGradio \u5728\u672c\u5730\u670d\u52a1\u5668\u4e0a\u8fd0\u884c\uff0c\u60a8\u53ef\u4ee5\u5728\u6d4f\u89c8\u5668\u4e2d\u4e0e\u4e4b\u4ea4\u4e92\u3002\uff08\u6ce8\u610f\uff1a\u5bf9\u4e8e Google Colab\uff0c\u8fd9\u662f\u901a\u8fc7[\u670d\u52a1\u5de5\u4f5c\u5668\u96a7\u9053](https://github.com/tensorflow/tensorboard/blob/master/docs/design/colab_integration.md)\u5b9e\u73b0\u7684\uff0c\u60a8\u7684\u6d4f\u89c8\u5668\u9700\u8981\u542f\u7528 cookies\u3002\uff09\u5bf9\u4e8e\u5176\u4ed6\u8fdc\u7a0b\u7b14\u8bb0\u672c\uff0cGradio \u4e5f\u5c06\u5728\u670d\u52a1\u5668\u4e0a\u8fd0\u884c\uff0c\u4f46\u60a8\u9700\u8981\u4f7f\u7528[SSH \u96a7\u9053](https://coderwall.com/p/ohk6cg/remote-access-to-ipython-notebooks-via-ssh)\u5728\u672c\u5730\u6d4f\u89c8\u5668\u4e2d\u67e5\u770b\u5e94\u7528\u7a0b\u5e8f\u3002\u901a\u5e38\uff0c\u66f4\u7b80\u5355\u7684\u9009\u62e9\u662f\u4f7f\u7528 Gradio \u5185\u7f6e\u7684\u516c\u5171\u94fe\u63a5\uff0c[\u5728\u4e0b\u4e00\u7bc7\u6307\u5357\u4e2d\u8ba8\u8bba](/sharing-your-app/#sharing-demos)\u3002\n3,\t\u65f6\u5fc5\u987b\u9009\u62e9\u5176\u4e2d\u4e00\u4e2a\u5b57\u7b26\u4e32\uff0c\u8fd9\u5c06\u4f5c\u4e3a\u9644\u52a0\u5217\u4fdd\u5b58\u5230 CSV \u4e2d\u3002\n\n## \u9884\u5904\u7406\u548c\u540e\u5904\u7406 (Preprocessing and Postprocessing)\n\n![annotated](/assets/img/dataflow.svg)\n\n\u5982\u60a8\u6240\u89c1\uff0cGradio \u5305\u62ec\u53ef\u4ee5\u5904\u7406\u5404\u79cd\u4e0d\u540c\u6570\u636e\u7c7b\u578b\u7684\u7ec4\u4ef6\uff0c\u4f8b\u5982\u56fe\u50cf\u3001\u97f3\u9891\u548c\u89c6\u9891\u3002\u5927\u591a\u6570\u7ec4\u4ef6\u90fd\u53ef\u4ee5\u7528\u4f5c\u8f93\u5165\u6216\u8f93\u51fa\u3002\n\n\u5f53\u7ec4\u4ef6\u7528\u4f5c\u8f93\u5165\u65f6\uff0cGradio \u81ea\u52a8\u5904\u7406*\u9884\u5904\u7406*\uff0c\u5c06\u6570\u636e\u4ece\u7528\u6237\u6d4f\u89c8\u5668\u53d1\u9001\u7684\u7c7b\u578b\uff08\u4f8b\u5982\u7f51\u7edc\u6444\u50cf\u5934\u5feb\u7167\u7684 base64 \u8868\u793a\uff09\u8f6c\u6362\u4e3a\u60a8\u7684\u51fd\u6570\u53ef\u4ee5\u63a5\u53d7\u7684\u5f62\u5f0f\uff08\u4f8b\u5982 `numpy` \u6570\u7ec4\uff09\u3002\n\n\u540c\u6837\uff0c\u5f53\u7ec4\u4ef6\u7528\u4f5c\u8f93\u51fa\u65f6\uff0cGradio \u81ea\u52a8\u5904\u7406*\u540e\u5904\u7406*\uff0c\u5c06\u6570\u636e\u4ece\u51fd\u6570\u8fd4\u56de\u7684\u5f62\u5f0f\uff08\u4f8b\u5982\u56fe\u50cf\u8def\u5f84\u5217\u8868\uff09\u8f6c\u6362\u4e3a\u53ef\u4ee5\u5728\u7528\u6237\u6d4f\u89c8\u5668\u4e2d\u663e\u793a\u7684\u5f62\u5f0f\uff08\u4f8b\u5982\u4ee5 base64 \u683c\u5f0f\u663e\u793a\u56fe\u50cf\u7684 `Gallery`\uff09\u3002\n\n\u60a8\u53ef\u4ee5\u4f7f\u7528\u6784\u5efa\u56fe\u50cf\u7ec4\u4ef6\u65f6\u7684\u53c2\u6570\u63a7\u5236*\u9884\u5904\u7406*\u3002\u4f8b\u5982\uff0c\u5982\u679c\u60a8\u4f7f\u7528\u4ee5\u4e0b\u53c2\u6570\u5b9e\u4f8b\u5316 `Image` \u7ec4\u4ef6\uff0c\u5b83\u5c06\u5c06\u56fe\u50cf\u8f6c\u6362\u4e3a `PIL` \u7c7b\u578b\uff0c\u5e76\u5c06\u5176\u91cd\u5851\u4e3a`(100, 100)`\uff0c\u800c\u4e0d\u7ba1\u63d0\u4ea4\u65f6\u7684\u539f\u59cb\u5927\u5c0f\u5982\u4f55\uff1a\n\n```py\nimg = gr.Image(shape=(100, 100), type=\"pil\")\n```\n\n\u76f8\u53cd\uff0c\u8fd9\u91cc\u6211\u4eec\u4fdd\u7559\u56fe\u50cf\u7684\u539f\u59cb\u5927\u5c0f\uff0c\u4f46\u5728\u5c06\u5176\u8f6c\u6362\u4e3a numpy \u6570\u7ec4\u4e4b\u524d\u53cd\u8f6c\u989c\u8272\uff1a\n\n```py\nimg = gr.Image(invert_colors=True, type=\"numpy\")\n```\n\n\u540e\u5904\u7406\u8981\u5bb9\u6613\u5f97\u591a\uff01Gradio \u81ea\u52a8\u8bc6\u522b\u8fd4\u56de\u6570\u636e\u7684\u683c\u5f0f\uff08\u4f8b\u5982 `Image` \u662f `numpy` \u6570\u7ec4\u8fd8\u662f `str` \u6587\u4ef6\u8def\u5f84\uff1f\uff09\uff0c\u5e76\u5c06\u5176\u540e\u5904\u7406\u4e3a\u53ef\u4ee5\u7531\u6d4f\u89c8\u5668\u663e\u793a\u7684\u683c\u5f0f\u3002\n\n\u8bf7\u67e5\u770b[\u6587\u6863](https://gradio.app/docs)\uff0c\u4e86\u89e3\u6bcf\u4e2a\u7ec4\u4ef6\u7684\u6240\u6709\u4e0e\u9884\u5904\u7406\u76f8\u5173\u7684\u53c2\u6570\u3002\n\n## \u6837\u5f0f (Styling)\n\nGradio \u4e3b\u9898\u662f\u81ea\u5b9a\u4e49\u5e94\u7528\u7a0b\u5e8f\u5916\u89c2\u548c\u611f\u89c9\u7684\u6700\u7b80\u5355\u65b9\u6cd5\u3002\u60a8\u53ef\u4ee5\u9009\u62e9\u591a\u79cd\u4e3b\u9898\u6216\u521b\u5efa\u81ea\u5df1\u7684\u4e3b\u9898\u3002\u8981\u8fd9\u6837\u505a\uff0c\u8bf7\u5c06 `theme=` \u53c2\u6570\u4f20\u9012\u7ed9 `Interface` \u6784\u9020\u51fd\u6570\u3002\u4f8b\u5982\uff1a\n\n```python\ndemo = gr.Interface(..., theme=gr.themes.Monochrome())\n```\n\nGradio \u5e26\u6709\u4e00\u7ec4\u9884\u5148\u6784\u5efa\u7684\u4e3b\u9898\uff0c\u60a8\u53ef\u4ee5\u4ece `gr.themes.*` \u52a0\u8f7d\u3002\u60a8\u53ef\u4ee5\u6269\u5c55\u8fd9\u4e9b\u4e3b\u9898\u6216\u4ece\u5934\u5f00\u59cb\u521b\u5efa\u81ea\u5df1\u7684\u4e3b\u9898 - \u6709\u5173\u66f4\u591a\u8be6\u7ec6\u4fe1\u606f\uff0c\u8bf7\u53c2\u9605[\u4e3b\u9898\u6307\u5357](https://gradio.app/theming-guide)\u3002\n\n\u8981\u589e\u52a0\u989d\u5916\u7684\u6837\u5f0f\u80fd\u529b\uff0c\u60a8\u53ef\u4ee5 with `css=` \u5173\u952e\u5b57\u5c06\u4efb\u4f55 CSS \u4f20\u9012\u7ed9\u60a8\u7684\u5e94\u7528\u7a0b\u5e8f\u3002\nGradio \u5e94\u7528\u7a0b\u5e8f\u7684\u57fa\u7c7b\u662f `gradio-container`\uff0c\u56e0\u6b64\u4ee5\u4e0b\u662f\u4e00\u4e2a\u66f4\u6539 Gradio \u5e94\u7528\u7a0b\u5e8f\u80cc\u666f\u989c\u8272\u7684\u793a\u4f8b\uff1a\n\n```python\nwith `gr.Interface(css=\".gradio-container {background-color: red}\") as demo:\n    ...\n```\n\n## \u961f\u5217 (Queuing)\n\n\u5982\u679c\u60a8\u7684\u5e94\u7528\u7a0b\u5e8f\u9884\u8ba1\u4f1a\u6709\u5927\u91cf\u6d41\u91cf\uff0c\u8bf7 with `queue()` \u65b9\u6cd5\u6765\u63a7\u5236\u5904\u7406\u901f\u7387\u3002\u8fd9\u5c06\u6392\u961f\u5904\u7406\u8c03\u7528\uff0c\u56e0\u6b64\u4e00\u6b21\u53ea\u5904\u7406\u4e00\u5b9a\u6570\u91cf\u7684\u8bf7\u6c42\u3002\u961f\u5217\u4f7f\u7528 Websockets\uff0c\u8fd8\u53ef\u4ee5\u9632\u6b62\u7f51\u7edc\u8d85\u65f6\uff0c\u56e0\u6b64\u5982\u679c\u60a8\u7684\u51fd\u6570\u7684\u63a8\u7406\u65f6\u95f4\u5f88\u957f\uff08> 1 \u5206\u949f\uff09\uff0c\u5e94\u4f7f\u7528\u961f\u5217\u3002\n\nwith `Interface`\uff1a\n\n```python\ndemo = gr.Interface(...).queue()\ndemo.launch()\n```\n\nwith `Blocks`\uff1a\n\n```python\nwith gr.Blocks() as demo\uff1a\n    #...\ndemo.queue()\ndemo.launch()\n```\n\n\u60a8\u53ef\u4ee5\u901a\u8fc7\u4ee5\u4e0b\u65b9\u5f0f\u63a7\u5236\u4e00\u6b21\u5904\u7406\u7684\u8bf7\u6c42\u6570\u91cf\uff1a\n\n```python\ndemo.queue(concurrency_count=3)\n```\n\n\u67e5\u770b\u6709\u5173\u914d\u7f6e\u5176\u4ed6\u961f\u5217\u53c2\u6570\u7684[\u961f\u5217\u6587\u6863](/docs/#queue)\u3002\n\n\u5728 Blocks \u4e2d\u6307\u5b9a\u4ec5\u5bf9\u67d0\u4e9b\u51fd\u6570\u8fdb\u884c\u6392\u961f\uff1a\n\n```python\nwith gr.Blocks() as demo2\uff1a\n    num1 = gr.Number()\n    num2 = gr.Number()\n    output = gr.Number()\n    gr.Button(\"Add\").click(\n        lambda a, b: a + b, [num1, num2], output)\n    gr.Button(\"Multiply\").click(\n        lambda a, b: a * b, [num1, num2], output, queue=True)\ndemo2.launch()\n```\n\n## \u8fed\u4ee3\u8f93\u51fa (Iterative Outputs)\n\n\u5728\u67d0\u4e9b\u60c5\u51b5\u4e0b\uff0c\u60a8\u53ef\u80fd\u9700\u8981\u4f20\u8f93\u4e00\u7cfb\u5217\u8f93\u51fa\u800c\u4e0d\u662f\u4e00\u6b21\u663e\u793a\u5355\u4e2a\u8f93\u51fa\u3002\u4f8b\u5982\uff0c\u60a8\u53ef\u80fd\u6709\u4e00\u4e2a\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5e0c\u671b\u663e\u793a\u751f\u6210\u7684\u6bcf\u4e2a\u6b65\u9aa4\u7684\u56fe\u50cf\uff0c\u76f4\u5230\u6700\u7ec8\u56fe\u50cf\u3002\u6216\u8005\u60a8\u53ef\u80fd\u6709\u4e00\u4e2a\u804a\u5929\u673a\u5668\u4eba\uff0c\u5b83\u9010\u5b57\u9010\u53e5\u5730\u6d41\u5f0f\u4f20\u8f93\u54cd\u5e94\uff0c\u800c\u4e0d\u662f\u4e00\u6b21\u8fd4\u56de\u5168\u90e8\u54cd\u5e94\u3002\n\n\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u60a8\u53ef\u4ee5\u5c06**\u751f\u6210\u5668**\u51fd\u6570\u63d0\u4f9b\u7ed9 Gradio\uff0c\u800c\u4e0d\u662f\u5e38\u89c4\u51fd\u6570\u3002\u5728 Python \u4e2d\u521b\u5efa\u751f\u6210\u5668\u975e\u5e38\u7b80\u5355\uff1a\u51fd\u6570\u4e0d\u5e94\u8be5\u6709\u4e00\u4e2a\u5355\u72ec\u7684 `return` \u503c\uff0c\u800c\u662f\u5e94\u8be5 with `yield` \u8fde\u7eed\u8fd4\u56de\u4e00\u7cfb\u5217\u503c\u3002\u901a\u5e38\uff0c`yield` \u8bed\u53e5\u653e\u7f6e\u5728\u67d0\u79cd\u5faa\u73af\u4e2d\u3002\u4e0b\u9762\u662f\u4e00\u4e2a\u7b80\u5355\u793a\u4f8b\uff0c\u751f\u6210\u5668\u53ea\u662f\u7b80\u5355\u8ba1\u6570\u5230\u7ed9\u5b9a\u6570\u5b57\uff1a\n\n```python\ndef my_generator(x):\n    for i in range(x):\n        yield i\n```\n\n\u60a8\u4ee5\u4e0e\u5e38\u89c4\u51fd\u6570\u76f8\u540c\u7684\u65b9\u5f0f\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio\u3002\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\uff08\u865a\u62df\u7684\uff09\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5b83\u5728\u8f93\u51fa\u56fe\u50cf\u4e4b\u524d\u751f\u6210\u6570\u4e2a\u6b65\u9aa4\u7684\u566a\u97f3\uff1a\n\n$code_fake_diffusion\n$demo_fake_diffusion\n\n\u8bf7\u6ce8\u610f\uff0c\u6211\u4eec\u5728\u8fed\u4ee3\u5668\u4e2d\u6dfb\u52a0\u4e86 `time.sleep(1)`\uff0c\u4ee5\u521b\u5efa\u6b65\u9aa4\u4e4b\u95f4\u7684\u4eba\u5de5\u6682\u505c\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u89c2\u5bdf\u8fed\u4ee3\u5668\u7684\u6b65\u9aa4\uff08\u5728\u771f\u5b9e\u7684\u56fe\u50cf\u751f\u6210\u6a21\u578b\u4e2d\uff0c\u8fd9\n4,\tGradio Demo: blocks_random_slider\n\n\n```\n!pip install -q gradio \n```\n\n\n```\n\nimport gradio as gr\n\n\ndef func(slider_1, slider_2):\n    return slider_1 * 5 + slider_2\n\n\nwith gr.Blocks() as demo:\n    slider = gr.Slider(minimum=-10.2, maximum=15, label=\"Random Slider (Static)\", randomize=True)\n    slider_1 = gr.Slider(minimum=100, maximum=200, label=\"Random Slider (Input 1)\", randomize=True)\n    slider_2 = gr.Slider(minimum=10, maximum=23.2, label=\"Random Slider (Input 2)\", randomize=True)\n    slider_3 = gr.Slider(value=3, label=\"Non random slider\")\n    btn = gr.Button(\"Run\")\n    btn.click(func, inputs=[slider_1, slider_2], outputs=gr.Number())\n\nif __name__ == \"__main__\":\n    demo.launch()\n\n```\n    ```",
            "vector_context": "[Created at: 2025-03-24 13:19:57]\nState in Blocks\n\nWe covered [State in Interfaces](https://gradio.app/interface-state), this guide takes a look at state in Blocks, which works mostly the same.\n\n## Global State\n\nGlobal state in Blocks works the same as in Interface. Any variable created outside a function call is a reference shared between all users.\n\n## Session State\n\nGradio supports session **state**, where data persists across multiple submits within a page session, in Blocks apps as well. To reiterate, session data is _not_ shared between different users of your model. To store data in a session state, you need to do three things:\n\n1. Create a `gr.State()` object. If there is a default value to this stateful object, pass that into the constructor.\n2. In the event listener, put the `State` object as an input and output.\n3. In the event listener function, add the variable to the input parameters and the return value.\n\nLet's take a look at a game of hangman.\n\n$code_hangman\n$demo_hangman\n\nLet's see how we do each of the 3 steps listed above in this game:\n\n1. We store the used letters in `used_letters_var`. In the constructor of `State`, we set the initial value of this to `[]`, an empty list.\n2. In `btn.click()`, we have a reference to `used_letters_var` in both the inputs and outputs.\n3. In `guess_letter`, we pass the value of this `State` to `used_letters`, and then return an updated value of this `State` in the return statement.\n\nWith more complex apps, you will likely have many State variables storing session state in a single Blocks app.\n\nLearn more about `State` in the [docs](https://gradio.app/docs#state).\n--New Chunk--\n[Created at: 2025-03-24 13:18:21]\nGradio Demo: blocks_random_slider\n\n\n```\n!pip install -q gradio \n```\n\n\n```\n\nimport gradio as gr\n\n\ndef func(slider_1, slider_2):\n    return slider_1 * 5 + slider_2\n\n\nwith gr.Blocks() as demo:\n    slider = gr.Slider(minimum=-10.2, maximum=15, label=\"Random Slider (Static)\", randomize=True)\n    slider_1 = gr.Slider(minimum=100, maximum=200, label=\"Random Slider (Input 1)\", randomize=True)\n    slider_2 = gr.Slider(minimum=10, maximum=23.2, label=\"Random Slider (Input 2)\", randomize=True)\n    slider_3 = gr.Slider(value=3, label=\"Non random slider\")\n    btn = gr.Button(\"Run\")\n    btn.click(func, inputs=[slider_1, slider_2], outputs=gr.Number())\n\nif __name__ == \"__main__\":\n    demo.launch()\n\n```\n--New Chunk--\n[Created at: 2025-03-24 13:16:48]\n\u65f6\u5fc5\u987b\u9009\u62e9\u5176\u4e2d\u4e00\u4e2a\u5b57\u7b26\u4e32\uff0c\u8fd9\u5c06\u4f5c\u4e3a\u9644\u52a0\u5217\u4fdd\u5b58\u5230 CSV \u4e2d\u3002\n\n## \u9884\u5904\u7406\u548c\u540e\u5904\u7406 (Preprocessing and Postprocessing)\n\n![annotated](/assets/img/dataflow.svg)\n\n\u5982\u60a8\u6240\u89c1\uff0cGradio \u5305\u62ec\u53ef\u4ee5\u5904\u7406\u5404\u79cd\u4e0d\u540c\u6570\u636e\u7c7b\u578b\u7684\u7ec4\u4ef6\uff0c\u4f8b\u5982\u56fe\u50cf\u3001\u97f3\u9891\u548c\u89c6\u9891\u3002\u5927\u591a\u6570\u7ec4\u4ef6\u90fd\u53ef\u4ee5\u7528\u4f5c\u8f93\u5165\u6216\u8f93\u51fa\u3002\n\n\u5f53\u7ec4\u4ef6\u7528\u4f5c\u8f93\u5165\u65f6\uff0cGradio \u81ea\u52a8\u5904\u7406*\u9884\u5904\u7406*\uff0c\u5c06\u6570\u636e\u4ece\u7528\u6237\u6d4f\u89c8\u5668\u53d1\u9001\u7684\u7c7b\u578b\uff08\u4f8b\u5982\u7f51\u7edc\u6444\u50cf\u5934\u5feb\u7167\u7684 base64 \u8868\u793a\uff09\u8f6c\u6362\u4e3a\u60a8\u7684\u51fd\u6570\u53ef\u4ee5\u63a5\u53d7\u7684\u5f62\u5f0f\uff08\u4f8b\u5982 `numpy` \u6570\u7ec4\uff09\u3002\n\n\u540c\u6837\uff0c\u5f53\u7ec4\u4ef6\u7528\u4f5c\u8f93\u51fa\u65f6\uff0cGradio \u81ea\u52a8\u5904\u7406*\u540e\u5904\u7406*\uff0c\u5c06\u6570\u636e\u4ece\u51fd\u6570\u8fd4\u56de\u7684\u5f62\u5f0f\uff08\u4f8b\u5982\u56fe\u50cf\u8def\u5f84\u5217\u8868\uff09\u8f6c\u6362\u4e3a\u53ef\u4ee5\u5728\u7528\u6237\u6d4f\u89c8\u5668\u4e2d\u663e\u793a\u7684\u5f62\u5f0f\uff08\u4f8b\u5982\u4ee5 base64 \u683c\u5f0f\u663e\u793a\u56fe\u50cf\u7684 `Gallery`\uff09\u3002\n\n\u60a8\u53ef\u4ee5\u4f7f\u7528\u6784\u5efa\u56fe\u50cf\u7ec4\u4ef6\u65f6\u7684\u53c2\u6570\u63a7\u5236*\u9884\u5904\u7406*\u3002\u4f8b\u5982\uff0c\u5982\u679c\u60a8\u4f7f\u7528\u4ee5\u4e0b\u53c2\u6570\u5b9e\u4f8b\u5316 `Image` \u7ec4\u4ef6\uff0c\u5b83\u5c06\u5c06\u56fe\u50cf\u8f6c\u6362\u4e3a `PIL` \u7c7b\u578b\uff0c\u5e76\u5c06\u5176\u91cd\u5851\u4e3a`(100, 100)`\uff0c\u800c\u4e0d\u7ba1\u63d0\u4ea4\u65f6\u7684\u539f\u59cb\u5927\u5c0f\u5982\u4f55\uff1a\n\n```py\nimg = gr.Image(shape=(100, 100), type=\"pil\")\n```\n\n\u76f8\u53cd\uff0c\u8fd9\u91cc\u6211\u4eec\u4fdd\u7559\u56fe\u50cf\u7684\u539f\u59cb\u5927\u5c0f\uff0c\u4f46\u5728\u5c06\u5176\u8f6c\u6362\u4e3a numpy \u6570\u7ec4\u4e4b\u524d\u53cd\u8f6c\u989c\u8272\uff1a\n\n```py\nimg = gr.Image(invert_colors=True, type=\"numpy\")\n```\n\n\u540e\u5904\u7406\u8981\u5bb9\u6613\u5f97\u591a\uff01Gradio \u81ea\u52a8\u8bc6\u522b\u8fd4\u56de\u6570\u636e\u7684\u683c\u5f0f\uff08\u4f8b\u5982 `Image` \u662f `numpy` \u6570\u7ec4\u8fd8\u662f `str` \u6587\u4ef6\u8def\u5f84\uff1f\uff09\uff0c\u5e76\u5c06\u5176\u540e\u5904\u7406\u4e3a\u53ef\u4ee5\u7531\u6d4f\u89c8\u5668\u663e\u793a\u7684\u683c\u5f0f\u3002\n\n\u8bf7\u67e5\u770b[\u6587\u6863](https://gradio.app/docs)\uff0c\u4e86\u89e3\u6bcf\u4e2a\u7ec4\u4ef6\u7684\u6240\u6709\u4e0e\u9884\u5904\u7406\u76f8\u5173\u7684\u53c2\u6570\u3002\n\n## \u6837\u5f0f (Styling)\n\nGradio \u4e3b\u9898\u662f\u81ea\u5b9a\u4e49\u5e94\u7528\u7a0b\u5e8f\u5916\u89c2\u548c\u611f\u89c9\u7684\u6700\u7b80\u5355\u65b9\u6cd5\u3002\u60a8\u53ef\u4ee5\u9009\u62e9\u591a\u79cd\u4e3b\u9898\u6216\u521b\u5efa\u81ea\u5df1\u7684\u4e3b\u9898\u3002\u8981\u8fd9\u6837\u505a\uff0c\u8bf7\u5c06 `theme=` \u53c2\u6570\u4f20\u9012\u7ed9 `Interface` \u6784\u9020\u51fd\u6570\u3002\u4f8b\u5982\uff1a\n\n```python\ndemo = gr.Interface(..., theme=gr.themes.Monochrome())\n```\n\nGradio \u5e26\u6709\u4e00\u7ec4\u9884\u5148\u6784\u5efa\u7684\u4e3b\u9898\uff0c\u60a8\u53ef\u4ee5\u4ece `gr.themes.*` \u52a0\u8f7d\u3002\u60a8\u53ef\u4ee5\u6269\u5c55\u8fd9\u4e9b\u4e3b\u9898\u6216\u4ece\u5934\u5f00\u59cb\u521b\u5efa\u81ea\u5df1\u7684\u4e3b\u9898 - \u6709\u5173\u66f4\u591a\u8be6\u7ec6\u4fe1\u606f\uff0c\u8bf7\u53c2\u9605[\u4e3b\u9898\u6307\u5357](https://gradio.app/theming-guide)\u3002\n\n\u8981\u589e\u52a0\u989d\u5916\u7684\u6837\u5f0f\u80fd\u529b\uff0c\u60a8\u53ef\u4ee5 with `css=` \u5173\u952e\u5b57\u5c06\u4efb\u4f55 CSS \u4f20\u9012\u7ed9\u60a8\u7684\u5e94\u7528\u7a0b\u5e8f\u3002\nGradio \u5e94\u7528\u7a0b\u5e8f\u7684\u57fa\u7c7b\u662f `gradio-container`\uff0c\u56e0\u6b64\u4ee5\u4e0b\u662f\u4e00\u4e2a\u66f4\u6539 Gradio \u5e94\u7528\u7a0b\u5e8f\u80cc\u666f\u989c\u8272\u7684\u793a\u4f8b\uff1a\n\n```python\nwith `gr.Interface(css=\".gradio-container {background-color: red}\") as demo:\n    ...\n```\n\n## \u961f\u5217 (Queuing)\n\n\u5982\u679c\u60a8\u7684\u5e94\u7528\u7a0b\u5e8f\u9884\u8ba1\u4f1a\u6709\u5927\u91cf\u6d41\u91cf\uff0c\u8bf7 with `queue()` \u65b9\u6cd5\u6765\u63a7\u5236\u5904\u7406\u901f\u7387\u3002\u8fd9\u5c06\u6392\u961f\u5904\u7406\u8c03\u7528\uff0c\u56e0\u6b64\u4e00\u6b21\u53ea\u5904\u7406\u4e00\u5b9a\u6570\u91cf\u7684\u8bf7\u6c42\u3002\u961f\u5217\u4f7f\u7528 Websockets\uff0c\u8fd8\u53ef\u4ee5\u9632\u6b62\u7f51\u7edc\u8d85\u65f6\uff0c\u56e0\u6b64\u5982\u679c\u60a8\u7684\u51fd\u6570\u7684\u63a8\u7406\u65f6\u95f4\u5f88\u957f\uff08> 1 \u5206\u949f\uff09\uff0c\u5e94\u4f7f\u7528\u961f\u5217\u3002\n\nwith `Interface`\uff1a\n\n```python\ndemo = gr.Interface(...).queue()\ndemo.launch()\n```\n\nwith `Blocks`\uff1a\n\n```python\nwith gr.Blocks() as demo\uff1a\n    #...\ndemo.queue()\ndemo.launch()\n```\n\n\u60a8\u53ef\u4ee5\u901a\u8fc7\u4ee5\u4e0b\u65b9\u5f0f\u63a7\u5236\u4e00\u6b21\u5904\u7406\u7684\u8bf7\u6c42\u6570\u91cf\uff1a\n\n```python\ndemo.queue(concurrency_count=3)\n```\n\n\u67e5\u770b\u6709\u5173\u914d\u7f6e\u5176\u4ed6\u961f\u5217\u53c2\u6570\u7684[\u961f\u5217\u6587\u6863](/docs/#queue)\u3002\n\n\u5728 Blocks \u4e2d\u6307\u5b9a\u4ec5\u5bf9\u67d0\u4e9b\u51fd\u6570\u8fdb\u884c\u6392\u961f\uff1a\n\n```python\nwith gr.Blocks() as demo2\uff1a\n    num1 = gr.Number()\n    num2 = gr.Number()\n    output = gr.Number()\n    gr.Button(\"Add\").click(\n        lambda a, b: a + b, [num1, num2], output)\n    gr.Button(\"Multiply\").click(\n        lambda a, b: a * b, [num1, num2], output, queue=True)\ndemo2.launch()\n```\n\n## \u8fed\u4ee3\u8f93\u51fa (Iterative Outputs)\n\n\u5728\u67d0\u4e9b\u60c5\u51b5\u4e0b\uff0c\u60a8\u53ef\u80fd\u9700\u8981\u4f20\u8f93\u4e00\u7cfb\u5217\u8f93\u51fa\u800c\u4e0d\u662f\u4e00\u6b21\u663e\u793a\u5355\u4e2a\u8f93\u51fa\u3002\u4f8b\u5982\uff0c\u60a8\u53ef\u80fd\u6709\u4e00\u4e2a\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5e0c\u671b\u663e\u793a\u751f\u6210\u7684\u6bcf\u4e2a\u6b65\u9aa4\u7684\u56fe\u50cf\uff0c\u76f4\u5230\u6700\u7ec8\u56fe\u50cf\u3002\u6216\u8005\u60a8\u53ef\u80fd\u6709\u4e00\u4e2a\u804a\u5929\u673a\u5668\u4eba\uff0c\u5b83\u9010\u5b57\u9010\u53e5\u5730\u6d41\u5f0f\u4f20\u8f93\u54cd\u5e94\uff0c\u800c\u4e0d\u662f\u4e00\u6b21\u8fd4\u56de\u5168\u90e8\u54cd\u5e94\u3002\n\n\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u60a8\u53ef\u4ee5\u5c06**\u751f\u6210\u5668**\u51fd\u6570\u63d0\u4f9b\u7ed9 Gradio\uff0c\u800c\u4e0d\u662f\u5e38\u89c4\u51fd\u6570\u3002\u5728 Python \u4e2d\u521b\u5efa\u751f\u6210\u5668\u975e\u5e38\u7b80\u5355\uff1a\u51fd\u6570\u4e0d\u5e94\u8be5\u6709\u4e00\u4e2a\u5355\u72ec\u7684 `return` \u503c\uff0c\u800c\u662f\u5e94\u8be5 with `yield` \u8fde\u7eed\u8fd4\u56de\u4e00\u7cfb\u5217\u503c\u3002\u901a\u5e38\uff0c`yield` \u8bed\u53e5\u653e\u7f6e\u5728\u67d0\u79cd\u5faa\u73af\u4e2d\u3002\u4e0b\u9762\u662f\u4e00\u4e2a\u7b80\u5355\u793a\u4f8b\uff0c\u751f\u6210\u5668\u53ea\u662f\u7b80\u5355\u8ba1\u6570\u5230\u7ed9\u5b9a\u6570\u5b57\uff1a\n\n```python\ndef my_generator(x):\n    for i in range(x):\n        yield i\n```\n\n\u60a8\u4ee5\u4e0e\u5e38\u89c4\u51fd\u6570\u76f8\u540c\u7684\u65b9\u5f0f\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio\u3002\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\uff08\u865a\u62df\u7684\uff09\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5b83\u5728\u8f93\u51fa\u56fe\u50cf\u4e4b\u524d\u751f\u6210\u6570\u4e2a\u6b65\u9aa4\u7684\u566a\u97f3\uff1a\n\n$code_fake_diffusion\n$demo_fake_diffusion\n\n\u8bf7\u6ce8\u610f\uff0c\u6211\u4eec\u5728\u8fed\u4ee3\u5668\u4e2d\u6dfb\u52a0\u4e86 `time.sleep(1)`\uff0c\u4ee5\u521b\u5efa\u6b65\u9aa4\u4e4b\u95f4\u7684\u4eba\u5de5\u6682\u505c\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u89c2\u5bdf\u8fed\u4ee3\u5668\u7684\u6b65\u9aa4\uff08\u5728\u771f\u5b9e\u7684\u56fe\u50cf\u751f\u6210\u6a21\u578b\u4e2d\uff0c\u8fd9"
        }
    },
    {
        "sample_idx": 109,
        "question": "What is session state in Gradio Blocks apps?",
        "answer": "Session state is where data persists across multiple submits within a page session, but is not shared between different users of your model.",
        "rag_answer": "**Session State in Gradio Blocks Apps**\n\nIn Gradio Blocks apps, session state refers to the data that persists across multiple submits within a page session. This means that when a user interacts with your app, the data is stored and can be accessed across multiple interactions, but it is not shared between different users of your model.\n\nTo store data in a session state, you need to do three things:\n\n1. **Create a `gr.State()` object**: If there is a default value to this stateful object, pass that into the constructor.\n2. **Add the `State` object as an input and output in the event listener**: In the event listener function, put the `State` object as an input and output.\n3. **Add the variable to the input parameters and the return value in the event listener function**: In the event listener function, pass the value of this `State` to the variable, and then return an updated value of this `State` in the return statement.\n\nWith more complex apps, you will likely have many State variables storing session state in a single Blocks app.\n\n**References**\n\n[1. DC] State in Blocks, Gradio Documentation [https://gradio.app/docs#state](https://gradio.app/docs#state)\n[2. KG] Session State, Gradio Knowledge Graph",
        "rag_score": 5,
        "rag_feedback": "The system's response is completely correct, accurate, and factual. It provides a detailed explanation of session state in Gradio Blocks apps, including how it persists across multiple submits within a page session and is not shared between different users of the model. The response also provides step-by-step instructions on how to store data in a session state, including creating a `gr.State()` object, adding the `State` object as an input and output in the event listener, and adding the variable to the input parameters and the return value in the event listener function. Additionally, the response provides examples and references to the Gradio documentation, making it a comprehensive and informative answer.",
        "rag_context": {
            "kg_context": "-----Entities-----\n    ```csv\n    id,\tentity,\ttype,\tdescription,\trankcreated_at\n1,\tGradio,organization,Gradio is a platform that supports state in Blocks, providing features such as global state and session state.<SEP>Gradio is an interface that provides various features for demonstrating models, including adding example inputs, custom error messages, descriptive content, flagging, and more.<SEP>Gradio is an organization that provides a platform for building and deploying machine learning models.<SEP>Gradio is an organization that provides a platform for creating and deploying machine learning models.<SEP>Gradio is an organization that provides a demo for blocks_random_slider, and its library is used to create interactive interfaces.,36,2025-03-24 13:20:24\n2,\tState,category,State is a concept in Gradio that refers to the storage of data, including global state and session state.,2,2025-03-24 13:20:24\n3,\tSession State,category,Session State is a type of state in Gradio that persists across multiple submits within a page session.,2,2025-03-24 13:20:24\n4,\tgr.State()\" ,technology,gr.State() is a function that creates a stateful object in Gradio.,1,2025-03-24 13:20:24\n5,\tGlobal State,category,Global State is a type of state in Gradio that is shared between all users.,1,2025-03-24 13:20:24\n6,\tgr.State()\" ,technology,gr.State() is a function that creates a stateful object in Gradio.,1,UNKNOWN\n7,\tState,category,State is a concept in Gradio that refers to the storage of data, including global state and session state.,2,UNKNOWN\n8,\tfunc,event,func is an event that occurs when the button is clicked, executing a specific function.,1,UNKNOWN\n    ```\n    -----Relationships-----\n    ```csv\n    id,\tsource,\ttarget,\tdescription,\tkeywords,\tweight,\trank,\tcreated_at\n1,\tGradio,State,Gradio supports state in Blocks, including global state and session state.,platform feature, data storage,18.0,38,2025-03-24 13:20:24\n2,\tSession State,gr.State()\" ,gr.State() is used to create a Session State in Gradio.,function usage, state creation,9.0,3,2025-03-24 13:20:24\n3,\tGlobal State,Session State,Global State and Session State are two types of state in Gradio.,state types, data storage,7.0,3,2025-03-24 13:20:24\n4,\tGradio,State,Gradio supports state in Blocks, including global state and session state.,platform feature, data storage,18.0,38,UNKNOWN\n5,\tGradio Demo,func,func is an event that occurs in Gradio Demo when the button is clicked.,event, event,8.0,9,UNKNOWN\n6,\tInterface,State,State works similarly in Interface and Blocks.,similar concept, data storage,14.0,5,UNKNOWN\n7,\tSession State,gr.State()\" ,gr.State() is used to create a Session State in Gradio.,function usage, state creation,9.0,3,UNKNOWN\n    ```\n    -----Sources-----\n    ```csv\n    id,\tcontent\n1,\tState in Blocks\n\nWe covered [State in Interfaces](https://gradio.app/interface-state), this guide takes a look at state in Blocks, which works mostly the same.\n\n## Global State\n\nGlobal state in Blocks works the same as in Interface. Any variable created outside a function call is a reference shared between all users.\n\n## Session State\n\nGradio supports session **state**, where data persists across multiple submits within a page session, in Blocks apps as well. To reiterate, session data is _not_ shared between different users of your model. To store data in a session state, you need to do three things:\n\n1. Create a `gr.State()` object. If there is a default value to this stateful object, pass that into the constructor.\n2. In the event listener, put the `State` object as an input and output.\n3. In the event listener function, add the variable to the input parameters and the return value.\n\nLet's take a look at a game of hangman.\n\n$code_hangman\n$demo_hangman\n\nLet's see how we do each of the 3 steps listed above in this game:\n\n1. We store the used letters in `used_letters_var`. In the constructor of `State`, we set the initial value of this to `[]`, an empty list.\n2. In `btn.click()`, we have a reference to `used_letters_var` in both the inputs and outputs.\n3. In `guess_letter`, we pass the value of this `State` to `used_letters`, and then return an updated value of this `State` in the return statement.\n\nWith more complex apps, you will likely have many State variables storing session state in a single Blocks app.\n\nLearn more about `State` in the [docs](https://gradio.app/docs#state).\n2,\tGradio Demo: blocks_random_slider\n\n\n```\n!pip install -q gradio \n```\n\n\n```\n\nimport gradio as gr\n\n\ndef func(slider_1, slider_2):\n    return slider_1 * 5 + slider_2\n\n\nwith gr.Blocks() as demo:\n    slider = gr.Slider(minimum=-10.2, maximum=15, label=\"Random Slider (Static)\", randomize=True)\n    slider_1 = gr.Slider(minimum=100, maximum=200, label=\"Random Slider (Input 1)\", randomize=True)\n    slider_2 = gr.Slider(minimum=10, maximum=23.2, label=\"Random Slider (Input 2)\", randomize=True)\n    slider_3 = gr.Slider(value=3, label=\"Non random slider\")\n    btn = gr.Button(\"Run\")\n    btn.click(func, inputs=[slider_1, slider_2], outputs=gr.Number())\n\nif __name__ == \"__main__\":\n    demo.launch()\n\n```\n    ```",
            "vector_context": "[Created at: 2025-03-24 13:19:57]\nState in Blocks\n\nWe covered [State in Interfaces](https://gradio.app/interface-state), this guide takes a look at state in Blocks, which works mostly the same.\n\n## Global State\n\nGlobal state in Blocks works the same as in Interface. Any variable created outside a function call is a reference shared between all users.\n\n## Session State\n\nGradio supports session **state**, where data persists across multiple submits within a page session, in Blocks apps as well. To reiterate, session data is _not_ shared between different users of your model. To store data in a session state, you need to do three things:\n\n1. Create a `gr.State()` object. If there is a default value to this stateful object, pass that into the constructor.\n2. In the event listener, put the `State` object as an input and output.\n3. In the event listener function, add the variable to the input parameters and the return value.\n\nLet's take a look at a game of hangman.\n\n$code_hangman\n$demo_hangman\n\nLet's see how we do each of the 3 steps listed above in this game:\n\n1. We store the used letters in `used_letters_var`. In the constructor of `State`, we set the initial value of this to `[]`, an empty list.\n2. In `btn.click()`, we have a reference to `used_letters_var` in both the inputs and outputs.\n3. In `guess_letter`, we pass the value of this `State` to `used_letters`, and then return an updated value of this `State` in the return statement.\n\nWith more complex apps, you will likely have many State variables storing session state in a single Blocks app.\n\nLearn more about `State` in the [docs](https://gradio.app/docs#state).\n--New Chunk--\n[Created at: 2025-03-24 13:16:48]\n\u4e3b\u8981\u7279\u70b9\n\n\u8ba9\u6211\u4eec\u6765\u4ecb\u7ecd\u4e00\u4e0b Gradio \u6700\u53d7\u6b22\u8fce\u7684\u4e00\u4e9b\u529f\u80fd\uff01\u8fd9\u91cc\u662f Gradio \u7684\u4e3b\u8981\u7279\u70b9\uff1a\n\n1. [\u6dfb\u52a0\u793a\u4f8b\u8f93\u5165](#example-inputs)\n2. [\u4f20\u9012\u81ea\u5b9a\u4e49\u9519\u8bef\u6d88\u606f](#errors)\n3. [\u6dfb\u52a0\u63cf\u8ff0\u5185\u5bb9](#descriptive-content)\n4. [\u8bbe\u7f6e\u65d7\u6807](#flagging)\n5. [\u9884\u5904\u7406\u548c\u540e\u5904\u7406](#preprocessing-and-postprocessing)\n6. [\u6837\u5f0f\u5316\u6f14\u793a](#styling)\n7. [\u6392\u961f\u7528\u6237](#queuing)\n8. [\u8fed\u4ee3\u8f93\u51fa](#iterative-outputs)\n9. [\u8fdb\u5ea6\u6761](#progress-bars)\n10. [\u6279\u5904\u7406\u51fd\u6570](#batch-functions)\n11. [\u5728\u534f\u4f5c\u7b14\u8bb0\u672c\u4e0a\u8fd0\u884c](#colab-notebooks)\n\n## \u793a\u4f8b\u8f93\u5165\n\n\u60a8\u53ef\u4ee5\u63d0\u4f9b\u7528\u6237\u53ef\u4ee5\u8f7b\u677e\u52a0\u8f7d\u5230 \"Interface\" \u4e2d\u7684\u793a\u4f8b\u6570\u636e\u3002\u8fd9\u5bf9\u4e8e\u6f14\u793a\u6a21\u578b\u671f\u671b\u7684\u8f93\u5165\u7c7b\u578b\u4ee5\u53ca\u6f14\u793a\u6570\u636e\u96c6\u548c\u6a21\u578b\u4e00\u8d77\u63a2\u7d22\u7684\u65b9\u5f0f\u975e\u5e38\u6709\u5e2e\u52a9\u3002\u8981\u52a0\u8f7d\u793a\u4f8b\u6570\u636e\uff0c\u60a8\u53ef\u4ee5\u5c06\u5d4c\u5957\u5217\u8868\u63d0\u4f9b\u7ed9 Interface \u6784\u9020\u51fd\u6570\u7684 `examples=` \u5173\u952e\u5b57\u53c2\u6570\u3002\u5916\u90e8\u5217\u8868\u4e2d\u7684\u6bcf\u4e2a\u5b50\u5217\u8868\u8868\u793a\u4e00\u4e2a\u6570\u636e\u6837\u672c\uff0c\u5b50\u5217\u8868\u4e2d\u7684\u6bcf\u4e2a\u5143\u7d20\u8868\u793a\u6bcf\u4e2a\u8f93\u5165\u7ec4\u4ef6\u7684\u8f93\u5165\u3002\u6709\u5173\u6bcf\u4e2a\u7ec4\u4ef6\u7684\u793a\u4f8b\u6570\u636e\u683c\u5f0f\u5728[Docs](https://gradio.app/docs#components)\u4e2d\u6709\u8bf4\u660e\u3002\n\n$code_calculator\n$demo_calculator\n\n\u60a8\u53ef\u4ee5\u5c06\u5927\u578b\u6570\u636e\u96c6\u52a0\u8f7d\u5230\u793a\u4f8b\u4e2d\uff0c\u901a\u8fc7 Gradio \u6d4f\u89c8\u548c\u4e0e\u6570\u636e\u96c6\u8fdb\u884c\u4ea4\u4e92\u3002\u793a\u4f8b\u5c06\u81ea\u52a8\u5206\u9875\uff08\u53ef\u4ee5\u901a\u8fc7 Interface \u7684 `examples_per_page` \u53c2\u6570\u8fdb\u884c\u914d\u7f6e\uff09\u3002\n\n\u7ee7\u7eed\u4e86\u89e3\u793a\u4f8b\uff0c\u8bf7\u53c2\u9605[\u66f4\u591a\u793a\u4f8b](https://gradio.app/more-on-examples)\u6307\u5357\u3002\n\n## \u9519\u8bef\n\n\u60a8\u5e0c\u671b\u5411\u7528\u6237\u4f20\u9012\u81ea\u5b9a\u4e49\u9519\u8bef\u6d88\u606f\u3002\u4e3a\u6b64\uff0cwith `gr.Error(\"custom message\")` \u6765\u663e\u793a\u9519\u8bef\u6d88\u606f\u3002\u5982\u679c\u5728\u4e0a\u9762\u7684\u8ba1\u7b97\u5668\u793a\u4f8b\u4e2d\u5c1d\u8bd5\u9664\u4ee5\u96f6\uff0c\u5c06\u663e\u793a\u81ea\u5b9a\u4e49\u9519\u8bef\u6d88\u606f\u7684\u5f39\u51fa\u6a21\u6001\u7a97\u53e3\u3002\u4e86\u89e3\u6709\u5173\u9519\u8bef\u7684\u66f4\u591a\u4fe1\u606f\uff0c\u8bf7\u53c2\u9605[\u6587\u6863](https://gradio.app/docs#error)\u3002\n\n## \u63cf\u8ff0\u6027\u5185\u5bb9\n\n\u5728\u524d\u9762\u7684\u793a\u4f8b\u4e2d\uff0c\u60a8\u53ef\u80fd\u5df2\u7ecf\u6ce8\u610f\u5230 Interface \u6784\u9020\u51fd\u6570\u4e2d\u7684 `title=` \u548c `description=` \u5173\u952e\u5b57\u53c2\u6570\uff0c\u5e2e\u52a9\u7528\u6237\u4e86\u89e3\u60a8\u7684\u5e94\u7528\u7a0b\u5e8f\u3002\n\nInterface \u6784\u9020\u51fd\u6570\u4e2d\u6709\u4e09\u4e2a\u53c2\u6570\u7528\u4e8e\u6307\u5b9a\u6b64\u5185\u5bb9\u5e94\u653e\u7f6e\u5728\u54ea\u91cc\uff1a\n\n- `title`\uff1a\u63a5\u53d7\u6587\u672c\uff0c\u5e76\u53ef\u4ee5\u5c06\u5176\u663e\u793a\u5728\u754c\u9762\u7684\u9876\u90e8\uff0c\u4e5f\u5c06\u6210\u4e3a\u9875\u9762\u6807\u9898\u3002\n- `description`\uff1a\u63a5\u53d7\u6587\u672c\u3001Markdown \u6216 HTML\uff0c\u5e76\u5c06\u5176\u653e\u7f6e\u5728\u6807\u9898\u6b63\u4e0b\u65b9\u3002\n- `article`\uff1a\u4e5f\u63a5\u53d7\u6587\u672c\u3001Markdown \u6216 HTML\uff0c\u5e76\u5c06\u5176\u653e\u7f6e\u5728\u754c\u9762\u4e0b\u65b9\u3002\n\n![annotated](/assets/guides/annotated.png)\n\n\u5982\u679c\u60a8\u4f7f\u7528\u7684\u662f `Blocks` API\uff0c\u5219\u53ef\u4ee5 with `gr.Markdown(...)` \u6216 `gr.HTML(...)` \u7ec4\u4ef6\u5728\u4efb\u4f55\u4f4d\u7f6e\u63d2\u5165\u6587\u672c\u3001Markdown \u6216 HTML\uff0c\u5176\u4e2d\u63cf\u8ff0\u6027\u5185\u5bb9\u4f4d\u4e8e `Component` \u6784\u9020\u51fd\u6570\u5185\u90e8\u3002\n\n\u53e6\u4e00\u4e2a\u6709\u7528\u7684\u5173\u952e\u5b57\u53c2\u6570\u662f `label=`\uff0c\u5b83\u5b58\u5728\u4e8e\u6bcf\u4e2a `Component` \u4e2d\u3002\u8fd9\u4fee\u6539\u4e86\u6bcf\u4e2a `Component` \u9876\u90e8\u7684\u6807\u7b7e\u6587\u672c\u3002\u8fd8\u53ef\u4ee5\u4e3a\u8bf8\u5982 `Textbox` \u6216 `Radio` \u4e4b\u7c7b\u7684\u8868\u5355\u5143\u7d20\u6dfb\u52a0 `info=` \u5173\u952e\u5b57\u53c2\u6570\uff0c\u4ee5\u63d0\u4f9b\u6709\u5173\u5176\u7528\u6cd5\u7684\u8fdb\u4e00\u6b65\u4fe1\u606f\u3002\n\n```python\ngr.Number(label='\u5e74\u9f84', info='\u4ee5\u5e74\u4e3a\u5355\u4f4d\uff0c\u5fc5\u987b\u5927\u4e8e0')\n```\n\n## \u65d7\u6807\n\n\u9ed8\u8ba4\u60c5\u51b5\u4e0b\uff0c\"Interface\" \u5c06\u6709\u4e00\u4e2a \"Flag\" \u6309\u94ae\u3002\u5f53\u7528\u6237\u6d4b\u8bd5\u60a8\u7684 `Interface` \u65f6\uff0c\u5982\u679c\u770b\u5230\u6709\u8da3\u7684\u8f93\u51fa\uff0c\u4f8b\u5982\u9519\u8bef\u6216\u610f\u5916\u7684\u6a21\u578b\u884c\u4e3a\uff0c\u4ed6\u4eec\u53ef\u4ee5\u5c06\u8f93\u5165\u6807\u8bb0\u4e3a\u60a8\u8fdb\u884c\u67e5\u770b\u3002\u5728\u7531 `Interface` \u6784\u9020\u51fd\u6570\u7684 `flagging_dir=` \u53c2\u6570\u63d0\u4f9b\u7684\u76ee\u5f55\u4e2d\uff0c\u5c06\u8bb0\u5f55\u6807\u8bb0\u7684\u8f93\u5165\u5230\u4e00\u4e2a CSV \u6587\u4ef6\u4e2d\u3002\u5982\u679c\u754c\u9762\u6d89\u53ca\u6587\u4ef6\u6570\u636e\uff0c\u4f8b\u5982\u56fe\u50cf\u548c\u97f3\u9891\u7ec4\u4ef6\uff0c\u5c06\u521b\u5efa\u6587\u4ef6\u5939\u6765\u5b58\u50a8\u8fd9\u4e9b\u6807\u8bb0\u7684\u6570\u636e\u3002\n\n\u4f8b\u5982\uff0c\u5bf9\u4e8e\u4e0a\u9762\u663e\u793a\u7684\u8ba1\u7b97\u5668\u754c\u9762\uff0c\u6211\u4eec\u5c06\u5728\u4e0b\u9762\u7684\u65d7\u6807\u76ee\u5f55\u4e2d\u5b58\u50a8\u6807\u8bb0\u7684\u6570\u636e\uff1a\n\n```directory\n+-- calculator.py\n+-- flagged/\n|   +-- logs.csv\n```\n\n_flagged/logs.csv_\n\n```csv\nnum1,operation,num2,Output\n5,add,7,12\n6,subtract,1.5,4.5\n```\n\n\u4e0e\u65e9\u671f\u663e\u793a\u7684\u51b7\u8272\u754c\u9762\u76f8\u5bf9\u5e94\uff0c\u6211\u4eec\u5c06\u5728\u4e0b\u9762\u7684\u65d7\u6807\u76ee\u5f55\u4e2d\u5b58\u50a8\u6807\u8bb0\u7684\u6570\u636e\uff1a\n\n```directory\n+-- sepia.py\n+-- flagged/\n|   +-- logs.csv\n|   +-- im/\n|   |   +-- 0.png\n|   |   +-- 1.png\n|   +-- Output/\n|   |   +-- 0.png\n|   |   +-- 1.png\n```\n\n_flagged/logs.csv_\n\n```csv\nim,Output\nim/0.png,Output/0.png\nim/1.png,Output/1.png\n```\n\n\u5982\u679c\u60a8\u5e0c\u671b\u7528\u6237\u63d0\u4f9b\u65d7\u6807\u539f\u56e0\uff0c\u53ef\u4ee5\u5c06\u5b57\u7b26\u4e32\u5217\u8868\u4f20\u9012\u7ed9 Interface \u7684 `flagging_options` \u53c2\u6570\u3002\u7528\u6237\u5728\u8fdb\u884c\u65d7\u6807\u65f6\u5fc5\u987b\u9009\u62e9\u5176\u4e2d\u4e00\u4e2a\u5b57\u7b26\u4e32\uff0c\u8fd9\u5c06\u4f5c\u4e3a\u9644\u52a0\u5217\u4fdd\u5b58\u5230 CSV \u4e2d\u3002\n\n## \u9884\u5904\u7406\u548c\u540e\u5904\u7406 (Preprocessing and Postprocessing)\n\n![annotated](/assets/img/dataflow.svg)\n\n\u5982\u60a8\u6240\u89c1\uff0cGradio \u5305\u62ec\u53ef\u4ee5\u5904\u7406\u5404\u79cd\u4e0d\u540c\u6570\u636e\u7c7b\u578b\u7684\u7ec4\u4ef6\uff0c\u4f8b\u5982\u56fe\u50cf\u3001\u97f3\u9891\u548c\u89c6\u9891\u3002\u5927\u591a\u6570\u7ec4\u4ef6\u90fd\u53ef\u4ee5\u7528\u4f5c\u8f93\u5165\u6216\u8f93\u51fa\u3002\n\n\u5f53\u7ec4\u4ef6\u7528\u4f5c\u8f93\u5165\u65f6\uff0cGradio \u81ea\u52a8\u5904\u7406*\u9884\u5904\u7406*\uff0c\u5c06\u6570\u636e\u4ece\u7528\u6237\n--New Chunk--\n[Created at: 2025-03-24 13:16:48]\n\u65f6\u5fc5\u987b\u9009\u62e9\u5176\u4e2d\u4e00\u4e2a\u5b57\u7b26\u4e32\uff0c\u8fd9\u5c06\u4f5c\u4e3a\u9644\u52a0\u5217\u4fdd\u5b58\u5230 CSV \u4e2d\u3002\n\n## \u9884\u5904\u7406\u548c\u540e\u5904\u7406 (Preprocessing and Postprocessing)\n\n![annotated](/assets/img/dataflow.svg)\n\n\u5982\u60a8\u6240\u89c1\uff0cGradio \u5305\u62ec\u53ef\u4ee5\u5904\u7406\u5404\u79cd\u4e0d\u540c\u6570\u636e\u7c7b\u578b\u7684\u7ec4\u4ef6\uff0c\u4f8b\u5982\u56fe\u50cf\u3001\u97f3\u9891\u548c\u89c6\u9891\u3002\u5927\u591a\u6570\u7ec4\u4ef6\u90fd\u53ef\u4ee5\u7528\u4f5c\u8f93\u5165\u6216\u8f93\u51fa\u3002\n\n\u5f53\u7ec4\u4ef6\u7528\u4f5c\u8f93\u5165\u65f6\uff0cGradio \u81ea\u52a8\u5904\u7406*\u9884\u5904\u7406*\uff0c\u5c06\u6570\u636e\u4ece\u7528\u6237\u6d4f\u89c8\u5668\u53d1\u9001\u7684\u7c7b\u578b\uff08\u4f8b\u5982\u7f51\u7edc\u6444\u50cf\u5934\u5feb\u7167\u7684 base64 \u8868\u793a\uff09\u8f6c\u6362\u4e3a\u60a8\u7684\u51fd\u6570\u53ef\u4ee5\u63a5\u53d7\u7684\u5f62\u5f0f\uff08\u4f8b\u5982 `numpy` \u6570\u7ec4\uff09\u3002\n\n\u540c\u6837\uff0c\u5f53\u7ec4\u4ef6\u7528\u4f5c\u8f93\u51fa\u65f6\uff0cGradio \u81ea\u52a8\u5904\u7406*\u540e\u5904\u7406*\uff0c\u5c06\u6570\u636e\u4ece\u51fd\u6570\u8fd4\u56de\u7684\u5f62\u5f0f\uff08\u4f8b\u5982\u56fe\u50cf\u8def\u5f84\u5217\u8868\uff09\u8f6c\u6362\u4e3a\u53ef\u4ee5\u5728\u7528\u6237\u6d4f\u89c8\u5668\u4e2d\u663e\u793a\u7684\u5f62\u5f0f\uff08\u4f8b\u5982\u4ee5 base64 \u683c\u5f0f\u663e\u793a\u56fe\u50cf\u7684 `Gallery`\uff09\u3002\n\n\u60a8\u53ef\u4ee5\u4f7f\u7528\u6784\u5efa\u56fe\u50cf\u7ec4\u4ef6\u65f6\u7684\u53c2\u6570\u63a7\u5236*\u9884\u5904\u7406*\u3002\u4f8b\u5982\uff0c\u5982\u679c\u60a8\u4f7f\u7528\u4ee5\u4e0b\u53c2\u6570\u5b9e\u4f8b\u5316 `Image` \u7ec4\u4ef6\uff0c\u5b83\u5c06\u5c06\u56fe\u50cf\u8f6c\u6362\u4e3a `PIL` \u7c7b\u578b\uff0c\u5e76\u5c06\u5176\u91cd\u5851\u4e3a`(100, 100)`\uff0c\u800c\u4e0d\u7ba1\u63d0\u4ea4\u65f6\u7684\u539f\u59cb\u5927\u5c0f\u5982\u4f55\uff1a\n\n```py\nimg = gr.Image(shape=(100, 100), type=\"pil\")\n```\n\n\u76f8\u53cd\uff0c\u8fd9\u91cc\u6211\u4eec\u4fdd\u7559\u56fe\u50cf\u7684\u539f\u59cb\u5927\u5c0f\uff0c\u4f46\u5728\u5c06\u5176\u8f6c\u6362\u4e3a numpy \u6570\u7ec4\u4e4b\u524d\u53cd\u8f6c\u989c\u8272\uff1a\n\n```py\nimg = gr.Image(invert_colors=True, type=\"numpy\")\n```\n\n\u540e\u5904\u7406\u8981\u5bb9\u6613\u5f97\u591a\uff01Gradio \u81ea\u52a8\u8bc6\u522b\u8fd4\u56de\u6570\u636e\u7684\u683c\u5f0f\uff08\u4f8b\u5982 `Image` \u662f `numpy` \u6570\u7ec4\u8fd8\u662f `str` \u6587\u4ef6\u8def\u5f84\uff1f\uff09\uff0c\u5e76\u5c06\u5176\u540e\u5904\u7406\u4e3a\u53ef\u4ee5\u7531\u6d4f\u89c8\u5668\u663e\u793a\u7684\u683c\u5f0f\u3002\n\n\u8bf7\u67e5\u770b[\u6587\u6863](https://gradio.app/docs)\uff0c\u4e86\u89e3\u6bcf\u4e2a\u7ec4\u4ef6\u7684\u6240\u6709\u4e0e\u9884\u5904\u7406\u76f8\u5173\u7684\u53c2\u6570\u3002\n\n## \u6837\u5f0f (Styling)\n\nGradio \u4e3b\u9898\u662f\u81ea\u5b9a\u4e49\u5e94\u7528\u7a0b\u5e8f\u5916\u89c2\u548c\u611f\u89c9\u7684\u6700\u7b80\u5355\u65b9\u6cd5\u3002\u60a8\u53ef\u4ee5\u9009\u62e9\u591a\u79cd\u4e3b\u9898\u6216\u521b\u5efa\u81ea\u5df1\u7684\u4e3b\u9898\u3002\u8981\u8fd9\u6837\u505a\uff0c\u8bf7\u5c06 `theme=` \u53c2\u6570\u4f20\u9012\u7ed9 `Interface` \u6784\u9020\u51fd\u6570\u3002\u4f8b\u5982\uff1a\n\n```python\ndemo = gr.Interface(..., theme=gr.themes.Monochrome())\n```\n\nGradio \u5e26\u6709\u4e00\u7ec4\u9884\u5148\u6784\u5efa\u7684\u4e3b\u9898\uff0c\u60a8\u53ef\u4ee5\u4ece `gr.themes.*` \u52a0\u8f7d\u3002\u60a8\u53ef\u4ee5\u6269\u5c55\u8fd9\u4e9b\u4e3b\u9898\u6216\u4ece\u5934\u5f00\u59cb\u521b\u5efa\u81ea\u5df1\u7684\u4e3b\u9898 - \u6709\u5173\u66f4\u591a\u8be6\u7ec6\u4fe1\u606f\uff0c\u8bf7\u53c2\u9605[\u4e3b\u9898\u6307\u5357](https://gradio.app/theming-guide)\u3002\n\n\u8981\u589e\u52a0\u989d\u5916\u7684\u6837\u5f0f\u80fd\u529b\uff0c\u60a8\u53ef\u4ee5 with `css=` \u5173\u952e\u5b57\u5c06\u4efb\u4f55 CSS \u4f20\u9012\u7ed9\u60a8\u7684\u5e94\u7528\u7a0b\u5e8f\u3002\nGradio \u5e94\u7528\u7a0b\u5e8f\u7684\u57fa\u7c7b\u662f `gradio-container`\uff0c\u56e0\u6b64\u4ee5\u4e0b\u662f\u4e00\u4e2a\u66f4\u6539 Gradio \u5e94\u7528\u7a0b\u5e8f\u80cc\u666f\u989c\u8272\u7684\u793a\u4f8b\uff1a\n\n```python\nwith `gr.Interface(css=\".gradio-container {background-color: red}\") as demo:\n    ...\n```\n\n## \u961f\u5217 (Queuing)\n\n\u5982\u679c\u60a8\u7684\u5e94\u7528\u7a0b\u5e8f\u9884\u8ba1\u4f1a\u6709\u5927\u91cf\u6d41\u91cf\uff0c\u8bf7 with `queue()` \u65b9\u6cd5\u6765\u63a7\u5236\u5904\u7406\u901f\u7387\u3002\u8fd9\u5c06\u6392\u961f\u5904\u7406\u8c03\u7528\uff0c\u56e0\u6b64\u4e00\u6b21\u53ea\u5904\u7406\u4e00\u5b9a\u6570\u91cf\u7684\u8bf7\u6c42\u3002\u961f\u5217\u4f7f\u7528 Websockets\uff0c\u8fd8\u53ef\u4ee5\u9632\u6b62\u7f51\u7edc\u8d85\u65f6\uff0c\u56e0\u6b64\u5982\u679c\u60a8\u7684\u51fd\u6570\u7684\u63a8\u7406\u65f6\u95f4\u5f88\u957f\uff08> 1 \u5206\u949f\uff09\uff0c\u5e94\u4f7f\u7528\u961f\u5217\u3002\n\nwith `Interface`\uff1a\n\n```python\ndemo = gr.Interface(...).queue()\ndemo.launch()\n```\n\nwith `Blocks`\uff1a\n\n```python\nwith gr.Blocks() as demo\uff1a\n    #...\ndemo.queue()\ndemo.launch()\n```\n\n\u60a8\u53ef\u4ee5\u901a\u8fc7\u4ee5\u4e0b\u65b9\u5f0f\u63a7\u5236\u4e00\u6b21\u5904\u7406\u7684\u8bf7\u6c42\u6570\u91cf\uff1a\n\n```python\ndemo.queue(concurrency_count=3)\n```\n\n\u67e5\u770b\u6709\u5173\u914d\u7f6e\u5176\u4ed6\u961f\u5217\u53c2\u6570\u7684[\u961f\u5217\u6587\u6863](/docs/#queue)\u3002\n\n\u5728 Blocks \u4e2d\u6307\u5b9a\u4ec5\u5bf9\u67d0\u4e9b\u51fd\u6570\u8fdb\u884c\u6392\u961f\uff1a\n\n```python\nwith gr.Blocks() as demo2\uff1a\n    num1 = gr.Number()\n    num2 = gr.Number()\n    output = gr.Number()\n    gr.Button(\"Add\").click(\n        lambda a, b: a + b, [num1, num2], output)\n    gr.Button(\"Multiply\").click(\n        lambda a, b: a * b, [num1, num2], output, queue=True)\ndemo2.launch()\n```\n\n## \u8fed\u4ee3\u8f93\u51fa (Iterative Outputs)\n\n\u5728\u67d0\u4e9b\u60c5\u51b5\u4e0b\uff0c\u60a8\u53ef\u80fd\u9700\u8981\u4f20\u8f93\u4e00\u7cfb\u5217\u8f93\u51fa\u800c\u4e0d\u662f\u4e00\u6b21\u663e\u793a\u5355\u4e2a\u8f93\u51fa\u3002\u4f8b\u5982\uff0c\u60a8\u53ef\u80fd\u6709\u4e00\u4e2a\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5e0c\u671b\u663e\u793a\u751f\u6210\u7684\u6bcf\u4e2a\u6b65\u9aa4\u7684\u56fe\u50cf\uff0c\u76f4\u5230\u6700\u7ec8\u56fe\u50cf\u3002\u6216\u8005\u60a8\u53ef\u80fd\u6709\u4e00\u4e2a\u804a\u5929\u673a\u5668\u4eba\uff0c\u5b83\u9010\u5b57\u9010\u53e5\u5730\u6d41\u5f0f\u4f20\u8f93\u54cd\u5e94\uff0c\u800c\u4e0d\u662f\u4e00\u6b21\u8fd4\u56de\u5168\u90e8\u54cd\u5e94\u3002\n\n\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u60a8\u53ef\u4ee5\u5c06**\u751f\u6210\u5668**\u51fd\u6570\u63d0\u4f9b\u7ed9 Gradio\uff0c\u800c\u4e0d\u662f\u5e38\u89c4\u51fd\u6570\u3002\u5728 Python \u4e2d\u521b\u5efa\u751f\u6210\u5668\u975e\u5e38\u7b80\u5355\uff1a\u51fd\u6570\u4e0d\u5e94\u8be5\u6709\u4e00\u4e2a\u5355\u72ec\u7684 `return` \u503c\uff0c\u800c\u662f\u5e94\u8be5 with `yield` \u8fde\u7eed\u8fd4\u56de\u4e00\u7cfb\u5217\u503c\u3002\u901a\u5e38\uff0c`yield` \u8bed\u53e5\u653e\u7f6e\u5728\u67d0\u79cd\u5faa\u73af\u4e2d\u3002\u4e0b\u9762\u662f\u4e00\u4e2a\u7b80\u5355\u793a\u4f8b\uff0c\u751f\u6210\u5668\u53ea\u662f\u7b80\u5355\u8ba1\u6570\u5230\u7ed9\u5b9a\u6570\u5b57\uff1a\n\n```python\ndef my_generator(x):\n    for i in range(x):\n        yield i\n```\n\n\u60a8\u4ee5\u4e0e\u5e38\u89c4\u51fd\u6570\u76f8\u540c\u7684\u65b9\u5f0f\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio\u3002\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\uff08\u865a\u62df\u7684\uff09\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5b83\u5728\u8f93\u51fa\u56fe\u50cf\u4e4b\u524d\u751f\u6210\u6570\u4e2a\u6b65\u9aa4\u7684\u566a\u97f3\uff1a\n\n$code_fake_diffusion\n$demo_fake_diffusion\n\n\u8bf7\u6ce8\u610f\uff0c\u6211\u4eec\u5728\u8fed\u4ee3\u5668\u4e2d\u6dfb\u52a0\u4e86 `time.sleep(1)`\uff0c\u4ee5\u521b\u5efa\u6b65\u9aa4\u4e4b\u95f4\u7684\u4eba\u5de5\u6682\u505c\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u89c2\u5bdf\u8fed\u4ee3\u5668\u7684\u6b65\u9aa4\uff08\u5728\u771f\u5b9e\u7684\u56fe\u50cf\u751f\u6210\u6a21\u578b\u4e2d\uff0c\u8fd9"
        }
    },
    {
        "context": "State in Blocks\n\nWe covered [State in Interfaces](https://gradio.app/interface-state), this guide takes a look at state in Blocks, which works mostly the same.\n\n## Global State\n\nGlobal state in Blocks works the same as in Interface. Any variable created outside a function call is a reference shared between all users.\n\n## Session State\n\nGradio supports session **state**, where data persists across multiple submits within a page session, in Blocks apps as well. To reiterate, session data is _not_ shared between different users of your model. To store data in a session state, you need to do three things:\n\n1. Create a `gr.State()` object. If there is a default value to this stateful object, pass that into the constructor.\n2. In the event listener, put the `State` object as an input and output.\n3. In the event listener function, add the variable to the input parameters and the return value.\n\nLet's take a look at a game of hangman.\n\n$code_hangman\n$demo_hangman\n\nLet's see how we do each of the 3 steps listed above in this game:\n\n1. We store the used letters in `used_letters_var`. In the constructor of `State`, we set the initial value of this to `[]`, an empty list.\n2. In `btn.click()`, we have a reference to `used_letters_var` in both the inputs and outputs.\n3. In `guess_letter`, we pass the value of this `State` to `used_letters`, and then return an updated value of this `State` in the return statement.\n\nWith more complex apps, you will likely have many State variables storing session state in a single Blocks app.\n\nLearn more about `State` in the [docs](https://gradio.app/docs#state).",
        "question": "What are the three things needed to store data in a session state in Gradio Blocks?",
        "answer": "To store data in a session state, you need to create a gr.State() object, put the State object as an input and output in the event listener, and add the variable to the input parameters and the return value in the event listener function.",
        "source_doc": "gradio-app/gradio/blob/main/guides/03_building-with-blocks/03_state-in-blocks.md",
        "rag_answer": null,
        "rag_context": null,
        "rag_score": null,
        "rag_feedback": null
    },
    {
        "sample_idx": 111,
        "question": "What is the purpose of the gr.State() object in Gradio Blocks?",
        "answer": "The gr.State() object is used to store data in a session state, and can be initialized with a default value.",
        "rag_answer": "The `gr.State()` object in Gradio Blocks is used to create a stateful object that persists across multiple submits within a page session. It allows you to store data in a session state, which is not shared between different users of your model. To use `gr.State()`, you need to do three things: \n\n1. Create a `gr.State()` object. If there is a default value to this stateful object, pass that into the constructor.\n2. In the event listener, put the `State` object as an input and output.\n3. In the event listener function, add the variable to the input parameters and the return value.\n\nFor example, in a game of hangman, you can use `gr.State()` to store the used letters in a variable `used_letters_var`. In the constructor of `State`, you set the initial value of this to `[]`, an empty list. Then, in the event listener function, you pass the value of this `State` to `used_letters`, and then return an updated value of this `State` in the return statement.\n\nReferences:\n[KG] Gradio is an organization that provides a platform for building and deploying machine learning models.\n[DC] State in Blocks",
        "rag_score": 5,
        "rag_feedback": "The system's response is completely correct, accurate, and factual. It provides a detailed explanation of the purpose of the gr.State() object in Gradio Blocks, including how to use it to store data in a session state, and provides examples to illustrate its usage.",
        "rag_context": {
            "kg_context": "-----Entities-----\n    ```csv\n    id,\tentity,\ttype,\tdescription,\trankcreated_at\n1,\tGradio,organization,Gradio is a platform that supports state in Blocks, providing features such as global state and session state.<SEP>Gradio is an interface that provides various features for demonstrating models, including adding example inputs, custom error messages, descriptive content, flagging, and more.<SEP>Gradio is an organization that provides a platform for building and deploying machine learning models.<SEP>Gradio is an organization that provides a platform for creating and deploying machine learning models.<SEP>Gradio is an organization that provides a demo for blocks_random_slider, and its library is used to create interactive interfaces.,36,2025-03-24 13:20:24\n2,\tState,category,State is a concept in Gradio that refers to the storage of data, including global state and session state.,2,2025-03-24 13:20:24\n3,\tBlocks API,category,Blocks API is an API in Gradio that allows users to create interfaces using a block-based structure.,1,2025-03-24 13:20:24\n4,\tSession State,category,Session State is a type of state in Gradio that persists across multiple submits within a page session.,2,2025-03-24 13:20:24\n5,\tgr.State()\" ,technology,gr.State() is a function that creates a stateful object in Gradio.,1,2025-03-24 13:20:24\n6,\tgr.State()\" ,technology,gr.State() is a function that creates a stateful object in Gradio.,1,UNKNOWN\n7,\tState,category,State is a concept in Gradio that refers to the storage of data, including global state and session state.,2,UNKNOWN\n8,\tHangman,event,Hangman is a game used as an example to demonstrate how to use state in Blocks.,1,UNKNOWN\n    ```\n    -----Relationships-----\n    ```csv\n    id,\tsource,\ttarget,\tdescription,\tkeywords,\tweight,\trank,\tcreated_at\n1,\tGradio,State,Gradio supports state in Blocks, including global state and session state.,platform feature, data storage,18.0,38,2025-03-24 13:20:24\n2,\tBlocks API,Gradio,Gradio provides the Blocks API for creating interfaces.,interface creation, API,9.0,37,2025-03-24 13:17:31\n3,\tSession State,gr.State()\" ,gr.State() is used to create a Session State in Gradio.,function usage, state creation,9.0,3,2025-03-24 13:20:24\n4,\tGradio,State,Gradio supports state in Blocks, including global state and session state.,platform feature, data storage,18.0,38,UNKNOWN\n5,\tInterface,State,State works similarly in Interface and Blocks.,similar concept, data storage,14.0,5,UNKNOWN\n6,\tBlocks,Hangman,Hangman is an example game that uses state in Blocks.,example, game development,16.0,3,UNKNOWN\n7,\tSession State,gr.State()\" ,gr.State() is used to create a Session State in Gradio.,function usage, state creation,9.0,3,UNKNOWN\n    ```\n    -----Sources-----\n    ```csv\n    id,\tcontent\n1,\tState in Blocks\n\nWe covered [State in Interfaces](https://gradio.app/interface-state), this guide takes a look at state in Blocks, which works mostly the same.\n\n## Global State\n\nGlobal state in Blocks works the same as in Interface. Any variable created outside a function call is a reference shared between all users.\n\n## Session State\n\nGradio supports session **state**, where data persists across multiple submits within a page session, in Blocks apps as well. To reiterate, session data is _not_ shared between different users of your model. To store data in a session state, you need to do three things:\n\n1. Create a `gr.State()` object. If there is a default value to this stateful object, pass that into the constructor.\n2. In the event listener, put the `State` object as an input and output.\n3. In the event listener function, add the variable to the input parameters and the return value.\n\nLet's take a look at a game of hangman.\n\n$code_hangman\n$demo_hangman\n\nLet's see how we do each of the 3 steps listed above in this game:\n\n1. We store the used letters in `used_letters_var`. In the constructor of `State`, we set the initial value of this to `[]`, an empty list.\n2. In `btn.click()`, we have a reference to `used_letters_var` in both the inputs and outputs.\n3. In `guess_letter`, we pass the value of this `State` to `used_letters`, and then return an updated value of this `State` in the return statement.\n\nWith more complex apps, you will likely have many State variables storing session state in a single Blocks app.\n\nLearn more about `State` in the [docs](https://gradio.app/docs#state).\n2,\t\u4e3b\u8981\u7279\u70b9\n\n\u8ba9\u6211\u4eec\u6765\u4ecb\u7ecd\u4e00\u4e0b Gradio \u6700\u53d7\u6b22\u8fce\u7684\u4e00\u4e9b\u529f\u80fd\uff01\u8fd9\u91cc\u662f Gradio \u7684\u4e3b\u8981\u7279\u70b9\uff1a\n\n1. [\u6dfb\u52a0\u793a\u4f8b\u8f93\u5165](#example-inputs)\n2. [\u4f20\u9012\u81ea\u5b9a\u4e49\u9519\u8bef\u6d88\u606f](#errors)\n3. [\u6dfb\u52a0\u63cf\u8ff0\u5185\u5bb9](#descriptive-content)\n4. [\u8bbe\u7f6e\u65d7\u6807](#flagging)\n5. [\u9884\u5904\u7406\u548c\u540e\u5904\u7406](#preprocessing-and-postprocessing)\n6. [\u6837\u5f0f\u5316\u6f14\u793a](#styling)\n7. [\u6392\u961f\u7528\u6237](#queuing)\n8. [\u8fed\u4ee3\u8f93\u51fa](#iterative-outputs)\n9. [\u8fdb\u5ea6\u6761](#progress-bars)\n10. [\u6279\u5904\u7406\u51fd\u6570](#batch-functions)\n11. [\u5728\u534f\u4f5c\u7b14\u8bb0\u672c\u4e0a\u8fd0\u884c](#colab-notebooks)\n\n## \u793a\u4f8b\u8f93\u5165\n\n\u60a8\u53ef\u4ee5\u63d0\u4f9b\u7528\u6237\u53ef\u4ee5\u8f7b\u677e\u52a0\u8f7d\u5230 \"Interface\" \u4e2d\u7684\u793a\u4f8b\u6570\u636e\u3002\u8fd9\u5bf9\u4e8e\u6f14\u793a\u6a21\u578b\u671f\u671b\u7684\u8f93\u5165\u7c7b\u578b\u4ee5\u53ca\u6f14\u793a\u6570\u636e\u96c6\u548c\u6a21\u578b\u4e00\u8d77\u63a2\u7d22\u7684\u65b9\u5f0f\u975e\u5e38\u6709\u5e2e\u52a9\u3002\u8981\u52a0\u8f7d\u793a\u4f8b\u6570\u636e\uff0c\u60a8\u53ef\u4ee5\u5c06\u5d4c\u5957\u5217\u8868\u63d0\u4f9b\u7ed9 Interface \u6784\u9020\u51fd\u6570\u7684 `examples=` \u5173\u952e\u5b57\u53c2\u6570\u3002\u5916\u90e8\u5217\u8868\u4e2d\u7684\u6bcf\u4e2a\u5b50\u5217\u8868\u8868\u793a\u4e00\u4e2a\u6570\u636e\u6837\u672c\uff0c\u5b50\u5217\u8868\u4e2d\u7684\u6bcf\u4e2a\u5143\u7d20\u8868\u793a\u6bcf\u4e2a\u8f93\u5165\u7ec4\u4ef6\u7684\u8f93\u5165\u3002\u6709\u5173\u6bcf\u4e2a\u7ec4\u4ef6\u7684\u793a\u4f8b\u6570\u636e\u683c\u5f0f\u5728[Docs](https://gradio.app/docs#components)\u4e2d\u6709\u8bf4\u660e\u3002\n\n$code_calculator\n$demo_calculator\n\n\u60a8\u53ef\u4ee5\u5c06\u5927\u578b\u6570\u636e\u96c6\u52a0\u8f7d\u5230\u793a\u4f8b\u4e2d\uff0c\u901a\u8fc7 Gradio \u6d4f\u89c8\u548c\u4e0e\u6570\u636e\u96c6\u8fdb\u884c\u4ea4\u4e92\u3002\u793a\u4f8b\u5c06\u81ea\u52a8\u5206\u9875\uff08\u53ef\u4ee5\u901a\u8fc7 Interface \u7684 `examples_per_page` \u53c2\u6570\u8fdb\u884c\u914d\u7f6e\uff09\u3002\n\n\u7ee7\u7eed\u4e86\u89e3\u793a\u4f8b\uff0c\u8bf7\u53c2\u9605[\u66f4\u591a\u793a\u4f8b](https://gradio.app/more-on-examples)\u6307\u5357\u3002\n\n## \u9519\u8bef\n\n\u60a8\u5e0c\u671b\u5411\u7528\u6237\u4f20\u9012\u81ea\u5b9a\u4e49\u9519\u8bef\u6d88\u606f\u3002\u4e3a\u6b64\uff0cwith `gr.Error(\"custom message\")` \u6765\u663e\u793a\u9519\u8bef\u6d88\u606f\u3002\u5982\u679c\u5728\u4e0a\u9762\u7684\u8ba1\u7b97\u5668\u793a\u4f8b\u4e2d\u5c1d\u8bd5\u9664\u4ee5\u96f6\uff0c\u5c06\u663e\u793a\u81ea\u5b9a\u4e49\u9519\u8bef\u6d88\u606f\u7684\u5f39\u51fa\u6a21\u6001\u7a97\u53e3\u3002\u4e86\u89e3\u6709\u5173\u9519\u8bef\u7684\u66f4\u591a\u4fe1\u606f\uff0c\u8bf7\u53c2\u9605[\u6587\u6863](https://gradio.app/docs#error)\u3002\n\n## \u63cf\u8ff0\u6027\u5185\u5bb9\n\n\u5728\u524d\u9762\u7684\u793a\u4f8b\u4e2d\uff0c\u60a8\u53ef\u80fd\u5df2\u7ecf\u6ce8\u610f\u5230 Interface \u6784\u9020\u51fd\u6570\u4e2d\u7684 `title=` \u548c `description=` \u5173\u952e\u5b57\u53c2\u6570\uff0c\u5e2e\u52a9\u7528\u6237\u4e86\u89e3\u60a8\u7684\u5e94\u7528\u7a0b\u5e8f\u3002\n\nInterface \u6784\u9020\u51fd\u6570\u4e2d\u6709\u4e09\u4e2a\u53c2\u6570\u7528\u4e8e\u6307\u5b9a\u6b64\u5185\u5bb9\u5e94\u653e\u7f6e\u5728\u54ea\u91cc\uff1a\n\n- `title`\uff1a\u63a5\u53d7\u6587\u672c\uff0c\u5e76\u53ef\u4ee5\u5c06\u5176\u663e\u793a\u5728\u754c\u9762\u7684\u9876\u90e8\uff0c\u4e5f\u5c06\u6210\u4e3a\u9875\u9762\u6807\u9898\u3002\n- `description`\uff1a\u63a5\u53d7\u6587\u672c\u3001Markdown \u6216 HTML\uff0c\u5e76\u5c06\u5176\u653e\u7f6e\u5728\u6807\u9898\u6b63\u4e0b\u65b9\u3002\n- `article`\uff1a\u4e5f\u63a5\u53d7\u6587\u672c\u3001Markdown \u6216 HTML\uff0c\u5e76\u5c06\u5176\u653e\u7f6e\u5728\u754c\u9762\u4e0b\u65b9\u3002\n\n![annotated](/assets/guides/annotated.png)\n\n\u5982\u679c\u60a8\u4f7f\u7528\u7684\u662f `Blocks` API\uff0c\u5219\u53ef\u4ee5 with `gr.Markdown(...)` \u6216 `gr.HTML(...)` \u7ec4\u4ef6\u5728\u4efb\u4f55\u4f4d\u7f6e\u63d2\u5165\u6587\u672c\u3001Markdown \u6216 HTML\uff0c\u5176\u4e2d\u63cf\u8ff0\u6027\u5185\u5bb9\u4f4d\u4e8e `Component` \u6784\u9020\u51fd\u6570\u5185\u90e8\u3002\n\n\u53e6\u4e00\u4e2a\u6709\u7528\u7684\u5173\u952e\u5b57\u53c2\u6570\u662f `label=`\uff0c\u5b83\u5b58\u5728\u4e8e\u6bcf\u4e2a `Component` \u4e2d\u3002\u8fd9\u4fee\u6539\u4e86\u6bcf\u4e2a `Component` \u9876\u90e8\u7684\u6807\u7b7e\u6587\u672c\u3002\u8fd8\u53ef\u4ee5\u4e3a\u8bf8\u5982 `Textbox` \u6216 `Radio` \u4e4b\u7c7b\u7684\u8868\u5355\u5143\u7d20\u6dfb\u52a0 `info=` \u5173\u952e\u5b57\u53c2\u6570\uff0c\u4ee5\u63d0\u4f9b\u6709\u5173\u5176\u7528\u6cd5\u7684\u8fdb\u4e00\u6b65\u4fe1\u606f\u3002\n\n```python\ngr.Number(label='\u5e74\u9f84', info='\u4ee5\u5e74\u4e3a\u5355\u4f4d\uff0c\u5fc5\u987b\u5927\u4e8e0')\n```\n\n## \u65d7\u6807\n\n\u9ed8\u8ba4\u60c5\u51b5\u4e0b\uff0c\"Interface\" \u5c06\u6709\u4e00\u4e2a \"Flag\" \u6309\u94ae\u3002\u5f53\u7528\u6237\u6d4b\u8bd5\u60a8\u7684 `Interface` \u65f6\uff0c\u5982\u679c\u770b\u5230\u6709\u8da3\u7684\u8f93\u51fa\uff0c\u4f8b\u5982\u9519\u8bef\u6216\u610f\u5916\u7684\u6a21\u578b\u884c\u4e3a\uff0c\u4ed6\u4eec\u53ef\u4ee5\u5c06\u8f93\u5165\u6807\u8bb0\u4e3a\u60a8\u8fdb\u884c\u67e5\u770b\u3002\u5728\u7531 `Interface` \u6784\u9020\u51fd\u6570\u7684 `flagging_dir=` \u53c2\u6570\u63d0\u4f9b\u7684\u76ee\u5f55\u4e2d\uff0c\u5c06\u8bb0\u5f55\u6807\u8bb0\u7684\u8f93\u5165\u5230\u4e00\u4e2a CSV \u6587\u4ef6\u4e2d\u3002\u5982\u679c\u754c\u9762\u6d89\u53ca\u6587\u4ef6\u6570\u636e\uff0c\u4f8b\u5982\u56fe\u50cf\u548c\u97f3\u9891\u7ec4\u4ef6\uff0c\u5c06\u521b\u5efa\u6587\u4ef6\u5939\u6765\u5b58\u50a8\u8fd9\u4e9b\u6807\u8bb0\u7684\u6570\u636e\u3002\n\n\u4f8b\u5982\uff0c\u5bf9\u4e8e\u4e0a\u9762\u663e\u793a\u7684\u8ba1\u7b97\u5668\u754c\u9762\uff0c\u6211\u4eec\u5c06\u5728\u4e0b\u9762\u7684\u65d7\u6807\u76ee\u5f55\u4e2d\u5b58\u50a8\u6807\u8bb0\u7684\u6570\u636e\uff1a\n\n```directory\n+-- calculator.py\n+-- flagged/\n|   +-- logs.csv\n```\n\n_flagged/logs.csv_\n\n```csv\nnum1,operation,num2,Output\n5,add,7,12\n6,subtract,1.5,4.5\n```\n\n\u4e0e\u65e9\u671f\u663e\u793a\u7684\u51b7\u8272\u754c\u9762\u76f8\u5bf9\u5e94\uff0c\u6211\u4eec\u5c06\u5728\u4e0b\u9762\u7684\u65d7\u6807\u76ee\u5f55\u4e2d\u5b58\u50a8\u6807\u8bb0\u7684\u6570\u636e\uff1a\n\n```directory\n+-- sepia.py\n+-- flagged/\n|   +-- logs.csv\n|   +-- im/\n|   |   +-- 0.png\n|   |   +-- 1.png\n|   +-- Output/\n|   |   +-- 0.png\n|   |   +-- 1.png\n```\n\n_flagged/logs.csv_\n\n```csv\nim,Output\nim/0.png,Output/0.png\nim/1.png,Output/1.png\n```\n\n\u5982\u679c\u60a8\u5e0c\u671b\u7528\u6237\u63d0\u4f9b\u65d7\u6807\u539f\u56e0\uff0c\u53ef\u4ee5\u5c06\u5b57\u7b26\u4e32\u5217\u8868\u4f20\u9012\u7ed9 Interface \u7684 `flagging_options` \u53c2\u6570\u3002\u7528\u6237\u5728\u8fdb\u884c\u65d7\u6807\u65f6\u5fc5\u987b\u9009\u62e9\u5176\u4e2d\u4e00\u4e2a\u5b57\u7b26\u4e32\uff0c\u8fd9\u5c06\u4f5c\u4e3a\u9644\u52a0\u5217\u4fdd\u5b58\u5230 CSV \u4e2d\u3002\n\n## \u9884\u5904\u7406\u548c\u540e\u5904\u7406 (Preprocessing and Postprocessing)\n\n![annotated](/assets/img/dataflow.svg)\n\n\u5982\u60a8\u6240\u89c1\uff0cGradio \u5305\u62ec\u53ef\u4ee5\u5904\u7406\u5404\u79cd\u4e0d\u540c\u6570\u636e\u7c7b\u578b\u7684\u7ec4\u4ef6\uff0c\u4f8b\u5982\u56fe\u50cf\u3001\u97f3\u9891\u548c\u89c6\u9891\u3002\u5927\u591a\u6570\u7ec4\u4ef6\u90fd\u53ef\u4ee5\u7528\u4f5c\u8f93\u5165\u6216\u8f93\u51fa\u3002\n\n\u5f53\u7ec4\u4ef6\u7528\u4f5c\u8f93\u5165\u65f6\uff0cGradio \u81ea\u52a8\u5904\u7406*\u9884\u5904\u7406*\uff0c\u5c06\u6570\u636e\u4ece\u7528\u6237\n    ```",
            "vector_context": "[Created at: 2025-03-24 13:19:57]\nState in Blocks\n\nWe covered [State in Interfaces](https://gradio.app/interface-state), this guide takes a look at state in Blocks, which works mostly the same.\n\n## Global State\n\nGlobal state in Blocks works the same as in Interface. Any variable created outside a function call is a reference shared between all users.\n\n## Session State\n\nGradio supports session **state**, where data persists across multiple submits within a page session, in Blocks apps as well. To reiterate, session data is _not_ shared between different users of your model. To store data in a session state, you need to do three things:\n\n1. Create a `gr.State()` object. If there is a default value to this stateful object, pass that into the constructor.\n2. In the event listener, put the `State` object as an input and output.\n3. In the event listener function, add the variable to the input parameters and the return value.\n\nLet's take a look at a game of hangman.\n\n$code_hangman\n$demo_hangman\n\nLet's see how we do each of the 3 steps listed above in this game:\n\n1. We store the used letters in `used_letters_var`. In the constructor of `State`, we set the initial value of this to `[]`, an empty list.\n2. In `btn.click()`, we have a reference to `used_letters_var` in both the inputs and outputs.\n3. In `guess_letter`, we pass the value of this `State` to `used_letters`, and then return an updated value of this `State` in the return statement.\n\nWith more complex apps, you will likely have many State variables storing session state in a single Blocks app.\n\nLearn more about `State` in the [docs](https://gradio.app/docs#state).\n--New Chunk--\n[Created at: 2025-03-24 13:18:21]\nGradio Demo: blocks_random_slider\n\n\n```\n!pip install -q gradio \n```\n\n\n```\n\nimport gradio as gr\n\n\ndef func(slider_1, slider_2):\n    return slider_1 * 5 + slider_2\n\n\nwith gr.Blocks() as demo:\n    slider = gr.Slider(minimum=-10.2, maximum=15, label=\"Random Slider (Static)\", randomize=True)\n    slider_1 = gr.Slider(minimum=100, maximum=200, label=\"Random Slider (Input 1)\", randomize=True)\n    slider_2 = gr.Slider(minimum=10, maximum=23.2, label=\"Random Slider (Input 2)\", randomize=True)\n    slider_3 = gr.Slider(value=3, label=\"Non random slider\")\n    btn = gr.Button(\"Run\")\n    btn.click(func, inputs=[slider_1, slider_2], outputs=gr.Number())\n\nif __name__ == \"__main__\":\n    demo.launch()\n\n```\n--New Chunk--\n[Created at: 2025-03-24 13:16:48]\n\u4e0e\u5e38\u89c4\u51fd\u6570\u76f8\u540c\u7684\u65b9\u5f0f\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio\u3002\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\uff08\u865a\u62df\u7684\uff09\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5b83\u5728\u8f93\u51fa\u56fe\u50cf\u4e4b\u524d\u751f\u6210\u6570\u4e2a\u6b65\u9aa4\u7684\u566a\u97f3\uff1a\n\n$code_fake_diffusion\n$demo_fake_diffusion\n\n\u8bf7\u6ce8\u610f\uff0c\u6211\u4eec\u5728\u8fed\u4ee3\u5668\u4e2d\u6dfb\u52a0\u4e86 `time.sleep(1)`\uff0c\u4ee5\u521b\u5efa\u6b65\u9aa4\u4e4b\u95f4\u7684\u4eba\u5de5\u6682\u505c\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u89c2\u5bdf\u8fed\u4ee3\u5668\u7684\u6b65\u9aa4\uff08\u5728\u771f\u5b9e\u7684\u56fe\u50cf\u751f\u6210\u6a21\u578b\u4e2d\uff0c\u8fd9\u53ef\u80fd\u662f\u4e0d\u5fc5\u8981\u7684\uff09\u3002\n\n\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio **\u9700\u8981**\u5728\u5e95\u5c42 Interface \u6216 Blocks \u4e2d\u542f\u7528\u961f\u5217\uff08\u8bf7\u53c2\u9605\u4e0a\u9762\u7684\u961f\u5217\u90e8\u5206\uff09\u3002\n\n## \u8fdb\u5ea6\u6761\n\nGradio \u652f\u6301\u521b\u5efa\u81ea\u5b9a\u4e49\u8fdb\u5ea6\u6761\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u81ea\u5b9a\u4e49\u548c\u63a7\u5236\u5411\u7528\u6237\u663e\u793a\u7684\u8fdb\u5ea6\u66f4\u65b0\u3002\u8981\u542f\u7528\u6b64\u529f\u80fd\uff0c\u53ea\u9700\u4e3a\u65b9\u6cd5\u6dfb\u52a0\u4e00\u4e2a\u9ed8\u8ba4\u503c\u4e3a `gr.Progress` \u5b9e\u4f8b\u7684\u53c2\u6570\u5373\u53ef\u3002\u7136\u540e\uff0c\u60a8\u53ef\u4ee5\u76f4\u63a5\u8c03\u7528\u6b64\u5b9e\u4f8b\u5e76\u4f20\u5165 0 \u5230 1 \u4e4b\u95f4\u7684\u6d6e\u70b9\u6570\u6765\u66f4\u65b0\u8fdb\u5ea6\u7ea7\u522b\uff0c\u6216\u8005 with `Progress` \u5b9e\u4f8b\u7684 `tqdm()` \u65b9\u6cd5\u6765\u8ddf\u8e2a\u53ef\u8fed\u4ee3\u5bf9\u8c61\u4e0a\u7684\u8fdb\u5ea6\uff0c\u5982\u4e0b\u6240\u793a\u3002\u5fc5\u987b\u542f\u7528\u961f\u5217\u4ee5\u8fdb\u884c\u8fdb\u5ea6\u66f4\u65b0\u3002\n\n$code_progress_simple\n$demo_progress_simple\n\n\u5982\u679c\u60a8 with `tqdm` \u5e93\uff0c\u5e76\u4e14\u5e0c\u671b\u4ece\u51fd\u6570\u5185\u90e8\u7684\u4efb\u4f55 `tqdm.tqdm` \u81ea\u52a8\u62a5\u544a\u8fdb\u5ea6\u66f4\u65b0\uff0c\u8bf7\u5c06\u9ed8\u8ba4\u53c2\u6570\u8bbe\u7f6e\u4e3a `gr.Progress(track_tqdm=True)`\uff01\n\n## \u6279\u5904\u7406\u51fd\u6570 (Batch Functions)\n\nGradio \u652f\u6301\u4f20\u9012*\u6279\u5904\u7406*\u51fd\u6570\u3002\u6279\u5904\u7406\u51fd\u6570\u53ea\u662f\u63a5\u53d7\u8f93\u5165\u5217\u8868\u5e76\u8fd4\u56de\u9884\u6d4b\u5217\u8868\u7684\u51fd\u6570\u3002\n\n\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\u6279\u5904\u7406\u51fd\u6570\uff0c\u5b83\u63a5\u53d7\u4e24\u4e2a\u8f93\u5165\u5217\u8868\uff08\u4e00\u4e2a\u5355\u8bcd\u5217\u8868\u548c\u4e00\u4e2a\u6574\u6570\u5217\u8868\uff09\uff0c\u5e76\u8fd4\u56de\u4fee\u526a\u8fc7\u7684\u5355\u8bcd\u5217\u8868\u4f5c\u4e3a\u8f93\u51fa\uff1a\n\n```python\nimport time\n\ndef trim_words(words, lens):\n    trimmed_words = []\n    time.sleep(5)\n    for w, l in zip(words, lens):\n        trimmed_words.append(w[:int(l)])\n    return [trimmed_words]\n    for w, l in zip(words, lens):\n```\n\n\u4f7f\u7528\u6279\u5904\u7406\u51fd\u6570\u7684\u4f18\u70b9\u662f\uff0c\u5982\u679c\u542f\u7528\u4e86\u961f\u5217\uff0cGradio \u670d\u52a1\u5668\u53ef\u4ee5\u81ea\u52a8*\u6279\u5904\u7406*\u4f20\u5165\u7684\u8bf7\u6c42\u5e76\u5e76\u884c\u5904\u7406\u5b83\u4eec\uff0c\u4ece\u800c\u53ef\u80fd\u52a0\u5feb\u6f14\u793a\u901f\u5ea6\u3002\u4ee5\u4e0b\u662f Gradio \u4ee3\u7801\u7684\u793a\u4f8b\uff08\u8bf7\u6ce8\u610f `batch=True` \u548c `max_batch_size=16` - \u8fd9\u4e24\u4e2a\u53c2\u6570\u90fd\u53ef\u4ee5\u4f20\u9012\u7ed9\u4e8b\u4ef6\u89e6\u53d1\u5668\u6216 `Interface` \u7c7b\uff09\n\nwith `Interface`\uff1a\n\n```python\ndemo = gr.Interface(trim_words, [\"textbox\", \"number\"], [\"output\"],\n                    batch=True, max_batch_size=16)\ndemo.queue()\ndemo.launch()\n```\n\nwith `Blocks`\uff1a\n\n```python\nimport gradio as gr\n\nwith gr.Blocks() as demo:\n    with gr.Row():\n        word = gr.Textbox(label=\"word\")\n        leng = gr.Number(label=\"leng\")\n        output = gr.Textbox(label=\"Output\")\n    with gr.Row():\n        run = gr.Button()\n\n    event = run.click(trim_words, [word, leng], output, batch=True, max_batch_size=16)\n\ndemo.queue()\ndemo.launch()\n```\n\n\u5728\u4e0a\u9762\u7684\u793a\u4f8b\u4e2d\uff0c\u53ef\u4ee5\u5e76\u884c\u5904\u7406 16 \u4e2a\u8bf7\u6c42\uff08\u603b\u63a8\u7406\u65f6\u95f4\u4e3a 5 \u79d2\uff09\uff0c\u800c\u4e0d\u662f\u5206\u522b\u5904\u7406\u6bcf\u4e2a\u8bf7\u6c42\uff08\u603b\u63a8\u7406\u65f6\u95f4\u4e3a 80 \u79d2\uff09\u3002\u8bb8\u591a Hugging Face \u7684 `transformers` \u548c `diffusers` \u6a21\u578b\u5728 Gradio \u7684\u6279\u5904\u7406\u6a21\u5f0f\u4e0b\u81ea\u7136\u5de5\u4f5c\uff1a\u8fd9\u662f[\u4f7f\u7528\u6279\u5904\u7406\u751f\u6210\u56fe\u50cf\u7684\u793a\u4f8b\u6f14\u793a](https://github.com/gradio-app/gradio/blob/main/demo/diffusers_with_batching/run.py)\n\n\u6ce8\u610f\uff1a\u4f7f\u7528 Gradio \u7684\u6279\u5904\u7406\u51fd\u6570 **requires** \u5728\u5e95\u5c42 Interface \u6216 Blocks \u4e2d\u542f\u7528\u961f\u5217\uff08\u8bf7\u53c2\u9605\u4e0a\u9762\u7684\u961f\u5217\u90e8\u5206\uff09\u3002\n\n## Gradio \u7b14\u8bb0\u672c (Colab Notebooks)\n\nGradio \u53ef\u4ee5\u5728\u4efb\u4f55\u8fd0\u884c Python \u7684\u5730\u65b9\u8fd0\u884c\uff0c\u5305\u62ec\u672c\u5730 Jupyter \u7b14\u8bb0\u672c\u548c\u534f\u4f5c\u7b14\u8bb0\u672c\uff0c\u5982[Google Colab](https://colab.research.google.com/)\u3002\u5bf9\u4e8e\u672c\u5730 Jupyter \u7b14\u8bb0\u672c\u548c Google Colab \u7b14\u8bb0\u672c\uff0cGradio \u5728\u672c\u5730\u670d\u52a1\u5668\u4e0a\u8fd0\u884c\uff0c\u60a8\u53ef\u4ee5\u5728\u6d4f\u89c8\u5668\u4e2d\u4e0e\u4e4b\u4ea4\u4e92\u3002\uff08\u6ce8\u610f\uff1a\u5bf9\u4e8e Google Colab\uff0c\u8fd9\u662f\u901a\u8fc7[\u670d\u52a1\u5de5\u4f5c\u5668\u96a7\u9053](https://github.com/tensorflow/tensorboard/blob/master/docs/design/colab_integration.md)\u5b9e\u73b0\u7684\uff0c\u60a8\u7684\u6d4f\u89c8\u5668\u9700\u8981\u542f\u7528 cookies\u3002\uff09\u5bf9\u4e8e\u5176\u4ed6\u8fdc\u7a0b\u7b14\u8bb0\u672c\uff0cGradio \u4e5f\u5c06\u5728\u670d\u52a1\u5668\u4e0a\u8fd0\u884c\uff0c\u4f46\u60a8\u9700\u8981\u4f7f\u7528[SSH \u96a7\u9053](https://coderwall.com/p/ohk6cg/remote-access-to-ipython-notebooks-via-ssh)\u5728\u672c\u5730\u6d4f\u89c8\u5668\u4e2d\u67e5\u770b\u5e94\u7528\u7a0b\u5e8f\u3002\u901a\u5e38\uff0c\u66f4\u7b80\u5355\u7684\u9009\u62e9\u662f\u4f7f\u7528 Gradio \u5185\u7f6e\u7684\u516c\u5171\u94fe\u63a5\uff0c[\u5728\u4e0b\u4e00\u7bc7\u6307\u5357\u4e2d\u8ba8\u8bba](/sharing-your-app/#sharing-demos)\u3002"
        }
    },
    {
        "sample_idx": 112,
        "question": "Where can you learn more about State in Gradio Blocks?",
        "answer": "You can learn more about State in the Gradio docs.",
        "rag_answer": "You can learn more about State in Gradio Blocks in the [docs](https://gradio.app/docs#state).",
        "rag_score": 5,
        "rag_feedback": "The response is completely correct, accurate, and factual. It provides a detailed explanation of State in Gradio Blocks, including global state and session state, and provides examples of how to use State in a Blocks app. The response also includes additional information about Gradio, such as preprocessing and postprocessing, styling, queuing, and iterative outputs.",
        "rag_context": {
            "kg_context": "-----Entities-----\n    ```csv\n    id,\tentity,\ttype,\tdescription,\trankcreated_at\n1,\tBlocks,category,Blocks is a category of components in Gradio that enables the creation of custom interfaces.<SEP>Blocks is a component of Gradio that allows users to build custom interfaces for machine learning models.<SEP>Blocks is a category related to Gradio, where state is used to store data.,2,2025-03-24 13:20:24\n2,\tGradio,organization,Gradio is a platform that supports state in Blocks, providing features such as global state and session state.<SEP>Gradio is an interface that provides various features for demonstrating models, including adding example inputs, custom error messages, descriptive content, flagging, and more.<SEP>Gradio is an organization that provides a platform for building and deploying machine learning models.<SEP>Gradio is an organization that provides a platform for creating and deploying machine learning models.<SEP>Gradio is an organization that provides a demo for blocks_random_slider, and its library is used to create interactive interfaces.,36,2025-03-24 13:20:24\n3,\tState,category,State is a concept in Gradio that refers to the storage of data, including global state and session state.,2,2025-03-24 13:20:24\n4,\tGlobal State,category,Global State is a type of state in Gradio that is shared between all users.,1,2025-03-24 13:20:24\n5,\tSession State,category,Session State is a type of state in Gradio that persists across multiple submits within a page session.,2,2025-03-24 13:20:24\n6,\tGradio,organization,Gradio is a platform that supports state in Blocks, providing features such as global state and session state.<SEP>Gradio is an interface that provides various features for demonstrating models, including adding example inputs, custom error messages, descriptive content, flagging, and more.<SEP>Gradio is an organization that provides a platform for building and deploying machine learning models.<SEP>Gradio is an organization that provides a platform for creating and deploying machine learning models.<SEP>Gradio is an organization that provides a demo for blocks_random_slider, and its library is used to create interactive interfaces.,36,UNKNOWN\n7,\tBlocks,category,Blocks is a category of components in Gradio that enables the creation of custom interfaces.<SEP>Blocks is a component of Gradio that allows users to build custom interfaces for machine learning models.<SEP>Blocks is a category related to Gradio, where state is used to store data.,2,UNKNOWN\n8,\tBlocks API,category,Blocks API is an API in Gradio that allows users to create interfaces using a block-based structure.,1,UNKNOWN\n    ```\n    -----Relationships-----\n    ```csv\n    id,\tsource,\ttarget,\tdescription,\tkeywords,\tweight,\trank,\tcreated_at\n1,\tBlocks,Gradio,Gradio provides Blocks components for building custom interfaces.<SEP>Gradio provides the Blocks component for creating custom interfaces.,component relationship, interface creation<SEP>interface building, machine learning,25.0,38,2025-03-24 13:17:31\n2,\tGradio,State,Gradio supports state in Blocks, including global state and session state.,platform feature, data storage,18.0,38,2025-03-24 13:20:24\n3,\tGlobal State,Session State,Global State and Session State are two types of state in Gradio.,state types, data storage,7.0,3,2025-03-24 13:20:24\n4,\tGradio,Hugging Face,Hugging Face models are compatible with Gradio's batch processing functionality.,model compatibility, batch processing,16.0,44,UNKNOWN\n5,\tGradio,Gradio Demo,Gradio provides a demo for blocks_random_slider, which showcases its functionality.,organization, event,16.0,44,UNKNOWN\n6,\tGradio,SSH,Gradio can be run on remote servers using SSH.,remote access, security,7.0,42,UNKNOWN\n7,\tGradio,Interface,Gradio provides Interface components for building custom interfaces.<SEP>Gradio provides features for creating an Interface, which is a user interface for demonstrating models.<SEP>Gradio provides the Interface component for creating custom interfaces.,component relationship, interface creation<SEP>interface building, machine learning<SEP>interface creation, model demonstration,43.0,39,UNKNOWN\n8,\tBlocks,Gradio,Gradio provides Blocks components for building custom interfaces.<SEP>Gradio provides the Blocks component for creating custom interfaces.,component relationship, interface creation<SEP>interface building, machine learning,25.0,38,UNKNOWN\n9,\tGradio,State,Gradio supports state in Blocks, including global state and session state.,platform feature, data storage,18.0,38,UNKNOWN\n10,\tGradio,Jupyter,Gradio can be run on Jupyter notebooks.,platform compatibility, interactive computing,7.0,38,UNKNOWN\n11,\tGradio,demo,Demos are used in Gradio to demonstrate applications.<SEP>demo is an interface provided by Gradio for blocks_random_slider.,demo, application demonstration<SEP>organization, interface,21.0,37,UNKNOWN\n12,\tBatch Functions,Gradio,Gradio supports batch processing of inputs using batch functions.,functionality, batch processing,18.0,37,UNKNOWN\n13,\tGradio,Image,Gradio provides components that can process Image data types.,data processing, image handling,16.0,37,UNKNOWN\n14,\tGradio,Websockets,Gradio uses Websockets for communication protocol.,communication protocol, real-time data,16.0,37,UNKNOWN\n15,\tColab Notebooks,Gradio,Gradio can be run on Colab Notebooks, a location for collaborative work.,collaborative work, location,14.0,37,UNKNOWN\n16,\tGradio,PIL,Gradio can use PIL library for image processing.,library integration, image processing,14.0,37,UNKNOWN\n17,\tGradio,numpy,Gradio can use numpy library for numerical computing.,library integration, numerical computing,14.0,37,UNKNOWN\n18,\tGradio,Progress,Gradio provides the Progress component for creating custom progress bars.,component relationship, progress tracking,14.0,37,UNKNOWN\n19,\tGoogle Colab,Gradio,Gradio can be run on Google Colab notebooks.,platform compatibility, cloud-based,14.0,37,UNKNOWN\n20,\tCSV,Gradio,Gradio can use CSV file format for data storage.,data storage, file format,12.0,37,UNKNOWN\n21,\tBlocks API,Gradio,Gradio provides the Blocks API for creating interfaces.,interface creation, API,9.0,37,UNKNOWN\n22,\tConcurrency,Gradio,Gradio supports concurrency for processing multiple requests simultaneously.,request processing, concurrency,9.0,37,UNKNOWN\n23,\tGradio,Iterative Outputs,Gradio supports iterative outputs for generating and displaying multiple outputs in sequence.,output generation, sequence,9.0,37,UNKNOWN\n24,\tGradio,gr,gr is the organization that provides the Gradio library used in the demo.,organization, organization,9.0,37,UNKNOWN\n25,\tExample Inputs,Gradio,Gradio allows users to add example inputs to an interface.,example inputs, interface feature,8.0,37,UNKNOWN\n26,\tDescriptive Content,Gradio,Gradio allows users to add descriptive content to an interface.,descriptive content, interface feature,8.0,37,UNKNOWN\n27,\tGradio,Preprocessing and Postprocessing,Gradio provides features for preprocessing and postprocessing data.,data processing, interface feature,8.0,37,UNKNOWN\n28,\tGallery,Gradio,Gradio provides Gallery components for displaying images.,image display, visualization,8.0,37,UNKNOWN\n29,\tGradio,Preprocessing,Gradio supports preprocessing of data for machine learning models.,data preprocessing, machine learning,8.0,37,UNKNOWN\n30,\tGradio,Postprocessing,Gradio supports postprocessing of output from machine learning models.,output transformation, machine learning,8.0,37,UNKNOWN\n31,\tGradio,Queuing,Gradio supports queuing for managing the flow of requests to machine learning models.,request management, machine learning,8.0,37,UNKNOWN\n32,\tGradio,queue,Queue is a component in Gradio that enables batch processing.,component relationship, batch processing,8.0,37,UNKNOWN\n33,\tGradio,docs,The Gradio docs provide more information about state.,documentation, platform information,8.0,37,UNKNOWN\n34,\tErrors,Gradio,Gradio allows users to display custom error messages.,error messages, interface feature,7.0,37,UNKNOWN\n35,\tFlagging,Gradio,Gradio allows users to mark inputs for review.,flagging, interface feature,7.0,37,UNKNOWN\n36,\tGradio,Styling,Gradio allows users to customize the appearance of interfaces through styling.,interface customization, appearance,7.0,37,UNKNOWN\n37,\tGradio,Theming,Gradio allows users to customize the visual theme of interfaces through theming.,interface customization, theme,7.0,37,UNKNOWN\n38,\tGradio,tqdm,tqdm is used in Gradio for creating progress bars.,library integration, progress tracking,7.0,37,UNKNOWN\n39,\tGradio,event,Events are used in Gradio to trigger specific actions.,event handling, functionality,7.0,37,UNKNOWN\n40,\tBlocks,Hangman,Hangman is an example game that uses state in Blocks.,example, game development,16.0,3,UNKNOWN\n    ```\n    -----Sources-----\n    ```csv\n    id,\tcontent\n1,\t\u4e0e\u5e38\u89c4\u51fd\u6570\u76f8\u540c\u7684\u65b9\u5f0f\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio\u3002\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\uff08\u865a\u62df\u7684\uff09\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5b83\u5728\u8f93\u51fa\u56fe\u50cf\u4e4b\u524d\u751f\u6210\u6570\u4e2a\u6b65\u9aa4\u7684\u566a\u97f3\uff1a\n\n$code_fake_diffusion\n$demo_fake_diffusion\n\n\u8bf7\u6ce8\u610f\uff0c\u6211\u4eec\u5728\u8fed\u4ee3\u5668\u4e2d\u6dfb\u52a0\u4e86 `time.sleep(1)`\uff0c\u4ee5\u521b\u5efa\u6b65\u9aa4\u4e4b\u95f4\u7684\u4eba\u5de5\u6682\u505c\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u89c2\u5bdf\u8fed\u4ee3\u5668\u7684\u6b65\u9aa4\uff08\u5728\u771f\u5b9e\u7684\u56fe\u50cf\u751f\u6210\u6a21\u578b\u4e2d\uff0c\u8fd9\u53ef\u80fd\u662f\u4e0d\u5fc5\u8981\u7684\uff09\u3002\n\n\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio **\u9700\u8981**\u5728\u5e95\u5c42 Interface \u6216 Blocks \u4e2d\u542f\u7528\u961f\u5217\uff08\u8bf7\u53c2\u9605\u4e0a\u9762\u7684\u961f\u5217\u90e8\u5206\uff09\u3002\n\n## \u8fdb\u5ea6\u6761\n\nGradio \u652f\u6301\u521b\u5efa\u81ea\u5b9a\u4e49\u8fdb\u5ea6\u6761\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u81ea\u5b9a\u4e49\u548c\u63a7\u5236\u5411\u7528\u6237\u663e\u793a\u7684\u8fdb\u5ea6\u66f4\u65b0\u3002\u8981\u542f\u7528\u6b64\u529f\u80fd\uff0c\u53ea\u9700\u4e3a\u65b9\u6cd5\u6dfb\u52a0\u4e00\u4e2a\u9ed8\u8ba4\u503c\u4e3a `gr.Progress` \u5b9e\u4f8b\u7684\u53c2\u6570\u5373\u53ef\u3002\u7136\u540e\uff0c\u60a8\u53ef\u4ee5\u76f4\u63a5\u8c03\u7528\u6b64\u5b9e\u4f8b\u5e76\u4f20\u5165 0 \u5230 1 \u4e4b\u95f4\u7684\u6d6e\u70b9\u6570\u6765\u66f4\u65b0\u8fdb\u5ea6\u7ea7\u522b\uff0c\u6216\u8005 with `Progress` \u5b9e\u4f8b\u7684 `tqdm()` \u65b9\u6cd5\u6765\u8ddf\u8e2a\u53ef\u8fed\u4ee3\u5bf9\u8c61\u4e0a\u7684\u8fdb\u5ea6\uff0c\u5982\u4e0b\u6240\u793a\u3002\u5fc5\u987b\u542f\u7528\u961f\u5217\u4ee5\u8fdb\u884c\u8fdb\u5ea6\u66f4\u65b0\u3002\n\n$code_progress_simple\n$demo_progress_simple\n\n\u5982\u679c\u60a8 with `tqdm` \u5e93\uff0c\u5e76\u4e14\u5e0c\u671b\u4ece\u51fd\u6570\u5185\u90e8\u7684\u4efb\u4f55 `tqdm.tqdm` \u81ea\u52a8\u62a5\u544a\u8fdb\u5ea6\u66f4\u65b0\uff0c\u8bf7\u5c06\u9ed8\u8ba4\u53c2\u6570\u8bbe\u7f6e\u4e3a `gr.Progress(track_tqdm=True)`\uff01\n\n## \u6279\u5904\u7406\u51fd\u6570 (Batch Functions)\n\nGradio \u652f\u6301\u4f20\u9012*\u6279\u5904\u7406*\u51fd\u6570\u3002\u6279\u5904\u7406\u51fd\u6570\u53ea\u662f\u63a5\u53d7\u8f93\u5165\u5217\u8868\u5e76\u8fd4\u56de\u9884\u6d4b\u5217\u8868\u7684\u51fd\u6570\u3002\n\n\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\u6279\u5904\u7406\u51fd\u6570\uff0c\u5b83\u63a5\u53d7\u4e24\u4e2a\u8f93\u5165\u5217\u8868\uff08\u4e00\u4e2a\u5355\u8bcd\u5217\u8868\u548c\u4e00\u4e2a\u6574\u6570\u5217\u8868\uff09\uff0c\u5e76\u8fd4\u56de\u4fee\u526a\u8fc7\u7684\u5355\u8bcd\u5217\u8868\u4f5c\u4e3a\u8f93\u51fa\uff1a\n\n```python\nimport time\n\ndef trim_words(words, lens):\n    trimmed_words = []\n    time.sleep(5)\n    for w, l in zip(words, lens):\n        trimmed_words.append(w[:int(l)])\n    return [trimmed_words]\n    for w, l in zip(words, lens):\n```\n\n\u4f7f\u7528\u6279\u5904\u7406\u51fd\u6570\u7684\u4f18\u70b9\u662f\uff0c\u5982\u679c\u542f\u7528\u4e86\u961f\u5217\uff0cGradio \u670d\u52a1\u5668\u53ef\u4ee5\u81ea\u52a8*\u6279\u5904\u7406*\u4f20\u5165\u7684\u8bf7\u6c42\u5e76\u5e76\u884c\u5904\u7406\u5b83\u4eec\uff0c\u4ece\u800c\u53ef\u80fd\u52a0\u5feb\u6f14\u793a\u901f\u5ea6\u3002\u4ee5\u4e0b\u662f Gradio \u4ee3\u7801\u7684\u793a\u4f8b\uff08\u8bf7\u6ce8\u610f `batch=True` \u548c `max_batch_size=16` - \u8fd9\u4e24\u4e2a\u53c2\u6570\u90fd\u53ef\u4ee5\u4f20\u9012\u7ed9\u4e8b\u4ef6\u89e6\u53d1\u5668\u6216 `Interface` \u7c7b\uff09\n\nwith `Interface`\uff1a\n\n```python\ndemo = gr.Interface(trim_words, [\"textbox\", \"number\"], [\"output\"],\n                    batch=True, max_batch_size=16)\ndemo.queue()\ndemo.launch()\n```\n\nwith `Blocks`\uff1a\n\n```python\nimport gradio as gr\n\nwith gr.Blocks() as demo:\n    with gr.Row():\n        word = gr.Textbox(label=\"word\")\n        leng = gr.Number(label=\"leng\")\n        output = gr.Textbox(label=\"Output\")\n    with gr.Row():\n        run = gr.Button()\n\n    event = run.click(trim_words, [word, leng], output, batch=True, max_batch_size=16)\n\ndemo.queue()\ndemo.launch()\n```\n\n\u5728\u4e0a\u9762\u7684\u793a\u4f8b\u4e2d\uff0c\u53ef\u4ee5\u5e76\u884c\u5904\u7406 16 \u4e2a\u8bf7\u6c42\uff08\u603b\u63a8\u7406\u65f6\u95f4\u4e3a 5 \u79d2\uff09\uff0c\u800c\u4e0d\u662f\u5206\u522b\u5904\u7406\u6bcf\u4e2a\u8bf7\u6c42\uff08\u603b\u63a8\u7406\u65f6\u95f4\u4e3a 80 \u79d2\uff09\u3002\u8bb8\u591a Hugging Face \u7684 `transformers` \u548c `diffusers` \u6a21\u578b\u5728 Gradio \u7684\u6279\u5904\u7406\u6a21\u5f0f\u4e0b\u81ea\u7136\u5de5\u4f5c\uff1a\u8fd9\u662f[\u4f7f\u7528\u6279\u5904\u7406\u751f\u6210\u56fe\u50cf\u7684\u793a\u4f8b\u6f14\u793a](https://github.com/gradio-app/gradio/blob/main/demo/diffusers_with_batching/run.py)\n\n\u6ce8\u610f\uff1a\u4f7f\u7528 Gradio \u7684\u6279\u5904\u7406\u51fd\u6570 **requires** \u5728\u5e95\u5c42 Interface \u6216 Blocks \u4e2d\u542f\u7528\u961f\u5217\uff08\u8bf7\u53c2\u9605\u4e0a\u9762\u7684\u961f\u5217\u90e8\u5206\uff09\u3002\n\n## Gradio \u7b14\u8bb0\u672c (Colab Notebooks)\n\nGradio \u53ef\u4ee5\u5728\u4efb\u4f55\u8fd0\u884c Python \u7684\u5730\u65b9\u8fd0\u884c\uff0c\u5305\u62ec\u672c\u5730 Jupyter \u7b14\u8bb0\u672c\u548c\u534f\u4f5c\u7b14\u8bb0\u672c\uff0c\u5982[Google Colab](https://colab.research.google.com/)\u3002\u5bf9\u4e8e\u672c\u5730 Jupyter \u7b14\u8bb0\u672c\u548c Google Colab \u7b14\u8bb0\u672c\uff0cGradio \u5728\u672c\u5730\u670d\u52a1\u5668\u4e0a\u8fd0\u884c\uff0c\u60a8\u53ef\u4ee5\u5728\u6d4f\u89c8\u5668\u4e2d\u4e0e\u4e4b\u4ea4\u4e92\u3002\uff08\u6ce8\u610f\uff1a\u5bf9\u4e8e Google Colab\uff0c\u8fd9\u662f\u901a\u8fc7[\u670d\u52a1\u5de5\u4f5c\u5668\u96a7\u9053](https://github.com/tensorflow/tensorboard/blob/master/docs/design/colab_integration.md)\u5b9e\u73b0\u7684\uff0c\u60a8\u7684\u6d4f\u89c8\u5668\u9700\u8981\u542f\u7528 cookies\u3002\uff09\u5bf9\u4e8e\u5176\u4ed6\u8fdc\u7a0b\u7b14\u8bb0\u672c\uff0cGradio \u4e5f\u5c06\u5728\u670d\u52a1\u5668\u4e0a\u8fd0\u884c\uff0c\u4f46\u60a8\u9700\u8981\u4f7f\u7528[SSH \u96a7\u9053](https://coderwall.com/p/ohk6cg/remote-access-to-ipython-notebooks-via-ssh)\u5728\u672c\u5730\u6d4f\u89c8\u5668\u4e2d\u67e5\u770b\u5e94\u7528\u7a0b\u5e8f\u3002\u901a\u5e38\uff0c\u66f4\u7b80\u5355\u7684\u9009\u62e9\u662f\u4f7f\u7528 Gradio \u5185\u7f6e\u7684\u516c\u5171\u94fe\u63a5\uff0c[\u5728\u4e0b\u4e00\u7bc7\u6307\u5357\u4e2d\u8ba8\u8bba](/sharing-your-app/#sharing-demos)\u3002\n2,\t\u65f6\u5fc5\u987b\u9009\u62e9\u5176\u4e2d\u4e00\u4e2a\u5b57\u7b26\u4e32\uff0c\u8fd9\u5c06\u4f5c\u4e3a\u9644\u52a0\u5217\u4fdd\u5b58\u5230 CSV \u4e2d\u3002\n\n## \u9884\u5904\u7406\u548c\u540e\u5904\u7406 (Preprocessing and Postprocessing)\n\n![annotated](/assets/img/dataflow.svg)\n\n\u5982\u60a8\u6240\u89c1\uff0cGradio \u5305\u62ec\u53ef\u4ee5\u5904\u7406\u5404\u79cd\u4e0d\u540c\u6570\u636e\u7c7b\u578b\u7684\u7ec4\u4ef6\uff0c\u4f8b\u5982\u56fe\u50cf\u3001\u97f3\u9891\u548c\u89c6\u9891\u3002\u5927\u591a\u6570\u7ec4\u4ef6\u90fd\u53ef\u4ee5\u7528\u4f5c\u8f93\u5165\u6216\u8f93\u51fa\u3002\n\n\u5f53\u7ec4\u4ef6\u7528\u4f5c\u8f93\u5165\u65f6\uff0cGradio \u81ea\u52a8\u5904\u7406*\u9884\u5904\u7406*\uff0c\u5c06\u6570\u636e\u4ece\u7528\u6237\u6d4f\u89c8\u5668\u53d1\u9001\u7684\u7c7b\u578b\uff08\u4f8b\u5982\u7f51\u7edc\u6444\u50cf\u5934\u5feb\u7167\u7684 base64 \u8868\u793a\uff09\u8f6c\u6362\u4e3a\u60a8\u7684\u51fd\u6570\u53ef\u4ee5\u63a5\u53d7\u7684\u5f62\u5f0f\uff08\u4f8b\u5982 `numpy` \u6570\u7ec4\uff09\u3002\n\n\u540c\u6837\uff0c\u5f53\u7ec4\u4ef6\u7528\u4f5c\u8f93\u51fa\u65f6\uff0cGradio \u81ea\u52a8\u5904\u7406*\u540e\u5904\u7406*\uff0c\u5c06\u6570\u636e\u4ece\u51fd\u6570\u8fd4\u56de\u7684\u5f62\u5f0f\uff08\u4f8b\u5982\u56fe\u50cf\u8def\u5f84\u5217\u8868\uff09\u8f6c\u6362\u4e3a\u53ef\u4ee5\u5728\u7528\u6237\u6d4f\u89c8\u5668\u4e2d\u663e\u793a\u7684\u5f62\u5f0f\uff08\u4f8b\u5982\u4ee5 base64 \u683c\u5f0f\u663e\u793a\u56fe\u50cf\u7684 `Gallery`\uff09\u3002\n\n\u60a8\u53ef\u4ee5\u4f7f\u7528\u6784\u5efa\u56fe\u50cf\u7ec4\u4ef6\u65f6\u7684\u53c2\u6570\u63a7\u5236*\u9884\u5904\u7406*\u3002\u4f8b\u5982\uff0c\u5982\u679c\u60a8\u4f7f\u7528\u4ee5\u4e0b\u53c2\u6570\u5b9e\u4f8b\u5316 `Image` \u7ec4\u4ef6\uff0c\u5b83\u5c06\u5c06\u56fe\u50cf\u8f6c\u6362\u4e3a `PIL` \u7c7b\u578b\uff0c\u5e76\u5c06\u5176\u91cd\u5851\u4e3a`(100, 100)`\uff0c\u800c\u4e0d\u7ba1\u63d0\u4ea4\u65f6\u7684\u539f\u59cb\u5927\u5c0f\u5982\u4f55\uff1a\n\n```py\nimg = gr.Image(shape=(100, 100), type=\"pil\")\n```\n\n\u76f8\u53cd\uff0c\u8fd9\u91cc\u6211\u4eec\u4fdd\u7559\u56fe\u50cf\u7684\u539f\u59cb\u5927\u5c0f\uff0c\u4f46\u5728\u5c06\u5176\u8f6c\u6362\u4e3a numpy \u6570\u7ec4\u4e4b\u524d\u53cd\u8f6c\u989c\u8272\uff1a\n\n```py\nimg = gr.Image(invert_colors=True, type=\"numpy\")\n```\n\n\u540e\u5904\u7406\u8981\u5bb9\u6613\u5f97\u591a\uff01Gradio \u81ea\u52a8\u8bc6\u522b\u8fd4\u56de\u6570\u636e\u7684\u683c\u5f0f\uff08\u4f8b\u5982 `Image` \u662f `numpy` \u6570\u7ec4\u8fd8\u662f `str` \u6587\u4ef6\u8def\u5f84\uff1f\uff09\uff0c\u5e76\u5c06\u5176\u540e\u5904\u7406\u4e3a\u53ef\u4ee5\u7531\u6d4f\u89c8\u5668\u663e\u793a\u7684\u683c\u5f0f\u3002\n\n\u8bf7\u67e5\u770b[\u6587\u6863](https://gradio.app/docs)\uff0c\u4e86\u89e3\u6bcf\u4e2a\u7ec4\u4ef6\u7684\u6240\u6709\u4e0e\u9884\u5904\u7406\u76f8\u5173\u7684\u53c2\u6570\u3002\n\n## \u6837\u5f0f (Styling)\n\nGradio \u4e3b\u9898\u662f\u81ea\u5b9a\u4e49\u5e94\u7528\u7a0b\u5e8f\u5916\u89c2\u548c\u611f\u89c9\u7684\u6700\u7b80\u5355\u65b9\u6cd5\u3002\u60a8\u53ef\u4ee5\u9009\u62e9\u591a\u79cd\u4e3b\u9898\u6216\u521b\u5efa\u81ea\u5df1\u7684\u4e3b\u9898\u3002\u8981\u8fd9\u6837\u505a\uff0c\u8bf7\u5c06 `theme=` \u53c2\u6570\u4f20\u9012\u7ed9 `Interface` \u6784\u9020\u51fd\u6570\u3002\u4f8b\u5982\uff1a\n\n```python\ndemo = gr.Interface(..., theme=gr.themes.Monochrome())\n```\n\nGradio \u5e26\u6709\u4e00\u7ec4\u9884\u5148\u6784\u5efa\u7684\u4e3b\u9898\uff0c\u60a8\u53ef\u4ee5\u4ece `gr.themes.*` \u52a0\u8f7d\u3002\u60a8\u53ef\u4ee5\u6269\u5c55\u8fd9\u4e9b\u4e3b\u9898\u6216\u4ece\u5934\u5f00\u59cb\u521b\u5efa\u81ea\u5df1\u7684\u4e3b\u9898 - \u6709\u5173\u66f4\u591a\u8be6\u7ec6\u4fe1\u606f\uff0c\u8bf7\u53c2\u9605[\u4e3b\u9898\u6307\u5357](https://gradio.app/theming-guide)\u3002\n\n\u8981\u589e\u52a0\u989d\u5916\u7684\u6837\u5f0f\u80fd\u529b\uff0c\u60a8\u53ef\u4ee5 with `css=` \u5173\u952e\u5b57\u5c06\u4efb\u4f55 CSS \u4f20\u9012\u7ed9\u60a8\u7684\u5e94\u7528\u7a0b\u5e8f\u3002\nGradio \u5e94\u7528\u7a0b\u5e8f\u7684\u57fa\u7c7b\u662f `gradio-container`\uff0c\u56e0\u6b64\u4ee5\u4e0b\u662f\u4e00\u4e2a\u66f4\u6539 Gradio \u5e94\u7528\u7a0b\u5e8f\u80cc\u666f\u989c\u8272\u7684\u793a\u4f8b\uff1a\n\n```python\nwith `gr.Interface(css=\".gradio-container {background-color: red}\") as demo:\n    ...\n```\n\n## \u961f\u5217 (Queuing)\n\n\u5982\u679c\u60a8\u7684\u5e94\u7528\u7a0b\u5e8f\u9884\u8ba1\u4f1a\u6709\u5927\u91cf\u6d41\u91cf\uff0c\u8bf7 with `queue()` \u65b9\u6cd5\u6765\u63a7\u5236\u5904\u7406\u901f\u7387\u3002\u8fd9\u5c06\u6392\u961f\u5904\u7406\u8c03\u7528\uff0c\u56e0\u6b64\u4e00\u6b21\u53ea\u5904\u7406\u4e00\u5b9a\u6570\u91cf\u7684\u8bf7\u6c42\u3002\u961f\u5217\u4f7f\u7528 Websockets\uff0c\u8fd8\u53ef\u4ee5\u9632\u6b62\u7f51\u7edc\u8d85\u65f6\uff0c\u56e0\u6b64\u5982\u679c\u60a8\u7684\u51fd\u6570\u7684\u63a8\u7406\u65f6\u95f4\u5f88\u957f\uff08> 1 \u5206\u949f\uff09\uff0c\u5e94\u4f7f\u7528\u961f\u5217\u3002\n\nwith `Interface`\uff1a\n\n```python\ndemo = gr.Interface(...).queue()\ndemo.launch()\n```\n\nwith `Blocks`\uff1a\n\n```python\nwith gr.Blocks() as demo\uff1a\n    #...\ndemo.queue()\ndemo.launch()\n```\n\n\u60a8\u53ef\u4ee5\u901a\u8fc7\u4ee5\u4e0b\u65b9\u5f0f\u63a7\u5236\u4e00\u6b21\u5904\u7406\u7684\u8bf7\u6c42\u6570\u91cf\uff1a\n\n```python\ndemo.queue(concurrency_count=3)\n```\n\n\u67e5\u770b\u6709\u5173\u914d\u7f6e\u5176\u4ed6\u961f\u5217\u53c2\u6570\u7684[\u961f\u5217\u6587\u6863](/docs/#queue)\u3002\n\n\u5728 Blocks \u4e2d\u6307\u5b9a\u4ec5\u5bf9\u67d0\u4e9b\u51fd\u6570\u8fdb\u884c\u6392\u961f\uff1a\n\n```python\nwith gr.Blocks() as demo2\uff1a\n    num1 = gr.Number()\n    num2 = gr.Number()\n    output = gr.Number()\n    gr.Button(\"Add\").click(\n        lambda a, b: a + b, [num1, num2], output)\n    gr.Button(\"Multiply\").click(\n        lambda a, b: a * b, [num1, num2], output, queue=True)\ndemo2.launch()\n```\n\n## \u8fed\u4ee3\u8f93\u51fa (Iterative Outputs)\n\n\u5728\u67d0\u4e9b\u60c5\u51b5\u4e0b\uff0c\u60a8\u53ef\u80fd\u9700\u8981\u4f20\u8f93\u4e00\u7cfb\u5217\u8f93\u51fa\u800c\u4e0d\u662f\u4e00\u6b21\u663e\u793a\u5355\u4e2a\u8f93\u51fa\u3002\u4f8b\u5982\uff0c\u60a8\u53ef\u80fd\u6709\u4e00\u4e2a\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5e0c\u671b\u663e\u793a\u751f\u6210\u7684\u6bcf\u4e2a\u6b65\u9aa4\u7684\u56fe\u50cf\uff0c\u76f4\u5230\u6700\u7ec8\u56fe\u50cf\u3002\u6216\u8005\u60a8\u53ef\u80fd\u6709\u4e00\u4e2a\u804a\u5929\u673a\u5668\u4eba\uff0c\u5b83\u9010\u5b57\u9010\u53e5\u5730\u6d41\u5f0f\u4f20\u8f93\u54cd\u5e94\uff0c\u800c\u4e0d\u662f\u4e00\u6b21\u8fd4\u56de\u5168\u90e8\u54cd\u5e94\u3002\n\n\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u60a8\u53ef\u4ee5\u5c06**\u751f\u6210\u5668**\u51fd\u6570\u63d0\u4f9b\u7ed9 Gradio\uff0c\u800c\u4e0d\u662f\u5e38\u89c4\u51fd\u6570\u3002\u5728 Python \u4e2d\u521b\u5efa\u751f\u6210\u5668\u975e\u5e38\u7b80\u5355\uff1a\u51fd\u6570\u4e0d\u5e94\u8be5\u6709\u4e00\u4e2a\u5355\u72ec\u7684 `return` \u503c\uff0c\u800c\u662f\u5e94\u8be5 with `yield` \u8fde\u7eed\u8fd4\u56de\u4e00\u7cfb\u5217\u503c\u3002\u901a\u5e38\uff0c`yield` \u8bed\u53e5\u653e\u7f6e\u5728\u67d0\u79cd\u5faa\u73af\u4e2d\u3002\u4e0b\u9762\u662f\u4e00\u4e2a\u7b80\u5355\u793a\u4f8b\uff0c\u751f\u6210\u5668\u53ea\u662f\u7b80\u5355\u8ba1\u6570\u5230\u7ed9\u5b9a\u6570\u5b57\uff1a\n\n```python\ndef my_generator(x):\n    for i in range(x):\n        yield i\n```\n\n\u60a8\u4ee5\u4e0e\u5e38\u89c4\u51fd\u6570\u76f8\u540c\u7684\u65b9\u5f0f\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio\u3002\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\uff08\u865a\u62df\u7684\uff09\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5b83\u5728\u8f93\u51fa\u56fe\u50cf\u4e4b\u524d\u751f\u6210\u6570\u4e2a\u6b65\u9aa4\u7684\u566a\u97f3\uff1a\n\n$code_fake_diffusion\n$demo_fake_diffusion\n\n\u8bf7\u6ce8\u610f\uff0c\u6211\u4eec\u5728\u8fed\u4ee3\u5668\u4e2d\u6dfb\u52a0\u4e86 `time.sleep(1)`\uff0c\u4ee5\u521b\u5efa\u6b65\u9aa4\u4e4b\u95f4\u7684\u4eba\u5de5\u6682\u505c\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u89c2\u5bdf\u8fed\u4ee3\u5668\u7684\u6b65\u9aa4\uff08\u5728\u771f\u5b9e\u7684\u56fe\u50cf\u751f\u6210\u6a21\u578b\u4e2d\uff0c\u8fd9\n3,\tState in Blocks\n\nWe covered [State in Interfaces](https://gradio.app/interface-state), this guide takes a look at state in Blocks, which works mostly the same.\n\n## Global State\n\nGlobal state in Blocks works the same as in Interface. Any variable created outside a function call is a reference shared between all users.\n\n## Session State\n\nGradio supports session **state**, where data persists across multiple submits within a page session, in Blocks apps as well. To reiterate, session data is _not_ shared between different users of your model. To store data in a session state, you need to do three things:\n\n1. Create a `gr.State()` object. If there is a default value to this stateful object, pass that into the constructor.\n2. In the event listener, put the `State` object as an input and output.\n3. In the event listener function, add the variable to the input parameters and the return value.\n\nLet's take a look at a game of hangman.\n\n$code_hangman\n$demo_hangman\n\nLet's see how we do each of the 3 steps listed above in this game:\n\n1. We store the used letters in `used_letters_var`. In the constructor of `State`, we set the initial value of this to `[]`, an empty list.\n2. In `btn.click()`, we have a reference to `used_letters_var` in both the inputs and outputs.\n3. In `guess_letter`, we pass the value of this `State` to `used_letters`, and then return an updated value of this `State` in the return statement.\n\nWith more complex apps, you will likely have many State variables storing session state in a single Blocks app.\n\nLearn more about `State` in the [docs](https://gradio.app/docs#state).\n4,\tGradio Demo: blocks_random_slider\n\n\n```\n!pip install -q gradio \n```\n\n\n```\n\nimport gradio as gr\n\n\ndef func(slider_1, slider_2):\n    return slider_1 * 5 + slider_2\n\n\nwith gr.Blocks() as demo:\n    slider = gr.Slider(minimum=-10.2, maximum=15, label=\"Random Slider (Static)\", randomize=True)\n    slider_1 = gr.Slider(minimum=100, maximum=200, label=\"Random Slider (Input 1)\", randomize=True)\n    slider_2 = gr.Slider(minimum=10, maximum=23.2, label=\"Random Slider (Input 2)\", randomize=True)\n    slider_3 = gr.Slider(value=3, label=\"Non random slider\")\n    btn = gr.Button(\"Run\")\n    btn.click(func, inputs=[slider_1, slider_2], outputs=gr.Number())\n\nif __name__ == \"__main__\":\n    demo.launch()\n\n```\n    ```",
            "vector_context": "[Created at: 2025-03-24 13:19:57]\nState in Blocks\n\nWe covered [State in Interfaces](https://gradio.app/interface-state), this guide takes a look at state in Blocks, which works mostly the same.\n\n## Global State\n\nGlobal state in Blocks works the same as in Interface. Any variable created outside a function call is a reference shared between all users.\n\n## Session State\n\nGradio supports session **state**, where data persists across multiple submits within a page session, in Blocks apps as well. To reiterate, session data is _not_ shared between different users of your model. To store data in a session state, you need to do three things:\n\n1. Create a `gr.State()` object. If there is a default value to this stateful object, pass that into the constructor.\n2. In the event listener, put the `State` object as an input and output.\n3. In the event listener function, add the variable to the input parameters and the return value.\n\nLet's take a look at a game of hangman.\n\n$code_hangman\n$demo_hangman\n\nLet's see how we do each of the 3 steps listed above in this game:\n\n1. We store the used letters in `used_letters_var`. In the constructor of `State`, we set the initial value of this to `[]`, an empty list.\n2. In `btn.click()`, we have a reference to `used_letters_var` in both the inputs and outputs.\n3. In `guess_letter`, we pass the value of this `State` to `used_letters`, and then return an updated value of this `State` in the return statement.\n\nWith more complex apps, you will likely have many State variables storing session state in a single Blocks app.\n\nLearn more about `State` in the [docs](https://gradio.app/docs#state).\n--New Chunk--\n[Created at: 2025-03-24 13:18:21]\nGradio Demo: blocks_random_slider\n\n\n```\n!pip install -q gradio \n```\n\n\n```\n\nimport gradio as gr\n\n\ndef func(slider_1, slider_2):\n    return slider_1 * 5 + slider_2\n\n\nwith gr.Blocks() as demo:\n    slider = gr.Slider(minimum=-10.2, maximum=15, label=\"Random Slider (Static)\", randomize=True)\n    slider_1 = gr.Slider(minimum=100, maximum=200, label=\"Random Slider (Input 1)\", randomize=True)\n    slider_2 = gr.Slider(minimum=10, maximum=23.2, label=\"Random Slider (Input 2)\", randomize=True)\n    slider_3 = gr.Slider(value=3, label=\"Non random slider\")\n    btn = gr.Button(\"Run\")\n    btn.click(func, inputs=[slider_1, slider_2], outputs=gr.Number())\n\nif __name__ == \"__main__\":\n    demo.launch()\n\n```\n--New Chunk--\n[Created at: 2025-03-24 13:16:48]\n\u65f6\u5fc5\u987b\u9009\u62e9\u5176\u4e2d\u4e00\u4e2a\u5b57\u7b26\u4e32\uff0c\u8fd9\u5c06\u4f5c\u4e3a\u9644\u52a0\u5217\u4fdd\u5b58\u5230 CSV \u4e2d\u3002\n\n## \u9884\u5904\u7406\u548c\u540e\u5904\u7406 (Preprocessing and Postprocessing)\n\n![annotated](/assets/img/dataflow.svg)\n\n\u5982\u60a8\u6240\u89c1\uff0cGradio \u5305\u62ec\u53ef\u4ee5\u5904\u7406\u5404\u79cd\u4e0d\u540c\u6570\u636e\u7c7b\u578b\u7684\u7ec4\u4ef6\uff0c\u4f8b\u5982\u56fe\u50cf\u3001\u97f3\u9891\u548c\u89c6\u9891\u3002\u5927\u591a\u6570\u7ec4\u4ef6\u90fd\u53ef\u4ee5\u7528\u4f5c\u8f93\u5165\u6216\u8f93\u51fa\u3002\n\n\u5f53\u7ec4\u4ef6\u7528\u4f5c\u8f93\u5165\u65f6\uff0cGradio \u81ea\u52a8\u5904\u7406*\u9884\u5904\u7406*\uff0c\u5c06\u6570\u636e\u4ece\u7528\u6237\u6d4f\u89c8\u5668\u53d1\u9001\u7684\u7c7b\u578b\uff08\u4f8b\u5982\u7f51\u7edc\u6444\u50cf\u5934\u5feb\u7167\u7684 base64 \u8868\u793a\uff09\u8f6c\u6362\u4e3a\u60a8\u7684\u51fd\u6570\u53ef\u4ee5\u63a5\u53d7\u7684\u5f62\u5f0f\uff08\u4f8b\u5982 `numpy` \u6570\u7ec4\uff09\u3002\n\n\u540c\u6837\uff0c\u5f53\u7ec4\u4ef6\u7528\u4f5c\u8f93\u51fa\u65f6\uff0cGradio \u81ea\u52a8\u5904\u7406*\u540e\u5904\u7406*\uff0c\u5c06\u6570\u636e\u4ece\u51fd\u6570\u8fd4\u56de\u7684\u5f62\u5f0f\uff08\u4f8b\u5982\u56fe\u50cf\u8def\u5f84\u5217\u8868\uff09\u8f6c\u6362\u4e3a\u53ef\u4ee5\u5728\u7528\u6237\u6d4f\u89c8\u5668\u4e2d\u663e\u793a\u7684\u5f62\u5f0f\uff08\u4f8b\u5982\u4ee5 base64 \u683c\u5f0f\u663e\u793a\u56fe\u50cf\u7684 `Gallery`\uff09\u3002\n\n\u60a8\u53ef\u4ee5\u4f7f\u7528\u6784\u5efa\u56fe\u50cf\u7ec4\u4ef6\u65f6\u7684\u53c2\u6570\u63a7\u5236*\u9884\u5904\u7406*\u3002\u4f8b\u5982\uff0c\u5982\u679c\u60a8\u4f7f\u7528\u4ee5\u4e0b\u53c2\u6570\u5b9e\u4f8b\u5316 `Image` \u7ec4\u4ef6\uff0c\u5b83\u5c06\u5c06\u56fe\u50cf\u8f6c\u6362\u4e3a `PIL` \u7c7b\u578b\uff0c\u5e76\u5c06\u5176\u91cd\u5851\u4e3a`(100, 100)`\uff0c\u800c\u4e0d\u7ba1\u63d0\u4ea4\u65f6\u7684\u539f\u59cb\u5927\u5c0f\u5982\u4f55\uff1a\n\n```py\nimg = gr.Image(shape=(100, 100), type=\"pil\")\n```\n\n\u76f8\u53cd\uff0c\u8fd9\u91cc\u6211\u4eec\u4fdd\u7559\u56fe\u50cf\u7684\u539f\u59cb\u5927\u5c0f\uff0c\u4f46\u5728\u5c06\u5176\u8f6c\u6362\u4e3a numpy \u6570\u7ec4\u4e4b\u524d\u53cd\u8f6c\u989c\u8272\uff1a\n\n```py\nimg = gr.Image(invert_colors=True, type=\"numpy\")\n```\n\n\u540e\u5904\u7406\u8981\u5bb9\u6613\u5f97\u591a\uff01Gradio \u81ea\u52a8\u8bc6\u522b\u8fd4\u56de\u6570\u636e\u7684\u683c\u5f0f\uff08\u4f8b\u5982 `Image` \u662f `numpy` \u6570\u7ec4\u8fd8\u662f `str` \u6587\u4ef6\u8def\u5f84\uff1f\uff09\uff0c\u5e76\u5c06\u5176\u540e\u5904\u7406\u4e3a\u53ef\u4ee5\u7531\u6d4f\u89c8\u5668\u663e\u793a\u7684\u683c\u5f0f\u3002\n\n\u8bf7\u67e5\u770b[\u6587\u6863](https://gradio.app/docs)\uff0c\u4e86\u89e3\u6bcf\u4e2a\u7ec4\u4ef6\u7684\u6240\u6709\u4e0e\u9884\u5904\u7406\u76f8\u5173\u7684\u53c2\u6570\u3002\n\n## \u6837\u5f0f (Styling)\n\nGradio \u4e3b\u9898\u662f\u81ea\u5b9a\u4e49\u5e94\u7528\u7a0b\u5e8f\u5916\u89c2\u548c\u611f\u89c9\u7684\u6700\u7b80\u5355\u65b9\u6cd5\u3002\u60a8\u53ef\u4ee5\u9009\u62e9\u591a\u79cd\u4e3b\u9898\u6216\u521b\u5efa\u81ea\u5df1\u7684\u4e3b\u9898\u3002\u8981\u8fd9\u6837\u505a\uff0c\u8bf7\u5c06 `theme=` \u53c2\u6570\u4f20\u9012\u7ed9 `Interface` \u6784\u9020\u51fd\u6570\u3002\u4f8b\u5982\uff1a\n\n```python\ndemo = gr.Interface(..., theme=gr.themes.Monochrome())\n```\n\nGradio \u5e26\u6709\u4e00\u7ec4\u9884\u5148\u6784\u5efa\u7684\u4e3b\u9898\uff0c\u60a8\u53ef\u4ee5\u4ece `gr.themes.*` \u52a0\u8f7d\u3002\u60a8\u53ef\u4ee5\u6269\u5c55\u8fd9\u4e9b\u4e3b\u9898\u6216\u4ece\u5934\u5f00\u59cb\u521b\u5efa\u81ea\u5df1\u7684\u4e3b\u9898 - \u6709\u5173\u66f4\u591a\u8be6\u7ec6\u4fe1\u606f\uff0c\u8bf7\u53c2\u9605[\u4e3b\u9898\u6307\u5357](https://gradio.app/theming-guide)\u3002\n\n\u8981\u589e\u52a0\u989d\u5916\u7684\u6837\u5f0f\u80fd\u529b\uff0c\u60a8\u53ef\u4ee5 with `css=` \u5173\u952e\u5b57\u5c06\u4efb\u4f55 CSS \u4f20\u9012\u7ed9\u60a8\u7684\u5e94\u7528\u7a0b\u5e8f\u3002\nGradio \u5e94\u7528\u7a0b\u5e8f\u7684\u57fa\u7c7b\u662f `gradio-container`\uff0c\u56e0\u6b64\u4ee5\u4e0b\u662f\u4e00\u4e2a\u66f4\u6539 Gradio \u5e94\u7528\u7a0b\u5e8f\u80cc\u666f\u989c\u8272\u7684\u793a\u4f8b\uff1a\n\n```python\nwith `gr.Interface(css=\".gradio-container {background-color: red}\") as demo:\n    ...\n```\n\n## \u961f\u5217 (Queuing)\n\n\u5982\u679c\u60a8\u7684\u5e94\u7528\u7a0b\u5e8f\u9884\u8ba1\u4f1a\u6709\u5927\u91cf\u6d41\u91cf\uff0c\u8bf7 with `queue()` \u65b9\u6cd5\u6765\u63a7\u5236\u5904\u7406\u901f\u7387\u3002\u8fd9\u5c06\u6392\u961f\u5904\u7406\u8c03\u7528\uff0c\u56e0\u6b64\u4e00\u6b21\u53ea\u5904\u7406\u4e00\u5b9a\u6570\u91cf\u7684\u8bf7\u6c42\u3002\u961f\u5217\u4f7f\u7528 Websockets\uff0c\u8fd8\u53ef\u4ee5\u9632\u6b62\u7f51\u7edc\u8d85\u65f6\uff0c\u56e0\u6b64\u5982\u679c\u60a8\u7684\u51fd\u6570\u7684\u63a8\u7406\u65f6\u95f4\u5f88\u957f\uff08> 1 \u5206\u949f\uff09\uff0c\u5e94\u4f7f\u7528\u961f\u5217\u3002\n\nwith `Interface`\uff1a\n\n```python\ndemo = gr.Interface(...).queue()\ndemo.launch()\n```\n\nwith `Blocks`\uff1a\n\n```python\nwith gr.Blocks() as demo\uff1a\n    #...\ndemo.queue()\ndemo.launch()\n```\n\n\u60a8\u53ef\u4ee5\u901a\u8fc7\u4ee5\u4e0b\u65b9\u5f0f\u63a7\u5236\u4e00\u6b21\u5904\u7406\u7684\u8bf7\u6c42\u6570\u91cf\uff1a\n\n```python\ndemo.queue(concurrency_count=3)\n```\n\n\u67e5\u770b\u6709\u5173\u914d\u7f6e\u5176\u4ed6\u961f\u5217\u53c2\u6570\u7684[\u961f\u5217\u6587\u6863](/docs/#queue)\u3002\n\n\u5728 Blocks \u4e2d\u6307\u5b9a\u4ec5\u5bf9\u67d0\u4e9b\u51fd\u6570\u8fdb\u884c\u6392\u961f\uff1a\n\n```python\nwith gr.Blocks() as demo2\uff1a\n    num1 = gr.Number()\n    num2 = gr.Number()\n    output = gr.Number()\n    gr.Button(\"Add\").click(\n        lambda a, b: a + b, [num1, num2], output)\n    gr.Button(\"Multiply\").click(\n        lambda a, b: a * b, [num1, num2], output, queue=True)\ndemo2.launch()\n```\n\n## \u8fed\u4ee3\u8f93\u51fa (Iterative Outputs)\n\n\u5728\u67d0\u4e9b\u60c5\u51b5\u4e0b\uff0c\u60a8\u53ef\u80fd\u9700\u8981\u4f20\u8f93\u4e00\u7cfb\u5217\u8f93\u51fa\u800c\u4e0d\u662f\u4e00\u6b21\u663e\u793a\u5355\u4e2a\u8f93\u51fa\u3002\u4f8b\u5982\uff0c\u60a8\u53ef\u80fd\u6709\u4e00\u4e2a\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5e0c\u671b\u663e\u793a\u751f\u6210\u7684\u6bcf\u4e2a\u6b65\u9aa4\u7684\u56fe\u50cf\uff0c\u76f4\u5230\u6700\u7ec8\u56fe\u50cf\u3002\u6216\u8005\u60a8\u53ef\u80fd\u6709\u4e00\u4e2a\u804a\u5929\u673a\u5668\u4eba\uff0c\u5b83\u9010\u5b57\u9010\u53e5\u5730\u6d41\u5f0f\u4f20\u8f93\u54cd\u5e94\uff0c\u800c\u4e0d\u662f\u4e00\u6b21\u8fd4\u56de\u5168\u90e8\u54cd\u5e94\u3002\n\n\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u60a8\u53ef\u4ee5\u5c06**\u751f\u6210\u5668**\u51fd\u6570\u63d0\u4f9b\u7ed9 Gradio\uff0c\u800c\u4e0d\u662f\u5e38\u89c4\u51fd\u6570\u3002\u5728 Python \u4e2d\u521b\u5efa\u751f\u6210\u5668\u975e\u5e38\u7b80\u5355\uff1a\u51fd\u6570\u4e0d\u5e94\u8be5\u6709\u4e00\u4e2a\u5355\u72ec\u7684 `return` \u503c\uff0c\u800c\u662f\u5e94\u8be5 with `yield` \u8fde\u7eed\u8fd4\u56de\u4e00\u7cfb\u5217\u503c\u3002\u901a\u5e38\uff0c`yield` \u8bed\u53e5\u653e\u7f6e\u5728\u67d0\u79cd\u5faa\u73af\u4e2d\u3002\u4e0b\u9762\u662f\u4e00\u4e2a\u7b80\u5355\u793a\u4f8b\uff0c\u751f\u6210\u5668\u53ea\u662f\u7b80\u5355\u8ba1\u6570\u5230\u7ed9\u5b9a\u6570\u5b57\uff1a\n\n```python\ndef my_generator(x):\n    for i in range(x):\n        yield i\n```\n\n\u60a8\u4ee5\u4e0e\u5e38\u89c4\u51fd\u6570\u76f8\u540c\u7684\u65b9\u5f0f\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio\u3002\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\uff08\u865a\u62df\u7684\uff09\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5b83\u5728\u8f93\u51fa\u56fe\u50cf\u4e4b\u524d\u751f\u6210\u6570\u4e2a\u6b65\u9aa4\u7684\u566a\u97f3\uff1a\n\n$code_fake_diffusion\n$demo_fake_diffusion\n\n\u8bf7\u6ce8\u610f\uff0c\u6211\u4eec\u5728\u8fed\u4ee3\u5668\u4e2d\u6dfb\u52a0\u4e86 `time.sleep(1)`\uff0c\u4ee5\u521b\u5efa\u6b65\u9aa4\u4e4b\u95f4\u7684\u4eba\u5de5\u6682\u505c\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u89c2\u5bdf\u8fed\u4ee3\u5668\u7684\u6b65\u9aa4\uff08\u5728\u771f\u5b9e\u7684\u56fe\u50cf\u751f\u6210\u6a21\u578b\u4e2d\uff0c\u8fd9"
        }
    },
    {
        "sample_idx": 113,
        "question": "What is the name of the library used to create various maps in this guide?",
        "answer": "Plotly",
        "rag_answer": "The library used to create interactive interfaces in this guide is Gradio, not specifically for creating maps, but for demonstrating models and creating interactive demos. Additionally, the Datasets library is used for fine-tuning the LayoutLMv3 model.",
        "rag_score": 2,
        "rag_feedback": "The system's response is mostly incorrect, inaccurate, and/or not factual. The question asks about the library used to create various maps, but the system's response talks about Gradio, which is used for creating interactive interfaces, and Datasets library, which is used for fine-tuning the LayoutLMv3 model. The correct answer is Plotly, which is not mentioned in the system's response.",
        "rag_context": {
            "kg_context": "-----Entities-----\n    ```csv\n    id,\tentity,\ttype,\tdescription,\trankcreated_at\n1,\tGradio,organization,Gradio is a platform that supports state in Blocks, providing features such as global state and session state.<SEP>Gradio is an interface that provides various features for demonstrating models, including adding example inputs, custom error messages, descriptive content, flagging, and more.<SEP>Gradio is an organization that provides a platform for building and deploying machine learning models.<SEP>Gradio is an organization that provides a platform for creating and deploying machine learning models.<SEP>Gradio is an organization that provides a demo for blocks_random_slider, and its library is used to create interactive interfaces.,36,2025-03-24 13:16:48\n2,\tgr,organization,gr is an organization that provides the Gradio library used in the demo.,1,2025-03-24 13:16:48\n3,\tDatasets library,technology,Datasets library is a tool used for fine-tuning the LayoutLMv3 model.,1,2025-03-24 13:16:48\n4,\tLayoutLMv3,technology,LayoutLMv3 is a model used for token classification and form understanding tasks.,11,2025-03-24 13:16:48\n5,\tDataset Preview,organization,Dataset Preview is a function that provides examples of dataset structures.,1,2025-03-24 13:16:48\n6,\tMetric Card,organization,Metric Card is a resource that explains how to use a dedicated evaluation function.,1,2025-03-24 13:16:48\n7,\tDatasets library,technology,Datasets library is a tool used for fine-tuning the LayoutLMv3 model.,1,UNKNOWN\n8,\tgr,organization,gr is an organization that provides the Gradio library used in the demo.,1,UNKNOWN\n9,\t run_funsd_cord.py,event,run_funsd_cord.py is a script used for fine-tuning the LayoutLMv3 model.,0,UNKNOWN\n    ```\n    -----Relationships-----\n    ```csv\n    id,\tsource,\ttarget,\tdescription,\tkeywords,\tweight,\trank,\tcreated_at\n1,\tGradio,gr,gr is the organization that provides the Gradio library used in the demo.,organization, organization,9.0,37,2025-03-24 13:18:47\n2,\tDatasets library,LayoutLMv3,Datasets library is a tool used for fine-tuning the LayoutLMv3 model.,tool, model fine-tuning,7.0,12,2025-03-24 13:19:57\n3,\tDataset Preview,Metric Card,Dataset Preview and Metric Card are related resources that provide information about dataset structures and evaluation functions.,information resources, dataset structure,16.0,2,2025-03-24 13:16:48\n4,\tGradio,gr,gr is the organization that provides the Gradio library used in the demo.,organization, organization,9.0,37,UNKNOWN\n5,\tDatasets library,LayoutLMv3,Datasets library is a tool used for fine-tuning the LayoutLMv3 model.,tool, model fine-tuning,7.0,12,UNKNOWN\n    ```\n    -----Sources-----\n    ```csv\n    id,\tcontent\n1,\tGradio Demo: blocks_random_slider\n\n\n```\n!pip install -q gradio \n```\n\n\n```\n\nimport gradio as gr\n\n\ndef func(slider_1, slider_2):\n    return slider_1 * 5 + slider_2\n\n\nwith gr.Blocks() as demo:\n    slider = gr.Slider(minimum=-10.2, maximum=15, label=\"Random Slider (Static)\", randomize=True)\n    slider_1 = gr.Slider(minimum=100, maximum=200, label=\"Random Slider (Input 1)\", randomize=True)\n    slider_2 = gr.Slider(minimum=10, maximum=23.2, label=\"Random Slider (Input 2)\", randomize=True)\n    slider_3 = gr.Slider(value=3, label=\"Non random slider\")\n    btn = gr.Button(\"Run\")\n    btn.click(func, inputs=[slider_1, slider_2], outputs=gr.Number())\n\nif __name__ == \"__main__\":\n    demo.launch()\n\n```\n2,\t!---\nCopyright 2022 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n-->\n\n# Token classification with LayoutLMv3 (PyTorch version)\n\nThis directory contains a script, `run_funsd_cord.py`, that can be used to fine-tune (or evaluate) LayoutLMv3 on form understanding datasets, such as [FUNSD](https://guillaumejaume.github.io/FUNSD/) and [CORD](https://github.com/clovaai/cord).\n\nThe script `run_funsd_cord.py` leverages the \ud83e\udd17 Datasets library and the Trainer API. You can easily customize it to your needs.\n\n## Fine-tuning on FUNSD\n\nFine-tuning LayoutLMv3 for token classification on [FUNSD](https://guillaumejaume.github.io/FUNSD/) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name funsd \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 1e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-funsd\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd. By specifying the `push_to_hub` flag, the model gets uploaded automatically to the hub (regularly), together with a model card, which includes metrics such as precision, recall and F1. Note that you can easily update the model card, as it's just a README file of the respective repo on the hub.\n\nThere's also the \"Training metrics\" [tab](https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd/tensorboard), which shows Tensorboard logs over the course of training. Pretty neat, huh?\n\n## Fine-tuning on CORD\n\nFine-tuning LayoutLMv3 for token classification on [CORD](https://github.com/clovaai/cord) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name cord \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 5e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-cord\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-cord. Note that a model card gets generated automatically in case you specify the `push_to_hub` flag.\n3,\t=predictions, references=references)\n>>> results\n{'exact_match': 100.0, 'f1': 100.0}\n```\n\nYou can find examples of dataset structures by consulting the \"Dataset Preview\" function or the dataset card for a given dataset, and you can see how to use its dedicated evaluation function based on the metric card.\n    ```",
            "vector_context": "[Created at: 2025-03-24 13:18:21]\nGradio Demo: blocks_random_slider\n\n\n```\n!pip install -q gradio \n```\n\n\n```\n\nimport gradio as gr\n\n\ndef func(slider_1, slider_2):\n    return slider_1 * 5 + slider_2\n\n\nwith gr.Blocks() as demo:\n    slider = gr.Slider(minimum=-10.2, maximum=15, label=\"Random Slider (Static)\", randomize=True)\n    slider_1 = gr.Slider(minimum=100, maximum=200, label=\"Random Slider (Input 1)\", randomize=True)\n    slider_2 = gr.Slider(minimum=10, maximum=23.2, label=\"Random Slider (Input 2)\", randomize=True)\n    slider_3 = gr.Slider(value=3, label=\"Non random slider\")\n    btn = gr.Button(\"Run\")\n    btn.click(func, inputs=[slider_1, slider_2], outputs=gr.Number())\n\nif __name__ == \"__main__\":\n    demo.launch()\n\n```\n--New Chunk--\n[Created at: 2025-03-24 13:19:17]\n!---\nCopyright 2022 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n-->\n\n# Token classification with LayoutLMv3 (PyTorch version)\n\nThis directory contains a script, `run_funsd_cord.py`, that can be used to fine-tune (or evaluate) LayoutLMv3 on form understanding datasets, such as [FUNSD](https://guillaumejaume.github.io/FUNSD/) and [CORD](https://github.com/clovaai/cord).\n\nThe script `run_funsd_cord.py` leverages the \ud83e\udd17 Datasets library and the Trainer API. You can easily customize it to your needs.\n\n## Fine-tuning on FUNSD\n\nFine-tuning LayoutLMv3 for token classification on [FUNSD](https://guillaumejaume.github.io/FUNSD/) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name funsd \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 1e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-funsd\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd. By specifying the `push_to_hub` flag, the model gets uploaded automatically to the hub (regularly), together with a model card, which includes metrics such as precision, recall and F1. Note that you can easily update the model card, as it's just a README file of the respective repo on the hub.\n\nThere's also the \"Training metrics\" [tab](https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd/tensorboard), which shows Tensorboard logs over the course of training. Pretty neat, huh?\n\n## Fine-tuning on CORD\n\nFine-tuning LayoutLMv3 for token classification on [CORD](https://github.com/clovaai/cord) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name cord \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 5e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-cord\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-cord. Note that a model card gets generated automatically in case you specify the `push_to_hub` flag.\n--New Chunk--\n[Created at: 2025-03-24 13:16:13]\n=predictions, references=references)\n>>> results\n{'exact_match': 100.0, 'f1': 100.0}\n```\n\nYou can find examples of dataset structures by consulting the \"Dataset Preview\" function or the dataset card for a given dataset, and you can see how to use its dedicated evaluation function based on the metric card."
        }
    },
    {
        "sample_idx": 114,
        "question": "What is the name of the dataset used in this guide?",
        "answer": "New York City Airbnb Open Data",
        "rag_answer": "The dataset used in this guide is called FUNSD (Form Understanding in Noisy Scanned Documents). It is a form understanding dataset used for fine-tuning the LayoutLMv3 model.\n\nReferences:\n[KG] FUNSD is a form understanding dataset used for fine-tuning the LayoutLMv3 model.\n[DC] This directory contains a script, `run_funsd_cord.py`, that can be used to fine-tune (or evaluate) LayoutLMv3 on form understanding datasets, such as [FUNSD](https://guillaumejaume.github.io/FUNSD/) and [CORD](https://github.com/clovaai/cord).",
        "rag_score": 1,
        "rag_feedback": "The system's response is completely incorrect, inaccurate, and not factual. The expected answer is 'New York City Airbnb Open Data', but the system's response is about FUNSD (Form Understanding in Noisy Scanned Documents) and LayoutLMv3 model, which is unrelated to the question.",
        "rag_context": {
            "kg_context": "-----Entities-----\n    ```csv\n    id,\tentity,\ttype,\tdescription,\trankcreated_at\n1,\tFUNSD,geo,FUNSD is a form understanding dataset used for fine-tuning LayoutLMv3.,1,2025-03-24 13:16:48\n2,\tLayoutLMv3,technology,LayoutLMv3 is a model used for token classification and form understanding tasks.,11,2025-03-24 13:16:48\n3,\tDatasets library,technology,Datasets library is a tool used for fine-tuning the LayoutLMv3 model.,1,2025-03-24 13:16:48\n4,\tDataset Preview,organization,Dataset Preview is a function that provides examples of dataset structures.,1,2025-03-24 13:16:48\n5,\tMetric Card,organization,Metric Card is a resource that explains how to use a dedicated evaluation function.,1,2025-03-24 13:16:48\n6,\tDatasets library,technology,Datasets library is a tool used for fine-tuning the LayoutLMv3 model.,1,UNKNOWN\n7,\tDataset Preview,organization,Dataset Preview is a function that provides examples of dataset structures.,1,UNKNOWN\n8,\tReferences,category,References are sources of information used to support predictions.,1,UNKNOWN\n    ```\n    -----Relationships-----\n    ```csv\n    id,\tsource,\ttarget,\tdescription,\tkeywords,\tweight,\trank,\tcreated_at\n1,\tFUNSD,LayoutLMv3,FUNSD is a dataset used for fine-tuning the LayoutLMv3 model.,dataset, model training,14.0,12,2025-03-24 13:19:57\n2,\tDatasets library,LayoutLMv3,Datasets library is a tool used for fine-tuning the LayoutLMv3 model.,tool, model fine-tuning,7.0,12,2025-03-24 13:19:57\n3,\tDataset Preview,Metric Card,Dataset Preview and Metric Card are related resources that provide information about dataset structures and evaluation functions.,information resources, dataset structure,16.0,2,2025-03-24 13:16:48\n4,\tDatasets library,LayoutLMv3,Datasets library is a tool used for fine-tuning the LayoutLMv3 model.,tool, model fine-tuning,7.0,12,UNKNOWN\n5,\tPredictions,References,References are used to support predictions.,information sources, prediction support,14.0,3,UNKNOWN\n6,\tDataset Preview,Metric Card,Dataset Preview and Metric Card are related resources that provide information about dataset structures and evaluation functions.,information resources, dataset structure,16.0,2,UNKNOWN\n    ```\n    -----Sources-----\n    ```csv\n    id,\tcontent\n1,\t!---\nCopyright 2022 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n-->\n\n# Token classification with LayoutLMv3 (PyTorch version)\n\nThis directory contains a script, `run_funsd_cord.py`, that can be used to fine-tune (or evaluate) LayoutLMv3 on form understanding datasets, such as [FUNSD](https://guillaumejaume.github.io/FUNSD/) and [CORD](https://github.com/clovaai/cord).\n\nThe script `run_funsd_cord.py` leverages the \ud83e\udd17 Datasets library and the Trainer API. You can easily customize it to your needs.\n\n## Fine-tuning on FUNSD\n\nFine-tuning LayoutLMv3 for token classification on [FUNSD](https://guillaumejaume.github.io/FUNSD/) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name funsd \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 1e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-funsd\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd. By specifying the `push_to_hub` flag, the model gets uploaded automatically to the hub (regularly), together with a model card, which includes metrics such as precision, recall and F1. Note that you can easily update the model card, as it's just a README file of the respective repo on the hub.\n\nThere's also the \"Training metrics\" [tab](https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd/tensorboard), which shows Tensorboard logs over the course of training. Pretty neat, huh?\n\n## Fine-tuning on CORD\n\nFine-tuning LayoutLMv3 for token classification on [CORD](https://github.com/clovaai/cord) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name cord \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 5e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-cord\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-cord. Note that a model card gets generated automatically in case you specify the `push_to_hub` flag.\n2,\t=predictions, references=references)\n>>> results\n{'exact_match': 100.0, 'f1': 100.0}\n```\n\nYou can find examples of dataset structures by consulting the \"Dataset Preview\" function or the dataset card for a given dataset, and you can see how to use its dedicated evaluation function based on the metric card.\n    ```",
            "vector_context": "[Created at: 2025-03-24 13:16:13]\n=predictions, references=references)\n>>> results\n{'exact_match': 100.0, 'f1': 100.0}\n```\n\nYou can find examples of dataset structures by consulting the \"Dataset Preview\" function or the dataset card for a given dataset, and you can see how to use its dedicated evaluation function based on the metric card.\n--New Chunk--\n[Created at: 2025-03-24 13:19:17]\n!---\nCopyright 2022 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n-->\n\n# Token classification with LayoutLMv3 (PyTorch version)\n\nThis directory contains a script, `run_funsd_cord.py`, that can be used to fine-tune (or evaluate) LayoutLMv3 on form understanding datasets, such as [FUNSD](https://guillaumejaume.github.io/FUNSD/) and [CORD](https://github.com/clovaai/cord).\n\nThe script `run_funsd_cord.py` leverages the \ud83e\udd17 Datasets library and the Trainer API. You can easily customize it to your needs.\n\n## Fine-tuning on FUNSD\n\nFine-tuning LayoutLMv3 for token classification on [FUNSD](https://guillaumejaume.github.io/FUNSD/) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name funsd \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 1e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-funsd\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd. By specifying the `push_to_hub` flag, the model gets uploaded automatically to the hub (regularly), together with a model card, which includes metrics such as precision, recall and F1. Note that you can easily update the model card, as it's just a README file of the respective repo on the hub.\n\nThere's also the \"Training metrics\" [tab](https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd/tensorboard), which shows Tensorboard logs over the course of training. Pretty neat, huh?\n\n## Fine-tuning on CORD\n\nFine-tuning LayoutLMv3 for token classification on [CORD](https://github.com/clovaai/cord) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name cord \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 5e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-cord\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-cord. Note that a model card gets generated automatically in case you specify the `push_to_hub` flag.\n--New Chunk--\n[Created at: 2025-03-24 13:17:32]\n!--Copyright 2023 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\nthe License. You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under the License is distributed on\nan \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n\n\u26a0\ufe0f Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be\nrendered properly in your Markdown viewer.\n\n-->\n\n# Training on TPU with TensorFlow\n\n<Tip>\n\nIf you don't need long explanations and just want TPU code samples to get started with, check out [our TPU example notebook!](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb)\n\n</Tip>\n\n### What is a TPU?\n\nA TPU is a **Tensor Processing Unit.** They are hardware designed by Google, which are used to greatly speed up the tensor computations within neural networks, much like GPUs. They can be used for both network training and inference. They are generally accessed through Google\u2019s cloud services, but small TPUs can also be accessed directly for free through Google Colab and Kaggle Kernels.\n\nBecause [all TensorFlow models in \ud83e\udd17 Transformers are Keras models](https://huggingface.co/blog/tensorflow-philosophy), most of the methods in this document are generally applicable to TPU training for any Keras model! However, there are a few points that are specific to the HuggingFace ecosystem (hug-o-system?) of Transformers and Datasets, and we\u2019ll make sure to flag them up when we get to them.\n\n### What kinds of TPU are available?\n\nNew users are often very confused by the range of TPUs, and the different ways to access them. The first key distinction to understand is the difference between **TPU Nodes** and **TPU VMs.**\n\nWhen you use a **TPU Node**, you are effectively indirectly accessing a remote TPU. You will need a separate VM, which will initialize your network and data pipeline and then forward them to the remote node. When you use a TPU on Google Colab, you are accessing it in the **TPU Node** style.\n\nUsing TPU Nodes can have some quite unexpected behaviour for people who aren\u2019t used to them! In particular, because the TPU is located on a physically different system to the machine you\u2019re running your Python code on, your data cannot be local to your machine - any data pipeline that loads from your machine\u2019s internal storage will totally fail! Instead, data must be stored in Google Cloud Storage where your data pipeline can still access it, even when the pipeline is running on the remote TPU node.\n\n<Tip>\n\nIf you can fit all your data in memory as `np.ndarray` or `tf.Tensor`, then you can `fit()` on that data even when using Colab or a TPU Node, without needing to upload it to Google Cloud Storage.\n\n</Tip>\n\n<Tip>\n\n**\ud83e\udd17Specific Hugging Face Tip\ud83e\udd17:** The methods `Dataset.to_tf_dataset()` and its higher-level wrapper `model.prepare_tf_dataset()` , which you will see throughout our TF code examples, will both fail on a TPU Node. The reason for this is that even though they create a `tf.data.Dataset` it is not a \u201cpure\u201d `tf.data` pipeline and uses `tf.numpy_function` or `Dataset.from_generator()` to stream data from the underlying HuggingFace `Dataset`. This HuggingFace `Dataset` is backed by data that is on a local disc and which the remote TPU Node will not be able to read.\n\n</Tip>\n\nThe second way to access a TPU is via a **TPU VM.** When using a TPU VM, you connect directly to the machine that the TPU is attached to, much like training on a GPU VM. TPU VMs are generally easier to work with, particularly when it comes to your data pipeline. All of the above warnings do not apply to TPU VMs!\n\nThis is an opinionated document, so here\u2019s our opinion: **Avoid using TPU Node if possible.** It is more confusing and more difficult to debug than TPU VMs. It is also likely to be unsupported in future - Google\u2019s latest TPU, TPUv4, can only be accessed as a TPU VM, which suggests that TPU Nodes are increasingly going to become a \u201clegacy\u201d access method. However, we understand that the only free TPU access is on Colab and Kaggle Kernels, which uses TPU Node - so we\u2019ll try to explain how to handle it if you have to! Check the [TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) for code samples that explain this in more detail.\n\n### What sizes of TPU are available?\n\nA single TPU (a v2-8/v3-8/v4-8) runs 8 replicas. TPUs exist in **pods** that can run hundreds or thousands of replicas simultaneously. When you use more than a single TPU but less than a whole pod (for example, a v3-32), your TPU fleet is referred to as a **pod slice.**\n\nWhen you access a free TPU via Colab, you generally get a single v2-8 TPU.\n\n### I keep hearing about this XLA thing. What\u2019s XLA, and how does it relate to TPUs?\n\nXLA is an optimizing compiler, used by both TensorFlow and JAX. In JAX it is the only compiler, whereas in TensorFlow it is optional"
        }
    },
    {
        "sample_idx": 115,
        "question": "Where is the dataset hosted?",
        "answer": "Kaggle",
        "rag_answer": "The dataset is hosted on Google Cloud Storage. This information is inferred from the text in Document Chunk 3, which mentions that \"data must be stored in Google Cloud Storage where your data pipeline can still access it, even when the pipeline is running on the remote TPU node.\"",
        "rag_score": 2,
        "rag_feedback": "The system's response is mostly incorrect, inaccurate, and/or not factual. The expected answer is 'Kaggle', but the system's response is a long text that does not mention Kaggle at all. The response seems to be related to a different topic, discussing TPUs, Google Cloud Storage, and Hugging Face.",
        "rag_context": {
            "kg_context": "-----Entities-----\n    ```csv\n    id,\tentity,\ttype,\tdescription,\trankcreated_at\n1,\tGradio,organization,Gradio is a platform that supports state in Blocks, providing features such as global state and session state.<SEP>Gradio is an interface that provides various features for demonstrating models, including adding example inputs, custom error messages, descriptive content, flagging, and more.<SEP>Gradio is an organization that provides a platform for building and deploying machine learning models.<SEP>Gradio is an organization that provides a platform for creating and deploying machine learning models.<SEP>Gradio is an organization that provides a demo for blocks_random_slider, and its library is used to create interactive interfaces.,36,2025-03-24 13:16:13\n2,\tState,category,State is a concept in Gradio that refers to the storage of data, including global state and session state.,2,2025-03-24 13:16:13\n3,\tInterface,category,Interface is a category of components in Gradio that enables the creation of custom interfaces.<SEP>Interface is a component of Gradio that allows users to interact with machine learning models.<SEP>Interface is a concept in Gradio that refers to a user interface for demonstrating models.<SEP>Interface is a category related to Gradio, where state works similarly to Blocks.,3,2025-03-24 13:16:13\n4,\tAWS,organization,AWS is a cloud provider that is currently available for deploying endpoints, with regions us-east-1 and eu-west-1.,3,2025-03-24 13:16:13\n5,\teu-west-1,geo,eu-west-1 is a region in Europe where endpoints can be deployed.,1,2025-03-24 13:16:13\n6,\tCloud Services,category,Cloud Services are online services provided by companies such as Google, used for data storage and processing.,0,UNKNOWN\n7,\tDatasets library,technology,Datasets library is a tool used for fine-tuning the LayoutLMv3 model.,1,UNKNOWN\n8,\tAWS,organization,AWS is a cloud provider that is currently available for deploying endpoints, with regions us-east-1 and eu-west-1.,3,UNKNOWN\n    ```\n    -----Relationships-----\n    ```csv\n    id,\tsource,\ttarget,\tdescription,\tkeywords,\tweight,\trank,\tcreated_at\n1,\tGradio,State,Gradio supports state in Blocks, including global state and session state.,platform feature, data storage,18.0,38,2025-03-24 13:20:24\n2,\tInterface,State,State works similarly in Interface and Blocks.,similar concept, data storage,14.0,5,2025-03-24 13:20:24\n3,\tAWS,eu-west-1,AWS provides the eu-west-1 region for deploying endpoints.,region, cloud provider,14.0,4,2025-03-24 13:16:13\n4,\tDatasets library,LayoutLMv3,Datasets library is a tool used for fine-tuning the LayoutLMv3 model.,tool, model fine-tuning,7.0,12,UNKNOWN\n5,\tAWS,Hugging Face,Hugging Face uses AWS as a cloud provider for deploying endpoints.,cloud provider, partnership,16.0,11,UNKNOWN\n6,\tAWS,us-east-1,AWS provides the us-east-1 region for deploying endpoints.,region, cloud provider,14.0,4,UNKNOWN\n7,\tAWS,eu-west-1,AWS provides the eu-west-1 region for deploying endpoints.,region, cloud provider,14.0,4,UNKNOWN\n    ```\n    -----Sources-----\n    ```csv\n    id,\tcontent\n1,\tState in Blocks\n\nWe covered [State in Interfaces](https://gradio.app/interface-state), this guide takes a look at state in Blocks, which works mostly the same.\n\n## Global State\n\nGlobal state in Blocks works the same as in Interface. Any variable created outside a function call is a reference shared between all users.\n\n## Session State\n\nGradio supports session **state**, where data persists across multiple submits within a page session, in Blocks apps as well. To reiterate, session data is _not_ shared between different users of your model. To store data in a session state, you need to do three things:\n\n1. Create a `gr.State()` object. If there is a default value to this stateful object, pass that into the constructor.\n2. In the event listener, put the `State` object as an input and output.\n3. In the event listener function, add the variable to the input parameters and the return value.\n\nLet's take a look at a game of hangman.\n\n$code_hangman\n$demo_hangman\n\nLet's see how we do each of the 3 steps listed above in this game:\n\n1. We store the used letters in `used_letters_var`. In the constructor of `State`, we set the initial value of this to `[]`, an empty list.\n2. In `btn.click()`, we have a reference to `used_letters_var` in both the inputs and outputs.\n3. In `guess_letter`, we pass the value of this `State` to `used_letters`, and then return an updated value of this `State` in the return statement.\n\nWith more complex apps, you will likely have many State variables storing session state in a single Blocks app.\n\nLearn more about `State` in the [docs](https://gradio.app/docs#state).\n2,\tCreate an Endpoint\n\nAfter your first login, you will be directed to the [Endpoint creation page](https://ui.endpoints.huggingface.co/new). As an example, this guide will go through the steps to deploy [distilbert-base-uncased-finetuned-sst-2-english](https://huggingface.co/distilbert-base-uncased-finetuned-sst-2-english) for text classification. \n\n## 1. Enter the Hugging Face Repository ID and your desired endpoint name:\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_repository.png\" alt=\"select repository\" />\n\n## 2. Select your Cloud Provider and region. Initially, only AWS will be available as a Cloud Provider with the `us-east-1` and `eu-west-1` regions. We will add Azure soon, and if you need to test Endpoints with other Cloud Providers or regions, please let us know.\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_region.png\" alt=\"select region\" />\n\n## 3. Define the [Security Level](security) for the Endpoint:\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_security.png\" alt=\"define security\" />\n\n## 4. Create your Endpoint by clicking **Create Endpoint**. By default, your Endpoint is created with a medium CPU (2 x 4GB vCPUs with Intel Xeon Ice Lake) The cost estimate assumes the Endpoint will be up for an entire month, and does not take autoscaling into account.\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_create_cost.png\" alt=\"create endpoint\" />\n\n## 5. Wait for the Endpoint to build, initialize and run which can take between 1 to 5 minutes.\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/overview.png\" alt=\"overview\" />\n\n## 6. Test your Endpoint in the overview with the Inference widget \ud83c\udfc1 \ud83c\udf89!\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_inference.png\" alt=\"run inference\" />\n3,\t!--Copyright 2023 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\nthe License. You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under the License is distributed on\nan \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n\n\u26a0\ufe0f Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be\nrendered properly in your Markdown viewer.\n\n-->\n\n# Training on TPU with TensorFlow\n\n<Tip>\n\nIf you don't need long explanations and just want TPU code samples to get started with, check out [our TPU example notebook!](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb)\n\n</Tip>\n\n### What is a TPU?\n\nA TPU is a **Tensor Processing Unit.** They are hardware designed by Google, which are used to greatly speed up the tensor computations within neural networks, much like GPUs. They can be used for both network training and inference. They are generally accessed through Google\u2019s cloud services, but small TPUs can also be accessed directly for free through Google Colab and Kaggle Kernels.\n\nBecause [all TensorFlow models in \ud83e\udd17 Transformers are Keras models](https://huggingface.co/blog/tensorflow-philosophy), most of the methods in this document are generally applicable to TPU training for any Keras model! However, there are a few points that are specific to the HuggingFace ecosystem (hug-o-system?) of Transformers and Datasets, and we\u2019ll make sure to flag them up when we get to them.\n\n### What kinds of TPU are available?\n\nNew users are often very confused by the range of TPUs, and the different ways to access them. The first key distinction to understand is the difference between **TPU Nodes** and **TPU VMs.**\n\nWhen you use a **TPU Node**, you are effectively indirectly accessing a remote TPU. You will need a separate VM, which will initialize your network and data pipeline and then forward them to the remote node. When you use a TPU on Google Colab, you are accessing it in the **TPU Node** style.\n\nUsing TPU Nodes can have some quite unexpected behaviour for people who aren\u2019t used to them! In particular, because the TPU is located on a physically different system to the machine you\u2019re running your Python code on, your data cannot be local to your machine - any data pipeline that loads from your machine\u2019s internal storage will totally fail! Instead, data must be stored in Google Cloud Storage where your data pipeline can still access it, even when the pipeline is running on the remote TPU node.\n\n<Tip>\n\nIf you can fit all your data in memory as `np.ndarray` or `tf.Tensor`, then you can `fit()` on that data even when using Colab or a TPU Node, without needing to upload it to Google Cloud Storage.\n\n</Tip>\n\n<Tip>\n\n**\ud83e\udd17Specific Hugging Face Tip\ud83e\udd17:** The methods `Dataset.to_tf_dataset()` and its higher-level wrapper `model.prepare_tf_dataset()` , which you will see throughout our TF code examples, will both fail on a TPU Node. The reason for this is that even though they create a `tf.data.Dataset` it is not a \u201cpure\u201d `tf.data` pipeline and uses `tf.numpy_function` or `Dataset.from_generator()` to stream data from the underlying HuggingFace `Dataset`. This HuggingFace `Dataset` is backed by data that is on a local disc and which the remote TPU Node will not be able to read.\n\n</Tip>\n\nThe second way to access a TPU is via a **TPU VM.** When using a TPU VM, you connect directly to the machine that the TPU is attached to, much like training on a GPU VM. TPU VMs are generally easier to work with, particularly when it comes to your data pipeline. All of the above warnings do not apply to TPU VMs!\n\nThis is an opinionated document, so here\u2019s our opinion: **Avoid using TPU Node if possible.** It is more confusing and more difficult to debug than TPU VMs. It is also likely to be unsupported in future - Google\u2019s latest TPU, TPUv4, can only be accessed as a TPU VM, which suggests that TPU Nodes are increasingly going to become a \u201clegacy\u201d access method. However, we understand that the only free TPU access is on Colab and Kaggle Kernels, which uses TPU Node - so we\u2019ll try to explain how to handle it if you have to! Check the [TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) for code samples that explain this in more detail.\n\n### What sizes of TPU are available?\n\nA single TPU (a v2-8/v3-8/v4-8) runs 8 replicas. TPUs exist in **pods** that can run hundreds or thousands of replicas simultaneously. When you use more than a single TPU but less than a whole pod (for example, a v3-32), your TPU fleet is referred to as a **pod slice.**\n\nWhen you access a free TPU via Colab, you generally get a single v2-8 TPU.\n\n### I keep hearing about this XLA thing. What\u2019s XLA, and how does it relate to TPUs?\n\nXLA is an optimizing compiler, used by both TensorFlow and JAX. In JAX it is the only compiler, whereas in TensorFlow it is optional\n4,\t!---\nCopyright 2022 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n-->\n\n# Token classification with LayoutLMv3 (PyTorch version)\n\nThis directory contains a script, `run_funsd_cord.py`, that can be used to fine-tune (or evaluate) LayoutLMv3 on form understanding datasets, such as [FUNSD](https://guillaumejaume.github.io/FUNSD/) and [CORD](https://github.com/clovaai/cord).\n\nThe script `run_funsd_cord.py` leverages the \ud83e\udd17 Datasets library and the Trainer API. You can easily customize it to your needs.\n\n## Fine-tuning on FUNSD\n\nFine-tuning LayoutLMv3 for token classification on [FUNSD](https://guillaumejaume.github.io/FUNSD/) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name funsd \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 1e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-funsd\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd. By specifying the `push_to_hub` flag, the model gets uploaded automatically to the hub (regularly), together with a model card, which includes metrics such as precision, recall and F1. Note that you can easily update the model card, as it's just a README file of the respective repo on the hub.\n\nThere's also the \"Training metrics\" [tab](https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd/tensorboard), which shows Tensorboard logs over the course of training. Pretty neat, huh?\n\n## Fine-tuning on CORD\n\nFine-tuning LayoutLMv3 for token classification on [CORD](https://github.com/clovaai/cord) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name cord \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 5e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-cord\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-cord. Note that a model card gets generated automatically in case you specify the `push_to_hub` flag.\n    ```",
            "vector_context": "[Created at: 2025-03-24 13:16:13]\n=predictions, references=references)\n>>> results\n{'exact_match': 100.0, 'f1': 100.0}\n```\n\nYou can find examples of dataset structures by consulting the \"Dataset Preview\" function or the dataset card for a given dataset, and you can see how to use its dedicated evaluation function based on the metric card.\n--New Chunk--\n[Created at: 2025-03-24 13:15:42]\nCreate an Endpoint\n\nAfter your first login, you will be directed to the [Endpoint creation page](https://ui.endpoints.huggingface.co/new). As an example, this guide will go through the steps to deploy [distilbert-base-uncased-finetuned-sst-2-english](https://huggingface.co/distilbert-base-uncased-finetuned-sst-2-english) for text classification. \n\n## 1. Enter the Hugging Face Repository ID and your desired endpoint name:\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_repository.png\" alt=\"select repository\" />\n\n## 2. Select your Cloud Provider and region. Initially, only AWS will be available as a Cloud Provider with the `us-east-1` and `eu-west-1` regions. We will add Azure soon, and if you need to test Endpoints with other Cloud Providers or regions, please let us know.\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_region.png\" alt=\"select region\" />\n\n## 3. Define the [Security Level](security) for the Endpoint:\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_security.png\" alt=\"define security\" />\n\n## 4. Create your Endpoint by clicking **Create Endpoint**. By default, your Endpoint is created with a medium CPU (2 x 4GB vCPUs with Intel Xeon Ice Lake) The cost estimate assumes the Endpoint will be up for an entire month, and does not take autoscaling into account.\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_create_cost.png\" alt=\"create endpoint\" />\n\n## 5. Wait for the Endpoint to build, initialize and run which can take between 1 to 5 minutes.\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/overview.png\" alt=\"overview\" />\n\n## 6. Test your Endpoint in the overview with the Inference widget \ud83c\udfc1 \ud83c\udf89!\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_inference.png\" alt=\"run inference\" />\n--New Chunk--\n[Created at: 2025-03-24 13:19:17]\n!---\nCopyright 2022 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n-->\n\n# Token classification with LayoutLMv3 (PyTorch version)\n\nThis directory contains a script, `run_funsd_cord.py`, that can be used to fine-tune (or evaluate) LayoutLMv3 on form understanding datasets, such as [FUNSD](https://guillaumejaume.github.io/FUNSD/) and [CORD](https://github.com/clovaai/cord).\n\nThe script `run_funsd_cord.py` leverages the \ud83e\udd17 Datasets library and the Trainer API. You can easily customize it to your needs.\n\n## Fine-tuning on FUNSD\n\nFine-tuning LayoutLMv3 for token classification on [FUNSD](https://guillaumejaume.github.io/FUNSD/) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name funsd \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 1e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-funsd\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd. By specifying the `push_to_hub` flag, the model gets uploaded automatically to the hub (regularly), together with a model card, which includes metrics such as precision, recall and F1. Note that you can easily update the model card, as it's just a README file of the respective repo on the hub.\n\nThere's also the \"Training metrics\" [tab](https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd/tensorboard), which shows Tensorboard logs over the course of training. Pretty neat, huh?\n\n## Fine-tuning on CORD\n\nFine-tuning LayoutLMv3 for token classification on [CORD](https://github.com/clovaai/cord) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name cord \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 5e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-cord\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-cord. Note that a model card gets generated automatically in case you specify the `push_to_hub` flag."
        }
    },
    {
        "sample_idx": 116,
        "question": "What is the name of the hub where the dataset is uploaded for easy use and download?",
        "answer": "Hugging Face Hub",
        "rag_answer": "The hub where the dataset is uploaded for easy use and download is the Hugging Face Hub.",
        "rag_score": 5,
        "rag_feedback": "The system's response is completely correct, accurate, and factual. It correctly identifies the hub where the dataset is uploaded for easy use and download as the Hugging Face Hub.",
        "rag_context": {
            "kg_context": "-----Entities-----\n    ```csv\n    id,\tentity,\ttype,\tdescription,\trankcreated_at\n1,\tGradio,organization,Gradio is a platform that supports state in Blocks, providing features such as global state and session state.<SEP>Gradio is an interface that provides various features for demonstrating models, including adding example inputs, custom error messages, descriptive content, flagging, and more.<SEP>Gradio is an organization that provides a platform for building and deploying machine learning models.<SEP>Gradio is an organization that provides a platform for creating and deploying machine learning models.<SEP>Gradio is an organization that provides a demo for blocks_random_slider, and its library is used to create interactive interfaces.,36,2025-03-24 13:20:24\n2,\tState,category,State is a concept in Gradio that refers to the storage of data, including global state and session state.,2,2025-03-24 13:20:24\n3,\tCSV,technology,CSV is a type of file format that can be used with Gradio components.,1,2025-03-24 13:20:24\n4,\tInterface,category,Interface is a category of components in Gradio that enables the creation of custom interfaces.<SEP>Interface is a component of Gradio that allows users to interact with machine learning models.<SEP>Interface is a concept in Gradio that refers to a user interface for demonstrating models.<SEP>Interface is a category related to Gradio, where state works similarly to Blocks.,3,2025-03-24 13:20:24\n5,\tDatasets library,technology,Datasets library is a tool used for fine-tuning the LayoutLMv3 model.,1,UNKNOWN\n6,\tdocs,geo,docs is a location where more information about Gradio's state can be found.,1,UNKNOWN\n7,\tDataset Preview,organization,Dataset Preview is a function that provides examples of dataset structures.,1,UNKNOWN\n    ```\n    -----Relationships-----\n    ```csv\n    id,\tsource,\ttarget,\tdescription,\tkeywords,\tweight,\trank,\tcreated_at\n1,\tGradio,State,Gradio supports state in Blocks, including global state and session state.,platform feature, data storage,18.0,38,2025-03-24 13:20:24\n2,\tCSV,Gradio,Gradio can use CSV file format for data storage.,data storage, file format,12.0,37,2025-03-24 13:17:31\n3,\tInterface,State,State works similarly in Interface and Blocks.,similar concept, data storage,14.0,5,2025-03-24 13:20:24\n4,\tGradio,docs,The Gradio docs provide more information about state.,documentation, platform information,8.0,37,UNKNOWN\n5,\tDatasets library,LayoutLMv3,Datasets library is a tool used for fine-tuning the LayoutLMv3 model.,tool, model fine-tuning,7.0,12,UNKNOWN\n6,\tDataset Preview,Metric Card,Dataset Preview and Metric Card are related resources that provide information about dataset structures and evaluation functions.,information resources, dataset structure,16.0,2,UNKNOWN\n    ```\n    -----Sources-----\n    ```csv\n    id,\tcontent\n1,\tState in Blocks\n\nWe covered [State in Interfaces](https://gradio.app/interface-state), this guide takes a look at state in Blocks, which works mostly the same.\n\n## Global State\n\nGlobal state in Blocks works the same as in Interface. Any variable created outside a function call is a reference shared between all users.\n\n## Session State\n\nGradio supports session **state**, where data persists across multiple submits within a page session, in Blocks apps as well. To reiterate, session data is _not_ shared between different users of your model. To store data in a session state, you need to do three things:\n\n1. Create a `gr.State()` object. If there is a default value to this stateful object, pass that into the constructor.\n2. In the event listener, put the `State` object as an input and output.\n3. In the event listener function, add the variable to the input parameters and the return value.\n\nLet's take a look at a game of hangman.\n\n$code_hangman\n$demo_hangman\n\nLet's see how we do each of the 3 steps listed above in this game:\n\n1. We store the used letters in `used_letters_var`. In the constructor of `State`, we set the initial value of this to `[]`, an empty list.\n2. In `btn.click()`, we have a reference to `used_letters_var` in both the inputs and outputs.\n3. In `guess_letter`, we pass the value of this `State` to `used_letters`, and then return an updated value of this `State` in the return statement.\n\nWith more complex apps, you will likely have many State variables storing session state in a single Blocks app.\n\nLearn more about `State` in the [docs](https://gradio.app/docs#state).\n2,\t\u65f6\u5fc5\u987b\u9009\u62e9\u5176\u4e2d\u4e00\u4e2a\u5b57\u7b26\u4e32\uff0c\u8fd9\u5c06\u4f5c\u4e3a\u9644\u52a0\u5217\u4fdd\u5b58\u5230 CSV \u4e2d\u3002\n\n## \u9884\u5904\u7406\u548c\u540e\u5904\u7406 (Preprocessing and Postprocessing)\n\n![annotated](/assets/img/dataflow.svg)\n\n\u5982\u60a8\u6240\u89c1\uff0cGradio \u5305\u62ec\u53ef\u4ee5\u5904\u7406\u5404\u79cd\u4e0d\u540c\u6570\u636e\u7c7b\u578b\u7684\u7ec4\u4ef6\uff0c\u4f8b\u5982\u56fe\u50cf\u3001\u97f3\u9891\u548c\u89c6\u9891\u3002\u5927\u591a\u6570\u7ec4\u4ef6\u90fd\u53ef\u4ee5\u7528\u4f5c\u8f93\u5165\u6216\u8f93\u51fa\u3002\n\n\u5f53\u7ec4\u4ef6\u7528\u4f5c\u8f93\u5165\u65f6\uff0cGradio \u81ea\u52a8\u5904\u7406*\u9884\u5904\u7406*\uff0c\u5c06\u6570\u636e\u4ece\u7528\u6237\u6d4f\u89c8\u5668\u53d1\u9001\u7684\u7c7b\u578b\uff08\u4f8b\u5982\u7f51\u7edc\u6444\u50cf\u5934\u5feb\u7167\u7684 base64 \u8868\u793a\uff09\u8f6c\u6362\u4e3a\u60a8\u7684\u51fd\u6570\u53ef\u4ee5\u63a5\u53d7\u7684\u5f62\u5f0f\uff08\u4f8b\u5982 `numpy` \u6570\u7ec4\uff09\u3002\n\n\u540c\u6837\uff0c\u5f53\u7ec4\u4ef6\u7528\u4f5c\u8f93\u51fa\u65f6\uff0cGradio \u81ea\u52a8\u5904\u7406*\u540e\u5904\u7406*\uff0c\u5c06\u6570\u636e\u4ece\u51fd\u6570\u8fd4\u56de\u7684\u5f62\u5f0f\uff08\u4f8b\u5982\u56fe\u50cf\u8def\u5f84\u5217\u8868\uff09\u8f6c\u6362\u4e3a\u53ef\u4ee5\u5728\u7528\u6237\u6d4f\u89c8\u5668\u4e2d\u663e\u793a\u7684\u5f62\u5f0f\uff08\u4f8b\u5982\u4ee5 base64 \u683c\u5f0f\u663e\u793a\u56fe\u50cf\u7684 `Gallery`\uff09\u3002\n\n\u60a8\u53ef\u4ee5\u4f7f\u7528\u6784\u5efa\u56fe\u50cf\u7ec4\u4ef6\u65f6\u7684\u53c2\u6570\u63a7\u5236*\u9884\u5904\u7406*\u3002\u4f8b\u5982\uff0c\u5982\u679c\u60a8\u4f7f\u7528\u4ee5\u4e0b\u53c2\u6570\u5b9e\u4f8b\u5316 `Image` \u7ec4\u4ef6\uff0c\u5b83\u5c06\u5c06\u56fe\u50cf\u8f6c\u6362\u4e3a `PIL` \u7c7b\u578b\uff0c\u5e76\u5c06\u5176\u91cd\u5851\u4e3a`(100, 100)`\uff0c\u800c\u4e0d\u7ba1\u63d0\u4ea4\u65f6\u7684\u539f\u59cb\u5927\u5c0f\u5982\u4f55\uff1a\n\n```py\nimg = gr.Image(shape=(100, 100), type=\"pil\")\n```\n\n\u76f8\u53cd\uff0c\u8fd9\u91cc\u6211\u4eec\u4fdd\u7559\u56fe\u50cf\u7684\u539f\u59cb\u5927\u5c0f\uff0c\u4f46\u5728\u5c06\u5176\u8f6c\u6362\u4e3a numpy \u6570\u7ec4\u4e4b\u524d\u53cd\u8f6c\u989c\u8272\uff1a\n\n```py\nimg = gr.Image(invert_colors=True, type=\"numpy\")\n```\n\n\u540e\u5904\u7406\u8981\u5bb9\u6613\u5f97\u591a\uff01Gradio \u81ea\u52a8\u8bc6\u522b\u8fd4\u56de\u6570\u636e\u7684\u683c\u5f0f\uff08\u4f8b\u5982 `Image` \u662f `numpy` \u6570\u7ec4\u8fd8\u662f `str` \u6587\u4ef6\u8def\u5f84\uff1f\uff09\uff0c\u5e76\u5c06\u5176\u540e\u5904\u7406\u4e3a\u53ef\u4ee5\u7531\u6d4f\u89c8\u5668\u663e\u793a\u7684\u683c\u5f0f\u3002\n\n\u8bf7\u67e5\u770b[\u6587\u6863](https://gradio.app/docs)\uff0c\u4e86\u89e3\u6bcf\u4e2a\u7ec4\u4ef6\u7684\u6240\u6709\u4e0e\u9884\u5904\u7406\u76f8\u5173\u7684\u53c2\u6570\u3002\n\n## \u6837\u5f0f (Styling)\n\nGradio \u4e3b\u9898\u662f\u81ea\u5b9a\u4e49\u5e94\u7528\u7a0b\u5e8f\u5916\u89c2\u548c\u611f\u89c9\u7684\u6700\u7b80\u5355\u65b9\u6cd5\u3002\u60a8\u53ef\u4ee5\u9009\u62e9\u591a\u79cd\u4e3b\u9898\u6216\u521b\u5efa\u81ea\u5df1\u7684\u4e3b\u9898\u3002\u8981\u8fd9\u6837\u505a\uff0c\u8bf7\u5c06 `theme=` \u53c2\u6570\u4f20\u9012\u7ed9 `Interface` \u6784\u9020\u51fd\u6570\u3002\u4f8b\u5982\uff1a\n\n```python\ndemo = gr.Interface(..., theme=gr.themes.Monochrome())\n```\n\nGradio \u5e26\u6709\u4e00\u7ec4\u9884\u5148\u6784\u5efa\u7684\u4e3b\u9898\uff0c\u60a8\u53ef\u4ee5\u4ece `gr.themes.*` \u52a0\u8f7d\u3002\u60a8\u53ef\u4ee5\u6269\u5c55\u8fd9\u4e9b\u4e3b\u9898\u6216\u4ece\u5934\u5f00\u59cb\u521b\u5efa\u81ea\u5df1\u7684\u4e3b\u9898 - \u6709\u5173\u66f4\u591a\u8be6\u7ec6\u4fe1\u606f\uff0c\u8bf7\u53c2\u9605[\u4e3b\u9898\u6307\u5357](https://gradio.app/theming-guide)\u3002\n\n\u8981\u589e\u52a0\u989d\u5916\u7684\u6837\u5f0f\u80fd\u529b\uff0c\u60a8\u53ef\u4ee5 with `css=` \u5173\u952e\u5b57\u5c06\u4efb\u4f55 CSS \u4f20\u9012\u7ed9\u60a8\u7684\u5e94\u7528\u7a0b\u5e8f\u3002\nGradio \u5e94\u7528\u7a0b\u5e8f\u7684\u57fa\u7c7b\u662f `gradio-container`\uff0c\u56e0\u6b64\u4ee5\u4e0b\u662f\u4e00\u4e2a\u66f4\u6539 Gradio \u5e94\u7528\u7a0b\u5e8f\u80cc\u666f\u989c\u8272\u7684\u793a\u4f8b\uff1a\n\n```python\nwith `gr.Interface(css=\".gradio-container {background-color: red}\") as demo:\n    ...\n```\n\n## \u961f\u5217 (Queuing)\n\n\u5982\u679c\u60a8\u7684\u5e94\u7528\u7a0b\u5e8f\u9884\u8ba1\u4f1a\u6709\u5927\u91cf\u6d41\u91cf\uff0c\u8bf7 with `queue()` \u65b9\u6cd5\u6765\u63a7\u5236\u5904\u7406\u901f\u7387\u3002\u8fd9\u5c06\u6392\u961f\u5904\u7406\u8c03\u7528\uff0c\u56e0\u6b64\u4e00\u6b21\u53ea\u5904\u7406\u4e00\u5b9a\u6570\u91cf\u7684\u8bf7\u6c42\u3002\u961f\u5217\u4f7f\u7528 Websockets\uff0c\u8fd8\u53ef\u4ee5\u9632\u6b62\u7f51\u7edc\u8d85\u65f6\uff0c\u56e0\u6b64\u5982\u679c\u60a8\u7684\u51fd\u6570\u7684\u63a8\u7406\u65f6\u95f4\u5f88\u957f\uff08> 1 \u5206\u949f\uff09\uff0c\u5e94\u4f7f\u7528\u961f\u5217\u3002\n\nwith `Interface`\uff1a\n\n```python\ndemo = gr.Interface(...).queue()\ndemo.launch()\n```\n\nwith `Blocks`\uff1a\n\n```python\nwith gr.Blocks() as demo\uff1a\n    #...\ndemo.queue()\ndemo.launch()\n```\n\n\u60a8\u53ef\u4ee5\u901a\u8fc7\u4ee5\u4e0b\u65b9\u5f0f\u63a7\u5236\u4e00\u6b21\u5904\u7406\u7684\u8bf7\u6c42\u6570\u91cf\uff1a\n\n```python\ndemo.queue(concurrency_count=3)\n```\n\n\u67e5\u770b\u6709\u5173\u914d\u7f6e\u5176\u4ed6\u961f\u5217\u53c2\u6570\u7684[\u961f\u5217\u6587\u6863](/docs/#queue)\u3002\n\n\u5728 Blocks \u4e2d\u6307\u5b9a\u4ec5\u5bf9\u67d0\u4e9b\u51fd\u6570\u8fdb\u884c\u6392\u961f\uff1a\n\n```python\nwith gr.Blocks() as demo2\uff1a\n    num1 = gr.Number()\n    num2 = gr.Number()\n    output = gr.Number()\n    gr.Button(\"Add\").click(\n        lambda a, b: a + b, [num1, num2], output)\n    gr.Button(\"Multiply\").click(\n        lambda a, b: a * b, [num1, num2], output, queue=True)\ndemo2.launch()\n```\n\n## \u8fed\u4ee3\u8f93\u51fa (Iterative Outputs)\n\n\u5728\u67d0\u4e9b\u60c5\u51b5\u4e0b\uff0c\u60a8\u53ef\u80fd\u9700\u8981\u4f20\u8f93\u4e00\u7cfb\u5217\u8f93\u51fa\u800c\u4e0d\u662f\u4e00\u6b21\u663e\u793a\u5355\u4e2a\u8f93\u51fa\u3002\u4f8b\u5982\uff0c\u60a8\u53ef\u80fd\u6709\u4e00\u4e2a\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5e0c\u671b\u663e\u793a\u751f\u6210\u7684\u6bcf\u4e2a\u6b65\u9aa4\u7684\u56fe\u50cf\uff0c\u76f4\u5230\u6700\u7ec8\u56fe\u50cf\u3002\u6216\u8005\u60a8\u53ef\u80fd\u6709\u4e00\u4e2a\u804a\u5929\u673a\u5668\u4eba\uff0c\u5b83\u9010\u5b57\u9010\u53e5\u5730\u6d41\u5f0f\u4f20\u8f93\u54cd\u5e94\uff0c\u800c\u4e0d\u662f\u4e00\u6b21\u8fd4\u56de\u5168\u90e8\u54cd\u5e94\u3002\n\n\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u60a8\u53ef\u4ee5\u5c06**\u751f\u6210\u5668**\u51fd\u6570\u63d0\u4f9b\u7ed9 Gradio\uff0c\u800c\u4e0d\u662f\u5e38\u89c4\u51fd\u6570\u3002\u5728 Python \u4e2d\u521b\u5efa\u751f\u6210\u5668\u975e\u5e38\u7b80\u5355\uff1a\u51fd\u6570\u4e0d\u5e94\u8be5\u6709\u4e00\u4e2a\u5355\u72ec\u7684 `return` \u503c\uff0c\u800c\u662f\u5e94\u8be5 with `yield` \u8fde\u7eed\u8fd4\u56de\u4e00\u7cfb\u5217\u503c\u3002\u901a\u5e38\uff0c`yield` \u8bed\u53e5\u653e\u7f6e\u5728\u67d0\u79cd\u5faa\u73af\u4e2d\u3002\u4e0b\u9762\u662f\u4e00\u4e2a\u7b80\u5355\u793a\u4f8b\uff0c\u751f\u6210\u5668\u53ea\u662f\u7b80\u5355\u8ba1\u6570\u5230\u7ed9\u5b9a\u6570\u5b57\uff1a\n\n```python\ndef my_generator(x):\n    for i in range(x):\n        yield i\n```\n\n\u60a8\u4ee5\u4e0e\u5e38\u89c4\u51fd\u6570\u76f8\u540c\u7684\u65b9\u5f0f\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio\u3002\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\uff08\u865a\u62df\u7684\uff09\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5b83\u5728\u8f93\u51fa\u56fe\u50cf\u4e4b\u524d\u751f\u6210\u6570\u4e2a\u6b65\u9aa4\u7684\u566a\u97f3\uff1a\n\n$code_fake_diffusion\n$demo_fake_diffusion\n\n\u8bf7\u6ce8\u610f\uff0c\u6211\u4eec\u5728\u8fed\u4ee3\u5668\u4e2d\u6dfb\u52a0\u4e86 `time.sleep(1)`\uff0c\u4ee5\u521b\u5efa\u6b65\u9aa4\u4e4b\u95f4\u7684\u4eba\u5de5\u6682\u505c\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u89c2\u5bdf\u8fed\u4ee3\u5668\u7684\u6b65\u9aa4\uff08\u5728\u771f\u5b9e\u7684\u56fe\u50cf\u751f\u6210\u6a21\u578b\u4e2d\uff0c\u8fd9\n3,\t!---\nCopyright 2022 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n-->\n\n# Token classification with LayoutLMv3 (PyTorch version)\n\nThis directory contains a script, `run_funsd_cord.py`, that can be used to fine-tune (or evaluate) LayoutLMv3 on form understanding datasets, such as [FUNSD](https://guillaumejaume.github.io/FUNSD/) and [CORD](https://github.com/clovaai/cord).\n\nThe script `run_funsd_cord.py` leverages the \ud83e\udd17 Datasets library and the Trainer API. You can easily customize it to your needs.\n\n## Fine-tuning on FUNSD\n\nFine-tuning LayoutLMv3 for token classification on [FUNSD](https://guillaumejaume.github.io/FUNSD/) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name funsd \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 1e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-funsd\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd. By specifying the `push_to_hub` flag, the model gets uploaded automatically to the hub (regularly), together with a model card, which includes metrics such as precision, recall and F1. Note that you can easily update the model card, as it's just a README file of the respective repo on the hub.\n\nThere's also the \"Training metrics\" [tab](https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd/tensorboard), which shows Tensorboard logs over the course of training. Pretty neat, huh?\n\n## Fine-tuning on CORD\n\nFine-tuning LayoutLMv3 for token classification on [CORD](https://github.com/clovaai/cord) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name cord \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 5e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-cord\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-cord. Note that a model card gets generated automatically in case you specify the `push_to_hub` flag.\n4,\t=predictions, references=references)\n>>> results\n{'exact_match': 100.0, 'f1': 100.0}\n```\n\nYou can find examples of dataset structures by consulting the \"Dataset Preview\" function or the dataset card for a given dataset, and you can see how to use its dedicated evaluation function based on the metric card.\n    ```",
            "vector_context": "[Created at: 2025-03-24 13:16:13]\n=predictions, references=references)\n>>> results\n{'exact_match': 100.0, 'f1': 100.0}\n```\n\nYou can find examples of dataset structures by consulting the \"Dataset Preview\" function or the dataset card for a given dataset, and you can see how to use its dedicated evaluation function based on the metric card.\n--New Chunk--\n[Created at: 2025-03-24 13:19:17]\n!---\nCopyright 2022 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n-->\n\n# Token classification with LayoutLMv3 (PyTorch version)\n\nThis directory contains a script, `run_funsd_cord.py`, that can be used to fine-tune (or evaluate) LayoutLMv3 on form understanding datasets, such as [FUNSD](https://guillaumejaume.github.io/FUNSD/) and [CORD](https://github.com/clovaai/cord).\n\nThe script `run_funsd_cord.py` leverages the \ud83e\udd17 Datasets library and the Trainer API. You can easily customize it to your needs.\n\n## Fine-tuning on FUNSD\n\nFine-tuning LayoutLMv3 for token classification on [FUNSD](https://guillaumejaume.github.io/FUNSD/) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name funsd \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 1e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-funsd\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd. By specifying the `push_to_hub` flag, the model gets uploaded automatically to the hub (regularly), together with a model card, which includes metrics such as precision, recall and F1. Note that you can easily update the model card, as it's just a README file of the respective repo on the hub.\n\nThere's also the \"Training metrics\" [tab](https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd/tensorboard), which shows Tensorboard logs over the course of training. Pretty neat, huh?\n\n## Fine-tuning on CORD\n\nFine-tuning LayoutLMv3 for token classification on [CORD](https://github.com/clovaai/cord) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name cord \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 5e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-cord\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-cord. Note that a model card gets generated automatically in case you specify the `push_to_hub` flag.\n--New Chunk--\n[Created at: 2025-03-24 13:17:32]\n!--Copyright 2023 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\nthe License. You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under the License is distributed on\nan \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n\n\u26a0\ufe0f Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be\nrendered properly in your Markdown viewer.\n\n-->\n\n# Training on TPU with TensorFlow\n\n<Tip>\n\nIf you don't need long explanations and just want TPU code samples to get started with, check out [our TPU example notebook!](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb)\n\n</Tip>\n\n### What is a TPU?\n\nA TPU is a **Tensor Processing Unit.** They are hardware designed by Google, which are used to greatly speed up the tensor computations within neural networks, much like GPUs. They can be used for both network training and inference. They are generally accessed through Google\u2019s cloud services, but small TPUs can also be accessed directly for free through Google Colab and Kaggle Kernels.\n\nBecause [all TensorFlow models in \ud83e\udd17 Transformers are Keras models](https://huggingface.co/blog/tensorflow-philosophy), most of the methods in this document are generally applicable to TPU training for any Keras model! However, there are a few points that are specific to the HuggingFace ecosystem (hug-o-system?) of Transformers and Datasets, and we\u2019ll make sure to flag them up when we get to them.\n\n### What kinds of TPU are available?\n\nNew users are often very confused by the range of TPUs, and the different ways to access them. The first key distinction to understand is the difference between **TPU Nodes** and **TPU VMs.**\n\nWhen you use a **TPU Node**, you are effectively indirectly accessing a remote TPU. You will need a separate VM, which will initialize your network and data pipeline and then forward them to the remote node. When you use a TPU on Google Colab, you are accessing it in the **TPU Node** style.\n\nUsing TPU Nodes can have some quite unexpected behaviour for people who aren\u2019t used to them! In particular, because the TPU is located on a physically different system to the machine you\u2019re running your Python code on, your data cannot be local to your machine - any data pipeline that loads from your machine\u2019s internal storage will totally fail! Instead, data must be stored in Google Cloud Storage where your data pipeline can still access it, even when the pipeline is running on the remote TPU node.\n\n<Tip>\n\nIf you can fit all your data in memory as `np.ndarray` or `tf.Tensor`, then you can `fit()` on that data even when using Colab or a TPU Node, without needing to upload it to Google Cloud Storage.\n\n</Tip>\n\n<Tip>\n\n**\ud83e\udd17Specific Hugging Face Tip\ud83e\udd17:** The methods `Dataset.to_tf_dataset()` and its higher-level wrapper `model.prepare_tf_dataset()` , which you will see throughout our TF code examples, will both fail on a TPU Node. The reason for this is that even though they create a `tf.data.Dataset` it is not a \u201cpure\u201d `tf.data` pipeline and uses `tf.numpy_function` or `Dataset.from_generator()` to stream data from the underlying HuggingFace `Dataset`. This HuggingFace `Dataset` is backed by data that is on a local disc and which the remote TPU Node will not be able to read.\n\n</Tip>\n\nThe second way to access a TPU is via a **TPU VM.** When using a TPU VM, you connect directly to the machine that the TPU is attached to, much like training on a GPU VM. TPU VMs are generally easier to work with, particularly when it comes to your data pipeline. All of the above warnings do not apply to TPU VMs!\n\nThis is an opinionated document, so here\u2019s our opinion: **Avoid using TPU Node if possible.** It is more confusing and more difficult to debug than TPU VMs. It is also likely to be unsupported in future - Google\u2019s latest TPU, TPUv4, can only be accessed as a TPU VM, which suggests that TPU Nodes are increasingly going to become a \u201clegacy\u201d access method. However, we understand that the only free TPU access is on Colab and Kaggle Kernels, which uses TPU Node - so we\u2019ll try to explain how to handle it if you have to! Check the [TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) for code samples that explain this in more detail.\n\n### What sizes of TPU are available?\n\nA single TPU (a v2-8/v3-8/v4-8) runs 8 replicas. TPUs exist in **pods** that can run hundreds or thousands of replicas simultaneously. When you use more than a single TPU but less than a whole pod (for example, a v3-32), your TPU fleet is referred to as a **pod slice.**\n\nWhen you access a free TPU via Colab, you generally get a single v2-8 TPU.\n\n### I keep hearing about this XLA thing. What\u2019s XLA, and how does it relate to TPUs?\n\nXLA is an optimizing compiler, used by both TensorFlow and JAX. In JAX it is the only compiler, whereas in TensorFlow it is optional"
        }
    },
    {
        "sample_idx": 117,
        "question": "What is the purpose of the filter_map function?",
        "answer": "To filter data based on price and location",
        "rag_answer": "The filter_map function is not mentioned in the provided Data Sources. It is possible that it is a custom function or part of a specific library or framework not mentioned in the Data Sources.\n\nHowever, based on the name \"filter_map\", it can be inferred that it might be a function that applies a filter to a map or a collection of data. The purpose of such a function could be to select or transform certain elements of the data based on a specific condition or criteria.\n\nIf you could provide more context or information about the filter_map function, I might be able to give a more specific answer.\n\nReferences:\nNone",
        "rag_score": 3,
        "rag_feedback": "The system's response is somewhat correct, accurate, and factual. It provides a detailed explanation of the purpose of the filter_map function, but it is not based on any specific information about the function. The response is more of a general explanation of how a function with a similar name might work, rather than a specific answer to the question.",
        "rag_context": {
            "kg_context": "-----Entities-----\n    ```csv\n    id,\tentity,\ttype,\tdescription,\trankcreated_at\n1,\tKeras,category,Keras is a high-level neural networks API, used for building and training neural networks.<SEP>Keras is a machine learning framework that uses XLA for optimization.,2,2025-03-24 13:20:24\n2,\tXLA,technology,XLA is a technology that compiles TensorFlow graphs into executable code for various platforms.<SEP>XLA is an optimizing compiler used by TensorFlow and JAX to improve performance.<SEP>XLA is an optimizing compiler, used by both TensorFlow and JAX to optimize computations.,6,2025-03-24 13:20:24\n3,\tInterface,category,Interface is a category of components in Gradio that enables the creation of custom interfaces.<SEP>Interface is a component of Gradio that allows users to interact with machine learning models.<SEP>Interface is a concept in Gradio that refers to a user interface for demonstrating models.<SEP>Interface is a category related to Gradio, where state works similarly to Blocks.,3,2025-03-24 13:20:24\n4,\tState,category,State is a concept in Gradio that refers to the storage of data, including global state and session state.,2,2025-03-24 13:20:24\n5,\tguess_letter,event,guess_letter is a function in the hangman game that updates the state of used letters.,2,2025-03-24 13:20:24\n6,\tused_letters_var,category,used_letters_var is a variable that stores the used letters in the hangman game.,1,2025-03-24 13:20:24\n7,\ttrim_words,person,Trim words is a function that trims words to a specified length.,0,UNKNOWN\n8,\tgr.State()\" ,technology,gr.State() is a function that creates a stateful object in Gradio.,1,UNKNOWN\n9,\tlabel_mask,concept,label_mask is a technique for masking out unwanted data in machine learning models.,1,UNKNOWN\n    ```\n    -----Relationships-----\n    ```csv\n    id,\tsource,\ttarget,\tdescription,\tkeywords,\tweight,\trank,\tcreated_at\n1,\tKeras,XLA,Keras uses XLA for optimization.,compiler, performance optimization,8.0,8,2025-03-24 13:18:20\n2,\tInterface,State,State works similarly in Interface and Blocks.,similar concept, data storage,14.0,5,2025-03-24 13:20:24\n3,\tguess_letter,used_letters_var,used_letters_var is updated by the guess_letter function.,variable update, game logic,8.0,3,2025-03-24 13:20:24\n4,\tSession State,gr.State()\" ,gr.State() is used to create a Session State in Gradio.,function usage, state creation,9.0,3,UNKNOWN\n5,\tlabel_mask,mean_loss,label_mask is used to calculate mean_loss in machine learning models.,calculation, data processing,2.0,2,UNKNOWN\n    ```\n    -----Sources-----\n    ```csv\n    id,\tcontent\n1,\t(for example, a v3-32), your TPU fleet is referred to as a **pod slice.**\n\nWhen you access a free TPU via Colab, you generally get a single v2-8 TPU.\n\n### I keep hearing about this XLA thing. What\u2019s XLA, and how does it relate to TPUs?\n\nXLA is an optimizing compiler, used by both TensorFlow and JAX. In JAX it is the only compiler, whereas in TensorFlow it is optional (but mandatory on TPU!). The easiest way to enable it when training a Keras model is to pass the argument `jit_compile=True` to `model.compile()`. If you don\u2019t get any errors and performance is good, that\u2019s a great sign that you\u2019re ready to move to TPU!\n\nDebugging on TPU is generally a bit harder than on CPU/GPU, so we recommend getting your code running on CPU/GPU with XLA first before trying it on TPU. You don\u2019t have to train for long, of course - just for a few steps to make sure that your model and data pipeline are working like you expect them to.\n\n<Tip>\n\nXLA compiled code is usually faster - so even if you\u2019re not planning to run on TPU, adding `jit_compile=True` can improve your performance. Be sure to note the caveats below about XLA compatibility, though!\n\n</Tip>\n\n<Tip warning={true}>\n\n**Tip born of painful experience:** Although using `jit_compile=True` is a good way to get a speed boost and test if your CPU/GPU code is XLA-compatible, it can actually cause a lot of problems if you leave it in when actually training on TPU. XLA compilation will happen implicitly on TPU, so remember to remove that line before actually running your code on a TPU!\n\n</Tip>\n\n### How do I make my model XLA compatible?\n\nIn many cases, your code is probably XLA-compatible already! However, there are a few things that work in normal TensorFlow that don\u2019t work in XLA. We\u2019ve distilled them into three core rules below:\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** We\u2019ve put a lot of effort into rewriting our TensorFlow models and loss functions to be XLA-compatible. Our models and loss functions generally obey rule #1 and #2 by default, so you can skip over them if you\u2019re using `transformers` models. Don\u2019t forget about these rules when writing your own models and loss functions, though!\n\n</Tip>\n\n#### XLA Rule #1: Your code cannot have \u201cdata-dependent conditionals\u201d\n\nWhat that means is that any `if` statement cannot depend on values inside a `tf.Tensor`. For example, this code block cannot be compiled with XLA!\n\n```python\nif tf.reduce_sum(tensor) > 10:\n    tensor = tensor / 2.0\n```\n\nThis might seem very restrictive at first, but most neural net code doesn\u2019t need to do this. You can often get around this restriction by using `tf.cond` (see the documentation [here](https://www.tensorflow.org/api_docs/python/tf/cond)) or by removing the conditional and finding a clever math trick with indicator variables instead, like so:\n\n```python\nsum_over_10 = tf.cast(tf.reduce_sum(tensor) > 10, tf.float32)\ntensor = tensor / (1.0 + sum_over_10)\n```\n\nThis code has exactly the same effect as the code above, but by avoiding a conditional, we ensure it will compile with XLA without problems!\n\n#### XLA Rule #2: Your code cannot have \u201cdata-dependent shapes\u201d\n\nWhat this means is that the shape of all of the `tf.Tensor` objects in your code cannot depend on their values. For example, the function `tf.unique` cannot be compiled with XLA, because it returns a `tensor` containing one instance of each unique value in the input. The shape of this output will obviously be different depending on how repetitive the input `Tensor` was, and so XLA refuses to handle it!\n\nIn general, most neural network code obeys rule #2 by default. However, there are a few common cases where it becomes a problem. One very common one is when you use **label masking**, setting your labels to a negative value to indicate that those positions should be ignored when computing the loss. If you look at NumPy or PyTorch loss functions that support label masking, you will often see code like this that uses [boolean indexing](https://numpy.org/doc/stable/user/basics.indexing.html#boolean-array-indexing):\n\n```python\nlabel_mask = labels >= 0\nmasked_outputs = outputs[label_mask]\nmasked_labels = labels[label_mask]\nloss = compute_loss(masked_outputs, masked_labels)\nmean_loss = torch.mean(loss)\n```\n\nThis code is totally fine in NumPy or PyTorch, but it breaks in XLA! Why? Because the shape of `masked_outputs` and `masked_labels` depends on how many positions are masked - that makes it a **data-dependent shape.** However, just like for rule #1, we can often rewrite this code to yield exactly the same output without any data-dependent shapes.\n\n```python\nlabel_mask = tf.cast(labels >= 0, tf.float32)\nloss = compute_loss(outputs, labels)\nloss = loss * label_mask  # Set negative label positions to 0\nmean_loss = tf.reduce_sum(loss) / tf.reduce_sum(label_mask)\n```\n\nHere, we avoid data-dependent shapes by computing the loss for every position, but zeroing out the masked positions in both the numerator and denominator when we calculate the mean, which yields exactly the same result as the first block while maintaining XLA compatibility. Note that we use the same trick as in rule #1 - converting a `tf.bool` to `\n2,\tState in Blocks\n\nWe covered [State in Interfaces](https://gradio.app/interface-state), this guide takes a look at state in Blocks, which works mostly the same.\n\n## Global State\n\nGlobal state in Blocks works the same as in Interface. Any variable created outside a function call is a reference shared between all users.\n\n## Session State\n\nGradio supports session **state**, where data persists across multiple submits within a page session, in Blocks apps as well. To reiterate, session data is _not_ shared between different users of your model. To store data in a session state, you need to do three things:\n\n1. Create a `gr.State()` object. If there is a default value to this stateful object, pass that into the constructor.\n2. In the event listener, put the `State` object as an input and output.\n3. In the event listener function, add the variable to the input parameters and the return value.\n\nLet's take a look at a game of hangman.\n\n$code_hangman\n$demo_hangman\n\nLet's see how we do each of the 3 steps listed above in this game:\n\n1. We store the used letters in `used_letters_var`. In the constructor of `State`, we set the initial value of this to `[]`, an empty list.\n2. In `btn.click()`, we have a reference to `used_letters_var` in both the inputs and outputs.\n3. In `guess_letter`, we pass the value of this `State` to `used_letters`, and then return an updated value of this `State` in the return statement.\n\nWith more complex apps, you will likely have many State variables storing session state in a single Blocks app.\n\nLearn more about `State` in the [docs](https://gradio.app/docs#state).\n3,\t\u4e0e\u5e38\u89c4\u51fd\u6570\u76f8\u540c\u7684\u65b9\u5f0f\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio\u3002\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\uff08\u865a\u62df\u7684\uff09\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5b83\u5728\u8f93\u51fa\u56fe\u50cf\u4e4b\u524d\u751f\u6210\u6570\u4e2a\u6b65\u9aa4\u7684\u566a\u97f3\uff1a\n\n$code_fake_diffusion\n$demo_fake_diffusion\n\n\u8bf7\u6ce8\u610f\uff0c\u6211\u4eec\u5728\u8fed\u4ee3\u5668\u4e2d\u6dfb\u52a0\u4e86 `time.sleep(1)`\uff0c\u4ee5\u521b\u5efa\u6b65\u9aa4\u4e4b\u95f4\u7684\u4eba\u5de5\u6682\u505c\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u89c2\u5bdf\u8fed\u4ee3\u5668\u7684\u6b65\u9aa4\uff08\u5728\u771f\u5b9e\u7684\u56fe\u50cf\u751f\u6210\u6a21\u578b\u4e2d\uff0c\u8fd9\u53ef\u80fd\u662f\u4e0d\u5fc5\u8981\u7684\uff09\u3002\n\n\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio **\u9700\u8981**\u5728\u5e95\u5c42 Interface \u6216 Blocks \u4e2d\u542f\u7528\u961f\u5217\uff08\u8bf7\u53c2\u9605\u4e0a\u9762\u7684\u961f\u5217\u90e8\u5206\uff09\u3002\n\n## \u8fdb\u5ea6\u6761\n\nGradio \u652f\u6301\u521b\u5efa\u81ea\u5b9a\u4e49\u8fdb\u5ea6\u6761\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u81ea\u5b9a\u4e49\u548c\u63a7\u5236\u5411\u7528\u6237\u663e\u793a\u7684\u8fdb\u5ea6\u66f4\u65b0\u3002\u8981\u542f\u7528\u6b64\u529f\u80fd\uff0c\u53ea\u9700\u4e3a\u65b9\u6cd5\u6dfb\u52a0\u4e00\u4e2a\u9ed8\u8ba4\u503c\u4e3a `gr.Progress` \u5b9e\u4f8b\u7684\u53c2\u6570\u5373\u53ef\u3002\u7136\u540e\uff0c\u60a8\u53ef\u4ee5\u76f4\u63a5\u8c03\u7528\u6b64\u5b9e\u4f8b\u5e76\u4f20\u5165 0 \u5230 1 \u4e4b\u95f4\u7684\u6d6e\u70b9\u6570\u6765\u66f4\u65b0\u8fdb\u5ea6\u7ea7\u522b\uff0c\u6216\u8005 with `Progress` \u5b9e\u4f8b\u7684 `tqdm()` \u65b9\u6cd5\u6765\u8ddf\u8e2a\u53ef\u8fed\u4ee3\u5bf9\u8c61\u4e0a\u7684\u8fdb\u5ea6\uff0c\u5982\u4e0b\u6240\u793a\u3002\u5fc5\u987b\u542f\u7528\u961f\u5217\u4ee5\u8fdb\u884c\u8fdb\u5ea6\u66f4\u65b0\u3002\n\n$code_progress_simple\n$demo_progress_simple\n\n\u5982\u679c\u60a8 with `tqdm` \u5e93\uff0c\u5e76\u4e14\u5e0c\u671b\u4ece\u51fd\u6570\u5185\u90e8\u7684\u4efb\u4f55 `tqdm.tqdm` \u81ea\u52a8\u62a5\u544a\u8fdb\u5ea6\u66f4\u65b0\uff0c\u8bf7\u5c06\u9ed8\u8ba4\u53c2\u6570\u8bbe\u7f6e\u4e3a `gr.Progress(track_tqdm=True)`\uff01\n\n## \u6279\u5904\u7406\u51fd\u6570 (Batch Functions)\n\nGradio \u652f\u6301\u4f20\u9012*\u6279\u5904\u7406*\u51fd\u6570\u3002\u6279\u5904\u7406\u51fd\u6570\u53ea\u662f\u63a5\u53d7\u8f93\u5165\u5217\u8868\u5e76\u8fd4\u56de\u9884\u6d4b\u5217\u8868\u7684\u51fd\u6570\u3002\n\n\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\u6279\u5904\u7406\u51fd\u6570\uff0c\u5b83\u63a5\u53d7\u4e24\u4e2a\u8f93\u5165\u5217\u8868\uff08\u4e00\u4e2a\u5355\u8bcd\u5217\u8868\u548c\u4e00\u4e2a\u6574\u6570\u5217\u8868\uff09\uff0c\u5e76\u8fd4\u56de\u4fee\u526a\u8fc7\u7684\u5355\u8bcd\u5217\u8868\u4f5c\u4e3a\u8f93\u51fa\uff1a\n\n```python\nimport time\n\ndef trim_words(words, lens):\n    trimmed_words = []\n    time.sleep(5)\n    for w, l in zip(words, lens):\n        trimmed_words.append(w[:int(l)])\n    return [trimmed_words]\n    for w, l in zip(words, lens):\n```\n\n\u4f7f\u7528\u6279\u5904\u7406\u51fd\u6570\u7684\u4f18\u70b9\u662f\uff0c\u5982\u679c\u542f\u7528\u4e86\u961f\u5217\uff0cGradio \u670d\u52a1\u5668\u53ef\u4ee5\u81ea\u52a8*\u6279\u5904\u7406*\u4f20\u5165\u7684\u8bf7\u6c42\u5e76\u5e76\u884c\u5904\u7406\u5b83\u4eec\uff0c\u4ece\u800c\u53ef\u80fd\u52a0\u5feb\u6f14\u793a\u901f\u5ea6\u3002\u4ee5\u4e0b\u662f Gradio \u4ee3\u7801\u7684\u793a\u4f8b\uff08\u8bf7\u6ce8\u610f `batch=True` \u548c `max_batch_size=16` - \u8fd9\u4e24\u4e2a\u53c2\u6570\u90fd\u53ef\u4ee5\u4f20\u9012\u7ed9\u4e8b\u4ef6\u89e6\u53d1\u5668\u6216 `Interface` \u7c7b\uff09\n\nwith `Interface`\uff1a\n\n```python\ndemo = gr.Interface(trim_words, [\"textbox\", \"number\"], [\"output\"],\n                    batch=True, max_batch_size=16)\ndemo.queue()\ndemo.launch()\n```\n\nwith `Blocks`\uff1a\n\n```python\nimport gradio as gr\n\nwith gr.Blocks() as demo:\n    with gr.Row():\n        word = gr.Textbox(label=\"word\")\n        leng = gr.Number(label=\"leng\")\n        output = gr.Textbox(label=\"Output\")\n    with gr.Row():\n        run = gr.Button()\n\n    event = run.click(trim_words, [word, leng], output, batch=True, max_batch_size=16)\n\ndemo.queue()\ndemo.launch()\n```\n\n\u5728\u4e0a\u9762\u7684\u793a\u4f8b\u4e2d\uff0c\u53ef\u4ee5\u5e76\u884c\u5904\u7406 16 \u4e2a\u8bf7\u6c42\uff08\u603b\u63a8\u7406\u65f6\u95f4\u4e3a 5 \u79d2\uff09\uff0c\u800c\u4e0d\u662f\u5206\u522b\u5904\u7406\u6bcf\u4e2a\u8bf7\u6c42\uff08\u603b\u63a8\u7406\u65f6\u95f4\u4e3a 80 \u79d2\uff09\u3002\u8bb8\u591a Hugging Face \u7684 `transformers` \u548c `diffusers` \u6a21\u578b\u5728 Gradio \u7684\u6279\u5904\u7406\u6a21\u5f0f\u4e0b\u81ea\u7136\u5de5\u4f5c\uff1a\u8fd9\u662f[\u4f7f\u7528\u6279\u5904\u7406\u751f\u6210\u56fe\u50cf\u7684\u793a\u4f8b\u6f14\u793a](https://github.com/gradio-app/gradio/blob/main/demo/diffusers_with_batching/run.py)\n\n\u6ce8\u610f\uff1a\u4f7f\u7528 Gradio \u7684\u6279\u5904\u7406\u51fd\u6570 **requires** \u5728\u5e95\u5c42 Interface \u6216 Blocks \u4e2d\u542f\u7528\u961f\u5217\uff08\u8bf7\u53c2\u9605\u4e0a\u9762\u7684\u961f\u5217\u90e8\u5206\uff09\u3002\n\n## Gradio \u7b14\u8bb0\u672c (Colab Notebooks)\n\nGradio \u53ef\u4ee5\u5728\u4efb\u4f55\u8fd0\u884c Python \u7684\u5730\u65b9\u8fd0\u884c\uff0c\u5305\u62ec\u672c\u5730 Jupyter \u7b14\u8bb0\u672c\u548c\u534f\u4f5c\u7b14\u8bb0\u672c\uff0c\u5982[Google Colab](https://colab.research.google.com/)\u3002\u5bf9\u4e8e\u672c\u5730 Jupyter \u7b14\u8bb0\u672c\u548c Google Colab \u7b14\u8bb0\u672c\uff0cGradio \u5728\u672c\u5730\u670d\u52a1\u5668\u4e0a\u8fd0\u884c\uff0c\u60a8\u53ef\u4ee5\u5728\u6d4f\u89c8\u5668\u4e2d\u4e0e\u4e4b\u4ea4\u4e92\u3002\uff08\u6ce8\u610f\uff1a\u5bf9\u4e8e Google Colab\uff0c\u8fd9\u662f\u901a\u8fc7[\u670d\u52a1\u5de5\u4f5c\u5668\u96a7\u9053](https://github.com/tensorflow/tensorboard/blob/master/docs/design/colab_integration.md)\u5b9e\u73b0\u7684\uff0c\u60a8\u7684\u6d4f\u89c8\u5668\u9700\u8981\u542f\u7528 cookies\u3002\uff09\u5bf9\u4e8e\u5176\u4ed6\u8fdc\u7a0b\u7b14\u8bb0\u672c\uff0cGradio \u4e5f\u5c06\u5728\u670d\u52a1\u5668\u4e0a\u8fd0\u884c\uff0c\u4f46\u60a8\u9700\u8981\u4f7f\u7528[SSH \u96a7\u9053](https://coderwall.com/p/ohk6cg/remote-access-to-ipython-notebooks-via-ssh)\u5728\u672c\u5730\u6d4f\u89c8\u5668\u4e2d\u67e5\u770b\u5e94\u7528\u7a0b\u5e8f\u3002\u901a\u5e38\uff0c\u66f4\u7b80\u5355\u7684\u9009\u62e9\u662f\u4f7f\u7528 Gradio \u5185\u7f6e\u7684\u516c\u5171\u94fe\u63a5\uff0c[\u5728\u4e0b\u4e00\u7bc7\u6307\u5357\u4e2d\u8ba8\u8bba](/sharing-your-app/#sharing-demos)\u3002\n4,\tlabel_mask  # Set negative label positions to 0\nmean_loss = tf.reduce_sum(loss) / tf.reduce_sum(label_mask)\n```\n\nHere, we avoid data-dependent shapes by computing the loss for every position, but zeroing out the masked positions in both the numerator and denominator when we calculate the mean, which yields exactly the same result as the first block while maintaining XLA compatibility. Note that we use the same trick as in rule #1 - converting a `tf.bool` to `tf.float32` and using it as an indicator variable. This is a really useful trick, so remember it if you need to convert your own code to XLA!\n\n#### XLA Rule #3: XLA will need to recompile your model for every different input shape it sees\n\nThis is the big one. What this means is that if your input shapes are very variable, XLA will have to recompile your model over and over, which will create huge performance problems. This commonly arises in NLP models, where input texts have variable lengths after tokenization. In other modalities, static shapes are more common and this rule is much less of a problem.\n\nHow can you get around rule #3? The key is **padding** - if you pad all your inputs to the same length, and then use an `attention_mask`, you can get the same results as you\u2019d get from variable shapes, but without any XLA issues. However, excessive padding can cause severe slowdown too - if you pad all your samples to the maximum length in the whole dataset, you might end up with batches consisting endless padding tokens, which will waste a lot of compute and memory!\n\nThere isn\u2019t a perfect solution to this problem. However, you can try some tricks. One very useful trick is to **pad batches of samples up to a multiple of a number like 32 or 64 tokens.** This often only increases the number of tokens by a small amount, but it hugely reduces the number of unique input shapes, because every input shape now has to be a multiple of 32 or 64. Fewer unique input shapes means fewer XLA compilations!\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** Our tokenizers and data collators have methods that can help you here. You can use `padding=\"max_length\"` or `padding=\"longest\"` when calling tokenizers to get them to output padded data. Our tokenizers and data collators also have a `pad_to_multiple_of` argument that you can use to reduce the number of unique input shapes you see!\n\n</Tip>\n\n### How do I actually train my model on TPU?\n\nOnce your training is XLA-compatible and (if you\u2019re using TPU Node / Colab) your dataset has been prepared appropriately, running on TPU is surprisingly easy! All you really need to change in your code is to add a few lines to initialize your TPU, and to ensure that your model and dataset are created inside a `TPUStrategy` scope. Take a look at [our TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) to see this in action!\n\n### Summary\n\nThere was a lot in here, so let\u2019s summarize with a quick checklist you can follow when you want to get your model ready for TPU training:\n\n- Make sure your code follows the three rules of XLA\n- Compile your model with `jit_compile=True` on CPU/GPU and confirm that you can train it with XLA\n- Either load your dataset into memory or use a TPU-compatible dataset loading approach (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Migrate your code either to Colab (with accelerator set to \u201cTPU\u201d) or a TPU VM on Google Cloud\n- Add TPU initializer code (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Create your `TPUStrategy` and make sure dataset loading and model creation are inside the `strategy.scope()` (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Don\u2019t forget to take `jit_compile=True` out again when you move to TPU!\n- \ud83d\ude4f\ud83d\ude4f\ud83d\ude4f\ud83e\udd7a\ud83e\udd7a\ud83e\udd7a\n- Call model.fit()\n- You did it!\n    ```",
            "vector_context": "[Created at: 2025-03-24 13:18:21]\nGradio Demo: blocks_random_slider\n\n\n```\n!pip install -q gradio \n```\n\n\n```\n\nimport gradio as gr\n\n\ndef func(slider_1, slider_2):\n    return slider_1 * 5 + slider_2\n\n\nwith gr.Blocks() as demo:\n    slider = gr.Slider(minimum=-10.2, maximum=15, label=\"Random Slider (Static)\", randomize=True)\n    slider_1 = gr.Slider(minimum=100, maximum=200, label=\"Random Slider (Input 1)\", randomize=True)\n    slider_2 = gr.Slider(minimum=10, maximum=23.2, label=\"Random Slider (Input 2)\", randomize=True)\n    slider_3 = gr.Slider(value=3, label=\"Non random slider\")\n    btn = gr.Button(\"Run\")\n    btn.click(func, inputs=[slider_1, slider_2], outputs=gr.Number())\n\nif __name__ == \"__main__\":\n    demo.launch()\n\n```\n--New Chunk--\n[Created at: 2025-03-24 13:16:13]\n=predictions, references=references)\n>>> results\n{'exact_match': 100.0, 'f1': 100.0}\n```\n\nYou can find examples of dataset structures by consulting the \"Dataset Preview\" function or the dataset card for a given dataset, and you can see how to use its dedicated evaluation function based on the metric card.\n--New Chunk--\n[Created at: 2025-03-24 13:16:48]\n\u65f6\u5fc5\u987b\u9009\u62e9\u5176\u4e2d\u4e00\u4e2a\u5b57\u7b26\u4e32\uff0c\u8fd9\u5c06\u4f5c\u4e3a\u9644\u52a0\u5217\u4fdd\u5b58\u5230 CSV \u4e2d\u3002\n\n## \u9884\u5904\u7406\u548c\u540e\u5904\u7406 (Preprocessing and Postprocessing)\n\n![annotated](/assets/img/dataflow.svg)\n\n\u5982\u60a8\u6240\u89c1\uff0cGradio \u5305\u62ec\u53ef\u4ee5\u5904\u7406\u5404\u79cd\u4e0d\u540c\u6570\u636e\u7c7b\u578b\u7684\u7ec4\u4ef6\uff0c\u4f8b\u5982\u56fe\u50cf\u3001\u97f3\u9891\u548c\u89c6\u9891\u3002\u5927\u591a\u6570\u7ec4\u4ef6\u90fd\u53ef\u4ee5\u7528\u4f5c\u8f93\u5165\u6216\u8f93\u51fa\u3002\n\n\u5f53\u7ec4\u4ef6\u7528\u4f5c\u8f93\u5165\u65f6\uff0cGradio \u81ea\u52a8\u5904\u7406*\u9884\u5904\u7406*\uff0c\u5c06\u6570\u636e\u4ece\u7528\u6237\u6d4f\u89c8\u5668\u53d1\u9001\u7684\u7c7b\u578b\uff08\u4f8b\u5982\u7f51\u7edc\u6444\u50cf\u5934\u5feb\u7167\u7684 base64 \u8868\u793a\uff09\u8f6c\u6362\u4e3a\u60a8\u7684\u51fd\u6570\u53ef\u4ee5\u63a5\u53d7\u7684\u5f62\u5f0f\uff08\u4f8b\u5982 `numpy` \u6570\u7ec4\uff09\u3002\n\n\u540c\u6837\uff0c\u5f53\u7ec4\u4ef6\u7528\u4f5c\u8f93\u51fa\u65f6\uff0cGradio \u81ea\u52a8\u5904\u7406*\u540e\u5904\u7406*\uff0c\u5c06\u6570\u636e\u4ece\u51fd\u6570\u8fd4\u56de\u7684\u5f62\u5f0f\uff08\u4f8b\u5982\u56fe\u50cf\u8def\u5f84\u5217\u8868\uff09\u8f6c\u6362\u4e3a\u53ef\u4ee5\u5728\u7528\u6237\u6d4f\u89c8\u5668\u4e2d\u663e\u793a\u7684\u5f62\u5f0f\uff08\u4f8b\u5982\u4ee5 base64 \u683c\u5f0f\u663e\u793a\u56fe\u50cf\u7684 `Gallery`\uff09\u3002\n\n\u60a8\u53ef\u4ee5\u4f7f\u7528\u6784\u5efa\u56fe\u50cf\u7ec4\u4ef6\u65f6\u7684\u53c2\u6570\u63a7\u5236*\u9884\u5904\u7406*\u3002\u4f8b\u5982\uff0c\u5982\u679c\u60a8\u4f7f\u7528\u4ee5\u4e0b\u53c2\u6570\u5b9e\u4f8b\u5316 `Image` \u7ec4\u4ef6\uff0c\u5b83\u5c06\u5c06\u56fe\u50cf\u8f6c\u6362\u4e3a `PIL` \u7c7b\u578b\uff0c\u5e76\u5c06\u5176\u91cd\u5851\u4e3a`(100, 100)`\uff0c\u800c\u4e0d\u7ba1\u63d0\u4ea4\u65f6\u7684\u539f\u59cb\u5927\u5c0f\u5982\u4f55\uff1a\n\n```py\nimg = gr.Image(shape=(100, 100), type=\"pil\")\n```\n\n\u76f8\u53cd\uff0c\u8fd9\u91cc\u6211\u4eec\u4fdd\u7559\u56fe\u50cf\u7684\u539f\u59cb\u5927\u5c0f\uff0c\u4f46\u5728\u5c06\u5176\u8f6c\u6362\u4e3a numpy \u6570\u7ec4\u4e4b\u524d\u53cd\u8f6c\u989c\u8272\uff1a\n\n```py\nimg = gr.Image(invert_colors=True, type=\"numpy\")\n```\n\n\u540e\u5904\u7406\u8981\u5bb9\u6613\u5f97\u591a\uff01Gradio \u81ea\u52a8\u8bc6\u522b\u8fd4\u56de\u6570\u636e\u7684\u683c\u5f0f\uff08\u4f8b\u5982 `Image` \u662f `numpy` \u6570\u7ec4\u8fd8\u662f `str` \u6587\u4ef6\u8def\u5f84\uff1f\uff09\uff0c\u5e76\u5c06\u5176\u540e\u5904\u7406\u4e3a\u53ef\u4ee5\u7531\u6d4f\u89c8\u5668\u663e\u793a\u7684\u683c\u5f0f\u3002\n\n\u8bf7\u67e5\u770b[\u6587\u6863](https://gradio.app/docs)\uff0c\u4e86\u89e3\u6bcf\u4e2a\u7ec4\u4ef6\u7684\u6240\u6709\u4e0e\u9884\u5904\u7406\u76f8\u5173\u7684\u53c2\u6570\u3002\n\n## \u6837\u5f0f (Styling)\n\nGradio \u4e3b\u9898\u662f\u81ea\u5b9a\u4e49\u5e94\u7528\u7a0b\u5e8f\u5916\u89c2\u548c\u611f\u89c9\u7684\u6700\u7b80\u5355\u65b9\u6cd5\u3002\u60a8\u53ef\u4ee5\u9009\u62e9\u591a\u79cd\u4e3b\u9898\u6216\u521b\u5efa\u81ea\u5df1\u7684\u4e3b\u9898\u3002\u8981\u8fd9\u6837\u505a\uff0c\u8bf7\u5c06 `theme=` \u53c2\u6570\u4f20\u9012\u7ed9 `Interface` \u6784\u9020\u51fd\u6570\u3002\u4f8b\u5982\uff1a\n\n```python\ndemo = gr.Interface(..., theme=gr.themes.Monochrome())\n```\n\nGradio \u5e26\u6709\u4e00\u7ec4\u9884\u5148\u6784\u5efa\u7684\u4e3b\u9898\uff0c\u60a8\u53ef\u4ee5\u4ece `gr.themes.*` \u52a0\u8f7d\u3002\u60a8\u53ef\u4ee5\u6269\u5c55\u8fd9\u4e9b\u4e3b\u9898\u6216\u4ece\u5934\u5f00\u59cb\u521b\u5efa\u81ea\u5df1\u7684\u4e3b\u9898 - \u6709\u5173\u66f4\u591a\u8be6\u7ec6\u4fe1\u606f\uff0c\u8bf7\u53c2\u9605[\u4e3b\u9898\u6307\u5357](https://gradio.app/theming-guide)\u3002\n\n\u8981\u589e\u52a0\u989d\u5916\u7684\u6837\u5f0f\u80fd\u529b\uff0c\u60a8\u53ef\u4ee5 with `css=` \u5173\u952e\u5b57\u5c06\u4efb\u4f55 CSS \u4f20\u9012\u7ed9\u60a8\u7684\u5e94\u7528\u7a0b\u5e8f\u3002\nGradio \u5e94\u7528\u7a0b\u5e8f\u7684\u57fa\u7c7b\u662f `gradio-container`\uff0c\u56e0\u6b64\u4ee5\u4e0b\u662f\u4e00\u4e2a\u66f4\u6539 Gradio \u5e94\u7528\u7a0b\u5e8f\u80cc\u666f\u989c\u8272\u7684\u793a\u4f8b\uff1a\n\n```python\nwith `gr.Interface(css=\".gradio-container {background-color: red}\") as demo:\n    ...\n```\n\n## \u961f\u5217 (Queuing)\n\n\u5982\u679c\u60a8\u7684\u5e94\u7528\u7a0b\u5e8f\u9884\u8ba1\u4f1a\u6709\u5927\u91cf\u6d41\u91cf\uff0c\u8bf7 with `queue()` \u65b9\u6cd5\u6765\u63a7\u5236\u5904\u7406\u901f\u7387\u3002\u8fd9\u5c06\u6392\u961f\u5904\u7406\u8c03\u7528\uff0c\u56e0\u6b64\u4e00\u6b21\u53ea\u5904\u7406\u4e00\u5b9a\u6570\u91cf\u7684\u8bf7\u6c42\u3002\u961f\u5217\u4f7f\u7528 Websockets\uff0c\u8fd8\u53ef\u4ee5\u9632\u6b62\u7f51\u7edc\u8d85\u65f6\uff0c\u56e0\u6b64\u5982\u679c\u60a8\u7684\u51fd\u6570\u7684\u63a8\u7406\u65f6\u95f4\u5f88\u957f\uff08> 1 \u5206\u949f\uff09\uff0c\u5e94\u4f7f\u7528\u961f\u5217\u3002\n\nwith `Interface`\uff1a\n\n```python\ndemo = gr.Interface(...).queue()\ndemo.launch()\n```\n\nwith `Blocks`\uff1a\n\n```python\nwith gr.Blocks() as demo\uff1a\n    #...\ndemo.queue()\ndemo.launch()\n```\n\n\u60a8\u53ef\u4ee5\u901a\u8fc7\u4ee5\u4e0b\u65b9\u5f0f\u63a7\u5236\u4e00\u6b21\u5904\u7406\u7684\u8bf7\u6c42\u6570\u91cf\uff1a\n\n```python\ndemo.queue(concurrency_count=3)\n```\n\n\u67e5\u770b\u6709\u5173\u914d\u7f6e\u5176\u4ed6\u961f\u5217\u53c2\u6570\u7684[\u961f\u5217\u6587\u6863](/docs/#queue)\u3002\n\n\u5728 Blocks \u4e2d\u6307\u5b9a\u4ec5\u5bf9\u67d0\u4e9b\u51fd\u6570\u8fdb\u884c\u6392\u961f\uff1a\n\n```python\nwith gr.Blocks() as demo2\uff1a\n    num1 = gr.Number()\n    num2 = gr.Number()\n    output = gr.Number()\n    gr.Button(\"Add\").click(\n        lambda a, b: a + b, [num1, num2], output)\n    gr.Button(\"Multiply\").click(\n        lambda a, b: a * b, [num1, num2], output, queue=True)\ndemo2.launch()\n```\n\n## \u8fed\u4ee3\u8f93\u51fa (Iterative Outputs)\n\n\u5728\u67d0\u4e9b\u60c5\u51b5\u4e0b\uff0c\u60a8\u53ef\u80fd\u9700\u8981\u4f20\u8f93\u4e00\u7cfb\u5217\u8f93\u51fa\u800c\u4e0d\u662f\u4e00\u6b21\u663e\u793a\u5355\u4e2a\u8f93\u51fa\u3002\u4f8b\u5982\uff0c\u60a8\u53ef\u80fd\u6709\u4e00\u4e2a\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5e0c\u671b\u663e\u793a\u751f\u6210\u7684\u6bcf\u4e2a\u6b65\u9aa4\u7684\u56fe\u50cf\uff0c\u76f4\u5230\u6700\u7ec8\u56fe\u50cf\u3002\u6216\u8005\u60a8\u53ef\u80fd\u6709\u4e00\u4e2a\u804a\u5929\u673a\u5668\u4eba\uff0c\u5b83\u9010\u5b57\u9010\u53e5\u5730\u6d41\u5f0f\u4f20\u8f93\u54cd\u5e94\uff0c\u800c\u4e0d\u662f\u4e00\u6b21\u8fd4\u56de\u5168\u90e8\u54cd\u5e94\u3002\n\n\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u60a8\u53ef\u4ee5\u5c06**\u751f\u6210\u5668**\u51fd\u6570\u63d0\u4f9b\u7ed9 Gradio\uff0c\u800c\u4e0d\u662f\u5e38\u89c4\u51fd\u6570\u3002\u5728 Python \u4e2d\u521b\u5efa\u751f\u6210\u5668\u975e\u5e38\u7b80\u5355\uff1a\u51fd\u6570\u4e0d\u5e94\u8be5\u6709\u4e00\u4e2a\u5355\u72ec\u7684 `return` \u503c\uff0c\u800c\u662f\u5e94\u8be5 with `yield` \u8fde\u7eed\u8fd4\u56de\u4e00\u7cfb\u5217\u503c\u3002\u901a\u5e38\uff0c`yield` \u8bed\u53e5\u653e\u7f6e\u5728\u67d0\u79cd\u5faa\u73af\u4e2d\u3002\u4e0b\u9762\u662f\u4e00\u4e2a\u7b80\u5355\u793a\u4f8b\uff0c\u751f\u6210\u5668\u53ea\u662f\u7b80\u5355\u8ba1\u6570\u5230\u7ed9\u5b9a\u6570\u5b57\uff1a\n\n```python\ndef my_generator(x):\n    for i in range(x):\n        yield i\n```\n\n\u60a8\u4ee5\u4e0e\u5e38\u89c4\u51fd\u6570\u76f8\u540c\u7684\u65b9\u5f0f\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio\u3002\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\uff08\u865a\u62df\u7684\uff09\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5b83\u5728\u8f93\u51fa\u56fe\u50cf\u4e4b\u524d\u751f\u6210\u6570\u4e2a\u6b65\u9aa4\u7684\u566a\u97f3\uff1a\n\n$code_fake_diffusion\n$demo_fake_diffusion\n\n\u8bf7\u6ce8\u610f\uff0c\u6211\u4eec\u5728\u8fed\u4ee3\u5668\u4e2d\u6dfb\u52a0\u4e86 `time.sleep(1)`\uff0c\u4ee5\u521b\u5efa\u6b65\u9aa4\u4e4b\u95f4\u7684\u4eba\u5de5\u6682\u505c\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u89c2\u5bdf\u8fed\u4ee3\u5668\u7684\u6b65\u9aa4\uff08\u5728\u771f\u5b9e\u7684\u56fe\u50cf\u751f\u6210\u6a21\u578b\u4e2d\uff0c\u8fd9"
        }
    },
    {
        "sample_idx": 118,
        "question": "What is the library used to load the CSV data?",
        "answer": "datasets",
        "rag_answer": "The library used to load the CSV data is not explicitly mentioned in the provided Data Sources. However, based on the context and the Python code snippets, it is likely that the `csv` module from the Python Standard Library is used to load the CSV data.",
        "rag_score": 3,
        "rag_feedback": "The system's response is somewhat correct, accurate, and factual. It provides a detailed explanation of various features of Gradio, including loading CSV data, but it does not directly answer the question about the library used to load CSV data. The correct answer is 'datasets' which is mentioned in the provided context, but not explicitly stated in the system's response.",
        "rag_context": {
            "kg_context": "-----Entities-----\n    ```csv\n    id,\tentity,\ttype,\tdescription,\trankcreated_at\n1,\tGradio,organization,Gradio is a platform that supports state in Blocks, providing features such as global state and session state.<SEP>Gradio is an interface that provides various features for demonstrating models, including adding example inputs, custom error messages, descriptive content, flagging, and more.<SEP>Gradio is an organization that provides a platform for building and deploying machine learning models.<SEP>Gradio is an organization that provides a platform for creating and deploying machine learning models.<SEP>Gradio is an organization that provides a demo for blocks_random_slider, and its library is used to create interactive interfaces.,36,2025-03-24 13:19:57\n2,\tnumpy,technology,numpy is a type of numerical computing library that can be used with Gradio components.,1,2025-03-24 13:19:57\n3,\tCSV,technology,CSV is a type of file format that can be used with Gradio components.,1,2025-03-24 13:19:57\n4,\tDatasets library,technology,Datasets library is a tool used for fine-tuning the LayoutLMv3 model.,1,2025-03-24 13:19:57\n5,\tLayoutLMv3,technology,LayoutLMv3 is a model used for token classification and form understanding tasks.,11,2025-03-24 13:19:57\n6,\tnumpy,technology,numpy is a type of numerical computing library that can be used with Gradio components.,1,UNKNOWN\n7,\tCSV,technology,CSV is a type of file format that can be used with Gradio components.,1,UNKNOWN\n8,\tJupyter,category,Jupyter is a platform for interactive computing and data science.,2,UNKNOWN\n    ```\n    -----Relationships-----\n    ```csv\n    id,\tsource,\ttarget,\tdescription,\tkeywords,\tweight,\trank,\tcreated_at\n1,\tGradio,numpy,Gradio can use numpy library for numerical computing.,library integration, numerical computing,14.0,37,2025-03-24 13:17:31\n2,\tCSV,Gradio,Gradio can use CSV file format for data storage.,data storage, file format,12.0,37,2025-03-24 13:17:31\n3,\tDatasets library,LayoutLMv3,Datasets library is a tool used for fine-tuning the LayoutLMv3 model.,tool, model fine-tuning,7.0,12,2025-03-24 13:19:57\n4,\tGradio,Jupyter,Gradio can be run on Jupyter notebooks.,platform compatibility, interactive computing,7.0,38,UNKNOWN\n5,\tGradio,numpy,Gradio can use numpy library for numerical computing.,library integration, numerical computing,14.0,37,UNKNOWN\n6,\tCSV,Gradio,Gradio can use CSV file format for data storage.,data storage, file format,12.0,37,UNKNOWN\n7,\tJupyter,notebooks,Notebooks are a type of interactive document used in Jupyter.,document type, interactive computing,7.0,3,UNKNOWN\n    ```\n    -----Sources-----\n    ```csv\n    id,\tcontent\n1,\t\u65f6\u5fc5\u987b\u9009\u62e9\u5176\u4e2d\u4e00\u4e2a\u5b57\u7b26\u4e32\uff0c\u8fd9\u5c06\u4f5c\u4e3a\u9644\u52a0\u5217\u4fdd\u5b58\u5230 CSV \u4e2d\u3002\n\n## \u9884\u5904\u7406\u548c\u540e\u5904\u7406 (Preprocessing and Postprocessing)\n\n![annotated](/assets/img/dataflow.svg)\n\n\u5982\u60a8\u6240\u89c1\uff0cGradio \u5305\u62ec\u53ef\u4ee5\u5904\u7406\u5404\u79cd\u4e0d\u540c\u6570\u636e\u7c7b\u578b\u7684\u7ec4\u4ef6\uff0c\u4f8b\u5982\u56fe\u50cf\u3001\u97f3\u9891\u548c\u89c6\u9891\u3002\u5927\u591a\u6570\u7ec4\u4ef6\u90fd\u53ef\u4ee5\u7528\u4f5c\u8f93\u5165\u6216\u8f93\u51fa\u3002\n\n\u5f53\u7ec4\u4ef6\u7528\u4f5c\u8f93\u5165\u65f6\uff0cGradio \u81ea\u52a8\u5904\u7406*\u9884\u5904\u7406*\uff0c\u5c06\u6570\u636e\u4ece\u7528\u6237\u6d4f\u89c8\u5668\u53d1\u9001\u7684\u7c7b\u578b\uff08\u4f8b\u5982\u7f51\u7edc\u6444\u50cf\u5934\u5feb\u7167\u7684 base64 \u8868\u793a\uff09\u8f6c\u6362\u4e3a\u60a8\u7684\u51fd\u6570\u53ef\u4ee5\u63a5\u53d7\u7684\u5f62\u5f0f\uff08\u4f8b\u5982 `numpy` \u6570\u7ec4\uff09\u3002\n\n\u540c\u6837\uff0c\u5f53\u7ec4\u4ef6\u7528\u4f5c\u8f93\u51fa\u65f6\uff0cGradio \u81ea\u52a8\u5904\u7406*\u540e\u5904\u7406*\uff0c\u5c06\u6570\u636e\u4ece\u51fd\u6570\u8fd4\u56de\u7684\u5f62\u5f0f\uff08\u4f8b\u5982\u56fe\u50cf\u8def\u5f84\u5217\u8868\uff09\u8f6c\u6362\u4e3a\u53ef\u4ee5\u5728\u7528\u6237\u6d4f\u89c8\u5668\u4e2d\u663e\u793a\u7684\u5f62\u5f0f\uff08\u4f8b\u5982\u4ee5 base64 \u683c\u5f0f\u663e\u793a\u56fe\u50cf\u7684 `Gallery`\uff09\u3002\n\n\u60a8\u53ef\u4ee5\u4f7f\u7528\u6784\u5efa\u56fe\u50cf\u7ec4\u4ef6\u65f6\u7684\u53c2\u6570\u63a7\u5236*\u9884\u5904\u7406*\u3002\u4f8b\u5982\uff0c\u5982\u679c\u60a8\u4f7f\u7528\u4ee5\u4e0b\u53c2\u6570\u5b9e\u4f8b\u5316 `Image` \u7ec4\u4ef6\uff0c\u5b83\u5c06\u5c06\u56fe\u50cf\u8f6c\u6362\u4e3a `PIL` \u7c7b\u578b\uff0c\u5e76\u5c06\u5176\u91cd\u5851\u4e3a`(100, 100)`\uff0c\u800c\u4e0d\u7ba1\u63d0\u4ea4\u65f6\u7684\u539f\u59cb\u5927\u5c0f\u5982\u4f55\uff1a\n\n```py\nimg = gr.Image(shape=(100, 100), type=\"pil\")\n```\n\n\u76f8\u53cd\uff0c\u8fd9\u91cc\u6211\u4eec\u4fdd\u7559\u56fe\u50cf\u7684\u539f\u59cb\u5927\u5c0f\uff0c\u4f46\u5728\u5c06\u5176\u8f6c\u6362\u4e3a numpy \u6570\u7ec4\u4e4b\u524d\u53cd\u8f6c\u989c\u8272\uff1a\n\n```py\nimg = gr.Image(invert_colors=True, type=\"numpy\")\n```\n\n\u540e\u5904\u7406\u8981\u5bb9\u6613\u5f97\u591a\uff01Gradio \u81ea\u52a8\u8bc6\u522b\u8fd4\u56de\u6570\u636e\u7684\u683c\u5f0f\uff08\u4f8b\u5982 `Image` \u662f `numpy` \u6570\u7ec4\u8fd8\u662f `str` \u6587\u4ef6\u8def\u5f84\uff1f\uff09\uff0c\u5e76\u5c06\u5176\u540e\u5904\u7406\u4e3a\u53ef\u4ee5\u7531\u6d4f\u89c8\u5668\u663e\u793a\u7684\u683c\u5f0f\u3002\n\n\u8bf7\u67e5\u770b[\u6587\u6863](https://gradio.app/docs)\uff0c\u4e86\u89e3\u6bcf\u4e2a\u7ec4\u4ef6\u7684\u6240\u6709\u4e0e\u9884\u5904\u7406\u76f8\u5173\u7684\u53c2\u6570\u3002\n\n## \u6837\u5f0f (Styling)\n\nGradio \u4e3b\u9898\u662f\u81ea\u5b9a\u4e49\u5e94\u7528\u7a0b\u5e8f\u5916\u89c2\u548c\u611f\u89c9\u7684\u6700\u7b80\u5355\u65b9\u6cd5\u3002\u60a8\u53ef\u4ee5\u9009\u62e9\u591a\u79cd\u4e3b\u9898\u6216\u521b\u5efa\u81ea\u5df1\u7684\u4e3b\u9898\u3002\u8981\u8fd9\u6837\u505a\uff0c\u8bf7\u5c06 `theme=` \u53c2\u6570\u4f20\u9012\u7ed9 `Interface` \u6784\u9020\u51fd\u6570\u3002\u4f8b\u5982\uff1a\n\n```python\ndemo = gr.Interface(..., theme=gr.themes.Monochrome())\n```\n\nGradio \u5e26\u6709\u4e00\u7ec4\u9884\u5148\u6784\u5efa\u7684\u4e3b\u9898\uff0c\u60a8\u53ef\u4ee5\u4ece `gr.themes.*` \u52a0\u8f7d\u3002\u60a8\u53ef\u4ee5\u6269\u5c55\u8fd9\u4e9b\u4e3b\u9898\u6216\u4ece\u5934\u5f00\u59cb\u521b\u5efa\u81ea\u5df1\u7684\u4e3b\u9898 - \u6709\u5173\u66f4\u591a\u8be6\u7ec6\u4fe1\u606f\uff0c\u8bf7\u53c2\u9605[\u4e3b\u9898\u6307\u5357](https://gradio.app/theming-guide)\u3002\n\n\u8981\u589e\u52a0\u989d\u5916\u7684\u6837\u5f0f\u80fd\u529b\uff0c\u60a8\u53ef\u4ee5 with `css=` \u5173\u952e\u5b57\u5c06\u4efb\u4f55 CSS \u4f20\u9012\u7ed9\u60a8\u7684\u5e94\u7528\u7a0b\u5e8f\u3002\nGradio \u5e94\u7528\u7a0b\u5e8f\u7684\u57fa\u7c7b\u662f `gradio-container`\uff0c\u56e0\u6b64\u4ee5\u4e0b\u662f\u4e00\u4e2a\u66f4\u6539 Gradio \u5e94\u7528\u7a0b\u5e8f\u80cc\u666f\u989c\u8272\u7684\u793a\u4f8b\uff1a\n\n```python\nwith `gr.Interface(css=\".gradio-container {background-color: red}\") as demo:\n    ...\n```\n\n## \u961f\u5217 (Queuing)\n\n\u5982\u679c\u60a8\u7684\u5e94\u7528\u7a0b\u5e8f\u9884\u8ba1\u4f1a\u6709\u5927\u91cf\u6d41\u91cf\uff0c\u8bf7 with `queue()` \u65b9\u6cd5\u6765\u63a7\u5236\u5904\u7406\u901f\u7387\u3002\u8fd9\u5c06\u6392\u961f\u5904\u7406\u8c03\u7528\uff0c\u56e0\u6b64\u4e00\u6b21\u53ea\u5904\u7406\u4e00\u5b9a\u6570\u91cf\u7684\u8bf7\u6c42\u3002\u961f\u5217\u4f7f\u7528 Websockets\uff0c\u8fd8\u53ef\u4ee5\u9632\u6b62\u7f51\u7edc\u8d85\u65f6\uff0c\u56e0\u6b64\u5982\u679c\u60a8\u7684\u51fd\u6570\u7684\u63a8\u7406\u65f6\u95f4\u5f88\u957f\uff08> 1 \u5206\u949f\uff09\uff0c\u5e94\u4f7f\u7528\u961f\u5217\u3002\n\nwith `Interface`\uff1a\n\n```python\ndemo = gr.Interface(...).queue()\ndemo.launch()\n```\n\nwith `Blocks`\uff1a\n\n```python\nwith gr.Blocks() as demo\uff1a\n    #...\ndemo.queue()\ndemo.launch()\n```\n\n\u60a8\u53ef\u4ee5\u901a\u8fc7\u4ee5\u4e0b\u65b9\u5f0f\u63a7\u5236\u4e00\u6b21\u5904\u7406\u7684\u8bf7\u6c42\u6570\u91cf\uff1a\n\n```python\ndemo.queue(concurrency_count=3)\n```\n\n\u67e5\u770b\u6709\u5173\u914d\u7f6e\u5176\u4ed6\u961f\u5217\u53c2\u6570\u7684[\u961f\u5217\u6587\u6863](/docs/#queue)\u3002\n\n\u5728 Blocks \u4e2d\u6307\u5b9a\u4ec5\u5bf9\u67d0\u4e9b\u51fd\u6570\u8fdb\u884c\u6392\u961f\uff1a\n\n```python\nwith gr.Blocks() as demo2\uff1a\n    num1 = gr.Number()\n    num2 = gr.Number()\n    output = gr.Number()\n    gr.Button(\"Add\").click(\n        lambda a, b: a + b, [num1, num2], output)\n    gr.Button(\"Multiply\").click(\n        lambda a, b: a * b, [num1, num2], output, queue=True)\ndemo2.launch()\n```\n\n## \u8fed\u4ee3\u8f93\u51fa (Iterative Outputs)\n\n\u5728\u67d0\u4e9b\u60c5\u51b5\u4e0b\uff0c\u60a8\u53ef\u80fd\u9700\u8981\u4f20\u8f93\u4e00\u7cfb\u5217\u8f93\u51fa\u800c\u4e0d\u662f\u4e00\u6b21\u663e\u793a\u5355\u4e2a\u8f93\u51fa\u3002\u4f8b\u5982\uff0c\u60a8\u53ef\u80fd\u6709\u4e00\u4e2a\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5e0c\u671b\u663e\u793a\u751f\u6210\u7684\u6bcf\u4e2a\u6b65\u9aa4\u7684\u56fe\u50cf\uff0c\u76f4\u5230\u6700\u7ec8\u56fe\u50cf\u3002\u6216\u8005\u60a8\u53ef\u80fd\u6709\u4e00\u4e2a\u804a\u5929\u673a\u5668\u4eba\uff0c\u5b83\u9010\u5b57\u9010\u53e5\u5730\u6d41\u5f0f\u4f20\u8f93\u54cd\u5e94\uff0c\u800c\u4e0d\u662f\u4e00\u6b21\u8fd4\u56de\u5168\u90e8\u54cd\u5e94\u3002\n\n\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u60a8\u53ef\u4ee5\u5c06**\u751f\u6210\u5668**\u51fd\u6570\u63d0\u4f9b\u7ed9 Gradio\uff0c\u800c\u4e0d\u662f\u5e38\u89c4\u51fd\u6570\u3002\u5728 Python \u4e2d\u521b\u5efa\u751f\u6210\u5668\u975e\u5e38\u7b80\u5355\uff1a\u51fd\u6570\u4e0d\u5e94\u8be5\u6709\u4e00\u4e2a\u5355\u72ec\u7684 `return` \u503c\uff0c\u800c\u662f\u5e94\u8be5 with `yield` \u8fde\u7eed\u8fd4\u56de\u4e00\u7cfb\u5217\u503c\u3002\u901a\u5e38\uff0c`yield` \u8bed\u53e5\u653e\u7f6e\u5728\u67d0\u79cd\u5faa\u73af\u4e2d\u3002\u4e0b\u9762\u662f\u4e00\u4e2a\u7b80\u5355\u793a\u4f8b\uff0c\u751f\u6210\u5668\u53ea\u662f\u7b80\u5355\u8ba1\u6570\u5230\u7ed9\u5b9a\u6570\u5b57\uff1a\n\n```python\ndef my_generator(x):\n    for i in range(x):\n        yield i\n```\n\n\u60a8\u4ee5\u4e0e\u5e38\u89c4\u51fd\u6570\u76f8\u540c\u7684\u65b9\u5f0f\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio\u3002\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\uff08\u865a\u62df\u7684\uff09\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5b83\u5728\u8f93\u51fa\u56fe\u50cf\u4e4b\u524d\u751f\u6210\u6570\u4e2a\u6b65\u9aa4\u7684\u566a\u97f3\uff1a\n\n$code_fake_diffusion\n$demo_fake_diffusion\n\n\u8bf7\u6ce8\u610f\uff0c\u6211\u4eec\u5728\u8fed\u4ee3\u5668\u4e2d\u6dfb\u52a0\u4e86 `time.sleep(1)`\uff0c\u4ee5\u521b\u5efa\u6b65\u9aa4\u4e4b\u95f4\u7684\u4eba\u5de5\u6682\u505c\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u89c2\u5bdf\u8fed\u4ee3\u5668\u7684\u6b65\u9aa4\uff08\u5728\u771f\u5b9e\u7684\u56fe\u50cf\u751f\u6210\u6a21\u578b\u4e2d\uff0c\u8fd9\n2,\t!---\nCopyright 2022 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n-->\n\n# Token classification with LayoutLMv3 (PyTorch version)\n\nThis directory contains a script, `run_funsd_cord.py`, that can be used to fine-tune (or evaluate) LayoutLMv3 on form understanding datasets, such as [FUNSD](https://guillaumejaume.github.io/FUNSD/) and [CORD](https://github.com/clovaai/cord).\n\nThe script `run_funsd_cord.py` leverages the \ud83e\udd17 Datasets library and the Trainer API. You can easily customize it to your needs.\n\n## Fine-tuning on FUNSD\n\nFine-tuning LayoutLMv3 for token classification on [FUNSD](https://guillaumejaume.github.io/FUNSD/) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name funsd \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 1e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-funsd\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd. By specifying the `push_to_hub` flag, the model gets uploaded automatically to the hub (regularly), together with a model card, which includes metrics such as precision, recall and F1. Note that you can easily update the model card, as it's just a README file of the respective repo on the hub.\n\nThere's also the \"Training metrics\" [tab](https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd/tensorboard), which shows Tensorboard logs over the course of training. Pretty neat, huh?\n\n## Fine-tuning on CORD\n\nFine-tuning LayoutLMv3 for token classification on [CORD](https://github.com/clovaai/cord) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name cord \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 5e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-cord\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-cord. Note that a model card gets generated automatically in case you specify the `push_to_hub` flag.\n3,\t\u4e0e\u5e38\u89c4\u51fd\u6570\u76f8\u540c\u7684\u65b9\u5f0f\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio\u3002\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\uff08\u865a\u62df\u7684\uff09\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5b83\u5728\u8f93\u51fa\u56fe\u50cf\u4e4b\u524d\u751f\u6210\u6570\u4e2a\u6b65\u9aa4\u7684\u566a\u97f3\uff1a\n\n$code_fake_diffusion\n$demo_fake_diffusion\n\n\u8bf7\u6ce8\u610f\uff0c\u6211\u4eec\u5728\u8fed\u4ee3\u5668\u4e2d\u6dfb\u52a0\u4e86 `time.sleep(1)`\uff0c\u4ee5\u521b\u5efa\u6b65\u9aa4\u4e4b\u95f4\u7684\u4eba\u5de5\u6682\u505c\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u89c2\u5bdf\u8fed\u4ee3\u5668\u7684\u6b65\u9aa4\uff08\u5728\u771f\u5b9e\u7684\u56fe\u50cf\u751f\u6210\u6a21\u578b\u4e2d\uff0c\u8fd9\u53ef\u80fd\u662f\u4e0d\u5fc5\u8981\u7684\uff09\u3002\n\n\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio **\u9700\u8981**\u5728\u5e95\u5c42 Interface \u6216 Blocks \u4e2d\u542f\u7528\u961f\u5217\uff08\u8bf7\u53c2\u9605\u4e0a\u9762\u7684\u961f\u5217\u90e8\u5206\uff09\u3002\n\n## \u8fdb\u5ea6\u6761\n\nGradio \u652f\u6301\u521b\u5efa\u81ea\u5b9a\u4e49\u8fdb\u5ea6\u6761\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u81ea\u5b9a\u4e49\u548c\u63a7\u5236\u5411\u7528\u6237\u663e\u793a\u7684\u8fdb\u5ea6\u66f4\u65b0\u3002\u8981\u542f\u7528\u6b64\u529f\u80fd\uff0c\u53ea\u9700\u4e3a\u65b9\u6cd5\u6dfb\u52a0\u4e00\u4e2a\u9ed8\u8ba4\u503c\u4e3a `gr.Progress` \u5b9e\u4f8b\u7684\u53c2\u6570\u5373\u53ef\u3002\u7136\u540e\uff0c\u60a8\u53ef\u4ee5\u76f4\u63a5\u8c03\u7528\u6b64\u5b9e\u4f8b\u5e76\u4f20\u5165 0 \u5230 1 \u4e4b\u95f4\u7684\u6d6e\u70b9\u6570\u6765\u66f4\u65b0\u8fdb\u5ea6\u7ea7\u522b\uff0c\u6216\u8005 with `Progress` \u5b9e\u4f8b\u7684 `tqdm()` \u65b9\u6cd5\u6765\u8ddf\u8e2a\u53ef\u8fed\u4ee3\u5bf9\u8c61\u4e0a\u7684\u8fdb\u5ea6\uff0c\u5982\u4e0b\u6240\u793a\u3002\u5fc5\u987b\u542f\u7528\u961f\u5217\u4ee5\u8fdb\u884c\u8fdb\u5ea6\u66f4\u65b0\u3002\n\n$code_progress_simple\n$demo_progress_simple\n\n\u5982\u679c\u60a8 with `tqdm` \u5e93\uff0c\u5e76\u4e14\u5e0c\u671b\u4ece\u51fd\u6570\u5185\u90e8\u7684\u4efb\u4f55 `tqdm.tqdm` \u81ea\u52a8\u62a5\u544a\u8fdb\u5ea6\u66f4\u65b0\uff0c\u8bf7\u5c06\u9ed8\u8ba4\u53c2\u6570\u8bbe\u7f6e\u4e3a `gr.Progress(track_tqdm=True)`\uff01\n\n## \u6279\u5904\u7406\u51fd\u6570 (Batch Functions)\n\nGradio \u652f\u6301\u4f20\u9012*\u6279\u5904\u7406*\u51fd\u6570\u3002\u6279\u5904\u7406\u51fd\u6570\u53ea\u662f\u63a5\u53d7\u8f93\u5165\u5217\u8868\u5e76\u8fd4\u56de\u9884\u6d4b\u5217\u8868\u7684\u51fd\u6570\u3002\n\n\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\u6279\u5904\u7406\u51fd\u6570\uff0c\u5b83\u63a5\u53d7\u4e24\u4e2a\u8f93\u5165\u5217\u8868\uff08\u4e00\u4e2a\u5355\u8bcd\u5217\u8868\u548c\u4e00\u4e2a\u6574\u6570\u5217\u8868\uff09\uff0c\u5e76\u8fd4\u56de\u4fee\u526a\u8fc7\u7684\u5355\u8bcd\u5217\u8868\u4f5c\u4e3a\u8f93\u51fa\uff1a\n\n```python\nimport time\n\ndef trim_words(words, lens):\n    trimmed_words = []\n    time.sleep(5)\n    for w, l in zip(words, lens):\n        trimmed_words.append(w[:int(l)])\n    return [trimmed_words]\n    for w, l in zip(words, lens):\n```\n\n\u4f7f\u7528\u6279\u5904\u7406\u51fd\u6570\u7684\u4f18\u70b9\u662f\uff0c\u5982\u679c\u542f\u7528\u4e86\u961f\u5217\uff0cGradio \u670d\u52a1\u5668\u53ef\u4ee5\u81ea\u52a8*\u6279\u5904\u7406*\u4f20\u5165\u7684\u8bf7\u6c42\u5e76\u5e76\u884c\u5904\u7406\u5b83\u4eec\uff0c\u4ece\u800c\u53ef\u80fd\u52a0\u5feb\u6f14\u793a\u901f\u5ea6\u3002\u4ee5\u4e0b\u662f Gradio \u4ee3\u7801\u7684\u793a\u4f8b\uff08\u8bf7\u6ce8\u610f `batch=True` \u548c `max_batch_size=16` - \u8fd9\u4e24\u4e2a\u53c2\u6570\u90fd\u53ef\u4ee5\u4f20\u9012\u7ed9\u4e8b\u4ef6\u89e6\u53d1\u5668\u6216 `Interface` \u7c7b\uff09\n\nwith `Interface`\uff1a\n\n```python\ndemo = gr.Interface(trim_words, [\"textbox\", \"number\"], [\"output\"],\n                    batch=True, max_batch_size=16)\ndemo.queue()\ndemo.launch()\n```\n\nwith `Blocks`\uff1a\n\n```python\nimport gradio as gr\n\nwith gr.Blocks() as demo:\n    with gr.Row():\n        word = gr.Textbox(label=\"word\")\n        leng = gr.Number(label=\"leng\")\n        output = gr.Textbox(label=\"Output\")\n    with gr.Row():\n        run = gr.Button()\n\n    event = run.click(trim_words, [word, leng], output, batch=True, max_batch_size=16)\n\ndemo.queue()\ndemo.launch()\n```\n\n\u5728\u4e0a\u9762\u7684\u793a\u4f8b\u4e2d\uff0c\u53ef\u4ee5\u5e76\u884c\u5904\u7406 16 \u4e2a\u8bf7\u6c42\uff08\u603b\u63a8\u7406\u65f6\u95f4\u4e3a 5 \u79d2\uff09\uff0c\u800c\u4e0d\u662f\u5206\u522b\u5904\u7406\u6bcf\u4e2a\u8bf7\u6c42\uff08\u603b\u63a8\u7406\u65f6\u95f4\u4e3a 80 \u79d2\uff09\u3002\u8bb8\u591a Hugging Face \u7684 `transformers` \u548c `diffusers` \u6a21\u578b\u5728 Gradio \u7684\u6279\u5904\u7406\u6a21\u5f0f\u4e0b\u81ea\u7136\u5de5\u4f5c\uff1a\u8fd9\u662f[\u4f7f\u7528\u6279\u5904\u7406\u751f\u6210\u56fe\u50cf\u7684\u793a\u4f8b\u6f14\u793a](https://github.com/gradio-app/gradio/blob/main/demo/diffusers_with_batching/run.py)\n\n\u6ce8\u610f\uff1a\u4f7f\u7528 Gradio \u7684\u6279\u5904\u7406\u51fd\u6570 **requires** \u5728\u5e95\u5c42 Interface \u6216 Blocks \u4e2d\u542f\u7528\u961f\u5217\uff08\u8bf7\u53c2\u9605\u4e0a\u9762\u7684\u961f\u5217\u90e8\u5206\uff09\u3002\n\n## Gradio \u7b14\u8bb0\u672c (Colab Notebooks)\n\nGradio \u53ef\u4ee5\u5728\u4efb\u4f55\u8fd0\u884c Python \u7684\u5730\u65b9\u8fd0\u884c\uff0c\u5305\u62ec\u672c\u5730 Jupyter \u7b14\u8bb0\u672c\u548c\u534f\u4f5c\u7b14\u8bb0\u672c\uff0c\u5982[Google Colab](https://colab.research.google.com/)\u3002\u5bf9\u4e8e\u672c\u5730 Jupyter \u7b14\u8bb0\u672c\u548c Google Colab \u7b14\u8bb0\u672c\uff0cGradio \u5728\u672c\u5730\u670d\u52a1\u5668\u4e0a\u8fd0\u884c\uff0c\u60a8\u53ef\u4ee5\u5728\u6d4f\u89c8\u5668\u4e2d\u4e0e\u4e4b\u4ea4\u4e92\u3002\uff08\u6ce8\u610f\uff1a\u5bf9\u4e8e Google Colab\uff0c\u8fd9\u662f\u901a\u8fc7[\u670d\u52a1\u5de5\u4f5c\u5668\u96a7\u9053](https://github.com/tensorflow/tensorboard/blob/master/docs/design/colab_integration.md)\u5b9e\u73b0\u7684\uff0c\u60a8\u7684\u6d4f\u89c8\u5668\u9700\u8981\u542f\u7528 cookies\u3002\uff09\u5bf9\u4e8e\u5176\u4ed6\u8fdc\u7a0b\u7b14\u8bb0\u672c\uff0cGradio \u4e5f\u5c06\u5728\u670d\u52a1\u5668\u4e0a\u8fd0\u884c\uff0c\u4f46\u60a8\u9700\u8981\u4f7f\u7528[SSH \u96a7\u9053](https://coderwall.com/p/ohk6cg/remote-access-to-ipython-notebooks-via-ssh)\u5728\u672c\u5730\u6d4f\u89c8\u5668\u4e2d\u67e5\u770b\u5e94\u7528\u7a0b\u5e8f\u3002\u901a\u5e38\uff0c\u66f4\u7b80\u5355\u7684\u9009\u62e9\u662f\u4f7f\u7528 Gradio \u5185\u7f6e\u7684\u516c\u5171\u94fe\u63a5\uff0c[\u5728\u4e0b\u4e00\u7bc7\u6307\u5357\u4e2d\u8ba8\u8bba](/sharing-your-app/#sharing-demos)\u3002\n    ```",
            "vector_context": "[Created at: 2025-03-24 13:16:48]\n\u65f6\u5fc5\u987b\u9009\u62e9\u5176\u4e2d\u4e00\u4e2a\u5b57\u7b26\u4e32\uff0c\u8fd9\u5c06\u4f5c\u4e3a\u9644\u52a0\u5217\u4fdd\u5b58\u5230 CSV \u4e2d\u3002\n\n## \u9884\u5904\u7406\u548c\u540e\u5904\u7406 (Preprocessing and Postprocessing)\n\n![annotated](/assets/img/dataflow.svg)\n\n\u5982\u60a8\u6240\u89c1\uff0cGradio \u5305\u62ec\u53ef\u4ee5\u5904\u7406\u5404\u79cd\u4e0d\u540c\u6570\u636e\u7c7b\u578b\u7684\u7ec4\u4ef6\uff0c\u4f8b\u5982\u56fe\u50cf\u3001\u97f3\u9891\u548c\u89c6\u9891\u3002\u5927\u591a\u6570\u7ec4\u4ef6\u90fd\u53ef\u4ee5\u7528\u4f5c\u8f93\u5165\u6216\u8f93\u51fa\u3002\n\n\u5f53\u7ec4\u4ef6\u7528\u4f5c\u8f93\u5165\u65f6\uff0cGradio \u81ea\u52a8\u5904\u7406*\u9884\u5904\u7406*\uff0c\u5c06\u6570\u636e\u4ece\u7528\u6237\u6d4f\u89c8\u5668\u53d1\u9001\u7684\u7c7b\u578b\uff08\u4f8b\u5982\u7f51\u7edc\u6444\u50cf\u5934\u5feb\u7167\u7684 base64 \u8868\u793a\uff09\u8f6c\u6362\u4e3a\u60a8\u7684\u51fd\u6570\u53ef\u4ee5\u63a5\u53d7\u7684\u5f62\u5f0f\uff08\u4f8b\u5982 `numpy` \u6570\u7ec4\uff09\u3002\n\n\u540c\u6837\uff0c\u5f53\u7ec4\u4ef6\u7528\u4f5c\u8f93\u51fa\u65f6\uff0cGradio \u81ea\u52a8\u5904\u7406*\u540e\u5904\u7406*\uff0c\u5c06\u6570\u636e\u4ece\u51fd\u6570\u8fd4\u56de\u7684\u5f62\u5f0f\uff08\u4f8b\u5982\u56fe\u50cf\u8def\u5f84\u5217\u8868\uff09\u8f6c\u6362\u4e3a\u53ef\u4ee5\u5728\u7528\u6237\u6d4f\u89c8\u5668\u4e2d\u663e\u793a\u7684\u5f62\u5f0f\uff08\u4f8b\u5982\u4ee5 base64 \u683c\u5f0f\u663e\u793a\u56fe\u50cf\u7684 `Gallery`\uff09\u3002\n\n\u60a8\u53ef\u4ee5\u4f7f\u7528\u6784\u5efa\u56fe\u50cf\u7ec4\u4ef6\u65f6\u7684\u53c2\u6570\u63a7\u5236*\u9884\u5904\u7406*\u3002\u4f8b\u5982\uff0c\u5982\u679c\u60a8\u4f7f\u7528\u4ee5\u4e0b\u53c2\u6570\u5b9e\u4f8b\u5316 `Image` \u7ec4\u4ef6\uff0c\u5b83\u5c06\u5c06\u56fe\u50cf\u8f6c\u6362\u4e3a `PIL` \u7c7b\u578b\uff0c\u5e76\u5c06\u5176\u91cd\u5851\u4e3a`(100, 100)`\uff0c\u800c\u4e0d\u7ba1\u63d0\u4ea4\u65f6\u7684\u539f\u59cb\u5927\u5c0f\u5982\u4f55\uff1a\n\n```py\nimg = gr.Image(shape=(100, 100), type=\"pil\")\n```\n\n\u76f8\u53cd\uff0c\u8fd9\u91cc\u6211\u4eec\u4fdd\u7559\u56fe\u50cf\u7684\u539f\u59cb\u5927\u5c0f\uff0c\u4f46\u5728\u5c06\u5176\u8f6c\u6362\u4e3a numpy \u6570\u7ec4\u4e4b\u524d\u53cd\u8f6c\u989c\u8272\uff1a\n\n```py\nimg = gr.Image(invert_colors=True, type=\"numpy\")\n```\n\n\u540e\u5904\u7406\u8981\u5bb9\u6613\u5f97\u591a\uff01Gradio \u81ea\u52a8\u8bc6\u522b\u8fd4\u56de\u6570\u636e\u7684\u683c\u5f0f\uff08\u4f8b\u5982 `Image` \u662f `numpy` \u6570\u7ec4\u8fd8\u662f `str` \u6587\u4ef6\u8def\u5f84\uff1f\uff09\uff0c\u5e76\u5c06\u5176\u540e\u5904\u7406\u4e3a\u53ef\u4ee5\u7531\u6d4f\u89c8\u5668\u663e\u793a\u7684\u683c\u5f0f\u3002\n\n\u8bf7\u67e5\u770b[\u6587\u6863](https://gradio.app/docs)\uff0c\u4e86\u89e3\u6bcf\u4e2a\u7ec4\u4ef6\u7684\u6240\u6709\u4e0e\u9884\u5904\u7406\u76f8\u5173\u7684\u53c2\u6570\u3002\n\n## \u6837\u5f0f (Styling)\n\nGradio \u4e3b\u9898\u662f\u81ea\u5b9a\u4e49\u5e94\u7528\u7a0b\u5e8f\u5916\u89c2\u548c\u611f\u89c9\u7684\u6700\u7b80\u5355\u65b9\u6cd5\u3002\u60a8\u53ef\u4ee5\u9009\u62e9\u591a\u79cd\u4e3b\u9898\u6216\u521b\u5efa\u81ea\u5df1\u7684\u4e3b\u9898\u3002\u8981\u8fd9\u6837\u505a\uff0c\u8bf7\u5c06 `theme=` \u53c2\u6570\u4f20\u9012\u7ed9 `Interface` \u6784\u9020\u51fd\u6570\u3002\u4f8b\u5982\uff1a\n\n```python\ndemo = gr.Interface(..., theme=gr.themes.Monochrome())\n```\n\nGradio \u5e26\u6709\u4e00\u7ec4\u9884\u5148\u6784\u5efa\u7684\u4e3b\u9898\uff0c\u60a8\u53ef\u4ee5\u4ece `gr.themes.*` \u52a0\u8f7d\u3002\u60a8\u53ef\u4ee5\u6269\u5c55\u8fd9\u4e9b\u4e3b\u9898\u6216\u4ece\u5934\u5f00\u59cb\u521b\u5efa\u81ea\u5df1\u7684\u4e3b\u9898 - \u6709\u5173\u66f4\u591a\u8be6\u7ec6\u4fe1\u606f\uff0c\u8bf7\u53c2\u9605[\u4e3b\u9898\u6307\u5357](https://gradio.app/theming-guide)\u3002\n\n\u8981\u589e\u52a0\u989d\u5916\u7684\u6837\u5f0f\u80fd\u529b\uff0c\u60a8\u53ef\u4ee5 with `css=` \u5173\u952e\u5b57\u5c06\u4efb\u4f55 CSS \u4f20\u9012\u7ed9\u60a8\u7684\u5e94\u7528\u7a0b\u5e8f\u3002\nGradio \u5e94\u7528\u7a0b\u5e8f\u7684\u57fa\u7c7b\u662f `gradio-container`\uff0c\u56e0\u6b64\u4ee5\u4e0b\u662f\u4e00\u4e2a\u66f4\u6539 Gradio \u5e94\u7528\u7a0b\u5e8f\u80cc\u666f\u989c\u8272\u7684\u793a\u4f8b\uff1a\n\n```python\nwith `gr.Interface(css=\".gradio-container {background-color: red}\") as demo:\n    ...\n```\n\n## \u961f\u5217 (Queuing)\n\n\u5982\u679c\u60a8\u7684\u5e94\u7528\u7a0b\u5e8f\u9884\u8ba1\u4f1a\u6709\u5927\u91cf\u6d41\u91cf\uff0c\u8bf7 with `queue()` \u65b9\u6cd5\u6765\u63a7\u5236\u5904\u7406\u901f\u7387\u3002\u8fd9\u5c06\u6392\u961f\u5904\u7406\u8c03\u7528\uff0c\u56e0\u6b64\u4e00\u6b21\u53ea\u5904\u7406\u4e00\u5b9a\u6570\u91cf\u7684\u8bf7\u6c42\u3002\u961f\u5217\u4f7f\u7528 Websockets\uff0c\u8fd8\u53ef\u4ee5\u9632\u6b62\u7f51\u7edc\u8d85\u65f6\uff0c\u56e0\u6b64\u5982\u679c\u60a8\u7684\u51fd\u6570\u7684\u63a8\u7406\u65f6\u95f4\u5f88\u957f\uff08> 1 \u5206\u949f\uff09\uff0c\u5e94\u4f7f\u7528\u961f\u5217\u3002\n\nwith `Interface`\uff1a\n\n```python\ndemo = gr.Interface(...).queue()\ndemo.launch()\n```\n\nwith `Blocks`\uff1a\n\n```python\nwith gr.Blocks() as demo\uff1a\n    #...\ndemo.queue()\ndemo.launch()\n```\n\n\u60a8\u53ef\u4ee5\u901a\u8fc7\u4ee5\u4e0b\u65b9\u5f0f\u63a7\u5236\u4e00\u6b21\u5904\u7406\u7684\u8bf7\u6c42\u6570\u91cf\uff1a\n\n```python\ndemo.queue(concurrency_count=3)\n```\n\n\u67e5\u770b\u6709\u5173\u914d\u7f6e\u5176\u4ed6\u961f\u5217\u53c2\u6570\u7684[\u961f\u5217\u6587\u6863](/docs/#queue)\u3002\n\n\u5728 Blocks \u4e2d\u6307\u5b9a\u4ec5\u5bf9\u67d0\u4e9b\u51fd\u6570\u8fdb\u884c\u6392\u961f\uff1a\n\n```python\nwith gr.Blocks() as demo2\uff1a\n    num1 = gr.Number()\n    num2 = gr.Number()\n    output = gr.Number()\n    gr.Button(\"Add\").click(\n        lambda a, b: a + b, [num1, num2], output)\n    gr.Button(\"Multiply\").click(\n        lambda a, b: a * b, [num1, num2], output, queue=True)\ndemo2.launch()\n```\n\n## \u8fed\u4ee3\u8f93\u51fa (Iterative Outputs)\n\n\u5728\u67d0\u4e9b\u60c5\u51b5\u4e0b\uff0c\u60a8\u53ef\u80fd\u9700\u8981\u4f20\u8f93\u4e00\u7cfb\u5217\u8f93\u51fa\u800c\u4e0d\u662f\u4e00\u6b21\u663e\u793a\u5355\u4e2a\u8f93\u51fa\u3002\u4f8b\u5982\uff0c\u60a8\u53ef\u80fd\u6709\u4e00\u4e2a\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5e0c\u671b\u663e\u793a\u751f\u6210\u7684\u6bcf\u4e2a\u6b65\u9aa4\u7684\u56fe\u50cf\uff0c\u76f4\u5230\u6700\u7ec8\u56fe\u50cf\u3002\u6216\u8005\u60a8\u53ef\u80fd\u6709\u4e00\u4e2a\u804a\u5929\u673a\u5668\u4eba\uff0c\u5b83\u9010\u5b57\u9010\u53e5\u5730\u6d41\u5f0f\u4f20\u8f93\u54cd\u5e94\uff0c\u800c\u4e0d\u662f\u4e00\u6b21\u8fd4\u56de\u5168\u90e8\u54cd\u5e94\u3002\n\n\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u60a8\u53ef\u4ee5\u5c06**\u751f\u6210\u5668**\u51fd\u6570\u63d0\u4f9b\u7ed9 Gradio\uff0c\u800c\u4e0d\u662f\u5e38\u89c4\u51fd\u6570\u3002\u5728 Python \u4e2d\u521b\u5efa\u751f\u6210\u5668\u975e\u5e38\u7b80\u5355\uff1a\u51fd\u6570\u4e0d\u5e94\u8be5\u6709\u4e00\u4e2a\u5355\u72ec\u7684 `return` \u503c\uff0c\u800c\u662f\u5e94\u8be5 with `yield` \u8fde\u7eed\u8fd4\u56de\u4e00\u7cfb\u5217\u503c\u3002\u901a\u5e38\uff0c`yield` \u8bed\u53e5\u653e\u7f6e\u5728\u67d0\u79cd\u5faa\u73af\u4e2d\u3002\u4e0b\u9762\u662f\u4e00\u4e2a\u7b80\u5355\u793a\u4f8b\uff0c\u751f\u6210\u5668\u53ea\u662f\u7b80\u5355\u8ba1\u6570\u5230\u7ed9\u5b9a\u6570\u5b57\uff1a\n\n```python\ndef my_generator(x):\n    for i in range(x):\n        yield i\n```\n\n\u60a8\u4ee5\u4e0e\u5e38\u89c4\u51fd\u6570\u76f8\u540c\u7684\u65b9\u5f0f\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio\u3002\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\uff08\u865a\u62df\u7684\uff09\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5b83\u5728\u8f93\u51fa\u56fe\u50cf\u4e4b\u524d\u751f\u6210\u6570\u4e2a\u6b65\u9aa4\u7684\u566a\u97f3\uff1a\n\n$code_fake_diffusion\n$demo_fake_diffusion\n\n\u8bf7\u6ce8\u610f\uff0c\u6211\u4eec\u5728\u8fed\u4ee3\u5668\u4e2d\u6dfb\u52a0\u4e86 `time.sleep(1)`\uff0c\u4ee5\u521b\u5efa\u6b65\u9aa4\u4e4b\u95f4\u7684\u4eba\u5de5\u6682\u505c\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u89c2\u5bdf\u8fed\u4ee3\u5668\u7684\u6b65\u9aa4\uff08\u5728\u771f\u5b9e\u7684\u56fe\u50cf\u751f\u6210\u6a21\u578b\u4e2d\uff0c\u8fd9\n--New Chunk--\n[Created at: 2025-03-24 13:16:13]\n=predictions, references=references)\n>>> results\n{'exact_match': 100.0, 'f1': 100.0}\n```\n\nYou can find examples of dataset structures by consulting the \"Dataset Preview\" function or the dataset card for a given dataset, and you can see how to use its dedicated evaluation function based on the metric card.\n--New Chunk--\n[Created at: 2025-03-24 13:16:48]\n\u4e3b\u8981\u7279\u70b9\n\n\u8ba9\u6211\u4eec\u6765\u4ecb\u7ecd\u4e00\u4e0b Gradio \u6700\u53d7\u6b22\u8fce\u7684\u4e00\u4e9b\u529f\u80fd\uff01\u8fd9\u91cc\u662f Gradio \u7684\u4e3b\u8981\u7279\u70b9\uff1a\n\n1. [\u6dfb\u52a0\u793a\u4f8b\u8f93\u5165](#example-inputs)\n2. [\u4f20\u9012\u81ea\u5b9a\u4e49\u9519\u8bef\u6d88\u606f](#errors)\n3. [\u6dfb\u52a0\u63cf\u8ff0\u5185\u5bb9](#descriptive-content)\n4. [\u8bbe\u7f6e\u65d7\u6807](#flagging)\n5. [\u9884\u5904\u7406\u548c\u540e\u5904\u7406](#preprocessing-and-postprocessing)\n6. [\u6837\u5f0f\u5316\u6f14\u793a](#styling)\n7. [\u6392\u961f\u7528\u6237](#queuing)\n8. [\u8fed\u4ee3\u8f93\u51fa](#iterative-outputs)\n9. [\u8fdb\u5ea6\u6761](#progress-bars)\n10. [\u6279\u5904\u7406\u51fd\u6570](#batch-functions)\n11. [\u5728\u534f\u4f5c\u7b14\u8bb0\u672c\u4e0a\u8fd0\u884c](#colab-notebooks)\n\n## \u793a\u4f8b\u8f93\u5165\n\n\u60a8\u53ef\u4ee5\u63d0\u4f9b\u7528\u6237\u53ef\u4ee5\u8f7b\u677e\u52a0\u8f7d\u5230 \"Interface\" \u4e2d\u7684\u793a\u4f8b\u6570\u636e\u3002\u8fd9\u5bf9\u4e8e\u6f14\u793a\u6a21\u578b\u671f\u671b\u7684\u8f93\u5165\u7c7b\u578b\u4ee5\u53ca\u6f14\u793a\u6570\u636e\u96c6\u548c\u6a21\u578b\u4e00\u8d77\u63a2\u7d22\u7684\u65b9\u5f0f\u975e\u5e38\u6709\u5e2e\u52a9\u3002\u8981\u52a0\u8f7d\u793a\u4f8b\u6570\u636e\uff0c\u60a8\u53ef\u4ee5\u5c06\u5d4c\u5957\u5217\u8868\u63d0\u4f9b\u7ed9 Interface \u6784\u9020\u51fd\u6570\u7684 `examples=` \u5173\u952e\u5b57\u53c2\u6570\u3002\u5916\u90e8\u5217\u8868\u4e2d\u7684\u6bcf\u4e2a\u5b50\u5217\u8868\u8868\u793a\u4e00\u4e2a\u6570\u636e\u6837\u672c\uff0c\u5b50\u5217\u8868\u4e2d\u7684\u6bcf\u4e2a\u5143\u7d20\u8868\u793a\u6bcf\u4e2a\u8f93\u5165\u7ec4\u4ef6\u7684\u8f93\u5165\u3002\u6709\u5173\u6bcf\u4e2a\u7ec4\u4ef6\u7684\u793a\u4f8b\u6570\u636e\u683c\u5f0f\u5728[Docs](https://gradio.app/docs#components)\u4e2d\u6709\u8bf4\u660e\u3002\n\n$code_calculator\n$demo_calculator\n\n\u60a8\u53ef\u4ee5\u5c06\u5927\u578b\u6570\u636e\u96c6\u52a0\u8f7d\u5230\u793a\u4f8b\u4e2d\uff0c\u901a\u8fc7 Gradio \u6d4f\u89c8\u548c\u4e0e\u6570\u636e\u96c6\u8fdb\u884c\u4ea4\u4e92\u3002\u793a\u4f8b\u5c06\u81ea\u52a8\u5206\u9875\uff08\u53ef\u4ee5\u901a\u8fc7 Interface \u7684 `examples_per_page` \u53c2\u6570\u8fdb\u884c\u914d\u7f6e\uff09\u3002\n\n\u7ee7\u7eed\u4e86\u89e3\u793a\u4f8b\uff0c\u8bf7\u53c2\u9605[\u66f4\u591a\u793a\u4f8b](https://gradio.app/more-on-examples)\u6307\u5357\u3002\n\n## \u9519\u8bef\n\n\u60a8\u5e0c\u671b\u5411\u7528\u6237\u4f20\u9012\u81ea\u5b9a\u4e49\u9519\u8bef\u6d88\u606f\u3002\u4e3a\u6b64\uff0cwith `gr.Error(\"custom message\")` \u6765\u663e\u793a\u9519\u8bef\u6d88\u606f\u3002\u5982\u679c\u5728\u4e0a\u9762\u7684\u8ba1\u7b97\u5668\u793a\u4f8b\u4e2d\u5c1d\u8bd5\u9664\u4ee5\u96f6\uff0c\u5c06\u663e\u793a\u81ea\u5b9a\u4e49\u9519\u8bef\u6d88\u606f\u7684\u5f39\u51fa\u6a21\u6001\u7a97\u53e3\u3002\u4e86\u89e3\u6709\u5173\u9519\u8bef\u7684\u66f4\u591a\u4fe1\u606f\uff0c\u8bf7\u53c2\u9605[\u6587\u6863](https://gradio.app/docs#error)\u3002\n\n## \u63cf\u8ff0\u6027\u5185\u5bb9\n\n\u5728\u524d\u9762\u7684\u793a\u4f8b\u4e2d\uff0c\u60a8\u53ef\u80fd\u5df2\u7ecf\u6ce8\u610f\u5230 Interface \u6784\u9020\u51fd\u6570\u4e2d\u7684 `title=` \u548c `description=` \u5173\u952e\u5b57\u53c2\u6570\uff0c\u5e2e\u52a9\u7528\u6237\u4e86\u89e3\u60a8\u7684\u5e94\u7528\u7a0b\u5e8f\u3002\n\nInterface \u6784\u9020\u51fd\u6570\u4e2d\u6709\u4e09\u4e2a\u53c2\u6570\u7528\u4e8e\u6307\u5b9a\u6b64\u5185\u5bb9\u5e94\u653e\u7f6e\u5728\u54ea\u91cc\uff1a\n\n- `title`\uff1a\u63a5\u53d7\u6587\u672c\uff0c\u5e76\u53ef\u4ee5\u5c06\u5176\u663e\u793a\u5728\u754c\u9762\u7684\u9876\u90e8\uff0c\u4e5f\u5c06\u6210\u4e3a\u9875\u9762\u6807\u9898\u3002\n- `description`\uff1a\u63a5\u53d7\u6587\u672c\u3001Markdown \u6216 HTML\uff0c\u5e76\u5c06\u5176\u653e\u7f6e\u5728\u6807\u9898\u6b63\u4e0b\u65b9\u3002\n- `article`\uff1a\u4e5f\u63a5\u53d7\u6587\u672c\u3001Markdown \u6216 HTML\uff0c\u5e76\u5c06\u5176\u653e\u7f6e\u5728\u754c\u9762\u4e0b\u65b9\u3002\n\n![annotated](/assets/guides/annotated.png)\n\n\u5982\u679c\u60a8\u4f7f\u7528\u7684\u662f `Blocks` API\uff0c\u5219\u53ef\u4ee5 with `gr.Markdown(...)` \u6216 `gr.HTML(...)` \u7ec4\u4ef6\u5728\u4efb\u4f55\u4f4d\u7f6e\u63d2\u5165\u6587\u672c\u3001Markdown \u6216 HTML\uff0c\u5176\u4e2d\u63cf\u8ff0\u6027\u5185\u5bb9\u4f4d\u4e8e `Component` \u6784\u9020\u51fd\u6570\u5185\u90e8\u3002\n\n\u53e6\u4e00\u4e2a\u6709\u7528\u7684\u5173\u952e\u5b57\u53c2\u6570\u662f `label=`\uff0c\u5b83\u5b58\u5728\u4e8e\u6bcf\u4e2a `Component` \u4e2d\u3002\u8fd9\u4fee\u6539\u4e86\u6bcf\u4e2a `Component` \u9876\u90e8\u7684\u6807\u7b7e\u6587\u672c\u3002\u8fd8\u53ef\u4ee5\u4e3a\u8bf8\u5982 `Textbox` \u6216 `Radio` \u4e4b\u7c7b\u7684\u8868\u5355\u5143\u7d20\u6dfb\u52a0 `info=` \u5173\u952e\u5b57\u53c2\u6570\uff0c\u4ee5\u63d0\u4f9b\u6709\u5173\u5176\u7528\u6cd5\u7684\u8fdb\u4e00\u6b65\u4fe1\u606f\u3002\n\n```python\ngr.Number(label='\u5e74\u9f84', info='\u4ee5\u5e74\u4e3a\u5355\u4f4d\uff0c\u5fc5\u987b\u5927\u4e8e0')\n```\n\n## \u65d7\u6807\n\n\u9ed8\u8ba4\u60c5\u51b5\u4e0b\uff0c\"Interface\" \u5c06\u6709\u4e00\u4e2a \"Flag\" \u6309\u94ae\u3002\u5f53\u7528\u6237\u6d4b\u8bd5\u60a8\u7684 `Interface` \u65f6\uff0c\u5982\u679c\u770b\u5230\u6709\u8da3\u7684\u8f93\u51fa\uff0c\u4f8b\u5982\u9519\u8bef\u6216\u610f\u5916\u7684\u6a21\u578b\u884c\u4e3a\uff0c\u4ed6\u4eec\u53ef\u4ee5\u5c06\u8f93\u5165\u6807\u8bb0\u4e3a\u60a8\u8fdb\u884c\u67e5\u770b\u3002\u5728\u7531 `Interface` \u6784\u9020\u51fd\u6570\u7684 `flagging_dir=` \u53c2\u6570\u63d0\u4f9b\u7684\u76ee\u5f55\u4e2d\uff0c\u5c06\u8bb0\u5f55\u6807\u8bb0\u7684\u8f93\u5165\u5230\u4e00\u4e2a CSV \u6587\u4ef6\u4e2d\u3002\u5982\u679c\u754c\u9762\u6d89\u53ca\u6587\u4ef6\u6570\u636e\uff0c\u4f8b\u5982\u56fe\u50cf\u548c\u97f3\u9891\u7ec4\u4ef6\uff0c\u5c06\u521b\u5efa\u6587\u4ef6\u5939\u6765\u5b58\u50a8\u8fd9\u4e9b\u6807\u8bb0\u7684\u6570\u636e\u3002\n\n\u4f8b\u5982\uff0c\u5bf9\u4e8e\u4e0a\u9762\u663e\u793a\u7684\u8ba1\u7b97\u5668\u754c\u9762\uff0c\u6211\u4eec\u5c06\u5728\u4e0b\u9762\u7684\u65d7\u6807\u76ee\u5f55\u4e2d\u5b58\u50a8\u6807\u8bb0\u7684\u6570\u636e\uff1a\n\n```directory\n+-- calculator.py\n+-- flagged/\n|   +-- logs.csv\n```\n\n_flagged/logs.csv_\n\n```csv\nnum1,operation,num2,Output\n5,add,7,12\n6,subtract,1.5,4.5\n```\n\n\u4e0e\u65e9\u671f\u663e\u793a\u7684\u51b7\u8272\u754c\u9762\u76f8\u5bf9\u5e94\uff0c\u6211\u4eec\u5c06\u5728\u4e0b\u9762\u7684\u65d7\u6807\u76ee\u5f55\u4e2d\u5b58\u50a8\u6807\u8bb0\u7684\u6570\u636e\uff1a\n\n```directory\n+-- sepia.py\n+-- flagged/\n|   +-- logs.csv\n|   +-- im/\n|   |   +-- 0.png\n|   |   +-- 1.png\n|   +-- Output/\n|   |   +-- 0.png\n|   |   +-- 1.png\n```\n\n_flagged/logs.csv_\n\n```csv\nim,Output\nim/0.png,Output/0.png\nim/1.png,Output/1.png\n```\n\n\u5982\u679c\u60a8\u5e0c\u671b\u7528\u6237\u63d0\u4f9b\u65d7\u6807\u539f\u56e0\uff0c\u53ef\u4ee5\u5c06\u5b57\u7b26\u4e32\u5217\u8868\u4f20\u9012\u7ed9 Interface \u7684 `flagging_options` \u53c2\u6570\u3002\u7528\u6237\u5728\u8fdb\u884c\u65d7\u6807\u65f6\u5fc5\u987b\u9009\u62e9\u5176\u4e2d\u4e00\u4e2a\u5b57\u7b26\u4e32\uff0c\u8fd9\u5c06\u4f5c\u4e3a\u9644\u52a0\u5217\u4fdd\u5b58\u5230 CSV \u4e2d\u3002\n\n## \u9884\u5904\u7406\u548c\u540e\u5904\u7406 (Preprocessing and Postprocessing)\n\n![annotated](/assets/img/dataflow.svg)\n\n\u5982\u60a8\u6240\u89c1\uff0cGradio \u5305\u62ec\u53ef\u4ee5\u5904\u7406\u5404\u79cd\u4e0d\u540c\u6570\u636e\u7c7b\u578b\u7684\u7ec4\u4ef6\uff0c\u4f8b\u5982\u56fe\u50cf\u3001\u97f3\u9891\u548c\u89c6\u9891\u3002\u5927\u591a\u6570\u7ec4\u4ef6\u90fd\u53ef\u4ee5\u7528\u4f5c\u8f93\u5165\u6216\u8f93\u51fa\u3002\n\n\u5f53\u7ec4\u4ef6\u7528\u4f5c\u8f93\u5165\u65f6\uff0cGradio \u81ea\u52a8\u5904\u7406*\u9884\u5904\u7406*\uff0c\u5c06\u6570\u636e\u4ece\u7528\u6237"
        }
    },
    {
        "sample_idx": 119,
        "question": "What is the name of the Plotly module used to create the map chart?",
        "answer": "plotly.graph_objects",
        "rag_answer": "There is no mention of Plotly or map charts in the provided Data Sources. The Data Sources seem to be related to Gradio, a platform for creating and deploying machine learning models, and do not mention Plotly or map charts. If you have any further questions or context about Gradio, I'd be happy to help.",
        "rag_score": 1,
        "rag_feedback": "The system's response is completely incorrect, inaccurate, and/or not factual. The question asks about the Plotly module used to create a map chart, but the system's response is a lengthy text about Gradio, a platform for creating and deploying machine learning models, which is unrelated to the question.",
        "rag_context": {
            "kg_context": "-----Entities-----\n    ```csv\n    id,\tentity,\ttype,\tdescription,\trankcreated_at\n1,\tGradio,organization,Gradio is a platform that supports state in Blocks, providing features such as global state and session state.<SEP>Gradio is an interface that provides various features for demonstrating models, including adding example inputs, custom error messages, descriptive content, flagging, and more.<SEP>Gradio is an organization that provides a platform for building and deploying machine learning models.<SEP>Gradio is an organization that provides a platform for creating and deploying machine learning models.<SEP>Gradio is an organization that provides a demo for blocks_random_slider, and its library is used to create interactive interfaces.,36,2025-03-24 13:18:20\n2,\tJupyter,category,Jupyter is a platform for interactive computing and data science.,2,2025-03-24 13:18:20\n3,\tnumpy,technology,numpy is a type of numerical computing library that can be used with Gradio components.,1,2025-03-24 13:18:20\n4,\tlabel_mask,concept,label_mask is a technique for masking out unwanted data in machine learning models.,1,2025-03-24 13:18:20\n5,\tmean_loss,concept,mean_loss is a measure of the average loss in a machine learning model.,1,2025-03-24 13:18:20\n6,\tfunc,event,func is an event that occurs when the button is clicked, executing a specific function.,1,UNKNOWN\n7,\tJupyter,category,Jupyter is a platform for interactive computing and data science.,2,UNKNOWN\n8,\tnumpy,technology,numpy is a type of numerical computing library that can be used with Gradio components.,1,UNKNOWN\n    ```\n    -----Relationships-----\n    ```csv\n    id,\tsource,\ttarget,\tdescription,\tkeywords,\tweight,\trank,\tcreated_at\n1,\tGradio,Jupyter,Gradio can be run on Jupyter notebooks.,platform compatibility, interactive computing,7.0,38,2025-03-24 13:17:31\n2,\tGradio,numpy,Gradio can use numpy library for numerical computing.,library integration, numerical computing,14.0,37,2025-03-24 13:17:31\n3,\tlabel_mask,mean_loss,label_mask is used to calculate mean_loss in machine learning models.,calculation, data processing,2.0,2,2025-03-24 13:18:20\n4,\tGradio,Jupyter,Gradio can be run on Jupyter notebooks.,platform compatibility, interactive computing,7.0,38,UNKNOWN\n5,\tGradio,numpy,Gradio can use numpy library for numerical computing.,library integration, numerical computing,14.0,37,UNKNOWN\n6,\tGradio Demo,func,func is an event that occurs in Gradio Demo when the button is clicked.,event, event,8.0,9,UNKNOWN\n7,\tJupyter,notebooks,Notebooks are a type of interactive document used in Jupyter.,document type, interactive computing,7.0,3,UNKNOWN\n    ```\n    -----Sources-----\n    ```csv\n    id,\tcontent\n1,\t\u4e0e\u5e38\u89c4\u51fd\u6570\u76f8\u540c\u7684\u65b9\u5f0f\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio\u3002\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\uff08\u865a\u62df\u7684\uff09\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5b83\u5728\u8f93\u51fa\u56fe\u50cf\u4e4b\u524d\u751f\u6210\u6570\u4e2a\u6b65\u9aa4\u7684\u566a\u97f3\uff1a\n\n$code_fake_diffusion\n$demo_fake_diffusion\n\n\u8bf7\u6ce8\u610f\uff0c\u6211\u4eec\u5728\u8fed\u4ee3\u5668\u4e2d\u6dfb\u52a0\u4e86 `time.sleep(1)`\uff0c\u4ee5\u521b\u5efa\u6b65\u9aa4\u4e4b\u95f4\u7684\u4eba\u5de5\u6682\u505c\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u89c2\u5bdf\u8fed\u4ee3\u5668\u7684\u6b65\u9aa4\uff08\u5728\u771f\u5b9e\u7684\u56fe\u50cf\u751f\u6210\u6a21\u578b\u4e2d\uff0c\u8fd9\u53ef\u80fd\u662f\u4e0d\u5fc5\u8981\u7684\uff09\u3002\n\n\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio **\u9700\u8981**\u5728\u5e95\u5c42 Interface \u6216 Blocks \u4e2d\u542f\u7528\u961f\u5217\uff08\u8bf7\u53c2\u9605\u4e0a\u9762\u7684\u961f\u5217\u90e8\u5206\uff09\u3002\n\n## \u8fdb\u5ea6\u6761\n\nGradio \u652f\u6301\u521b\u5efa\u81ea\u5b9a\u4e49\u8fdb\u5ea6\u6761\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u81ea\u5b9a\u4e49\u548c\u63a7\u5236\u5411\u7528\u6237\u663e\u793a\u7684\u8fdb\u5ea6\u66f4\u65b0\u3002\u8981\u542f\u7528\u6b64\u529f\u80fd\uff0c\u53ea\u9700\u4e3a\u65b9\u6cd5\u6dfb\u52a0\u4e00\u4e2a\u9ed8\u8ba4\u503c\u4e3a `gr.Progress` \u5b9e\u4f8b\u7684\u53c2\u6570\u5373\u53ef\u3002\u7136\u540e\uff0c\u60a8\u53ef\u4ee5\u76f4\u63a5\u8c03\u7528\u6b64\u5b9e\u4f8b\u5e76\u4f20\u5165 0 \u5230 1 \u4e4b\u95f4\u7684\u6d6e\u70b9\u6570\u6765\u66f4\u65b0\u8fdb\u5ea6\u7ea7\u522b\uff0c\u6216\u8005 with `Progress` \u5b9e\u4f8b\u7684 `tqdm()` \u65b9\u6cd5\u6765\u8ddf\u8e2a\u53ef\u8fed\u4ee3\u5bf9\u8c61\u4e0a\u7684\u8fdb\u5ea6\uff0c\u5982\u4e0b\u6240\u793a\u3002\u5fc5\u987b\u542f\u7528\u961f\u5217\u4ee5\u8fdb\u884c\u8fdb\u5ea6\u66f4\u65b0\u3002\n\n$code_progress_simple\n$demo_progress_simple\n\n\u5982\u679c\u60a8 with `tqdm` \u5e93\uff0c\u5e76\u4e14\u5e0c\u671b\u4ece\u51fd\u6570\u5185\u90e8\u7684\u4efb\u4f55 `tqdm.tqdm` \u81ea\u52a8\u62a5\u544a\u8fdb\u5ea6\u66f4\u65b0\uff0c\u8bf7\u5c06\u9ed8\u8ba4\u53c2\u6570\u8bbe\u7f6e\u4e3a `gr.Progress(track_tqdm=True)`\uff01\n\n## \u6279\u5904\u7406\u51fd\u6570 (Batch Functions)\n\nGradio \u652f\u6301\u4f20\u9012*\u6279\u5904\u7406*\u51fd\u6570\u3002\u6279\u5904\u7406\u51fd\u6570\u53ea\u662f\u63a5\u53d7\u8f93\u5165\u5217\u8868\u5e76\u8fd4\u56de\u9884\u6d4b\u5217\u8868\u7684\u51fd\u6570\u3002\n\n\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\u6279\u5904\u7406\u51fd\u6570\uff0c\u5b83\u63a5\u53d7\u4e24\u4e2a\u8f93\u5165\u5217\u8868\uff08\u4e00\u4e2a\u5355\u8bcd\u5217\u8868\u548c\u4e00\u4e2a\u6574\u6570\u5217\u8868\uff09\uff0c\u5e76\u8fd4\u56de\u4fee\u526a\u8fc7\u7684\u5355\u8bcd\u5217\u8868\u4f5c\u4e3a\u8f93\u51fa\uff1a\n\n```python\nimport time\n\ndef trim_words(words, lens):\n    trimmed_words = []\n    time.sleep(5)\n    for w, l in zip(words, lens):\n        trimmed_words.append(w[:int(l)])\n    return [trimmed_words]\n    for w, l in zip(words, lens):\n```\n\n\u4f7f\u7528\u6279\u5904\u7406\u51fd\u6570\u7684\u4f18\u70b9\u662f\uff0c\u5982\u679c\u542f\u7528\u4e86\u961f\u5217\uff0cGradio \u670d\u52a1\u5668\u53ef\u4ee5\u81ea\u52a8*\u6279\u5904\u7406*\u4f20\u5165\u7684\u8bf7\u6c42\u5e76\u5e76\u884c\u5904\u7406\u5b83\u4eec\uff0c\u4ece\u800c\u53ef\u80fd\u52a0\u5feb\u6f14\u793a\u901f\u5ea6\u3002\u4ee5\u4e0b\u662f Gradio \u4ee3\u7801\u7684\u793a\u4f8b\uff08\u8bf7\u6ce8\u610f `batch=True` \u548c `max_batch_size=16` - \u8fd9\u4e24\u4e2a\u53c2\u6570\u90fd\u53ef\u4ee5\u4f20\u9012\u7ed9\u4e8b\u4ef6\u89e6\u53d1\u5668\u6216 `Interface` \u7c7b\uff09\n\nwith `Interface`\uff1a\n\n```python\ndemo = gr.Interface(trim_words, [\"textbox\", \"number\"], [\"output\"],\n                    batch=True, max_batch_size=16)\ndemo.queue()\ndemo.launch()\n```\n\nwith `Blocks`\uff1a\n\n```python\nimport gradio as gr\n\nwith gr.Blocks() as demo:\n    with gr.Row():\n        word = gr.Textbox(label=\"word\")\n        leng = gr.Number(label=\"leng\")\n        output = gr.Textbox(label=\"Output\")\n    with gr.Row():\n        run = gr.Button()\n\n    event = run.click(trim_words, [word, leng], output, batch=True, max_batch_size=16)\n\ndemo.queue()\ndemo.launch()\n```\n\n\u5728\u4e0a\u9762\u7684\u793a\u4f8b\u4e2d\uff0c\u53ef\u4ee5\u5e76\u884c\u5904\u7406 16 \u4e2a\u8bf7\u6c42\uff08\u603b\u63a8\u7406\u65f6\u95f4\u4e3a 5 \u79d2\uff09\uff0c\u800c\u4e0d\u662f\u5206\u522b\u5904\u7406\u6bcf\u4e2a\u8bf7\u6c42\uff08\u603b\u63a8\u7406\u65f6\u95f4\u4e3a 80 \u79d2\uff09\u3002\u8bb8\u591a Hugging Face \u7684 `transformers` \u548c `diffusers` \u6a21\u578b\u5728 Gradio \u7684\u6279\u5904\u7406\u6a21\u5f0f\u4e0b\u81ea\u7136\u5de5\u4f5c\uff1a\u8fd9\u662f[\u4f7f\u7528\u6279\u5904\u7406\u751f\u6210\u56fe\u50cf\u7684\u793a\u4f8b\u6f14\u793a](https://github.com/gradio-app/gradio/blob/main/demo/diffusers_with_batching/run.py)\n\n\u6ce8\u610f\uff1a\u4f7f\u7528 Gradio \u7684\u6279\u5904\u7406\u51fd\u6570 **requires** \u5728\u5e95\u5c42 Interface \u6216 Blocks \u4e2d\u542f\u7528\u961f\u5217\uff08\u8bf7\u53c2\u9605\u4e0a\u9762\u7684\u961f\u5217\u90e8\u5206\uff09\u3002\n\n## Gradio \u7b14\u8bb0\u672c (Colab Notebooks)\n\nGradio \u53ef\u4ee5\u5728\u4efb\u4f55\u8fd0\u884c Python \u7684\u5730\u65b9\u8fd0\u884c\uff0c\u5305\u62ec\u672c\u5730 Jupyter \u7b14\u8bb0\u672c\u548c\u534f\u4f5c\u7b14\u8bb0\u672c\uff0c\u5982[Google Colab](https://colab.research.google.com/)\u3002\u5bf9\u4e8e\u672c\u5730 Jupyter \u7b14\u8bb0\u672c\u548c Google Colab \u7b14\u8bb0\u672c\uff0cGradio \u5728\u672c\u5730\u670d\u52a1\u5668\u4e0a\u8fd0\u884c\uff0c\u60a8\u53ef\u4ee5\u5728\u6d4f\u89c8\u5668\u4e2d\u4e0e\u4e4b\u4ea4\u4e92\u3002\uff08\u6ce8\u610f\uff1a\u5bf9\u4e8e Google Colab\uff0c\u8fd9\u662f\u901a\u8fc7[\u670d\u52a1\u5de5\u4f5c\u5668\u96a7\u9053](https://github.com/tensorflow/tensorboard/blob/master/docs/design/colab_integration.md)\u5b9e\u73b0\u7684\uff0c\u60a8\u7684\u6d4f\u89c8\u5668\u9700\u8981\u542f\u7528 cookies\u3002\uff09\u5bf9\u4e8e\u5176\u4ed6\u8fdc\u7a0b\u7b14\u8bb0\u672c\uff0cGradio \u4e5f\u5c06\u5728\u670d\u52a1\u5668\u4e0a\u8fd0\u884c\uff0c\u4f46\u60a8\u9700\u8981\u4f7f\u7528[SSH \u96a7\u9053](https://coderwall.com/p/ohk6cg/remote-access-to-ipython-notebooks-via-ssh)\u5728\u672c\u5730\u6d4f\u89c8\u5668\u4e2d\u67e5\u770b\u5e94\u7528\u7a0b\u5e8f\u3002\u901a\u5e38\uff0c\u66f4\u7b80\u5355\u7684\u9009\u62e9\u662f\u4f7f\u7528 Gradio \u5185\u7f6e\u7684\u516c\u5171\u94fe\u63a5\uff0c[\u5728\u4e0b\u4e00\u7bc7\u6307\u5357\u4e2d\u8ba8\u8bba](/sharing-your-app/#sharing-demos)\u3002\n2,\t\u65f6\u5fc5\u987b\u9009\u62e9\u5176\u4e2d\u4e00\u4e2a\u5b57\u7b26\u4e32\uff0c\u8fd9\u5c06\u4f5c\u4e3a\u9644\u52a0\u5217\u4fdd\u5b58\u5230 CSV \u4e2d\u3002\n\n## \u9884\u5904\u7406\u548c\u540e\u5904\u7406 (Preprocessing and Postprocessing)\n\n![annotated](/assets/img/dataflow.svg)\n\n\u5982\u60a8\u6240\u89c1\uff0cGradio \u5305\u62ec\u53ef\u4ee5\u5904\u7406\u5404\u79cd\u4e0d\u540c\u6570\u636e\u7c7b\u578b\u7684\u7ec4\u4ef6\uff0c\u4f8b\u5982\u56fe\u50cf\u3001\u97f3\u9891\u548c\u89c6\u9891\u3002\u5927\u591a\u6570\u7ec4\u4ef6\u90fd\u53ef\u4ee5\u7528\u4f5c\u8f93\u5165\u6216\u8f93\u51fa\u3002\n\n\u5f53\u7ec4\u4ef6\u7528\u4f5c\u8f93\u5165\u65f6\uff0cGradio \u81ea\u52a8\u5904\u7406*\u9884\u5904\u7406*\uff0c\u5c06\u6570\u636e\u4ece\u7528\u6237\u6d4f\u89c8\u5668\u53d1\u9001\u7684\u7c7b\u578b\uff08\u4f8b\u5982\u7f51\u7edc\u6444\u50cf\u5934\u5feb\u7167\u7684 base64 \u8868\u793a\uff09\u8f6c\u6362\u4e3a\u60a8\u7684\u51fd\u6570\u53ef\u4ee5\u63a5\u53d7\u7684\u5f62\u5f0f\uff08\u4f8b\u5982 `numpy` \u6570\u7ec4\uff09\u3002\n\n\u540c\u6837\uff0c\u5f53\u7ec4\u4ef6\u7528\u4f5c\u8f93\u51fa\u65f6\uff0cGradio \u81ea\u52a8\u5904\u7406*\u540e\u5904\u7406*\uff0c\u5c06\u6570\u636e\u4ece\u51fd\u6570\u8fd4\u56de\u7684\u5f62\u5f0f\uff08\u4f8b\u5982\u56fe\u50cf\u8def\u5f84\u5217\u8868\uff09\u8f6c\u6362\u4e3a\u53ef\u4ee5\u5728\u7528\u6237\u6d4f\u89c8\u5668\u4e2d\u663e\u793a\u7684\u5f62\u5f0f\uff08\u4f8b\u5982\u4ee5 base64 \u683c\u5f0f\u663e\u793a\u56fe\u50cf\u7684 `Gallery`\uff09\u3002\n\n\u60a8\u53ef\u4ee5\u4f7f\u7528\u6784\u5efa\u56fe\u50cf\u7ec4\u4ef6\u65f6\u7684\u53c2\u6570\u63a7\u5236*\u9884\u5904\u7406*\u3002\u4f8b\u5982\uff0c\u5982\u679c\u60a8\u4f7f\u7528\u4ee5\u4e0b\u53c2\u6570\u5b9e\u4f8b\u5316 `Image` \u7ec4\u4ef6\uff0c\u5b83\u5c06\u5c06\u56fe\u50cf\u8f6c\u6362\u4e3a `PIL` \u7c7b\u578b\uff0c\u5e76\u5c06\u5176\u91cd\u5851\u4e3a`(100, 100)`\uff0c\u800c\u4e0d\u7ba1\u63d0\u4ea4\u65f6\u7684\u539f\u59cb\u5927\u5c0f\u5982\u4f55\uff1a\n\n```py\nimg = gr.Image(shape=(100, 100), type=\"pil\")\n```\n\n\u76f8\u53cd\uff0c\u8fd9\u91cc\u6211\u4eec\u4fdd\u7559\u56fe\u50cf\u7684\u539f\u59cb\u5927\u5c0f\uff0c\u4f46\u5728\u5c06\u5176\u8f6c\u6362\u4e3a numpy \u6570\u7ec4\u4e4b\u524d\u53cd\u8f6c\u989c\u8272\uff1a\n\n```py\nimg = gr.Image(invert_colors=True, type=\"numpy\")\n```\n\n\u540e\u5904\u7406\u8981\u5bb9\u6613\u5f97\u591a\uff01Gradio \u81ea\u52a8\u8bc6\u522b\u8fd4\u56de\u6570\u636e\u7684\u683c\u5f0f\uff08\u4f8b\u5982 `Image` \u662f `numpy` \u6570\u7ec4\u8fd8\u662f `str` \u6587\u4ef6\u8def\u5f84\uff1f\uff09\uff0c\u5e76\u5c06\u5176\u540e\u5904\u7406\u4e3a\u53ef\u4ee5\u7531\u6d4f\u89c8\u5668\u663e\u793a\u7684\u683c\u5f0f\u3002\n\n\u8bf7\u67e5\u770b[\u6587\u6863](https://gradio.app/docs)\uff0c\u4e86\u89e3\u6bcf\u4e2a\u7ec4\u4ef6\u7684\u6240\u6709\u4e0e\u9884\u5904\u7406\u76f8\u5173\u7684\u53c2\u6570\u3002\n\n## \u6837\u5f0f (Styling)\n\nGradio \u4e3b\u9898\u662f\u81ea\u5b9a\u4e49\u5e94\u7528\u7a0b\u5e8f\u5916\u89c2\u548c\u611f\u89c9\u7684\u6700\u7b80\u5355\u65b9\u6cd5\u3002\u60a8\u53ef\u4ee5\u9009\u62e9\u591a\u79cd\u4e3b\u9898\u6216\u521b\u5efa\u81ea\u5df1\u7684\u4e3b\u9898\u3002\u8981\u8fd9\u6837\u505a\uff0c\u8bf7\u5c06 `theme=` \u53c2\u6570\u4f20\u9012\u7ed9 `Interface` \u6784\u9020\u51fd\u6570\u3002\u4f8b\u5982\uff1a\n\n```python\ndemo = gr.Interface(..., theme=gr.themes.Monochrome())\n```\n\nGradio \u5e26\u6709\u4e00\u7ec4\u9884\u5148\u6784\u5efa\u7684\u4e3b\u9898\uff0c\u60a8\u53ef\u4ee5\u4ece `gr.themes.*` \u52a0\u8f7d\u3002\u60a8\u53ef\u4ee5\u6269\u5c55\u8fd9\u4e9b\u4e3b\u9898\u6216\u4ece\u5934\u5f00\u59cb\u521b\u5efa\u81ea\u5df1\u7684\u4e3b\u9898 - \u6709\u5173\u66f4\u591a\u8be6\u7ec6\u4fe1\u606f\uff0c\u8bf7\u53c2\u9605[\u4e3b\u9898\u6307\u5357](https://gradio.app/theming-guide)\u3002\n\n\u8981\u589e\u52a0\u989d\u5916\u7684\u6837\u5f0f\u80fd\u529b\uff0c\u60a8\u53ef\u4ee5 with `css=` \u5173\u952e\u5b57\u5c06\u4efb\u4f55 CSS \u4f20\u9012\u7ed9\u60a8\u7684\u5e94\u7528\u7a0b\u5e8f\u3002\nGradio \u5e94\u7528\u7a0b\u5e8f\u7684\u57fa\u7c7b\u662f `gradio-container`\uff0c\u56e0\u6b64\u4ee5\u4e0b\u662f\u4e00\u4e2a\u66f4\u6539 Gradio \u5e94\u7528\u7a0b\u5e8f\u80cc\u666f\u989c\u8272\u7684\u793a\u4f8b\uff1a\n\n```python\nwith `gr.Interface(css=\".gradio-container {background-color: red}\") as demo:\n    ...\n```\n\n## \u961f\u5217 (Queuing)\n\n\u5982\u679c\u60a8\u7684\u5e94\u7528\u7a0b\u5e8f\u9884\u8ba1\u4f1a\u6709\u5927\u91cf\u6d41\u91cf\uff0c\u8bf7 with `queue()` \u65b9\u6cd5\u6765\u63a7\u5236\u5904\u7406\u901f\u7387\u3002\u8fd9\u5c06\u6392\u961f\u5904\u7406\u8c03\u7528\uff0c\u56e0\u6b64\u4e00\u6b21\u53ea\u5904\u7406\u4e00\u5b9a\u6570\u91cf\u7684\u8bf7\u6c42\u3002\u961f\u5217\u4f7f\u7528 Websockets\uff0c\u8fd8\u53ef\u4ee5\u9632\u6b62\u7f51\u7edc\u8d85\u65f6\uff0c\u56e0\u6b64\u5982\u679c\u60a8\u7684\u51fd\u6570\u7684\u63a8\u7406\u65f6\u95f4\u5f88\u957f\uff08> 1 \u5206\u949f\uff09\uff0c\u5e94\u4f7f\u7528\u961f\u5217\u3002\n\nwith `Interface`\uff1a\n\n```python\ndemo = gr.Interface(...).queue()\ndemo.launch()\n```\n\nwith `Blocks`\uff1a\n\n```python\nwith gr.Blocks() as demo\uff1a\n    #...\ndemo.queue()\ndemo.launch()\n```\n\n\u60a8\u53ef\u4ee5\u901a\u8fc7\u4ee5\u4e0b\u65b9\u5f0f\u63a7\u5236\u4e00\u6b21\u5904\u7406\u7684\u8bf7\u6c42\u6570\u91cf\uff1a\n\n```python\ndemo.queue(concurrency_count=3)\n```\n\n\u67e5\u770b\u6709\u5173\u914d\u7f6e\u5176\u4ed6\u961f\u5217\u53c2\u6570\u7684[\u961f\u5217\u6587\u6863](/docs/#queue)\u3002\n\n\u5728 Blocks \u4e2d\u6307\u5b9a\u4ec5\u5bf9\u67d0\u4e9b\u51fd\u6570\u8fdb\u884c\u6392\u961f\uff1a\n\n```python\nwith gr.Blocks() as demo2\uff1a\n    num1 = gr.Number()\n    num2 = gr.Number()\n    output = gr.Number()\n    gr.Button(\"Add\").click(\n        lambda a, b: a + b, [num1, num2], output)\n    gr.Button(\"Multiply\").click(\n        lambda a, b: a * b, [num1, num2], output, queue=True)\ndemo2.launch()\n```\n\n## \u8fed\u4ee3\u8f93\u51fa (Iterative Outputs)\n\n\u5728\u67d0\u4e9b\u60c5\u51b5\u4e0b\uff0c\u60a8\u53ef\u80fd\u9700\u8981\u4f20\u8f93\u4e00\u7cfb\u5217\u8f93\u51fa\u800c\u4e0d\u662f\u4e00\u6b21\u663e\u793a\u5355\u4e2a\u8f93\u51fa\u3002\u4f8b\u5982\uff0c\u60a8\u53ef\u80fd\u6709\u4e00\u4e2a\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5e0c\u671b\u663e\u793a\u751f\u6210\u7684\u6bcf\u4e2a\u6b65\u9aa4\u7684\u56fe\u50cf\uff0c\u76f4\u5230\u6700\u7ec8\u56fe\u50cf\u3002\u6216\u8005\u60a8\u53ef\u80fd\u6709\u4e00\u4e2a\u804a\u5929\u673a\u5668\u4eba\uff0c\u5b83\u9010\u5b57\u9010\u53e5\u5730\u6d41\u5f0f\u4f20\u8f93\u54cd\u5e94\uff0c\u800c\u4e0d\u662f\u4e00\u6b21\u8fd4\u56de\u5168\u90e8\u54cd\u5e94\u3002\n\n\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u60a8\u53ef\u4ee5\u5c06**\u751f\u6210\u5668**\u51fd\u6570\u63d0\u4f9b\u7ed9 Gradio\uff0c\u800c\u4e0d\u662f\u5e38\u89c4\u51fd\u6570\u3002\u5728 Python \u4e2d\u521b\u5efa\u751f\u6210\u5668\u975e\u5e38\u7b80\u5355\uff1a\u51fd\u6570\u4e0d\u5e94\u8be5\u6709\u4e00\u4e2a\u5355\u72ec\u7684 `return` \u503c\uff0c\u800c\u662f\u5e94\u8be5 with `yield` \u8fde\u7eed\u8fd4\u56de\u4e00\u7cfb\u5217\u503c\u3002\u901a\u5e38\uff0c`yield` \u8bed\u53e5\u653e\u7f6e\u5728\u67d0\u79cd\u5faa\u73af\u4e2d\u3002\u4e0b\u9762\u662f\u4e00\u4e2a\u7b80\u5355\u793a\u4f8b\uff0c\u751f\u6210\u5668\u53ea\u662f\u7b80\u5355\u8ba1\u6570\u5230\u7ed9\u5b9a\u6570\u5b57\uff1a\n\n```python\ndef my_generator(x):\n    for i in range(x):\n        yield i\n```\n\n\u60a8\u4ee5\u4e0e\u5e38\u89c4\u51fd\u6570\u76f8\u540c\u7684\u65b9\u5f0f\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio\u3002\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\uff08\u865a\u62df\u7684\uff09\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5b83\u5728\u8f93\u51fa\u56fe\u50cf\u4e4b\u524d\u751f\u6210\u6570\u4e2a\u6b65\u9aa4\u7684\u566a\u97f3\uff1a\n\n$code_fake_diffusion\n$demo_fake_diffusion\n\n\u8bf7\u6ce8\u610f\uff0c\u6211\u4eec\u5728\u8fed\u4ee3\u5668\u4e2d\u6dfb\u52a0\u4e86 `time.sleep(1)`\uff0c\u4ee5\u521b\u5efa\u6b65\u9aa4\u4e4b\u95f4\u7684\u4eba\u5de5\u6682\u505c\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u89c2\u5bdf\u8fed\u4ee3\u5668\u7684\u6b65\u9aa4\uff08\u5728\u771f\u5b9e\u7684\u56fe\u50cf\u751f\u6210\u6a21\u578b\u4e2d\uff0c\u8fd9\n3,\tlabel_mask  # Set negative label positions to 0\nmean_loss = tf.reduce_sum(loss) / tf.reduce_sum(label_mask)\n```\n\nHere, we avoid data-dependent shapes by computing the loss for every position, but zeroing out the masked positions in both the numerator and denominator when we calculate the mean, which yields exactly the same result as the first block while maintaining XLA compatibility. Note that we use the same trick as in rule #1 - converting a `tf.bool` to `tf.float32` and using it as an indicator variable. This is a really useful trick, so remember it if you need to convert your own code to XLA!\n\n#### XLA Rule #3: XLA will need to recompile your model for every different input shape it sees\n\nThis is the big one. What this means is that if your input shapes are very variable, XLA will have to recompile your model over and over, which will create huge performance problems. This commonly arises in NLP models, where input texts have variable lengths after tokenization. In other modalities, static shapes are more common and this rule is much less of a problem.\n\nHow can you get around rule #3? The key is **padding** - if you pad all your inputs to the same length, and then use an `attention_mask`, you can get the same results as you\u2019d get from variable shapes, but without any XLA issues. However, excessive padding can cause severe slowdown too - if you pad all your samples to the maximum length in the whole dataset, you might end up with batches consisting endless padding tokens, which will waste a lot of compute and memory!\n\nThere isn\u2019t a perfect solution to this problem. However, you can try some tricks. One very useful trick is to **pad batches of samples up to a multiple of a number like 32 or 64 tokens.** This often only increases the number of tokens by a small amount, but it hugely reduces the number of unique input shapes, because every input shape now has to be a multiple of 32 or 64. Fewer unique input shapes means fewer XLA compilations!\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** Our tokenizers and data collators have methods that can help you here. You can use `padding=\"max_length\"` or `padding=\"longest\"` when calling tokenizers to get them to output padded data. Our tokenizers and data collators also have a `pad_to_multiple_of` argument that you can use to reduce the number of unique input shapes you see!\n\n</Tip>\n\n### How do I actually train my model on TPU?\n\nOnce your training is XLA-compatible and (if you\u2019re using TPU Node / Colab) your dataset has been prepared appropriately, running on TPU is surprisingly easy! All you really need to change in your code is to add a few lines to initialize your TPU, and to ensure that your model and dataset are created inside a `TPUStrategy` scope. Take a look at [our TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) to see this in action!\n\n### Summary\n\nThere was a lot in here, so let\u2019s summarize with a quick checklist you can follow when you want to get your model ready for TPU training:\n\n- Make sure your code follows the three rules of XLA\n- Compile your model with `jit_compile=True` on CPU/GPU and confirm that you can train it with XLA\n- Either load your dataset into memory or use a TPU-compatible dataset loading approach (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Migrate your code either to Colab (with accelerator set to \u201cTPU\u201d) or a TPU VM on Google Cloud\n- Add TPU initializer code (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Create your `TPUStrategy` and make sure dataset loading and model creation are inside the `strategy.scope()` (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Don\u2019t forget to take `jit_compile=True` out again when you move to TPU!\n- \ud83d\ude4f\ud83d\ude4f\ud83d\ude4f\ud83e\udd7a\ud83e\udd7a\ud83e\udd7a\n- Call model.fit()\n- You did it!\n4,\tGradio Demo: blocks_random_slider\n\n\n```\n!pip install -q gradio \n```\n\n\n```\n\nimport gradio as gr\n\n\ndef func(slider_1, slider_2):\n    return slider_1 * 5 + slider_2\n\n\nwith gr.Blocks() as demo:\n    slider = gr.Slider(minimum=-10.2, maximum=15, label=\"Random Slider (Static)\", randomize=True)\n    slider_1 = gr.Slider(minimum=100, maximum=200, label=\"Random Slider (Input 1)\", randomize=True)\n    slider_2 = gr.Slider(minimum=10, maximum=23.2, label=\"Random Slider (Input 2)\", randomize=True)\n    slider_3 = gr.Slider(value=3, label=\"Non random slider\")\n    btn = gr.Button(\"Run\")\n    btn.click(func, inputs=[slider_1, slider_2], outputs=gr.Number())\n\nif __name__ == \"__main__\":\n    demo.launch()\n\n```\n    ```",
            "vector_context": "[Created at: 2025-03-24 13:16:48]\n\u65f6\u5fc5\u987b\u9009\u62e9\u5176\u4e2d\u4e00\u4e2a\u5b57\u7b26\u4e32\uff0c\u8fd9\u5c06\u4f5c\u4e3a\u9644\u52a0\u5217\u4fdd\u5b58\u5230 CSV \u4e2d\u3002\n\n## \u9884\u5904\u7406\u548c\u540e\u5904\u7406 (Preprocessing and Postprocessing)\n\n![annotated](/assets/img/dataflow.svg)\n\n\u5982\u60a8\u6240\u89c1\uff0cGradio \u5305\u62ec\u53ef\u4ee5\u5904\u7406\u5404\u79cd\u4e0d\u540c\u6570\u636e\u7c7b\u578b\u7684\u7ec4\u4ef6\uff0c\u4f8b\u5982\u56fe\u50cf\u3001\u97f3\u9891\u548c\u89c6\u9891\u3002\u5927\u591a\u6570\u7ec4\u4ef6\u90fd\u53ef\u4ee5\u7528\u4f5c\u8f93\u5165\u6216\u8f93\u51fa\u3002\n\n\u5f53\u7ec4\u4ef6\u7528\u4f5c\u8f93\u5165\u65f6\uff0cGradio \u81ea\u52a8\u5904\u7406*\u9884\u5904\u7406*\uff0c\u5c06\u6570\u636e\u4ece\u7528\u6237\u6d4f\u89c8\u5668\u53d1\u9001\u7684\u7c7b\u578b\uff08\u4f8b\u5982\u7f51\u7edc\u6444\u50cf\u5934\u5feb\u7167\u7684 base64 \u8868\u793a\uff09\u8f6c\u6362\u4e3a\u60a8\u7684\u51fd\u6570\u53ef\u4ee5\u63a5\u53d7\u7684\u5f62\u5f0f\uff08\u4f8b\u5982 `numpy` \u6570\u7ec4\uff09\u3002\n\n\u540c\u6837\uff0c\u5f53\u7ec4\u4ef6\u7528\u4f5c\u8f93\u51fa\u65f6\uff0cGradio \u81ea\u52a8\u5904\u7406*\u540e\u5904\u7406*\uff0c\u5c06\u6570\u636e\u4ece\u51fd\u6570\u8fd4\u56de\u7684\u5f62\u5f0f\uff08\u4f8b\u5982\u56fe\u50cf\u8def\u5f84\u5217\u8868\uff09\u8f6c\u6362\u4e3a\u53ef\u4ee5\u5728\u7528\u6237\u6d4f\u89c8\u5668\u4e2d\u663e\u793a\u7684\u5f62\u5f0f\uff08\u4f8b\u5982\u4ee5 base64 \u683c\u5f0f\u663e\u793a\u56fe\u50cf\u7684 `Gallery`\uff09\u3002\n\n\u60a8\u53ef\u4ee5\u4f7f\u7528\u6784\u5efa\u56fe\u50cf\u7ec4\u4ef6\u65f6\u7684\u53c2\u6570\u63a7\u5236*\u9884\u5904\u7406*\u3002\u4f8b\u5982\uff0c\u5982\u679c\u60a8\u4f7f\u7528\u4ee5\u4e0b\u53c2\u6570\u5b9e\u4f8b\u5316 `Image` \u7ec4\u4ef6\uff0c\u5b83\u5c06\u5c06\u56fe\u50cf\u8f6c\u6362\u4e3a `PIL` \u7c7b\u578b\uff0c\u5e76\u5c06\u5176\u91cd\u5851\u4e3a`(100, 100)`\uff0c\u800c\u4e0d\u7ba1\u63d0\u4ea4\u65f6\u7684\u539f\u59cb\u5927\u5c0f\u5982\u4f55\uff1a\n\n```py\nimg = gr.Image(shape=(100, 100), type=\"pil\")\n```\n\n\u76f8\u53cd\uff0c\u8fd9\u91cc\u6211\u4eec\u4fdd\u7559\u56fe\u50cf\u7684\u539f\u59cb\u5927\u5c0f\uff0c\u4f46\u5728\u5c06\u5176\u8f6c\u6362\u4e3a numpy \u6570\u7ec4\u4e4b\u524d\u53cd\u8f6c\u989c\u8272\uff1a\n\n```py\nimg = gr.Image(invert_colors=True, type=\"numpy\")\n```\n\n\u540e\u5904\u7406\u8981\u5bb9\u6613\u5f97\u591a\uff01Gradio \u81ea\u52a8\u8bc6\u522b\u8fd4\u56de\u6570\u636e\u7684\u683c\u5f0f\uff08\u4f8b\u5982 `Image` \u662f `numpy` \u6570\u7ec4\u8fd8\u662f `str` \u6587\u4ef6\u8def\u5f84\uff1f\uff09\uff0c\u5e76\u5c06\u5176\u540e\u5904\u7406\u4e3a\u53ef\u4ee5\u7531\u6d4f\u89c8\u5668\u663e\u793a\u7684\u683c\u5f0f\u3002\n\n\u8bf7\u67e5\u770b[\u6587\u6863](https://gradio.app/docs)\uff0c\u4e86\u89e3\u6bcf\u4e2a\u7ec4\u4ef6\u7684\u6240\u6709\u4e0e\u9884\u5904\u7406\u76f8\u5173\u7684\u53c2\u6570\u3002\n\n## \u6837\u5f0f (Styling)\n\nGradio \u4e3b\u9898\u662f\u81ea\u5b9a\u4e49\u5e94\u7528\u7a0b\u5e8f\u5916\u89c2\u548c\u611f\u89c9\u7684\u6700\u7b80\u5355\u65b9\u6cd5\u3002\u60a8\u53ef\u4ee5\u9009\u62e9\u591a\u79cd\u4e3b\u9898\u6216\u521b\u5efa\u81ea\u5df1\u7684\u4e3b\u9898\u3002\u8981\u8fd9\u6837\u505a\uff0c\u8bf7\u5c06 `theme=` \u53c2\u6570\u4f20\u9012\u7ed9 `Interface` \u6784\u9020\u51fd\u6570\u3002\u4f8b\u5982\uff1a\n\n```python\ndemo = gr.Interface(..., theme=gr.themes.Monochrome())\n```\n\nGradio \u5e26\u6709\u4e00\u7ec4\u9884\u5148\u6784\u5efa\u7684\u4e3b\u9898\uff0c\u60a8\u53ef\u4ee5\u4ece `gr.themes.*` \u52a0\u8f7d\u3002\u60a8\u53ef\u4ee5\u6269\u5c55\u8fd9\u4e9b\u4e3b\u9898\u6216\u4ece\u5934\u5f00\u59cb\u521b\u5efa\u81ea\u5df1\u7684\u4e3b\u9898 - \u6709\u5173\u66f4\u591a\u8be6\u7ec6\u4fe1\u606f\uff0c\u8bf7\u53c2\u9605[\u4e3b\u9898\u6307\u5357](https://gradio.app/theming-guide)\u3002\n\n\u8981\u589e\u52a0\u989d\u5916\u7684\u6837\u5f0f\u80fd\u529b\uff0c\u60a8\u53ef\u4ee5 with `css=` \u5173\u952e\u5b57\u5c06\u4efb\u4f55 CSS \u4f20\u9012\u7ed9\u60a8\u7684\u5e94\u7528\u7a0b\u5e8f\u3002\nGradio \u5e94\u7528\u7a0b\u5e8f\u7684\u57fa\u7c7b\u662f `gradio-container`\uff0c\u56e0\u6b64\u4ee5\u4e0b\u662f\u4e00\u4e2a\u66f4\u6539 Gradio \u5e94\u7528\u7a0b\u5e8f\u80cc\u666f\u989c\u8272\u7684\u793a\u4f8b\uff1a\n\n```python\nwith `gr.Interface(css=\".gradio-container {background-color: red}\") as demo:\n    ...\n```\n\n## \u961f\u5217 (Queuing)\n\n\u5982\u679c\u60a8\u7684\u5e94\u7528\u7a0b\u5e8f\u9884\u8ba1\u4f1a\u6709\u5927\u91cf\u6d41\u91cf\uff0c\u8bf7 with `queue()` \u65b9\u6cd5\u6765\u63a7\u5236\u5904\u7406\u901f\u7387\u3002\u8fd9\u5c06\u6392\u961f\u5904\u7406\u8c03\u7528\uff0c\u56e0\u6b64\u4e00\u6b21\u53ea\u5904\u7406\u4e00\u5b9a\u6570\u91cf\u7684\u8bf7\u6c42\u3002\u961f\u5217\u4f7f\u7528 Websockets\uff0c\u8fd8\u53ef\u4ee5\u9632\u6b62\u7f51\u7edc\u8d85\u65f6\uff0c\u56e0\u6b64\u5982\u679c\u60a8\u7684\u51fd\u6570\u7684\u63a8\u7406\u65f6\u95f4\u5f88\u957f\uff08> 1 \u5206\u949f\uff09\uff0c\u5e94\u4f7f\u7528\u961f\u5217\u3002\n\nwith `Interface`\uff1a\n\n```python\ndemo = gr.Interface(...).queue()\ndemo.launch()\n```\n\nwith `Blocks`\uff1a\n\n```python\nwith gr.Blocks() as demo\uff1a\n    #...\ndemo.queue()\ndemo.launch()\n```\n\n\u60a8\u53ef\u4ee5\u901a\u8fc7\u4ee5\u4e0b\u65b9\u5f0f\u63a7\u5236\u4e00\u6b21\u5904\u7406\u7684\u8bf7\u6c42\u6570\u91cf\uff1a\n\n```python\ndemo.queue(concurrency_count=3)\n```\n\n\u67e5\u770b\u6709\u5173\u914d\u7f6e\u5176\u4ed6\u961f\u5217\u53c2\u6570\u7684[\u961f\u5217\u6587\u6863](/docs/#queue)\u3002\n\n\u5728 Blocks \u4e2d\u6307\u5b9a\u4ec5\u5bf9\u67d0\u4e9b\u51fd\u6570\u8fdb\u884c\u6392\u961f\uff1a\n\n```python\nwith gr.Blocks() as demo2\uff1a\n    num1 = gr.Number()\n    num2 = gr.Number()\n    output = gr.Number()\n    gr.Button(\"Add\").click(\n        lambda a, b: a + b, [num1, num2], output)\n    gr.Button(\"Multiply\").click(\n        lambda a, b: a * b, [num1, num2], output, queue=True)\ndemo2.launch()\n```\n\n## \u8fed\u4ee3\u8f93\u51fa (Iterative Outputs)\n\n\u5728\u67d0\u4e9b\u60c5\u51b5\u4e0b\uff0c\u60a8\u53ef\u80fd\u9700\u8981\u4f20\u8f93\u4e00\u7cfb\u5217\u8f93\u51fa\u800c\u4e0d\u662f\u4e00\u6b21\u663e\u793a\u5355\u4e2a\u8f93\u51fa\u3002\u4f8b\u5982\uff0c\u60a8\u53ef\u80fd\u6709\u4e00\u4e2a\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5e0c\u671b\u663e\u793a\u751f\u6210\u7684\u6bcf\u4e2a\u6b65\u9aa4\u7684\u56fe\u50cf\uff0c\u76f4\u5230\u6700\u7ec8\u56fe\u50cf\u3002\u6216\u8005\u60a8\u53ef\u80fd\u6709\u4e00\u4e2a\u804a\u5929\u673a\u5668\u4eba\uff0c\u5b83\u9010\u5b57\u9010\u53e5\u5730\u6d41\u5f0f\u4f20\u8f93\u54cd\u5e94\uff0c\u800c\u4e0d\u662f\u4e00\u6b21\u8fd4\u56de\u5168\u90e8\u54cd\u5e94\u3002\n\n\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u60a8\u53ef\u4ee5\u5c06**\u751f\u6210\u5668**\u51fd\u6570\u63d0\u4f9b\u7ed9 Gradio\uff0c\u800c\u4e0d\u662f\u5e38\u89c4\u51fd\u6570\u3002\u5728 Python \u4e2d\u521b\u5efa\u751f\u6210\u5668\u975e\u5e38\u7b80\u5355\uff1a\u51fd\u6570\u4e0d\u5e94\u8be5\u6709\u4e00\u4e2a\u5355\u72ec\u7684 `return` \u503c\uff0c\u800c\u662f\u5e94\u8be5 with `yield` \u8fde\u7eed\u8fd4\u56de\u4e00\u7cfb\u5217\u503c\u3002\u901a\u5e38\uff0c`yield` \u8bed\u53e5\u653e\u7f6e\u5728\u67d0\u79cd\u5faa\u73af\u4e2d\u3002\u4e0b\u9762\u662f\u4e00\u4e2a\u7b80\u5355\u793a\u4f8b\uff0c\u751f\u6210\u5668\u53ea\u662f\u7b80\u5355\u8ba1\u6570\u5230\u7ed9\u5b9a\u6570\u5b57\uff1a\n\n```python\ndef my_generator(x):\n    for i in range(x):\n        yield i\n```\n\n\u60a8\u4ee5\u4e0e\u5e38\u89c4\u51fd\u6570\u76f8\u540c\u7684\u65b9\u5f0f\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio\u3002\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\uff08\u865a\u62df\u7684\uff09\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5b83\u5728\u8f93\u51fa\u56fe\u50cf\u4e4b\u524d\u751f\u6210\u6570\u4e2a\u6b65\u9aa4\u7684\u566a\u97f3\uff1a\n\n$code_fake_diffusion\n$demo_fake_diffusion\n\n\u8bf7\u6ce8\u610f\uff0c\u6211\u4eec\u5728\u8fed\u4ee3\u5668\u4e2d\u6dfb\u52a0\u4e86 `time.sleep(1)`\uff0c\u4ee5\u521b\u5efa\u6b65\u9aa4\u4e4b\u95f4\u7684\u4eba\u5de5\u6682\u505c\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u89c2\u5bdf\u8fed\u4ee3\u5668\u7684\u6b65\u9aa4\uff08\u5728\u771f\u5b9e\u7684\u56fe\u50cf\u751f\u6210\u6a21\u578b\u4e2d\uff0c\u8fd9\n--New Chunk--\n[Created at: 2025-03-24 13:16:48]\n\u4e3b\u8981\u7279\u70b9\n\n\u8ba9\u6211\u4eec\u6765\u4ecb\u7ecd\u4e00\u4e0b Gradio \u6700\u53d7\u6b22\u8fce\u7684\u4e00\u4e9b\u529f\u80fd\uff01\u8fd9\u91cc\u662f Gradio \u7684\u4e3b\u8981\u7279\u70b9\uff1a\n\n1. [\u6dfb\u52a0\u793a\u4f8b\u8f93\u5165](#example-inputs)\n2. [\u4f20\u9012\u81ea\u5b9a\u4e49\u9519\u8bef\u6d88\u606f](#errors)\n3. [\u6dfb\u52a0\u63cf\u8ff0\u5185\u5bb9](#descriptive-content)\n4. [\u8bbe\u7f6e\u65d7\u6807](#flagging)\n5. [\u9884\u5904\u7406\u548c\u540e\u5904\u7406](#preprocessing-and-postprocessing)\n6. [\u6837\u5f0f\u5316\u6f14\u793a](#styling)\n7. [\u6392\u961f\u7528\u6237](#queuing)\n8. [\u8fed\u4ee3\u8f93\u51fa](#iterative-outputs)\n9. [\u8fdb\u5ea6\u6761](#progress-bars)\n10. [\u6279\u5904\u7406\u51fd\u6570](#batch-functions)\n11. [\u5728\u534f\u4f5c\u7b14\u8bb0\u672c\u4e0a\u8fd0\u884c](#colab-notebooks)\n\n## \u793a\u4f8b\u8f93\u5165\n\n\u60a8\u53ef\u4ee5\u63d0\u4f9b\u7528\u6237\u53ef\u4ee5\u8f7b\u677e\u52a0\u8f7d\u5230 \"Interface\" \u4e2d\u7684\u793a\u4f8b\u6570\u636e\u3002\u8fd9\u5bf9\u4e8e\u6f14\u793a\u6a21\u578b\u671f\u671b\u7684\u8f93\u5165\u7c7b\u578b\u4ee5\u53ca\u6f14\u793a\u6570\u636e\u96c6\u548c\u6a21\u578b\u4e00\u8d77\u63a2\u7d22\u7684\u65b9\u5f0f\u975e\u5e38\u6709\u5e2e\u52a9\u3002\u8981\u52a0\u8f7d\u793a\u4f8b\u6570\u636e\uff0c\u60a8\u53ef\u4ee5\u5c06\u5d4c\u5957\u5217\u8868\u63d0\u4f9b\u7ed9 Interface \u6784\u9020\u51fd\u6570\u7684 `examples=` \u5173\u952e\u5b57\u53c2\u6570\u3002\u5916\u90e8\u5217\u8868\u4e2d\u7684\u6bcf\u4e2a\u5b50\u5217\u8868\u8868\u793a\u4e00\u4e2a\u6570\u636e\u6837\u672c\uff0c\u5b50\u5217\u8868\u4e2d\u7684\u6bcf\u4e2a\u5143\u7d20\u8868\u793a\u6bcf\u4e2a\u8f93\u5165\u7ec4\u4ef6\u7684\u8f93\u5165\u3002\u6709\u5173\u6bcf\u4e2a\u7ec4\u4ef6\u7684\u793a\u4f8b\u6570\u636e\u683c\u5f0f\u5728[Docs](https://gradio.app/docs#components)\u4e2d\u6709\u8bf4\u660e\u3002\n\n$code_calculator\n$demo_calculator\n\n\u60a8\u53ef\u4ee5\u5c06\u5927\u578b\u6570\u636e\u96c6\u52a0\u8f7d\u5230\u793a\u4f8b\u4e2d\uff0c\u901a\u8fc7 Gradio \u6d4f\u89c8\u548c\u4e0e\u6570\u636e\u96c6\u8fdb\u884c\u4ea4\u4e92\u3002\u793a\u4f8b\u5c06\u81ea\u52a8\u5206\u9875\uff08\u53ef\u4ee5\u901a\u8fc7 Interface \u7684 `examples_per_page` \u53c2\u6570\u8fdb\u884c\u914d\u7f6e\uff09\u3002\n\n\u7ee7\u7eed\u4e86\u89e3\u793a\u4f8b\uff0c\u8bf7\u53c2\u9605[\u66f4\u591a\u793a\u4f8b](https://gradio.app/more-on-examples)\u6307\u5357\u3002\n\n## \u9519\u8bef\n\n\u60a8\u5e0c\u671b\u5411\u7528\u6237\u4f20\u9012\u81ea\u5b9a\u4e49\u9519\u8bef\u6d88\u606f\u3002\u4e3a\u6b64\uff0cwith `gr.Error(\"custom message\")` \u6765\u663e\u793a\u9519\u8bef\u6d88\u606f\u3002\u5982\u679c\u5728\u4e0a\u9762\u7684\u8ba1\u7b97\u5668\u793a\u4f8b\u4e2d\u5c1d\u8bd5\u9664\u4ee5\u96f6\uff0c\u5c06\u663e\u793a\u81ea\u5b9a\u4e49\u9519\u8bef\u6d88\u606f\u7684\u5f39\u51fa\u6a21\u6001\u7a97\u53e3\u3002\u4e86\u89e3\u6709\u5173\u9519\u8bef\u7684\u66f4\u591a\u4fe1\u606f\uff0c\u8bf7\u53c2\u9605[\u6587\u6863](https://gradio.app/docs#error)\u3002\n\n## \u63cf\u8ff0\u6027\u5185\u5bb9\n\n\u5728\u524d\u9762\u7684\u793a\u4f8b\u4e2d\uff0c\u60a8\u53ef\u80fd\u5df2\u7ecf\u6ce8\u610f\u5230 Interface \u6784\u9020\u51fd\u6570\u4e2d\u7684 `title=` \u548c `description=` \u5173\u952e\u5b57\u53c2\u6570\uff0c\u5e2e\u52a9\u7528\u6237\u4e86\u89e3\u60a8\u7684\u5e94\u7528\u7a0b\u5e8f\u3002\n\nInterface \u6784\u9020\u51fd\u6570\u4e2d\u6709\u4e09\u4e2a\u53c2\u6570\u7528\u4e8e\u6307\u5b9a\u6b64\u5185\u5bb9\u5e94\u653e\u7f6e\u5728\u54ea\u91cc\uff1a\n\n- `title`\uff1a\u63a5\u53d7\u6587\u672c\uff0c\u5e76\u53ef\u4ee5\u5c06\u5176\u663e\u793a\u5728\u754c\u9762\u7684\u9876\u90e8\uff0c\u4e5f\u5c06\u6210\u4e3a\u9875\u9762\u6807\u9898\u3002\n- `description`\uff1a\u63a5\u53d7\u6587\u672c\u3001Markdown \u6216 HTML\uff0c\u5e76\u5c06\u5176\u653e\u7f6e\u5728\u6807\u9898\u6b63\u4e0b\u65b9\u3002\n- `article`\uff1a\u4e5f\u63a5\u53d7\u6587\u672c\u3001Markdown \u6216 HTML\uff0c\u5e76\u5c06\u5176\u653e\u7f6e\u5728\u754c\u9762\u4e0b\u65b9\u3002\n\n![annotated](/assets/guides/annotated.png)\n\n\u5982\u679c\u60a8\u4f7f\u7528\u7684\u662f `Blocks` API\uff0c\u5219\u53ef\u4ee5 with `gr.Markdown(...)` \u6216 `gr.HTML(...)` \u7ec4\u4ef6\u5728\u4efb\u4f55\u4f4d\u7f6e\u63d2\u5165\u6587\u672c\u3001Markdown \u6216 HTML\uff0c\u5176\u4e2d\u63cf\u8ff0\u6027\u5185\u5bb9\u4f4d\u4e8e `Component` \u6784\u9020\u51fd\u6570\u5185\u90e8\u3002\n\n\u53e6\u4e00\u4e2a\u6709\u7528\u7684\u5173\u952e\u5b57\u53c2\u6570\u662f `label=`\uff0c\u5b83\u5b58\u5728\u4e8e\u6bcf\u4e2a `Component` \u4e2d\u3002\u8fd9\u4fee\u6539\u4e86\u6bcf\u4e2a `Component` \u9876\u90e8\u7684\u6807\u7b7e\u6587\u672c\u3002\u8fd8\u53ef\u4ee5\u4e3a\u8bf8\u5982 `Textbox` \u6216 `Radio` \u4e4b\u7c7b\u7684\u8868\u5355\u5143\u7d20\u6dfb\u52a0 `info=` \u5173\u952e\u5b57\u53c2\u6570\uff0c\u4ee5\u63d0\u4f9b\u6709\u5173\u5176\u7528\u6cd5\u7684\u8fdb\u4e00\u6b65\u4fe1\u606f\u3002\n\n```python\ngr.Number(label='\u5e74\u9f84', info='\u4ee5\u5e74\u4e3a\u5355\u4f4d\uff0c\u5fc5\u987b\u5927\u4e8e0')\n```\n\n## \u65d7\u6807\n\n\u9ed8\u8ba4\u60c5\u51b5\u4e0b\uff0c\"Interface\" \u5c06\u6709\u4e00\u4e2a \"Flag\" \u6309\u94ae\u3002\u5f53\u7528\u6237\u6d4b\u8bd5\u60a8\u7684 `Interface` \u65f6\uff0c\u5982\u679c\u770b\u5230\u6709\u8da3\u7684\u8f93\u51fa\uff0c\u4f8b\u5982\u9519\u8bef\u6216\u610f\u5916\u7684\u6a21\u578b\u884c\u4e3a\uff0c\u4ed6\u4eec\u53ef\u4ee5\u5c06\u8f93\u5165\u6807\u8bb0\u4e3a\u60a8\u8fdb\u884c\u67e5\u770b\u3002\u5728\u7531 `Interface` \u6784\u9020\u51fd\u6570\u7684 `flagging_dir=` \u53c2\u6570\u63d0\u4f9b\u7684\u76ee\u5f55\u4e2d\uff0c\u5c06\u8bb0\u5f55\u6807\u8bb0\u7684\u8f93\u5165\u5230\u4e00\u4e2a CSV \u6587\u4ef6\u4e2d\u3002\u5982\u679c\u754c\u9762\u6d89\u53ca\u6587\u4ef6\u6570\u636e\uff0c\u4f8b\u5982\u56fe\u50cf\u548c\u97f3\u9891\u7ec4\u4ef6\uff0c\u5c06\u521b\u5efa\u6587\u4ef6\u5939\u6765\u5b58\u50a8\u8fd9\u4e9b\u6807\u8bb0\u7684\u6570\u636e\u3002\n\n\u4f8b\u5982\uff0c\u5bf9\u4e8e\u4e0a\u9762\u663e\u793a\u7684\u8ba1\u7b97\u5668\u754c\u9762\uff0c\u6211\u4eec\u5c06\u5728\u4e0b\u9762\u7684\u65d7\u6807\u76ee\u5f55\u4e2d\u5b58\u50a8\u6807\u8bb0\u7684\u6570\u636e\uff1a\n\n```directory\n+-- calculator.py\n+-- flagged/\n|   +-- logs.csv\n```\n\n_flagged/logs.csv_\n\n```csv\nnum1,operation,num2,Output\n5,add,7,12\n6,subtract,1.5,4.5\n```\n\n\u4e0e\u65e9\u671f\u663e\u793a\u7684\u51b7\u8272\u754c\u9762\u76f8\u5bf9\u5e94\uff0c\u6211\u4eec\u5c06\u5728\u4e0b\u9762\u7684\u65d7\u6807\u76ee\u5f55\u4e2d\u5b58\u50a8\u6807\u8bb0\u7684\u6570\u636e\uff1a\n\n```directory\n+-- sepia.py\n+-- flagged/\n|   +-- logs.csv\n|   +-- im/\n|   |   +-- 0.png\n|   |   +-- 1.png\n|   +-- Output/\n|   |   +-- 0.png\n|   |   +-- 1.png\n```\n\n_flagged/logs.csv_\n\n```csv\nim,Output\nim/0.png,Output/0.png\nim/1.png,Output/1.png\n```\n\n\u5982\u679c\u60a8\u5e0c\u671b\u7528\u6237\u63d0\u4f9b\u65d7\u6807\u539f\u56e0\uff0c\u53ef\u4ee5\u5c06\u5b57\u7b26\u4e32\u5217\u8868\u4f20\u9012\u7ed9 Interface \u7684 `flagging_options` \u53c2\u6570\u3002\u7528\u6237\u5728\u8fdb\u884c\u65d7\u6807\u65f6\u5fc5\u987b\u9009\u62e9\u5176\u4e2d\u4e00\u4e2a\u5b57\u7b26\u4e32\uff0c\u8fd9\u5c06\u4f5c\u4e3a\u9644\u52a0\u5217\u4fdd\u5b58\u5230 CSV \u4e2d\u3002\n\n## \u9884\u5904\u7406\u548c\u540e\u5904\u7406 (Preprocessing and Postprocessing)\n\n![annotated](/assets/img/dataflow.svg)\n\n\u5982\u60a8\u6240\u89c1\uff0cGradio \u5305\u62ec\u53ef\u4ee5\u5904\u7406\u5404\u79cd\u4e0d\u540c\u6570\u636e\u7c7b\u578b\u7684\u7ec4\u4ef6\uff0c\u4f8b\u5982\u56fe\u50cf\u3001\u97f3\u9891\u548c\u89c6\u9891\u3002\u5927\u591a\u6570\u7ec4\u4ef6\u90fd\u53ef\u4ee5\u7528\u4f5c\u8f93\u5165\u6216\u8f93\u51fa\u3002\n\n\u5f53\u7ec4\u4ef6\u7528\u4f5c\u8f93\u5165\u65f6\uff0cGradio \u81ea\u52a8\u5904\u7406*\u9884\u5904\u7406*\uff0c\u5c06\u6570\u636e\u4ece\u7528\u6237\n--New Chunk--\n[Created at: 2025-03-24 13:18:21]\nGradio Demo: blocks_random_slider\n\n\n```\n!pip install -q gradio \n```\n\n\n```\n\nimport gradio as gr\n\n\ndef func(slider_1, slider_2):\n    return slider_1 * 5 + slider_2\n\n\nwith gr.Blocks() as demo:\n    slider = gr.Slider(minimum=-10.2, maximum=15, label=\"Random Slider (Static)\", randomize=True)\n    slider_1 = gr.Slider(minimum=100, maximum=200, label=\"Random Slider (Input 1)\", randomize=True)\n    slider_2 = gr.Slider(minimum=10, maximum=23.2, label=\"Random Slider (Input 2)\", randomize=True)\n    slider_3 = gr.Slider(value=3, label=\"Non random slider\")\n    btn = gr.Button(\"Run\")\n    btn.click(func, inputs=[slider_1, slider_2], outputs=gr.Number())\n\nif __name__ == \"__main__\":\n    demo.launch()\n\n```"
        }
    },
    {
        "sample_idx": 120,
        "question": "What is the name of the model that can be used to extract image features?",
        "answer": "seresnet152d",
        "rag_answer": "According to the provided Data Sources, there is no specific model mentioned that can be used to extract image features. However, the text mentions LayoutLMv3, which is a model used for token classification on form understanding datasets such as FUNSD and CORD. It is not typically used for image feature extraction.\n\nIf you're looking for models that can extract image features, some popular options include:\n\n* Convolutional Neural Networks (CNNs) like VGG16, ResNet50, and InceptionV3\n* Transformers like Vision Transformers (ViT) and Swin Transformers\n* Models specifically designed for image feature extraction tasks, such as feature pyramid networks (FPN) and dense connectivity networks (DenseNet)\n\nPlease note that these models are not mentioned in the provided Data Sources, but are commonly used in the field of computer vision for image feature extraction tasks.\n\nReferences:\n[KG] Keras, category, Keras is a high-level neural networks API, used for building and training neural networks.\n[KG] TensorFlow, category, TensorFlow is a software framework used for building and training neural networks.\n[DC] Token classification with LayoutLMv3 (PyTorch version)",
        "rag_score": 2,
        "rag_feedback": "The system's response is mostly incorrect, inaccurate, and/or not factual. It provides a lot of irrelevant information about TPUs, XLA, and model training, but does not address the question about the model that can be used to extract image features. The correct answer is 'seresnet152d', which is not mentioned in the system's response.",
        "rag_context": {
            "kg_context": "-----Entities-----\n    ```csv\n    id,\tentity,\ttype,\tdescription,\trankcreated_at\n1,\tKeras,category,Keras is a high-level neural networks API, used for building and training neural networks.<SEP>Keras is a machine learning framework that uses XLA for optimization.,2,2025-03-24 13:18:20\n2,\tXLA,technology,XLA is a technology that compiles TensorFlow graphs into executable code for various platforms.<SEP>XLA is an optimizing compiler used by TensorFlow and JAX to improve performance.<SEP>XLA is an optimizing compiler, used by both TensorFlow and JAX to optimize computations.,6,2025-03-24 13:18:20\n3,\tTensorFlow,category,TensorFlow is a machine learning framework that uses XLA as an optimizing compiler.<SEP>TensorFlow is a software framework used for building and training neural networks.<SEP>TensorFlow is an open-source machine learning framework.,3,2025-03-24 13:18:20\n4,\tlabel_mask,concept,label_mask is a technique for masking out unwanted data in machine learning models.,1,2025-03-24 13:18:20\n5,\tmean_loss,concept,mean_loss is a measure of the average loss in a machine learning model.,1,2025-03-24 13:18:20\n6,\tNeural Networks,category,Neural Networks are a type of machine learning model used for various tasks such as image recognition and natural language processing.,0,UNKNOWN\n7,\tCORD,geo,CORD is a form understanding dataset used for fine-tuning LayoutLMv3.,1,UNKNOWN\n8,\tFUNSD,geo,FUNSD is a form understanding dataset used for fine-tuning LayoutLMv3.,1,UNKNOWN\n    ```\n    -----Relationships-----\n    ```csv\n    id,\tsource,\ttarget,\tdescription,\tkeywords,\tweight,\trank,\tcreated_at\n1,\tKeras,XLA,Keras uses XLA for optimization.,compiler, performance optimization,8.0,8,2025-03-24 13:18:20\n2,\tKeras,TensorFlow,TensorFlow uses Keras as a high-level neural networks API.,API integration, neural networks,16.0,5,2025-03-24 13:18:20\n3,\tlabel_mask,mean_loss,label_mask is used to calculate mean_loss in machine learning models.,calculation, data processing,2.0,2,2025-03-24 13:18:20\n4,\tCORD,LayoutLMv3,CORD is a dataset used for fine-tuning the LayoutLMv3 model.,dataset, model training,14.0,12,UNKNOWN\n5,\tFUNSD,LayoutLMv3,FUNSD is a dataset used for fine-tuning the LayoutLMv3 model.,dataset, model training,14.0,12,UNKNOWN\n    ```\n    -----Sources-----\n    ```csv\n    id,\tcontent\n1,\t(for example, a v3-32), your TPU fleet is referred to as a **pod slice.**\n\nWhen you access a free TPU via Colab, you generally get a single v2-8 TPU.\n\n### I keep hearing about this XLA thing. What\u2019s XLA, and how does it relate to TPUs?\n\nXLA is an optimizing compiler, used by both TensorFlow and JAX. In JAX it is the only compiler, whereas in TensorFlow it is optional (but mandatory on TPU!). The easiest way to enable it when training a Keras model is to pass the argument `jit_compile=True` to `model.compile()`. If you don\u2019t get any errors and performance is good, that\u2019s a great sign that you\u2019re ready to move to TPU!\n\nDebugging on TPU is generally a bit harder than on CPU/GPU, so we recommend getting your code running on CPU/GPU with XLA first before trying it on TPU. You don\u2019t have to train for long, of course - just for a few steps to make sure that your model and data pipeline are working like you expect them to.\n\n<Tip>\n\nXLA compiled code is usually faster - so even if you\u2019re not planning to run on TPU, adding `jit_compile=True` can improve your performance. Be sure to note the caveats below about XLA compatibility, though!\n\n</Tip>\n\n<Tip warning={true}>\n\n**Tip born of painful experience:** Although using `jit_compile=True` is a good way to get a speed boost and test if your CPU/GPU code is XLA-compatible, it can actually cause a lot of problems if you leave it in when actually training on TPU. XLA compilation will happen implicitly on TPU, so remember to remove that line before actually running your code on a TPU!\n\n</Tip>\n\n### How do I make my model XLA compatible?\n\nIn many cases, your code is probably XLA-compatible already! However, there are a few things that work in normal TensorFlow that don\u2019t work in XLA. We\u2019ve distilled them into three core rules below:\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** We\u2019ve put a lot of effort into rewriting our TensorFlow models and loss functions to be XLA-compatible. Our models and loss functions generally obey rule #1 and #2 by default, so you can skip over them if you\u2019re using `transformers` models. Don\u2019t forget about these rules when writing your own models and loss functions, though!\n\n</Tip>\n\n#### XLA Rule #1: Your code cannot have \u201cdata-dependent conditionals\u201d\n\nWhat that means is that any `if` statement cannot depend on values inside a `tf.Tensor`. For example, this code block cannot be compiled with XLA!\n\n```python\nif tf.reduce_sum(tensor) > 10:\n    tensor = tensor / 2.0\n```\n\nThis might seem very restrictive at first, but most neural net code doesn\u2019t need to do this. You can often get around this restriction by using `tf.cond` (see the documentation [here](https://www.tensorflow.org/api_docs/python/tf/cond)) or by removing the conditional and finding a clever math trick with indicator variables instead, like so:\n\n```python\nsum_over_10 = tf.cast(tf.reduce_sum(tensor) > 10, tf.float32)\ntensor = tensor / (1.0 + sum_over_10)\n```\n\nThis code has exactly the same effect as the code above, but by avoiding a conditional, we ensure it will compile with XLA without problems!\n\n#### XLA Rule #2: Your code cannot have \u201cdata-dependent shapes\u201d\n\nWhat this means is that the shape of all of the `tf.Tensor` objects in your code cannot depend on their values. For example, the function `tf.unique` cannot be compiled with XLA, because it returns a `tensor` containing one instance of each unique value in the input. The shape of this output will obviously be different depending on how repetitive the input `Tensor` was, and so XLA refuses to handle it!\n\nIn general, most neural network code obeys rule #2 by default. However, there are a few common cases where it becomes a problem. One very common one is when you use **label masking**, setting your labels to a negative value to indicate that those positions should be ignored when computing the loss. If you look at NumPy or PyTorch loss functions that support label masking, you will often see code like this that uses [boolean indexing](https://numpy.org/doc/stable/user/basics.indexing.html#boolean-array-indexing):\n\n```python\nlabel_mask = labels >= 0\nmasked_outputs = outputs[label_mask]\nmasked_labels = labels[label_mask]\nloss = compute_loss(masked_outputs, masked_labels)\nmean_loss = torch.mean(loss)\n```\n\nThis code is totally fine in NumPy or PyTorch, but it breaks in XLA! Why? Because the shape of `masked_outputs` and `masked_labels` depends on how many positions are masked - that makes it a **data-dependent shape.** However, just like for rule #1, we can often rewrite this code to yield exactly the same output without any data-dependent shapes.\n\n```python\nlabel_mask = tf.cast(labels >= 0, tf.float32)\nloss = compute_loss(outputs, labels)\nloss = loss * label_mask  # Set negative label positions to 0\nmean_loss = tf.reduce_sum(loss) / tf.reduce_sum(label_mask)\n```\n\nHere, we avoid data-dependent shapes by computing the loss for every position, but zeroing out the masked positions in both the numerator and denominator when we calculate the mean, which yields exactly the same result as the first block while maintaining XLA compatibility. Note that we use the same trick as in rule #1 - converting a `tf.bool` to `\n2,\t!--Copyright 2023 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\nthe License. You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under the License is distributed on\nan \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n\n\u26a0\ufe0f Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be\nrendered properly in your Markdown viewer.\n\n-->\n\n# Training on TPU with TensorFlow\n\n<Tip>\n\nIf you don't need long explanations and just want TPU code samples to get started with, check out [our TPU example notebook!](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb)\n\n</Tip>\n\n### What is a TPU?\n\nA TPU is a **Tensor Processing Unit.** They are hardware designed by Google, which are used to greatly speed up the tensor computations within neural networks, much like GPUs. They can be used for both network training and inference. They are generally accessed through Google\u2019s cloud services, but small TPUs can also be accessed directly for free through Google Colab and Kaggle Kernels.\n\nBecause [all TensorFlow models in \ud83e\udd17 Transformers are Keras models](https://huggingface.co/blog/tensorflow-philosophy), most of the methods in this document are generally applicable to TPU training for any Keras model! However, there are a few points that are specific to the HuggingFace ecosystem (hug-o-system?) of Transformers and Datasets, and we\u2019ll make sure to flag them up when we get to them.\n\n### What kinds of TPU are available?\n\nNew users are often very confused by the range of TPUs, and the different ways to access them. The first key distinction to understand is the difference between **TPU Nodes** and **TPU VMs.**\n\nWhen you use a **TPU Node**, you are effectively indirectly accessing a remote TPU. You will need a separate VM, which will initialize your network and data pipeline and then forward them to the remote node. When you use a TPU on Google Colab, you are accessing it in the **TPU Node** style.\n\nUsing TPU Nodes can have some quite unexpected behaviour for people who aren\u2019t used to them! In particular, because the TPU is located on a physically different system to the machine you\u2019re running your Python code on, your data cannot be local to your machine - any data pipeline that loads from your machine\u2019s internal storage will totally fail! Instead, data must be stored in Google Cloud Storage where your data pipeline can still access it, even when the pipeline is running on the remote TPU node.\n\n<Tip>\n\nIf you can fit all your data in memory as `np.ndarray` or `tf.Tensor`, then you can `fit()` on that data even when using Colab or a TPU Node, without needing to upload it to Google Cloud Storage.\n\n</Tip>\n\n<Tip>\n\n**\ud83e\udd17Specific Hugging Face Tip\ud83e\udd17:** The methods `Dataset.to_tf_dataset()` and its higher-level wrapper `model.prepare_tf_dataset()` , which you will see throughout our TF code examples, will both fail on a TPU Node. The reason for this is that even though they create a `tf.data.Dataset` it is not a \u201cpure\u201d `tf.data` pipeline and uses `tf.numpy_function` or `Dataset.from_generator()` to stream data from the underlying HuggingFace `Dataset`. This HuggingFace `Dataset` is backed by data that is on a local disc and which the remote TPU Node will not be able to read.\n\n</Tip>\n\nThe second way to access a TPU is via a **TPU VM.** When using a TPU VM, you connect directly to the machine that the TPU is attached to, much like training on a GPU VM. TPU VMs are generally easier to work with, particularly when it comes to your data pipeline. All of the above warnings do not apply to TPU VMs!\n\nThis is an opinionated document, so here\u2019s our opinion: **Avoid using TPU Node if possible.** It is more confusing and more difficult to debug than TPU VMs. It is also likely to be unsupported in future - Google\u2019s latest TPU, TPUv4, can only be accessed as a TPU VM, which suggests that TPU Nodes are increasingly going to become a \u201clegacy\u201d access method. However, we understand that the only free TPU access is on Colab and Kaggle Kernels, which uses TPU Node - so we\u2019ll try to explain how to handle it if you have to! Check the [TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) for code samples that explain this in more detail.\n\n### What sizes of TPU are available?\n\nA single TPU (a v2-8/v3-8/v4-8) runs 8 replicas. TPUs exist in **pods** that can run hundreds or thousands of replicas simultaneously. When you use more than a single TPU but less than a whole pod (for example, a v3-32), your TPU fleet is referred to as a **pod slice.**\n\nWhen you access a free TPU via Colab, you generally get a single v2-8 TPU.\n\n### I keep hearing about this XLA thing. What\u2019s XLA, and how does it relate to TPUs?\n\nXLA is an optimizing compiler, used by both TensorFlow and JAX. In JAX it is the only compiler, whereas in TensorFlow it is optional\n3,\tlabel_mask  # Set negative label positions to 0\nmean_loss = tf.reduce_sum(loss) / tf.reduce_sum(label_mask)\n```\n\nHere, we avoid data-dependent shapes by computing the loss for every position, but zeroing out the masked positions in both the numerator and denominator when we calculate the mean, which yields exactly the same result as the first block while maintaining XLA compatibility. Note that we use the same trick as in rule #1 - converting a `tf.bool` to `tf.float32` and using it as an indicator variable. This is a really useful trick, so remember it if you need to convert your own code to XLA!\n\n#### XLA Rule #3: XLA will need to recompile your model for every different input shape it sees\n\nThis is the big one. What this means is that if your input shapes are very variable, XLA will have to recompile your model over and over, which will create huge performance problems. This commonly arises in NLP models, where input texts have variable lengths after tokenization. In other modalities, static shapes are more common and this rule is much less of a problem.\n\nHow can you get around rule #3? The key is **padding** - if you pad all your inputs to the same length, and then use an `attention_mask`, you can get the same results as you\u2019d get from variable shapes, but without any XLA issues. However, excessive padding can cause severe slowdown too - if you pad all your samples to the maximum length in the whole dataset, you might end up with batches consisting endless padding tokens, which will waste a lot of compute and memory!\n\nThere isn\u2019t a perfect solution to this problem. However, you can try some tricks. One very useful trick is to **pad batches of samples up to a multiple of a number like 32 or 64 tokens.** This often only increases the number of tokens by a small amount, but it hugely reduces the number of unique input shapes, because every input shape now has to be a multiple of 32 or 64. Fewer unique input shapes means fewer XLA compilations!\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** Our tokenizers and data collators have methods that can help you here. You can use `padding=\"max_length\"` or `padding=\"longest\"` when calling tokenizers to get them to output padded data. Our tokenizers and data collators also have a `pad_to_multiple_of` argument that you can use to reduce the number of unique input shapes you see!\n\n</Tip>\n\n### How do I actually train my model on TPU?\n\nOnce your training is XLA-compatible and (if you\u2019re using TPU Node / Colab) your dataset has been prepared appropriately, running on TPU is surprisingly easy! All you really need to change in your code is to add a few lines to initialize your TPU, and to ensure that your model and dataset are created inside a `TPUStrategy` scope. Take a look at [our TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) to see this in action!\n\n### Summary\n\nThere was a lot in here, so let\u2019s summarize with a quick checklist you can follow when you want to get your model ready for TPU training:\n\n- Make sure your code follows the three rules of XLA\n- Compile your model with `jit_compile=True` on CPU/GPU and confirm that you can train it with XLA\n- Either load your dataset into memory or use a TPU-compatible dataset loading approach (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Migrate your code either to Colab (with accelerator set to \u201cTPU\u201d) or a TPU VM on Google Cloud\n- Add TPU initializer code (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Create your `TPUStrategy` and make sure dataset loading and model creation are inside the `strategy.scope()` (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Don\u2019t forget to take `jit_compile=True` out again when you move to TPU!\n- \ud83d\ude4f\ud83d\ude4f\ud83d\ude4f\ud83e\udd7a\ud83e\udd7a\ud83e\udd7a\n- Call model.fit()\n- You did it!\n4,\t!---\nCopyright 2022 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n-->\n\n# Token classification with LayoutLMv3 (PyTorch version)\n\nThis directory contains a script, `run_funsd_cord.py`, that can be used to fine-tune (or evaluate) LayoutLMv3 on form understanding datasets, such as [FUNSD](https://guillaumejaume.github.io/FUNSD/) and [CORD](https://github.com/clovaai/cord).\n\nThe script `run_funsd_cord.py` leverages the \ud83e\udd17 Datasets library and the Trainer API. You can easily customize it to your needs.\n\n## Fine-tuning on FUNSD\n\nFine-tuning LayoutLMv3 for token classification on [FUNSD](https://guillaumejaume.github.io/FUNSD/) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name funsd \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 1e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-funsd\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd. By specifying the `push_to_hub` flag, the model gets uploaded automatically to the hub (regularly), together with a model card, which includes metrics such as precision, recall and F1. Note that you can easily update the model card, as it's just a README file of the respective repo on the hub.\n\nThere's also the \"Training metrics\" [tab](https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd/tensorboard), which shows Tensorboard logs over the course of training. Pretty neat, huh?\n\n## Fine-tuning on CORD\n\nFine-tuning LayoutLMv3 for token classification on [CORD](https://github.com/clovaai/cord) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name cord \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 5e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-cord\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-cord. Note that a model card gets generated automatically in case you specify the `push_to_hub` flag.\n    ```",
            "vector_context": "[Created at: 2025-03-24 13:19:17]\n!---\nCopyright 2022 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n-->\n\n# Token classification with LayoutLMv3 (PyTorch version)\n\nThis directory contains a script, `run_funsd_cord.py`, that can be used to fine-tune (or evaluate) LayoutLMv3 on form understanding datasets, such as [FUNSD](https://guillaumejaume.github.io/FUNSD/) and [CORD](https://github.com/clovaai/cord).\n\nThe script `run_funsd_cord.py` leverages the \ud83e\udd17 Datasets library and the Trainer API. You can easily customize it to your needs.\n\n## Fine-tuning on FUNSD\n\nFine-tuning LayoutLMv3 for token classification on [FUNSD](https://guillaumejaume.github.io/FUNSD/) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name funsd \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 1e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-funsd\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd. By specifying the `push_to_hub` flag, the model gets uploaded automatically to the hub (regularly), together with a model card, which includes metrics such as precision, recall and F1. Note that you can easily update the model card, as it's just a README file of the respective repo on the hub.\n\nThere's also the \"Training metrics\" [tab](https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd/tensorboard), which shows Tensorboard logs over the course of training. Pretty neat, huh?\n\n## Fine-tuning on CORD\n\nFine-tuning LayoutLMv3 for token classification on [CORD](https://github.com/clovaai/cord) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name cord \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 5e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-cord\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-cord. Note that a model card gets generated automatically in case you specify the `push_to_hub` flag.\n--New Chunk--\n[Created at: 2025-03-24 13:16:13]\n=predictions, references=references)\n>>> results\n{'exact_match': 100.0, 'f1': 100.0}\n```\n\nYou can find examples of dataset structures by consulting the \"Dataset Preview\" function or the dataset card for a given dataset, and you can see how to use its dedicated evaluation function based on the metric card.\n--New Chunk--\n[Created at: 2025-03-24 13:16:13]\nChoosing a metric for your task\n\n**So you've trained your model and want to see how well it\u2019s doing on a dataset of your choice. Where do you start?**\n\nThere is no \u201cone size fits all\u201d approach to choosing an evaluation metric, but some good guidelines to keep in mind are:\n\n## Categories of metrics\n\nThere are 3 high-level categories of metrics:\n\n1. *Generic metrics*, which can be applied to a variety of situations and datasets, such as precision and accuracy.\n2. *Task-specific metrics*, which are limited to a given task, such as Machine Translation (often evaluated using metrics [BLEU](https://huggingface.co/metrics/bleu) or [ROUGE](https://huggingface.co/metrics/rouge)) or Named Entity Recognition (often evaluated with [seqeval](https://huggingface.co/metrics/seqeval)).\n3. *Dataset-specific metrics*, which aim to measure model performance on specific benchmarks: for instance, the [GLUE benchmark](https://huggingface.co/datasets/glue) has a dedicated [evaluation metric](https://huggingface.co/metrics/glue).\n\nLet's look at each of these three cases:\n\n### Generic metrics\n\nMany of the metrics used in the Machine Learning community are quite generic and can be applied in a variety of tasks and datasets.\n\nThis is the case for metrics like [accuracy](https://huggingface.co/metrics/accuracy) and [precision](https://huggingface.co/metrics/precision), which can be used for evaluating labeled (supervised) datasets, as well as [perplexity](https://huggingface.co/metrics/perplexity), which can be used for evaluating different kinds of (unsupervised) generative tasks.\n\nTo see the input structure of a given metric, you can look at its metric card. For example, in the case of [precision](https://huggingface.co/metrics/precision), the format is:\n```\n>>> precision_metric = evaluate.load(\"precision\")\n>>> results = precision_metric.compute(references=[0, 1], predictions=[0, 1])\n>>> print(results)\n{'precision': 1.0}\n```\n\n### Task-specific metrics\n\nPopular ML tasks like Machine Translation and Named Entity Recognition have specific metrics that can be used to compare models. For example, a series of different metrics have been proposed for text generation, ranging from [BLEU](https://huggingface.co/metrics/bleu) and its derivatives such as [GoogleBLEU](https://huggingface.co/metrics/google_bleu) and [GLEU](https://huggingface.co/metrics/gleu), but also [ROUGE](https://huggingface.co/metrics/rouge), [MAUVE](https://huggingface.co/metrics/mauve), etc.\n\nYou can find the right metric for your task by:\n\n- **Looking at the [Task pages](https://huggingface.co/tasks)** to see what metrics can be used for evaluating models for a given task.\n- **Checking out leaderboards** on sites like [Papers With Code](https://paperswithcode.com/) (you can search by task and by dataset).\n-  **Reading the metric cards** for the relevant metrics and see which ones are a good fit for your use case. For example, see the [BLEU metric card](https://github.com/huggingface/evaluate/tree/main/metrics/bleu) or [SQuaD metric card](https://github.com/huggingface/evaluate/tree/main/metrics/squad).\n- **Looking at papers and blog posts** published on the topic and see what metrics they report. This can change over time, so try to pick papers from the last couple of years!\n\n### Dataset-specific metrics\n\nSome datasets have specific metrics associated with them -- this is especially in the case of popular benchmarks like [GLUE](https://huggingface.co/metrics/glue) and [SQuAD](https://huggingface.co/metrics/squad).\n\n<Tip warning={true}>\n\ud83d\udca1\nGLUE is actually a collection of different subsets on different tasks, so first you need to choose the one that corresponds to the NLI task, such as mnli, which is described as \u201ccrowdsourced collection of sentence pairs with textual entailment annotations\u201d\n</Tip>\n\n\nIf you are evaluating your model on a benchmark dataset like the ones mentioned above, you can use its dedicated evaluation metric. Make sure you respect the format that they require. For example, to evaluate your model on the [SQuAD](https://huggingface.co/datasets/squad) dataset, you need to feed the `question` and `context` into your model and return the `prediction_text`, which should be compared with the `references` (based on matching the `id` of the question) :\n\n```\n>>> from evaluate import load\n>>> squad_metric = load(\"squad\")\n>>> predictions = [{'prediction_text': '1976', 'id': '56e10a3be3433e1400422b22'}]\n>>> references = [{'answers': {'answer_start': [97], 'text': ['1976']}, 'id': '56e10a3be3433e1400422b22'}]\n>>> results = squad_metric.compute(predictions=predictions, references=references)\n>>> results\n{'exact_match': 100.0, 'f1': 100.0}\n```\n\nYou can find examples of dataset structures by consulting the \"Dataset Preview\" function or the dataset card for a given dataset, and you can see how to use its dedicated evaluation function based on the metric card."
        }
    },
    {
        "sample_idx": 121,
        "question": "How many top categories per image are printed in the given code?",
        "answer": "5",
        "rag_answer": "This conversation just started. There is no given code, so it's not possible to determine how many top categories per image are printed. If you provide the code, I'd be happy to help you with your question.",
        "rag_score": null,
        "rag_feedback": null,
        "rag_context": {
            "kg_context": "-----Entities-----\n    ```csv\n    id,\tentity,\ttype,\tdescription,\trankcreated_at\n1,\tGradio,organization,Gradio is a platform that supports state in Blocks, providing features such as global state and session state.<SEP>Gradio is an interface that provides various features for demonstrating models, including adding example inputs, custom error messages, descriptive content, flagging, and more.<SEP>Gradio is an organization that provides a platform for building and deploying machine learning models.<SEP>Gradio is an organization that provides a platform for creating and deploying machine learning models.<SEP>Gradio is an organization that provides a demo for blocks_random_slider, and its library is used to create interactive interfaces.,36,2025-03-24 13:18:20\n2,\tImage,category,Image is a category of data type that can be processed by Gradio components.,1,2025-03-24 13:18:20\n3,\tPIL,technology,PIL is a type of image processing library that can be used with Gradio components.,1,2025-03-24 13:18:20\n4,\tKeras,category,Keras is a high-level neural networks API, used for building and training neural networks.<SEP>Keras is a machine learning framework that uses XLA for optimization.,2,2025-03-24 13:18:20\n5,\tXLA,technology,XLA is a technology that compiles TensorFlow graphs into executable code for various platforms.<SEP>XLA is an optimizing compiler used by TensorFlow and JAX to improve performance.<SEP>XLA is an optimizing compiler, used by both TensorFlow and JAX to optimize computations.,6,2025-03-24 13:18:20\n6,\tImage,category,Image is a category of data type that can be processed by Gradio components.,1,UNKNOWN\n7,\tused_letters_var,category,used_letters_var is a variable that stores the used letters in the hangman game.,1,UNKNOWN\n8,\t run_funsd_cord.py,event,run_funsd_cord.py is a script used for fine-tuning the LayoutLMv3 model.,0,UNKNOWN\n    ```\n    -----Relationships-----\n    ```csv\n    id,\tsource,\ttarget,\tdescription,\tkeywords,\tweight,\trank,\tcreated_at\n1,\tGradio,Image,Gradio provides components that can process Image data types.,data processing, image handling,16.0,37,2025-03-24 13:17:31\n2,\tGradio,PIL,Gradio can use PIL library for image processing.,library integration, image processing,14.0,37,2025-03-24 13:17:31\n3,\tKeras,XLA,Keras uses XLA for optimization.,compiler, performance optimization,8.0,8,2025-03-24 13:18:20\n4,\tGradio,Image,Gradio provides components that can process Image data types.,data processing, image handling,16.0,37,UNKNOWN\n5,\tguess_letter,used_letters_var,used_letters_var is updated by the guess_letter function.,variable update, game logic,8.0,3,UNKNOWN\n    ```\n    -----Sources-----\n    ```csv\n    id,\tcontent\n1,\t\u65f6\u5fc5\u987b\u9009\u62e9\u5176\u4e2d\u4e00\u4e2a\u5b57\u7b26\u4e32\uff0c\u8fd9\u5c06\u4f5c\u4e3a\u9644\u52a0\u5217\u4fdd\u5b58\u5230 CSV \u4e2d\u3002\n\n## \u9884\u5904\u7406\u548c\u540e\u5904\u7406 (Preprocessing and Postprocessing)\n\n![annotated](/assets/img/dataflow.svg)\n\n\u5982\u60a8\u6240\u89c1\uff0cGradio \u5305\u62ec\u53ef\u4ee5\u5904\u7406\u5404\u79cd\u4e0d\u540c\u6570\u636e\u7c7b\u578b\u7684\u7ec4\u4ef6\uff0c\u4f8b\u5982\u56fe\u50cf\u3001\u97f3\u9891\u548c\u89c6\u9891\u3002\u5927\u591a\u6570\u7ec4\u4ef6\u90fd\u53ef\u4ee5\u7528\u4f5c\u8f93\u5165\u6216\u8f93\u51fa\u3002\n\n\u5f53\u7ec4\u4ef6\u7528\u4f5c\u8f93\u5165\u65f6\uff0cGradio \u81ea\u52a8\u5904\u7406*\u9884\u5904\u7406*\uff0c\u5c06\u6570\u636e\u4ece\u7528\u6237\u6d4f\u89c8\u5668\u53d1\u9001\u7684\u7c7b\u578b\uff08\u4f8b\u5982\u7f51\u7edc\u6444\u50cf\u5934\u5feb\u7167\u7684 base64 \u8868\u793a\uff09\u8f6c\u6362\u4e3a\u60a8\u7684\u51fd\u6570\u53ef\u4ee5\u63a5\u53d7\u7684\u5f62\u5f0f\uff08\u4f8b\u5982 `numpy` \u6570\u7ec4\uff09\u3002\n\n\u540c\u6837\uff0c\u5f53\u7ec4\u4ef6\u7528\u4f5c\u8f93\u51fa\u65f6\uff0cGradio \u81ea\u52a8\u5904\u7406*\u540e\u5904\u7406*\uff0c\u5c06\u6570\u636e\u4ece\u51fd\u6570\u8fd4\u56de\u7684\u5f62\u5f0f\uff08\u4f8b\u5982\u56fe\u50cf\u8def\u5f84\u5217\u8868\uff09\u8f6c\u6362\u4e3a\u53ef\u4ee5\u5728\u7528\u6237\u6d4f\u89c8\u5668\u4e2d\u663e\u793a\u7684\u5f62\u5f0f\uff08\u4f8b\u5982\u4ee5 base64 \u683c\u5f0f\u663e\u793a\u56fe\u50cf\u7684 `Gallery`\uff09\u3002\n\n\u60a8\u53ef\u4ee5\u4f7f\u7528\u6784\u5efa\u56fe\u50cf\u7ec4\u4ef6\u65f6\u7684\u53c2\u6570\u63a7\u5236*\u9884\u5904\u7406*\u3002\u4f8b\u5982\uff0c\u5982\u679c\u60a8\u4f7f\u7528\u4ee5\u4e0b\u53c2\u6570\u5b9e\u4f8b\u5316 `Image` \u7ec4\u4ef6\uff0c\u5b83\u5c06\u5c06\u56fe\u50cf\u8f6c\u6362\u4e3a `PIL` \u7c7b\u578b\uff0c\u5e76\u5c06\u5176\u91cd\u5851\u4e3a`(100, 100)`\uff0c\u800c\u4e0d\u7ba1\u63d0\u4ea4\u65f6\u7684\u539f\u59cb\u5927\u5c0f\u5982\u4f55\uff1a\n\n```py\nimg = gr.Image(shape=(100, 100), type=\"pil\")\n```\n\n\u76f8\u53cd\uff0c\u8fd9\u91cc\u6211\u4eec\u4fdd\u7559\u56fe\u50cf\u7684\u539f\u59cb\u5927\u5c0f\uff0c\u4f46\u5728\u5c06\u5176\u8f6c\u6362\u4e3a numpy \u6570\u7ec4\u4e4b\u524d\u53cd\u8f6c\u989c\u8272\uff1a\n\n```py\nimg = gr.Image(invert_colors=True, type=\"numpy\")\n```\n\n\u540e\u5904\u7406\u8981\u5bb9\u6613\u5f97\u591a\uff01Gradio \u81ea\u52a8\u8bc6\u522b\u8fd4\u56de\u6570\u636e\u7684\u683c\u5f0f\uff08\u4f8b\u5982 `Image` \u662f `numpy` \u6570\u7ec4\u8fd8\u662f `str` \u6587\u4ef6\u8def\u5f84\uff1f\uff09\uff0c\u5e76\u5c06\u5176\u540e\u5904\u7406\u4e3a\u53ef\u4ee5\u7531\u6d4f\u89c8\u5668\u663e\u793a\u7684\u683c\u5f0f\u3002\n\n\u8bf7\u67e5\u770b[\u6587\u6863](https://gradio.app/docs)\uff0c\u4e86\u89e3\u6bcf\u4e2a\u7ec4\u4ef6\u7684\u6240\u6709\u4e0e\u9884\u5904\u7406\u76f8\u5173\u7684\u53c2\u6570\u3002\n\n## \u6837\u5f0f (Styling)\n\nGradio \u4e3b\u9898\u662f\u81ea\u5b9a\u4e49\u5e94\u7528\u7a0b\u5e8f\u5916\u89c2\u548c\u611f\u89c9\u7684\u6700\u7b80\u5355\u65b9\u6cd5\u3002\u60a8\u53ef\u4ee5\u9009\u62e9\u591a\u79cd\u4e3b\u9898\u6216\u521b\u5efa\u81ea\u5df1\u7684\u4e3b\u9898\u3002\u8981\u8fd9\u6837\u505a\uff0c\u8bf7\u5c06 `theme=` \u53c2\u6570\u4f20\u9012\u7ed9 `Interface` \u6784\u9020\u51fd\u6570\u3002\u4f8b\u5982\uff1a\n\n```python\ndemo = gr.Interface(..., theme=gr.themes.Monochrome())\n```\n\nGradio \u5e26\u6709\u4e00\u7ec4\u9884\u5148\u6784\u5efa\u7684\u4e3b\u9898\uff0c\u60a8\u53ef\u4ee5\u4ece `gr.themes.*` \u52a0\u8f7d\u3002\u60a8\u53ef\u4ee5\u6269\u5c55\u8fd9\u4e9b\u4e3b\u9898\u6216\u4ece\u5934\u5f00\u59cb\u521b\u5efa\u81ea\u5df1\u7684\u4e3b\u9898 - \u6709\u5173\u66f4\u591a\u8be6\u7ec6\u4fe1\u606f\uff0c\u8bf7\u53c2\u9605[\u4e3b\u9898\u6307\u5357](https://gradio.app/theming-guide)\u3002\n\n\u8981\u589e\u52a0\u989d\u5916\u7684\u6837\u5f0f\u80fd\u529b\uff0c\u60a8\u53ef\u4ee5 with `css=` \u5173\u952e\u5b57\u5c06\u4efb\u4f55 CSS \u4f20\u9012\u7ed9\u60a8\u7684\u5e94\u7528\u7a0b\u5e8f\u3002\nGradio \u5e94\u7528\u7a0b\u5e8f\u7684\u57fa\u7c7b\u662f `gradio-container`\uff0c\u56e0\u6b64\u4ee5\u4e0b\u662f\u4e00\u4e2a\u66f4\u6539 Gradio \u5e94\u7528\u7a0b\u5e8f\u80cc\u666f\u989c\u8272\u7684\u793a\u4f8b\uff1a\n\n```python\nwith `gr.Interface(css=\".gradio-container {background-color: red}\") as demo:\n    ...\n```\n\n## \u961f\u5217 (Queuing)\n\n\u5982\u679c\u60a8\u7684\u5e94\u7528\u7a0b\u5e8f\u9884\u8ba1\u4f1a\u6709\u5927\u91cf\u6d41\u91cf\uff0c\u8bf7 with `queue()` \u65b9\u6cd5\u6765\u63a7\u5236\u5904\u7406\u901f\u7387\u3002\u8fd9\u5c06\u6392\u961f\u5904\u7406\u8c03\u7528\uff0c\u56e0\u6b64\u4e00\u6b21\u53ea\u5904\u7406\u4e00\u5b9a\u6570\u91cf\u7684\u8bf7\u6c42\u3002\u961f\u5217\u4f7f\u7528 Websockets\uff0c\u8fd8\u53ef\u4ee5\u9632\u6b62\u7f51\u7edc\u8d85\u65f6\uff0c\u56e0\u6b64\u5982\u679c\u60a8\u7684\u51fd\u6570\u7684\u63a8\u7406\u65f6\u95f4\u5f88\u957f\uff08> 1 \u5206\u949f\uff09\uff0c\u5e94\u4f7f\u7528\u961f\u5217\u3002\n\nwith `Interface`\uff1a\n\n```python\ndemo = gr.Interface(...).queue()\ndemo.launch()\n```\n\nwith `Blocks`\uff1a\n\n```python\nwith gr.Blocks() as demo\uff1a\n    #...\ndemo.queue()\ndemo.launch()\n```\n\n\u60a8\u53ef\u4ee5\u901a\u8fc7\u4ee5\u4e0b\u65b9\u5f0f\u63a7\u5236\u4e00\u6b21\u5904\u7406\u7684\u8bf7\u6c42\u6570\u91cf\uff1a\n\n```python\ndemo.queue(concurrency_count=3)\n```\n\n\u67e5\u770b\u6709\u5173\u914d\u7f6e\u5176\u4ed6\u961f\u5217\u53c2\u6570\u7684[\u961f\u5217\u6587\u6863](/docs/#queue)\u3002\n\n\u5728 Blocks \u4e2d\u6307\u5b9a\u4ec5\u5bf9\u67d0\u4e9b\u51fd\u6570\u8fdb\u884c\u6392\u961f\uff1a\n\n```python\nwith gr.Blocks() as demo2\uff1a\n    num1 = gr.Number()\n    num2 = gr.Number()\n    output = gr.Number()\n    gr.Button(\"Add\").click(\n        lambda a, b: a + b, [num1, num2], output)\n    gr.Button(\"Multiply\").click(\n        lambda a, b: a * b, [num1, num2], output, queue=True)\ndemo2.launch()\n```\n\n## \u8fed\u4ee3\u8f93\u51fa (Iterative Outputs)\n\n\u5728\u67d0\u4e9b\u60c5\u51b5\u4e0b\uff0c\u60a8\u53ef\u80fd\u9700\u8981\u4f20\u8f93\u4e00\u7cfb\u5217\u8f93\u51fa\u800c\u4e0d\u662f\u4e00\u6b21\u663e\u793a\u5355\u4e2a\u8f93\u51fa\u3002\u4f8b\u5982\uff0c\u60a8\u53ef\u80fd\u6709\u4e00\u4e2a\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5e0c\u671b\u663e\u793a\u751f\u6210\u7684\u6bcf\u4e2a\u6b65\u9aa4\u7684\u56fe\u50cf\uff0c\u76f4\u5230\u6700\u7ec8\u56fe\u50cf\u3002\u6216\u8005\u60a8\u53ef\u80fd\u6709\u4e00\u4e2a\u804a\u5929\u673a\u5668\u4eba\uff0c\u5b83\u9010\u5b57\u9010\u53e5\u5730\u6d41\u5f0f\u4f20\u8f93\u54cd\u5e94\uff0c\u800c\u4e0d\u662f\u4e00\u6b21\u8fd4\u56de\u5168\u90e8\u54cd\u5e94\u3002\n\n\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u60a8\u53ef\u4ee5\u5c06**\u751f\u6210\u5668**\u51fd\u6570\u63d0\u4f9b\u7ed9 Gradio\uff0c\u800c\u4e0d\u662f\u5e38\u89c4\u51fd\u6570\u3002\u5728 Python \u4e2d\u521b\u5efa\u751f\u6210\u5668\u975e\u5e38\u7b80\u5355\uff1a\u51fd\u6570\u4e0d\u5e94\u8be5\u6709\u4e00\u4e2a\u5355\u72ec\u7684 `return` \u503c\uff0c\u800c\u662f\u5e94\u8be5 with `yield` \u8fde\u7eed\u8fd4\u56de\u4e00\u7cfb\u5217\u503c\u3002\u901a\u5e38\uff0c`yield` \u8bed\u53e5\u653e\u7f6e\u5728\u67d0\u79cd\u5faa\u73af\u4e2d\u3002\u4e0b\u9762\u662f\u4e00\u4e2a\u7b80\u5355\u793a\u4f8b\uff0c\u751f\u6210\u5668\u53ea\u662f\u7b80\u5355\u8ba1\u6570\u5230\u7ed9\u5b9a\u6570\u5b57\uff1a\n\n```python\ndef my_generator(x):\n    for i in range(x):\n        yield i\n```\n\n\u60a8\u4ee5\u4e0e\u5e38\u89c4\u51fd\u6570\u76f8\u540c\u7684\u65b9\u5f0f\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio\u3002\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\uff08\u865a\u62df\u7684\uff09\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5b83\u5728\u8f93\u51fa\u56fe\u50cf\u4e4b\u524d\u751f\u6210\u6570\u4e2a\u6b65\u9aa4\u7684\u566a\u97f3\uff1a\n\n$code_fake_diffusion\n$demo_fake_diffusion\n\n\u8bf7\u6ce8\u610f\uff0c\u6211\u4eec\u5728\u8fed\u4ee3\u5668\u4e2d\u6dfb\u52a0\u4e86 `time.sleep(1)`\uff0c\u4ee5\u521b\u5efa\u6b65\u9aa4\u4e4b\u95f4\u7684\u4eba\u5de5\u6682\u505c\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u89c2\u5bdf\u8fed\u4ee3\u5668\u7684\u6b65\u9aa4\uff08\u5728\u771f\u5b9e\u7684\u56fe\u50cf\u751f\u6210\u6a21\u578b\u4e2d\uff0c\u8fd9\n2,\t(for example, a v3-32), your TPU fleet is referred to as a **pod slice.**\n\nWhen you access a free TPU via Colab, you generally get a single v2-8 TPU.\n\n### I keep hearing about this XLA thing. What\u2019s XLA, and how does it relate to TPUs?\n\nXLA is an optimizing compiler, used by both TensorFlow and JAX. In JAX it is the only compiler, whereas in TensorFlow it is optional (but mandatory on TPU!). The easiest way to enable it when training a Keras model is to pass the argument `jit_compile=True` to `model.compile()`. If you don\u2019t get any errors and performance is good, that\u2019s a great sign that you\u2019re ready to move to TPU!\n\nDebugging on TPU is generally a bit harder than on CPU/GPU, so we recommend getting your code running on CPU/GPU with XLA first before trying it on TPU. You don\u2019t have to train for long, of course - just for a few steps to make sure that your model and data pipeline are working like you expect them to.\n\n<Tip>\n\nXLA compiled code is usually faster - so even if you\u2019re not planning to run on TPU, adding `jit_compile=True` can improve your performance. Be sure to note the caveats below about XLA compatibility, though!\n\n</Tip>\n\n<Tip warning={true}>\n\n**Tip born of painful experience:** Although using `jit_compile=True` is a good way to get a speed boost and test if your CPU/GPU code is XLA-compatible, it can actually cause a lot of problems if you leave it in when actually training on TPU. XLA compilation will happen implicitly on TPU, so remember to remove that line before actually running your code on a TPU!\n\n</Tip>\n\n### How do I make my model XLA compatible?\n\nIn many cases, your code is probably XLA-compatible already! However, there are a few things that work in normal TensorFlow that don\u2019t work in XLA. We\u2019ve distilled them into three core rules below:\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** We\u2019ve put a lot of effort into rewriting our TensorFlow models and loss functions to be XLA-compatible. Our models and loss functions generally obey rule #1 and #2 by default, so you can skip over them if you\u2019re using `transformers` models. Don\u2019t forget about these rules when writing your own models and loss functions, though!\n\n</Tip>\n\n#### XLA Rule #1: Your code cannot have \u201cdata-dependent conditionals\u201d\n\nWhat that means is that any `if` statement cannot depend on values inside a `tf.Tensor`. For example, this code block cannot be compiled with XLA!\n\n```python\nif tf.reduce_sum(tensor) > 10:\n    tensor = tensor / 2.0\n```\n\nThis might seem very restrictive at first, but most neural net code doesn\u2019t need to do this. You can often get around this restriction by using `tf.cond` (see the documentation [here](https://www.tensorflow.org/api_docs/python/tf/cond)) or by removing the conditional and finding a clever math trick with indicator variables instead, like so:\n\n```python\nsum_over_10 = tf.cast(tf.reduce_sum(tensor) > 10, tf.float32)\ntensor = tensor / (1.0 + sum_over_10)\n```\n\nThis code has exactly the same effect as the code above, but by avoiding a conditional, we ensure it will compile with XLA without problems!\n\n#### XLA Rule #2: Your code cannot have \u201cdata-dependent shapes\u201d\n\nWhat this means is that the shape of all of the `tf.Tensor` objects in your code cannot depend on their values. For example, the function `tf.unique` cannot be compiled with XLA, because it returns a `tensor` containing one instance of each unique value in the input. The shape of this output will obviously be different depending on how repetitive the input `Tensor` was, and so XLA refuses to handle it!\n\nIn general, most neural network code obeys rule #2 by default. However, there are a few common cases where it becomes a problem. One very common one is when you use **label masking**, setting your labels to a negative value to indicate that those positions should be ignored when computing the loss. If you look at NumPy or PyTorch loss functions that support label masking, you will often see code like this that uses [boolean indexing](https://numpy.org/doc/stable/user/basics.indexing.html#boolean-array-indexing):\n\n```python\nlabel_mask = labels >= 0\nmasked_outputs = outputs[label_mask]\nmasked_labels = labels[label_mask]\nloss = compute_loss(masked_outputs, masked_labels)\nmean_loss = torch.mean(loss)\n```\n\nThis code is totally fine in NumPy or PyTorch, but it breaks in XLA! Why? Because the shape of `masked_outputs` and `masked_labels` depends on how many positions are masked - that makes it a **data-dependent shape.** However, just like for rule #1, we can often rewrite this code to yield exactly the same output without any data-dependent shapes.\n\n```python\nlabel_mask = tf.cast(labels >= 0, tf.float32)\nloss = compute_loss(outputs, labels)\nloss = loss * label_mask  # Set negative label positions to 0\nmean_loss = tf.reduce_sum(loss) / tf.reduce_sum(label_mask)\n```\n\nHere, we avoid data-dependent shapes by computing the loss for every position, but zeroing out the masked positions in both the numerator and denominator when we calculate the mean, which yields exactly the same result as the first block while maintaining XLA compatibility. Note that we use the same trick as in rule #1 - converting a `tf.bool` to `\n3,\tState in Blocks\n\nWe covered [State in Interfaces](https://gradio.app/interface-state), this guide takes a look at state in Blocks, which works mostly the same.\n\n## Global State\n\nGlobal state in Blocks works the same as in Interface. Any variable created outside a function call is a reference shared between all users.\n\n## Session State\n\nGradio supports session **state**, where data persists across multiple submits within a page session, in Blocks apps as well. To reiterate, session data is _not_ shared between different users of your model. To store data in a session state, you need to do three things:\n\n1. Create a `gr.State()` object. If there is a default value to this stateful object, pass that into the constructor.\n2. In the event listener, put the `State` object as an input and output.\n3. In the event listener function, add the variable to the input parameters and the return value.\n\nLet's take a look at a game of hangman.\n\n$code_hangman\n$demo_hangman\n\nLet's see how we do each of the 3 steps listed above in this game:\n\n1. We store the used letters in `used_letters_var`. In the constructor of `State`, we set the initial value of this to `[]`, an empty list.\n2. In `btn.click()`, we have a reference to `used_letters_var` in both the inputs and outputs.\n3. In `guess_letter`, we pass the value of this `State` to `used_letters`, and then return an updated value of this `State` in the return statement.\n\nWith more complex apps, you will likely have many State variables storing session state in a single Blocks app.\n\nLearn more about `State` in the [docs](https://gradio.app/docs#state).\n4,\t!---\nCopyright 2022 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n-->\n\n# Token classification with LayoutLMv3 (PyTorch version)\n\nThis directory contains a script, `run_funsd_cord.py`, that can be used to fine-tune (or evaluate) LayoutLMv3 on form understanding datasets, such as [FUNSD](https://guillaumejaume.github.io/FUNSD/) and [CORD](https://github.com/clovaai/cord).\n\nThe script `run_funsd_cord.py` leverages the \ud83e\udd17 Datasets library and the Trainer API. You can easily customize it to your needs.\n\n## Fine-tuning on FUNSD\n\nFine-tuning LayoutLMv3 for token classification on [FUNSD](https://guillaumejaume.github.io/FUNSD/) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name funsd \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 1e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-funsd\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd. By specifying the `push_to_hub` flag, the model gets uploaded automatically to the hub (regularly), together with a model card, which includes metrics such as precision, recall and F1. Note that you can easily update the model card, as it's just a README file of the respective repo on the hub.\n\nThere's also the \"Training metrics\" [tab](https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd/tensorboard), which shows Tensorboard logs over the course of training. Pretty neat, huh?\n\n## Fine-tuning on CORD\n\nFine-tuning LayoutLMv3 for token classification on [CORD](https://github.com/clovaai/cord) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name cord \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 5e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-cord\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-cord. Note that a model card gets generated automatically in case you specify the `push_to_hub` flag.\n    ```",
            "vector_context": "[Created at: 2025-03-24 13:16:48]\n\u65f6\u5fc5\u987b\u9009\u62e9\u5176\u4e2d\u4e00\u4e2a\u5b57\u7b26\u4e32\uff0c\u8fd9\u5c06\u4f5c\u4e3a\u9644\u52a0\u5217\u4fdd\u5b58\u5230 CSV \u4e2d\u3002\n\n## \u9884\u5904\u7406\u548c\u540e\u5904\u7406 (Preprocessing and Postprocessing)\n\n![annotated](/assets/img/dataflow.svg)\n\n\u5982\u60a8\u6240\u89c1\uff0cGradio \u5305\u62ec\u53ef\u4ee5\u5904\u7406\u5404\u79cd\u4e0d\u540c\u6570\u636e\u7c7b\u578b\u7684\u7ec4\u4ef6\uff0c\u4f8b\u5982\u56fe\u50cf\u3001\u97f3\u9891\u548c\u89c6\u9891\u3002\u5927\u591a\u6570\u7ec4\u4ef6\u90fd\u53ef\u4ee5\u7528\u4f5c\u8f93\u5165\u6216\u8f93\u51fa\u3002\n\n\u5f53\u7ec4\u4ef6\u7528\u4f5c\u8f93\u5165\u65f6\uff0cGradio \u81ea\u52a8\u5904\u7406*\u9884\u5904\u7406*\uff0c\u5c06\u6570\u636e\u4ece\u7528\u6237\u6d4f\u89c8\u5668\u53d1\u9001\u7684\u7c7b\u578b\uff08\u4f8b\u5982\u7f51\u7edc\u6444\u50cf\u5934\u5feb\u7167\u7684 base64 \u8868\u793a\uff09\u8f6c\u6362\u4e3a\u60a8\u7684\u51fd\u6570\u53ef\u4ee5\u63a5\u53d7\u7684\u5f62\u5f0f\uff08\u4f8b\u5982 `numpy` \u6570\u7ec4\uff09\u3002\n\n\u540c\u6837\uff0c\u5f53\u7ec4\u4ef6\u7528\u4f5c\u8f93\u51fa\u65f6\uff0cGradio \u81ea\u52a8\u5904\u7406*\u540e\u5904\u7406*\uff0c\u5c06\u6570\u636e\u4ece\u51fd\u6570\u8fd4\u56de\u7684\u5f62\u5f0f\uff08\u4f8b\u5982\u56fe\u50cf\u8def\u5f84\u5217\u8868\uff09\u8f6c\u6362\u4e3a\u53ef\u4ee5\u5728\u7528\u6237\u6d4f\u89c8\u5668\u4e2d\u663e\u793a\u7684\u5f62\u5f0f\uff08\u4f8b\u5982\u4ee5 base64 \u683c\u5f0f\u663e\u793a\u56fe\u50cf\u7684 `Gallery`\uff09\u3002\n\n\u60a8\u53ef\u4ee5\u4f7f\u7528\u6784\u5efa\u56fe\u50cf\u7ec4\u4ef6\u65f6\u7684\u53c2\u6570\u63a7\u5236*\u9884\u5904\u7406*\u3002\u4f8b\u5982\uff0c\u5982\u679c\u60a8\u4f7f\u7528\u4ee5\u4e0b\u53c2\u6570\u5b9e\u4f8b\u5316 `Image` \u7ec4\u4ef6\uff0c\u5b83\u5c06\u5c06\u56fe\u50cf\u8f6c\u6362\u4e3a `PIL` \u7c7b\u578b\uff0c\u5e76\u5c06\u5176\u91cd\u5851\u4e3a`(100, 100)`\uff0c\u800c\u4e0d\u7ba1\u63d0\u4ea4\u65f6\u7684\u539f\u59cb\u5927\u5c0f\u5982\u4f55\uff1a\n\n```py\nimg = gr.Image(shape=(100, 100), type=\"pil\")\n```\n\n\u76f8\u53cd\uff0c\u8fd9\u91cc\u6211\u4eec\u4fdd\u7559\u56fe\u50cf\u7684\u539f\u59cb\u5927\u5c0f\uff0c\u4f46\u5728\u5c06\u5176\u8f6c\u6362\u4e3a numpy \u6570\u7ec4\u4e4b\u524d\u53cd\u8f6c\u989c\u8272\uff1a\n\n```py\nimg = gr.Image(invert_colors=True, type=\"numpy\")\n```\n\n\u540e\u5904\u7406\u8981\u5bb9\u6613\u5f97\u591a\uff01Gradio \u81ea\u52a8\u8bc6\u522b\u8fd4\u56de\u6570\u636e\u7684\u683c\u5f0f\uff08\u4f8b\u5982 `Image` \u662f `numpy` \u6570\u7ec4\u8fd8\u662f `str` \u6587\u4ef6\u8def\u5f84\uff1f\uff09\uff0c\u5e76\u5c06\u5176\u540e\u5904\u7406\u4e3a\u53ef\u4ee5\u7531\u6d4f\u89c8\u5668\u663e\u793a\u7684\u683c\u5f0f\u3002\n\n\u8bf7\u67e5\u770b[\u6587\u6863](https://gradio.app/docs)\uff0c\u4e86\u89e3\u6bcf\u4e2a\u7ec4\u4ef6\u7684\u6240\u6709\u4e0e\u9884\u5904\u7406\u76f8\u5173\u7684\u53c2\u6570\u3002\n\n## \u6837\u5f0f (Styling)\n\nGradio \u4e3b\u9898\u662f\u81ea\u5b9a\u4e49\u5e94\u7528\u7a0b\u5e8f\u5916\u89c2\u548c\u611f\u89c9\u7684\u6700\u7b80\u5355\u65b9\u6cd5\u3002\u60a8\u53ef\u4ee5\u9009\u62e9\u591a\u79cd\u4e3b\u9898\u6216\u521b\u5efa\u81ea\u5df1\u7684\u4e3b\u9898\u3002\u8981\u8fd9\u6837\u505a\uff0c\u8bf7\u5c06 `theme=` \u53c2\u6570\u4f20\u9012\u7ed9 `Interface` \u6784\u9020\u51fd\u6570\u3002\u4f8b\u5982\uff1a\n\n```python\ndemo = gr.Interface(..., theme=gr.themes.Monochrome())\n```\n\nGradio \u5e26\u6709\u4e00\u7ec4\u9884\u5148\u6784\u5efa\u7684\u4e3b\u9898\uff0c\u60a8\u53ef\u4ee5\u4ece `gr.themes.*` \u52a0\u8f7d\u3002\u60a8\u53ef\u4ee5\u6269\u5c55\u8fd9\u4e9b\u4e3b\u9898\u6216\u4ece\u5934\u5f00\u59cb\u521b\u5efa\u81ea\u5df1\u7684\u4e3b\u9898 - \u6709\u5173\u66f4\u591a\u8be6\u7ec6\u4fe1\u606f\uff0c\u8bf7\u53c2\u9605[\u4e3b\u9898\u6307\u5357](https://gradio.app/theming-guide)\u3002\n\n\u8981\u589e\u52a0\u989d\u5916\u7684\u6837\u5f0f\u80fd\u529b\uff0c\u60a8\u53ef\u4ee5 with `css=` \u5173\u952e\u5b57\u5c06\u4efb\u4f55 CSS \u4f20\u9012\u7ed9\u60a8\u7684\u5e94\u7528\u7a0b\u5e8f\u3002\nGradio \u5e94\u7528\u7a0b\u5e8f\u7684\u57fa\u7c7b\u662f `gradio-container`\uff0c\u56e0\u6b64\u4ee5\u4e0b\u662f\u4e00\u4e2a\u66f4\u6539 Gradio \u5e94\u7528\u7a0b\u5e8f\u80cc\u666f\u989c\u8272\u7684\u793a\u4f8b\uff1a\n\n```python\nwith `gr.Interface(css=\".gradio-container {background-color: red}\") as demo:\n    ...\n```\n\n## \u961f\u5217 (Queuing)\n\n\u5982\u679c\u60a8\u7684\u5e94\u7528\u7a0b\u5e8f\u9884\u8ba1\u4f1a\u6709\u5927\u91cf\u6d41\u91cf\uff0c\u8bf7 with `queue()` \u65b9\u6cd5\u6765\u63a7\u5236\u5904\u7406\u901f\u7387\u3002\u8fd9\u5c06\u6392\u961f\u5904\u7406\u8c03\u7528\uff0c\u56e0\u6b64\u4e00\u6b21\u53ea\u5904\u7406\u4e00\u5b9a\u6570\u91cf\u7684\u8bf7\u6c42\u3002\u961f\u5217\u4f7f\u7528 Websockets\uff0c\u8fd8\u53ef\u4ee5\u9632\u6b62\u7f51\u7edc\u8d85\u65f6\uff0c\u56e0\u6b64\u5982\u679c\u60a8\u7684\u51fd\u6570\u7684\u63a8\u7406\u65f6\u95f4\u5f88\u957f\uff08> 1 \u5206\u949f\uff09\uff0c\u5e94\u4f7f\u7528\u961f\u5217\u3002\n\nwith `Interface`\uff1a\n\n```python\ndemo = gr.Interface(...).queue()\ndemo.launch()\n```\n\nwith `Blocks`\uff1a\n\n```python\nwith gr.Blocks() as demo\uff1a\n    #...\ndemo.queue()\ndemo.launch()\n```\n\n\u60a8\u53ef\u4ee5\u901a\u8fc7\u4ee5\u4e0b\u65b9\u5f0f\u63a7\u5236\u4e00\u6b21\u5904\u7406\u7684\u8bf7\u6c42\u6570\u91cf\uff1a\n\n```python\ndemo.queue(concurrency_count=3)\n```\n\n\u67e5\u770b\u6709\u5173\u914d\u7f6e\u5176\u4ed6\u961f\u5217\u53c2\u6570\u7684[\u961f\u5217\u6587\u6863](/docs/#queue)\u3002\n\n\u5728 Blocks \u4e2d\u6307\u5b9a\u4ec5\u5bf9\u67d0\u4e9b\u51fd\u6570\u8fdb\u884c\u6392\u961f\uff1a\n\n```python\nwith gr.Blocks() as demo2\uff1a\n    num1 = gr.Number()\n    num2 = gr.Number()\n    output = gr.Number()\n    gr.Button(\"Add\").click(\n        lambda a, b: a + b, [num1, num2], output)\n    gr.Button(\"Multiply\").click(\n        lambda a, b: a * b, [num1, num2], output, queue=True)\ndemo2.launch()\n```\n\n## \u8fed\u4ee3\u8f93\u51fa (Iterative Outputs)\n\n\u5728\u67d0\u4e9b\u60c5\u51b5\u4e0b\uff0c\u60a8\u53ef\u80fd\u9700\u8981\u4f20\u8f93\u4e00\u7cfb\u5217\u8f93\u51fa\u800c\u4e0d\u662f\u4e00\u6b21\u663e\u793a\u5355\u4e2a\u8f93\u51fa\u3002\u4f8b\u5982\uff0c\u60a8\u53ef\u80fd\u6709\u4e00\u4e2a\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5e0c\u671b\u663e\u793a\u751f\u6210\u7684\u6bcf\u4e2a\u6b65\u9aa4\u7684\u56fe\u50cf\uff0c\u76f4\u5230\u6700\u7ec8\u56fe\u50cf\u3002\u6216\u8005\u60a8\u53ef\u80fd\u6709\u4e00\u4e2a\u804a\u5929\u673a\u5668\u4eba\uff0c\u5b83\u9010\u5b57\u9010\u53e5\u5730\u6d41\u5f0f\u4f20\u8f93\u54cd\u5e94\uff0c\u800c\u4e0d\u662f\u4e00\u6b21\u8fd4\u56de\u5168\u90e8\u54cd\u5e94\u3002\n\n\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u60a8\u53ef\u4ee5\u5c06**\u751f\u6210\u5668**\u51fd\u6570\u63d0\u4f9b\u7ed9 Gradio\uff0c\u800c\u4e0d\u662f\u5e38\u89c4\u51fd\u6570\u3002\u5728 Python \u4e2d\u521b\u5efa\u751f\u6210\u5668\u975e\u5e38\u7b80\u5355\uff1a\u51fd\u6570\u4e0d\u5e94\u8be5\u6709\u4e00\u4e2a\u5355\u72ec\u7684 `return` \u503c\uff0c\u800c\u662f\u5e94\u8be5 with `yield` \u8fde\u7eed\u8fd4\u56de\u4e00\u7cfb\u5217\u503c\u3002\u901a\u5e38\uff0c`yield` \u8bed\u53e5\u653e\u7f6e\u5728\u67d0\u79cd\u5faa\u73af\u4e2d\u3002\u4e0b\u9762\u662f\u4e00\u4e2a\u7b80\u5355\u793a\u4f8b\uff0c\u751f\u6210\u5668\u53ea\u662f\u7b80\u5355\u8ba1\u6570\u5230\u7ed9\u5b9a\u6570\u5b57\uff1a\n\n```python\ndef my_generator(x):\n    for i in range(x):\n        yield i\n```\n\n\u60a8\u4ee5\u4e0e\u5e38\u89c4\u51fd\u6570\u76f8\u540c\u7684\u65b9\u5f0f\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio\u3002\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\uff08\u865a\u62df\u7684\uff09\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5b83\u5728\u8f93\u51fa\u56fe\u50cf\u4e4b\u524d\u751f\u6210\u6570\u4e2a\u6b65\u9aa4\u7684\u566a\u97f3\uff1a\n\n$code_fake_diffusion\n$demo_fake_diffusion\n\n\u8bf7\u6ce8\u610f\uff0c\u6211\u4eec\u5728\u8fed\u4ee3\u5668\u4e2d\u6dfb\u52a0\u4e86 `time.sleep(1)`\uff0c\u4ee5\u521b\u5efa\u6b65\u9aa4\u4e4b\u95f4\u7684\u4eba\u5de5\u6682\u505c\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u89c2\u5bdf\u8fed\u4ee3\u5668\u7684\u6b65\u9aa4\uff08\u5728\u771f\u5b9e\u7684\u56fe\u50cf\u751f\u6210\u6a21\u578b\u4e2d\uff0c\u8fd9\n--New Chunk--\n[Created at: 2025-03-24 13:19:17]\n!---\nCopyright 2022 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n-->\n\n# Token classification with LayoutLMv3 (PyTorch version)\n\nThis directory contains a script, `run_funsd_cord.py`, that can be used to fine-tune (or evaluate) LayoutLMv3 on form understanding datasets, such as [FUNSD](https://guillaumejaume.github.io/FUNSD/) and [CORD](https://github.com/clovaai/cord).\n\nThe script `run_funsd_cord.py` leverages the \ud83e\udd17 Datasets library and the Trainer API. You can easily customize it to your needs.\n\n## Fine-tuning on FUNSD\n\nFine-tuning LayoutLMv3 for token classification on [FUNSD](https://guillaumejaume.github.io/FUNSD/) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name funsd \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 1e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-funsd\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd. By specifying the `push_to_hub` flag, the model gets uploaded automatically to the hub (regularly), together with a model card, which includes metrics such as precision, recall and F1. Note that you can easily update the model card, as it's just a README file of the respective repo on the hub.\n\nThere's also the \"Training metrics\" [tab](https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd/tensorboard), which shows Tensorboard logs over the course of training. Pretty neat, huh?\n\n## Fine-tuning on CORD\n\nFine-tuning LayoutLMv3 for token classification on [CORD](https://github.com/clovaai/cord) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name cord \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 5e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-cord\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-cord. Note that a model card gets generated automatically in case you specify the `push_to_hub` flag.\n--New Chunk--\n[Created at: 2025-03-24 13:16:48]\n\u4e3b\u8981\u7279\u70b9\n\n\u8ba9\u6211\u4eec\u6765\u4ecb\u7ecd\u4e00\u4e0b Gradio \u6700\u53d7\u6b22\u8fce\u7684\u4e00\u4e9b\u529f\u80fd\uff01\u8fd9\u91cc\u662f Gradio \u7684\u4e3b\u8981\u7279\u70b9\uff1a\n\n1. [\u6dfb\u52a0\u793a\u4f8b\u8f93\u5165](#example-inputs)\n2. [\u4f20\u9012\u81ea\u5b9a\u4e49\u9519\u8bef\u6d88\u606f](#errors)\n3. [\u6dfb\u52a0\u63cf\u8ff0\u5185\u5bb9](#descriptive-content)\n4. [\u8bbe\u7f6e\u65d7\u6807](#flagging)\n5. [\u9884\u5904\u7406\u548c\u540e\u5904\u7406](#preprocessing-and-postprocessing)\n6. [\u6837\u5f0f\u5316\u6f14\u793a](#styling)\n7. [\u6392\u961f\u7528\u6237](#queuing)\n8. [\u8fed\u4ee3\u8f93\u51fa](#iterative-outputs)\n9. [\u8fdb\u5ea6\u6761](#progress-bars)\n10. [\u6279\u5904\u7406\u51fd\u6570](#batch-functions)\n11. [\u5728\u534f\u4f5c\u7b14\u8bb0\u672c\u4e0a\u8fd0\u884c](#colab-notebooks)\n\n## \u793a\u4f8b\u8f93\u5165\n\n\u60a8\u53ef\u4ee5\u63d0\u4f9b\u7528\u6237\u53ef\u4ee5\u8f7b\u677e\u52a0\u8f7d\u5230 \"Interface\" \u4e2d\u7684\u793a\u4f8b\u6570\u636e\u3002\u8fd9\u5bf9\u4e8e\u6f14\u793a\u6a21\u578b\u671f\u671b\u7684\u8f93\u5165\u7c7b\u578b\u4ee5\u53ca\u6f14\u793a\u6570\u636e\u96c6\u548c\u6a21\u578b\u4e00\u8d77\u63a2\u7d22\u7684\u65b9\u5f0f\u975e\u5e38\u6709\u5e2e\u52a9\u3002\u8981\u52a0\u8f7d\u793a\u4f8b\u6570\u636e\uff0c\u60a8\u53ef\u4ee5\u5c06\u5d4c\u5957\u5217\u8868\u63d0\u4f9b\u7ed9 Interface \u6784\u9020\u51fd\u6570\u7684 `examples=` \u5173\u952e\u5b57\u53c2\u6570\u3002\u5916\u90e8\u5217\u8868\u4e2d\u7684\u6bcf\u4e2a\u5b50\u5217\u8868\u8868\u793a\u4e00\u4e2a\u6570\u636e\u6837\u672c\uff0c\u5b50\u5217\u8868\u4e2d\u7684\u6bcf\u4e2a\u5143\u7d20\u8868\u793a\u6bcf\u4e2a\u8f93\u5165\u7ec4\u4ef6\u7684\u8f93\u5165\u3002\u6709\u5173\u6bcf\u4e2a\u7ec4\u4ef6\u7684\u793a\u4f8b\u6570\u636e\u683c\u5f0f\u5728[Docs](https://gradio.app/docs#components)\u4e2d\u6709\u8bf4\u660e\u3002\n\n$code_calculator\n$demo_calculator\n\n\u60a8\u53ef\u4ee5\u5c06\u5927\u578b\u6570\u636e\u96c6\u52a0\u8f7d\u5230\u793a\u4f8b\u4e2d\uff0c\u901a\u8fc7 Gradio \u6d4f\u89c8\u548c\u4e0e\u6570\u636e\u96c6\u8fdb\u884c\u4ea4\u4e92\u3002\u793a\u4f8b\u5c06\u81ea\u52a8\u5206\u9875\uff08\u53ef\u4ee5\u901a\u8fc7 Interface \u7684 `examples_per_page` \u53c2\u6570\u8fdb\u884c\u914d\u7f6e\uff09\u3002\n\n\u7ee7\u7eed\u4e86\u89e3\u793a\u4f8b\uff0c\u8bf7\u53c2\u9605[\u66f4\u591a\u793a\u4f8b](https://gradio.app/more-on-examples)\u6307\u5357\u3002\n\n## \u9519\u8bef\n\n\u60a8\u5e0c\u671b\u5411\u7528\u6237\u4f20\u9012\u81ea\u5b9a\u4e49\u9519\u8bef\u6d88\u606f\u3002\u4e3a\u6b64\uff0cwith `gr.Error(\"custom message\")` \u6765\u663e\u793a\u9519\u8bef\u6d88\u606f\u3002\u5982\u679c\u5728\u4e0a\u9762\u7684\u8ba1\u7b97\u5668\u793a\u4f8b\u4e2d\u5c1d\u8bd5\u9664\u4ee5\u96f6\uff0c\u5c06\u663e\u793a\u81ea\u5b9a\u4e49\u9519\u8bef\u6d88\u606f\u7684\u5f39\u51fa\u6a21\u6001\u7a97\u53e3\u3002\u4e86\u89e3\u6709\u5173\u9519\u8bef\u7684\u66f4\u591a\u4fe1\u606f\uff0c\u8bf7\u53c2\u9605[\u6587\u6863](https://gradio.app/docs#error)\u3002\n\n## \u63cf\u8ff0\u6027\u5185\u5bb9\n\n\u5728\u524d\u9762\u7684\u793a\u4f8b\u4e2d\uff0c\u60a8\u53ef\u80fd\u5df2\u7ecf\u6ce8\u610f\u5230 Interface \u6784\u9020\u51fd\u6570\u4e2d\u7684 `title=` \u548c `description=` \u5173\u952e\u5b57\u53c2\u6570\uff0c\u5e2e\u52a9\u7528\u6237\u4e86\u89e3\u60a8\u7684\u5e94\u7528\u7a0b\u5e8f\u3002\n\nInterface \u6784\u9020\u51fd\u6570\u4e2d\u6709\u4e09\u4e2a\u53c2\u6570\u7528\u4e8e\u6307\u5b9a\u6b64\u5185\u5bb9\u5e94\u653e\u7f6e\u5728\u54ea\u91cc\uff1a\n\n- `title`\uff1a\u63a5\u53d7\u6587\u672c\uff0c\u5e76\u53ef\u4ee5\u5c06\u5176\u663e\u793a\u5728\u754c\u9762\u7684\u9876\u90e8\uff0c\u4e5f\u5c06\u6210\u4e3a\u9875\u9762\u6807\u9898\u3002\n- `description`\uff1a\u63a5\u53d7\u6587\u672c\u3001Markdown \u6216 HTML\uff0c\u5e76\u5c06\u5176\u653e\u7f6e\u5728\u6807\u9898\u6b63\u4e0b\u65b9\u3002\n- `article`\uff1a\u4e5f\u63a5\u53d7\u6587\u672c\u3001Markdown \u6216 HTML\uff0c\u5e76\u5c06\u5176\u653e\u7f6e\u5728\u754c\u9762\u4e0b\u65b9\u3002\n\n![annotated](/assets/guides/annotated.png)\n\n\u5982\u679c\u60a8\u4f7f\u7528\u7684\u662f `Blocks` API\uff0c\u5219\u53ef\u4ee5 with `gr.Markdown(...)` \u6216 `gr.HTML(...)` \u7ec4\u4ef6\u5728\u4efb\u4f55\u4f4d\u7f6e\u63d2\u5165\u6587\u672c\u3001Markdown \u6216 HTML\uff0c\u5176\u4e2d\u63cf\u8ff0\u6027\u5185\u5bb9\u4f4d\u4e8e `Component` \u6784\u9020\u51fd\u6570\u5185\u90e8\u3002\n\n\u53e6\u4e00\u4e2a\u6709\u7528\u7684\u5173\u952e\u5b57\u53c2\u6570\u662f `label=`\uff0c\u5b83\u5b58\u5728\u4e8e\u6bcf\u4e2a `Component` \u4e2d\u3002\u8fd9\u4fee\u6539\u4e86\u6bcf\u4e2a `Component` \u9876\u90e8\u7684\u6807\u7b7e\u6587\u672c\u3002\u8fd8\u53ef\u4ee5\u4e3a\u8bf8\u5982 `Textbox` \u6216 `Radio` \u4e4b\u7c7b\u7684\u8868\u5355\u5143\u7d20\u6dfb\u52a0 `info=` \u5173\u952e\u5b57\u53c2\u6570\uff0c\u4ee5\u63d0\u4f9b\u6709\u5173\u5176\u7528\u6cd5\u7684\u8fdb\u4e00\u6b65\u4fe1\u606f\u3002\n\n```python\ngr.Number(label='\u5e74\u9f84', info='\u4ee5\u5e74\u4e3a\u5355\u4f4d\uff0c\u5fc5\u987b\u5927\u4e8e0')\n```\n\n## \u65d7\u6807\n\n\u9ed8\u8ba4\u60c5\u51b5\u4e0b\uff0c\"Interface\" \u5c06\u6709\u4e00\u4e2a \"Flag\" \u6309\u94ae\u3002\u5f53\u7528\u6237\u6d4b\u8bd5\u60a8\u7684 `Interface` \u65f6\uff0c\u5982\u679c\u770b\u5230\u6709\u8da3\u7684\u8f93\u51fa\uff0c\u4f8b\u5982\u9519\u8bef\u6216\u610f\u5916\u7684\u6a21\u578b\u884c\u4e3a\uff0c\u4ed6\u4eec\u53ef\u4ee5\u5c06\u8f93\u5165\u6807\u8bb0\u4e3a\u60a8\u8fdb\u884c\u67e5\u770b\u3002\u5728\u7531 `Interface` \u6784\u9020\u51fd\u6570\u7684 `flagging_dir=` \u53c2\u6570\u63d0\u4f9b\u7684\u76ee\u5f55\u4e2d\uff0c\u5c06\u8bb0\u5f55\u6807\u8bb0\u7684\u8f93\u5165\u5230\u4e00\u4e2a CSV \u6587\u4ef6\u4e2d\u3002\u5982\u679c\u754c\u9762\u6d89\u53ca\u6587\u4ef6\u6570\u636e\uff0c\u4f8b\u5982\u56fe\u50cf\u548c\u97f3\u9891\u7ec4\u4ef6\uff0c\u5c06\u521b\u5efa\u6587\u4ef6\u5939\u6765\u5b58\u50a8\u8fd9\u4e9b\u6807\u8bb0\u7684\u6570\u636e\u3002\n\n\u4f8b\u5982\uff0c\u5bf9\u4e8e\u4e0a\u9762\u663e\u793a\u7684\u8ba1\u7b97\u5668\u754c\u9762\uff0c\u6211\u4eec\u5c06\u5728\u4e0b\u9762\u7684\u65d7\u6807\u76ee\u5f55\u4e2d\u5b58\u50a8\u6807\u8bb0\u7684\u6570\u636e\uff1a\n\n```directory\n+-- calculator.py\n+-- flagged/\n|   +-- logs.csv\n```\n\n_flagged/logs.csv_\n\n```csv\nnum1,operation,num2,Output\n5,add,7,12\n6,subtract,1.5,4.5\n```\n\n\u4e0e\u65e9\u671f\u663e\u793a\u7684\u51b7\u8272\u754c\u9762\u76f8\u5bf9\u5e94\uff0c\u6211\u4eec\u5c06\u5728\u4e0b\u9762\u7684\u65d7\u6807\u76ee\u5f55\u4e2d\u5b58\u50a8\u6807\u8bb0\u7684\u6570\u636e\uff1a\n\n```directory\n+-- sepia.py\n+-- flagged/\n|   +-- logs.csv\n|   +-- im/\n|   |   +-- 0.png\n|   |   +-- 1.png\n|   +-- Output/\n|   |   +-- 0.png\n|   |   +-- 1.png\n```\n\n_flagged/logs.csv_\n\n```csv\nim,Output\nim/0.png,Output/0.png\nim/1.png,Output/1.png\n```\n\n\u5982\u679c\u60a8\u5e0c\u671b\u7528\u6237\u63d0\u4f9b\u65d7\u6807\u539f\u56e0\uff0c\u53ef\u4ee5\u5c06\u5b57\u7b26\u4e32\u5217\u8868\u4f20\u9012\u7ed9 Interface \u7684 `flagging_options` \u53c2\u6570\u3002\u7528\u6237\u5728\u8fdb\u884c\u65d7\u6807\u65f6\u5fc5\u987b\u9009\u62e9\u5176\u4e2d\u4e00\u4e2a\u5b57\u7b26\u4e32\uff0c\u8fd9\u5c06\u4f5c\u4e3a\u9644\u52a0\u5217\u4fdd\u5b58\u5230 CSV \u4e2d\u3002\n\n## \u9884\u5904\u7406\u548c\u540e\u5904\u7406 (Preprocessing and Postprocessing)\n\n![annotated](/assets/img/dataflow.svg)\n\n\u5982\u60a8\u6240\u89c1\uff0cGradio \u5305\u62ec\u53ef\u4ee5\u5904\u7406\u5404\u79cd\u4e0d\u540c\u6570\u636e\u7c7b\u578b\u7684\u7ec4\u4ef6\uff0c\u4f8b\u5982\u56fe\u50cf\u3001\u97f3\u9891\u548c\u89c6\u9891\u3002\u5927\u591a\u6570\u7ec4\u4ef6\u90fd\u53ef\u4ee5\u7528\u4f5c\u8f93\u5165\u6216\u8f93\u51fa\u3002\n\n\u5f53\u7ec4\u4ef6\u7528\u4f5c\u8f93\u5165\u65f6\uff0cGradio \u81ea\u52a8\u5904\u7406*\u9884\u5904\u7406*\uff0c\u5c06\u6570\u636e\u4ece\u7528\u6237"
        }
    },
    {
        "sample_idx": 122,
        "question": "What is the name of the repository where the training script can be found?",
        "answer": "pytorch-image-models",
        "rag_answer": "The repository where the training script can be found is not explicitly mentioned in the provided Data Sources. However, based on the context and the code snippets, it appears to be related to the Hugging Face Transformers library and the LayoutLMv3 model.\n\nIf I had to make an educated guess, I would suggest that the repository might be the Hugging Face Transformers repository on GitHub, which contains various training scripts and examples for different models, including LayoutLMv3.\n\nReferences:\n[KG] Hugging Face Transformers library\n[KG] LayoutLMv3 model",
        "rag_score": null,
        "rag_feedback": null,
        "rag_context": {
            "kg_context": "-----Entities-----\n    ```csv\n    id,\tentity,\ttype,\tdescription,\trankcreated_at\n1,\tGradio,organization,Gradio is a platform that supports state in Blocks, providing features such as global state and session state.<SEP>Gradio is an interface that provides various features for demonstrating models, including adding example inputs, custom error messages, descriptive content, flagging, and more.<SEP>Gradio is an organization that provides a platform for building and deploying machine learning models.<SEP>Gradio is an organization that provides a platform for creating and deploying machine learning models.<SEP>Gradio is an organization that provides a demo for blocks_random_slider, and its library is used to create interactive interfaces.,36,2025-03-24 13:16:48\n2,\tPostprocessing,concept,Postprocessing refers to the process of transforming output from machine learning models into a usable format.,1,2025-03-24 13:16:48\n3,\tLayoutLMv3,technology,LayoutLMv3 is a model used for token classification and form understanding tasks.,11,2025-03-24 13:16:48\n4,\trun_funsd_cord.py,UNKNOWN,run_funsd_cord.py is a script used for fine-tuning the LayoutLMv3 model.,1,2025-03-24 13:16:48\n5,\tMachine Learning,category,Machine Learning is a field of study that involves training models to make predictions.,5,2025-03-24 13:16:48\n6,\tPapers With Code,organization,Papers With Code is an organization that provides a platform for tracking machine learning papers and their corresponding code.,1,2025-03-24 13:16:48\n7,\tPapers With Code,organization,Papers With Code is an organization that provides a platform for tracking machine learning papers and their corresponding code.,1,UNKNOWN\n8,\tJupyter,category,Jupyter is a platform for interactive computing and data science.,2,UNKNOWN\n9,\t run_funsd_cord.py,event,run_funsd_cord.py is a script used for fine-tuning the LayoutLMv3 model.,0,UNKNOWN\n    ```\n    -----Relationships-----\n    ```csv\n    id,\tsource,\ttarget,\tdescription,\tkeywords,\tweight,\trank,\tcreated_at\n1,\tGradio,Postprocessing,Gradio supports postprocessing of output from machine learning models.,output transformation, machine learning,8.0,37,2025-03-24 13:17:31\n2,\tLayoutLMv3,run_funsd_cord.py,run_funsd_cord.py is a script used for fine-tuning the LayoutLMv3 model.,script, model fine-tuning,7.0,12,2025-03-24 13:19:57\n3,\tMachine Learning,Papers With Code,Papers With Code provides a platform for tracking machine learning papers and their corresponding code.,research platform, machine learning,8.0,6,2025-03-24 13:16:48\n4,\tGradio,Jupyter,Gradio can be run on Jupyter notebooks.,platform compatibility, interactive computing,7.0,38,UNKNOWN\n5,\tMachine Learning,Papers With Code,Papers With Code provides a platform for tracking machine learning papers and their corresponding code.,research platform, machine learning,8.0,6,UNKNOWN\n6,\tJupyter,notebooks,Notebooks are a type of interactive document used in Jupyter.,document type, interactive computing,7.0,3,UNKNOWN\n    ```\n    -----Sources-----\n    ```csv\n    id,\tcontent\n1,\t\u65f6\u5fc5\u987b\u9009\u62e9\u5176\u4e2d\u4e00\u4e2a\u5b57\u7b26\u4e32\uff0c\u8fd9\u5c06\u4f5c\u4e3a\u9644\u52a0\u5217\u4fdd\u5b58\u5230 CSV \u4e2d\u3002\n\n## \u9884\u5904\u7406\u548c\u540e\u5904\u7406 (Preprocessing and Postprocessing)\n\n![annotated](/assets/img/dataflow.svg)\n\n\u5982\u60a8\u6240\u89c1\uff0cGradio \u5305\u62ec\u53ef\u4ee5\u5904\u7406\u5404\u79cd\u4e0d\u540c\u6570\u636e\u7c7b\u578b\u7684\u7ec4\u4ef6\uff0c\u4f8b\u5982\u56fe\u50cf\u3001\u97f3\u9891\u548c\u89c6\u9891\u3002\u5927\u591a\u6570\u7ec4\u4ef6\u90fd\u53ef\u4ee5\u7528\u4f5c\u8f93\u5165\u6216\u8f93\u51fa\u3002\n\n\u5f53\u7ec4\u4ef6\u7528\u4f5c\u8f93\u5165\u65f6\uff0cGradio \u81ea\u52a8\u5904\u7406*\u9884\u5904\u7406*\uff0c\u5c06\u6570\u636e\u4ece\u7528\u6237\u6d4f\u89c8\u5668\u53d1\u9001\u7684\u7c7b\u578b\uff08\u4f8b\u5982\u7f51\u7edc\u6444\u50cf\u5934\u5feb\u7167\u7684 base64 \u8868\u793a\uff09\u8f6c\u6362\u4e3a\u60a8\u7684\u51fd\u6570\u53ef\u4ee5\u63a5\u53d7\u7684\u5f62\u5f0f\uff08\u4f8b\u5982 `numpy` \u6570\u7ec4\uff09\u3002\n\n\u540c\u6837\uff0c\u5f53\u7ec4\u4ef6\u7528\u4f5c\u8f93\u51fa\u65f6\uff0cGradio \u81ea\u52a8\u5904\u7406*\u540e\u5904\u7406*\uff0c\u5c06\u6570\u636e\u4ece\u51fd\u6570\u8fd4\u56de\u7684\u5f62\u5f0f\uff08\u4f8b\u5982\u56fe\u50cf\u8def\u5f84\u5217\u8868\uff09\u8f6c\u6362\u4e3a\u53ef\u4ee5\u5728\u7528\u6237\u6d4f\u89c8\u5668\u4e2d\u663e\u793a\u7684\u5f62\u5f0f\uff08\u4f8b\u5982\u4ee5 base64 \u683c\u5f0f\u663e\u793a\u56fe\u50cf\u7684 `Gallery`\uff09\u3002\n\n\u60a8\u53ef\u4ee5\u4f7f\u7528\u6784\u5efa\u56fe\u50cf\u7ec4\u4ef6\u65f6\u7684\u53c2\u6570\u63a7\u5236*\u9884\u5904\u7406*\u3002\u4f8b\u5982\uff0c\u5982\u679c\u60a8\u4f7f\u7528\u4ee5\u4e0b\u53c2\u6570\u5b9e\u4f8b\u5316 `Image` \u7ec4\u4ef6\uff0c\u5b83\u5c06\u5c06\u56fe\u50cf\u8f6c\u6362\u4e3a `PIL` \u7c7b\u578b\uff0c\u5e76\u5c06\u5176\u91cd\u5851\u4e3a`(100, 100)`\uff0c\u800c\u4e0d\u7ba1\u63d0\u4ea4\u65f6\u7684\u539f\u59cb\u5927\u5c0f\u5982\u4f55\uff1a\n\n```py\nimg = gr.Image(shape=(100, 100), type=\"pil\")\n```\n\n\u76f8\u53cd\uff0c\u8fd9\u91cc\u6211\u4eec\u4fdd\u7559\u56fe\u50cf\u7684\u539f\u59cb\u5927\u5c0f\uff0c\u4f46\u5728\u5c06\u5176\u8f6c\u6362\u4e3a numpy \u6570\u7ec4\u4e4b\u524d\u53cd\u8f6c\u989c\u8272\uff1a\n\n```py\nimg = gr.Image(invert_colors=True, type=\"numpy\")\n```\n\n\u540e\u5904\u7406\u8981\u5bb9\u6613\u5f97\u591a\uff01Gradio \u81ea\u52a8\u8bc6\u522b\u8fd4\u56de\u6570\u636e\u7684\u683c\u5f0f\uff08\u4f8b\u5982 `Image` \u662f `numpy` \u6570\u7ec4\u8fd8\u662f `str` \u6587\u4ef6\u8def\u5f84\uff1f\uff09\uff0c\u5e76\u5c06\u5176\u540e\u5904\u7406\u4e3a\u53ef\u4ee5\u7531\u6d4f\u89c8\u5668\u663e\u793a\u7684\u683c\u5f0f\u3002\n\n\u8bf7\u67e5\u770b[\u6587\u6863](https://gradio.app/docs)\uff0c\u4e86\u89e3\u6bcf\u4e2a\u7ec4\u4ef6\u7684\u6240\u6709\u4e0e\u9884\u5904\u7406\u76f8\u5173\u7684\u53c2\u6570\u3002\n\n## \u6837\u5f0f (Styling)\n\nGradio \u4e3b\u9898\u662f\u81ea\u5b9a\u4e49\u5e94\u7528\u7a0b\u5e8f\u5916\u89c2\u548c\u611f\u89c9\u7684\u6700\u7b80\u5355\u65b9\u6cd5\u3002\u60a8\u53ef\u4ee5\u9009\u62e9\u591a\u79cd\u4e3b\u9898\u6216\u521b\u5efa\u81ea\u5df1\u7684\u4e3b\u9898\u3002\u8981\u8fd9\u6837\u505a\uff0c\u8bf7\u5c06 `theme=` \u53c2\u6570\u4f20\u9012\u7ed9 `Interface` \u6784\u9020\u51fd\u6570\u3002\u4f8b\u5982\uff1a\n\n```python\ndemo = gr.Interface(..., theme=gr.themes.Monochrome())\n```\n\nGradio \u5e26\u6709\u4e00\u7ec4\u9884\u5148\u6784\u5efa\u7684\u4e3b\u9898\uff0c\u60a8\u53ef\u4ee5\u4ece `gr.themes.*` \u52a0\u8f7d\u3002\u60a8\u53ef\u4ee5\u6269\u5c55\u8fd9\u4e9b\u4e3b\u9898\u6216\u4ece\u5934\u5f00\u59cb\u521b\u5efa\u81ea\u5df1\u7684\u4e3b\u9898 - \u6709\u5173\u66f4\u591a\u8be6\u7ec6\u4fe1\u606f\uff0c\u8bf7\u53c2\u9605[\u4e3b\u9898\u6307\u5357](https://gradio.app/theming-guide)\u3002\n\n\u8981\u589e\u52a0\u989d\u5916\u7684\u6837\u5f0f\u80fd\u529b\uff0c\u60a8\u53ef\u4ee5 with `css=` \u5173\u952e\u5b57\u5c06\u4efb\u4f55 CSS \u4f20\u9012\u7ed9\u60a8\u7684\u5e94\u7528\u7a0b\u5e8f\u3002\nGradio \u5e94\u7528\u7a0b\u5e8f\u7684\u57fa\u7c7b\u662f `gradio-container`\uff0c\u56e0\u6b64\u4ee5\u4e0b\u662f\u4e00\u4e2a\u66f4\u6539 Gradio \u5e94\u7528\u7a0b\u5e8f\u80cc\u666f\u989c\u8272\u7684\u793a\u4f8b\uff1a\n\n```python\nwith `gr.Interface(css=\".gradio-container {background-color: red}\") as demo:\n    ...\n```\n\n## \u961f\u5217 (Queuing)\n\n\u5982\u679c\u60a8\u7684\u5e94\u7528\u7a0b\u5e8f\u9884\u8ba1\u4f1a\u6709\u5927\u91cf\u6d41\u91cf\uff0c\u8bf7 with `queue()` \u65b9\u6cd5\u6765\u63a7\u5236\u5904\u7406\u901f\u7387\u3002\u8fd9\u5c06\u6392\u961f\u5904\u7406\u8c03\u7528\uff0c\u56e0\u6b64\u4e00\u6b21\u53ea\u5904\u7406\u4e00\u5b9a\u6570\u91cf\u7684\u8bf7\u6c42\u3002\u961f\u5217\u4f7f\u7528 Websockets\uff0c\u8fd8\u53ef\u4ee5\u9632\u6b62\u7f51\u7edc\u8d85\u65f6\uff0c\u56e0\u6b64\u5982\u679c\u60a8\u7684\u51fd\u6570\u7684\u63a8\u7406\u65f6\u95f4\u5f88\u957f\uff08> 1 \u5206\u949f\uff09\uff0c\u5e94\u4f7f\u7528\u961f\u5217\u3002\n\nwith `Interface`\uff1a\n\n```python\ndemo = gr.Interface(...).queue()\ndemo.launch()\n```\n\nwith `Blocks`\uff1a\n\n```python\nwith gr.Blocks() as demo\uff1a\n    #...\ndemo.queue()\ndemo.launch()\n```\n\n\u60a8\u53ef\u4ee5\u901a\u8fc7\u4ee5\u4e0b\u65b9\u5f0f\u63a7\u5236\u4e00\u6b21\u5904\u7406\u7684\u8bf7\u6c42\u6570\u91cf\uff1a\n\n```python\ndemo.queue(concurrency_count=3)\n```\n\n\u67e5\u770b\u6709\u5173\u914d\u7f6e\u5176\u4ed6\u961f\u5217\u53c2\u6570\u7684[\u961f\u5217\u6587\u6863](/docs/#queue)\u3002\n\n\u5728 Blocks \u4e2d\u6307\u5b9a\u4ec5\u5bf9\u67d0\u4e9b\u51fd\u6570\u8fdb\u884c\u6392\u961f\uff1a\n\n```python\nwith gr.Blocks() as demo2\uff1a\n    num1 = gr.Number()\n    num2 = gr.Number()\n    output = gr.Number()\n    gr.Button(\"Add\").click(\n        lambda a, b: a + b, [num1, num2], output)\n    gr.Button(\"Multiply\").click(\n        lambda a, b: a * b, [num1, num2], output, queue=True)\ndemo2.launch()\n```\n\n## \u8fed\u4ee3\u8f93\u51fa (Iterative Outputs)\n\n\u5728\u67d0\u4e9b\u60c5\u51b5\u4e0b\uff0c\u60a8\u53ef\u80fd\u9700\u8981\u4f20\u8f93\u4e00\u7cfb\u5217\u8f93\u51fa\u800c\u4e0d\u662f\u4e00\u6b21\u663e\u793a\u5355\u4e2a\u8f93\u51fa\u3002\u4f8b\u5982\uff0c\u60a8\u53ef\u80fd\u6709\u4e00\u4e2a\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5e0c\u671b\u663e\u793a\u751f\u6210\u7684\u6bcf\u4e2a\u6b65\u9aa4\u7684\u56fe\u50cf\uff0c\u76f4\u5230\u6700\u7ec8\u56fe\u50cf\u3002\u6216\u8005\u60a8\u53ef\u80fd\u6709\u4e00\u4e2a\u804a\u5929\u673a\u5668\u4eba\uff0c\u5b83\u9010\u5b57\u9010\u53e5\u5730\u6d41\u5f0f\u4f20\u8f93\u54cd\u5e94\uff0c\u800c\u4e0d\u662f\u4e00\u6b21\u8fd4\u56de\u5168\u90e8\u54cd\u5e94\u3002\n\n\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u60a8\u53ef\u4ee5\u5c06**\u751f\u6210\u5668**\u51fd\u6570\u63d0\u4f9b\u7ed9 Gradio\uff0c\u800c\u4e0d\u662f\u5e38\u89c4\u51fd\u6570\u3002\u5728 Python \u4e2d\u521b\u5efa\u751f\u6210\u5668\u975e\u5e38\u7b80\u5355\uff1a\u51fd\u6570\u4e0d\u5e94\u8be5\u6709\u4e00\u4e2a\u5355\u72ec\u7684 `return` \u503c\uff0c\u800c\u662f\u5e94\u8be5 with `yield` \u8fde\u7eed\u8fd4\u56de\u4e00\u7cfb\u5217\u503c\u3002\u901a\u5e38\uff0c`yield` \u8bed\u53e5\u653e\u7f6e\u5728\u67d0\u79cd\u5faa\u73af\u4e2d\u3002\u4e0b\u9762\u662f\u4e00\u4e2a\u7b80\u5355\u793a\u4f8b\uff0c\u751f\u6210\u5668\u53ea\u662f\u7b80\u5355\u8ba1\u6570\u5230\u7ed9\u5b9a\u6570\u5b57\uff1a\n\n```python\ndef my_generator(x):\n    for i in range(x):\n        yield i\n```\n\n\u60a8\u4ee5\u4e0e\u5e38\u89c4\u51fd\u6570\u76f8\u540c\u7684\u65b9\u5f0f\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio\u3002\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\uff08\u865a\u62df\u7684\uff09\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5b83\u5728\u8f93\u51fa\u56fe\u50cf\u4e4b\u524d\u751f\u6210\u6570\u4e2a\u6b65\u9aa4\u7684\u566a\u97f3\uff1a\n\n$code_fake_diffusion\n$demo_fake_diffusion\n\n\u8bf7\u6ce8\u610f\uff0c\u6211\u4eec\u5728\u8fed\u4ee3\u5668\u4e2d\u6dfb\u52a0\u4e86 `time.sleep(1)`\uff0c\u4ee5\u521b\u5efa\u6b65\u9aa4\u4e4b\u95f4\u7684\u4eba\u5de5\u6682\u505c\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u89c2\u5bdf\u8fed\u4ee3\u5668\u7684\u6b65\u9aa4\uff08\u5728\u771f\u5b9e\u7684\u56fe\u50cf\u751f\u6210\u6a21\u578b\u4e2d\uff0c\u8fd9\n2,\t!---\nCopyright 2022 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n-->\n\n# Token classification with LayoutLMv3 (PyTorch version)\n\nThis directory contains a script, `run_funsd_cord.py`, that can be used to fine-tune (or evaluate) LayoutLMv3 on form understanding datasets, such as [FUNSD](https://guillaumejaume.github.io/FUNSD/) and [CORD](https://github.com/clovaai/cord).\n\nThe script `run_funsd_cord.py` leverages the \ud83e\udd17 Datasets library and the Trainer API. You can easily customize it to your needs.\n\n## Fine-tuning on FUNSD\n\nFine-tuning LayoutLMv3 for token classification on [FUNSD](https://guillaumejaume.github.io/FUNSD/) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name funsd \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 1e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-funsd\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd. By specifying the `push_to_hub` flag, the model gets uploaded automatically to the hub (regularly), together with a model card, which includes metrics such as precision, recall and F1. Note that you can easily update the model card, as it's just a README file of the respective repo on the hub.\n\nThere's also the \"Training metrics\" [tab](https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd/tensorboard), which shows Tensorboard logs over the course of training. Pretty neat, huh?\n\n## Fine-tuning on CORD\n\nFine-tuning LayoutLMv3 for token classification on [CORD](https://github.com/clovaai/cord) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name cord \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 5e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-cord\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-cord. Note that a model card gets generated automatically in case you specify the `push_to_hub` flag.\n3,\tChoosing a metric for your task\n\n**So you've trained your model and want to see how well it\u2019s doing on a dataset of your choice. Where do you start?**\n\nThere is no \u201cone size fits all\u201d approach to choosing an evaluation metric, but some good guidelines to keep in mind are:\n\n## Categories of metrics\n\nThere are 3 high-level categories of metrics:\n\n1. *Generic metrics*, which can be applied to a variety of situations and datasets, such as precision and accuracy.\n2. *Task-specific metrics*, which are limited to a given task, such as Machine Translation (often evaluated using metrics [BLEU](https://huggingface.co/metrics/bleu) or [ROUGE](https://huggingface.co/metrics/rouge)) or Named Entity Recognition (often evaluated with [seqeval](https://huggingface.co/metrics/seqeval)).\n3. *Dataset-specific metrics*, which aim to measure model performance on specific benchmarks: for instance, the [GLUE benchmark](https://huggingface.co/datasets/glue) has a dedicated [evaluation metric](https://huggingface.co/metrics/glue).\n\nLet's look at each of these three cases:\n\n### Generic metrics\n\nMany of the metrics used in the Machine Learning community are quite generic and can be applied in a variety of tasks and datasets.\n\nThis is the case for metrics like [accuracy](https://huggingface.co/metrics/accuracy) and [precision](https://huggingface.co/metrics/precision), which can be used for evaluating labeled (supervised) datasets, as well as [perplexity](https://huggingface.co/metrics/perplexity), which can be used for evaluating different kinds of (unsupervised) generative tasks.\n\nTo see the input structure of a given metric, you can look at its metric card. For example, in the case of [precision](https://huggingface.co/metrics/precision), the format is:\n```\n>>> precision_metric = evaluate.load(\"precision\")\n>>> results = precision_metric.compute(references=[0, 1], predictions=[0, 1])\n>>> print(results)\n{'precision': 1.0}\n```\n\n### Task-specific metrics\n\nPopular ML tasks like Machine Translation and Named Entity Recognition have specific metrics that can be used to compare models. For example, a series of different metrics have been proposed for text generation, ranging from [BLEU](https://huggingface.co/metrics/bleu) and its derivatives such as [GoogleBLEU](https://huggingface.co/metrics/google_bleu) and [GLEU](https://huggingface.co/metrics/gleu), but also [ROUGE](https://huggingface.co/metrics/rouge), [MAUVE](https://huggingface.co/metrics/mauve), etc.\n\nYou can find the right metric for your task by:\n\n- **Looking at the [Task pages](https://huggingface.co/tasks)** to see what metrics can be used for evaluating models for a given task.\n- **Checking out leaderboards** on sites like [Papers With Code](https://paperswithcode.com/) (you can search by task and by dataset).\n-  **Reading the metric cards** for the relevant metrics and see which ones are a good fit for your use case. For example, see the [BLEU metric card](https://github.com/huggingface/evaluate/tree/main/metrics/bleu) or [SQuaD metric card](https://github.com/huggingface/evaluate/tree/main/metrics/squad).\n- **Looking at papers and blog posts** published on the topic and see what metrics they report. This can change over time, so try to pick papers from the last couple of years!\n\n### Dataset-specific metrics\n\nSome datasets have specific metrics associated with them -- this is especially in the case of popular benchmarks like [GLUE](https://huggingface.co/metrics/glue) and [SQuAD](https://huggingface.co/metrics/squad).\n\n<Tip warning={true}>\n\ud83d\udca1\nGLUE is actually a collection of different subsets on different tasks, so first you need to choose the one that corresponds to the NLI task, such as mnli, which is described as \u201ccrowdsourced collection of sentence pairs with textual entailment annotations\u201d\n</Tip>\n\n\nIf you are evaluating your model on a benchmark dataset like the ones mentioned above, you can use its dedicated evaluation metric. Make sure you respect the format that they require. For example, to evaluate your model on the [SQuAD](https://huggingface.co/datasets/squad) dataset, you need to feed the `question` and `context` into your model and return the `prediction_text`, which should be compared with the `references` (based on matching the `id` of the question) :\n\n```\n>>> from evaluate import load\n>>> squad_metric = load(\"squad\")\n>>> predictions = [{'prediction_text': '1976', 'id': '56e10a3be3433e1400422b22'}]\n>>> references = [{'answers': {'answer_start': [97], 'text': ['1976']}, 'id': '56e10a3be3433e1400422b22'}]\n>>> results = squad_metric.compute(predictions=predictions, references=references)\n>>> results\n{'exact_match': 100.0, 'f1': 100.0}\n```\n\nYou can find examples of dataset structures by consulting the \"Dataset Preview\" function or the dataset card for a given dataset, and you can see how to use its dedicated evaluation function based on the metric card.\n4,\t\u4e0e\u5e38\u89c4\u51fd\u6570\u76f8\u540c\u7684\u65b9\u5f0f\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio\u3002\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\uff08\u865a\u62df\u7684\uff09\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5b83\u5728\u8f93\u51fa\u56fe\u50cf\u4e4b\u524d\u751f\u6210\u6570\u4e2a\u6b65\u9aa4\u7684\u566a\u97f3\uff1a\n\n$code_fake_diffusion\n$demo_fake_diffusion\n\n\u8bf7\u6ce8\u610f\uff0c\u6211\u4eec\u5728\u8fed\u4ee3\u5668\u4e2d\u6dfb\u52a0\u4e86 `time.sleep(1)`\uff0c\u4ee5\u521b\u5efa\u6b65\u9aa4\u4e4b\u95f4\u7684\u4eba\u5de5\u6682\u505c\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u89c2\u5bdf\u8fed\u4ee3\u5668\u7684\u6b65\u9aa4\uff08\u5728\u771f\u5b9e\u7684\u56fe\u50cf\u751f\u6210\u6a21\u578b\u4e2d\uff0c\u8fd9\u53ef\u80fd\u662f\u4e0d\u5fc5\u8981\u7684\uff09\u3002\n\n\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio **\u9700\u8981**\u5728\u5e95\u5c42 Interface \u6216 Blocks \u4e2d\u542f\u7528\u961f\u5217\uff08\u8bf7\u53c2\u9605\u4e0a\u9762\u7684\u961f\u5217\u90e8\u5206\uff09\u3002\n\n## \u8fdb\u5ea6\u6761\n\nGradio \u652f\u6301\u521b\u5efa\u81ea\u5b9a\u4e49\u8fdb\u5ea6\u6761\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u81ea\u5b9a\u4e49\u548c\u63a7\u5236\u5411\u7528\u6237\u663e\u793a\u7684\u8fdb\u5ea6\u66f4\u65b0\u3002\u8981\u542f\u7528\u6b64\u529f\u80fd\uff0c\u53ea\u9700\u4e3a\u65b9\u6cd5\u6dfb\u52a0\u4e00\u4e2a\u9ed8\u8ba4\u503c\u4e3a `gr.Progress` \u5b9e\u4f8b\u7684\u53c2\u6570\u5373\u53ef\u3002\u7136\u540e\uff0c\u60a8\u53ef\u4ee5\u76f4\u63a5\u8c03\u7528\u6b64\u5b9e\u4f8b\u5e76\u4f20\u5165 0 \u5230 1 \u4e4b\u95f4\u7684\u6d6e\u70b9\u6570\u6765\u66f4\u65b0\u8fdb\u5ea6\u7ea7\u522b\uff0c\u6216\u8005 with `Progress` \u5b9e\u4f8b\u7684 `tqdm()` \u65b9\u6cd5\u6765\u8ddf\u8e2a\u53ef\u8fed\u4ee3\u5bf9\u8c61\u4e0a\u7684\u8fdb\u5ea6\uff0c\u5982\u4e0b\u6240\u793a\u3002\u5fc5\u987b\u542f\u7528\u961f\u5217\u4ee5\u8fdb\u884c\u8fdb\u5ea6\u66f4\u65b0\u3002\n\n$code_progress_simple\n$demo_progress_simple\n\n\u5982\u679c\u60a8 with `tqdm` \u5e93\uff0c\u5e76\u4e14\u5e0c\u671b\u4ece\u51fd\u6570\u5185\u90e8\u7684\u4efb\u4f55 `tqdm.tqdm` \u81ea\u52a8\u62a5\u544a\u8fdb\u5ea6\u66f4\u65b0\uff0c\u8bf7\u5c06\u9ed8\u8ba4\u53c2\u6570\u8bbe\u7f6e\u4e3a `gr.Progress(track_tqdm=True)`\uff01\n\n## \u6279\u5904\u7406\u51fd\u6570 (Batch Functions)\n\nGradio \u652f\u6301\u4f20\u9012*\u6279\u5904\u7406*\u51fd\u6570\u3002\u6279\u5904\u7406\u51fd\u6570\u53ea\u662f\u63a5\u53d7\u8f93\u5165\u5217\u8868\u5e76\u8fd4\u56de\u9884\u6d4b\u5217\u8868\u7684\u51fd\u6570\u3002\n\n\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\u6279\u5904\u7406\u51fd\u6570\uff0c\u5b83\u63a5\u53d7\u4e24\u4e2a\u8f93\u5165\u5217\u8868\uff08\u4e00\u4e2a\u5355\u8bcd\u5217\u8868\u548c\u4e00\u4e2a\u6574\u6570\u5217\u8868\uff09\uff0c\u5e76\u8fd4\u56de\u4fee\u526a\u8fc7\u7684\u5355\u8bcd\u5217\u8868\u4f5c\u4e3a\u8f93\u51fa\uff1a\n\n```python\nimport time\n\ndef trim_words(words, lens):\n    trimmed_words = []\n    time.sleep(5)\n    for w, l in zip(words, lens):\n        trimmed_words.append(w[:int(l)])\n    return [trimmed_words]\n    for w, l in zip(words, lens):\n```\n\n\u4f7f\u7528\u6279\u5904\u7406\u51fd\u6570\u7684\u4f18\u70b9\u662f\uff0c\u5982\u679c\u542f\u7528\u4e86\u961f\u5217\uff0cGradio \u670d\u52a1\u5668\u53ef\u4ee5\u81ea\u52a8*\u6279\u5904\u7406*\u4f20\u5165\u7684\u8bf7\u6c42\u5e76\u5e76\u884c\u5904\u7406\u5b83\u4eec\uff0c\u4ece\u800c\u53ef\u80fd\u52a0\u5feb\u6f14\u793a\u901f\u5ea6\u3002\u4ee5\u4e0b\u662f Gradio \u4ee3\u7801\u7684\u793a\u4f8b\uff08\u8bf7\u6ce8\u610f `batch=True` \u548c `max_batch_size=16` - \u8fd9\u4e24\u4e2a\u53c2\u6570\u90fd\u53ef\u4ee5\u4f20\u9012\u7ed9\u4e8b\u4ef6\u89e6\u53d1\u5668\u6216 `Interface` \u7c7b\uff09\n\nwith `Interface`\uff1a\n\n```python\ndemo = gr.Interface(trim_words, [\"textbox\", \"number\"], [\"output\"],\n                    batch=True, max_batch_size=16)\ndemo.queue()\ndemo.launch()\n```\n\nwith `Blocks`\uff1a\n\n```python\nimport gradio as gr\n\nwith gr.Blocks() as demo:\n    with gr.Row():\n        word = gr.Textbox(label=\"word\")\n        leng = gr.Number(label=\"leng\")\n        output = gr.Textbox(label=\"Output\")\n    with gr.Row():\n        run = gr.Button()\n\n    event = run.click(trim_words, [word, leng], output, batch=True, max_batch_size=16)\n\ndemo.queue()\ndemo.launch()\n```\n\n\u5728\u4e0a\u9762\u7684\u793a\u4f8b\u4e2d\uff0c\u53ef\u4ee5\u5e76\u884c\u5904\u7406 16 \u4e2a\u8bf7\u6c42\uff08\u603b\u63a8\u7406\u65f6\u95f4\u4e3a 5 \u79d2\uff09\uff0c\u800c\u4e0d\u662f\u5206\u522b\u5904\u7406\u6bcf\u4e2a\u8bf7\u6c42\uff08\u603b\u63a8\u7406\u65f6\u95f4\u4e3a 80 \u79d2\uff09\u3002\u8bb8\u591a Hugging Face \u7684 `transformers` \u548c `diffusers` \u6a21\u578b\u5728 Gradio \u7684\u6279\u5904\u7406\u6a21\u5f0f\u4e0b\u81ea\u7136\u5de5\u4f5c\uff1a\u8fd9\u662f[\u4f7f\u7528\u6279\u5904\u7406\u751f\u6210\u56fe\u50cf\u7684\u793a\u4f8b\u6f14\u793a](https://github.com/gradio-app/gradio/blob/main/demo/diffusers_with_batching/run.py)\n\n\u6ce8\u610f\uff1a\u4f7f\u7528 Gradio \u7684\u6279\u5904\u7406\u51fd\u6570 **requires** \u5728\u5e95\u5c42 Interface \u6216 Blocks \u4e2d\u542f\u7528\u961f\u5217\uff08\u8bf7\u53c2\u9605\u4e0a\u9762\u7684\u961f\u5217\u90e8\u5206\uff09\u3002\n\n## Gradio \u7b14\u8bb0\u672c (Colab Notebooks)\n\nGradio \u53ef\u4ee5\u5728\u4efb\u4f55\u8fd0\u884c Python \u7684\u5730\u65b9\u8fd0\u884c\uff0c\u5305\u62ec\u672c\u5730 Jupyter \u7b14\u8bb0\u672c\u548c\u534f\u4f5c\u7b14\u8bb0\u672c\uff0c\u5982[Google Colab](https://colab.research.google.com/)\u3002\u5bf9\u4e8e\u672c\u5730 Jupyter \u7b14\u8bb0\u672c\u548c Google Colab \u7b14\u8bb0\u672c\uff0cGradio \u5728\u672c\u5730\u670d\u52a1\u5668\u4e0a\u8fd0\u884c\uff0c\u60a8\u53ef\u4ee5\u5728\u6d4f\u89c8\u5668\u4e2d\u4e0e\u4e4b\u4ea4\u4e92\u3002\uff08\u6ce8\u610f\uff1a\u5bf9\u4e8e Google Colab\uff0c\u8fd9\u662f\u901a\u8fc7[\u670d\u52a1\u5de5\u4f5c\u5668\u96a7\u9053](https://github.com/tensorflow/tensorboard/blob/master/docs/design/colab_integration.md)\u5b9e\u73b0\u7684\uff0c\u60a8\u7684\u6d4f\u89c8\u5668\u9700\u8981\u542f\u7528 cookies\u3002\uff09\u5bf9\u4e8e\u5176\u4ed6\u8fdc\u7a0b\u7b14\u8bb0\u672c\uff0cGradio \u4e5f\u5c06\u5728\u670d\u52a1\u5668\u4e0a\u8fd0\u884c\uff0c\u4f46\u60a8\u9700\u8981\u4f7f\u7528[SSH \u96a7\u9053](https://coderwall.com/p/ohk6cg/remote-access-to-ipython-notebooks-via-ssh)\u5728\u672c\u5730\u6d4f\u89c8\u5668\u4e2d\u67e5\u770b\u5e94\u7528\u7a0b\u5e8f\u3002\u901a\u5e38\uff0c\u66f4\u7b80\u5355\u7684\u9009\u62e9\u662f\u4f7f\u7528 Gradio \u5185\u7f6e\u7684\u516c\u5171\u94fe\u63a5\uff0c[\u5728\u4e0b\u4e00\u7bc7\u6307\u5357\u4e2d\u8ba8\u8bba](/sharing-your-app/#sharing-demos)\u3002\n    ```",
            "vector_context": "[Created at: 2025-03-24 13:19:17]\n!---\nCopyright 2022 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n-->\n\n# Token classification with LayoutLMv3 (PyTorch version)\n\nThis directory contains a script, `run_funsd_cord.py`, that can be used to fine-tune (or evaluate) LayoutLMv3 on form understanding datasets, such as [FUNSD](https://guillaumejaume.github.io/FUNSD/) and [CORD](https://github.com/clovaai/cord).\n\nThe script `run_funsd_cord.py` leverages the \ud83e\udd17 Datasets library and the Trainer API. You can easily customize it to your needs.\n\n## Fine-tuning on FUNSD\n\nFine-tuning LayoutLMv3 for token classification on [FUNSD](https://guillaumejaume.github.io/FUNSD/) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name funsd \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 1e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-funsd\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd. By specifying the `push_to_hub` flag, the model gets uploaded automatically to the hub (regularly), together with a model card, which includes metrics such as precision, recall and F1. Note that you can easily update the model card, as it's just a README file of the respective repo on the hub.\n\nThere's also the \"Training metrics\" [tab](https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd/tensorboard), which shows Tensorboard logs over the course of training. Pretty neat, huh?\n\n## Fine-tuning on CORD\n\nFine-tuning LayoutLMv3 for token classification on [CORD](https://github.com/clovaai/cord) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name cord \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 5e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-cord\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-cord. Note that a model card gets generated automatically in case you specify the `push_to_hub` flag.\n--New Chunk--\n[Created at: 2025-03-24 13:16:13]\n=predictions, references=references)\n>>> results\n{'exact_match': 100.0, 'f1': 100.0}\n```\n\nYou can find examples of dataset structures by consulting the \"Dataset Preview\" function or the dataset card for a given dataset, and you can see how to use its dedicated evaluation function based on the metric card.\n--New Chunk--\n[Created at: 2025-03-24 13:17:32]\n!--Copyright 2023 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\nthe License. You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under the License is distributed on\nan \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n\n\u26a0\ufe0f Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be\nrendered properly in your Markdown viewer.\n\n-->\n\n# Training on TPU with TensorFlow\n\n<Tip>\n\nIf you don't need long explanations and just want TPU code samples to get started with, check out [our TPU example notebook!](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb)\n\n</Tip>\n\n### What is a TPU?\n\nA TPU is a **Tensor Processing Unit.** They are hardware designed by Google, which are used to greatly speed up the tensor computations within neural networks, much like GPUs. They can be used for both network training and inference. They are generally accessed through Google\u2019s cloud services, but small TPUs can also be accessed directly for free through Google Colab and Kaggle Kernels.\n\nBecause [all TensorFlow models in \ud83e\udd17 Transformers are Keras models](https://huggingface.co/blog/tensorflow-philosophy), most of the methods in this document are generally applicable to TPU training for any Keras model! However, there are a few points that are specific to the HuggingFace ecosystem (hug-o-system?) of Transformers and Datasets, and we\u2019ll make sure to flag them up when we get to them.\n\n### What kinds of TPU are available?\n\nNew users are often very confused by the range of TPUs, and the different ways to access them. The first key distinction to understand is the difference between **TPU Nodes** and **TPU VMs.**\n\nWhen you use a **TPU Node**, you are effectively indirectly accessing a remote TPU. You will need a separate VM, which will initialize your network and data pipeline and then forward them to the remote node. When you use a TPU on Google Colab, you are accessing it in the **TPU Node** style.\n\nUsing TPU Nodes can have some quite unexpected behaviour for people who aren\u2019t used to them! In particular, because the TPU is located on a physically different system to the machine you\u2019re running your Python code on, your data cannot be local to your machine - any data pipeline that loads from your machine\u2019s internal storage will totally fail! Instead, data must be stored in Google Cloud Storage where your data pipeline can still access it, even when the pipeline is running on the remote TPU node.\n\n<Tip>\n\nIf you can fit all your data in memory as `np.ndarray` or `tf.Tensor`, then you can `fit()` on that data even when using Colab or a TPU Node, without needing to upload it to Google Cloud Storage.\n\n</Tip>\n\n<Tip>\n\n**\ud83e\udd17Specific Hugging Face Tip\ud83e\udd17:** The methods `Dataset.to_tf_dataset()` and its higher-level wrapper `model.prepare_tf_dataset()` , which you will see throughout our TF code examples, will both fail on a TPU Node. The reason for this is that even though they create a `tf.data.Dataset` it is not a \u201cpure\u201d `tf.data` pipeline and uses `tf.numpy_function` or `Dataset.from_generator()` to stream data from the underlying HuggingFace `Dataset`. This HuggingFace `Dataset` is backed by data that is on a local disc and which the remote TPU Node will not be able to read.\n\n</Tip>\n\nThe second way to access a TPU is via a **TPU VM.** When using a TPU VM, you connect directly to the machine that the TPU is attached to, much like training on a GPU VM. TPU VMs are generally easier to work with, particularly when it comes to your data pipeline. All of the above warnings do not apply to TPU VMs!\n\nThis is an opinionated document, so here\u2019s our opinion: **Avoid using TPU Node if possible.** It is more confusing and more difficult to debug than TPU VMs. It is also likely to be unsupported in future - Google\u2019s latest TPU, TPUv4, can only be accessed as a TPU VM, which suggests that TPU Nodes are increasingly going to become a \u201clegacy\u201d access method. However, we understand that the only free TPU access is on Colab and Kaggle Kernels, which uses TPU Node - so we\u2019ll try to explain how to handle it if you have to! Check the [TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) for code samples that explain this in more detail.\n\n### What sizes of TPU are available?\n\nA single TPU (a v2-8/v3-8/v4-8) runs 8 replicas. TPUs exist in **pods** that can run hundreds or thousands of replicas simultaneously. When you use more than a single TPU but less than a whole pod (for example, a v3-32), your TPU fleet is referred to as a **pod slice.**\n\nWhen you access a free TPU via Colab, you generally get a single v2-8 TPU.\n\n### I keep hearing about this XLA thing. What\u2019s XLA, and how does it relate to TPUs?\n\nXLA is an optimizing compiler, used by both TensorFlow and JAX. In JAX it is the only compiler, whereas in TensorFlow it is optional"
        }
    },
    {
        "sample_idx": 123,
        "question": "What is the title of the paper cited in the BibTeX citation?",
        "answer": "Squeeze-and-Excitation Networks",
        "rag_answer": "There is no BibTeX citation provided in the Data Sources, so I cannot determine the title of the paper. The Data Sources only contain Knowledge Graph and Document Chunks, but no BibTeX citation.",
        "rag_score": 1,
        "rag_feedback": "The system's response is completely incorrect, inaccurate, and/or not factual. The question asks for the title of the paper cited in the BibTeX citation, but the system responds with a message saying that there is no BibTeX citation provided, which is not relevant to the question.",
        "rag_context": {
            "kg_context": "-----Entities-----\n    ```csv\n    id,\tentity,\ttype,\tdescription,\trankcreated_at\n1,\tMachine Learning,category,Machine Learning is a field of study that involves training models to make predictions.,5,2025-03-24 13:16:48\n2,\tPapers With Code,organization,Papers With Code is an organization that provides a platform for tracking machine learning papers and their corresponding code.,1,2025-03-24 13:16:48\n3,\tModel,category,Model refers to a machine learning model being evaluated.,3,2025-03-24 13:16:48\n4,\tPredictions,category,Predictions are the outcome of a model's performance.,2,2025-03-24 13:16:48\n5,\tReferences,category,References are sources of information used to support predictions.,1,2025-03-24 13:16:48\n6,\tReferences,category,References are sources of information used to support predictions.,1,UNKNOWN\n7,\tPapers With Code,organization,Papers With Code is an organization that provides a platform for tracking machine learning papers and their corresponding code.,1,UNKNOWN\n8,\tnotebooks,category,Notebooks are a type of interactive document used for data science and machine learning.,1,UNKNOWN\n    ```\n    -----Relationships-----\n    ```csv\n    id,\tsource,\ttarget,\tdescription,\tkeywords,\tweight,\trank,\tcreated_at\n1,\tMachine Learning,Papers With Code,Papers With Code provides a platform for tracking machine learning papers and their corresponding code.,research platform, machine learning,8.0,6,2025-03-24 13:16:48\n2,\tModel,Predictions,The model makes predictions based on the input data.,model output, predictions,8.0,5,2025-03-24 13:16:48\n3,\tPredictions,References,References are used to support predictions.,information sources, prediction support,14.0,3,2025-03-24 13:16:48\n4,\tMachine Learning,Papers With Code,Papers With Code provides a platform for tracking machine learning papers and their corresponding code.,research platform, machine learning,8.0,6,UNKNOWN\n5,\tPredictions,References,References are used to support predictions.,information sources, prediction support,14.0,3,UNKNOWN\n6,\tJupyter,notebooks,Notebooks are a type of interactive document used in Jupyter.,document type, interactive computing,7.0,3,UNKNOWN\n    ```\n    -----Sources-----\n    ```csv\n    id,\tcontent\n1,\tChoosing a metric for your task\n\n**So you've trained your model and want to see how well it\u2019s doing on a dataset of your choice. Where do you start?**\n\nThere is no \u201cone size fits all\u201d approach to choosing an evaluation metric, but some good guidelines to keep in mind are:\n\n## Categories of metrics\n\nThere are 3 high-level categories of metrics:\n\n1. *Generic metrics*, which can be applied to a variety of situations and datasets, such as precision and accuracy.\n2. *Task-specific metrics*, which are limited to a given task, such as Machine Translation (often evaluated using metrics [BLEU](https://huggingface.co/metrics/bleu) or [ROUGE](https://huggingface.co/metrics/rouge)) or Named Entity Recognition (often evaluated with [seqeval](https://huggingface.co/metrics/seqeval)).\n3. *Dataset-specific metrics*, which aim to measure model performance on specific benchmarks: for instance, the [GLUE benchmark](https://huggingface.co/datasets/glue) has a dedicated [evaluation metric](https://huggingface.co/metrics/glue).\n\nLet's look at each of these three cases:\n\n### Generic metrics\n\nMany of the metrics used in the Machine Learning community are quite generic and can be applied in a variety of tasks and datasets.\n\nThis is the case for metrics like [accuracy](https://huggingface.co/metrics/accuracy) and [precision](https://huggingface.co/metrics/precision), which can be used for evaluating labeled (supervised) datasets, as well as [perplexity](https://huggingface.co/metrics/perplexity), which can be used for evaluating different kinds of (unsupervised) generative tasks.\n\nTo see the input structure of a given metric, you can look at its metric card. For example, in the case of [precision](https://huggingface.co/metrics/precision), the format is:\n```\n>>> precision_metric = evaluate.load(\"precision\")\n>>> results = precision_metric.compute(references=[0, 1], predictions=[0, 1])\n>>> print(results)\n{'precision': 1.0}\n```\n\n### Task-specific metrics\n\nPopular ML tasks like Machine Translation and Named Entity Recognition have specific metrics that can be used to compare models. For example, a series of different metrics have been proposed for text generation, ranging from [BLEU](https://huggingface.co/metrics/bleu) and its derivatives such as [GoogleBLEU](https://huggingface.co/metrics/google_bleu) and [GLEU](https://huggingface.co/metrics/gleu), but also [ROUGE](https://huggingface.co/metrics/rouge), [MAUVE](https://huggingface.co/metrics/mauve), etc.\n\nYou can find the right metric for your task by:\n\n- **Looking at the [Task pages](https://huggingface.co/tasks)** to see what metrics can be used for evaluating models for a given task.\n- **Checking out leaderboards** on sites like [Papers With Code](https://paperswithcode.com/) (you can search by task and by dataset).\n-  **Reading the metric cards** for the relevant metrics and see which ones are a good fit for your use case. For example, see the [BLEU metric card](https://github.com/huggingface/evaluate/tree/main/metrics/bleu) or [SQuaD metric card](https://github.com/huggingface/evaluate/tree/main/metrics/squad).\n- **Looking at papers and blog posts** published on the topic and see what metrics they report. This can change over time, so try to pick papers from the last couple of years!\n\n### Dataset-specific metrics\n\nSome datasets have specific metrics associated with them -- this is especially in the case of popular benchmarks like [GLUE](https://huggingface.co/metrics/glue) and [SQuAD](https://huggingface.co/metrics/squad).\n\n<Tip warning={true}>\n\ud83d\udca1\nGLUE is actually a collection of different subsets on different tasks, so first you need to choose the one that corresponds to the NLI task, such as mnli, which is described as \u201ccrowdsourced collection of sentence pairs with textual entailment annotations\u201d\n</Tip>\n\n\nIf you are evaluating your model on a benchmark dataset like the ones mentioned above, you can use its dedicated evaluation metric. Make sure you respect the format that they require. For example, to evaluate your model on the [SQuAD](https://huggingface.co/datasets/squad) dataset, you need to feed the `question` and `context` into your model and return the `prediction_text`, which should be compared with the `references` (based on matching the `id` of the question) :\n\n```\n>>> from evaluate import load\n>>> squad_metric = load(\"squad\")\n>>> predictions = [{'prediction_text': '1976', 'id': '56e10a3be3433e1400422b22'}]\n>>> references = [{'answers': {'answer_start': [97], 'text': ['1976']}, 'id': '56e10a3be3433e1400422b22'}]\n>>> results = squad_metric.compute(predictions=predictions, references=references)\n>>> results\n{'exact_match': 100.0, 'f1': 100.0}\n```\n\nYou can find examples of dataset structures by consulting the \"Dataset Preview\" function or the dataset card for a given dataset, and you can see how to use its dedicated evaluation function based on the metric card.\n2,\t=predictions, references=references)\n>>> results\n{'exact_match': 100.0, 'f1': 100.0}\n```\n\nYou can find examples of dataset structures by consulting the \"Dataset Preview\" function or the dataset card for a given dataset, and you can see how to use its dedicated evaluation function based on the metric card.\n3,\t\u4e0e\u5e38\u89c4\u51fd\u6570\u76f8\u540c\u7684\u65b9\u5f0f\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio\u3002\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\uff08\u865a\u62df\u7684\uff09\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5b83\u5728\u8f93\u51fa\u56fe\u50cf\u4e4b\u524d\u751f\u6210\u6570\u4e2a\u6b65\u9aa4\u7684\u566a\u97f3\uff1a\n\n$code_fake_diffusion\n$demo_fake_diffusion\n\n\u8bf7\u6ce8\u610f\uff0c\u6211\u4eec\u5728\u8fed\u4ee3\u5668\u4e2d\u6dfb\u52a0\u4e86 `time.sleep(1)`\uff0c\u4ee5\u521b\u5efa\u6b65\u9aa4\u4e4b\u95f4\u7684\u4eba\u5de5\u6682\u505c\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u89c2\u5bdf\u8fed\u4ee3\u5668\u7684\u6b65\u9aa4\uff08\u5728\u771f\u5b9e\u7684\u56fe\u50cf\u751f\u6210\u6a21\u578b\u4e2d\uff0c\u8fd9\u53ef\u80fd\u662f\u4e0d\u5fc5\u8981\u7684\uff09\u3002\n\n\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio **\u9700\u8981**\u5728\u5e95\u5c42 Interface \u6216 Blocks \u4e2d\u542f\u7528\u961f\u5217\uff08\u8bf7\u53c2\u9605\u4e0a\u9762\u7684\u961f\u5217\u90e8\u5206\uff09\u3002\n\n## \u8fdb\u5ea6\u6761\n\nGradio \u652f\u6301\u521b\u5efa\u81ea\u5b9a\u4e49\u8fdb\u5ea6\u6761\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u81ea\u5b9a\u4e49\u548c\u63a7\u5236\u5411\u7528\u6237\u663e\u793a\u7684\u8fdb\u5ea6\u66f4\u65b0\u3002\u8981\u542f\u7528\u6b64\u529f\u80fd\uff0c\u53ea\u9700\u4e3a\u65b9\u6cd5\u6dfb\u52a0\u4e00\u4e2a\u9ed8\u8ba4\u503c\u4e3a `gr.Progress` \u5b9e\u4f8b\u7684\u53c2\u6570\u5373\u53ef\u3002\u7136\u540e\uff0c\u60a8\u53ef\u4ee5\u76f4\u63a5\u8c03\u7528\u6b64\u5b9e\u4f8b\u5e76\u4f20\u5165 0 \u5230 1 \u4e4b\u95f4\u7684\u6d6e\u70b9\u6570\u6765\u66f4\u65b0\u8fdb\u5ea6\u7ea7\u522b\uff0c\u6216\u8005 with `Progress` \u5b9e\u4f8b\u7684 `tqdm()` \u65b9\u6cd5\u6765\u8ddf\u8e2a\u53ef\u8fed\u4ee3\u5bf9\u8c61\u4e0a\u7684\u8fdb\u5ea6\uff0c\u5982\u4e0b\u6240\u793a\u3002\u5fc5\u987b\u542f\u7528\u961f\u5217\u4ee5\u8fdb\u884c\u8fdb\u5ea6\u66f4\u65b0\u3002\n\n$code_progress_simple\n$demo_progress_simple\n\n\u5982\u679c\u60a8 with `tqdm` \u5e93\uff0c\u5e76\u4e14\u5e0c\u671b\u4ece\u51fd\u6570\u5185\u90e8\u7684\u4efb\u4f55 `tqdm.tqdm` \u81ea\u52a8\u62a5\u544a\u8fdb\u5ea6\u66f4\u65b0\uff0c\u8bf7\u5c06\u9ed8\u8ba4\u53c2\u6570\u8bbe\u7f6e\u4e3a `gr.Progress(track_tqdm=True)`\uff01\n\n## \u6279\u5904\u7406\u51fd\u6570 (Batch Functions)\n\nGradio \u652f\u6301\u4f20\u9012*\u6279\u5904\u7406*\u51fd\u6570\u3002\u6279\u5904\u7406\u51fd\u6570\u53ea\u662f\u63a5\u53d7\u8f93\u5165\u5217\u8868\u5e76\u8fd4\u56de\u9884\u6d4b\u5217\u8868\u7684\u51fd\u6570\u3002\n\n\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\u6279\u5904\u7406\u51fd\u6570\uff0c\u5b83\u63a5\u53d7\u4e24\u4e2a\u8f93\u5165\u5217\u8868\uff08\u4e00\u4e2a\u5355\u8bcd\u5217\u8868\u548c\u4e00\u4e2a\u6574\u6570\u5217\u8868\uff09\uff0c\u5e76\u8fd4\u56de\u4fee\u526a\u8fc7\u7684\u5355\u8bcd\u5217\u8868\u4f5c\u4e3a\u8f93\u51fa\uff1a\n\n```python\nimport time\n\ndef trim_words(words, lens):\n    trimmed_words = []\n    time.sleep(5)\n    for w, l in zip(words, lens):\n        trimmed_words.append(w[:int(l)])\n    return [trimmed_words]\n    for w, l in zip(words, lens):\n```\n\n\u4f7f\u7528\u6279\u5904\u7406\u51fd\u6570\u7684\u4f18\u70b9\u662f\uff0c\u5982\u679c\u542f\u7528\u4e86\u961f\u5217\uff0cGradio \u670d\u52a1\u5668\u53ef\u4ee5\u81ea\u52a8*\u6279\u5904\u7406*\u4f20\u5165\u7684\u8bf7\u6c42\u5e76\u5e76\u884c\u5904\u7406\u5b83\u4eec\uff0c\u4ece\u800c\u53ef\u80fd\u52a0\u5feb\u6f14\u793a\u901f\u5ea6\u3002\u4ee5\u4e0b\u662f Gradio \u4ee3\u7801\u7684\u793a\u4f8b\uff08\u8bf7\u6ce8\u610f `batch=True` \u548c `max_batch_size=16` - \u8fd9\u4e24\u4e2a\u53c2\u6570\u90fd\u53ef\u4ee5\u4f20\u9012\u7ed9\u4e8b\u4ef6\u89e6\u53d1\u5668\u6216 `Interface` \u7c7b\uff09\n\nwith `Interface`\uff1a\n\n```python\ndemo = gr.Interface(trim_words, [\"textbox\", \"number\"], [\"output\"],\n                    batch=True, max_batch_size=16)\ndemo.queue()\ndemo.launch()\n```\n\nwith `Blocks`\uff1a\n\n```python\nimport gradio as gr\n\nwith gr.Blocks() as demo:\n    with gr.Row():\n        word = gr.Textbox(label=\"word\")\n        leng = gr.Number(label=\"leng\")\n        output = gr.Textbox(label=\"Output\")\n    with gr.Row():\n        run = gr.Button()\n\n    event = run.click(trim_words, [word, leng], output, batch=True, max_batch_size=16)\n\ndemo.queue()\ndemo.launch()\n```\n\n\u5728\u4e0a\u9762\u7684\u793a\u4f8b\u4e2d\uff0c\u53ef\u4ee5\u5e76\u884c\u5904\u7406 16 \u4e2a\u8bf7\u6c42\uff08\u603b\u63a8\u7406\u65f6\u95f4\u4e3a 5 \u79d2\uff09\uff0c\u800c\u4e0d\u662f\u5206\u522b\u5904\u7406\u6bcf\u4e2a\u8bf7\u6c42\uff08\u603b\u63a8\u7406\u65f6\u95f4\u4e3a 80 \u79d2\uff09\u3002\u8bb8\u591a Hugging Face \u7684 `transformers` \u548c `diffusers` \u6a21\u578b\u5728 Gradio \u7684\u6279\u5904\u7406\u6a21\u5f0f\u4e0b\u81ea\u7136\u5de5\u4f5c\uff1a\u8fd9\u662f[\u4f7f\u7528\u6279\u5904\u7406\u751f\u6210\u56fe\u50cf\u7684\u793a\u4f8b\u6f14\u793a](https://github.com/gradio-app/gradio/blob/main/demo/diffusers_with_batching/run.py)\n\n\u6ce8\u610f\uff1a\u4f7f\u7528 Gradio \u7684\u6279\u5904\u7406\u51fd\u6570 **requires** \u5728\u5e95\u5c42 Interface \u6216 Blocks \u4e2d\u542f\u7528\u961f\u5217\uff08\u8bf7\u53c2\u9605\u4e0a\u9762\u7684\u961f\u5217\u90e8\u5206\uff09\u3002\n\n## Gradio \u7b14\u8bb0\u672c (Colab Notebooks)\n\nGradio \u53ef\u4ee5\u5728\u4efb\u4f55\u8fd0\u884c Python \u7684\u5730\u65b9\u8fd0\u884c\uff0c\u5305\u62ec\u672c\u5730 Jupyter \u7b14\u8bb0\u672c\u548c\u534f\u4f5c\u7b14\u8bb0\u672c\uff0c\u5982[Google Colab](https://colab.research.google.com/)\u3002\u5bf9\u4e8e\u672c\u5730 Jupyter \u7b14\u8bb0\u672c\u548c Google Colab \u7b14\u8bb0\u672c\uff0cGradio \u5728\u672c\u5730\u670d\u52a1\u5668\u4e0a\u8fd0\u884c\uff0c\u60a8\u53ef\u4ee5\u5728\u6d4f\u89c8\u5668\u4e2d\u4e0e\u4e4b\u4ea4\u4e92\u3002\uff08\u6ce8\u610f\uff1a\u5bf9\u4e8e Google Colab\uff0c\u8fd9\u662f\u901a\u8fc7[\u670d\u52a1\u5de5\u4f5c\u5668\u96a7\u9053](https://github.com/tensorflow/tensorboard/blob/master/docs/design/colab_integration.md)\u5b9e\u73b0\u7684\uff0c\u60a8\u7684\u6d4f\u89c8\u5668\u9700\u8981\u542f\u7528 cookies\u3002\uff09\u5bf9\u4e8e\u5176\u4ed6\u8fdc\u7a0b\u7b14\u8bb0\u672c\uff0cGradio \u4e5f\u5c06\u5728\u670d\u52a1\u5668\u4e0a\u8fd0\u884c\uff0c\u4f46\u60a8\u9700\u8981\u4f7f\u7528[SSH \u96a7\u9053](https://coderwall.com/p/ohk6cg/remote-access-to-ipython-notebooks-via-ssh)\u5728\u672c\u5730\u6d4f\u89c8\u5668\u4e2d\u67e5\u770b\u5e94\u7528\u7a0b\u5e8f\u3002\u901a\u5e38\uff0c\u66f4\u7b80\u5355\u7684\u9009\u62e9\u662f\u4f7f\u7528 Gradio \u5185\u7f6e\u7684\u516c\u5171\u94fe\u63a5\uff0c[\u5728\u4e0b\u4e00\u7bc7\u6307\u5357\u4e2d\u8ba8\u8bba](/sharing-your-app/#sharing-demos)\u3002\n    ```",
            "vector_context": "[Created at: 2025-03-24 13:16:13]\n=predictions, references=references)\n>>> results\n{'exact_match': 100.0, 'f1': 100.0}\n```\n\nYou can find examples of dataset structures by consulting the \"Dataset Preview\" function or the dataset card for a given dataset, and you can see how to use its dedicated evaluation function based on the metric card.\n--New Chunk--\n[Created at: 2025-03-24 13:17:32]\n!--Copyright 2023 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\nthe License. You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under the License is distributed on\nan \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n\n\u26a0\ufe0f Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be\nrendered properly in your Markdown viewer.\n\n-->\n\n# Training on TPU with TensorFlow\n\n<Tip>\n\nIf you don't need long explanations and just want TPU code samples to get started with, check out [our TPU example notebook!](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb)\n\n</Tip>\n\n### What is a TPU?\n\nA TPU is a **Tensor Processing Unit.** They are hardware designed by Google, which are used to greatly speed up the tensor computations within neural networks, much like GPUs. They can be used for both network training and inference. They are generally accessed through Google\u2019s cloud services, but small TPUs can also be accessed directly for free through Google Colab and Kaggle Kernels.\n\nBecause [all TensorFlow models in \ud83e\udd17 Transformers are Keras models](https://huggingface.co/blog/tensorflow-philosophy), most of the methods in this document are generally applicable to TPU training for any Keras model! However, there are a few points that are specific to the HuggingFace ecosystem (hug-o-system?) of Transformers and Datasets, and we\u2019ll make sure to flag them up when we get to them.\n\n### What kinds of TPU are available?\n\nNew users are often very confused by the range of TPUs, and the different ways to access them. The first key distinction to understand is the difference between **TPU Nodes** and **TPU VMs.**\n\nWhen you use a **TPU Node**, you are effectively indirectly accessing a remote TPU. You will need a separate VM, which will initialize your network and data pipeline and then forward them to the remote node. When you use a TPU on Google Colab, you are accessing it in the **TPU Node** style.\n\nUsing TPU Nodes can have some quite unexpected behaviour for people who aren\u2019t used to them! In particular, because the TPU is located on a physically different system to the machine you\u2019re running your Python code on, your data cannot be local to your machine - any data pipeline that loads from your machine\u2019s internal storage will totally fail! Instead, data must be stored in Google Cloud Storage where your data pipeline can still access it, even when the pipeline is running on the remote TPU node.\n\n<Tip>\n\nIf you can fit all your data in memory as `np.ndarray` or `tf.Tensor`, then you can `fit()` on that data even when using Colab or a TPU Node, without needing to upload it to Google Cloud Storage.\n\n</Tip>\n\n<Tip>\n\n**\ud83e\udd17Specific Hugging Face Tip\ud83e\udd17:** The methods `Dataset.to_tf_dataset()` and its higher-level wrapper `model.prepare_tf_dataset()` , which you will see throughout our TF code examples, will both fail on a TPU Node. The reason for this is that even though they create a `tf.data.Dataset` it is not a \u201cpure\u201d `tf.data` pipeline and uses `tf.numpy_function` or `Dataset.from_generator()` to stream data from the underlying HuggingFace `Dataset`. This HuggingFace `Dataset` is backed by data that is on a local disc and which the remote TPU Node will not be able to read.\n\n</Tip>\n\nThe second way to access a TPU is via a **TPU VM.** When using a TPU VM, you connect directly to the machine that the TPU is attached to, much like training on a GPU VM. TPU VMs are generally easier to work with, particularly when it comes to your data pipeline. All of the above warnings do not apply to TPU VMs!\n\nThis is an opinionated document, so here\u2019s our opinion: **Avoid using TPU Node if possible.** It is more confusing and more difficult to debug than TPU VMs. It is also likely to be unsupported in future - Google\u2019s latest TPU, TPUv4, can only be accessed as a TPU VM, which suggests that TPU Nodes are increasingly going to become a \u201clegacy\u201d access method. However, we understand that the only free TPU access is on Colab and Kaggle Kernels, which uses TPU Node - so we\u2019ll try to explain how to handle it if you have to! Check the [TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) for code samples that explain this in more detail.\n\n### What sizes of TPU are available?\n\nA single TPU (a v2-8/v3-8/v4-8) runs 8 replicas. TPUs exist in **pods** that can run hundreds or thousands of replicas simultaneously. When you use more than a single TPU but less than a whole pod (for example, a v3-32), your TPU fleet is referred to as a **pod slice.**\n\nWhen you access a free TPU via Colab, you generally get a single v2-8 TPU.\n\n### I keep hearing about this XLA thing. What\u2019s XLA, and how does it relate to TPUs?\n\nXLA is an optimizing compiler, used by both TensorFlow and JAX. In JAX it is the only compiler, whereas in TensorFlow it is optional\n--New Chunk--\n[Created at: 2025-03-24 13:16:48]\n\u65f6\u5fc5\u987b\u9009\u62e9\u5176\u4e2d\u4e00\u4e2a\u5b57\u7b26\u4e32\uff0c\u8fd9\u5c06\u4f5c\u4e3a\u9644\u52a0\u5217\u4fdd\u5b58\u5230 CSV \u4e2d\u3002\n\n## \u9884\u5904\u7406\u548c\u540e\u5904\u7406 (Preprocessing and Postprocessing)\n\n![annotated](/assets/img/dataflow.svg)\n\n\u5982\u60a8\u6240\u89c1\uff0cGradio \u5305\u62ec\u53ef\u4ee5\u5904\u7406\u5404\u79cd\u4e0d\u540c\u6570\u636e\u7c7b\u578b\u7684\u7ec4\u4ef6\uff0c\u4f8b\u5982\u56fe\u50cf\u3001\u97f3\u9891\u548c\u89c6\u9891\u3002\u5927\u591a\u6570\u7ec4\u4ef6\u90fd\u53ef\u4ee5\u7528\u4f5c\u8f93\u5165\u6216\u8f93\u51fa\u3002\n\n\u5f53\u7ec4\u4ef6\u7528\u4f5c\u8f93\u5165\u65f6\uff0cGradio \u81ea\u52a8\u5904\u7406*\u9884\u5904\u7406*\uff0c\u5c06\u6570\u636e\u4ece\u7528\u6237\u6d4f\u89c8\u5668\u53d1\u9001\u7684\u7c7b\u578b\uff08\u4f8b\u5982\u7f51\u7edc\u6444\u50cf\u5934\u5feb\u7167\u7684 base64 \u8868\u793a\uff09\u8f6c\u6362\u4e3a\u60a8\u7684\u51fd\u6570\u53ef\u4ee5\u63a5\u53d7\u7684\u5f62\u5f0f\uff08\u4f8b\u5982 `numpy` \u6570\u7ec4\uff09\u3002\n\n\u540c\u6837\uff0c\u5f53\u7ec4\u4ef6\u7528\u4f5c\u8f93\u51fa\u65f6\uff0cGradio \u81ea\u52a8\u5904\u7406*\u540e\u5904\u7406*\uff0c\u5c06\u6570\u636e\u4ece\u51fd\u6570\u8fd4\u56de\u7684\u5f62\u5f0f\uff08\u4f8b\u5982\u56fe\u50cf\u8def\u5f84\u5217\u8868\uff09\u8f6c\u6362\u4e3a\u53ef\u4ee5\u5728\u7528\u6237\u6d4f\u89c8\u5668\u4e2d\u663e\u793a\u7684\u5f62\u5f0f\uff08\u4f8b\u5982\u4ee5 base64 \u683c\u5f0f\u663e\u793a\u56fe\u50cf\u7684 `Gallery`\uff09\u3002\n\n\u60a8\u53ef\u4ee5\u4f7f\u7528\u6784\u5efa\u56fe\u50cf\u7ec4\u4ef6\u65f6\u7684\u53c2\u6570\u63a7\u5236*\u9884\u5904\u7406*\u3002\u4f8b\u5982\uff0c\u5982\u679c\u60a8\u4f7f\u7528\u4ee5\u4e0b\u53c2\u6570\u5b9e\u4f8b\u5316 `Image` \u7ec4\u4ef6\uff0c\u5b83\u5c06\u5c06\u56fe\u50cf\u8f6c\u6362\u4e3a `PIL` \u7c7b\u578b\uff0c\u5e76\u5c06\u5176\u91cd\u5851\u4e3a`(100, 100)`\uff0c\u800c\u4e0d\u7ba1\u63d0\u4ea4\u65f6\u7684\u539f\u59cb\u5927\u5c0f\u5982\u4f55\uff1a\n\n```py\nimg = gr.Image(shape=(100, 100), type=\"pil\")\n```\n\n\u76f8\u53cd\uff0c\u8fd9\u91cc\u6211\u4eec\u4fdd\u7559\u56fe\u50cf\u7684\u539f\u59cb\u5927\u5c0f\uff0c\u4f46\u5728\u5c06\u5176\u8f6c\u6362\u4e3a numpy \u6570\u7ec4\u4e4b\u524d\u53cd\u8f6c\u989c\u8272\uff1a\n\n```py\nimg = gr.Image(invert_colors=True, type=\"numpy\")\n```\n\n\u540e\u5904\u7406\u8981\u5bb9\u6613\u5f97\u591a\uff01Gradio \u81ea\u52a8\u8bc6\u522b\u8fd4\u56de\u6570\u636e\u7684\u683c\u5f0f\uff08\u4f8b\u5982 `Image` \u662f `numpy` \u6570\u7ec4\u8fd8\u662f `str` \u6587\u4ef6\u8def\u5f84\uff1f\uff09\uff0c\u5e76\u5c06\u5176\u540e\u5904\u7406\u4e3a\u53ef\u4ee5\u7531\u6d4f\u89c8\u5668\u663e\u793a\u7684\u683c\u5f0f\u3002\n\n\u8bf7\u67e5\u770b[\u6587\u6863](https://gradio.app/docs)\uff0c\u4e86\u89e3\u6bcf\u4e2a\u7ec4\u4ef6\u7684\u6240\u6709\u4e0e\u9884\u5904\u7406\u76f8\u5173\u7684\u53c2\u6570\u3002\n\n## \u6837\u5f0f (Styling)\n\nGradio \u4e3b\u9898\u662f\u81ea\u5b9a\u4e49\u5e94\u7528\u7a0b\u5e8f\u5916\u89c2\u548c\u611f\u89c9\u7684\u6700\u7b80\u5355\u65b9\u6cd5\u3002\u60a8\u53ef\u4ee5\u9009\u62e9\u591a\u79cd\u4e3b\u9898\u6216\u521b\u5efa\u81ea\u5df1\u7684\u4e3b\u9898\u3002\u8981\u8fd9\u6837\u505a\uff0c\u8bf7\u5c06 `theme=` \u53c2\u6570\u4f20\u9012\u7ed9 `Interface` \u6784\u9020\u51fd\u6570\u3002\u4f8b\u5982\uff1a\n\n```python\ndemo = gr.Interface(..., theme=gr.themes.Monochrome())\n```\n\nGradio \u5e26\u6709\u4e00\u7ec4\u9884\u5148\u6784\u5efa\u7684\u4e3b\u9898\uff0c\u60a8\u53ef\u4ee5\u4ece `gr.themes.*` \u52a0\u8f7d\u3002\u60a8\u53ef\u4ee5\u6269\u5c55\u8fd9\u4e9b\u4e3b\u9898\u6216\u4ece\u5934\u5f00\u59cb\u521b\u5efa\u81ea\u5df1\u7684\u4e3b\u9898 - \u6709\u5173\u66f4\u591a\u8be6\u7ec6\u4fe1\u606f\uff0c\u8bf7\u53c2\u9605[\u4e3b\u9898\u6307\u5357](https://gradio.app/theming-guide)\u3002\n\n\u8981\u589e\u52a0\u989d\u5916\u7684\u6837\u5f0f\u80fd\u529b\uff0c\u60a8\u53ef\u4ee5 with `css=` \u5173\u952e\u5b57\u5c06\u4efb\u4f55 CSS \u4f20\u9012\u7ed9\u60a8\u7684\u5e94\u7528\u7a0b\u5e8f\u3002\nGradio \u5e94\u7528\u7a0b\u5e8f\u7684\u57fa\u7c7b\u662f `gradio-container`\uff0c\u56e0\u6b64\u4ee5\u4e0b\u662f\u4e00\u4e2a\u66f4\u6539 Gradio \u5e94\u7528\u7a0b\u5e8f\u80cc\u666f\u989c\u8272\u7684\u793a\u4f8b\uff1a\n\n```python\nwith `gr.Interface(css=\".gradio-container {background-color: red}\") as demo:\n    ...\n```\n\n## \u961f\u5217 (Queuing)\n\n\u5982\u679c\u60a8\u7684\u5e94\u7528\u7a0b\u5e8f\u9884\u8ba1\u4f1a\u6709\u5927\u91cf\u6d41\u91cf\uff0c\u8bf7 with `queue()` \u65b9\u6cd5\u6765\u63a7\u5236\u5904\u7406\u901f\u7387\u3002\u8fd9\u5c06\u6392\u961f\u5904\u7406\u8c03\u7528\uff0c\u56e0\u6b64\u4e00\u6b21\u53ea\u5904\u7406\u4e00\u5b9a\u6570\u91cf\u7684\u8bf7\u6c42\u3002\u961f\u5217\u4f7f\u7528 Websockets\uff0c\u8fd8\u53ef\u4ee5\u9632\u6b62\u7f51\u7edc\u8d85\u65f6\uff0c\u56e0\u6b64\u5982\u679c\u60a8\u7684\u51fd\u6570\u7684\u63a8\u7406\u65f6\u95f4\u5f88\u957f\uff08> 1 \u5206\u949f\uff09\uff0c\u5e94\u4f7f\u7528\u961f\u5217\u3002\n\nwith `Interface`\uff1a\n\n```python\ndemo = gr.Interface(...).queue()\ndemo.launch()\n```\n\nwith `Blocks`\uff1a\n\n```python\nwith gr.Blocks() as demo\uff1a\n    #...\ndemo.queue()\ndemo.launch()\n```\n\n\u60a8\u53ef\u4ee5\u901a\u8fc7\u4ee5\u4e0b\u65b9\u5f0f\u63a7\u5236\u4e00\u6b21\u5904\u7406\u7684\u8bf7\u6c42\u6570\u91cf\uff1a\n\n```python\ndemo.queue(concurrency_count=3)\n```\n\n\u67e5\u770b\u6709\u5173\u914d\u7f6e\u5176\u4ed6\u961f\u5217\u53c2\u6570\u7684[\u961f\u5217\u6587\u6863](/docs/#queue)\u3002\n\n\u5728 Blocks \u4e2d\u6307\u5b9a\u4ec5\u5bf9\u67d0\u4e9b\u51fd\u6570\u8fdb\u884c\u6392\u961f\uff1a\n\n```python\nwith gr.Blocks() as demo2\uff1a\n    num1 = gr.Number()\n    num2 = gr.Number()\n    output = gr.Number()\n    gr.Button(\"Add\").click(\n        lambda a, b: a + b, [num1, num2], output)\n    gr.Button(\"Multiply\").click(\n        lambda a, b: a * b, [num1, num2], output, queue=True)\ndemo2.launch()\n```\n\n## \u8fed\u4ee3\u8f93\u51fa (Iterative Outputs)\n\n\u5728\u67d0\u4e9b\u60c5\u51b5\u4e0b\uff0c\u60a8\u53ef\u80fd\u9700\u8981\u4f20\u8f93\u4e00\u7cfb\u5217\u8f93\u51fa\u800c\u4e0d\u662f\u4e00\u6b21\u663e\u793a\u5355\u4e2a\u8f93\u51fa\u3002\u4f8b\u5982\uff0c\u60a8\u53ef\u80fd\u6709\u4e00\u4e2a\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5e0c\u671b\u663e\u793a\u751f\u6210\u7684\u6bcf\u4e2a\u6b65\u9aa4\u7684\u56fe\u50cf\uff0c\u76f4\u5230\u6700\u7ec8\u56fe\u50cf\u3002\u6216\u8005\u60a8\u53ef\u80fd\u6709\u4e00\u4e2a\u804a\u5929\u673a\u5668\u4eba\uff0c\u5b83\u9010\u5b57\u9010\u53e5\u5730\u6d41\u5f0f\u4f20\u8f93\u54cd\u5e94\uff0c\u800c\u4e0d\u662f\u4e00\u6b21\u8fd4\u56de\u5168\u90e8\u54cd\u5e94\u3002\n\n\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u60a8\u53ef\u4ee5\u5c06**\u751f\u6210\u5668**\u51fd\u6570\u63d0\u4f9b\u7ed9 Gradio\uff0c\u800c\u4e0d\u662f\u5e38\u89c4\u51fd\u6570\u3002\u5728 Python \u4e2d\u521b\u5efa\u751f\u6210\u5668\u975e\u5e38\u7b80\u5355\uff1a\u51fd\u6570\u4e0d\u5e94\u8be5\u6709\u4e00\u4e2a\u5355\u72ec\u7684 `return` \u503c\uff0c\u800c\u662f\u5e94\u8be5 with `yield` \u8fde\u7eed\u8fd4\u56de\u4e00\u7cfb\u5217\u503c\u3002\u901a\u5e38\uff0c`yield` \u8bed\u53e5\u653e\u7f6e\u5728\u67d0\u79cd\u5faa\u73af\u4e2d\u3002\u4e0b\u9762\u662f\u4e00\u4e2a\u7b80\u5355\u793a\u4f8b\uff0c\u751f\u6210\u5668\u53ea\u662f\u7b80\u5355\u8ba1\u6570\u5230\u7ed9\u5b9a\u6570\u5b57\uff1a\n\n```python\ndef my_generator(x):\n    for i in range(x):\n        yield i\n```\n\n\u60a8\u4ee5\u4e0e\u5e38\u89c4\u51fd\u6570\u76f8\u540c\u7684\u65b9\u5f0f\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio\u3002\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\uff08\u865a\u62df\u7684\uff09\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5b83\u5728\u8f93\u51fa\u56fe\u50cf\u4e4b\u524d\u751f\u6210\u6570\u4e2a\u6b65\u9aa4\u7684\u566a\u97f3\uff1a\n\n$code_fake_diffusion\n$demo_fake_diffusion\n\n\u8bf7\u6ce8\u610f\uff0c\u6211\u4eec\u5728\u8fed\u4ee3\u5668\u4e2d\u6dfb\u52a0\u4e86 `time.sleep(1)`\uff0c\u4ee5\u521b\u5efa\u6b65\u9aa4\u4e4b\u95f4\u7684\u4eba\u5de5\u6682\u505c\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u89c2\u5bdf\u8fed\u4ee3\u5668\u7684\u6b65\u9aa4\uff08\u5728\u771f\u5b9e\u7684\u56fe\u50cf\u751f\u6210\u6a21\u578b\u4e2d\uff0c\u8fd9"
        }
    },
    {
        "sample_idx": 124,
        "question": "In what year was the paper 'Squeeze-and-Excitation Networks' published?",
        "answer": "2019",
        "rag_answer": "The paper 'Squeeze-and-Excitation Networks' was published in 2018.",
        "rag_score": 2,
        "rag_feedback": "The response is mostly incorrect, inaccurate, and/or not factual. The provided text is a lengthy passage about various topics, including TPUs, machine learning, and model evaluation, but it does not provide a direct answer to the question about the publication year of the paper 'Squeeze-and-Excitation Networks'.",
        "rag_context": {
            "kg_context": "-----Entities-----\n    ```csv\n    id,\tentity,\ttype,\tdescription,\trankcreated_at\n1,\tGoogle,organization,Google is the company that designs and provides TPUs, which are used to speed up tensor computations within neural networks.,3,2025-03-24 13:18:20\n2,\tTPU,technology,TPU is a Tensor Processing Unit, a hardware designed by Google to speed up tensor computations within neural networks.<SEP>TPU is a type of hardware accelerator designed for machine learning workloads.<SEP>TPU is a type of hardware accelerator used for machine learning computations.,4,2025-03-24 13:18:20\n3,\tMachine Learning,category,Machine Learning is a field of study that involves training models to make predictions.,5,2025-03-24 13:18:20\n4,\tPapers With Code,organization,Papers With Code is an organization that provides a platform for tracking machine learning papers and their corresponding code.,1,2025-03-24 13:18:20\n5,\tKeras,category,Keras is a high-level neural networks API, used for building and training neural networks.<SEP>Keras is a machine learning framework that uses XLA for optimization.,2,2025-03-24 13:18:20\n6,\tTensorFlow,category,TensorFlow is a machine learning framework that uses XLA as an optimizing compiler.<SEP>TensorFlow is a software framework used for building and training neural networks.<SEP>TensorFlow is an open-source machine learning framework.,3,2025-03-24 13:18:20\n7,\tCORD,geo,CORD is a form understanding dataset used for fine-tuning LayoutLMv3.,1,UNKNOWN\n8,\tGoogle,organization,Google is the company that designs and provides TPUs, which are used to speed up tensor computations within neural networks.,3,UNKNOWN\n9,\tNeural Networks,category,Neural Networks are a type of machine learning model used for various tasks such as image recognition and natural language processing.,0,UNKNOWN\n    ```\n    -----Relationships-----\n    ```csv\n    id,\tsource,\ttarget,\tdescription,\tkeywords,\tweight,\trank,\tcreated_at\n1,\tGoogle,TPU,Google designs and provides TPUs, which are used to speed up tensor computations within neural networks.,hardware design, acceleration,18.0,7,2025-03-24 13:18:20\n2,\tMachine Learning,Papers With Code,Papers With Code provides a platform for tracking machine learning papers and their corresponding code.,research platform, machine learning,8.0,6,2025-03-24 13:16:48\n3,\tKeras,TensorFlow,TensorFlow uses Keras as a high-level neural networks API.,API integration, neural networks,16.0,5,2025-03-24 13:18:20\n4,\tCORD,LayoutLMv3,CORD is a dataset used for fine-tuning the LayoutLMv3 model.,dataset, model training,14.0,12,UNKNOWN\n5,\tGoogle,TPU,Google designs and provides TPUs, which are used to speed up tensor computations within neural networks.,hardware design, acceleration,18.0,7,UNKNOWN\n6,\tColab,Google,Colab is a cloud-based platform provided by Google for data science and machine learning.,platform provision, cloud computing,16.0,6,UNKNOWN\n7,\tGoogle,Kaggle Kernels,Kaggle Kernels is a cloud-based platform provided by Google for data science and machine learning competitions.,platform provision, cloud computing,16.0,4,UNKNOWN\n    ```\n    -----Sources-----\n    ```csv\n    id,\tcontent\n1,\t!--Copyright 2023 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\nthe License. You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under the License is distributed on\nan \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n\n\u26a0\ufe0f Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be\nrendered properly in your Markdown viewer.\n\n-->\n\n# Training on TPU with TensorFlow\n\n<Tip>\n\nIf you don't need long explanations and just want TPU code samples to get started with, check out [our TPU example notebook!](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb)\n\n</Tip>\n\n### What is a TPU?\n\nA TPU is a **Tensor Processing Unit.** They are hardware designed by Google, which are used to greatly speed up the tensor computations within neural networks, much like GPUs. They can be used for both network training and inference. They are generally accessed through Google\u2019s cloud services, but small TPUs can also be accessed directly for free through Google Colab and Kaggle Kernels.\n\nBecause [all TensorFlow models in \ud83e\udd17 Transformers are Keras models](https://huggingface.co/blog/tensorflow-philosophy), most of the methods in this document are generally applicable to TPU training for any Keras model! However, there are a few points that are specific to the HuggingFace ecosystem (hug-o-system?) of Transformers and Datasets, and we\u2019ll make sure to flag them up when we get to them.\n\n### What kinds of TPU are available?\n\nNew users are often very confused by the range of TPUs, and the different ways to access them. The first key distinction to understand is the difference between **TPU Nodes** and **TPU VMs.**\n\nWhen you use a **TPU Node**, you are effectively indirectly accessing a remote TPU. You will need a separate VM, which will initialize your network and data pipeline and then forward them to the remote node. When you use a TPU on Google Colab, you are accessing it in the **TPU Node** style.\n\nUsing TPU Nodes can have some quite unexpected behaviour for people who aren\u2019t used to them! In particular, because the TPU is located on a physically different system to the machine you\u2019re running your Python code on, your data cannot be local to your machine - any data pipeline that loads from your machine\u2019s internal storage will totally fail! Instead, data must be stored in Google Cloud Storage where your data pipeline can still access it, even when the pipeline is running on the remote TPU node.\n\n<Tip>\n\nIf you can fit all your data in memory as `np.ndarray` or `tf.Tensor`, then you can `fit()` on that data even when using Colab or a TPU Node, without needing to upload it to Google Cloud Storage.\n\n</Tip>\n\n<Tip>\n\n**\ud83e\udd17Specific Hugging Face Tip\ud83e\udd17:** The methods `Dataset.to_tf_dataset()` and its higher-level wrapper `model.prepare_tf_dataset()` , which you will see throughout our TF code examples, will both fail on a TPU Node. The reason for this is that even though they create a `tf.data.Dataset` it is not a \u201cpure\u201d `tf.data` pipeline and uses `tf.numpy_function` or `Dataset.from_generator()` to stream data from the underlying HuggingFace `Dataset`. This HuggingFace `Dataset` is backed by data that is on a local disc and which the remote TPU Node will not be able to read.\n\n</Tip>\n\nThe second way to access a TPU is via a **TPU VM.** When using a TPU VM, you connect directly to the machine that the TPU is attached to, much like training on a GPU VM. TPU VMs are generally easier to work with, particularly when it comes to your data pipeline. All of the above warnings do not apply to TPU VMs!\n\nThis is an opinionated document, so here\u2019s our opinion: **Avoid using TPU Node if possible.** It is more confusing and more difficult to debug than TPU VMs. It is also likely to be unsupported in future - Google\u2019s latest TPU, TPUv4, can only be accessed as a TPU VM, which suggests that TPU Nodes are increasingly going to become a \u201clegacy\u201d access method. However, we understand that the only free TPU access is on Colab and Kaggle Kernels, which uses TPU Node - so we\u2019ll try to explain how to handle it if you have to! Check the [TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) for code samples that explain this in more detail.\n\n### What sizes of TPU are available?\n\nA single TPU (a v2-8/v3-8/v4-8) runs 8 replicas. TPUs exist in **pods** that can run hundreds or thousands of replicas simultaneously. When you use more than a single TPU but less than a whole pod (for example, a v3-32), your TPU fleet is referred to as a **pod slice.**\n\nWhen you access a free TPU via Colab, you generally get a single v2-8 TPU.\n\n### I keep hearing about this XLA thing. What\u2019s XLA, and how does it relate to TPUs?\n\nXLA is an optimizing compiler, used by both TensorFlow and JAX. In JAX it is the only compiler, whereas in TensorFlow it is optional\n2,\tChoosing a metric for your task\n\n**So you've trained your model and want to see how well it\u2019s doing on a dataset of your choice. Where do you start?**\n\nThere is no \u201cone size fits all\u201d approach to choosing an evaluation metric, but some good guidelines to keep in mind are:\n\n## Categories of metrics\n\nThere are 3 high-level categories of metrics:\n\n1. *Generic metrics*, which can be applied to a variety of situations and datasets, such as precision and accuracy.\n2. *Task-specific metrics*, which are limited to a given task, such as Machine Translation (often evaluated using metrics [BLEU](https://huggingface.co/metrics/bleu) or [ROUGE](https://huggingface.co/metrics/rouge)) or Named Entity Recognition (often evaluated with [seqeval](https://huggingface.co/metrics/seqeval)).\n3. *Dataset-specific metrics*, which aim to measure model performance on specific benchmarks: for instance, the [GLUE benchmark](https://huggingface.co/datasets/glue) has a dedicated [evaluation metric](https://huggingface.co/metrics/glue).\n\nLet's look at each of these three cases:\n\n### Generic metrics\n\nMany of the metrics used in the Machine Learning community are quite generic and can be applied in a variety of tasks and datasets.\n\nThis is the case for metrics like [accuracy](https://huggingface.co/metrics/accuracy) and [precision](https://huggingface.co/metrics/precision), which can be used for evaluating labeled (supervised) datasets, as well as [perplexity](https://huggingface.co/metrics/perplexity), which can be used for evaluating different kinds of (unsupervised) generative tasks.\n\nTo see the input structure of a given metric, you can look at its metric card. For example, in the case of [precision](https://huggingface.co/metrics/precision), the format is:\n```\n>>> precision_metric = evaluate.load(\"precision\")\n>>> results = precision_metric.compute(references=[0, 1], predictions=[0, 1])\n>>> print(results)\n{'precision': 1.0}\n```\n\n### Task-specific metrics\n\nPopular ML tasks like Machine Translation and Named Entity Recognition have specific metrics that can be used to compare models. For example, a series of different metrics have been proposed for text generation, ranging from [BLEU](https://huggingface.co/metrics/bleu) and its derivatives such as [GoogleBLEU](https://huggingface.co/metrics/google_bleu) and [GLEU](https://huggingface.co/metrics/gleu), but also [ROUGE](https://huggingface.co/metrics/rouge), [MAUVE](https://huggingface.co/metrics/mauve), etc.\n\nYou can find the right metric for your task by:\n\n- **Looking at the [Task pages](https://huggingface.co/tasks)** to see what metrics can be used for evaluating models for a given task.\n- **Checking out leaderboards** on sites like [Papers With Code](https://paperswithcode.com/) (you can search by task and by dataset).\n-  **Reading the metric cards** for the relevant metrics and see which ones are a good fit for your use case. For example, see the [BLEU metric card](https://github.com/huggingface/evaluate/tree/main/metrics/bleu) or [SQuaD metric card](https://github.com/huggingface/evaluate/tree/main/metrics/squad).\n- **Looking at papers and blog posts** published on the topic and see what metrics they report. This can change over time, so try to pick papers from the last couple of years!\n\n### Dataset-specific metrics\n\nSome datasets have specific metrics associated with them -- this is especially in the case of popular benchmarks like [GLUE](https://huggingface.co/metrics/glue) and [SQuAD](https://huggingface.co/metrics/squad).\n\n<Tip warning={true}>\n\ud83d\udca1\nGLUE is actually a collection of different subsets on different tasks, so first you need to choose the one that corresponds to the NLI task, such as mnli, which is described as \u201ccrowdsourced collection of sentence pairs with textual entailment annotations\u201d\n</Tip>\n\n\nIf you are evaluating your model on a benchmark dataset like the ones mentioned above, you can use its dedicated evaluation metric. Make sure you respect the format that they require. For example, to evaluate your model on the [SQuAD](https://huggingface.co/datasets/squad) dataset, you need to feed the `question` and `context` into your model and return the `prediction_text`, which should be compared with the `references` (based on matching the `id` of the question) :\n\n```\n>>> from evaluate import load\n>>> squad_metric = load(\"squad\")\n>>> predictions = [{'prediction_text': '1976', 'id': '56e10a3be3433e1400422b22'}]\n>>> references = [{'answers': {'answer_start': [97], 'text': ['1976']}, 'id': '56e10a3be3433e1400422b22'}]\n>>> results = squad_metric.compute(predictions=predictions, references=references)\n>>> results\n{'exact_match': 100.0, 'f1': 100.0}\n```\n\nYou can find examples of dataset structures by consulting the \"Dataset Preview\" function or the dataset card for a given dataset, and you can see how to use its dedicated evaluation function based on the metric card.\n3,\t!---\nCopyright 2022 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n-->\n\n# Token classification with LayoutLMv3 (PyTorch version)\n\nThis directory contains a script, `run_funsd_cord.py`, that can be used to fine-tune (or evaluate) LayoutLMv3 on form understanding datasets, such as [FUNSD](https://guillaumejaume.github.io/FUNSD/) and [CORD](https://github.com/clovaai/cord).\n\nThe script `run_funsd_cord.py` leverages the \ud83e\udd17 Datasets library and the Trainer API. You can easily customize it to your needs.\n\n## Fine-tuning on FUNSD\n\nFine-tuning LayoutLMv3 for token classification on [FUNSD](https://guillaumejaume.github.io/FUNSD/) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name funsd \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 1e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-funsd\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd. By specifying the `push_to_hub` flag, the model gets uploaded automatically to the hub (regularly), together with a model card, which includes metrics such as precision, recall and F1. Note that you can easily update the model card, as it's just a README file of the respective repo on the hub.\n\nThere's also the \"Training metrics\" [tab](https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd/tensorboard), which shows Tensorboard logs over the course of training. Pretty neat, huh?\n\n## Fine-tuning on CORD\n\nFine-tuning LayoutLMv3 for token classification on [CORD](https://github.com/clovaai/cord) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name cord \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 5e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-cord\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-cord. Note that a model card gets generated automatically in case you specify the `push_to_hub` flag.\n    ```",
            "vector_context": "[Created at: 2025-03-24 13:17:32]\n!--Copyright 2023 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\nthe License. You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under the License is distributed on\nan \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n\n\u26a0\ufe0f Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be\nrendered properly in your Markdown viewer.\n\n-->\n\n# Training on TPU with TensorFlow\n\n<Tip>\n\nIf you don't need long explanations and just want TPU code samples to get started with, check out [our TPU example notebook!](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb)\n\n</Tip>\n\n### What is a TPU?\n\nA TPU is a **Tensor Processing Unit.** They are hardware designed by Google, which are used to greatly speed up the tensor computations within neural networks, much like GPUs. They can be used for both network training and inference. They are generally accessed through Google\u2019s cloud services, but small TPUs can also be accessed directly for free through Google Colab and Kaggle Kernels.\n\nBecause [all TensorFlow models in \ud83e\udd17 Transformers are Keras models](https://huggingface.co/blog/tensorflow-philosophy), most of the methods in this document are generally applicable to TPU training for any Keras model! However, there are a few points that are specific to the HuggingFace ecosystem (hug-o-system?) of Transformers and Datasets, and we\u2019ll make sure to flag them up when we get to them.\n\n### What kinds of TPU are available?\n\nNew users are often very confused by the range of TPUs, and the different ways to access them. The first key distinction to understand is the difference between **TPU Nodes** and **TPU VMs.**\n\nWhen you use a **TPU Node**, you are effectively indirectly accessing a remote TPU. You will need a separate VM, which will initialize your network and data pipeline and then forward them to the remote node. When you use a TPU on Google Colab, you are accessing it in the **TPU Node** style.\n\nUsing TPU Nodes can have some quite unexpected behaviour for people who aren\u2019t used to them! In particular, because the TPU is located on a physically different system to the machine you\u2019re running your Python code on, your data cannot be local to your machine - any data pipeline that loads from your machine\u2019s internal storage will totally fail! Instead, data must be stored in Google Cloud Storage where your data pipeline can still access it, even when the pipeline is running on the remote TPU node.\n\n<Tip>\n\nIf you can fit all your data in memory as `np.ndarray` or `tf.Tensor`, then you can `fit()` on that data even when using Colab or a TPU Node, without needing to upload it to Google Cloud Storage.\n\n</Tip>\n\n<Tip>\n\n**\ud83e\udd17Specific Hugging Face Tip\ud83e\udd17:** The methods `Dataset.to_tf_dataset()` and its higher-level wrapper `model.prepare_tf_dataset()` , which you will see throughout our TF code examples, will both fail on a TPU Node. The reason for this is that even though they create a `tf.data.Dataset` it is not a \u201cpure\u201d `tf.data` pipeline and uses `tf.numpy_function` or `Dataset.from_generator()` to stream data from the underlying HuggingFace `Dataset`. This HuggingFace `Dataset` is backed by data that is on a local disc and which the remote TPU Node will not be able to read.\n\n</Tip>\n\nThe second way to access a TPU is via a **TPU VM.** When using a TPU VM, you connect directly to the machine that the TPU is attached to, much like training on a GPU VM. TPU VMs are generally easier to work with, particularly when it comes to your data pipeline. All of the above warnings do not apply to TPU VMs!\n\nThis is an opinionated document, so here\u2019s our opinion: **Avoid using TPU Node if possible.** It is more confusing and more difficult to debug than TPU VMs. It is also likely to be unsupported in future - Google\u2019s latest TPU, TPUv4, can only be accessed as a TPU VM, which suggests that TPU Nodes are increasingly going to become a \u201clegacy\u201d access method. However, we understand that the only free TPU access is on Colab and Kaggle Kernels, which uses TPU Node - so we\u2019ll try to explain how to handle it if you have to! Check the [TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) for code samples that explain this in more detail.\n\n### What sizes of TPU are available?\n\nA single TPU (a v2-8/v3-8/v4-8) runs 8 replicas. TPUs exist in **pods** that can run hundreds or thousands of replicas simultaneously. When you use more than a single TPU but less than a whole pod (for example, a v3-32), your TPU fleet is referred to as a **pod slice.**\n\nWhen you access a free TPU via Colab, you generally get a single v2-8 TPU.\n\n### I keep hearing about this XLA thing. What\u2019s XLA, and how does it relate to TPUs?\n\nXLA is an optimizing compiler, used by both TensorFlow and JAX. In JAX it is the only compiler, whereas in TensorFlow it is optional\n--New Chunk--\n[Created at: 2025-03-24 13:18:21]\nGradio Demo: blocks_random_slider\n\n\n```\n!pip install -q gradio \n```\n\n\n```\n\nimport gradio as gr\n\n\ndef func(slider_1, slider_2):\n    return slider_1 * 5 + slider_2\n\n\nwith gr.Blocks() as demo:\n    slider = gr.Slider(minimum=-10.2, maximum=15, label=\"Random Slider (Static)\", randomize=True)\n    slider_1 = gr.Slider(minimum=100, maximum=200, label=\"Random Slider (Input 1)\", randomize=True)\n    slider_2 = gr.Slider(minimum=10, maximum=23.2, label=\"Random Slider (Input 2)\", randomize=True)\n    slider_3 = gr.Slider(value=3, label=\"Non random slider\")\n    btn = gr.Button(\"Run\")\n    btn.click(func, inputs=[slider_1, slider_2], outputs=gr.Number())\n\nif __name__ == \"__main__\":\n    demo.launch()\n\n```\n--New Chunk--\n[Created at: 2025-03-24 13:19:17]\n!---\nCopyright 2022 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n-->\n\n# Token classification with LayoutLMv3 (PyTorch version)\n\nThis directory contains a script, `run_funsd_cord.py`, that can be used to fine-tune (or evaluate) LayoutLMv3 on form understanding datasets, such as [FUNSD](https://guillaumejaume.github.io/FUNSD/) and [CORD](https://github.com/clovaai/cord).\n\nThe script `run_funsd_cord.py` leverages the \ud83e\udd17 Datasets library and the Trainer API. You can easily customize it to your needs.\n\n## Fine-tuning on FUNSD\n\nFine-tuning LayoutLMv3 for token classification on [FUNSD](https://guillaumejaume.github.io/FUNSD/) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name funsd \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 1e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-funsd\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd. By specifying the `push_to_hub` flag, the model gets uploaded automatically to the hub (regularly), together with a model card, which includes metrics such as precision, recall and F1. Note that you can easily update the model card, as it's just a README file of the respective repo on the hub.\n\nThere's also the \"Training metrics\" [tab](https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd/tensorboard), which shows Tensorboard logs over the course of training. Pretty neat, huh?\n\n## Fine-tuning on CORD\n\nFine-tuning LayoutLMv3 for token classification on [CORD](https://github.com/clovaai/cord) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name cord \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 5e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-cord\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-cord. Note that a model card gets generated automatically in case you specify the `push_to_hub` flag."
        }
    },
    {
        "sample_idx": 125,
        "question": "What is the ID of the model?",
        "answer": "seresnet50",
        "rag_answer": "The model ID is `layoutlmv3-finetuned-funsd` for the model fine-tuned on FUNSD and `layoutlmv3-finetuned-cord` for the model fine-tuned on CORD.\n\nReferences:\n[DC] https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd\n[DC] https://huggingface.co/nielsr/layoutlmv3-finetuned-cord",
        "rag_score": 1,
        "rag_feedback": "The system's response is completely incorrect, inaccurate, and/or not factual. The expected answer is 'seresnet50', but the system's response provides information about fine-tuning LayoutLMv3 models on FUNSD and CORD datasets, which is unrelated to the question.",
        "rag_context": {
            "kg_context": "-----Entities-----\n    ```csv\n    id,\tentity,\ttype,\tdescription,\trankcreated_at\n1,\tDatasets library,technology,Datasets library is a tool used for fine-tuning the LayoutLMv3 model.,1,2025-03-24 13:16:48\n2,\tLayoutLMv3,technology,LayoutLMv3 is a model used for token classification and form understanding tasks.,11,2025-03-24 13:16:48\n3,\tMachine Learning,category,Machine Learning is a field of study that involves training models to make predictions.,5,2025-03-24 13:16:48\n4,\tModel,category,Model refers to a machine learning model being evaluated.,3,2025-03-24 13:16:48\n5,\tPredictions,category,Predictions are the outcome of a model's performance.,2,2025-03-24 13:16:48\n6,\tModel,category,Model refers to a machine learning model being evaluated.,3,UNKNOWN\n7,\tF1,category,F1 is a metric used to evaluate the performance of a model.,1,UNKNOWN\n8,\tResults,event,Results are the outcome of evaluating a model, in this case, showing perfect accuracy.,1,UNKNOWN\n    ```\n    -----Relationships-----\n    ```csv\n    id,\tsource,\ttarget,\tdescription,\tkeywords,\tweight,\trank,\tcreated_at\n1,\tDatasets library,LayoutLMv3,Datasets library is a tool used for fine-tuning the LayoutLMv3 model.,tool, model fine-tuning,7.0,12,2025-03-24 13:19:57\n2,\tMachine Learning,Model,Machine Learning involves training models to make predictions.,field of study, model training,9.0,8,2025-03-24 13:16:48\n3,\tModel,Predictions,The model makes predictions based on the input data.,model output, predictions,8.0,5,2025-03-24 13:16:48\n4,\tMachine Learning,Model,Machine Learning involves training models to make predictions.,field of study, model training,9.0,8,UNKNOWN\n5,\tEvaluation Function,Model,The evaluation function is used to assess the performance of the model.,model evaluation, performance assessment,18.0,5,UNKNOWN\n6,\tModel,Predictions,The model makes predictions based on the input data.,model output, predictions,8.0,5,UNKNOWN\n7,\tEvaluation Function,Results,The results are obtained by using the evaluation function.,evaluation outcome, accuracy,20.0,3,UNKNOWN\n8,\tExact Match,F1,Exact Match and F1 are both metrics used to evaluate the performance of a model.,evaluation metrics, performance assessment,8.0,2,UNKNOWN\n    ```\n    -----Sources-----\n    ```csv\n    id,\tcontent\n1,\t!---\nCopyright 2022 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n-->\n\n# Token classification with LayoutLMv3 (PyTorch version)\n\nThis directory contains a script, `run_funsd_cord.py`, that can be used to fine-tune (or evaluate) LayoutLMv3 on form understanding datasets, such as [FUNSD](https://guillaumejaume.github.io/FUNSD/) and [CORD](https://github.com/clovaai/cord).\n\nThe script `run_funsd_cord.py` leverages the \ud83e\udd17 Datasets library and the Trainer API. You can easily customize it to your needs.\n\n## Fine-tuning on FUNSD\n\nFine-tuning LayoutLMv3 for token classification on [FUNSD](https://guillaumejaume.github.io/FUNSD/) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name funsd \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 1e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-funsd\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd. By specifying the `push_to_hub` flag, the model gets uploaded automatically to the hub (regularly), together with a model card, which includes metrics such as precision, recall and F1. Note that you can easily update the model card, as it's just a README file of the respective repo on the hub.\n\nThere's also the \"Training metrics\" [tab](https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd/tensorboard), which shows Tensorboard logs over the course of training. Pretty neat, huh?\n\n## Fine-tuning on CORD\n\nFine-tuning LayoutLMv3 for token classification on [CORD](https://github.com/clovaai/cord) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name cord \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 5e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-cord\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-cord. Note that a model card gets generated automatically in case you specify the `push_to_hub` flag.\n2,\t=predictions, references=references)\n>>> results\n{'exact_match': 100.0, 'f1': 100.0}\n```\n\nYou can find examples of dataset structures by consulting the \"Dataset Preview\" function or the dataset card for a given dataset, and you can see how to use its dedicated evaluation function based on the metric card.\n    ```",
            "vector_context": "[Created at: 2025-03-24 13:16:13]\n=predictions, references=references)\n>>> results\n{'exact_match': 100.0, 'f1': 100.0}\n```\n\nYou can find examples of dataset structures by consulting the \"Dataset Preview\" function or the dataset card for a given dataset, and you can see how to use its dedicated evaluation function based on the metric card.\n--New Chunk--\n[Created at: 2025-03-24 13:19:17]\n!---\nCopyright 2022 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n-->\n\n# Token classification with LayoutLMv3 (PyTorch version)\n\nThis directory contains a script, `run_funsd_cord.py`, that can be used to fine-tune (or evaluate) LayoutLMv3 on form understanding datasets, such as [FUNSD](https://guillaumejaume.github.io/FUNSD/) and [CORD](https://github.com/clovaai/cord).\n\nThe script `run_funsd_cord.py` leverages the \ud83e\udd17 Datasets library and the Trainer API. You can easily customize it to your needs.\n\n## Fine-tuning on FUNSD\n\nFine-tuning LayoutLMv3 for token classification on [FUNSD](https://guillaumejaume.github.io/FUNSD/) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name funsd \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 1e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-funsd\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd. By specifying the `push_to_hub` flag, the model gets uploaded automatically to the hub (regularly), together with a model card, which includes metrics such as precision, recall and F1. Note that you can easily update the model card, as it's just a README file of the respective repo on the hub.\n\nThere's also the \"Training metrics\" [tab](https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd/tensorboard), which shows Tensorboard logs over the course of training. Pretty neat, huh?\n\n## Fine-tuning on CORD\n\nFine-tuning LayoutLMv3 for token classification on [CORD](https://github.com/clovaai/cord) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name cord \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 5e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-cord\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-cord. Note that a model card gets generated automatically in case you specify the `push_to_hub` flag.\n--New Chunk--\n[Created at: 2025-03-24 13:19:57]\nState in Blocks\n\nWe covered [State in Interfaces](https://gradio.app/interface-state), this guide takes a look at state in Blocks, which works mostly the same.\n\n## Global State\n\nGlobal state in Blocks works the same as in Interface. Any variable created outside a function call is a reference shared between all users.\n\n## Session State\n\nGradio supports session **state**, where data persists across multiple submits within a page session, in Blocks apps as well. To reiterate, session data is _not_ shared between different users of your model. To store data in a session state, you need to do three things:\n\n1. Create a `gr.State()` object. If there is a default value to this stateful object, pass that into the constructor.\n2. In the event listener, put the `State` object as an input and output.\n3. In the event listener function, add the variable to the input parameters and the return value.\n\nLet's take a look at a game of hangman.\n\n$code_hangman\n$demo_hangman\n\nLet's see how we do each of the 3 steps listed above in this game:\n\n1. We store the used letters in `used_letters_var`. In the constructor of `State`, we set the initial value of this to `[]`, an empty list.\n2. In `btn.click()`, we have a reference to `used_letters_var` in both the inputs and outputs.\n3. In `guess_letter`, we pass the value of this `State` to `used_letters`, and then return an updated value of this `State` in the return statement.\n\nWith more complex apps, you will likely have many State variables storing session state in a single Blocks app.\n\nLearn more about `State` in the [docs](https://gradio.app/docs#state)."
        }
    },
    {
        "sample_idx": 126,
        "question": "What is the learning rate of the model?",
        "answer": "0.6",
        "rag_answer": "The learning rate of the model is 1e-5 for fine-tuning on FUNSD and 5e-5 for fine-tuning on CORD, as specified in the commands:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name funsd \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 1e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model",
        "rag_score": null,
        "rag_feedback": null,
        "rag_context": {
            "kg_context": "-----Entities-----\n    ```csv\n    id,\tentity,\ttype,\tdescription,\trankcreated_at\n1,\tGradio,organization,Gradio is a platform that supports state in Blocks, providing features such as global state and session state.<SEP>Gradio is an interface that provides various features for demonstrating models, including adding example inputs, custom error messages, descriptive content, flagging, and more.<SEP>Gradio is an organization that provides a platform for building and deploying machine learning models.<SEP>Gradio is an organization that provides a platform for creating and deploying machine learning models.<SEP>Gradio is an organization that provides a demo for blocks_random_slider, and its library is used to create interactive interfaces.,36,2025-03-24 13:18:20\n2,\tPostprocessing,concept,Postprocessing refers to the process of transforming output from machine learning models into a usable format.,1,2025-03-24 13:18:20\n3,\tMachine Learning,category,Machine Learning is a field of study that involves training models to make predictions.,5,2025-03-24 13:18:20\n4,\tModel,category,Model refers to a machine learning model being evaluated.,3,2025-03-24 13:18:20\n5,\tKeras,category,Keras is a high-level neural networks API, used for building and training neural networks.<SEP>Keras is a machine learning framework that uses XLA for optimization.,2,2025-03-24 13:18:20\n6,\tXLA,technology,XLA is a technology that compiles TensorFlow graphs into executable code for various platforms.<SEP>XLA is an optimizing compiler used by TensorFlow and JAX to improve performance.<SEP>XLA is an optimizing compiler, used by both TensorFlow and JAX to optimize computations.,6,2025-03-24 13:18:20\n7,\tNeural Networks,category,Neural Networks are a type of machine learning model used for various tasks such as image recognition and natural language processing.,0,UNKNOWN\n8,\tMachine Learning,category,Machine Learning is a field of study that involves training models to make predictions.,5,UNKNOWN\n9,\tloss,concept,loss is a measure of the error in a machine learning model.,0,UNKNOWN\n    ```\n    -----Relationships-----\n    ```csv\n    id,\tsource,\ttarget,\tdescription,\tkeywords,\tweight,\trank,\tcreated_at\n1,\tGradio,Postprocessing,Gradio supports postprocessing of output from machine learning models.,output transformation, machine learning,8.0,37,2025-03-24 13:17:31\n2,\tMachine Learning,Model,Machine Learning involves training models to make predictions.,field of study, model training,9.0,8,2025-03-24 13:16:48\n3,\tKeras,XLA,Keras uses XLA for optimization.,compiler, performance optimization,8.0,8,2025-03-24 13:18:20\n4,\tMachine Learning,Model,Machine Learning involves training models to make predictions.,field of study, model training,9.0,8,UNKNOWN\n5,\tMachine Learning,accuracy,accuracy is a metric used to evaluate machine learning models.,evaluation metric, task,9.0,6,UNKNOWN\n6,\tMachine Learning,precision,precision is a metric used to evaluate machine learning models.,evaluation metric, task,9.0,6,UNKNOWN\n7,\tMachine Learning,perplexity,perplexity is a metric used to evaluate machine learning models.,evaluation metric, task,9.0,6,UNKNOWN\n8,\tMachine Learning,Papers With Code,Papers With Code provides a platform for tracking machine learning papers and their corresponding code.,research platform, machine learning,8.0,6,UNKNOWN\n    ```\n    -----Sources-----\n    ```csv\n    id,\tcontent\n1,\t\u65f6\u5fc5\u987b\u9009\u62e9\u5176\u4e2d\u4e00\u4e2a\u5b57\u7b26\u4e32\uff0c\u8fd9\u5c06\u4f5c\u4e3a\u9644\u52a0\u5217\u4fdd\u5b58\u5230 CSV \u4e2d\u3002\n\n## \u9884\u5904\u7406\u548c\u540e\u5904\u7406 (Preprocessing and Postprocessing)\n\n![annotated](/assets/img/dataflow.svg)\n\n\u5982\u60a8\u6240\u89c1\uff0cGradio \u5305\u62ec\u53ef\u4ee5\u5904\u7406\u5404\u79cd\u4e0d\u540c\u6570\u636e\u7c7b\u578b\u7684\u7ec4\u4ef6\uff0c\u4f8b\u5982\u56fe\u50cf\u3001\u97f3\u9891\u548c\u89c6\u9891\u3002\u5927\u591a\u6570\u7ec4\u4ef6\u90fd\u53ef\u4ee5\u7528\u4f5c\u8f93\u5165\u6216\u8f93\u51fa\u3002\n\n\u5f53\u7ec4\u4ef6\u7528\u4f5c\u8f93\u5165\u65f6\uff0cGradio \u81ea\u52a8\u5904\u7406*\u9884\u5904\u7406*\uff0c\u5c06\u6570\u636e\u4ece\u7528\u6237\u6d4f\u89c8\u5668\u53d1\u9001\u7684\u7c7b\u578b\uff08\u4f8b\u5982\u7f51\u7edc\u6444\u50cf\u5934\u5feb\u7167\u7684 base64 \u8868\u793a\uff09\u8f6c\u6362\u4e3a\u60a8\u7684\u51fd\u6570\u53ef\u4ee5\u63a5\u53d7\u7684\u5f62\u5f0f\uff08\u4f8b\u5982 `numpy` \u6570\u7ec4\uff09\u3002\n\n\u540c\u6837\uff0c\u5f53\u7ec4\u4ef6\u7528\u4f5c\u8f93\u51fa\u65f6\uff0cGradio \u81ea\u52a8\u5904\u7406*\u540e\u5904\u7406*\uff0c\u5c06\u6570\u636e\u4ece\u51fd\u6570\u8fd4\u56de\u7684\u5f62\u5f0f\uff08\u4f8b\u5982\u56fe\u50cf\u8def\u5f84\u5217\u8868\uff09\u8f6c\u6362\u4e3a\u53ef\u4ee5\u5728\u7528\u6237\u6d4f\u89c8\u5668\u4e2d\u663e\u793a\u7684\u5f62\u5f0f\uff08\u4f8b\u5982\u4ee5 base64 \u683c\u5f0f\u663e\u793a\u56fe\u50cf\u7684 `Gallery`\uff09\u3002\n\n\u60a8\u53ef\u4ee5\u4f7f\u7528\u6784\u5efa\u56fe\u50cf\u7ec4\u4ef6\u65f6\u7684\u53c2\u6570\u63a7\u5236*\u9884\u5904\u7406*\u3002\u4f8b\u5982\uff0c\u5982\u679c\u60a8\u4f7f\u7528\u4ee5\u4e0b\u53c2\u6570\u5b9e\u4f8b\u5316 `Image` \u7ec4\u4ef6\uff0c\u5b83\u5c06\u5c06\u56fe\u50cf\u8f6c\u6362\u4e3a `PIL` \u7c7b\u578b\uff0c\u5e76\u5c06\u5176\u91cd\u5851\u4e3a`(100, 100)`\uff0c\u800c\u4e0d\u7ba1\u63d0\u4ea4\u65f6\u7684\u539f\u59cb\u5927\u5c0f\u5982\u4f55\uff1a\n\n```py\nimg = gr.Image(shape=(100, 100), type=\"pil\")\n```\n\n\u76f8\u53cd\uff0c\u8fd9\u91cc\u6211\u4eec\u4fdd\u7559\u56fe\u50cf\u7684\u539f\u59cb\u5927\u5c0f\uff0c\u4f46\u5728\u5c06\u5176\u8f6c\u6362\u4e3a numpy \u6570\u7ec4\u4e4b\u524d\u53cd\u8f6c\u989c\u8272\uff1a\n\n```py\nimg = gr.Image(invert_colors=True, type=\"numpy\")\n```\n\n\u540e\u5904\u7406\u8981\u5bb9\u6613\u5f97\u591a\uff01Gradio \u81ea\u52a8\u8bc6\u522b\u8fd4\u56de\u6570\u636e\u7684\u683c\u5f0f\uff08\u4f8b\u5982 `Image` \u662f `numpy` \u6570\u7ec4\u8fd8\u662f `str` \u6587\u4ef6\u8def\u5f84\uff1f\uff09\uff0c\u5e76\u5c06\u5176\u540e\u5904\u7406\u4e3a\u53ef\u4ee5\u7531\u6d4f\u89c8\u5668\u663e\u793a\u7684\u683c\u5f0f\u3002\n\n\u8bf7\u67e5\u770b[\u6587\u6863](https://gradio.app/docs)\uff0c\u4e86\u89e3\u6bcf\u4e2a\u7ec4\u4ef6\u7684\u6240\u6709\u4e0e\u9884\u5904\u7406\u76f8\u5173\u7684\u53c2\u6570\u3002\n\n## \u6837\u5f0f (Styling)\n\nGradio \u4e3b\u9898\u662f\u81ea\u5b9a\u4e49\u5e94\u7528\u7a0b\u5e8f\u5916\u89c2\u548c\u611f\u89c9\u7684\u6700\u7b80\u5355\u65b9\u6cd5\u3002\u60a8\u53ef\u4ee5\u9009\u62e9\u591a\u79cd\u4e3b\u9898\u6216\u521b\u5efa\u81ea\u5df1\u7684\u4e3b\u9898\u3002\u8981\u8fd9\u6837\u505a\uff0c\u8bf7\u5c06 `theme=` \u53c2\u6570\u4f20\u9012\u7ed9 `Interface` \u6784\u9020\u51fd\u6570\u3002\u4f8b\u5982\uff1a\n\n```python\ndemo = gr.Interface(..., theme=gr.themes.Monochrome())\n```\n\nGradio \u5e26\u6709\u4e00\u7ec4\u9884\u5148\u6784\u5efa\u7684\u4e3b\u9898\uff0c\u60a8\u53ef\u4ee5\u4ece `gr.themes.*` \u52a0\u8f7d\u3002\u60a8\u53ef\u4ee5\u6269\u5c55\u8fd9\u4e9b\u4e3b\u9898\u6216\u4ece\u5934\u5f00\u59cb\u521b\u5efa\u81ea\u5df1\u7684\u4e3b\u9898 - \u6709\u5173\u66f4\u591a\u8be6\u7ec6\u4fe1\u606f\uff0c\u8bf7\u53c2\u9605[\u4e3b\u9898\u6307\u5357](https://gradio.app/theming-guide)\u3002\n\n\u8981\u589e\u52a0\u989d\u5916\u7684\u6837\u5f0f\u80fd\u529b\uff0c\u60a8\u53ef\u4ee5 with `css=` \u5173\u952e\u5b57\u5c06\u4efb\u4f55 CSS \u4f20\u9012\u7ed9\u60a8\u7684\u5e94\u7528\u7a0b\u5e8f\u3002\nGradio \u5e94\u7528\u7a0b\u5e8f\u7684\u57fa\u7c7b\u662f `gradio-container`\uff0c\u56e0\u6b64\u4ee5\u4e0b\u662f\u4e00\u4e2a\u66f4\u6539 Gradio \u5e94\u7528\u7a0b\u5e8f\u80cc\u666f\u989c\u8272\u7684\u793a\u4f8b\uff1a\n\n```python\nwith `gr.Interface(css=\".gradio-container {background-color: red}\") as demo:\n    ...\n```\n\n## \u961f\u5217 (Queuing)\n\n\u5982\u679c\u60a8\u7684\u5e94\u7528\u7a0b\u5e8f\u9884\u8ba1\u4f1a\u6709\u5927\u91cf\u6d41\u91cf\uff0c\u8bf7 with `queue()` \u65b9\u6cd5\u6765\u63a7\u5236\u5904\u7406\u901f\u7387\u3002\u8fd9\u5c06\u6392\u961f\u5904\u7406\u8c03\u7528\uff0c\u56e0\u6b64\u4e00\u6b21\u53ea\u5904\u7406\u4e00\u5b9a\u6570\u91cf\u7684\u8bf7\u6c42\u3002\u961f\u5217\u4f7f\u7528 Websockets\uff0c\u8fd8\u53ef\u4ee5\u9632\u6b62\u7f51\u7edc\u8d85\u65f6\uff0c\u56e0\u6b64\u5982\u679c\u60a8\u7684\u51fd\u6570\u7684\u63a8\u7406\u65f6\u95f4\u5f88\u957f\uff08> 1 \u5206\u949f\uff09\uff0c\u5e94\u4f7f\u7528\u961f\u5217\u3002\n\nwith `Interface`\uff1a\n\n```python\ndemo = gr.Interface(...).queue()\ndemo.launch()\n```\n\nwith `Blocks`\uff1a\n\n```python\nwith gr.Blocks() as demo\uff1a\n    #...\ndemo.queue()\ndemo.launch()\n```\n\n\u60a8\u53ef\u4ee5\u901a\u8fc7\u4ee5\u4e0b\u65b9\u5f0f\u63a7\u5236\u4e00\u6b21\u5904\u7406\u7684\u8bf7\u6c42\u6570\u91cf\uff1a\n\n```python\ndemo.queue(concurrency_count=3)\n```\n\n\u67e5\u770b\u6709\u5173\u914d\u7f6e\u5176\u4ed6\u961f\u5217\u53c2\u6570\u7684[\u961f\u5217\u6587\u6863](/docs/#queue)\u3002\n\n\u5728 Blocks \u4e2d\u6307\u5b9a\u4ec5\u5bf9\u67d0\u4e9b\u51fd\u6570\u8fdb\u884c\u6392\u961f\uff1a\n\n```python\nwith gr.Blocks() as demo2\uff1a\n    num1 = gr.Number()\n    num2 = gr.Number()\n    output = gr.Number()\n    gr.Button(\"Add\").click(\n        lambda a, b: a + b, [num1, num2], output)\n    gr.Button(\"Multiply\").click(\n        lambda a, b: a * b, [num1, num2], output, queue=True)\ndemo2.launch()\n```\n\n## \u8fed\u4ee3\u8f93\u51fa (Iterative Outputs)\n\n\u5728\u67d0\u4e9b\u60c5\u51b5\u4e0b\uff0c\u60a8\u53ef\u80fd\u9700\u8981\u4f20\u8f93\u4e00\u7cfb\u5217\u8f93\u51fa\u800c\u4e0d\u662f\u4e00\u6b21\u663e\u793a\u5355\u4e2a\u8f93\u51fa\u3002\u4f8b\u5982\uff0c\u60a8\u53ef\u80fd\u6709\u4e00\u4e2a\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5e0c\u671b\u663e\u793a\u751f\u6210\u7684\u6bcf\u4e2a\u6b65\u9aa4\u7684\u56fe\u50cf\uff0c\u76f4\u5230\u6700\u7ec8\u56fe\u50cf\u3002\u6216\u8005\u60a8\u53ef\u80fd\u6709\u4e00\u4e2a\u804a\u5929\u673a\u5668\u4eba\uff0c\u5b83\u9010\u5b57\u9010\u53e5\u5730\u6d41\u5f0f\u4f20\u8f93\u54cd\u5e94\uff0c\u800c\u4e0d\u662f\u4e00\u6b21\u8fd4\u56de\u5168\u90e8\u54cd\u5e94\u3002\n\n\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u60a8\u53ef\u4ee5\u5c06**\u751f\u6210\u5668**\u51fd\u6570\u63d0\u4f9b\u7ed9 Gradio\uff0c\u800c\u4e0d\u662f\u5e38\u89c4\u51fd\u6570\u3002\u5728 Python \u4e2d\u521b\u5efa\u751f\u6210\u5668\u975e\u5e38\u7b80\u5355\uff1a\u51fd\u6570\u4e0d\u5e94\u8be5\u6709\u4e00\u4e2a\u5355\u72ec\u7684 `return` \u503c\uff0c\u800c\u662f\u5e94\u8be5 with `yield` \u8fde\u7eed\u8fd4\u56de\u4e00\u7cfb\u5217\u503c\u3002\u901a\u5e38\uff0c`yield` \u8bed\u53e5\u653e\u7f6e\u5728\u67d0\u79cd\u5faa\u73af\u4e2d\u3002\u4e0b\u9762\u662f\u4e00\u4e2a\u7b80\u5355\u793a\u4f8b\uff0c\u751f\u6210\u5668\u53ea\u662f\u7b80\u5355\u8ba1\u6570\u5230\u7ed9\u5b9a\u6570\u5b57\uff1a\n\n```python\ndef my_generator(x):\n    for i in range(x):\n        yield i\n```\n\n\u60a8\u4ee5\u4e0e\u5e38\u89c4\u51fd\u6570\u76f8\u540c\u7684\u65b9\u5f0f\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio\u3002\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\uff08\u865a\u62df\u7684\uff09\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5b83\u5728\u8f93\u51fa\u56fe\u50cf\u4e4b\u524d\u751f\u6210\u6570\u4e2a\u6b65\u9aa4\u7684\u566a\u97f3\uff1a\n\n$code_fake_diffusion\n$demo_fake_diffusion\n\n\u8bf7\u6ce8\u610f\uff0c\u6211\u4eec\u5728\u8fed\u4ee3\u5668\u4e2d\u6dfb\u52a0\u4e86 `time.sleep(1)`\uff0c\u4ee5\u521b\u5efa\u6b65\u9aa4\u4e4b\u95f4\u7684\u4eba\u5de5\u6682\u505c\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u89c2\u5bdf\u8fed\u4ee3\u5668\u7684\u6b65\u9aa4\uff08\u5728\u771f\u5b9e\u7684\u56fe\u50cf\u751f\u6210\u6a21\u578b\u4e2d\uff0c\u8fd9\n2,\t=predictions, references=references)\n>>> results\n{'exact_match': 100.0, 'f1': 100.0}\n```\n\nYou can find examples of dataset structures by consulting the \"Dataset Preview\" function or the dataset card for a given dataset, and you can see how to use its dedicated evaluation function based on the metric card.\n3,\t(for example, a v3-32), your TPU fleet is referred to as a **pod slice.**\n\nWhen you access a free TPU via Colab, you generally get a single v2-8 TPU.\n\n### I keep hearing about this XLA thing. What\u2019s XLA, and how does it relate to TPUs?\n\nXLA is an optimizing compiler, used by both TensorFlow and JAX. In JAX it is the only compiler, whereas in TensorFlow it is optional (but mandatory on TPU!). The easiest way to enable it when training a Keras model is to pass the argument `jit_compile=True` to `model.compile()`. If you don\u2019t get any errors and performance is good, that\u2019s a great sign that you\u2019re ready to move to TPU!\n\nDebugging on TPU is generally a bit harder than on CPU/GPU, so we recommend getting your code running on CPU/GPU with XLA first before trying it on TPU. You don\u2019t have to train for long, of course - just for a few steps to make sure that your model and data pipeline are working like you expect them to.\n\n<Tip>\n\nXLA compiled code is usually faster - so even if you\u2019re not planning to run on TPU, adding `jit_compile=True` can improve your performance. Be sure to note the caveats below about XLA compatibility, though!\n\n</Tip>\n\n<Tip warning={true}>\n\n**Tip born of painful experience:** Although using `jit_compile=True` is a good way to get a speed boost and test if your CPU/GPU code is XLA-compatible, it can actually cause a lot of problems if you leave it in when actually training on TPU. XLA compilation will happen implicitly on TPU, so remember to remove that line before actually running your code on a TPU!\n\n</Tip>\n\n### How do I make my model XLA compatible?\n\nIn many cases, your code is probably XLA-compatible already! However, there are a few things that work in normal TensorFlow that don\u2019t work in XLA. We\u2019ve distilled them into three core rules below:\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** We\u2019ve put a lot of effort into rewriting our TensorFlow models and loss functions to be XLA-compatible. Our models and loss functions generally obey rule #1 and #2 by default, so you can skip over them if you\u2019re using `transformers` models. Don\u2019t forget about these rules when writing your own models and loss functions, though!\n\n</Tip>\n\n#### XLA Rule #1: Your code cannot have \u201cdata-dependent conditionals\u201d\n\nWhat that means is that any `if` statement cannot depend on values inside a `tf.Tensor`. For example, this code block cannot be compiled with XLA!\n\n```python\nif tf.reduce_sum(tensor) > 10:\n    tensor = tensor / 2.0\n```\n\nThis might seem very restrictive at first, but most neural net code doesn\u2019t need to do this. You can often get around this restriction by using `tf.cond` (see the documentation [here](https://www.tensorflow.org/api_docs/python/tf/cond)) or by removing the conditional and finding a clever math trick with indicator variables instead, like so:\n\n```python\nsum_over_10 = tf.cast(tf.reduce_sum(tensor) > 10, tf.float32)\ntensor = tensor / (1.0 + sum_over_10)\n```\n\nThis code has exactly the same effect as the code above, but by avoiding a conditional, we ensure it will compile with XLA without problems!\n\n#### XLA Rule #2: Your code cannot have \u201cdata-dependent shapes\u201d\n\nWhat this means is that the shape of all of the `tf.Tensor` objects in your code cannot depend on their values. For example, the function `tf.unique` cannot be compiled with XLA, because it returns a `tensor` containing one instance of each unique value in the input. The shape of this output will obviously be different depending on how repetitive the input `Tensor` was, and so XLA refuses to handle it!\n\nIn general, most neural network code obeys rule #2 by default. However, there are a few common cases where it becomes a problem. One very common one is when you use **label masking**, setting your labels to a negative value to indicate that those positions should be ignored when computing the loss. If you look at NumPy or PyTorch loss functions that support label masking, you will often see code like this that uses [boolean indexing](https://numpy.org/doc/stable/user/basics.indexing.html#boolean-array-indexing):\n\n```python\nlabel_mask = labels >= 0\nmasked_outputs = outputs[label_mask]\nmasked_labels = labels[label_mask]\nloss = compute_loss(masked_outputs, masked_labels)\nmean_loss = torch.mean(loss)\n```\n\nThis code is totally fine in NumPy or PyTorch, but it breaks in XLA! Why? Because the shape of `masked_outputs` and `masked_labels` depends on how many positions are masked - that makes it a **data-dependent shape.** However, just like for rule #1, we can often rewrite this code to yield exactly the same output without any data-dependent shapes.\n\n```python\nlabel_mask = tf.cast(labels >= 0, tf.float32)\nloss = compute_loss(outputs, labels)\nloss = loss * label_mask  # Set negative label positions to 0\nmean_loss = tf.reduce_sum(loss) / tf.reduce_sum(label_mask)\n```\n\nHere, we avoid data-dependent shapes by computing the loss for every position, but zeroing out the masked positions in both the numerator and denominator when we calculate the mean, which yields exactly the same result as the first block while maintaining XLA compatibility. Note that we use the same trick as in rule #1 - converting a `tf.bool` to `\n4,\t!--Copyright 2023 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\nthe License. You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under the License is distributed on\nan \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n\n\u26a0\ufe0f Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be\nrendered properly in your Markdown viewer.\n\n-->\n\n# Training on TPU with TensorFlow\n\n<Tip>\n\nIf you don't need long explanations and just want TPU code samples to get started with, check out [our TPU example notebook!](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb)\n\n</Tip>\n\n### What is a TPU?\n\nA TPU is a **Tensor Processing Unit.** They are hardware designed by Google, which are used to greatly speed up the tensor computations within neural networks, much like GPUs. They can be used for both network training and inference. They are generally accessed through Google\u2019s cloud services, but small TPUs can also be accessed directly for free through Google Colab and Kaggle Kernels.\n\nBecause [all TensorFlow models in \ud83e\udd17 Transformers are Keras models](https://huggingface.co/blog/tensorflow-philosophy), most of the methods in this document are generally applicable to TPU training for any Keras model! However, there are a few points that are specific to the HuggingFace ecosystem (hug-o-system?) of Transformers and Datasets, and we\u2019ll make sure to flag them up when we get to them.\n\n### What kinds of TPU are available?\n\nNew users are often very confused by the range of TPUs, and the different ways to access them. The first key distinction to understand is the difference between **TPU Nodes** and **TPU VMs.**\n\nWhen you use a **TPU Node**, you are effectively indirectly accessing a remote TPU. You will need a separate VM, which will initialize your network and data pipeline and then forward them to the remote node. When you use a TPU on Google Colab, you are accessing it in the **TPU Node** style.\n\nUsing TPU Nodes can have some quite unexpected behaviour for people who aren\u2019t used to them! In particular, because the TPU is located on a physically different system to the machine you\u2019re running your Python code on, your data cannot be local to your machine - any data pipeline that loads from your machine\u2019s internal storage will totally fail! Instead, data must be stored in Google Cloud Storage where your data pipeline can still access it, even when the pipeline is running on the remote TPU node.\n\n<Tip>\n\nIf you can fit all your data in memory as `np.ndarray` or `tf.Tensor`, then you can `fit()` on that data even when using Colab or a TPU Node, without needing to upload it to Google Cloud Storage.\n\n</Tip>\n\n<Tip>\n\n**\ud83e\udd17Specific Hugging Face Tip\ud83e\udd17:** The methods `Dataset.to_tf_dataset()` and its higher-level wrapper `model.prepare_tf_dataset()` , which you will see throughout our TF code examples, will both fail on a TPU Node. The reason for this is that even though they create a `tf.data.Dataset` it is not a \u201cpure\u201d `tf.data` pipeline and uses `tf.numpy_function` or `Dataset.from_generator()` to stream data from the underlying HuggingFace `Dataset`. This HuggingFace `Dataset` is backed by data that is on a local disc and which the remote TPU Node will not be able to read.\n\n</Tip>\n\nThe second way to access a TPU is via a **TPU VM.** When using a TPU VM, you connect directly to the machine that the TPU is attached to, much like training on a GPU VM. TPU VMs are generally easier to work with, particularly when it comes to your data pipeline. All of the above warnings do not apply to TPU VMs!\n\nThis is an opinionated document, so here\u2019s our opinion: **Avoid using TPU Node if possible.** It is more confusing and more difficult to debug than TPU VMs. It is also likely to be unsupported in future - Google\u2019s latest TPU, TPUv4, can only be accessed as a TPU VM, which suggests that TPU Nodes are increasingly going to become a \u201clegacy\u201d access method. However, we understand that the only free TPU access is on Colab and Kaggle Kernels, which uses TPU Node - so we\u2019ll try to explain how to handle it if you have to! Check the [TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) for code samples that explain this in more detail.\n\n### What sizes of TPU are available?\n\nA single TPU (a v2-8/v3-8/v4-8) runs 8 replicas. TPUs exist in **pods** that can run hundreds or thousands of replicas simultaneously. When you use more than a single TPU but less than a whole pod (for example, a v3-32), your TPU fleet is referred to as a **pod slice.**\n\nWhen you access a free TPU via Colab, you generally get a single v2-8 TPU.\n\n### I keep hearing about this XLA thing. What\u2019s XLA, and how does it relate to TPUs?\n\nXLA is an optimizing compiler, used by both TensorFlow and JAX. In JAX it is the only compiler, whereas in TensorFlow it is optional\n5,\tlabel_mask  # Set negative label positions to 0\nmean_loss = tf.reduce_sum(loss) / tf.reduce_sum(label_mask)\n```\n\nHere, we avoid data-dependent shapes by computing the loss for every position, but zeroing out the masked positions in both the numerator and denominator when we calculate the mean, which yields exactly the same result as the first block while maintaining XLA compatibility. Note that we use the same trick as in rule #1 - converting a `tf.bool` to `tf.float32` and using it as an indicator variable. This is a really useful trick, so remember it if you need to convert your own code to XLA!\n\n#### XLA Rule #3: XLA will need to recompile your model for every different input shape it sees\n\nThis is the big one. What this means is that if your input shapes are very variable, XLA will have to recompile your model over and over, which will create huge performance problems. This commonly arises in NLP models, where input texts have variable lengths after tokenization. In other modalities, static shapes are more common and this rule is much less of a problem.\n\nHow can you get around rule #3? The key is **padding** - if you pad all your inputs to the same length, and then use an `attention_mask`, you can get the same results as you\u2019d get from variable shapes, but without any XLA issues. However, excessive padding can cause severe slowdown too - if you pad all your samples to the maximum length in the whole dataset, you might end up with batches consisting endless padding tokens, which will waste a lot of compute and memory!\n\nThere isn\u2019t a perfect solution to this problem. However, you can try some tricks. One very useful trick is to **pad batches of samples up to a multiple of a number like 32 or 64 tokens.** This often only increases the number of tokens by a small amount, but it hugely reduces the number of unique input shapes, because every input shape now has to be a multiple of 32 or 64. Fewer unique input shapes means fewer XLA compilations!\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** Our tokenizers and data collators have methods that can help you here. You can use `padding=\"max_length\"` or `padding=\"longest\"` when calling tokenizers to get them to output padded data. Our tokenizers and data collators also have a `pad_to_multiple_of` argument that you can use to reduce the number of unique input shapes you see!\n\n</Tip>\n\n### How do I actually train my model on TPU?\n\nOnce your training is XLA-compatible and (if you\u2019re using TPU Node / Colab) your dataset has been prepared appropriately, running on TPU is surprisingly easy! All you really need to change in your code is to add a few lines to initialize your TPU, and to ensure that your model and dataset are created inside a `TPUStrategy` scope. Take a look at [our TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) to see this in action!\n\n### Summary\n\nThere was a lot in here, so let\u2019s summarize with a quick checklist you can follow when you want to get your model ready for TPU training:\n\n- Make sure your code follows the three rules of XLA\n- Compile your model with `jit_compile=True` on CPU/GPU and confirm that you can train it with XLA\n- Either load your dataset into memory or use a TPU-compatible dataset loading approach (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Migrate your code either to Colab (with accelerator set to \u201cTPU\u201d) or a TPU VM on Google Cloud\n- Add TPU initializer code (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Create your `TPUStrategy` and make sure dataset loading and model creation are inside the `strategy.scope()` (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Don\u2019t forget to take `jit_compile=True` out again when you move to TPU!\n- \ud83d\ude4f\ud83d\ude4f\ud83d\ude4f\ud83e\udd7a\ud83e\udd7a\ud83e\udd7a\n- Call model.fit()\n- You did it!\n    ```",
            "vector_context": "[Created at: 2025-03-24 13:16:13]\nChoosing a metric for your task\n\n**So you've trained your model and want to see how well it\u2019s doing on a dataset of your choice. Where do you start?**\n\nThere is no \u201cone size fits all\u201d approach to choosing an evaluation metric, but some good guidelines to keep in mind are:\n\n## Categories of metrics\n\nThere are 3 high-level categories of metrics:\n\n1. *Generic metrics*, which can be applied to a variety of situations and datasets, such as precision and accuracy.\n2. *Task-specific metrics*, which are limited to a given task, such as Machine Translation (often evaluated using metrics [BLEU](https://huggingface.co/metrics/bleu) or [ROUGE](https://huggingface.co/metrics/rouge)) or Named Entity Recognition (often evaluated with [seqeval](https://huggingface.co/metrics/seqeval)).\n3. *Dataset-specific metrics*, which aim to measure model performance on specific benchmarks: for instance, the [GLUE benchmark](https://huggingface.co/datasets/glue) has a dedicated [evaluation metric](https://huggingface.co/metrics/glue).\n\nLet's look at each of these three cases:\n\n### Generic metrics\n\nMany of the metrics used in the Machine Learning community are quite generic and can be applied in a variety of tasks and datasets.\n\nThis is the case for metrics like [accuracy](https://huggingface.co/metrics/accuracy) and [precision](https://huggingface.co/metrics/precision), which can be used for evaluating labeled (supervised) datasets, as well as [perplexity](https://huggingface.co/metrics/perplexity), which can be used for evaluating different kinds of (unsupervised) generative tasks.\n\nTo see the input structure of a given metric, you can look at its metric card. For example, in the case of [precision](https://huggingface.co/metrics/precision), the format is:\n```\n>>> precision_metric = evaluate.load(\"precision\")\n>>> results = precision_metric.compute(references=[0, 1], predictions=[0, 1])\n>>> print(results)\n{'precision': 1.0}\n```\n\n### Task-specific metrics\n\nPopular ML tasks like Machine Translation and Named Entity Recognition have specific metrics that can be used to compare models. For example, a series of different metrics have been proposed for text generation, ranging from [BLEU](https://huggingface.co/metrics/bleu) and its derivatives such as [GoogleBLEU](https://huggingface.co/metrics/google_bleu) and [GLEU](https://huggingface.co/metrics/gleu), but also [ROUGE](https://huggingface.co/metrics/rouge), [MAUVE](https://huggingface.co/metrics/mauve), etc.\n\nYou can find the right metric for your task by:\n\n- **Looking at the [Task pages](https://huggingface.co/tasks)** to see what metrics can be used for evaluating models for a given task.\n- **Checking out leaderboards** on sites like [Papers With Code](https://paperswithcode.com/) (you can search by task and by dataset).\n-  **Reading the metric cards** for the relevant metrics and see which ones are a good fit for your use case. For example, see the [BLEU metric card](https://github.com/huggingface/evaluate/tree/main/metrics/bleu) or [SQuaD metric card](https://github.com/huggingface/evaluate/tree/main/metrics/squad).\n- **Looking at papers and blog posts** published on the topic and see what metrics they report. This can change over time, so try to pick papers from the last couple of years!\n\n### Dataset-specific metrics\n\nSome datasets have specific metrics associated with them -- this is especially in the case of popular benchmarks like [GLUE](https://huggingface.co/metrics/glue) and [SQuAD](https://huggingface.co/metrics/squad).\n\n<Tip warning={true}>\n\ud83d\udca1\nGLUE is actually a collection of different subsets on different tasks, so first you need to choose the one that corresponds to the NLI task, such as mnli, which is described as \u201ccrowdsourced collection of sentence pairs with textual entailment annotations\u201d\n</Tip>\n\n\nIf you are evaluating your model on a benchmark dataset like the ones mentioned above, you can use its dedicated evaluation metric. Make sure you respect the format that they require. For example, to evaluate your model on the [SQuAD](https://huggingface.co/datasets/squad) dataset, you need to feed the `question` and `context` into your model and return the `prediction_text`, which should be compared with the `references` (based on matching the `id` of the question) :\n\n```\n>>> from evaluate import load\n>>> squad_metric = load(\"squad\")\n>>> predictions = [{'prediction_text': '1976', 'id': '56e10a3be3433e1400422b22'}]\n>>> references = [{'answers': {'answer_start': [97], 'text': ['1976']}, 'id': '56e10a3be3433e1400422b22'}]\n>>> results = squad_metric.compute(predictions=predictions, references=references)\n>>> results\n{'exact_match': 100.0, 'f1': 100.0}\n```\n\nYou can find examples of dataset structures by consulting the \"Dataset Preview\" function or the dataset card for a given dataset, and you can see how to use its dedicated evaluation function based on the metric card.\n--New Chunk--\n[Created at: 2025-03-24 13:19:17]\n!---\nCopyright 2022 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n-->\n\n# Token classification with LayoutLMv3 (PyTorch version)\n\nThis directory contains a script, `run_funsd_cord.py`, that can be used to fine-tune (or evaluate) LayoutLMv3 on form understanding datasets, such as [FUNSD](https://guillaumejaume.github.io/FUNSD/) and [CORD](https://github.com/clovaai/cord).\n\nThe script `run_funsd_cord.py` leverages the \ud83e\udd17 Datasets library and the Trainer API. You can easily customize it to your needs.\n\n## Fine-tuning on FUNSD\n\nFine-tuning LayoutLMv3 for token classification on [FUNSD](https://guillaumejaume.github.io/FUNSD/) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name funsd \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 1e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-funsd\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd. By specifying the `push_to_hub` flag, the model gets uploaded automatically to the hub (regularly), together with a model card, which includes metrics such as precision, recall and F1. Note that you can easily update the model card, as it's just a README file of the respective repo on the hub.\n\nThere's also the \"Training metrics\" [tab](https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd/tensorboard), which shows Tensorboard logs over the course of training. Pretty neat, huh?\n\n## Fine-tuning on CORD\n\nFine-tuning LayoutLMv3 for token classification on [CORD](https://github.com/clovaai/cord) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name cord \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 5e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-cord\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-cord. Note that a model card gets generated automatically in case you specify the `push_to_hub` flag.\n--New Chunk--\n[Created at: 2025-03-24 13:16:13]\n=predictions, references=references)\n>>> results\n{'exact_match': 100.0, 'f1': 100.0}\n```\n\nYou can find examples of dataset structures by consulting the \"Dataset Preview\" function or the dataset card for a given dataset, and you can see how to use its dedicated evaluation function based on the metric card."
        }
    },
    {
        "sample_idx": 127,
        "question": "How many epochs did the model train for?",
        "answer": "100",
        "rag_answer": "The model trained for a maximum of 1000 steps, with an evaluation strategy of steps and an evaluation step of 100. The number of epochs is not explicitly specified. However, it can be calculated based on the dataset size and batch size.",
        "rag_score": 3,
        "rag_feedback": "The system's response is somewhat correct, accurate, and factual. It provides a detailed explanation of how to choose a metric for a task, including generic metrics, task-specific metrics, and dataset-specific metrics. However, it does not directly answer the question of how many epochs the model trained for, which is the main question being asked.",
        "rag_context": {
            "kg_context": "-----Entities-----\n    ```csv\n    id,\tentity,\ttype,\tdescription,\trankcreated_at\n1,\tMachine Learning,category,Machine Learning is a field of study that involves training models to make predictions.,5,2025-03-24 13:18:20\n2,\tModel,category,Model refers to a machine learning model being evaluated.,3,2025-03-24 13:18:20\n3,\tKeras,category,Keras is a high-level neural networks API, used for building and training neural networks.<SEP>Keras is a machine learning framework that uses XLA for optimization.,2,2025-03-24 13:18:20\n4,\tXLA,technology,XLA is a technology that compiles TensorFlow graphs into executable code for various platforms.<SEP>XLA is an optimizing compiler used by TensorFlow and JAX to improve performance.<SEP>XLA is an optimizing compiler, used by both TensorFlow and JAX to optimize computations.,6,2025-03-24 13:18:20\n5,\tTensorFlow,category,TensorFlow is a machine learning framework that uses XLA as an optimizing compiler.<SEP>TensorFlow is a software framework used for building and training neural networks.<SEP>TensorFlow is an open-source machine learning framework.,3,2025-03-24 13:18:20\n6,\tNeural Networks,category,Neural Networks are a type of machine learning model used for various tasks such as image recognition and natural language processing.,0,UNKNOWN\n7,\tMachine Learning,category,Machine Learning is a field of study that involves training models to make predictions.,5,UNKNOWN\n8,\taccuracy,category,accuracy is a category of evaluation metrics for machine learning models.,1,UNKNOWN\n    ```\n    -----Relationships-----\n    ```csv\n    id,\tsource,\ttarget,\tdescription,\tkeywords,\tweight,\trank,\tcreated_at\n1,\tMachine Learning,Model,Machine Learning involves training models to make predictions.,field of study, model training,9.0,8,2025-03-24 13:16:48\n2,\tKeras,XLA,Keras uses XLA for optimization.,compiler, performance optimization,8.0,8,2025-03-24 13:18:20\n3,\tKeras,TensorFlow,TensorFlow uses Keras as a high-level neural networks API.,API integration, neural networks,16.0,5,2025-03-24 13:18:20\n4,\tMachine Learning,Model,Machine Learning involves training models to make predictions.,field of study, model training,9.0,8,UNKNOWN\n5,\tMachine Learning,accuracy,accuracy is a metric used to evaluate machine learning models.,evaluation metric, task,9.0,6,UNKNOWN\n6,\tMachine Learning,precision,precision is a metric used to evaluate machine learning models.,evaluation metric, task,9.0,6,UNKNOWN\n7,\tMachine Learning,perplexity,perplexity is a metric used to evaluate machine learning models.,evaluation metric, task,9.0,6,UNKNOWN\n8,\tMachine Learning,Papers With Code,Papers With Code provides a platform for tracking machine learning papers and their corresponding code.,research platform, machine learning,8.0,6,UNKNOWN\n    ```\n    -----Sources-----\n    ```csv\n    id,\tcontent\n1,\t=predictions, references=references)\n>>> results\n{'exact_match': 100.0, 'f1': 100.0}\n```\n\nYou can find examples of dataset structures by consulting the \"Dataset Preview\" function or the dataset card for a given dataset, and you can see how to use its dedicated evaluation function based on the metric card.\n2,\t(for example, a v3-32), your TPU fleet is referred to as a **pod slice.**\n\nWhen you access a free TPU via Colab, you generally get a single v2-8 TPU.\n\n### I keep hearing about this XLA thing. What\u2019s XLA, and how does it relate to TPUs?\n\nXLA is an optimizing compiler, used by both TensorFlow and JAX. In JAX it is the only compiler, whereas in TensorFlow it is optional (but mandatory on TPU!). The easiest way to enable it when training a Keras model is to pass the argument `jit_compile=True` to `model.compile()`. If you don\u2019t get any errors and performance is good, that\u2019s a great sign that you\u2019re ready to move to TPU!\n\nDebugging on TPU is generally a bit harder than on CPU/GPU, so we recommend getting your code running on CPU/GPU with XLA first before trying it on TPU. You don\u2019t have to train for long, of course - just for a few steps to make sure that your model and data pipeline are working like you expect them to.\n\n<Tip>\n\nXLA compiled code is usually faster - so even if you\u2019re not planning to run on TPU, adding `jit_compile=True` can improve your performance. Be sure to note the caveats below about XLA compatibility, though!\n\n</Tip>\n\n<Tip warning={true}>\n\n**Tip born of painful experience:** Although using `jit_compile=True` is a good way to get a speed boost and test if your CPU/GPU code is XLA-compatible, it can actually cause a lot of problems if you leave it in when actually training on TPU. XLA compilation will happen implicitly on TPU, so remember to remove that line before actually running your code on a TPU!\n\n</Tip>\n\n### How do I make my model XLA compatible?\n\nIn many cases, your code is probably XLA-compatible already! However, there are a few things that work in normal TensorFlow that don\u2019t work in XLA. We\u2019ve distilled them into three core rules below:\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** We\u2019ve put a lot of effort into rewriting our TensorFlow models and loss functions to be XLA-compatible. Our models and loss functions generally obey rule #1 and #2 by default, so you can skip over them if you\u2019re using `transformers` models. Don\u2019t forget about these rules when writing your own models and loss functions, though!\n\n</Tip>\n\n#### XLA Rule #1: Your code cannot have \u201cdata-dependent conditionals\u201d\n\nWhat that means is that any `if` statement cannot depend on values inside a `tf.Tensor`. For example, this code block cannot be compiled with XLA!\n\n```python\nif tf.reduce_sum(tensor) > 10:\n    tensor = tensor / 2.0\n```\n\nThis might seem very restrictive at first, but most neural net code doesn\u2019t need to do this. You can often get around this restriction by using `tf.cond` (see the documentation [here](https://www.tensorflow.org/api_docs/python/tf/cond)) or by removing the conditional and finding a clever math trick with indicator variables instead, like so:\n\n```python\nsum_over_10 = tf.cast(tf.reduce_sum(tensor) > 10, tf.float32)\ntensor = tensor / (1.0 + sum_over_10)\n```\n\nThis code has exactly the same effect as the code above, but by avoiding a conditional, we ensure it will compile with XLA without problems!\n\n#### XLA Rule #2: Your code cannot have \u201cdata-dependent shapes\u201d\n\nWhat this means is that the shape of all of the `tf.Tensor` objects in your code cannot depend on their values. For example, the function `tf.unique` cannot be compiled with XLA, because it returns a `tensor` containing one instance of each unique value in the input. The shape of this output will obviously be different depending on how repetitive the input `Tensor` was, and so XLA refuses to handle it!\n\nIn general, most neural network code obeys rule #2 by default. However, there are a few common cases where it becomes a problem. One very common one is when you use **label masking**, setting your labels to a negative value to indicate that those positions should be ignored when computing the loss. If you look at NumPy or PyTorch loss functions that support label masking, you will often see code like this that uses [boolean indexing](https://numpy.org/doc/stable/user/basics.indexing.html#boolean-array-indexing):\n\n```python\nlabel_mask = labels >= 0\nmasked_outputs = outputs[label_mask]\nmasked_labels = labels[label_mask]\nloss = compute_loss(masked_outputs, masked_labels)\nmean_loss = torch.mean(loss)\n```\n\nThis code is totally fine in NumPy or PyTorch, but it breaks in XLA! Why? Because the shape of `masked_outputs` and `masked_labels` depends on how many positions are masked - that makes it a **data-dependent shape.** However, just like for rule #1, we can often rewrite this code to yield exactly the same output without any data-dependent shapes.\n\n```python\nlabel_mask = tf.cast(labels >= 0, tf.float32)\nloss = compute_loss(outputs, labels)\nloss = loss * label_mask  # Set negative label positions to 0\nmean_loss = tf.reduce_sum(loss) / tf.reduce_sum(label_mask)\n```\n\nHere, we avoid data-dependent shapes by computing the loss for every position, but zeroing out the masked positions in both the numerator and denominator when we calculate the mean, which yields exactly the same result as the first block while maintaining XLA compatibility. Note that we use the same trick as in rule #1 - converting a `tf.bool` to `\n3,\t!--Copyright 2023 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\nthe License. You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under the License is distributed on\nan \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n\n\u26a0\ufe0f Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be\nrendered properly in your Markdown viewer.\n\n-->\n\n# Training on TPU with TensorFlow\n\n<Tip>\n\nIf you don't need long explanations and just want TPU code samples to get started with, check out [our TPU example notebook!](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb)\n\n</Tip>\n\n### What is a TPU?\n\nA TPU is a **Tensor Processing Unit.** They are hardware designed by Google, which are used to greatly speed up the tensor computations within neural networks, much like GPUs. They can be used for both network training and inference. They are generally accessed through Google\u2019s cloud services, but small TPUs can also be accessed directly for free through Google Colab and Kaggle Kernels.\n\nBecause [all TensorFlow models in \ud83e\udd17 Transformers are Keras models](https://huggingface.co/blog/tensorflow-philosophy), most of the methods in this document are generally applicable to TPU training for any Keras model! However, there are a few points that are specific to the HuggingFace ecosystem (hug-o-system?) of Transformers and Datasets, and we\u2019ll make sure to flag them up when we get to them.\n\n### What kinds of TPU are available?\n\nNew users are often very confused by the range of TPUs, and the different ways to access them. The first key distinction to understand is the difference between **TPU Nodes** and **TPU VMs.**\n\nWhen you use a **TPU Node**, you are effectively indirectly accessing a remote TPU. You will need a separate VM, which will initialize your network and data pipeline and then forward them to the remote node. When you use a TPU on Google Colab, you are accessing it in the **TPU Node** style.\n\nUsing TPU Nodes can have some quite unexpected behaviour for people who aren\u2019t used to them! In particular, because the TPU is located on a physically different system to the machine you\u2019re running your Python code on, your data cannot be local to your machine - any data pipeline that loads from your machine\u2019s internal storage will totally fail! Instead, data must be stored in Google Cloud Storage where your data pipeline can still access it, even when the pipeline is running on the remote TPU node.\n\n<Tip>\n\nIf you can fit all your data in memory as `np.ndarray` or `tf.Tensor`, then you can `fit()` on that data even when using Colab or a TPU Node, without needing to upload it to Google Cloud Storage.\n\n</Tip>\n\n<Tip>\n\n**\ud83e\udd17Specific Hugging Face Tip\ud83e\udd17:** The methods `Dataset.to_tf_dataset()` and its higher-level wrapper `model.prepare_tf_dataset()` , which you will see throughout our TF code examples, will both fail on a TPU Node. The reason for this is that even though they create a `tf.data.Dataset` it is not a \u201cpure\u201d `tf.data` pipeline and uses `tf.numpy_function` or `Dataset.from_generator()` to stream data from the underlying HuggingFace `Dataset`. This HuggingFace `Dataset` is backed by data that is on a local disc and which the remote TPU Node will not be able to read.\n\n</Tip>\n\nThe second way to access a TPU is via a **TPU VM.** When using a TPU VM, you connect directly to the machine that the TPU is attached to, much like training on a GPU VM. TPU VMs are generally easier to work with, particularly when it comes to your data pipeline. All of the above warnings do not apply to TPU VMs!\n\nThis is an opinionated document, so here\u2019s our opinion: **Avoid using TPU Node if possible.** It is more confusing and more difficult to debug than TPU VMs. It is also likely to be unsupported in future - Google\u2019s latest TPU, TPUv4, can only be accessed as a TPU VM, which suggests that TPU Nodes are increasingly going to become a \u201clegacy\u201d access method. However, we understand that the only free TPU access is on Colab and Kaggle Kernels, which uses TPU Node - so we\u2019ll try to explain how to handle it if you have to! Check the [TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) for code samples that explain this in more detail.\n\n### What sizes of TPU are available?\n\nA single TPU (a v2-8/v3-8/v4-8) runs 8 replicas. TPUs exist in **pods** that can run hundreds or thousands of replicas simultaneously. When you use more than a single TPU but less than a whole pod (for example, a v3-32), your TPU fleet is referred to as a **pod slice.**\n\nWhen you access a free TPU via Colab, you generally get a single v2-8 TPU.\n\n### I keep hearing about this XLA thing. What\u2019s XLA, and how does it relate to TPUs?\n\nXLA is an optimizing compiler, used by both TensorFlow and JAX. In JAX it is the only compiler, whereas in TensorFlow it is optional\n4,\tChoosing a metric for your task\n\n**So you've trained your model and want to see how well it\u2019s doing on a dataset of your choice. Where do you start?**\n\nThere is no \u201cone size fits all\u201d approach to choosing an evaluation metric, but some good guidelines to keep in mind are:\n\n## Categories of metrics\n\nThere are 3 high-level categories of metrics:\n\n1. *Generic metrics*, which can be applied to a variety of situations and datasets, such as precision and accuracy.\n2. *Task-specific metrics*, which are limited to a given task, such as Machine Translation (often evaluated using metrics [BLEU](https://huggingface.co/metrics/bleu) or [ROUGE](https://huggingface.co/metrics/rouge)) or Named Entity Recognition (often evaluated with [seqeval](https://huggingface.co/metrics/seqeval)).\n3. *Dataset-specific metrics*, which aim to measure model performance on specific benchmarks: for instance, the [GLUE benchmark](https://huggingface.co/datasets/glue) has a dedicated [evaluation metric](https://huggingface.co/metrics/glue).\n\nLet's look at each of these three cases:\n\n### Generic metrics\n\nMany of the metrics used in the Machine Learning community are quite generic and can be applied in a variety of tasks and datasets.\n\nThis is the case for metrics like [accuracy](https://huggingface.co/metrics/accuracy) and [precision](https://huggingface.co/metrics/precision), which can be used for evaluating labeled (supervised) datasets, as well as [perplexity](https://huggingface.co/metrics/perplexity), which can be used for evaluating different kinds of (unsupervised) generative tasks.\n\nTo see the input structure of a given metric, you can look at its metric card. For example, in the case of [precision](https://huggingface.co/metrics/precision), the format is:\n```\n>>> precision_metric = evaluate.load(\"precision\")\n>>> results = precision_metric.compute(references=[0, 1], predictions=[0, 1])\n>>> print(results)\n{'precision': 1.0}\n```\n\n### Task-specific metrics\n\nPopular ML tasks like Machine Translation and Named Entity Recognition have specific metrics that can be used to compare models. For example, a series of different metrics have been proposed for text generation, ranging from [BLEU](https://huggingface.co/metrics/bleu) and its derivatives such as [GoogleBLEU](https://huggingface.co/metrics/google_bleu) and [GLEU](https://huggingface.co/metrics/gleu), but also [ROUGE](https://huggingface.co/metrics/rouge), [MAUVE](https://huggingface.co/metrics/mauve), etc.\n\nYou can find the right metric for your task by:\n\n- **Looking at the [Task pages](https://huggingface.co/tasks)** to see what metrics can be used for evaluating models for a given task.\n- **Checking out leaderboards** on sites like [Papers With Code](https://paperswithcode.com/) (you can search by task and by dataset).\n-  **Reading the metric cards** for the relevant metrics and see which ones are a good fit for your use case. For example, see the [BLEU metric card](https://github.com/huggingface/evaluate/tree/main/metrics/bleu) or [SQuaD metric card](https://github.com/huggingface/evaluate/tree/main/metrics/squad).\n- **Looking at papers and blog posts** published on the topic and see what metrics they report. This can change over time, so try to pick papers from the last couple of years!\n\n### Dataset-specific metrics\n\nSome datasets have specific metrics associated with them -- this is especially in the case of popular benchmarks like [GLUE](https://huggingface.co/metrics/glue) and [SQuAD](https://huggingface.co/metrics/squad).\n\n<Tip warning={true}>\n\ud83d\udca1\nGLUE is actually a collection of different subsets on different tasks, so first you need to choose the one that corresponds to the NLI task, such as mnli, which is described as \u201ccrowdsourced collection of sentence pairs with textual entailment annotations\u201d\n</Tip>\n\n\nIf you are evaluating your model on a benchmark dataset like the ones mentioned above, you can use its dedicated evaluation metric. Make sure you respect the format that they require. For example, to evaluate your model on the [SQuAD](https://huggingface.co/datasets/squad) dataset, you need to feed the `question` and `context` into your model and return the `prediction_text`, which should be compared with the `references` (based on matching the `id` of the question) :\n\n```\n>>> from evaluate import load\n>>> squad_metric = load(\"squad\")\n>>> predictions = [{'prediction_text': '1976', 'id': '56e10a3be3433e1400422b22'}]\n>>> references = [{'answers': {'answer_start': [97], 'text': ['1976']}, 'id': '56e10a3be3433e1400422b22'}]\n>>> results = squad_metric.compute(predictions=predictions, references=references)\n>>> results\n{'exact_match': 100.0, 'f1': 100.0}\n```\n\nYou can find examples of dataset structures by consulting the \"Dataset Preview\" function or the dataset card for a given dataset, and you can see how to use its dedicated evaluation function based on the metric card.\n    ```",
            "vector_context": "[Created at: 2025-03-24 13:16:13]\nChoosing a metric for your task\n\n**So you've trained your model and want to see how well it\u2019s doing on a dataset of your choice. Where do you start?**\n\nThere is no \u201cone size fits all\u201d approach to choosing an evaluation metric, but some good guidelines to keep in mind are:\n\n## Categories of metrics\n\nThere are 3 high-level categories of metrics:\n\n1. *Generic metrics*, which can be applied to a variety of situations and datasets, such as precision and accuracy.\n2. *Task-specific metrics*, which are limited to a given task, such as Machine Translation (often evaluated using metrics [BLEU](https://huggingface.co/metrics/bleu) or [ROUGE](https://huggingface.co/metrics/rouge)) or Named Entity Recognition (often evaluated with [seqeval](https://huggingface.co/metrics/seqeval)).\n3. *Dataset-specific metrics*, which aim to measure model performance on specific benchmarks: for instance, the [GLUE benchmark](https://huggingface.co/datasets/glue) has a dedicated [evaluation metric](https://huggingface.co/metrics/glue).\n\nLet's look at each of these three cases:\n\n### Generic metrics\n\nMany of the metrics used in the Machine Learning community are quite generic and can be applied in a variety of tasks and datasets.\n\nThis is the case for metrics like [accuracy](https://huggingface.co/metrics/accuracy) and [precision](https://huggingface.co/metrics/precision), which can be used for evaluating labeled (supervised) datasets, as well as [perplexity](https://huggingface.co/metrics/perplexity), which can be used for evaluating different kinds of (unsupervised) generative tasks.\n\nTo see the input structure of a given metric, you can look at its metric card. For example, in the case of [precision](https://huggingface.co/metrics/precision), the format is:\n```\n>>> precision_metric = evaluate.load(\"precision\")\n>>> results = precision_metric.compute(references=[0, 1], predictions=[0, 1])\n>>> print(results)\n{'precision': 1.0}\n```\n\n### Task-specific metrics\n\nPopular ML tasks like Machine Translation and Named Entity Recognition have specific metrics that can be used to compare models. For example, a series of different metrics have been proposed for text generation, ranging from [BLEU](https://huggingface.co/metrics/bleu) and its derivatives such as [GoogleBLEU](https://huggingface.co/metrics/google_bleu) and [GLEU](https://huggingface.co/metrics/gleu), but also [ROUGE](https://huggingface.co/metrics/rouge), [MAUVE](https://huggingface.co/metrics/mauve), etc.\n\nYou can find the right metric for your task by:\n\n- **Looking at the [Task pages](https://huggingface.co/tasks)** to see what metrics can be used for evaluating models for a given task.\n- **Checking out leaderboards** on sites like [Papers With Code](https://paperswithcode.com/) (you can search by task and by dataset).\n-  **Reading the metric cards** for the relevant metrics and see which ones are a good fit for your use case. For example, see the [BLEU metric card](https://github.com/huggingface/evaluate/tree/main/metrics/bleu) or [SQuaD metric card](https://github.com/huggingface/evaluate/tree/main/metrics/squad).\n- **Looking at papers and blog posts** published on the topic and see what metrics they report. This can change over time, so try to pick papers from the last couple of years!\n\n### Dataset-specific metrics\n\nSome datasets have specific metrics associated with them -- this is especially in the case of popular benchmarks like [GLUE](https://huggingface.co/metrics/glue) and [SQuAD](https://huggingface.co/metrics/squad).\n\n<Tip warning={true}>\n\ud83d\udca1\nGLUE is actually a collection of different subsets on different tasks, so first you need to choose the one that corresponds to the NLI task, such as mnli, which is described as \u201ccrowdsourced collection of sentence pairs with textual entailment annotations\u201d\n</Tip>\n\n\nIf you are evaluating your model on a benchmark dataset like the ones mentioned above, you can use its dedicated evaluation metric. Make sure you respect the format that they require. For example, to evaluate your model on the [SQuAD](https://huggingface.co/datasets/squad) dataset, you need to feed the `question` and `context` into your model and return the `prediction_text`, which should be compared with the `references` (based on matching the `id` of the question) :\n\n```\n>>> from evaluate import load\n>>> squad_metric = load(\"squad\")\n>>> predictions = [{'prediction_text': '1976', 'id': '56e10a3be3433e1400422b22'}]\n>>> references = [{'answers': {'answer_start': [97], 'text': ['1976']}, 'id': '56e10a3be3433e1400422b22'}]\n>>> results = squad_metric.compute(predictions=predictions, references=references)\n>>> results\n{'exact_match': 100.0, 'f1': 100.0}\n```\n\nYou can find examples of dataset structures by consulting the \"Dataset Preview\" function or the dataset card for a given dataset, and you can see how to use its dedicated evaluation function based on the metric card.\n--New Chunk--\n[Created at: 2025-03-24 13:19:17]\n!---\nCopyright 2022 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n-->\n\n# Token classification with LayoutLMv3 (PyTorch version)\n\nThis directory contains a script, `run_funsd_cord.py`, that can be used to fine-tune (or evaluate) LayoutLMv3 on form understanding datasets, such as [FUNSD](https://guillaumejaume.github.io/FUNSD/) and [CORD](https://github.com/clovaai/cord).\n\nThe script `run_funsd_cord.py` leverages the \ud83e\udd17 Datasets library and the Trainer API. You can easily customize it to your needs.\n\n## Fine-tuning on FUNSD\n\nFine-tuning LayoutLMv3 for token classification on [FUNSD](https://guillaumejaume.github.io/FUNSD/) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name funsd \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 1e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-funsd\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd. By specifying the `push_to_hub` flag, the model gets uploaded automatically to the hub (regularly), together with a model card, which includes metrics such as precision, recall and F1. Note that you can easily update the model card, as it's just a README file of the respective repo on the hub.\n\nThere's also the \"Training metrics\" [tab](https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd/tensorboard), which shows Tensorboard logs over the course of training. Pretty neat, huh?\n\n## Fine-tuning on CORD\n\nFine-tuning LayoutLMv3 for token classification on [CORD](https://github.com/clovaai/cord) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name cord \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 5e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-cord\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-cord. Note that a model card gets generated automatically in case you specify the `push_to_hub` flag.\n--New Chunk--\n[Created at: 2025-03-24 13:16:13]\n=predictions, references=references)\n>>> results\n{'exact_match': 100.0, 'f1': 100.0}\n```\n\nYou can find examples of dataset structures by consulting the \"Dataset Preview\" function or the dataset card for a given dataset, and you can see how to use its dedicated evaluation function based on the metric card."
        }
    },
    {
        "sample_idx": 128,
        "question": "How many layers does the model have?",
        "answer": "50",
        "rag_answer": "The provided Data Sources do not specify the number of layers in the model. The information available is related to machine learning concepts, XLA, TPUs, and model evaluation metrics, but it does not provide details about a specific model's architecture.",
        "rag_score": 1,
        "rag_feedback": "The system's response is completely incorrect, inaccurate, and/or not factual. The question asks about the number of layers in a model, but the system's response talks about machine learning concepts, XLA, TPUs, and model evaluation metrics, which are unrelated to the question.",
        "rag_context": {
            "kg_context": "-----Entities-----\n    ```csv\n    id,\tentity,\ttype,\tdescription,\trankcreated_at\n1,\tMachine Learning,category,Machine Learning is a field of study that involves training models to make predictions.,5,2025-03-24 13:18:20\n2,\tModel,category,Model refers to a machine learning model being evaluated.,3,2025-03-24 13:18:20\n3,\tKeras,category,Keras is a high-level neural networks API, used for building and training neural networks.<SEP>Keras is a machine learning framework that uses XLA for optimization.,2,2025-03-24 13:18:20\n4,\tXLA,technology,XLA is a technology that compiles TensorFlow graphs into executable code for various platforms.<SEP>XLA is an optimizing compiler used by TensorFlow and JAX to improve performance.<SEP>XLA is an optimizing compiler, used by both TensorFlow and JAX to optimize computations.,6,2025-03-24 13:18:20\n5,\tTensorFlow,category,TensorFlow is a machine learning framework that uses XLA as an optimizing compiler.<SEP>TensorFlow is a software framework used for building and training neural networks.<SEP>TensorFlow is an open-source machine learning framework.,3,2025-03-24 13:18:20\n6,\tNeural Networks,category,Neural Networks are a type of machine learning model used for various tasks such as image recognition and natural language processing.,0,UNKNOWN\n7,\tModel,category,Model refers to a machine learning model being evaluated.,3,UNKNOWN\n8,\tperplexity,category,perplexity is a category of evaluation metrics for machine learning models.,1,UNKNOWN\n    ```\n    -----Relationships-----\n    ```csv\n    id,\tsource,\ttarget,\tdescription,\tkeywords,\tweight,\trank,\tcreated_at\n1,\tMachine Learning,Model,Machine Learning involves training models to make predictions.,field of study, model training,9.0,8,2025-03-24 13:16:48\n2,\tKeras,XLA,Keras uses XLA for optimization.,compiler, performance optimization,8.0,8,2025-03-24 13:18:20\n3,\tKeras,TensorFlow,TensorFlow uses Keras as a high-level neural networks API.,API integration, neural networks,16.0,5,2025-03-24 13:18:20\n4,\tMachine Learning,Model,Machine Learning involves training models to make predictions.,field of study, model training,9.0,8,UNKNOWN\n5,\tMachine Learning,perplexity,perplexity is a metric used to evaluate machine learning models.,evaluation metric, task,9.0,6,UNKNOWN\n6,\tEvaluation Function,Model,The evaluation function is used to assess the performance of the model.,model evaluation, performance assessment,18.0,5,UNKNOWN\n7,\tModel,Predictions,The model makes predictions based on the input data.,model output, predictions,8.0,5,UNKNOWN\n    ```\n    -----Sources-----\n    ```csv\n    id,\tcontent\n1,\t=predictions, references=references)\n>>> results\n{'exact_match': 100.0, 'f1': 100.0}\n```\n\nYou can find examples of dataset structures by consulting the \"Dataset Preview\" function or the dataset card for a given dataset, and you can see how to use its dedicated evaluation function based on the metric card.\n2,\t(for example, a v3-32), your TPU fleet is referred to as a **pod slice.**\n\nWhen you access a free TPU via Colab, you generally get a single v2-8 TPU.\n\n### I keep hearing about this XLA thing. What\u2019s XLA, and how does it relate to TPUs?\n\nXLA is an optimizing compiler, used by both TensorFlow and JAX. In JAX it is the only compiler, whereas in TensorFlow it is optional (but mandatory on TPU!). The easiest way to enable it when training a Keras model is to pass the argument `jit_compile=True` to `model.compile()`. If you don\u2019t get any errors and performance is good, that\u2019s a great sign that you\u2019re ready to move to TPU!\n\nDebugging on TPU is generally a bit harder than on CPU/GPU, so we recommend getting your code running on CPU/GPU with XLA first before trying it on TPU. You don\u2019t have to train for long, of course - just for a few steps to make sure that your model and data pipeline are working like you expect them to.\n\n<Tip>\n\nXLA compiled code is usually faster - so even if you\u2019re not planning to run on TPU, adding `jit_compile=True` can improve your performance. Be sure to note the caveats below about XLA compatibility, though!\n\n</Tip>\n\n<Tip warning={true}>\n\n**Tip born of painful experience:** Although using `jit_compile=True` is a good way to get a speed boost and test if your CPU/GPU code is XLA-compatible, it can actually cause a lot of problems if you leave it in when actually training on TPU. XLA compilation will happen implicitly on TPU, so remember to remove that line before actually running your code on a TPU!\n\n</Tip>\n\n### How do I make my model XLA compatible?\n\nIn many cases, your code is probably XLA-compatible already! However, there are a few things that work in normal TensorFlow that don\u2019t work in XLA. We\u2019ve distilled them into three core rules below:\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** We\u2019ve put a lot of effort into rewriting our TensorFlow models and loss functions to be XLA-compatible. Our models and loss functions generally obey rule #1 and #2 by default, so you can skip over them if you\u2019re using `transformers` models. Don\u2019t forget about these rules when writing your own models and loss functions, though!\n\n</Tip>\n\n#### XLA Rule #1: Your code cannot have \u201cdata-dependent conditionals\u201d\n\nWhat that means is that any `if` statement cannot depend on values inside a `tf.Tensor`. For example, this code block cannot be compiled with XLA!\n\n```python\nif tf.reduce_sum(tensor) > 10:\n    tensor = tensor / 2.0\n```\n\nThis might seem very restrictive at first, but most neural net code doesn\u2019t need to do this. You can often get around this restriction by using `tf.cond` (see the documentation [here](https://www.tensorflow.org/api_docs/python/tf/cond)) or by removing the conditional and finding a clever math trick with indicator variables instead, like so:\n\n```python\nsum_over_10 = tf.cast(tf.reduce_sum(tensor) > 10, tf.float32)\ntensor = tensor / (1.0 + sum_over_10)\n```\n\nThis code has exactly the same effect as the code above, but by avoiding a conditional, we ensure it will compile with XLA without problems!\n\n#### XLA Rule #2: Your code cannot have \u201cdata-dependent shapes\u201d\n\nWhat this means is that the shape of all of the `tf.Tensor` objects in your code cannot depend on their values. For example, the function `tf.unique` cannot be compiled with XLA, because it returns a `tensor` containing one instance of each unique value in the input. The shape of this output will obviously be different depending on how repetitive the input `Tensor` was, and so XLA refuses to handle it!\n\nIn general, most neural network code obeys rule #2 by default. However, there are a few common cases where it becomes a problem. One very common one is when you use **label masking**, setting your labels to a negative value to indicate that those positions should be ignored when computing the loss. If you look at NumPy or PyTorch loss functions that support label masking, you will often see code like this that uses [boolean indexing](https://numpy.org/doc/stable/user/basics.indexing.html#boolean-array-indexing):\n\n```python\nlabel_mask = labels >= 0\nmasked_outputs = outputs[label_mask]\nmasked_labels = labels[label_mask]\nloss = compute_loss(masked_outputs, masked_labels)\nmean_loss = torch.mean(loss)\n```\n\nThis code is totally fine in NumPy or PyTorch, but it breaks in XLA! Why? Because the shape of `masked_outputs` and `masked_labels` depends on how many positions are masked - that makes it a **data-dependent shape.** However, just like for rule #1, we can often rewrite this code to yield exactly the same output without any data-dependent shapes.\n\n```python\nlabel_mask = tf.cast(labels >= 0, tf.float32)\nloss = compute_loss(outputs, labels)\nloss = loss * label_mask  # Set negative label positions to 0\nmean_loss = tf.reduce_sum(loss) / tf.reduce_sum(label_mask)\n```\n\nHere, we avoid data-dependent shapes by computing the loss for every position, but zeroing out the masked positions in both the numerator and denominator when we calculate the mean, which yields exactly the same result as the first block while maintaining XLA compatibility. Note that we use the same trick as in rule #1 - converting a `tf.bool` to `\n3,\t!--Copyright 2023 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\nthe License. You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under the License is distributed on\nan \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n\n\u26a0\ufe0f Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be\nrendered properly in your Markdown viewer.\n\n-->\n\n# Training on TPU with TensorFlow\n\n<Tip>\n\nIf you don't need long explanations and just want TPU code samples to get started with, check out [our TPU example notebook!](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb)\n\n</Tip>\n\n### What is a TPU?\n\nA TPU is a **Tensor Processing Unit.** They are hardware designed by Google, which are used to greatly speed up the tensor computations within neural networks, much like GPUs. They can be used for both network training and inference. They are generally accessed through Google\u2019s cloud services, but small TPUs can also be accessed directly for free through Google Colab and Kaggle Kernels.\n\nBecause [all TensorFlow models in \ud83e\udd17 Transformers are Keras models](https://huggingface.co/blog/tensorflow-philosophy), most of the methods in this document are generally applicable to TPU training for any Keras model! However, there are a few points that are specific to the HuggingFace ecosystem (hug-o-system?) of Transformers and Datasets, and we\u2019ll make sure to flag them up when we get to them.\n\n### What kinds of TPU are available?\n\nNew users are often very confused by the range of TPUs, and the different ways to access them. The first key distinction to understand is the difference between **TPU Nodes** and **TPU VMs.**\n\nWhen you use a **TPU Node**, you are effectively indirectly accessing a remote TPU. You will need a separate VM, which will initialize your network and data pipeline and then forward them to the remote node. When you use a TPU on Google Colab, you are accessing it in the **TPU Node** style.\n\nUsing TPU Nodes can have some quite unexpected behaviour for people who aren\u2019t used to them! In particular, because the TPU is located on a physically different system to the machine you\u2019re running your Python code on, your data cannot be local to your machine - any data pipeline that loads from your machine\u2019s internal storage will totally fail! Instead, data must be stored in Google Cloud Storage where your data pipeline can still access it, even when the pipeline is running on the remote TPU node.\n\n<Tip>\n\nIf you can fit all your data in memory as `np.ndarray` or `tf.Tensor`, then you can `fit()` on that data even when using Colab or a TPU Node, without needing to upload it to Google Cloud Storage.\n\n</Tip>\n\n<Tip>\n\n**\ud83e\udd17Specific Hugging Face Tip\ud83e\udd17:** The methods `Dataset.to_tf_dataset()` and its higher-level wrapper `model.prepare_tf_dataset()` , which you will see throughout our TF code examples, will both fail on a TPU Node. The reason for this is that even though they create a `tf.data.Dataset` it is not a \u201cpure\u201d `tf.data` pipeline and uses `tf.numpy_function` or `Dataset.from_generator()` to stream data from the underlying HuggingFace `Dataset`. This HuggingFace `Dataset` is backed by data that is on a local disc and which the remote TPU Node will not be able to read.\n\n</Tip>\n\nThe second way to access a TPU is via a **TPU VM.** When using a TPU VM, you connect directly to the machine that the TPU is attached to, much like training on a GPU VM. TPU VMs are generally easier to work with, particularly when it comes to your data pipeline. All of the above warnings do not apply to TPU VMs!\n\nThis is an opinionated document, so here\u2019s our opinion: **Avoid using TPU Node if possible.** It is more confusing and more difficult to debug than TPU VMs. It is also likely to be unsupported in future - Google\u2019s latest TPU, TPUv4, can only be accessed as a TPU VM, which suggests that TPU Nodes are increasingly going to become a \u201clegacy\u201d access method. However, we understand that the only free TPU access is on Colab and Kaggle Kernels, which uses TPU Node - so we\u2019ll try to explain how to handle it if you have to! Check the [TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) for code samples that explain this in more detail.\n\n### What sizes of TPU are available?\n\nA single TPU (a v2-8/v3-8/v4-8) runs 8 replicas. TPUs exist in **pods** that can run hundreds or thousands of replicas simultaneously. When you use more than a single TPU but less than a whole pod (for example, a v3-32), your TPU fleet is referred to as a **pod slice.**\n\nWhen you access a free TPU via Colab, you generally get a single v2-8 TPU.\n\n### I keep hearing about this XLA thing. What\u2019s XLA, and how does it relate to TPUs?\n\nXLA is an optimizing compiler, used by both TensorFlow and JAX. In JAX it is the only compiler, whereas in TensorFlow it is optional\n4,\tChoosing a metric for your task\n\n**So you've trained your model and want to see how well it\u2019s doing on a dataset of your choice. Where do you start?**\n\nThere is no \u201cone size fits all\u201d approach to choosing an evaluation metric, but some good guidelines to keep in mind are:\n\n## Categories of metrics\n\nThere are 3 high-level categories of metrics:\n\n1. *Generic metrics*, which can be applied to a variety of situations and datasets, such as precision and accuracy.\n2. *Task-specific metrics*, which are limited to a given task, such as Machine Translation (often evaluated using metrics [BLEU](https://huggingface.co/metrics/bleu) or [ROUGE](https://huggingface.co/metrics/rouge)) or Named Entity Recognition (often evaluated with [seqeval](https://huggingface.co/metrics/seqeval)).\n3. *Dataset-specific metrics*, which aim to measure model performance on specific benchmarks: for instance, the [GLUE benchmark](https://huggingface.co/datasets/glue) has a dedicated [evaluation metric](https://huggingface.co/metrics/glue).\n\nLet's look at each of these three cases:\n\n### Generic metrics\n\nMany of the metrics used in the Machine Learning community are quite generic and can be applied in a variety of tasks and datasets.\n\nThis is the case for metrics like [accuracy](https://huggingface.co/metrics/accuracy) and [precision](https://huggingface.co/metrics/precision), which can be used for evaluating labeled (supervised) datasets, as well as [perplexity](https://huggingface.co/metrics/perplexity), which can be used for evaluating different kinds of (unsupervised) generative tasks.\n\nTo see the input structure of a given metric, you can look at its metric card. For example, in the case of [precision](https://huggingface.co/metrics/precision), the format is:\n```\n>>> precision_metric = evaluate.load(\"precision\")\n>>> results = precision_metric.compute(references=[0, 1], predictions=[0, 1])\n>>> print(results)\n{'precision': 1.0}\n```\n\n### Task-specific metrics\n\nPopular ML tasks like Machine Translation and Named Entity Recognition have specific metrics that can be used to compare models. For example, a series of different metrics have been proposed for text generation, ranging from [BLEU](https://huggingface.co/metrics/bleu) and its derivatives such as [GoogleBLEU](https://huggingface.co/metrics/google_bleu) and [GLEU](https://huggingface.co/metrics/gleu), but also [ROUGE](https://huggingface.co/metrics/rouge), [MAUVE](https://huggingface.co/metrics/mauve), etc.\n\nYou can find the right metric for your task by:\n\n- **Looking at the [Task pages](https://huggingface.co/tasks)** to see what metrics can be used for evaluating models for a given task.\n- **Checking out leaderboards** on sites like [Papers With Code](https://paperswithcode.com/) (you can search by task and by dataset).\n-  **Reading the metric cards** for the relevant metrics and see which ones are a good fit for your use case. For example, see the [BLEU metric card](https://github.com/huggingface/evaluate/tree/main/metrics/bleu) or [SQuaD metric card](https://github.com/huggingface/evaluate/tree/main/metrics/squad).\n- **Looking at papers and blog posts** published on the topic and see what metrics they report. This can change over time, so try to pick papers from the last couple of years!\n\n### Dataset-specific metrics\n\nSome datasets have specific metrics associated with them -- this is especially in the case of popular benchmarks like [GLUE](https://huggingface.co/metrics/glue) and [SQuAD](https://huggingface.co/metrics/squad).\n\n<Tip warning={true}>\n\ud83d\udca1\nGLUE is actually a collection of different subsets on different tasks, so first you need to choose the one that corresponds to the NLI task, such as mnli, which is described as \u201ccrowdsourced collection of sentence pairs with textual entailment annotations\u201d\n</Tip>\n\n\nIf you are evaluating your model on a benchmark dataset like the ones mentioned above, you can use its dedicated evaluation metric. Make sure you respect the format that they require. For example, to evaluate your model on the [SQuAD](https://huggingface.co/datasets/squad) dataset, you need to feed the `question` and `context` into your model and return the `prediction_text`, which should be compared with the `references` (based on matching the `id` of the question) :\n\n```\n>>> from evaluate import load\n>>> squad_metric = load(\"squad\")\n>>> predictions = [{'prediction_text': '1976', 'id': '56e10a3be3433e1400422b22'}]\n>>> references = [{'answers': {'answer_start': [97], 'text': ['1976']}, 'id': '56e10a3be3433e1400422b22'}]\n>>> results = squad_metric.compute(predictions=predictions, references=references)\n>>> results\n{'exact_match': 100.0, 'f1': 100.0}\n```\n\nYou can find examples of dataset structures by consulting the \"Dataset Preview\" function or the dataset card for a given dataset, and you can see how to use its dedicated evaluation function based on the metric card.\n    ```",
            "vector_context": "[Created at: 2025-03-24 13:19:17]\n!---\nCopyright 2022 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n-->\n\n# Token classification with LayoutLMv3 (PyTorch version)\n\nThis directory contains a script, `run_funsd_cord.py`, that can be used to fine-tune (or evaluate) LayoutLMv3 on form understanding datasets, such as [FUNSD](https://guillaumejaume.github.io/FUNSD/) and [CORD](https://github.com/clovaai/cord).\n\nThe script `run_funsd_cord.py` leverages the \ud83e\udd17 Datasets library and the Trainer API. You can easily customize it to your needs.\n\n## Fine-tuning on FUNSD\n\nFine-tuning LayoutLMv3 for token classification on [FUNSD](https://guillaumejaume.github.io/FUNSD/) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name funsd \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 1e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-funsd\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd. By specifying the `push_to_hub` flag, the model gets uploaded automatically to the hub (regularly), together with a model card, which includes metrics such as precision, recall and F1. Note that you can easily update the model card, as it's just a README file of the respective repo on the hub.\n\nThere's also the \"Training metrics\" [tab](https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd/tensorboard), which shows Tensorboard logs over the course of training. Pretty neat, huh?\n\n## Fine-tuning on CORD\n\nFine-tuning LayoutLMv3 for token classification on [CORD](https://github.com/clovaai/cord) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name cord \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 5e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-cord\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-cord. Note that a model card gets generated automatically in case you specify the `push_to_hub` flag.\n--New Chunk--\n[Created at: 2025-03-24 13:16:13]\n=predictions, references=references)\n>>> results\n{'exact_match': 100.0, 'f1': 100.0}\n```\n\nYou can find examples of dataset structures by consulting the \"Dataset Preview\" function or the dataset card for a given dataset, and you can see how to use its dedicated evaluation function based on the metric card.\n--New Chunk--\n[Created at: 2025-03-24 13:17:32]\n(for example, a v3-32), your TPU fleet is referred to as a **pod slice.**\n\nWhen you access a free TPU via Colab, you generally get a single v2-8 TPU.\n\n### I keep hearing about this XLA thing. What\u2019s XLA, and how does it relate to TPUs?\n\nXLA is an optimizing compiler, used by both TensorFlow and JAX. In JAX it is the only compiler, whereas in TensorFlow it is optional (but mandatory on TPU!). The easiest way to enable it when training a Keras model is to pass the argument `jit_compile=True` to `model.compile()`. If you don\u2019t get any errors and performance is good, that\u2019s a great sign that you\u2019re ready to move to TPU!\n\nDebugging on TPU is generally a bit harder than on CPU/GPU, so we recommend getting your code running on CPU/GPU with XLA first before trying it on TPU. You don\u2019t have to train for long, of course - just for a few steps to make sure that your model and data pipeline are working like you expect them to.\n\n<Tip>\n\nXLA compiled code is usually faster - so even if you\u2019re not planning to run on TPU, adding `jit_compile=True` can improve your performance. Be sure to note the caveats below about XLA compatibility, though!\n\n</Tip>\n\n<Tip warning={true}>\n\n**Tip born of painful experience:** Although using `jit_compile=True` is a good way to get a speed boost and test if your CPU/GPU code is XLA-compatible, it can actually cause a lot of problems if you leave it in when actually training on TPU. XLA compilation will happen implicitly on TPU, so remember to remove that line before actually running your code on a TPU!\n\n</Tip>\n\n### How do I make my model XLA compatible?\n\nIn many cases, your code is probably XLA-compatible already! However, there are a few things that work in normal TensorFlow that don\u2019t work in XLA. We\u2019ve distilled them into three core rules below:\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** We\u2019ve put a lot of effort into rewriting our TensorFlow models and loss functions to be XLA-compatible. Our models and loss functions generally obey rule #1 and #2 by default, so you can skip over them if you\u2019re using `transformers` models. Don\u2019t forget about these rules when writing your own models and loss functions, though!\n\n</Tip>\n\n#### XLA Rule #1: Your code cannot have \u201cdata-dependent conditionals\u201d\n\nWhat that means is that any `if` statement cannot depend on values inside a `tf.Tensor`. For example, this code block cannot be compiled with XLA!\n\n```python\nif tf.reduce_sum(tensor) > 10:\n    tensor = tensor / 2.0\n```\n\nThis might seem very restrictive at first, but most neural net code doesn\u2019t need to do this. You can often get around this restriction by using `tf.cond` (see the documentation [here](https://www.tensorflow.org/api_docs/python/tf/cond)) or by removing the conditional and finding a clever math trick with indicator variables instead, like so:\n\n```python\nsum_over_10 = tf.cast(tf.reduce_sum(tensor) > 10, tf.float32)\ntensor = tensor / (1.0 + sum_over_10)\n```\n\nThis code has exactly the same effect as the code above, but by avoiding a conditional, we ensure it will compile with XLA without problems!\n\n#### XLA Rule #2: Your code cannot have \u201cdata-dependent shapes\u201d\n\nWhat this means is that the shape of all of the `tf.Tensor` objects in your code cannot depend on their values. For example, the function `tf.unique` cannot be compiled with XLA, because it returns a `tensor` containing one instance of each unique value in the input. The shape of this output will obviously be different depending on how repetitive the input `Tensor` was, and so XLA refuses to handle it!\n\nIn general, most neural network code obeys rule #2 by default. However, there are a few common cases where it becomes a problem. One very common one is when you use **label masking**, setting your labels to a negative value to indicate that those positions should be ignored when computing the loss. If you look at NumPy or PyTorch loss functions that support label masking, you will often see code like this that uses [boolean indexing](https://numpy.org/doc/stable/user/basics.indexing.html#boolean-array-indexing):\n\n```python\nlabel_mask = labels >= 0\nmasked_outputs = outputs[label_mask]\nmasked_labels = labels[label_mask]\nloss = compute_loss(masked_outputs, masked_labels)\nmean_loss = torch.mean(loss)\n```\n\nThis code is totally fine in NumPy or PyTorch, but it breaks in XLA! Why? Because the shape of `masked_outputs` and `masked_labels` depends on how many positions are masked - that makes it a **data-dependent shape.** However, just like for rule #1, we can often rewrite this code to yield exactly the same output without any data-dependent shapes.\n\n```python\nlabel_mask = tf.cast(labels >= 0, tf.float32)\nloss = compute_loss(outputs, labels)\nloss = loss * label_mask  # Set negative label positions to 0\nmean_loss = tf.reduce_sum(loss) / tf.reduce_sum(label_mask)\n```\n\nHere, we avoid data-dependent shapes by computing the loss for every position, but zeroing out the masked positions in both the numerator and denominator when we calculate the mean, which yields exactly the same result as the first block while maintaining XLA compatibility. Note that we use the same trick as in rule #1 - converting a `tf.bool` to `"
        }
    },
    {
        "sample_idx": 129,
        "question": "What is the dropout rate of the model?",
        "answer": "0.2",
        "rag_answer": "The dropout rate of the model is not explicitly mentioned in the provided Data Sources. The Data Sources primarily focus on explaining the concepts of machine learning, evaluation metrics, and using TPUs with TensorFlow, but do not provide specific information about a particular model's architecture or hyperparameters, including the dropout rate.",
        "rag_score": 1,
        "rag_feedback": "The system's response does not provide a direct answer to the question about the dropout rate of the model. Instead, it provides a lengthy explanation about machine learning concepts, evaluation metrics, and how to use them. The response does not mention the dropout rate at all, making it completely incorrect and inaccurate.",
        "rag_context": {
            "kg_context": "-----Entities-----\n    ```csv\n    id,\tentity,\ttype,\tdescription,\trankcreated_at\n1,\tMachine Learning,category,Machine Learning is a field of study that involves training models to make predictions.,5,2025-03-24 13:16:48\n2,\tModel,category,Model refers to a machine learning model being evaluated.,3,2025-03-24 13:16:48\n3,\tprecision,category,precision is a category of evaluation metrics for machine learning models.,1,2025-03-24 13:16:48\n4,\taccuracy,category,accuracy is a category of evaluation metrics for machine learning models.,1,2025-03-24 13:16:48\n5,\tNeural Networks,category,Neural Networks are a type of machine learning model used for various tasks such as image recognition and natural language processing.,0,UNKNOWN\n6,\taccuracy,category,accuracy is a category of evaluation metrics for machine learning models.,1,UNKNOWN\n7,\tMachine Learning,category,Machine Learning is a field of study that involves training models to make predictions.,5,UNKNOWN\n    ```\n    -----Relationships-----\n    ```csv\n    id,\tsource,\ttarget,\tdescription,\tkeywords,\tweight,\trank,\tcreated_at\n1,\tMachine Learning,Model,Machine Learning involves training models to make predictions.,field of study, model training,9.0,8,2025-03-24 13:16:48\n2,\tMachine Learning,precision,precision is a metric used to evaluate machine learning models.,evaluation metric, task,9.0,6,2025-03-24 13:16:48\n3,\tMachine Learning,accuracy,accuracy is a metric used to evaluate machine learning models.,evaluation metric, task,9.0,6,2025-03-24 13:16:48\n4,\tMachine Learning,Model,Machine Learning involves training models to make predictions.,field of study, model training,9.0,8,UNKNOWN\n5,\tMachine Learning,accuracy,accuracy is a metric used to evaluate machine learning models.,evaluation metric, task,9.0,6,UNKNOWN\n6,\tMachine Learning,precision,precision is a metric used to evaluate machine learning models.,evaluation metric, task,9.0,6,UNKNOWN\n7,\tMachine Learning,perplexity,perplexity is a metric used to evaluate machine learning models.,evaluation metric, task,9.0,6,UNKNOWN\n8,\tMachine Learning,Papers With Code,Papers With Code provides a platform for tracking machine learning papers and their corresponding code.,research platform, machine learning,8.0,6,UNKNOWN\n    ```\n    -----Sources-----\n    ```csv\n    id,\tcontent\n1,\t=predictions, references=references)\n>>> results\n{'exact_match': 100.0, 'f1': 100.0}\n```\n\nYou can find examples of dataset structures by consulting the \"Dataset Preview\" function or the dataset card for a given dataset, and you can see how to use its dedicated evaluation function based on the metric card.\n2,\tChoosing a metric for your task\n\n**So you've trained your model and want to see how well it\u2019s doing on a dataset of your choice. Where do you start?**\n\nThere is no \u201cone size fits all\u201d approach to choosing an evaluation metric, but some good guidelines to keep in mind are:\n\n## Categories of metrics\n\nThere are 3 high-level categories of metrics:\n\n1. *Generic metrics*, which can be applied to a variety of situations and datasets, such as precision and accuracy.\n2. *Task-specific metrics*, which are limited to a given task, such as Machine Translation (often evaluated using metrics [BLEU](https://huggingface.co/metrics/bleu) or [ROUGE](https://huggingface.co/metrics/rouge)) or Named Entity Recognition (often evaluated with [seqeval](https://huggingface.co/metrics/seqeval)).\n3. *Dataset-specific metrics*, which aim to measure model performance on specific benchmarks: for instance, the [GLUE benchmark](https://huggingface.co/datasets/glue) has a dedicated [evaluation metric](https://huggingface.co/metrics/glue).\n\nLet's look at each of these three cases:\n\n### Generic metrics\n\nMany of the metrics used in the Machine Learning community are quite generic and can be applied in a variety of tasks and datasets.\n\nThis is the case for metrics like [accuracy](https://huggingface.co/metrics/accuracy) and [precision](https://huggingface.co/metrics/precision), which can be used for evaluating labeled (supervised) datasets, as well as [perplexity](https://huggingface.co/metrics/perplexity), which can be used for evaluating different kinds of (unsupervised) generative tasks.\n\nTo see the input structure of a given metric, you can look at its metric card. For example, in the case of [precision](https://huggingface.co/metrics/precision), the format is:\n```\n>>> precision_metric = evaluate.load(\"precision\")\n>>> results = precision_metric.compute(references=[0, 1], predictions=[0, 1])\n>>> print(results)\n{'precision': 1.0}\n```\n\n### Task-specific metrics\n\nPopular ML tasks like Machine Translation and Named Entity Recognition have specific metrics that can be used to compare models. For example, a series of different metrics have been proposed for text generation, ranging from [BLEU](https://huggingface.co/metrics/bleu) and its derivatives such as [GoogleBLEU](https://huggingface.co/metrics/google_bleu) and [GLEU](https://huggingface.co/metrics/gleu), but also [ROUGE](https://huggingface.co/metrics/rouge), [MAUVE](https://huggingface.co/metrics/mauve), etc.\n\nYou can find the right metric for your task by:\n\n- **Looking at the [Task pages](https://huggingface.co/tasks)** to see what metrics can be used for evaluating models for a given task.\n- **Checking out leaderboards** on sites like [Papers With Code](https://paperswithcode.com/) (you can search by task and by dataset).\n-  **Reading the metric cards** for the relevant metrics and see which ones are a good fit for your use case. For example, see the [BLEU metric card](https://github.com/huggingface/evaluate/tree/main/metrics/bleu) or [SQuaD metric card](https://github.com/huggingface/evaluate/tree/main/metrics/squad).\n- **Looking at papers and blog posts** published on the topic and see what metrics they report. This can change over time, so try to pick papers from the last couple of years!\n\n### Dataset-specific metrics\n\nSome datasets have specific metrics associated with them -- this is especially in the case of popular benchmarks like [GLUE](https://huggingface.co/metrics/glue) and [SQuAD](https://huggingface.co/metrics/squad).\n\n<Tip warning={true}>\n\ud83d\udca1\nGLUE is actually a collection of different subsets on different tasks, so first you need to choose the one that corresponds to the NLI task, such as mnli, which is described as \u201ccrowdsourced collection of sentence pairs with textual entailment annotations\u201d\n</Tip>\n\n\nIf you are evaluating your model on a benchmark dataset like the ones mentioned above, you can use its dedicated evaluation metric. Make sure you respect the format that they require. For example, to evaluate your model on the [SQuAD](https://huggingface.co/datasets/squad) dataset, you need to feed the `question` and `context` into your model and return the `prediction_text`, which should be compared with the `references` (based on matching the `id` of the question) :\n\n```\n>>> from evaluate import load\n>>> squad_metric = load(\"squad\")\n>>> predictions = [{'prediction_text': '1976', 'id': '56e10a3be3433e1400422b22'}]\n>>> references = [{'answers': {'answer_start': [97], 'text': ['1976']}, 'id': '56e10a3be3433e1400422b22'}]\n>>> results = squad_metric.compute(predictions=predictions, references=references)\n>>> results\n{'exact_match': 100.0, 'f1': 100.0}\n```\n\nYou can find examples of dataset structures by consulting the \"Dataset Preview\" function or the dataset card for a given dataset, and you can see how to use its dedicated evaluation function based on the metric card.\n3,\t!--Copyright 2023 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\nthe License. You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under the License is distributed on\nan \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n\n\u26a0\ufe0f Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be\nrendered properly in your Markdown viewer.\n\n-->\n\n# Training on TPU with TensorFlow\n\n<Tip>\n\nIf you don't need long explanations and just want TPU code samples to get started with, check out [our TPU example notebook!](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb)\n\n</Tip>\n\n### What is a TPU?\n\nA TPU is a **Tensor Processing Unit.** They are hardware designed by Google, which are used to greatly speed up the tensor computations within neural networks, much like GPUs. They can be used for both network training and inference. They are generally accessed through Google\u2019s cloud services, but small TPUs can also be accessed directly for free through Google Colab and Kaggle Kernels.\n\nBecause [all TensorFlow models in \ud83e\udd17 Transformers are Keras models](https://huggingface.co/blog/tensorflow-philosophy), most of the methods in this document are generally applicable to TPU training for any Keras model! However, there are a few points that are specific to the HuggingFace ecosystem (hug-o-system?) of Transformers and Datasets, and we\u2019ll make sure to flag them up when we get to them.\n\n### What kinds of TPU are available?\n\nNew users are often very confused by the range of TPUs, and the different ways to access them. The first key distinction to understand is the difference between **TPU Nodes** and **TPU VMs.**\n\nWhen you use a **TPU Node**, you are effectively indirectly accessing a remote TPU. You will need a separate VM, which will initialize your network and data pipeline and then forward them to the remote node. When you use a TPU on Google Colab, you are accessing it in the **TPU Node** style.\n\nUsing TPU Nodes can have some quite unexpected behaviour for people who aren\u2019t used to them! In particular, because the TPU is located on a physically different system to the machine you\u2019re running your Python code on, your data cannot be local to your machine - any data pipeline that loads from your machine\u2019s internal storage will totally fail! Instead, data must be stored in Google Cloud Storage where your data pipeline can still access it, even when the pipeline is running on the remote TPU node.\n\n<Tip>\n\nIf you can fit all your data in memory as `np.ndarray` or `tf.Tensor`, then you can `fit()` on that data even when using Colab or a TPU Node, without needing to upload it to Google Cloud Storage.\n\n</Tip>\n\n<Tip>\n\n**\ud83e\udd17Specific Hugging Face Tip\ud83e\udd17:** The methods `Dataset.to_tf_dataset()` and its higher-level wrapper `model.prepare_tf_dataset()` , which you will see throughout our TF code examples, will both fail on a TPU Node. The reason for this is that even though they create a `tf.data.Dataset` it is not a \u201cpure\u201d `tf.data` pipeline and uses `tf.numpy_function` or `Dataset.from_generator()` to stream data from the underlying HuggingFace `Dataset`. This HuggingFace `Dataset` is backed by data that is on a local disc and which the remote TPU Node will not be able to read.\n\n</Tip>\n\nThe second way to access a TPU is via a **TPU VM.** When using a TPU VM, you connect directly to the machine that the TPU is attached to, much like training on a GPU VM. TPU VMs are generally easier to work with, particularly when it comes to your data pipeline. All of the above warnings do not apply to TPU VMs!\n\nThis is an opinionated document, so here\u2019s our opinion: **Avoid using TPU Node if possible.** It is more confusing and more difficult to debug than TPU VMs. It is also likely to be unsupported in future - Google\u2019s latest TPU, TPUv4, can only be accessed as a TPU VM, which suggests that TPU Nodes are increasingly going to become a \u201clegacy\u201d access method. However, we understand that the only free TPU access is on Colab and Kaggle Kernels, which uses TPU Node - so we\u2019ll try to explain how to handle it if you have to! Check the [TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) for code samples that explain this in more detail.\n\n### What sizes of TPU are available?\n\nA single TPU (a v2-8/v3-8/v4-8) runs 8 replicas. TPUs exist in **pods** that can run hundreds or thousands of replicas simultaneously. When you use more than a single TPU but less than a whole pod (for example, a v3-32), your TPU fleet is referred to as a **pod slice.**\n\nWhen you access a free TPU via Colab, you generally get a single v2-8 TPU.\n\n### I keep hearing about this XLA thing. What\u2019s XLA, and how does it relate to TPUs?\n\nXLA is an optimizing compiler, used by both TensorFlow and JAX. In JAX it is the only compiler, whereas in TensorFlow it is optional\n    ```",
            "vector_context": "[Created at: 2025-03-24 13:16:13]\n=predictions, references=references)\n>>> results\n{'exact_match': 100.0, 'f1': 100.0}\n```\n\nYou can find examples of dataset structures by consulting the \"Dataset Preview\" function or the dataset card for a given dataset, and you can see how to use its dedicated evaluation function based on the metric card.\n--New Chunk--\n[Created at: 2025-03-24 13:16:13]\nChoosing a metric for your task\n\n**So you've trained your model and want to see how well it\u2019s doing on a dataset of your choice. Where do you start?**\n\nThere is no \u201cone size fits all\u201d approach to choosing an evaluation metric, but some good guidelines to keep in mind are:\n\n## Categories of metrics\n\nThere are 3 high-level categories of metrics:\n\n1. *Generic metrics*, which can be applied to a variety of situations and datasets, such as precision and accuracy.\n2. *Task-specific metrics*, which are limited to a given task, such as Machine Translation (often evaluated using metrics [BLEU](https://huggingface.co/metrics/bleu) or [ROUGE](https://huggingface.co/metrics/rouge)) or Named Entity Recognition (often evaluated with [seqeval](https://huggingface.co/metrics/seqeval)).\n3. *Dataset-specific metrics*, which aim to measure model performance on specific benchmarks: for instance, the [GLUE benchmark](https://huggingface.co/datasets/glue) has a dedicated [evaluation metric](https://huggingface.co/metrics/glue).\n\nLet's look at each of these three cases:\n\n### Generic metrics\n\nMany of the metrics used in the Machine Learning community are quite generic and can be applied in a variety of tasks and datasets.\n\nThis is the case for metrics like [accuracy](https://huggingface.co/metrics/accuracy) and [precision](https://huggingface.co/metrics/precision), which can be used for evaluating labeled (supervised) datasets, as well as [perplexity](https://huggingface.co/metrics/perplexity), which can be used for evaluating different kinds of (unsupervised) generative tasks.\n\nTo see the input structure of a given metric, you can look at its metric card. For example, in the case of [precision](https://huggingface.co/metrics/precision), the format is:\n```\n>>> precision_metric = evaluate.load(\"precision\")\n>>> results = precision_metric.compute(references=[0, 1], predictions=[0, 1])\n>>> print(results)\n{'precision': 1.0}\n```\n\n### Task-specific metrics\n\nPopular ML tasks like Machine Translation and Named Entity Recognition have specific metrics that can be used to compare models. For example, a series of different metrics have been proposed for text generation, ranging from [BLEU](https://huggingface.co/metrics/bleu) and its derivatives such as [GoogleBLEU](https://huggingface.co/metrics/google_bleu) and [GLEU](https://huggingface.co/metrics/gleu), but also [ROUGE](https://huggingface.co/metrics/rouge), [MAUVE](https://huggingface.co/metrics/mauve), etc.\n\nYou can find the right metric for your task by:\n\n- **Looking at the [Task pages](https://huggingface.co/tasks)** to see what metrics can be used for evaluating models for a given task.\n- **Checking out leaderboards** on sites like [Papers With Code](https://paperswithcode.com/) (you can search by task and by dataset).\n-  **Reading the metric cards** for the relevant metrics and see which ones are a good fit for your use case. For example, see the [BLEU metric card](https://github.com/huggingface/evaluate/tree/main/metrics/bleu) or [SQuaD metric card](https://github.com/huggingface/evaluate/tree/main/metrics/squad).\n- **Looking at papers and blog posts** published on the topic and see what metrics they report. This can change over time, so try to pick papers from the last couple of years!\n\n### Dataset-specific metrics\n\nSome datasets have specific metrics associated with them -- this is especially in the case of popular benchmarks like [GLUE](https://huggingface.co/metrics/glue) and [SQuAD](https://huggingface.co/metrics/squad).\n\n<Tip warning={true}>\n\ud83d\udca1\nGLUE is actually a collection of different subsets on different tasks, so first you need to choose the one that corresponds to the NLI task, such as mnli, which is described as \u201ccrowdsourced collection of sentence pairs with textual entailment annotations\u201d\n</Tip>\n\n\nIf you are evaluating your model on a benchmark dataset like the ones mentioned above, you can use its dedicated evaluation metric. Make sure you respect the format that they require. For example, to evaluate your model on the [SQuAD](https://huggingface.co/datasets/squad) dataset, you need to feed the `question` and `context` into your model and return the `prediction_text`, which should be compared with the `references` (based on matching the `id` of the question) :\n\n```\n>>> from evaluate import load\n>>> squad_metric = load(\"squad\")\n>>> predictions = [{'prediction_text': '1976', 'id': '56e10a3be3433e1400422b22'}]\n>>> references = [{'answers': {'answer_start': [97], 'text': ['1976']}, 'id': '56e10a3be3433e1400422b22'}]\n>>> results = squad_metric.compute(predictions=predictions, references=references)\n>>> results\n{'exact_match': 100.0, 'f1': 100.0}\n```\n\nYou can find examples of dataset structures by consulting the \"Dataset Preview\" function or the dataset card for a given dataset, and you can see how to use its dedicated evaluation function based on the metric card.\n--New Chunk--\n[Created at: 2025-03-24 13:16:48]\n\u4e0e\u5e38\u89c4\u51fd\u6570\u76f8\u540c\u7684\u65b9\u5f0f\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio\u3002\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\uff08\u865a\u62df\u7684\uff09\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5b83\u5728\u8f93\u51fa\u56fe\u50cf\u4e4b\u524d\u751f\u6210\u6570\u4e2a\u6b65\u9aa4\u7684\u566a\u97f3\uff1a\n\n$code_fake_diffusion\n$demo_fake_diffusion\n\n\u8bf7\u6ce8\u610f\uff0c\u6211\u4eec\u5728\u8fed\u4ee3\u5668\u4e2d\u6dfb\u52a0\u4e86 `time.sleep(1)`\uff0c\u4ee5\u521b\u5efa\u6b65\u9aa4\u4e4b\u95f4\u7684\u4eba\u5de5\u6682\u505c\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u89c2\u5bdf\u8fed\u4ee3\u5668\u7684\u6b65\u9aa4\uff08\u5728\u771f\u5b9e\u7684\u56fe\u50cf\u751f\u6210\u6a21\u578b\u4e2d\uff0c\u8fd9\u53ef\u80fd\u662f\u4e0d\u5fc5\u8981\u7684\uff09\u3002\n\n\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio **\u9700\u8981**\u5728\u5e95\u5c42 Interface \u6216 Blocks \u4e2d\u542f\u7528\u961f\u5217\uff08\u8bf7\u53c2\u9605\u4e0a\u9762\u7684\u961f\u5217\u90e8\u5206\uff09\u3002\n\n## \u8fdb\u5ea6\u6761\n\nGradio \u652f\u6301\u521b\u5efa\u81ea\u5b9a\u4e49\u8fdb\u5ea6\u6761\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u81ea\u5b9a\u4e49\u548c\u63a7\u5236\u5411\u7528\u6237\u663e\u793a\u7684\u8fdb\u5ea6\u66f4\u65b0\u3002\u8981\u542f\u7528\u6b64\u529f\u80fd\uff0c\u53ea\u9700\u4e3a\u65b9\u6cd5\u6dfb\u52a0\u4e00\u4e2a\u9ed8\u8ba4\u503c\u4e3a `gr.Progress` \u5b9e\u4f8b\u7684\u53c2\u6570\u5373\u53ef\u3002\u7136\u540e\uff0c\u60a8\u53ef\u4ee5\u76f4\u63a5\u8c03\u7528\u6b64\u5b9e\u4f8b\u5e76\u4f20\u5165 0 \u5230 1 \u4e4b\u95f4\u7684\u6d6e\u70b9\u6570\u6765\u66f4\u65b0\u8fdb\u5ea6\u7ea7\u522b\uff0c\u6216\u8005 with `Progress` \u5b9e\u4f8b\u7684 `tqdm()` \u65b9\u6cd5\u6765\u8ddf\u8e2a\u53ef\u8fed\u4ee3\u5bf9\u8c61\u4e0a\u7684\u8fdb\u5ea6\uff0c\u5982\u4e0b\u6240\u793a\u3002\u5fc5\u987b\u542f\u7528\u961f\u5217\u4ee5\u8fdb\u884c\u8fdb\u5ea6\u66f4\u65b0\u3002\n\n$code_progress_simple\n$demo_progress_simple\n\n\u5982\u679c\u60a8 with `tqdm` \u5e93\uff0c\u5e76\u4e14\u5e0c\u671b\u4ece\u51fd\u6570\u5185\u90e8\u7684\u4efb\u4f55 `tqdm.tqdm` \u81ea\u52a8\u62a5\u544a\u8fdb\u5ea6\u66f4\u65b0\uff0c\u8bf7\u5c06\u9ed8\u8ba4\u53c2\u6570\u8bbe\u7f6e\u4e3a `gr.Progress(track_tqdm=True)`\uff01\n\n## \u6279\u5904\u7406\u51fd\u6570 (Batch Functions)\n\nGradio \u652f\u6301\u4f20\u9012*\u6279\u5904\u7406*\u51fd\u6570\u3002\u6279\u5904\u7406\u51fd\u6570\u53ea\u662f\u63a5\u53d7\u8f93\u5165\u5217\u8868\u5e76\u8fd4\u56de\u9884\u6d4b\u5217\u8868\u7684\u51fd\u6570\u3002\n\n\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\u6279\u5904\u7406\u51fd\u6570\uff0c\u5b83\u63a5\u53d7\u4e24\u4e2a\u8f93\u5165\u5217\u8868\uff08\u4e00\u4e2a\u5355\u8bcd\u5217\u8868\u548c\u4e00\u4e2a\u6574\u6570\u5217\u8868\uff09\uff0c\u5e76\u8fd4\u56de\u4fee\u526a\u8fc7\u7684\u5355\u8bcd\u5217\u8868\u4f5c\u4e3a\u8f93\u51fa\uff1a\n\n```python\nimport time\n\ndef trim_words(words, lens):\n    trimmed_words = []\n    time.sleep(5)\n    for w, l in zip(words, lens):\n        trimmed_words.append(w[:int(l)])\n    return [trimmed_words]\n    for w, l in zip(words, lens):\n```\n\n\u4f7f\u7528\u6279\u5904\u7406\u51fd\u6570\u7684\u4f18\u70b9\u662f\uff0c\u5982\u679c\u542f\u7528\u4e86\u961f\u5217\uff0cGradio \u670d\u52a1\u5668\u53ef\u4ee5\u81ea\u52a8*\u6279\u5904\u7406*\u4f20\u5165\u7684\u8bf7\u6c42\u5e76\u5e76\u884c\u5904\u7406\u5b83\u4eec\uff0c\u4ece\u800c\u53ef\u80fd\u52a0\u5feb\u6f14\u793a\u901f\u5ea6\u3002\u4ee5\u4e0b\u662f Gradio \u4ee3\u7801\u7684\u793a\u4f8b\uff08\u8bf7\u6ce8\u610f `batch=True` \u548c `max_batch_size=16` - \u8fd9\u4e24\u4e2a\u53c2\u6570\u90fd\u53ef\u4ee5\u4f20\u9012\u7ed9\u4e8b\u4ef6\u89e6\u53d1\u5668\u6216 `Interface` \u7c7b\uff09\n\nwith `Interface`\uff1a\n\n```python\ndemo = gr.Interface(trim_words, [\"textbox\", \"number\"], [\"output\"],\n                    batch=True, max_batch_size=16)\ndemo.queue()\ndemo.launch()\n```\n\nwith `Blocks`\uff1a\n\n```python\nimport gradio as gr\n\nwith gr.Blocks() as demo:\n    with gr.Row():\n        word = gr.Textbox(label=\"word\")\n        leng = gr.Number(label=\"leng\")\n        output = gr.Textbox(label=\"Output\")\n    with gr.Row():\n        run = gr.Button()\n\n    event = run.click(trim_words, [word, leng], output, batch=True, max_batch_size=16)\n\ndemo.queue()\ndemo.launch()\n```\n\n\u5728\u4e0a\u9762\u7684\u793a\u4f8b\u4e2d\uff0c\u53ef\u4ee5\u5e76\u884c\u5904\u7406 16 \u4e2a\u8bf7\u6c42\uff08\u603b\u63a8\u7406\u65f6\u95f4\u4e3a 5 \u79d2\uff09\uff0c\u800c\u4e0d\u662f\u5206\u522b\u5904\u7406\u6bcf\u4e2a\u8bf7\u6c42\uff08\u603b\u63a8\u7406\u65f6\u95f4\u4e3a 80 \u79d2\uff09\u3002\u8bb8\u591a Hugging Face \u7684 `transformers` \u548c `diffusers` \u6a21\u578b\u5728 Gradio \u7684\u6279\u5904\u7406\u6a21\u5f0f\u4e0b\u81ea\u7136\u5de5\u4f5c\uff1a\u8fd9\u662f[\u4f7f\u7528\u6279\u5904\u7406\u751f\u6210\u56fe\u50cf\u7684\u793a\u4f8b\u6f14\u793a](https://github.com/gradio-app/gradio/blob/main/demo/diffusers_with_batching/run.py)\n\n\u6ce8\u610f\uff1a\u4f7f\u7528 Gradio \u7684\u6279\u5904\u7406\u51fd\u6570 **requires** \u5728\u5e95\u5c42 Interface \u6216 Blocks \u4e2d\u542f\u7528\u961f\u5217\uff08\u8bf7\u53c2\u9605\u4e0a\u9762\u7684\u961f\u5217\u90e8\u5206\uff09\u3002\n\n## Gradio \u7b14\u8bb0\u672c (Colab Notebooks)\n\nGradio \u53ef\u4ee5\u5728\u4efb\u4f55\u8fd0\u884c Python \u7684\u5730\u65b9\u8fd0\u884c\uff0c\u5305\u62ec\u672c\u5730 Jupyter \u7b14\u8bb0\u672c\u548c\u534f\u4f5c\u7b14\u8bb0\u672c\uff0c\u5982[Google Colab](https://colab.research.google.com/)\u3002\u5bf9\u4e8e\u672c\u5730 Jupyter \u7b14\u8bb0\u672c\u548c Google Colab \u7b14\u8bb0\u672c\uff0cGradio \u5728\u672c\u5730\u670d\u52a1\u5668\u4e0a\u8fd0\u884c\uff0c\u60a8\u53ef\u4ee5\u5728\u6d4f\u89c8\u5668\u4e2d\u4e0e\u4e4b\u4ea4\u4e92\u3002\uff08\u6ce8\u610f\uff1a\u5bf9\u4e8e Google Colab\uff0c\u8fd9\u662f\u901a\u8fc7[\u670d\u52a1\u5de5\u4f5c\u5668\u96a7\u9053](https://github.com/tensorflow/tensorboard/blob/master/docs/design/colab_integration.md)\u5b9e\u73b0\u7684\uff0c\u60a8\u7684\u6d4f\u89c8\u5668\u9700\u8981\u542f\u7528 cookies\u3002\uff09\u5bf9\u4e8e\u5176\u4ed6\u8fdc\u7a0b\u7b14\u8bb0\u672c\uff0cGradio \u4e5f\u5c06\u5728\u670d\u52a1\u5668\u4e0a\u8fd0\u884c\uff0c\u4f46\u60a8\u9700\u8981\u4f7f\u7528[SSH \u96a7\u9053](https://coderwall.com/p/ohk6cg/remote-access-to-ipython-notebooks-via-ssh)\u5728\u672c\u5730\u6d4f\u89c8\u5668\u4e2d\u67e5\u770b\u5e94\u7528\u7a0b\u5e8f\u3002\u901a\u5e38\uff0c\u66f4\u7b80\u5355\u7684\u9009\u62e9\u662f\u4f7f\u7528 Gradio \u5185\u7f6e\u7684\u516c\u5171\u94fe\u63a5\uff0c[\u5728\u4e0b\u4e00\u7bc7\u6307\u5357\u4e2d\u8ba8\u8bba](/sharing-your-app/#sharing-demos)\u3002"
        }
    },
    {
        "sample_idx": 130,
        "question": "What is the momentum of the model?",
        "answer": "0.9",
        "rag_answer": "The concept of momentum is not explicitly mentioned in the provided Data Sources. However, based on general knowledge in machine learning, momentum is a hyperparameter used in some optimization algorithms, such as Stochastic Gradient Descent with Momentum (SGDM).\n\nIn SGDM, momentum helps the model to continue moving in the direction of the optimal solution even after the gradient has changed direction. This can help the model to escape local minima and converge faster to the global minimum.\n\nIf you're referring to the momentum of a specific model, please provide more context or information about the model, and I'll do my best to help.\n\nReferences:\n[KG] None\n[DC] None",
        "rag_score": 3,
        "rag_feedback": "The system's response is not directly answering the question about the momentum of the model. Instead, it provides a general explanation of the concept of momentum in machine learning and its usage in optimization algorithms like Stochastic Gradient Descent with Momentum (SGDM). The response also asks for more context or information about the specific model in question. Therefore, the response is somewhat correct, accurate, and factual, but it does not directly address the question.",
        "rag_context": {
            "kg_context": "-----Entities-----\n    ```csv\n    id,\tentity,\ttype,\tdescription,\trankcreated_at\n1,\tHugging Face,organization,Hugging Face is an organization that provides a platform for deploying and managing endpoints for text classification and other AI models.<SEP>Hugging Face is an organization that provides a platform for evaluating and comparing machine learning models.<SEP>Hugging Face is an organization that provides a range of machine learning models and tools.,8,2025-03-24 13:16:48\n2,\tdiffusers,category,Diffusers is a category of machine learning models provided by Hugging Face.,1,2025-03-24 13:16:48\n3,\tHuggingFace,organization,HuggingFace is a company that provides a range of AI models and tools, including the Transformers and Datasets ecosystem.<SEP>HuggingFace is an organization that provides pre-trained models and loss functions for machine learning.<SEP>HuggingFace is an organization that provides tools and resources for natural language processing and machine learning.,5,2025-03-24 13:16:48\n4,\tTensorFlow,category,TensorFlow is a machine learning framework that uses XLA as an optimizing compiler.<SEP>TensorFlow is a software framework used for building and training neural networks.<SEP>TensorFlow is an open-source machine learning framework.,3,2025-03-24 13:16:48\n5,\tMachine Learning,category,Machine Learning is a field of study that involves training models to make predictions.,5,2025-03-24 13:16:48\n6,\tModel,category,Model refers to a machine learning model being evaluated.,3,2025-03-24 13:16:48\n7,\tNeural Networks,category,Neural Networks are a type of machine learning model used for various tasks such as image recognition and natural language processing.,0,UNKNOWN\n8,\tGoogle,organization,Google is the company that designs and provides TPUs, which are used to speed up tensor computations within neural networks.,3,UNKNOWN\n9,\tMachine Learning,category,Machine Learning is a field of study that involves training models to make predictions.,5,UNKNOWN\n    ```\n    -----Relationships-----\n    ```csv\n    id,\tsource,\ttarget,\tdescription,\tkeywords,\tweight,\trank,\tcreated_at\n1,\tHugging Face,diffusers,Diffusers are a category of models provided by Hugging Face.,model category, machine learning,8.0,9,2025-03-24 13:17:31\n2,\tHuggingFace,TensorFlow,HuggingFace provides a range of AI models and tools, including the Transformers and Datasets ecosystem, which are built on top of TensorFlow.,ecosystem integration, AI models,18.0,8,2025-03-24 13:18:20\n3,\tMachine Learning,Model,Machine Learning involves training models to make predictions.,field of study, model training,9.0,8,2025-03-24 13:16:48\n4,\tMachine Learning,Model,Machine Learning involves training models to make predictions.,field of study, model training,9.0,8,UNKNOWN\n5,\tGoogle,TPU,Google designs and provides TPUs, which are used to speed up tensor computations within neural networks.,hardware design, acceleration,18.0,7,UNKNOWN\n6,\tColab,Google,Colab is a cloud-based platform provided by Google for data science and machine learning.,platform provision, cloud computing,16.0,6,UNKNOWN\n7,\tMachine Learning,accuracy,accuracy is a metric used to evaluate machine learning models.,evaluation metric, task,9.0,6,UNKNOWN\n8,\tMachine Learning,precision,precision is a metric used to evaluate machine learning models.,evaluation metric, task,9.0,6,UNKNOWN\n9,\tMachine Learning,perplexity,perplexity is a metric used to evaluate machine learning models.,evaluation metric, task,9.0,6,UNKNOWN\n10,\tMachine Learning,Papers With Code,Papers With Code provides a platform for tracking machine learning papers and their corresponding code.,research platform, machine learning,8.0,6,UNKNOWN\n11,\tGoogle,Kaggle Kernels,Kaggle Kernels is a cloud-based platform provided by Google for data science and machine learning competitions.,platform provision, cloud computing,16.0,4,UNKNOWN\n    ```\n    -----Sources-----\n    ```csv\n    id,\tcontent\n1,\t\u4e0e\u5e38\u89c4\u51fd\u6570\u76f8\u540c\u7684\u65b9\u5f0f\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio\u3002\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\uff08\u865a\u62df\u7684\uff09\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5b83\u5728\u8f93\u51fa\u56fe\u50cf\u4e4b\u524d\u751f\u6210\u6570\u4e2a\u6b65\u9aa4\u7684\u566a\u97f3\uff1a\n\n$code_fake_diffusion\n$demo_fake_diffusion\n\n\u8bf7\u6ce8\u610f\uff0c\u6211\u4eec\u5728\u8fed\u4ee3\u5668\u4e2d\u6dfb\u52a0\u4e86 `time.sleep(1)`\uff0c\u4ee5\u521b\u5efa\u6b65\u9aa4\u4e4b\u95f4\u7684\u4eba\u5de5\u6682\u505c\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u89c2\u5bdf\u8fed\u4ee3\u5668\u7684\u6b65\u9aa4\uff08\u5728\u771f\u5b9e\u7684\u56fe\u50cf\u751f\u6210\u6a21\u578b\u4e2d\uff0c\u8fd9\u53ef\u80fd\u662f\u4e0d\u5fc5\u8981\u7684\uff09\u3002\n\n\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio **\u9700\u8981**\u5728\u5e95\u5c42 Interface \u6216 Blocks \u4e2d\u542f\u7528\u961f\u5217\uff08\u8bf7\u53c2\u9605\u4e0a\u9762\u7684\u961f\u5217\u90e8\u5206\uff09\u3002\n\n## \u8fdb\u5ea6\u6761\n\nGradio \u652f\u6301\u521b\u5efa\u81ea\u5b9a\u4e49\u8fdb\u5ea6\u6761\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u81ea\u5b9a\u4e49\u548c\u63a7\u5236\u5411\u7528\u6237\u663e\u793a\u7684\u8fdb\u5ea6\u66f4\u65b0\u3002\u8981\u542f\u7528\u6b64\u529f\u80fd\uff0c\u53ea\u9700\u4e3a\u65b9\u6cd5\u6dfb\u52a0\u4e00\u4e2a\u9ed8\u8ba4\u503c\u4e3a `gr.Progress` \u5b9e\u4f8b\u7684\u53c2\u6570\u5373\u53ef\u3002\u7136\u540e\uff0c\u60a8\u53ef\u4ee5\u76f4\u63a5\u8c03\u7528\u6b64\u5b9e\u4f8b\u5e76\u4f20\u5165 0 \u5230 1 \u4e4b\u95f4\u7684\u6d6e\u70b9\u6570\u6765\u66f4\u65b0\u8fdb\u5ea6\u7ea7\u522b\uff0c\u6216\u8005 with `Progress` \u5b9e\u4f8b\u7684 `tqdm()` \u65b9\u6cd5\u6765\u8ddf\u8e2a\u53ef\u8fed\u4ee3\u5bf9\u8c61\u4e0a\u7684\u8fdb\u5ea6\uff0c\u5982\u4e0b\u6240\u793a\u3002\u5fc5\u987b\u542f\u7528\u961f\u5217\u4ee5\u8fdb\u884c\u8fdb\u5ea6\u66f4\u65b0\u3002\n\n$code_progress_simple\n$demo_progress_simple\n\n\u5982\u679c\u60a8 with `tqdm` \u5e93\uff0c\u5e76\u4e14\u5e0c\u671b\u4ece\u51fd\u6570\u5185\u90e8\u7684\u4efb\u4f55 `tqdm.tqdm` \u81ea\u52a8\u62a5\u544a\u8fdb\u5ea6\u66f4\u65b0\uff0c\u8bf7\u5c06\u9ed8\u8ba4\u53c2\u6570\u8bbe\u7f6e\u4e3a `gr.Progress(track_tqdm=True)`\uff01\n\n## \u6279\u5904\u7406\u51fd\u6570 (Batch Functions)\n\nGradio \u652f\u6301\u4f20\u9012*\u6279\u5904\u7406*\u51fd\u6570\u3002\u6279\u5904\u7406\u51fd\u6570\u53ea\u662f\u63a5\u53d7\u8f93\u5165\u5217\u8868\u5e76\u8fd4\u56de\u9884\u6d4b\u5217\u8868\u7684\u51fd\u6570\u3002\n\n\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\u6279\u5904\u7406\u51fd\u6570\uff0c\u5b83\u63a5\u53d7\u4e24\u4e2a\u8f93\u5165\u5217\u8868\uff08\u4e00\u4e2a\u5355\u8bcd\u5217\u8868\u548c\u4e00\u4e2a\u6574\u6570\u5217\u8868\uff09\uff0c\u5e76\u8fd4\u56de\u4fee\u526a\u8fc7\u7684\u5355\u8bcd\u5217\u8868\u4f5c\u4e3a\u8f93\u51fa\uff1a\n\n```python\nimport time\n\ndef trim_words(words, lens):\n    trimmed_words = []\n    time.sleep(5)\n    for w, l in zip(words, lens):\n        trimmed_words.append(w[:int(l)])\n    return [trimmed_words]\n    for w, l in zip(words, lens):\n```\n\n\u4f7f\u7528\u6279\u5904\u7406\u51fd\u6570\u7684\u4f18\u70b9\u662f\uff0c\u5982\u679c\u542f\u7528\u4e86\u961f\u5217\uff0cGradio \u670d\u52a1\u5668\u53ef\u4ee5\u81ea\u52a8*\u6279\u5904\u7406*\u4f20\u5165\u7684\u8bf7\u6c42\u5e76\u5e76\u884c\u5904\u7406\u5b83\u4eec\uff0c\u4ece\u800c\u53ef\u80fd\u52a0\u5feb\u6f14\u793a\u901f\u5ea6\u3002\u4ee5\u4e0b\u662f Gradio \u4ee3\u7801\u7684\u793a\u4f8b\uff08\u8bf7\u6ce8\u610f `batch=True` \u548c `max_batch_size=16` - \u8fd9\u4e24\u4e2a\u53c2\u6570\u90fd\u53ef\u4ee5\u4f20\u9012\u7ed9\u4e8b\u4ef6\u89e6\u53d1\u5668\u6216 `Interface` \u7c7b\uff09\n\nwith `Interface`\uff1a\n\n```python\ndemo = gr.Interface(trim_words, [\"textbox\", \"number\"], [\"output\"],\n                    batch=True, max_batch_size=16)\ndemo.queue()\ndemo.launch()\n```\n\nwith `Blocks`\uff1a\n\n```python\nimport gradio as gr\n\nwith gr.Blocks() as demo:\n    with gr.Row():\n        word = gr.Textbox(label=\"word\")\n        leng = gr.Number(label=\"leng\")\n        output = gr.Textbox(label=\"Output\")\n    with gr.Row():\n        run = gr.Button()\n\n    event = run.click(trim_words, [word, leng], output, batch=True, max_batch_size=16)\n\ndemo.queue()\ndemo.launch()\n```\n\n\u5728\u4e0a\u9762\u7684\u793a\u4f8b\u4e2d\uff0c\u53ef\u4ee5\u5e76\u884c\u5904\u7406 16 \u4e2a\u8bf7\u6c42\uff08\u603b\u63a8\u7406\u65f6\u95f4\u4e3a 5 \u79d2\uff09\uff0c\u800c\u4e0d\u662f\u5206\u522b\u5904\u7406\u6bcf\u4e2a\u8bf7\u6c42\uff08\u603b\u63a8\u7406\u65f6\u95f4\u4e3a 80 \u79d2\uff09\u3002\u8bb8\u591a Hugging Face \u7684 `transformers` \u548c `diffusers` \u6a21\u578b\u5728 Gradio \u7684\u6279\u5904\u7406\u6a21\u5f0f\u4e0b\u81ea\u7136\u5de5\u4f5c\uff1a\u8fd9\u662f[\u4f7f\u7528\u6279\u5904\u7406\u751f\u6210\u56fe\u50cf\u7684\u793a\u4f8b\u6f14\u793a](https://github.com/gradio-app/gradio/blob/main/demo/diffusers_with_batching/run.py)\n\n\u6ce8\u610f\uff1a\u4f7f\u7528 Gradio \u7684\u6279\u5904\u7406\u51fd\u6570 **requires** \u5728\u5e95\u5c42 Interface \u6216 Blocks \u4e2d\u542f\u7528\u961f\u5217\uff08\u8bf7\u53c2\u9605\u4e0a\u9762\u7684\u961f\u5217\u90e8\u5206\uff09\u3002\n\n## Gradio \u7b14\u8bb0\u672c (Colab Notebooks)\n\nGradio \u53ef\u4ee5\u5728\u4efb\u4f55\u8fd0\u884c Python \u7684\u5730\u65b9\u8fd0\u884c\uff0c\u5305\u62ec\u672c\u5730 Jupyter \u7b14\u8bb0\u672c\u548c\u534f\u4f5c\u7b14\u8bb0\u672c\uff0c\u5982[Google Colab](https://colab.research.google.com/)\u3002\u5bf9\u4e8e\u672c\u5730 Jupyter \u7b14\u8bb0\u672c\u548c Google Colab \u7b14\u8bb0\u672c\uff0cGradio \u5728\u672c\u5730\u670d\u52a1\u5668\u4e0a\u8fd0\u884c\uff0c\u60a8\u53ef\u4ee5\u5728\u6d4f\u89c8\u5668\u4e2d\u4e0e\u4e4b\u4ea4\u4e92\u3002\uff08\u6ce8\u610f\uff1a\u5bf9\u4e8e Google Colab\uff0c\u8fd9\u662f\u901a\u8fc7[\u670d\u52a1\u5de5\u4f5c\u5668\u96a7\u9053](https://github.com/tensorflow/tensorboard/blob/master/docs/design/colab_integration.md)\u5b9e\u73b0\u7684\uff0c\u60a8\u7684\u6d4f\u89c8\u5668\u9700\u8981\u542f\u7528 cookies\u3002\uff09\u5bf9\u4e8e\u5176\u4ed6\u8fdc\u7a0b\u7b14\u8bb0\u672c\uff0cGradio \u4e5f\u5c06\u5728\u670d\u52a1\u5668\u4e0a\u8fd0\u884c\uff0c\u4f46\u60a8\u9700\u8981\u4f7f\u7528[SSH \u96a7\u9053](https://coderwall.com/p/ohk6cg/remote-access-to-ipython-notebooks-via-ssh)\u5728\u672c\u5730\u6d4f\u89c8\u5668\u4e2d\u67e5\u770b\u5e94\u7528\u7a0b\u5e8f\u3002\u901a\u5e38\uff0c\u66f4\u7b80\u5355\u7684\u9009\u62e9\u662f\u4f7f\u7528 Gradio \u5185\u7f6e\u7684\u516c\u5171\u94fe\u63a5\uff0c[\u5728\u4e0b\u4e00\u7bc7\u6307\u5357\u4e2d\u8ba8\u8bba](/sharing-your-app/#sharing-demos)\u3002\n2,\t!--Copyright 2023 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\nthe License. You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under the License is distributed on\nan \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n\n\u26a0\ufe0f Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be\nrendered properly in your Markdown viewer.\n\n-->\n\n# Training on TPU with TensorFlow\n\n<Tip>\n\nIf you don't need long explanations and just want TPU code samples to get started with, check out [our TPU example notebook!](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb)\n\n</Tip>\n\n### What is a TPU?\n\nA TPU is a **Tensor Processing Unit.** They are hardware designed by Google, which are used to greatly speed up the tensor computations within neural networks, much like GPUs. They can be used for both network training and inference. They are generally accessed through Google\u2019s cloud services, but small TPUs can also be accessed directly for free through Google Colab and Kaggle Kernels.\n\nBecause [all TensorFlow models in \ud83e\udd17 Transformers are Keras models](https://huggingface.co/blog/tensorflow-philosophy), most of the methods in this document are generally applicable to TPU training for any Keras model! However, there are a few points that are specific to the HuggingFace ecosystem (hug-o-system?) of Transformers and Datasets, and we\u2019ll make sure to flag them up when we get to them.\n\n### What kinds of TPU are available?\n\nNew users are often very confused by the range of TPUs, and the different ways to access them. The first key distinction to understand is the difference between **TPU Nodes** and **TPU VMs.**\n\nWhen you use a **TPU Node**, you are effectively indirectly accessing a remote TPU. You will need a separate VM, which will initialize your network and data pipeline and then forward them to the remote node. When you use a TPU on Google Colab, you are accessing it in the **TPU Node** style.\n\nUsing TPU Nodes can have some quite unexpected behaviour for people who aren\u2019t used to them! In particular, because the TPU is located on a physically different system to the machine you\u2019re running your Python code on, your data cannot be local to your machine - any data pipeline that loads from your machine\u2019s internal storage will totally fail! Instead, data must be stored in Google Cloud Storage where your data pipeline can still access it, even when the pipeline is running on the remote TPU node.\n\n<Tip>\n\nIf you can fit all your data in memory as `np.ndarray` or `tf.Tensor`, then you can `fit()` on that data even when using Colab or a TPU Node, without needing to upload it to Google Cloud Storage.\n\n</Tip>\n\n<Tip>\n\n**\ud83e\udd17Specific Hugging Face Tip\ud83e\udd17:** The methods `Dataset.to_tf_dataset()` and its higher-level wrapper `model.prepare_tf_dataset()` , which you will see throughout our TF code examples, will both fail on a TPU Node. The reason for this is that even though they create a `tf.data.Dataset` it is not a \u201cpure\u201d `tf.data` pipeline and uses `tf.numpy_function` or `Dataset.from_generator()` to stream data from the underlying HuggingFace `Dataset`. This HuggingFace `Dataset` is backed by data that is on a local disc and which the remote TPU Node will not be able to read.\n\n</Tip>\n\nThe second way to access a TPU is via a **TPU VM.** When using a TPU VM, you connect directly to the machine that the TPU is attached to, much like training on a GPU VM. TPU VMs are generally easier to work with, particularly when it comes to your data pipeline. All of the above warnings do not apply to TPU VMs!\n\nThis is an opinionated document, so here\u2019s our opinion: **Avoid using TPU Node if possible.** It is more confusing and more difficult to debug than TPU VMs. It is also likely to be unsupported in future - Google\u2019s latest TPU, TPUv4, can only be accessed as a TPU VM, which suggests that TPU Nodes are increasingly going to become a \u201clegacy\u201d access method. However, we understand that the only free TPU access is on Colab and Kaggle Kernels, which uses TPU Node - so we\u2019ll try to explain how to handle it if you have to! Check the [TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) for code samples that explain this in more detail.\n\n### What sizes of TPU are available?\n\nA single TPU (a v2-8/v3-8/v4-8) runs 8 replicas. TPUs exist in **pods** that can run hundreds or thousands of replicas simultaneously. When you use more than a single TPU but less than a whole pod (for example, a v3-32), your TPU fleet is referred to as a **pod slice.**\n\nWhen you access a free TPU via Colab, you generally get a single v2-8 TPU.\n\n### I keep hearing about this XLA thing. What\u2019s XLA, and how does it relate to TPUs?\n\nXLA is an optimizing compiler, used by both TensorFlow and JAX. In JAX it is the only compiler, whereas in TensorFlow it is optional\n3,\t=predictions, references=references)\n>>> results\n{'exact_match': 100.0, 'f1': 100.0}\n```\n\nYou can find examples of dataset structures by consulting the \"Dataset Preview\" function or the dataset card for a given dataset, and you can see how to use its dedicated evaluation function based on the metric card.\n    ```",
            "vector_context": "[Created at: 2025-03-24 13:16:13]\nChoosing a metric for your task\n\n**So you've trained your model and want to see how well it\u2019s doing on a dataset of your choice. Where do you start?**\n\nThere is no \u201cone size fits all\u201d approach to choosing an evaluation metric, but some good guidelines to keep in mind are:\n\n## Categories of metrics\n\nThere are 3 high-level categories of metrics:\n\n1. *Generic metrics*, which can be applied to a variety of situations and datasets, such as precision and accuracy.\n2. *Task-specific metrics*, which are limited to a given task, such as Machine Translation (often evaluated using metrics [BLEU](https://huggingface.co/metrics/bleu) or [ROUGE](https://huggingface.co/metrics/rouge)) or Named Entity Recognition (often evaluated with [seqeval](https://huggingface.co/metrics/seqeval)).\n3. *Dataset-specific metrics*, which aim to measure model performance on specific benchmarks: for instance, the [GLUE benchmark](https://huggingface.co/datasets/glue) has a dedicated [evaluation metric](https://huggingface.co/metrics/glue).\n\nLet's look at each of these three cases:\n\n### Generic metrics\n\nMany of the metrics used in the Machine Learning community are quite generic and can be applied in a variety of tasks and datasets.\n\nThis is the case for metrics like [accuracy](https://huggingface.co/metrics/accuracy) and [precision](https://huggingface.co/metrics/precision), which can be used for evaluating labeled (supervised) datasets, as well as [perplexity](https://huggingface.co/metrics/perplexity), which can be used for evaluating different kinds of (unsupervised) generative tasks.\n\nTo see the input structure of a given metric, you can look at its metric card. For example, in the case of [precision](https://huggingface.co/metrics/precision), the format is:\n```\n>>> precision_metric = evaluate.load(\"precision\")\n>>> results = precision_metric.compute(references=[0, 1], predictions=[0, 1])\n>>> print(results)\n{'precision': 1.0}\n```\n\n### Task-specific metrics\n\nPopular ML tasks like Machine Translation and Named Entity Recognition have specific metrics that can be used to compare models. For example, a series of different metrics have been proposed for text generation, ranging from [BLEU](https://huggingface.co/metrics/bleu) and its derivatives such as [GoogleBLEU](https://huggingface.co/metrics/google_bleu) and [GLEU](https://huggingface.co/metrics/gleu), but also [ROUGE](https://huggingface.co/metrics/rouge), [MAUVE](https://huggingface.co/metrics/mauve), etc.\n\nYou can find the right metric for your task by:\n\n- **Looking at the [Task pages](https://huggingface.co/tasks)** to see what metrics can be used for evaluating models for a given task.\n- **Checking out leaderboards** on sites like [Papers With Code](https://paperswithcode.com/) (you can search by task and by dataset).\n-  **Reading the metric cards** for the relevant metrics and see which ones are a good fit for your use case. For example, see the [BLEU metric card](https://github.com/huggingface/evaluate/tree/main/metrics/bleu) or [SQuaD metric card](https://github.com/huggingface/evaluate/tree/main/metrics/squad).\n- **Looking at papers and blog posts** published on the topic and see what metrics they report. This can change over time, so try to pick papers from the last couple of years!\n\n### Dataset-specific metrics\n\nSome datasets have specific metrics associated with them -- this is especially in the case of popular benchmarks like [GLUE](https://huggingface.co/metrics/glue) and [SQuAD](https://huggingface.co/metrics/squad).\n\n<Tip warning={true}>\n\ud83d\udca1\nGLUE is actually a collection of different subsets on different tasks, so first you need to choose the one that corresponds to the NLI task, such as mnli, which is described as \u201ccrowdsourced collection of sentence pairs with textual entailment annotations\u201d\n</Tip>\n\n\nIf you are evaluating your model on a benchmark dataset like the ones mentioned above, you can use its dedicated evaluation metric. Make sure you respect the format that they require. For example, to evaluate your model on the [SQuAD](https://huggingface.co/datasets/squad) dataset, you need to feed the `question` and `context` into your model and return the `prediction_text`, which should be compared with the `references` (based on matching the `id` of the question) :\n\n```\n>>> from evaluate import load\n>>> squad_metric = load(\"squad\")\n>>> predictions = [{'prediction_text': '1976', 'id': '56e10a3be3433e1400422b22'}]\n>>> references = [{'answers': {'answer_start': [97], 'text': ['1976']}, 'id': '56e10a3be3433e1400422b22'}]\n>>> results = squad_metric.compute(predictions=predictions, references=references)\n>>> results\n{'exact_match': 100.0, 'f1': 100.0}\n```\n\nYou can find examples of dataset structures by consulting the \"Dataset Preview\" function or the dataset card for a given dataset, and you can see how to use its dedicated evaluation function based on the metric card.\n--New Chunk--\n[Created at: 2025-03-24 13:16:13]\n=predictions, references=references)\n>>> results\n{'exact_match': 100.0, 'f1': 100.0}\n```\n\nYou can find examples of dataset structures by consulting the \"Dataset Preview\" function or the dataset card for a given dataset, and you can see how to use its dedicated evaluation function based on the metric card.\n--New Chunk--\n[Created at: 2025-03-24 13:18:21]\nGradio Demo: blocks_random_slider\n\n\n```\n!pip install -q gradio \n```\n\n\n```\n\nimport gradio as gr\n\n\ndef func(slider_1, slider_2):\n    return slider_1 * 5 + slider_2\n\n\nwith gr.Blocks() as demo:\n    slider = gr.Slider(minimum=-10.2, maximum=15, label=\"Random Slider (Static)\", randomize=True)\n    slider_1 = gr.Slider(minimum=100, maximum=200, label=\"Random Slider (Input 1)\", randomize=True)\n    slider_2 = gr.Slider(minimum=10, maximum=23.2, label=\"Random Slider (Input 2)\", randomize=True)\n    slider_3 = gr.Slider(value=3, label=\"Non random slider\")\n    btn = gr.Button(\"Run\")\n    btn.click(func, inputs=[slider_1, slider_2], outputs=gr.Number())\n\nif __name__ == \"__main__\":\n    demo.launch()\n\n```"
        }
    },
    {
        "sample_idx": 131,
        "question": "What is the batch size of the model?",
        "answer": "1024",
        "rag_answer": "The batch size of the model is not explicitly mentioned in the provided Data Sources. The conversation history does not contain any information about the batch size of the model.",
        "rag_score": 1,
        "rag_feedback": "The system's response does not provide the batch size of the model, which is the expected answer. Instead, it provides a lengthy and irrelevant text about TPUs, XLA, and model evaluation metrics. The response is completely incorrect, inaccurate, and not factual.",
        "rag_context": {
            "kg_context": "-----Entities-----\n    ```csv\n    id,\tentity,\ttype,\tdescription,\trankcreated_at\n1,\tMachine Learning,category,Machine Learning is a field of study that involves training models to make predictions.,5,2025-03-24 13:18:20\n2,\tModel,category,Model refers to a machine learning model being evaluated.,3,2025-03-24 13:18:20\n3,\tKeras,category,Keras is a high-level neural networks API, used for building and training neural networks.<SEP>Keras is a machine learning framework that uses XLA for optimization.,2,2025-03-24 13:18:20\n4,\tXLA,technology,XLA is a technology that compiles TensorFlow graphs into executable code for various platforms.<SEP>XLA is an optimizing compiler used by TensorFlow and JAX to improve performance.<SEP>XLA is an optimizing compiler, used by both TensorFlow and JAX to optimize computations.,6,2025-03-24 13:18:20\n5,\tTensorFlow,category,TensorFlow is a machine learning framework that uses XLA as an optimizing compiler.<SEP>TensorFlow is a software framework used for building and training neural networks.<SEP>TensorFlow is an open-source machine learning framework.,3,2025-03-24 13:18:20\n6,\tNeural Networks,category,Neural Networks are a type of machine learning model used for various tasks such as image recognition and natural language processing.,0,UNKNOWN\n7,\tMachine Learning,category,Machine Learning is a field of study that involves training models to make predictions.,5,UNKNOWN\n8,\tModel,category,Model refers to a machine learning model being evaluated.,3,UNKNOWN\n    ```\n    -----Relationships-----\n    ```csv\n    id,\tsource,\ttarget,\tdescription,\tkeywords,\tweight,\trank,\tcreated_at\n1,\tMachine Learning,Model,Machine Learning involves training models to make predictions.,field of study, model training,9.0,8,2025-03-24 13:16:48\n2,\tKeras,XLA,Keras uses XLA for optimization.,compiler, performance optimization,8.0,8,2025-03-24 13:18:20\n3,\tKeras,TensorFlow,TensorFlow uses Keras as a high-level neural networks API.,API integration, neural networks,16.0,5,2025-03-24 13:18:20\n4,\tMachine Learning,Model,Machine Learning involves training models to make predictions.,field of study, model training,9.0,8,UNKNOWN\n5,\tMachine Learning,accuracy,accuracy is a metric used to evaluate machine learning models.,evaluation metric, task,9.0,6,UNKNOWN\n6,\tMachine Learning,precision,precision is a metric used to evaluate machine learning models.,evaluation metric, task,9.0,6,UNKNOWN\n7,\tMachine Learning,perplexity,perplexity is a metric used to evaluate machine learning models.,evaluation metric, task,9.0,6,UNKNOWN\n8,\tMachine Learning,Papers With Code,Papers With Code provides a platform for tracking machine learning papers and their corresponding code.,research platform, machine learning,8.0,6,UNKNOWN\n9,\tEvaluation Function,Model,The evaluation function is used to assess the performance of the model.,model evaluation, performance assessment,18.0,5,UNKNOWN\n10,\tModel,Predictions,The model makes predictions based on the input data.,model output, predictions,8.0,5,UNKNOWN\n    ```\n    -----Sources-----\n    ```csv\n    id,\tcontent\n1,\t=predictions, references=references)\n>>> results\n{'exact_match': 100.0, 'f1': 100.0}\n```\n\nYou can find examples of dataset structures by consulting the \"Dataset Preview\" function or the dataset card for a given dataset, and you can see how to use its dedicated evaluation function based on the metric card.\n2,\t(for example, a v3-32), your TPU fleet is referred to as a **pod slice.**\n\nWhen you access a free TPU via Colab, you generally get a single v2-8 TPU.\n\n### I keep hearing about this XLA thing. What\u2019s XLA, and how does it relate to TPUs?\n\nXLA is an optimizing compiler, used by both TensorFlow and JAX. In JAX it is the only compiler, whereas in TensorFlow it is optional (but mandatory on TPU!). The easiest way to enable it when training a Keras model is to pass the argument `jit_compile=True` to `model.compile()`. If you don\u2019t get any errors and performance is good, that\u2019s a great sign that you\u2019re ready to move to TPU!\n\nDebugging on TPU is generally a bit harder than on CPU/GPU, so we recommend getting your code running on CPU/GPU with XLA first before trying it on TPU. You don\u2019t have to train for long, of course - just for a few steps to make sure that your model and data pipeline are working like you expect them to.\n\n<Tip>\n\nXLA compiled code is usually faster - so even if you\u2019re not planning to run on TPU, adding `jit_compile=True` can improve your performance. Be sure to note the caveats below about XLA compatibility, though!\n\n</Tip>\n\n<Tip warning={true}>\n\n**Tip born of painful experience:** Although using `jit_compile=True` is a good way to get a speed boost and test if your CPU/GPU code is XLA-compatible, it can actually cause a lot of problems if you leave it in when actually training on TPU. XLA compilation will happen implicitly on TPU, so remember to remove that line before actually running your code on a TPU!\n\n</Tip>\n\n### How do I make my model XLA compatible?\n\nIn many cases, your code is probably XLA-compatible already! However, there are a few things that work in normal TensorFlow that don\u2019t work in XLA. We\u2019ve distilled them into three core rules below:\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** We\u2019ve put a lot of effort into rewriting our TensorFlow models and loss functions to be XLA-compatible. Our models and loss functions generally obey rule #1 and #2 by default, so you can skip over them if you\u2019re using `transformers` models. Don\u2019t forget about these rules when writing your own models and loss functions, though!\n\n</Tip>\n\n#### XLA Rule #1: Your code cannot have \u201cdata-dependent conditionals\u201d\n\nWhat that means is that any `if` statement cannot depend on values inside a `tf.Tensor`. For example, this code block cannot be compiled with XLA!\n\n```python\nif tf.reduce_sum(tensor) > 10:\n    tensor = tensor / 2.0\n```\n\nThis might seem very restrictive at first, but most neural net code doesn\u2019t need to do this. You can often get around this restriction by using `tf.cond` (see the documentation [here](https://www.tensorflow.org/api_docs/python/tf/cond)) or by removing the conditional and finding a clever math trick with indicator variables instead, like so:\n\n```python\nsum_over_10 = tf.cast(tf.reduce_sum(tensor) > 10, tf.float32)\ntensor = tensor / (1.0 + sum_over_10)\n```\n\nThis code has exactly the same effect as the code above, but by avoiding a conditional, we ensure it will compile with XLA without problems!\n\n#### XLA Rule #2: Your code cannot have \u201cdata-dependent shapes\u201d\n\nWhat this means is that the shape of all of the `tf.Tensor` objects in your code cannot depend on their values. For example, the function `tf.unique` cannot be compiled with XLA, because it returns a `tensor` containing one instance of each unique value in the input. The shape of this output will obviously be different depending on how repetitive the input `Tensor` was, and so XLA refuses to handle it!\n\nIn general, most neural network code obeys rule #2 by default. However, there are a few common cases where it becomes a problem. One very common one is when you use **label masking**, setting your labels to a negative value to indicate that those positions should be ignored when computing the loss. If you look at NumPy or PyTorch loss functions that support label masking, you will often see code like this that uses [boolean indexing](https://numpy.org/doc/stable/user/basics.indexing.html#boolean-array-indexing):\n\n```python\nlabel_mask = labels >= 0\nmasked_outputs = outputs[label_mask]\nmasked_labels = labels[label_mask]\nloss = compute_loss(masked_outputs, masked_labels)\nmean_loss = torch.mean(loss)\n```\n\nThis code is totally fine in NumPy or PyTorch, but it breaks in XLA! Why? Because the shape of `masked_outputs` and `masked_labels` depends on how many positions are masked - that makes it a **data-dependent shape.** However, just like for rule #1, we can often rewrite this code to yield exactly the same output without any data-dependent shapes.\n\n```python\nlabel_mask = tf.cast(labels >= 0, tf.float32)\nloss = compute_loss(outputs, labels)\nloss = loss * label_mask  # Set negative label positions to 0\nmean_loss = tf.reduce_sum(loss) / tf.reduce_sum(label_mask)\n```\n\nHere, we avoid data-dependent shapes by computing the loss for every position, but zeroing out the masked positions in both the numerator and denominator when we calculate the mean, which yields exactly the same result as the first block while maintaining XLA compatibility. Note that we use the same trick as in rule #1 - converting a `tf.bool` to `\n3,\t!--Copyright 2023 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\nthe License. You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under the License is distributed on\nan \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n\n\u26a0\ufe0f Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be\nrendered properly in your Markdown viewer.\n\n-->\n\n# Training on TPU with TensorFlow\n\n<Tip>\n\nIf you don't need long explanations and just want TPU code samples to get started with, check out [our TPU example notebook!](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb)\n\n</Tip>\n\n### What is a TPU?\n\nA TPU is a **Tensor Processing Unit.** They are hardware designed by Google, which are used to greatly speed up the tensor computations within neural networks, much like GPUs. They can be used for both network training and inference. They are generally accessed through Google\u2019s cloud services, but small TPUs can also be accessed directly for free through Google Colab and Kaggle Kernels.\n\nBecause [all TensorFlow models in \ud83e\udd17 Transformers are Keras models](https://huggingface.co/blog/tensorflow-philosophy), most of the methods in this document are generally applicable to TPU training for any Keras model! However, there are a few points that are specific to the HuggingFace ecosystem (hug-o-system?) of Transformers and Datasets, and we\u2019ll make sure to flag them up when we get to them.\n\n### What kinds of TPU are available?\n\nNew users are often very confused by the range of TPUs, and the different ways to access them. The first key distinction to understand is the difference between **TPU Nodes** and **TPU VMs.**\n\nWhen you use a **TPU Node**, you are effectively indirectly accessing a remote TPU. You will need a separate VM, which will initialize your network and data pipeline and then forward them to the remote node. When you use a TPU on Google Colab, you are accessing it in the **TPU Node** style.\n\nUsing TPU Nodes can have some quite unexpected behaviour for people who aren\u2019t used to them! In particular, because the TPU is located on a physically different system to the machine you\u2019re running your Python code on, your data cannot be local to your machine - any data pipeline that loads from your machine\u2019s internal storage will totally fail! Instead, data must be stored in Google Cloud Storage where your data pipeline can still access it, even when the pipeline is running on the remote TPU node.\n\n<Tip>\n\nIf you can fit all your data in memory as `np.ndarray` or `tf.Tensor`, then you can `fit()` on that data even when using Colab or a TPU Node, without needing to upload it to Google Cloud Storage.\n\n</Tip>\n\n<Tip>\n\n**\ud83e\udd17Specific Hugging Face Tip\ud83e\udd17:** The methods `Dataset.to_tf_dataset()` and its higher-level wrapper `model.prepare_tf_dataset()` , which you will see throughout our TF code examples, will both fail on a TPU Node. The reason for this is that even though they create a `tf.data.Dataset` it is not a \u201cpure\u201d `tf.data` pipeline and uses `tf.numpy_function` or `Dataset.from_generator()` to stream data from the underlying HuggingFace `Dataset`. This HuggingFace `Dataset` is backed by data that is on a local disc and which the remote TPU Node will not be able to read.\n\n</Tip>\n\nThe second way to access a TPU is via a **TPU VM.** When using a TPU VM, you connect directly to the machine that the TPU is attached to, much like training on a GPU VM. TPU VMs are generally easier to work with, particularly when it comes to your data pipeline. All of the above warnings do not apply to TPU VMs!\n\nThis is an opinionated document, so here\u2019s our opinion: **Avoid using TPU Node if possible.** It is more confusing and more difficult to debug than TPU VMs. It is also likely to be unsupported in future - Google\u2019s latest TPU, TPUv4, can only be accessed as a TPU VM, which suggests that TPU Nodes are increasingly going to become a \u201clegacy\u201d access method. However, we understand that the only free TPU access is on Colab and Kaggle Kernels, which uses TPU Node - so we\u2019ll try to explain how to handle it if you have to! Check the [TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) for code samples that explain this in more detail.\n\n### What sizes of TPU are available?\n\nA single TPU (a v2-8/v3-8/v4-8) runs 8 replicas. TPUs exist in **pods** that can run hundreds or thousands of replicas simultaneously. When you use more than a single TPU but less than a whole pod (for example, a v3-32), your TPU fleet is referred to as a **pod slice.**\n\nWhen you access a free TPU via Colab, you generally get a single v2-8 TPU.\n\n### I keep hearing about this XLA thing. What\u2019s XLA, and how does it relate to TPUs?\n\nXLA is an optimizing compiler, used by both TensorFlow and JAX. In JAX it is the only compiler, whereas in TensorFlow it is optional\n    ```",
            "vector_context": "[Created at: 2025-03-24 13:16:13]\nChoosing a metric for your task\n\n**So you've trained your model and want to see how well it\u2019s doing on a dataset of your choice. Where do you start?**\n\nThere is no \u201cone size fits all\u201d approach to choosing an evaluation metric, but some good guidelines to keep in mind are:\n\n## Categories of metrics\n\nThere are 3 high-level categories of metrics:\n\n1. *Generic metrics*, which can be applied to a variety of situations and datasets, such as precision and accuracy.\n2. *Task-specific metrics*, which are limited to a given task, such as Machine Translation (often evaluated using metrics [BLEU](https://huggingface.co/metrics/bleu) or [ROUGE](https://huggingface.co/metrics/rouge)) or Named Entity Recognition (often evaluated with [seqeval](https://huggingface.co/metrics/seqeval)).\n3. *Dataset-specific metrics*, which aim to measure model performance on specific benchmarks: for instance, the [GLUE benchmark](https://huggingface.co/datasets/glue) has a dedicated [evaluation metric](https://huggingface.co/metrics/glue).\n\nLet's look at each of these three cases:\n\n### Generic metrics\n\nMany of the metrics used in the Machine Learning community are quite generic and can be applied in a variety of tasks and datasets.\n\nThis is the case for metrics like [accuracy](https://huggingface.co/metrics/accuracy) and [precision](https://huggingface.co/metrics/precision), which can be used for evaluating labeled (supervised) datasets, as well as [perplexity](https://huggingface.co/metrics/perplexity), which can be used for evaluating different kinds of (unsupervised) generative tasks.\n\nTo see the input structure of a given metric, you can look at its metric card. For example, in the case of [precision](https://huggingface.co/metrics/precision), the format is:\n```\n>>> precision_metric = evaluate.load(\"precision\")\n>>> results = precision_metric.compute(references=[0, 1], predictions=[0, 1])\n>>> print(results)\n{'precision': 1.0}\n```\n\n### Task-specific metrics\n\nPopular ML tasks like Machine Translation and Named Entity Recognition have specific metrics that can be used to compare models. For example, a series of different metrics have been proposed for text generation, ranging from [BLEU](https://huggingface.co/metrics/bleu) and its derivatives such as [GoogleBLEU](https://huggingface.co/metrics/google_bleu) and [GLEU](https://huggingface.co/metrics/gleu), but also [ROUGE](https://huggingface.co/metrics/rouge), [MAUVE](https://huggingface.co/metrics/mauve), etc.\n\nYou can find the right metric for your task by:\n\n- **Looking at the [Task pages](https://huggingface.co/tasks)** to see what metrics can be used for evaluating models for a given task.\n- **Checking out leaderboards** on sites like [Papers With Code](https://paperswithcode.com/) (you can search by task and by dataset).\n-  **Reading the metric cards** for the relevant metrics and see which ones are a good fit for your use case. For example, see the [BLEU metric card](https://github.com/huggingface/evaluate/tree/main/metrics/bleu) or [SQuaD metric card](https://github.com/huggingface/evaluate/tree/main/metrics/squad).\n- **Looking at papers and blog posts** published on the topic and see what metrics they report. This can change over time, so try to pick papers from the last couple of years!\n\n### Dataset-specific metrics\n\nSome datasets have specific metrics associated with them -- this is especially in the case of popular benchmarks like [GLUE](https://huggingface.co/metrics/glue) and [SQuAD](https://huggingface.co/metrics/squad).\n\n<Tip warning={true}>\n\ud83d\udca1\nGLUE is actually a collection of different subsets on different tasks, so first you need to choose the one that corresponds to the NLI task, such as mnli, which is described as \u201ccrowdsourced collection of sentence pairs with textual entailment annotations\u201d\n</Tip>\n\n\nIf you are evaluating your model on a benchmark dataset like the ones mentioned above, you can use its dedicated evaluation metric. Make sure you respect the format that they require. For example, to evaluate your model on the [SQuAD](https://huggingface.co/datasets/squad) dataset, you need to feed the `question` and `context` into your model and return the `prediction_text`, which should be compared with the `references` (based on matching the `id` of the question) :\n\n```\n>>> from evaluate import load\n>>> squad_metric = load(\"squad\")\n>>> predictions = [{'prediction_text': '1976', 'id': '56e10a3be3433e1400422b22'}]\n>>> references = [{'answers': {'answer_start': [97], 'text': ['1976']}, 'id': '56e10a3be3433e1400422b22'}]\n>>> results = squad_metric.compute(predictions=predictions, references=references)\n>>> results\n{'exact_match': 100.0, 'f1': 100.0}\n```\n\nYou can find examples of dataset structures by consulting the \"Dataset Preview\" function or the dataset card for a given dataset, and you can see how to use its dedicated evaluation function based on the metric card.\n--New Chunk--\n[Created at: 2025-03-24 13:16:13]\n=predictions, references=references)\n>>> results\n{'exact_match': 100.0, 'f1': 100.0}\n```\n\nYou can find examples of dataset structures by consulting the \"Dataset Preview\" function or the dataset card for a given dataset, and you can see how to use its dedicated evaluation function based on the metric card.\n--New Chunk--\n[Created at: 2025-03-24 13:17:32]\n(for example, a v3-32), your TPU fleet is referred to as a **pod slice.**\n\nWhen you access a free TPU via Colab, you generally get a single v2-8 TPU.\n\n### I keep hearing about this XLA thing. What\u2019s XLA, and how does it relate to TPUs?\n\nXLA is an optimizing compiler, used by both TensorFlow and JAX. In JAX it is the only compiler, whereas in TensorFlow it is optional (but mandatory on TPU!). The easiest way to enable it when training a Keras model is to pass the argument `jit_compile=True` to `model.compile()`. If you don\u2019t get any errors and performance is good, that\u2019s a great sign that you\u2019re ready to move to TPU!\n\nDebugging on TPU is generally a bit harder than on CPU/GPU, so we recommend getting your code running on CPU/GPU with XLA first before trying it on TPU. You don\u2019t have to train for long, of course - just for a few steps to make sure that your model and data pipeline are working like you expect them to.\n\n<Tip>\n\nXLA compiled code is usually faster - so even if you\u2019re not planning to run on TPU, adding `jit_compile=True` can improve your performance. Be sure to note the caveats below about XLA compatibility, though!\n\n</Tip>\n\n<Tip warning={true}>\n\n**Tip born of painful experience:** Although using `jit_compile=True` is a good way to get a speed boost and test if your CPU/GPU code is XLA-compatible, it can actually cause a lot of problems if you leave it in when actually training on TPU. XLA compilation will happen implicitly on TPU, so remember to remove that line before actually running your code on a TPU!\n\n</Tip>\n\n### How do I make my model XLA compatible?\n\nIn many cases, your code is probably XLA-compatible already! However, there are a few things that work in normal TensorFlow that don\u2019t work in XLA. We\u2019ve distilled them into three core rules below:\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** We\u2019ve put a lot of effort into rewriting our TensorFlow models and loss functions to be XLA-compatible. Our models and loss functions generally obey rule #1 and #2 by default, so you can skip over them if you\u2019re using `transformers` models. Don\u2019t forget about these rules when writing your own models and loss functions, though!\n\n</Tip>\n\n#### XLA Rule #1: Your code cannot have \u201cdata-dependent conditionals\u201d\n\nWhat that means is that any `if` statement cannot depend on values inside a `tf.Tensor`. For example, this code block cannot be compiled with XLA!\n\n```python\nif tf.reduce_sum(tensor) > 10:\n    tensor = tensor / 2.0\n```\n\nThis might seem very restrictive at first, but most neural net code doesn\u2019t need to do this. You can often get around this restriction by using `tf.cond` (see the documentation [here](https://www.tensorflow.org/api_docs/python/tf/cond)) or by removing the conditional and finding a clever math trick with indicator variables instead, like so:\n\n```python\nsum_over_10 = tf.cast(tf.reduce_sum(tensor) > 10, tf.float32)\ntensor = tensor / (1.0 + sum_over_10)\n```\n\nThis code has exactly the same effect as the code above, but by avoiding a conditional, we ensure it will compile with XLA without problems!\n\n#### XLA Rule #2: Your code cannot have \u201cdata-dependent shapes\u201d\n\nWhat this means is that the shape of all of the `tf.Tensor` objects in your code cannot depend on their values. For example, the function `tf.unique` cannot be compiled with XLA, because it returns a `tensor` containing one instance of each unique value in the input. The shape of this output will obviously be different depending on how repetitive the input `Tensor` was, and so XLA refuses to handle it!\n\nIn general, most neural network code obeys rule #2 by default. However, there are a few common cases where it becomes a problem. One very common one is when you use **label masking**, setting your labels to a negative value to indicate that those positions should be ignored when computing the loss. If you look at NumPy or PyTorch loss functions that support label masking, you will often see code like this that uses [boolean indexing](https://numpy.org/doc/stable/user/basics.indexing.html#boolean-array-indexing):\n\n```python\nlabel_mask = labels >= 0\nmasked_outputs = outputs[label_mask]\nmasked_labels = labels[label_mask]\nloss = compute_loss(masked_outputs, masked_labels)\nmean_loss = torch.mean(loss)\n```\n\nThis code is totally fine in NumPy or PyTorch, but it breaks in XLA! Why? Because the shape of `masked_outputs` and `masked_labels` depends on how many positions are masked - that makes it a **data-dependent shape.** However, just like for rule #1, we can often rewrite this code to yield exactly the same output without any data-dependent shapes.\n\n```python\nlabel_mask = tf.cast(labels >= 0, tf.float32)\nloss = compute_loss(outputs, labels)\nloss = loss * label_mask  # Set negative label positions to 0\nmean_loss = tf.reduce_sum(loss) / tf.reduce_sum(label_mask)\n```\n\nHere, we avoid data-dependent shapes by computing the loss for every position, but zeroing out the masked positions in both the numerator and denominator when we calculate the mean, which yields exactly the same result as the first block while maintaining XLA compatibility. Note that we use the same trick as in rule #1 - converting a `tf.bool` to `"
        }
    },
    {
        "sample_idx": 132,
        "question": "What is the image size of the model?",
        "answer": "224",
        "rag_answer": "Based on the provided information, the image size of the model can be controlled when constructing the `Image` component. For example, you can specify the `shape` parameter to set the image size. Here's an example:\n```py\nimg = gr.Image(shape=(100, 100), type=\"pil\")\n```\nIn this case, the image size is set to `(100, 100)` pixels. You can adjust this parameter to change the image size according to your needs.\n\nAdditionally, you can also specify the `invert_colors` parameter to control the image processing. For instance:\n```py\nimg = gr.Image(invert_colors=True, type=\"numpy\")\n```\nThis will invert the colors of the image before processing it as a numpy array.\n\nPlease note that the image size and processing parameters can be adjusted based on your specific use case and requirements.\n\nReferences:\n[KG] Gradio organization, Gradio documentation (https://gradio.app/docs)\n[DC] Document Chunk, Preprocessing and Postprocessing (https://example.com/preprocessing-postprocessing)",
        "rag_score": 1,
        "rag_feedback": "The system's response is completely incorrect, inaccurate, and/or not factual. The question asks about the image size of the model, but the response provides a lengthy and irrelevant text about Gradio, a platform for building and deploying machine learning models, including information about preprocessing, postprocessing, styling, queuing, and iterative outputs.",
        "rag_context": {
            "kg_context": "-----Entities-----\n    ```csv\n    id,\tentity,\ttype,\tdescription,\trankcreated_at\n1,\tGradio,organization,Gradio is a platform that supports state in Blocks, providing features such as global state and session state.<SEP>Gradio is an interface that provides various features for demonstrating models, including adding example inputs, custom error messages, descriptive content, flagging, and more.<SEP>Gradio is an organization that provides a platform for building and deploying machine learning models.<SEP>Gradio is an organization that provides a platform for creating and deploying machine learning models.<SEP>Gradio is an organization that provides a demo for blocks_random_slider, and its library is used to create interactive interfaces.,36,2025-03-24 13:18:20\n2,\tImage,category,Image is a category of data type that can be processed by Gradio components.,1,2025-03-24 13:18:20\n3,\tMachine Learning,category,Machine Learning is a field of study that involves training models to make predictions.,5,2025-03-24 13:18:20\n4,\tModel,category,Model refers to a machine learning model being evaluated.,3,2025-03-24 13:18:20\n5,\tKeras,category,Keras is a high-level neural networks API, used for building and training neural networks.<SEP>Keras is a machine learning framework that uses XLA for optimization.,2,2025-03-24 13:18:20\n6,\tXLA,technology,XLA is a technology that compiles TensorFlow graphs into executable code for various platforms.<SEP>XLA is an optimizing compiler used by TensorFlow and JAX to improve performance.<SEP>XLA is an optimizing compiler, used by both TensorFlow and JAX to optimize computations.,6,2025-03-24 13:18:20\n7,\tImage,category,Image is a category of data type that can be processed by Gradio components.,1,UNKNOWN\n8,\tResults,event,Results are the outcome of evaluating a model, in this case, showing perfect accuracy.,1,UNKNOWN\n9,\tModel,category,Model refers to a machine learning model being evaluated.,3,UNKNOWN\n    ```\n    -----Relationships-----\n    ```csv\n    id,\tsource,\ttarget,\tdescription,\tkeywords,\tweight,\trank,\tcreated_at\n1,\tGradio,Image,Gradio provides components that can process Image data types.,data processing, image handling,16.0,37,2025-03-24 13:17:31\n2,\tMachine Learning,Model,Machine Learning involves training models to make predictions.,field of study, model training,9.0,8,2025-03-24 13:16:48\n3,\tKeras,XLA,Keras uses XLA for optimization.,compiler, performance optimization,8.0,8,2025-03-24 13:18:20\n4,\tGradio,Image,Gradio provides components that can process Image data types.,data processing, image handling,16.0,37,UNKNOWN\n5,\tMachine Learning,Model,Machine Learning involves training models to make predictions.,field of study, model training,9.0,8,UNKNOWN\n6,\tEvaluation Function,Model,The evaluation function is used to assess the performance of the model.,model evaluation, performance assessment,18.0,5,UNKNOWN\n7,\tModel,Predictions,The model makes predictions based on the input data.,model output, predictions,8.0,5,UNKNOWN\n8,\tEvaluation Function,Results,The results are obtained by using the evaluation function.,evaluation outcome, accuracy,20.0,3,UNKNOWN\n    ```\n    -----Sources-----\n    ```csv\n    id,\tcontent\n1,\t\u65f6\u5fc5\u987b\u9009\u62e9\u5176\u4e2d\u4e00\u4e2a\u5b57\u7b26\u4e32\uff0c\u8fd9\u5c06\u4f5c\u4e3a\u9644\u52a0\u5217\u4fdd\u5b58\u5230 CSV \u4e2d\u3002\n\n## \u9884\u5904\u7406\u548c\u540e\u5904\u7406 (Preprocessing and Postprocessing)\n\n![annotated](/assets/img/dataflow.svg)\n\n\u5982\u60a8\u6240\u89c1\uff0cGradio \u5305\u62ec\u53ef\u4ee5\u5904\u7406\u5404\u79cd\u4e0d\u540c\u6570\u636e\u7c7b\u578b\u7684\u7ec4\u4ef6\uff0c\u4f8b\u5982\u56fe\u50cf\u3001\u97f3\u9891\u548c\u89c6\u9891\u3002\u5927\u591a\u6570\u7ec4\u4ef6\u90fd\u53ef\u4ee5\u7528\u4f5c\u8f93\u5165\u6216\u8f93\u51fa\u3002\n\n\u5f53\u7ec4\u4ef6\u7528\u4f5c\u8f93\u5165\u65f6\uff0cGradio \u81ea\u52a8\u5904\u7406*\u9884\u5904\u7406*\uff0c\u5c06\u6570\u636e\u4ece\u7528\u6237\u6d4f\u89c8\u5668\u53d1\u9001\u7684\u7c7b\u578b\uff08\u4f8b\u5982\u7f51\u7edc\u6444\u50cf\u5934\u5feb\u7167\u7684 base64 \u8868\u793a\uff09\u8f6c\u6362\u4e3a\u60a8\u7684\u51fd\u6570\u53ef\u4ee5\u63a5\u53d7\u7684\u5f62\u5f0f\uff08\u4f8b\u5982 `numpy` \u6570\u7ec4\uff09\u3002\n\n\u540c\u6837\uff0c\u5f53\u7ec4\u4ef6\u7528\u4f5c\u8f93\u51fa\u65f6\uff0cGradio \u81ea\u52a8\u5904\u7406*\u540e\u5904\u7406*\uff0c\u5c06\u6570\u636e\u4ece\u51fd\u6570\u8fd4\u56de\u7684\u5f62\u5f0f\uff08\u4f8b\u5982\u56fe\u50cf\u8def\u5f84\u5217\u8868\uff09\u8f6c\u6362\u4e3a\u53ef\u4ee5\u5728\u7528\u6237\u6d4f\u89c8\u5668\u4e2d\u663e\u793a\u7684\u5f62\u5f0f\uff08\u4f8b\u5982\u4ee5 base64 \u683c\u5f0f\u663e\u793a\u56fe\u50cf\u7684 `Gallery`\uff09\u3002\n\n\u60a8\u53ef\u4ee5\u4f7f\u7528\u6784\u5efa\u56fe\u50cf\u7ec4\u4ef6\u65f6\u7684\u53c2\u6570\u63a7\u5236*\u9884\u5904\u7406*\u3002\u4f8b\u5982\uff0c\u5982\u679c\u60a8\u4f7f\u7528\u4ee5\u4e0b\u53c2\u6570\u5b9e\u4f8b\u5316 `Image` \u7ec4\u4ef6\uff0c\u5b83\u5c06\u5c06\u56fe\u50cf\u8f6c\u6362\u4e3a `PIL` \u7c7b\u578b\uff0c\u5e76\u5c06\u5176\u91cd\u5851\u4e3a`(100, 100)`\uff0c\u800c\u4e0d\u7ba1\u63d0\u4ea4\u65f6\u7684\u539f\u59cb\u5927\u5c0f\u5982\u4f55\uff1a\n\n```py\nimg = gr.Image(shape=(100, 100), type=\"pil\")\n```\n\n\u76f8\u53cd\uff0c\u8fd9\u91cc\u6211\u4eec\u4fdd\u7559\u56fe\u50cf\u7684\u539f\u59cb\u5927\u5c0f\uff0c\u4f46\u5728\u5c06\u5176\u8f6c\u6362\u4e3a numpy \u6570\u7ec4\u4e4b\u524d\u53cd\u8f6c\u989c\u8272\uff1a\n\n```py\nimg = gr.Image(invert_colors=True, type=\"numpy\")\n```\n\n\u540e\u5904\u7406\u8981\u5bb9\u6613\u5f97\u591a\uff01Gradio \u81ea\u52a8\u8bc6\u522b\u8fd4\u56de\u6570\u636e\u7684\u683c\u5f0f\uff08\u4f8b\u5982 `Image` \u662f `numpy` \u6570\u7ec4\u8fd8\u662f `str` \u6587\u4ef6\u8def\u5f84\uff1f\uff09\uff0c\u5e76\u5c06\u5176\u540e\u5904\u7406\u4e3a\u53ef\u4ee5\u7531\u6d4f\u89c8\u5668\u663e\u793a\u7684\u683c\u5f0f\u3002\n\n\u8bf7\u67e5\u770b[\u6587\u6863](https://gradio.app/docs)\uff0c\u4e86\u89e3\u6bcf\u4e2a\u7ec4\u4ef6\u7684\u6240\u6709\u4e0e\u9884\u5904\u7406\u76f8\u5173\u7684\u53c2\u6570\u3002\n\n## \u6837\u5f0f (Styling)\n\nGradio \u4e3b\u9898\u662f\u81ea\u5b9a\u4e49\u5e94\u7528\u7a0b\u5e8f\u5916\u89c2\u548c\u611f\u89c9\u7684\u6700\u7b80\u5355\u65b9\u6cd5\u3002\u60a8\u53ef\u4ee5\u9009\u62e9\u591a\u79cd\u4e3b\u9898\u6216\u521b\u5efa\u81ea\u5df1\u7684\u4e3b\u9898\u3002\u8981\u8fd9\u6837\u505a\uff0c\u8bf7\u5c06 `theme=` \u53c2\u6570\u4f20\u9012\u7ed9 `Interface` \u6784\u9020\u51fd\u6570\u3002\u4f8b\u5982\uff1a\n\n```python\ndemo = gr.Interface(..., theme=gr.themes.Monochrome())\n```\n\nGradio \u5e26\u6709\u4e00\u7ec4\u9884\u5148\u6784\u5efa\u7684\u4e3b\u9898\uff0c\u60a8\u53ef\u4ee5\u4ece `gr.themes.*` \u52a0\u8f7d\u3002\u60a8\u53ef\u4ee5\u6269\u5c55\u8fd9\u4e9b\u4e3b\u9898\u6216\u4ece\u5934\u5f00\u59cb\u521b\u5efa\u81ea\u5df1\u7684\u4e3b\u9898 - \u6709\u5173\u66f4\u591a\u8be6\u7ec6\u4fe1\u606f\uff0c\u8bf7\u53c2\u9605[\u4e3b\u9898\u6307\u5357](https://gradio.app/theming-guide)\u3002\n\n\u8981\u589e\u52a0\u989d\u5916\u7684\u6837\u5f0f\u80fd\u529b\uff0c\u60a8\u53ef\u4ee5 with `css=` \u5173\u952e\u5b57\u5c06\u4efb\u4f55 CSS \u4f20\u9012\u7ed9\u60a8\u7684\u5e94\u7528\u7a0b\u5e8f\u3002\nGradio \u5e94\u7528\u7a0b\u5e8f\u7684\u57fa\u7c7b\u662f `gradio-container`\uff0c\u56e0\u6b64\u4ee5\u4e0b\u662f\u4e00\u4e2a\u66f4\u6539 Gradio \u5e94\u7528\u7a0b\u5e8f\u80cc\u666f\u989c\u8272\u7684\u793a\u4f8b\uff1a\n\n```python\nwith `gr.Interface(css=\".gradio-container {background-color: red}\") as demo:\n    ...\n```\n\n## \u961f\u5217 (Queuing)\n\n\u5982\u679c\u60a8\u7684\u5e94\u7528\u7a0b\u5e8f\u9884\u8ba1\u4f1a\u6709\u5927\u91cf\u6d41\u91cf\uff0c\u8bf7 with `queue()` \u65b9\u6cd5\u6765\u63a7\u5236\u5904\u7406\u901f\u7387\u3002\u8fd9\u5c06\u6392\u961f\u5904\u7406\u8c03\u7528\uff0c\u56e0\u6b64\u4e00\u6b21\u53ea\u5904\u7406\u4e00\u5b9a\u6570\u91cf\u7684\u8bf7\u6c42\u3002\u961f\u5217\u4f7f\u7528 Websockets\uff0c\u8fd8\u53ef\u4ee5\u9632\u6b62\u7f51\u7edc\u8d85\u65f6\uff0c\u56e0\u6b64\u5982\u679c\u60a8\u7684\u51fd\u6570\u7684\u63a8\u7406\u65f6\u95f4\u5f88\u957f\uff08> 1 \u5206\u949f\uff09\uff0c\u5e94\u4f7f\u7528\u961f\u5217\u3002\n\nwith `Interface`\uff1a\n\n```python\ndemo = gr.Interface(...).queue()\ndemo.launch()\n```\n\nwith `Blocks`\uff1a\n\n```python\nwith gr.Blocks() as demo\uff1a\n    #...\ndemo.queue()\ndemo.launch()\n```\n\n\u60a8\u53ef\u4ee5\u901a\u8fc7\u4ee5\u4e0b\u65b9\u5f0f\u63a7\u5236\u4e00\u6b21\u5904\u7406\u7684\u8bf7\u6c42\u6570\u91cf\uff1a\n\n```python\ndemo.queue(concurrency_count=3)\n```\n\n\u67e5\u770b\u6709\u5173\u914d\u7f6e\u5176\u4ed6\u961f\u5217\u53c2\u6570\u7684[\u961f\u5217\u6587\u6863](/docs/#queue)\u3002\n\n\u5728 Blocks \u4e2d\u6307\u5b9a\u4ec5\u5bf9\u67d0\u4e9b\u51fd\u6570\u8fdb\u884c\u6392\u961f\uff1a\n\n```python\nwith gr.Blocks() as demo2\uff1a\n    num1 = gr.Number()\n    num2 = gr.Number()\n    output = gr.Number()\n    gr.Button(\"Add\").click(\n        lambda a, b: a + b, [num1, num2], output)\n    gr.Button(\"Multiply\").click(\n        lambda a, b: a * b, [num1, num2], output, queue=True)\ndemo2.launch()\n```\n\n## \u8fed\u4ee3\u8f93\u51fa (Iterative Outputs)\n\n\u5728\u67d0\u4e9b\u60c5\u51b5\u4e0b\uff0c\u60a8\u53ef\u80fd\u9700\u8981\u4f20\u8f93\u4e00\u7cfb\u5217\u8f93\u51fa\u800c\u4e0d\u662f\u4e00\u6b21\u663e\u793a\u5355\u4e2a\u8f93\u51fa\u3002\u4f8b\u5982\uff0c\u60a8\u53ef\u80fd\u6709\u4e00\u4e2a\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5e0c\u671b\u663e\u793a\u751f\u6210\u7684\u6bcf\u4e2a\u6b65\u9aa4\u7684\u56fe\u50cf\uff0c\u76f4\u5230\u6700\u7ec8\u56fe\u50cf\u3002\u6216\u8005\u60a8\u53ef\u80fd\u6709\u4e00\u4e2a\u804a\u5929\u673a\u5668\u4eba\uff0c\u5b83\u9010\u5b57\u9010\u53e5\u5730\u6d41\u5f0f\u4f20\u8f93\u54cd\u5e94\uff0c\u800c\u4e0d\u662f\u4e00\u6b21\u8fd4\u56de\u5168\u90e8\u54cd\u5e94\u3002\n\n\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u60a8\u53ef\u4ee5\u5c06**\u751f\u6210\u5668**\u51fd\u6570\u63d0\u4f9b\u7ed9 Gradio\uff0c\u800c\u4e0d\u662f\u5e38\u89c4\u51fd\u6570\u3002\u5728 Python \u4e2d\u521b\u5efa\u751f\u6210\u5668\u975e\u5e38\u7b80\u5355\uff1a\u51fd\u6570\u4e0d\u5e94\u8be5\u6709\u4e00\u4e2a\u5355\u72ec\u7684 `return` \u503c\uff0c\u800c\u662f\u5e94\u8be5 with `yield` \u8fde\u7eed\u8fd4\u56de\u4e00\u7cfb\u5217\u503c\u3002\u901a\u5e38\uff0c`yield` \u8bed\u53e5\u653e\u7f6e\u5728\u67d0\u79cd\u5faa\u73af\u4e2d\u3002\u4e0b\u9762\u662f\u4e00\u4e2a\u7b80\u5355\u793a\u4f8b\uff0c\u751f\u6210\u5668\u53ea\u662f\u7b80\u5355\u8ba1\u6570\u5230\u7ed9\u5b9a\u6570\u5b57\uff1a\n\n```python\ndef my_generator(x):\n    for i in range(x):\n        yield i\n```\n\n\u60a8\u4ee5\u4e0e\u5e38\u89c4\u51fd\u6570\u76f8\u540c\u7684\u65b9\u5f0f\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio\u3002\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\uff08\u865a\u62df\u7684\uff09\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5b83\u5728\u8f93\u51fa\u56fe\u50cf\u4e4b\u524d\u751f\u6210\u6570\u4e2a\u6b65\u9aa4\u7684\u566a\u97f3\uff1a\n\n$code_fake_diffusion\n$demo_fake_diffusion\n\n\u8bf7\u6ce8\u610f\uff0c\u6211\u4eec\u5728\u8fed\u4ee3\u5668\u4e2d\u6dfb\u52a0\u4e86 `time.sleep(1)`\uff0c\u4ee5\u521b\u5efa\u6b65\u9aa4\u4e4b\u95f4\u7684\u4eba\u5de5\u6682\u505c\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u89c2\u5bdf\u8fed\u4ee3\u5668\u7684\u6b65\u9aa4\uff08\u5728\u771f\u5b9e\u7684\u56fe\u50cf\u751f\u6210\u6a21\u578b\u4e2d\uff0c\u8fd9\n2,\t=predictions, references=references)\n>>> results\n{'exact_match': 100.0, 'f1': 100.0}\n```\n\nYou can find examples of dataset structures by consulting the \"Dataset Preview\" function or the dataset card for a given dataset, and you can see how to use its dedicated evaluation function based on the metric card.\n3,\t(for example, a v3-32), your TPU fleet is referred to as a **pod slice.**\n\nWhen you access a free TPU via Colab, you generally get a single v2-8 TPU.\n\n### I keep hearing about this XLA thing. What\u2019s XLA, and how does it relate to TPUs?\n\nXLA is an optimizing compiler, used by both TensorFlow and JAX. In JAX it is the only compiler, whereas in TensorFlow it is optional (but mandatory on TPU!). The easiest way to enable it when training a Keras model is to pass the argument `jit_compile=True` to `model.compile()`. If you don\u2019t get any errors and performance is good, that\u2019s a great sign that you\u2019re ready to move to TPU!\n\nDebugging on TPU is generally a bit harder than on CPU/GPU, so we recommend getting your code running on CPU/GPU with XLA first before trying it on TPU. You don\u2019t have to train for long, of course - just for a few steps to make sure that your model and data pipeline are working like you expect them to.\n\n<Tip>\n\nXLA compiled code is usually faster - so even if you\u2019re not planning to run on TPU, adding `jit_compile=True` can improve your performance. Be sure to note the caveats below about XLA compatibility, though!\n\n</Tip>\n\n<Tip warning={true}>\n\n**Tip born of painful experience:** Although using `jit_compile=True` is a good way to get a speed boost and test if your CPU/GPU code is XLA-compatible, it can actually cause a lot of problems if you leave it in when actually training on TPU. XLA compilation will happen implicitly on TPU, so remember to remove that line before actually running your code on a TPU!\n\n</Tip>\n\n### How do I make my model XLA compatible?\n\nIn many cases, your code is probably XLA-compatible already! However, there are a few things that work in normal TensorFlow that don\u2019t work in XLA. We\u2019ve distilled them into three core rules below:\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** We\u2019ve put a lot of effort into rewriting our TensorFlow models and loss functions to be XLA-compatible. Our models and loss functions generally obey rule #1 and #2 by default, so you can skip over them if you\u2019re using `transformers` models. Don\u2019t forget about these rules when writing your own models and loss functions, though!\n\n</Tip>\n\n#### XLA Rule #1: Your code cannot have \u201cdata-dependent conditionals\u201d\n\nWhat that means is that any `if` statement cannot depend on values inside a `tf.Tensor`. For example, this code block cannot be compiled with XLA!\n\n```python\nif tf.reduce_sum(tensor) > 10:\n    tensor = tensor / 2.0\n```\n\nThis might seem very restrictive at first, but most neural net code doesn\u2019t need to do this. You can often get around this restriction by using `tf.cond` (see the documentation [here](https://www.tensorflow.org/api_docs/python/tf/cond)) or by removing the conditional and finding a clever math trick with indicator variables instead, like so:\n\n```python\nsum_over_10 = tf.cast(tf.reduce_sum(tensor) > 10, tf.float32)\ntensor = tensor / (1.0 + sum_over_10)\n```\n\nThis code has exactly the same effect as the code above, but by avoiding a conditional, we ensure it will compile with XLA without problems!\n\n#### XLA Rule #2: Your code cannot have \u201cdata-dependent shapes\u201d\n\nWhat this means is that the shape of all of the `tf.Tensor` objects in your code cannot depend on their values. For example, the function `tf.unique` cannot be compiled with XLA, because it returns a `tensor` containing one instance of each unique value in the input. The shape of this output will obviously be different depending on how repetitive the input `Tensor` was, and so XLA refuses to handle it!\n\nIn general, most neural network code obeys rule #2 by default. However, there are a few common cases where it becomes a problem. One very common one is when you use **label masking**, setting your labels to a negative value to indicate that those positions should be ignored when computing the loss. If you look at NumPy or PyTorch loss functions that support label masking, you will often see code like this that uses [boolean indexing](https://numpy.org/doc/stable/user/basics.indexing.html#boolean-array-indexing):\n\n```python\nlabel_mask = labels >= 0\nmasked_outputs = outputs[label_mask]\nmasked_labels = labels[label_mask]\nloss = compute_loss(masked_outputs, masked_labels)\nmean_loss = torch.mean(loss)\n```\n\nThis code is totally fine in NumPy or PyTorch, but it breaks in XLA! Why? Because the shape of `masked_outputs` and `masked_labels` depends on how many positions are masked - that makes it a **data-dependent shape.** However, just like for rule #1, we can often rewrite this code to yield exactly the same output without any data-dependent shapes.\n\n```python\nlabel_mask = tf.cast(labels >= 0, tf.float32)\nloss = compute_loss(outputs, labels)\nloss = loss * label_mask  # Set negative label positions to 0\nmean_loss = tf.reduce_sum(loss) / tf.reduce_sum(label_mask)\n```\n\nHere, we avoid data-dependent shapes by computing the loss for every position, but zeroing out the masked positions in both the numerator and denominator when we calculate the mean, which yields exactly the same result as the first block while maintaining XLA compatibility. Note that we use the same trick as in rule #1 - converting a `tf.bool` to `\n    ```",
            "vector_context": "[Created at: 2025-03-24 13:16:13]\n=predictions, references=references)\n>>> results\n{'exact_match': 100.0, 'f1': 100.0}\n```\n\nYou can find examples of dataset structures by consulting the \"Dataset Preview\" function or the dataset card for a given dataset, and you can see how to use its dedicated evaluation function based on the metric card.\n--New Chunk--\n[Created at: 2025-03-24 13:16:48]\n\u65f6\u5fc5\u987b\u9009\u62e9\u5176\u4e2d\u4e00\u4e2a\u5b57\u7b26\u4e32\uff0c\u8fd9\u5c06\u4f5c\u4e3a\u9644\u52a0\u5217\u4fdd\u5b58\u5230 CSV \u4e2d\u3002\n\n## \u9884\u5904\u7406\u548c\u540e\u5904\u7406 (Preprocessing and Postprocessing)\n\n![annotated](/assets/img/dataflow.svg)\n\n\u5982\u60a8\u6240\u89c1\uff0cGradio \u5305\u62ec\u53ef\u4ee5\u5904\u7406\u5404\u79cd\u4e0d\u540c\u6570\u636e\u7c7b\u578b\u7684\u7ec4\u4ef6\uff0c\u4f8b\u5982\u56fe\u50cf\u3001\u97f3\u9891\u548c\u89c6\u9891\u3002\u5927\u591a\u6570\u7ec4\u4ef6\u90fd\u53ef\u4ee5\u7528\u4f5c\u8f93\u5165\u6216\u8f93\u51fa\u3002\n\n\u5f53\u7ec4\u4ef6\u7528\u4f5c\u8f93\u5165\u65f6\uff0cGradio \u81ea\u52a8\u5904\u7406*\u9884\u5904\u7406*\uff0c\u5c06\u6570\u636e\u4ece\u7528\u6237\u6d4f\u89c8\u5668\u53d1\u9001\u7684\u7c7b\u578b\uff08\u4f8b\u5982\u7f51\u7edc\u6444\u50cf\u5934\u5feb\u7167\u7684 base64 \u8868\u793a\uff09\u8f6c\u6362\u4e3a\u60a8\u7684\u51fd\u6570\u53ef\u4ee5\u63a5\u53d7\u7684\u5f62\u5f0f\uff08\u4f8b\u5982 `numpy` \u6570\u7ec4\uff09\u3002\n\n\u540c\u6837\uff0c\u5f53\u7ec4\u4ef6\u7528\u4f5c\u8f93\u51fa\u65f6\uff0cGradio \u81ea\u52a8\u5904\u7406*\u540e\u5904\u7406*\uff0c\u5c06\u6570\u636e\u4ece\u51fd\u6570\u8fd4\u56de\u7684\u5f62\u5f0f\uff08\u4f8b\u5982\u56fe\u50cf\u8def\u5f84\u5217\u8868\uff09\u8f6c\u6362\u4e3a\u53ef\u4ee5\u5728\u7528\u6237\u6d4f\u89c8\u5668\u4e2d\u663e\u793a\u7684\u5f62\u5f0f\uff08\u4f8b\u5982\u4ee5 base64 \u683c\u5f0f\u663e\u793a\u56fe\u50cf\u7684 `Gallery`\uff09\u3002\n\n\u60a8\u53ef\u4ee5\u4f7f\u7528\u6784\u5efa\u56fe\u50cf\u7ec4\u4ef6\u65f6\u7684\u53c2\u6570\u63a7\u5236*\u9884\u5904\u7406*\u3002\u4f8b\u5982\uff0c\u5982\u679c\u60a8\u4f7f\u7528\u4ee5\u4e0b\u53c2\u6570\u5b9e\u4f8b\u5316 `Image` \u7ec4\u4ef6\uff0c\u5b83\u5c06\u5c06\u56fe\u50cf\u8f6c\u6362\u4e3a `PIL` \u7c7b\u578b\uff0c\u5e76\u5c06\u5176\u91cd\u5851\u4e3a`(100, 100)`\uff0c\u800c\u4e0d\u7ba1\u63d0\u4ea4\u65f6\u7684\u539f\u59cb\u5927\u5c0f\u5982\u4f55\uff1a\n\n```py\nimg = gr.Image(shape=(100, 100), type=\"pil\")\n```\n\n\u76f8\u53cd\uff0c\u8fd9\u91cc\u6211\u4eec\u4fdd\u7559\u56fe\u50cf\u7684\u539f\u59cb\u5927\u5c0f\uff0c\u4f46\u5728\u5c06\u5176\u8f6c\u6362\u4e3a numpy \u6570\u7ec4\u4e4b\u524d\u53cd\u8f6c\u989c\u8272\uff1a\n\n```py\nimg = gr.Image(invert_colors=True, type=\"numpy\")\n```\n\n\u540e\u5904\u7406\u8981\u5bb9\u6613\u5f97\u591a\uff01Gradio \u81ea\u52a8\u8bc6\u522b\u8fd4\u56de\u6570\u636e\u7684\u683c\u5f0f\uff08\u4f8b\u5982 `Image` \u662f `numpy` \u6570\u7ec4\u8fd8\u662f `str` \u6587\u4ef6\u8def\u5f84\uff1f\uff09\uff0c\u5e76\u5c06\u5176\u540e\u5904\u7406\u4e3a\u53ef\u4ee5\u7531\u6d4f\u89c8\u5668\u663e\u793a\u7684\u683c\u5f0f\u3002\n\n\u8bf7\u67e5\u770b[\u6587\u6863](https://gradio.app/docs)\uff0c\u4e86\u89e3\u6bcf\u4e2a\u7ec4\u4ef6\u7684\u6240\u6709\u4e0e\u9884\u5904\u7406\u76f8\u5173\u7684\u53c2\u6570\u3002\n\n## \u6837\u5f0f (Styling)\n\nGradio \u4e3b\u9898\u662f\u81ea\u5b9a\u4e49\u5e94\u7528\u7a0b\u5e8f\u5916\u89c2\u548c\u611f\u89c9\u7684\u6700\u7b80\u5355\u65b9\u6cd5\u3002\u60a8\u53ef\u4ee5\u9009\u62e9\u591a\u79cd\u4e3b\u9898\u6216\u521b\u5efa\u81ea\u5df1\u7684\u4e3b\u9898\u3002\u8981\u8fd9\u6837\u505a\uff0c\u8bf7\u5c06 `theme=` \u53c2\u6570\u4f20\u9012\u7ed9 `Interface` \u6784\u9020\u51fd\u6570\u3002\u4f8b\u5982\uff1a\n\n```python\ndemo = gr.Interface(..., theme=gr.themes.Monochrome())\n```\n\nGradio \u5e26\u6709\u4e00\u7ec4\u9884\u5148\u6784\u5efa\u7684\u4e3b\u9898\uff0c\u60a8\u53ef\u4ee5\u4ece `gr.themes.*` \u52a0\u8f7d\u3002\u60a8\u53ef\u4ee5\u6269\u5c55\u8fd9\u4e9b\u4e3b\u9898\u6216\u4ece\u5934\u5f00\u59cb\u521b\u5efa\u81ea\u5df1\u7684\u4e3b\u9898 - \u6709\u5173\u66f4\u591a\u8be6\u7ec6\u4fe1\u606f\uff0c\u8bf7\u53c2\u9605[\u4e3b\u9898\u6307\u5357](https://gradio.app/theming-guide)\u3002\n\n\u8981\u589e\u52a0\u989d\u5916\u7684\u6837\u5f0f\u80fd\u529b\uff0c\u60a8\u53ef\u4ee5 with `css=` \u5173\u952e\u5b57\u5c06\u4efb\u4f55 CSS \u4f20\u9012\u7ed9\u60a8\u7684\u5e94\u7528\u7a0b\u5e8f\u3002\nGradio \u5e94\u7528\u7a0b\u5e8f\u7684\u57fa\u7c7b\u662f `gradio-container`\uff0c\u56e0\u6b64\u4ee5\u4e0b\u662f\u4e00\u4e2a\u66f4\u6539 Gradio \u5e94\u7528\u7a0b\u5e8f\u80cc\u666f\u989c\u8272\u7684\u793a\u4f8b\uff1a\n\n```python\nwith `gr.Interface(css=\".gradio-container {background-color: red}\") as demo:\n    ...\n```\n\n## \u961f\u5217 (Queuing)\n\n\u5982\u679c\u60a8\u7684\u5e94\u7528\u7a0b\u5e8f\u9884\u8ba1\u4f1a\u6709\u5927\u91cf\u6d41\u91cf\uff0c\u8bf7 with `queue()` \u65b9\u6cd5\u6765\u63a7\u5236\u5904\u7406\u901f\u7387\u3002\u8fd9\u5c06\u6392\u961f\u5904\u7406\u8c03\u7528\uff0c\u56e0\u6b64\u4e00\u6b21\u53ea\u5904\u7406\u4e00\u5b9a\u6570\u91cf\u7684\u8bf7\u6c42\u3002\u961f\u5217\u4f7f\u7528 Websockets\uff0c\u8fd8\u53ef\u4ee5\u9632\u6b62\u7f51\u7edc\u8d85\u65f6\uff0c\u56e0\u6b64\u5982\u679c\u60a8\u7684\u51fd\u6570\u7684\u63a8\u7406\u65f6\u95f4\u5f88\u957f\uff08> 1 \u5206\u949f\uff09\uff0c\u5e94\u4f7f\u7528\u961f\u5217\u3002\n\nwith `Interface`\uff1a\n\n```python\ndemo = gr.Interface(...).queue()\ndemo.launch()\n```\n\nwith `Blocks`\uff1a\n\n```python\nwith gr.Blocks() as demo\uff1a\n    #...\ndemo.queue()\ndemo.launch()\n```\n\n\u60a8\u53ef\u4ee5\u901a\u8fc7\u4ee5\u4e0b\u65b9\u5f0f\u63a7\u5236\u4e00\u6b21\u5904\u7406\u7684\u8bf7\u6c42\u6570\u91cf\uff1a\n\n```python\ndemo.queue(concurrency_count=3)\n```\n\n\u67e5\u770b\u6709\u5173\u914d\u7f6e\u5176\u4ed6\u961f\u5217\u53c2\u6570\u7684[\u961f\u5217\u6587\u6863](/docs/#queue)\u3002\n\n\u5728 Blocks \u4e2d\u6307\u5b9a\u4ec5\u5bf9\u67d0\u4e9b\u51fd\u6570\u8fdb\u884c\u6392\u961f\uff1a\n\n```python\nwith gr.Blocks() as demo2\uff1a\n    num1 = gr.Number()\n    num2 = gr.Number()\n    output = gr.Number()\n    gr.Button(\"Add\").click(\n        lambda a, b: a + b, [num1, num2], output)\n    gr.Button(\"Multiply\").click(\n        lambda a, b: a * b, [num1, num2], output, queue=True)\ndemo2.launch()\n```\n\n## \u8fed\u4ee3\u8f93\u51fa (Iterative Outputs)\n\n\u5728\u67d0\u4e9b\u60c5\u51b5\u4e0b\uff0c\u60a8\u53ef\u80fd\u9700\u8981\u4f20\u8f93\u4e00\u7cfb\u5217\u8f93\u51fa\u800c\u4e0d\u662f\u4e00\u6b21\u663e\u793a\u5355\u4e2a\u8f93\u51fa\u3002\u4f8b\u5982\uff0c\u60a8\u53ef\u80fd\u6709\u4e00\u4e2a\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5e0c\u671b\u663e\u793a\u751f\u6210\u7684\u6bcf\u4e2a\u6b65\u9aa4\u7684\u56fe\u50cf\uff0c\u76f4\u5230\u6700\u7ec8\u56fe\u50cf\u3002\u6216\u8005\u60a8\u53ef\u80fd\u6709\u4e00\u4e2a\u804a\u5929\u673a\u5668\u4eba\uff0c\u5b83\u9010\u5b57\u9010\u53e5\u5730\u6d41\u5f0f\u4f20\u8f93\u54cd\u5e94\uff0c\u800c\u4e0d\u662f\u4e00\u6b21\u8fd4\u56de\u5168\u90e8\u54cd\u5e94\u3002\n\n\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u60a8\u53ef\u4ee5\u5c06**\u751f\u6210\u5668**\u51fd\u6570\u63d0\u4f9b\u7ed9 Gradio\uff0c\u800c\u4e0d\u662f\u5e38\u89c4\u51fd\u6570\u3002\u5728 Python \u4e2d\u521b\u5efa\u751f\u6210\u5668\u975e\u5e38\u7b80\u5355\uff1a\u51fd\u6570\u4e0d\u5e94\u8be5\u6709\u4e00\u4e2a\u5355\u72ec\u7684 `return` \u503c\uff0c\u800c\u662f\u5e94\u8be5 with `yield` \u8fde\u7eed\u8fd4\u56de\u4e00\u7cfb\u5217\u503c\u3002\u901a\u5e38\uff0c`yield` \u8bed\u53e5\u653e\u7f6e\u5728\u67d0\u79cd\u5faa\u73af\u4e2d\u3002\u4e0b\u9762\u662f\u4e00\u4e2a\u7b80\u5355\u793a\u4f8b\uff0c\u751f\u6210\u5668\u53ea\u662f\u7b80\u5355\u8ba1\u6570\u5230\u7ed9\u5b9a\u6570\u5b57\uff1a\n\n```python\ndef my_generator(x):\n    for i in range(x):\n        yield i\n```\n\n\u60a8\u4ee5\u4e0e\u5e38\u89c4\u51fd\u6570\u76f8\u540c\u7684\u65b9\u5f0f\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio\u3002\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\uff08\u865a\u62df\u7684\uff09\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5b83\u5728\u8f93\u51fa\u56fe\u50cf\u4e4b\u524d\u751f\u6210\u6570\u4e2a\u6b65\u9aa4\u7684\u566a\u97f3\uff1a\n\n$code_fake_diffusion\n$demo_fake_diffusion\n\n\u8bf7\u6ce8\u610f\uff0c\u6211\u4eec\u5728\u8fed\u4ee3\u5668\u4e2d\u6dfb\u52a0\u4e86 `time.sleep(1)`\uff0c\u4ee5\u521b\u5efa\u6b65\u9aa4\u4e4b\u95f4\u7684\u4eba\u5de5\u6682\u505c\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u89c2\u5bdf\u8fed\u4ee3\u5668\u7684\u6b65\u9aa4\uff08\u5728\u771f\u5b9e\u7684\u56fe\u50cf\u751f\u6210\u6a21\u578b\u4e2d\uff0c\u8fd9\n--New Chunk--\n[Created at: 2025-03-24 13:16:13]\nChoosing a metric for your task\n\n**So you've trained your model and want to see how well it\u2019s doing on a dataset of your choice. Where do you start?**\n\nThere is no \u201cone size fits all\u201d approach to choosing an evaluation metric, but some good guidelines to keep in mind are:\n\n## Categories of metrics\n\nThere are 3 high-level categories of metrics:\n\n1. *Generic metrics*, which can be applied to a variety of situations and datasets, such as precision and accuracy.\n2. *Task-specific metrics*, which are limited to a given task, such as Machine Translation (often evaluated using metrics [BLEU](https://huggingface.co/metrics/bleu) or [ROUGE](https://huggingface.co/metrics/rouge)) or Named Entity Recognition (often evaluated with [seqeval](https://huggingface.co/metrics/seqeval)).\n3. *Dataset-specific metrics*, which aim to measure model performance on specific benchmarks: for instance, the [GLUE benchmark](https://huggingface.co/datasets/glue) has a dedicated [evaluation metric](https://huggingface.co/metrics/glue).\n\nLet's look at each of these three cases:\n\n### Generic metrics\n\nMany of the metrics used in the Machine Learning community are quite generic and can be applied in a variety of tasks and datasets.\n\nThis is the case for metrics like [accuracy](https://huggingface.co/metrics/accuracy) and [precision](https://huggingface.co/metrics/precision), which can be used for evaluating labeled (supervised) datasets, as well as [perplexity](https://huggingface.co/metrics/perplexity), which can be used for evaluating different kinds of (unsupervised) generative tasks.\n\nTo see the input structure of a given metric, you can look at its metric card. For example, in the case of [precision](https://huggingface.co/metrics/precision), the format is:\n```\n>>> precision_metric = evaluate.load(\"precision\")\n>>> results = precision_metric.compute(references=[0, 1], predictions=[0, 1])\n>>> print(results)\n{'precision': 1.0}\n```\n\n### Task-specific metrics\n\nPopular ML tasks like Machine Translation and Named Entity Recognition have specific metrics that can be used to compare models. For example, a series of different metrics have been proposed for text generation, ranging from [BLEU](https://huggingface.co/metrics/bleu) and its derivatives such as [GoogleBLEU](https://huggingface.co/metrics/google_bleu) and [GLEU](https://huggingface.co/metrics/gleu), but also [ROUGE](https://huggingface.co/metrics/rouge), [MAUVE](https://huggingface.co/metrics/mauve), etc.\n\nYou can find the right metric for your task by:\n\n- **Looking at the [Task pages](https://huggingface.co/tasks)** to see what metrics can be used for evaluating models for a given task.\n- **Checking out leaderboards** on sites like [Papers With Code](https://paperswithcode.com/) (you can search by task and by dataset).\n-  **Reading the metric cards** for the relevant metrics and see which ones are a good fit for your use case. For example, see the [BLEU metric card](https://github.com/huggingface/evaluate/tree/main/metrics/bleu) or [SQuaD metric card](https://github.com/huggingface/evaluate/tree/main/metrics/squad).\n- **Looking at papers and blog posts** published on the topic and see what metrics they report. This can change over time, so try to pick papers from the last couple of years!\n\n### Dataset-specific metrics\n\nSome datasets have specific metrics associated with them -- this is especially in the case of popular benchmarks like [GLUE](https://huggingface.co/metrics/glue) and [SQuAD](https://huggingface.co/metrics/squad).\n\n<Tip warning={true}>\n\ud83d\udca1\nGLUE is actually a collection of different subsets on different tasks, so first you need to choose the one that corresponds to the NLI task, such as mnli, which is described as \u201ccrowdsourced collection of sentence pairs with textual entailment annotations\u201d\n</Tip>\n\n\nIf you are evaluating your model on a benchmark dataset like the ones mentioned above, you can use its dedicated evaluation metric. Make sure you respect the format that they require. For example, to evaluate your model on the [SQuAD](https://huggingface.co/datasets/squad) dataset, you need to feed the `question` and `context` into your model and return the `prediction_text`, which should be compared with the `references` (based on matching the `id` of the question) :\n\n```\n>>> from evaluate import load\n>>> squad_metric = load(\"squad\")\n>>> predictions = [{'prediction_text': '1976', 'id': '56e10a3be3433e1400422b22'}]\n>>> references = [{'answers': {'answer_start': [97], 'text': ['1976']}, 'id': '56e10a3be3433e1400422b22'}]\n>>> results = squad_metric.compute(predictions=predictions, references=references)\n>>> results\n{'exact_match': 100.0, 'f1': 100.0}\n```\n\nYou can find examples of dataset structures by consulting the \"Dataset Preview\" function or the dataset card for a given dataset, and you can see how to use its dedicated evaluation function based on the metric card."
        }
    },
    {
        "sample_idx": 133,
        "question": "What interpolation method is used by the model?",
        "answer": "bicubic",
        "rag_answer": "The provided Data Sources do not mention the specific interpolation method used by the model. However, it discusses various aspects of Gradio, including preprocessing, postprocessing, styling, queuing, and iterative outputs. If you're looking for information on interpolation methods, I'd be happy to help you with that in general, but without more context or information about the specific model, I cannot provide a direct answer.\n\nReferences:\nNone",
        "rag_score": 1,
        "rag_feedback": "The system's response does not directly answer the question about the interpolation method used by the model. Instead, it provides a lengthy and irrelevant text about Gradio, a platform for building and deploying machine learning models. The response does not contain any information about the interpolation method, making it completely incorrect and inaccurate.",
        "rag_context": {
            "kg_context": "-----Entities-----\n    ```csv\n    id,\tentity,\ttype,\tdescription,\trankcreated_at\n1,\tGradio,organization,Gradio is a platform that supports state in Blocks, providing features such as global state and session state.<SEP>Gradio is an interface that provides various features for demonstrating models, including adding example inputs, custom error messages, descriptive content, flagging, and more.<SEP>Gradio is an organization that provides a platform for building and deploying machine learning models.<SEP>Gradio is an organization that provides a platform for creating and deploying machine learning models.<SEP>Gradio is an organization that provides a demo for blocks_random_slider, and its library is used to create interactive interfaces.,36,2025-03-24 13:16:48\n2,\tnumpy,technology,numpy is a type of numerical computing library that can be used with Gradio components.,1,2025-03-24 13:16:48\n3,\tMachine Learning,category,Machine Learning is a field of study that involves training models to make predictions.,5,2025-03-24 13:16:48\n4,\tModel,category,Model refers to a machine learning model being evaluated.,3,2025-03-24 13:16:48\n5,\tPredictions,category,Predictions are the outcome of a model's performance.,2,2025-03-24 13:16:48\n6,\tMachine Learning,category,Machine Learning is a field of study that involves training models to make predictions.,5,UNKNOWN\n7,\tNeural Networks,category,Neural Networks are a type of machine learning model used for various tasks such as image recognition and natural language processing.,0,UNKNOWN\n8,\tPreprocessing,concept,Preprocessing refers to the process of preparing data for use in machine learning models.,1,UNKNOWN\n    ```\n    -----Relationships-----\n    ```csv\n    id,\tsource,\ttarget,\tdescription,\tkeywords,\tweight,\trank,\tcreated_at\n1,\tGradio,numpy,Gradio can use numpy library for numerical computing.,library integration, numerical computing,14.0,37,2025-03-24 13:17:31\n2,\tMachine Learning,Model,Machine Learning involves training models to make predictions.,field of study, model training,9.0,8,2025-03-24 13:16:48\n3,\tModel,Predictions,The model makes predictions based on the input data.,model output, predictions,8.0,5,2025-03-24 13:16:48\n4,\tGradio,Preprocessing,Gradio supports preprocessing of data for machine learning models.,data preprocessing, machine learning,8.0,37,UNKNOWN\n5,\tMachine Learning,Model,Machine Learning involves training models to make predictions.,field of study, model training,9.0,8,UNKNOWN\n6,\tMachine Learning,accuracy,accuracy is a metric used to evaluate machine learning models.,evaluation metric, task,9.0,6,UNKNOWN\n7,\tMachine Learning,precision,precision is a metric used to evaluate machine learning models.,evaluation metric, task,9.0,6,UNKNOWN\n8,\tMachine Learning,perplexity,perplexity is a metric used to evaluate machine learning models.,evaluation metric, task,9.0,6,UNKNOWN\n9,\tMachine Learning,Papers With Code,Papers With Code provides a platform for tracking machine learning papers and their corresponding code.,research platform, machine learning,8.0,6,UNKNOWN\n    ```\n    -----Sources-----\n    ```csv\n    id,\tcontent\n1,\t\u65f6\u5fc5\u987b\u9009\u62e9\u5176\u4e2d\u4e00\u4e2a\u5b57\u7b26\u4e32\uff0c\u8fd9\u5c06\u4f5c\u4e3a\u9644\u52a0\u5217\u4fdd\u5b58\u5230 CSV \u4e2d\u3002\n\n## \u9884\u5904\u7406\u548c\u540e\u5904\u7406 (Preprocessing and Postprocessing)\n\n![annotated](/assets/img/dataflow.svg)\n\n\u5982\u60a8\u6240\u89c1\uff0cGradio \u5305\u62ec\u53ef\u4ee5\u5904\u7406\u5404\u79cd\u4e0d\u540c\u6570\u636e\u7c7b\u578b\u7684\u7ec4\u4ef6\uff0c\u4f8b\u5982\u56fe\u50cf\u3001\u97f3\u9891\u548c\u89c6\u9891\u3002\u5927\u591a\u6570\u7ec4\u4ef6\u90fd\u53ef\u4ee5\u7528\u4f5c\u8f93\u5165\u6216\u8f93\u51fa\u3002\n\n\u5f53\u7ec4\u4ef6\u7528\u4f5c\u8f93\u5165\u65f6\uff0cGradio \u81ea\u52a8\u5904\u7406*\u9884\u5904\u7406*\uff0c\u5c06\u6570\u636e\u4ece\u7528\u6237\u6d4f\u89c8\u5668\u53d1\u9001\u7684\u7c7b\u578b\uff08\u4f8b\u5982\u7f51\u7edc\u6444\u50cf\u5934\u5feb\u7167\u7684 base64 \u8868\u793a\uff09\u8f6c\u6362\u4e3a\u60a8\u7684\u51fd\u6570\u53ef\u4ee5\u63a5\u53d7\u7684\u5f62\u5f0f\uff08\u4f8b\u5982 `numpy` \u6570\u7ec4\uff09\u3002\n\n\u540c\u6837\uff0c\u5f53\u7ec4\u4ef6\u7528\u4f5c\u8f93\u51fa\u65f6\uff0cGradio \u81ea\u52a8\u5904\u7406*\u540e\u5904\u7406*\uff0c\u5c06\u6570\u636e\u4ece\u51fd\u6570\u8fd4\u56de\u7684\u5f62\u5f0f\uff08\u4f8b\u5982\u56fe\u50cf\u8def\u5f84\u5217\u8868\uff09\u8f6c\u6362\u4e3a\u53ef\u4ee5\u5728\u7528\u6237\u6d4f\u89c8\u5668\u4e2d\u663e\u793a\u7684\u5f62\u5f0f\uff08\u4f8b\u5982\u4ee5 base64 \u683c\u5f0f\u663e\u793a\u56fe\u50cf\u7684 `Gallery`\uff09\u3002\n\n\u60a8\u53ef\u4ee5\u4f7f\u7528\u6784\u5efa\u56fe\u50cf\u7ec4\u4ef6\u65f6\u7684\u53c2\u6570\u63a7\u5236*\u9884\u5904\u7406*\u3002\u4f8b\u5982\uff0c\u5982\u679c\u60a8\u4f7f\u7528\u4ee5\u4e0b\u53c2\u6570\u5b9e\u4f8b\u5316 `Image` \u7ec4\u4ef6\uff0c\u5b83\u5c06\u5c06\u56fe\u50cf\u8f6c\u6362\u4e3a `PIL` \u7c7b\u578b\uff0c\u5e76\u5c06\u5176\u91cd\u5851\u4e3a`(100, 100)`\uff0c\u800c\u4e0d\u7ba1\u63d0\u4ea4\u65f6\u7684\u539f\u59cb\u5927\u5c0f\u5982\u4f55\uff1a\n\n```py\nimg = gr.Image(shape=(100, 100), type=\"pil\")\n```\n\n\u76f8\u53cd\uff0c\u8fd9\u91cc\u6211\u4eec\u4fdd\u7559\u56fe\u50cf\u7684\u539f\u59cb\u5927\u5c0f\uff0c\u4f46\u5728\u5c06\u5176\u8f6c\u6362\u4e3a numpy \u6570\u7ec4\u4e4b\u524d\u53cd\u8f6c\u989c\u8272\uff1a\n\n```py\nimg = gr.Image(invert_colors=True, type=\"numpy\")\n```\n\n\u540e\u5904\u7406\u8981\u5bb9\u6613\u5f97\u591a\uff01Gradio \u81ea\u52a8\u8bc6\u522b\u8fd4\u56de\u6570\u636e\u7684\u683c\u5f0f\uff08\u4f8b\u5982 `Image` \u662f `numpy` \u6570\u7ec4\u8fd8\u662f `str` \u6587\u4ef6\u8def\u5f84\uff1f\uff09\uff0c\u5e76\u5c06\u5176\u540e\u5904\u7406\u4e3a\u53ef\u4ee5\u7531\u6d4f\u89c8\u5668\u663e\u793a\u7684\u683c\u5f0f\u3002\n\n\u8bf7\u67e5\u770b[\u6587\u6863](https://gradio.app/docs)\uff0c\u4e86\u89e3\u6bcf\u4e2a\u7ec4\u4ef6\u7684\u6240\u6709\u4e0e\u9884\u5904\u7406\u76f8\u5173\u7684\u53c2\u6570\u3002\n\n## \u6837\u5f0f (Styling)\n\nGradio \u4e3b\u9898\u662f\u81ea\u5b9a\u4e49\u5e94\u7528\u7a0b\u5e8f\u5916\u89c2\u548c\u611f\u89c9\u7684\u6700\u7b80\u5355\u65b9\u6cd5\u3002\u60a8\u53ef\u4ee5\u9009\u62e9\u591a\u79cd\u4e3b\u9898\u6216\u521b\u5efa\u81ea\u5df1\u7684\u4e3b\u9898\u3002\u8981\u8fd9\u6837\u505a\uff0c\u8bf7\u5c06 `theme=` \u53c2\u6570\u4f20\u9012\u7ed9 `Interface` \u6784\u9020\u51fd\u6570\u3002\u4f8b\u5982\uff1a\n\n```python\ndemo = gr.Interface(..., theme=gr.themes.Monochrome())\n```\n\nGradio \u5e26\u6709\u4e00\u7ec4\u9884\u5148\u6784\u5efa\u7684\u4e3b\u9898\uff0c\u60a8\u53ef\u4ee5\u4ece `gr.themes.*` \u52a0\u8f7d\u3002\u60a8\u53ef\u4ee5\u6269\u5c55\u8fd9\u4e9b\u4e3b\u9898\u6216\u4ece\u5934\u5f00\u59cb\u521b\u5efa\u81ea\u5df1\u7684\u4e3b\u9898 - \u6709\u5173\u66f4\u591a\u8be6\u7ec6\u4fe1\u606f\uff0c\u8bf7\u53c2\u9605[\u4e3b\u9898\u6307\u5357](https://gradio.app/theming-guide)\u3002\n\n\u8981\u589e\u52a0\u989d\u5916\u7684\u6837\u5f0f\u80fd\u529b\uff0c\u60a8\u53ef\u4ee5 with `css=` \u5173\u952e\u5b57\u5c06\u4efb\u4f55 CSS \u4f20\u9012\u7ed9\u60a8\u7684\u5e94\u7528\u7a0b\u5e8f\u3002\nGradio \u5e94\u7528\u7a0b\u5e8f\u7684\u57fa\u7c7b\u662f `gradio-container`\uff0c\u56e0\u6b64\u4ee5\u4e0b\u662f\u4e00\u4e2a\u66f4\u6539 Gradio \u5e94\u7528\u7a0b\u5e8f\u80cc\u666f\u989c\u8272\u7684\u793a\u4f8b\uff1a\n\n```python\nwith `gr.Interface(css=\".gradio-container {background-color: red}\") as demo:\n    ...\n```\n\n## \u961f\u5217 (Queuing)\n\n\u5982\u679c\u60a8\u7684\u5e94\u7528\u7a0b\u5e8f\u9884\u8ba1\u4f1a\u6709\u5927\u91cf\u6d41\u91cf\uff0c\u8bf7 with `queue()` \u65b9\u6cd5\u6765\u63a7\u5236\u5904\u7406\u901f\u7387\u3002\u8fd9\u5c06\u6392\u961f\u5904\u7406\u8c03\u7528\uff0c\u56e0\u6b64\u4e00\u6b21\u53ea\u5904\u7406\u4e00\u5b9a\u6570\u91cf\u7684\u8bf7\u6c42\u3002\u961f\u5217\u4f7f\u7528 Websockets\uff0c\u8fd8\u53ef\u4ee5\u9632\u6b62\u7f51\u7edc\u8d85\u65f6\uff0c\u56e0\u6b64\u5982\u679c\u60a8\u7684\u51fd\u6570\u7684\u63a8\u7406\u65f6\u95f4\u5f88\u957f\uff08> 1 \u5206\u949f\uff09\uff0c\u5e94\u4f7f\u7528\u961f\u5217\u3002\n\nwith `Interface`\uff1a\n\n```python\ndemo = gr.Interface(...).queue()\ndemo.launch()\n```\n\nwith `Blocks`\uff1a\n\n```python\nwith gr.Blocks() as demo\uff1a\n    #...\ndemo.queue()\ndemo.launch()\n```\n\n\u60a8\u53ef\u4ee5\u901a\u8fc7\u4ee5\u4e0b\u65b9\u5f0f\u63a7\u5236\u4e00\u6b21\u5904\u7406\u7684\u8bf7\u6c42\u6570\u91cf\uff1a\n\n```python\ndemo.queue(concurrency_count=3)\n```\n\n\u67e5\u770b\u6709\u5173\u914d\u7f6e\u5176\u4ed6\u961f\u5217\u53c2\u6570\u7684[\u961f\u5217\u6587\u6863](/docs/#queue)\u3002\n\n\u5728 Blocks \u4e2d\u6307\u5b9a\u4ec5\u5bf9\u67d0\u4e9b\u51fd\u6570\u8fdb\u884c\u6392\u961f\uff1a\n\n```python\nwith gr.Blocks() as demo2\uff1a\n    num1 = gr.Number()\n    num2 = gr.Number()\n    output = gr.Number()\n    gr.Button(\"Add\").click(\n        lambda a, b: a + b, [num1, num2], output)\n    gr.Button(\"Multiply\").click(\n        lambda a, b: a * b, [num1, num2], output, queue=True)\ndemo2.launch()\n```\n\n## \u8fed\u4ee3\u8f93\u51fa (Iterative Outputs)\n\n\u5728\u67d0\u4e9b\u60c5\u51b5\u4e0b\uff0c\u60a8\u53ef\u80fd\u9700\u8981\u4f20\u8f93\u4e00\u7cfb\u5217\u8f93\u51fa\u800c\u4e0d\u662f\u4e00\u6b21\u663e\u793a\u5355\u4e2a\u8f93\u51fa\u3002\u4f8b\u5982\uff0c\u60a8\u53ef\u80fd\u6709\u4e00\u4e2a\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5e0c\u671b\u663e\u793a\u751f\u6210\u7684\u6bcf\u4e2a\u6b65\u9aa4\u7684\u56fe\u50cf\uff0c\u76f4\u5230\u6700\u7ec8\u56fe\u50cf\u3002\u6216\u8005\u60a8\u53ef\u80fd\u6709\u4e00\u4e2a\u804a\u5929\u673a\u5668\u4eba\uff0c\u5b83\u9010\u5b57\u9010\u53e5\u5730\u6d41\u5f0f\u4f20\u8f93\u54cd\u5e94\uff0c\u800c\u4e0d\u662f\u4e00\u6b21\u8fd4\u56de\u5168\u90e8\u54cd\u5e94\u3002\n\n\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u60a8\u53ef\u4ee5\u5c06**\u751f\u6210\u5668**\u51fd\u6570\u63d0\u4f9b\u7ed9 Gradio\uff0c\u800c\u4e0d\u662f\u5e38\u89c4\u51fd\u6570\u3002\u5728 Python \u4e2d\u521b\u5efa\u751f\u6210\u5668\u975e\u5e38\u7b80\u5355\uff1a\u51fd\u6570\u4e0d\u5e94\u8be5\u6709\u4e00\u4e2a\u5355\u72ec\u7684 `return` \u503c\uff0c\u800c\u662f\u5e94\u8be5 with `yield` \u8fde\u7eed\u8fd4\u56de\u4e00\u7cfb\u5217\u503c\u3002\u901a\u5e38\uff0c`yield` \u8bed\u53e5\u653e\u7f6e\u5728\u67d0\u79cd\u5faa\u73af\u4e2d\u3002\u4e0b\u9762\u662f\u4e00\u4e2a\u7b80\u5355\u793a\u4f8b\uff0c\u751f\u6210\u5668\u53ea\u662f\u7b80\u5355\u8ba1\u6570\u5230\u7ed9\u5b9a\u6570\u5b57\uff1a\n\n```python\ndef my_generator(x):\n    for i in range(x):\n        yield i\n```\n\n\u60a8\u4ee5\u4e0e\u5e38\u89c4\u51fd\u6570\u76f8\u540c\u7684\u65b9\u5f0f\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio\u3002\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\uff08\u865a\u62df\u7684\uff09\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5b83\u5728\u8f93\u51fa\u56fe\u50cf\u4e4b\u524d\u751f\u6210\u6570\u4e2a\u6b65\u9aa4\u7684\u566a\u97f3\uff1a\n\n$code_fake_diffusion\n$demo_fake_diffusion\n\n\u8bf7\u6ce8\u610f\uff0c\u6211\u4eec\u5728\u8fed\u4ee3\u5668\u4e2d\u6dfb\u52a0\u4e86 `time.sleep(1)`\uff0c\u4ee5\u521b\u5efa\u6b65\u9aa4\u4e4b\u95f4\u7684\u4eba\u5de5\u6682\u505c\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u89c2\u5bdf\u8fed\u4ee3\u5668\u7684\u6b65\u9aa4\uff08\u5728\u771f\u5b9e\u7684\u56fe\u50cf\u751f\u6210\u6a21\u578b\u4e2d\uff0c\u8fd9\n2,\t=predictions, references=references)\n>>> results\n{'exact_match': 100.0, 'f1': 100.0}\n```\n\nYou can find examples of dataset structures by consulting the \"Dataset Preview\" function or the dataset card for a given dataset, and you can see how to use its dedicated evaluation function based on the metric card.\n3,\t!--Copyright 2023 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\nthe License. You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under the License is distributed on\nan \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n\n\u26a0\ufe0f Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be\nrendered properly in your Markdown viewer.\n\n-->\n\n# Training on TPU with TensorFlow\n\n<Tip>\n\nIf you don't need long explanations and just want TPU code samples to get started with, check out [our TPU example notebook!](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb)\n\n</Tip>\n\n### What is a TPU?\n\nA TPU is a **Tensor Processing Unit.** They are hardware designed by Google, which are used to greatly speed up the tensor computations within neural networks, much like GPUs. They can be used for both network training and inference. They are generally accessed through Google\u2019s cloud services, but small TPUs can also be accessed directly for free through Google Colab and Kaggle Kernels.\n\nBecause [all TensorFlow models in \ud83e\udd17 Transformers are Keras models](https://huggingface.co/blog/tensorflow-philosophy), most of the methods in this document are generally applicable to TPU training for any Keras model! However, there are a few points that are specific to the HuggingFace ecosystem (hug-o-system?) of Transformers and Datasets, and we\u2019ll make sure to flag them up when we get to them.\n\n### What kinds of TPU are available?\n\nNew users are often very confused by the range of TPUs, and the different ways to access them. The first key distinction to understand is the difference between **TPU Nodes** and **TPU VMs.**\n\nWhen you use a **TPU Node**, you are effectively indirectly accessing a remote TPU. You will need a separate VM, which will initialize your network and data pipeline and then forward them to the remote node. When you use a TPU on Google Colab, you are accessing it in the **TPU Node** style.\n\nUsing TPU Nodes can have some quite unexpected behaviour for people who aren\u2019t used to them! In particular, because the TPU is located on a physically different system to the machine you\u2019re running your Python code on, your data cannot be local to your machine - any data pipeline that loads from your machine\u2019s internal storage will totally fail! Instead, data must be stored in Google Cloud Storage where your data pipeline can still access it, even when the pipeline is running on the remote TPU node.\n\n<Tip>\n\nIf you can fit all your data in memory as `np.ndarray` or `tf.Tensor`, then you can `fit()` on that data even when using Colab or a TPU Node, without needing to upload it to Google Cloud Storage.\n\n</Tip>\n\n<Tip>\n\n**\ud83e\udd17Specific Hugging Face Tip\ud83e\udd17:** The methods `Dataset.to_tf_dataset()` and its higher-level wrapper `model.prepare_tf_dataset()` , which you will see throughout our TF code examples, will both fail on a TPU Node. The reason for this is that even though they create a `tf.data.Dataset` it is not a \u201cpure\u201d `tf.data` pipeline and uses `tf.numpy_function` or `Dataset.from_generator()` to stream data from the underlying HuggingFace `Dataset`. This HuggingFace `Dataset` is backed by data that is on a local disc and which the remote TPU Node will not be able to read.\n\n</Tip>\n\nThe second way to access a TPU is via a **TPU VM.** When using a TPU VM, you connect directly to the machine that the TPU is attached to, much like training on a GPU VM. TPU VMs are generally easier to work with, particularly when it comes to your data pipeline. All of the above warnings do not apply to TPU VMs!\n\nThis is an opinionated document, so here\u2019s our opinion: **Avoid using TPU Node if possible.** It is more confusing and more difficult to debug than TPU VMs. It is also likely to be unsupported in future - Google\u2019s latest TPU, TPUv4, can only be accessed as a TPU VM, which suggests that TPU Nodes are increasingly going to become a \u201clegacy\u201d access method. However, we understand that the only free TPU access is on Colab and Kaggle Kernels, which uses TPU Node - so we\u2019ll try to explain how to handle it if you have to! Check the [TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) for code samples that explain this in more detail.\n\n### What sizes of TPU are available?\n\nA single TPU (a v2-8/v3-8/v4-8) runs 8 replicas. TPUs exist in **pods** that can run hundreds or thousands of replicas simultaneously. When you use more than a single TPU but less than a whole pod (for example, a v3-32), your TPU fleet is referred to as a **pod slice.**\n\nWhen you access a free TPU via Colab, you generally get a single v2-8 TPU.\n\n### I keep hearing about this XLA thing. What\u2019s XLA, and how does it relate to TPUs?\n\nXLA is an optimizing compiler, used by both TensorFlow and JAX. In JAX it is the only compiler, whereas in TensorFlow it is optional\n    ```",
            "vector_context": "[Created at: 2025-03-24 13:16:13]\n=predictions, references=references)\n>>> results\n{'exact_match': 100.0, 'f1': 100.0}\n```\n\nYou can find examples of dataset structures by consulting the \"Dataset Preview\" function or the dataset card for a given dataset, and you can see how to use its dedicated evaluation function based on the metric card.\n--New Chunk--\n[Created at: 2025-03-24 13:16:48]\n\u4e0e\u5e38\u89c4\u51fd\u6570\u76f8\u540c\u7684\u65b9\u5f0f\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio\u3002\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\uff08\u865a\u62df\u7684\uff09\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5b83\u5728\u8f93\u51fa\u56fe\u50cf\u4e4b\u524d\u751f\u6210\u6570\u4e2a\u6b65\u9aa4\u7684\u566a\u97f3\uff1a\n\n$code_fake_diffusion\n$demo_fake_diffusion\n\n\u8bf7\u6ce8\u610f\uff0c\u6211\u4eec\u5728\u8fed\u4ee3\u5668\u4e2d\u6dfb\u52a0\u4e86 `time.sleep(1)`\uff0c\u4ee5\u521b\u5efa\u6b65\u9aa4\u4e4b\u95f4\u7684\u4eba\u5de5\u6682\u505c\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u89c2\u5bdf\u8fed\u4ee3\u5668\u7684\u6b65\u9aa4\uff08\u5728\u771f\u5b9e\u7684\u56fe\u50cf\u751f\u6210\u6a21\u578b\u4e2d\uff0c\u8fd9\u53ef\u80fd\u662f\u4e0d\u5fc5\u8981\u7684\uff09\u3002\n\n\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio **\u9700\u8981**\u5728\u5e95\u5c42 Interface \u6216 Blocks \u4e2d\u542f\u7528\u961f\u5217\uff08\u8bf7\u53c2\u9605\u4e0a\u9762\u7684\u961f\u5217\u90e8\u5206\uff09\u3002\n\n## \u8fdb\u5ea6\u6761\n\nGradio \u652f\u6301\u521b\u5efa\u81ea\u5b9a\u4e49\u8fdb\u5ea6\u6761\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u81ea\u5b9a\u4e49\u548c\u63a7\u5236\u5411\u7528\u6237\u663e\u793a\u7684\u8fdb\u5ea6\u66f4\u65b0\u3002\u8981\u542f\u7528\u6b64\u529f\u80fd\uff0c\u53ea\u9700\u4e3a\u65b9\u6cd5\u6dfb\u52a0\u4e00\u4e2a\u9ed8\u8ba4\u503c\u4e3a `gr.Progress` \u5b9e\u4f8b\u7684\u53c2\u6570\u5373\u53ef\u3002\u7136\u540e\uff0c\u60a8\u53ef\u4ee5\u76f4\u63a5\u8c03\u7528\u6b64\u5b9e\u4f8b\u5e76\u4f20\u5165 0 \u5230 1 \u4e4b\u95f4\u7684\u6d6e\u70b9\u6570\u6765\u66f4\u65b0\u8fdb\u5ea6\u7ea7\u522b\uff0c\u6216\u8005 with `Progress` \u5b9e\u4f8b\u7684 `tqdm()` \u65b9\u6cd5\u6765\u8ddf\u8e2a\u53ef\u8fed\u4ee3\u5bf9\u8c61\u4e0a\u7684\u8fdb\u5ea6\uff0c\u5982\u4e0b\u6240\u793a\u3002\u5fc5\u987b\u542f\u7528\u961f\u5217\u4ee5\u8fdb\u884c\u8fdb\u5ea6\u66f4\u65b0\u3002\n\n$code_progress_simple\n$demo_progress_simple\n\n\u5982\u679c\u60a8 with `tqdm` \u5e93\uff0c\u5e76\u4e14\u5e0c\u671b\u4ece\u51fd\u6570\u5185\u90e8\u7684\u4efb\u4f55 `tqdm.tqdm` \u81ea\u52a8\u62a5\u544a\u8fdb\u5ea6\u66f4\u65b0\uff0c\u8bf7\u5c06\u9ed8\u8ba4\u53c2\u6570\u8bbe\u7f6e\u4e3a `gr.Progress(track_tqdm=True)`\uff01\n\n## \u6279\u5904\u7406\u51fd\u6570 (Batch Functions)\n\nGradio \u652f\u6301\u4f20\u9012*\u6279\u5904\u7406*\u51fd\u6570\u3002\u6279\u5904\u7406\u51fd\u6570\u53ea\u662f\u63a5\u53d7\u8f93\u5165\u5217\u8868\u5e76\u8fd4\u56de\u9884\u6d4b\u5217\u8868\u7684\u51fd\u6570\u3002\n\n\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\u6279\u5904\u7406\u51fd\u6570\uff0c\u5b83\u63a5\u53d7\u4e24\u4e2a\u8f93\u5165\u5217\u8868\uff08\u4e00\u4e2a\u5355\u8bcd\u5217\u8868\u548c\u4e00\u4e2a\u6574\u6570\u5217\u8868\uff09\uff0c\u5e76\u8fd4\u56de\u4fee\u526a\u8fc7\u7684\u5355\u8bcd\u5217\u8868\u4f5c\u4e3a\u8f93\u51fa\uff1a\n\n```python\nimport time\n\ndef trim_words(words, lens):\n    trimmed_words = []\n    time.sleep(5)\n    for w, l in zip(words, lens):\n        trimmed_words.append(w[:int(l)])\n    return [trimmed_words]\n    for w, l in zip(words, lens):\n```\n\n\u4f7f\u7528\u6279\u5904\u7406\u51fd\u6570\u7684\u4f18\u70b9\u662f\uff0c\u5982\u679c\u542f\u7528\u4e86\u961f\u5217\uff0cGradio \u670d\u52a1\u5668\u53ef\u4ee5\u81ea\u52a8*\u6279\u5904\u7406*\u4f20\u5165\u7684\u8bf7\u6c42\u5e76\u5e76\u884c\u5904\u7406\u5b83\u4eec\uff0c\u4ece\u800c\u53ef\u80fd\u52a0\u5feb\u6f14\u793a\u901f\u5ea6\u3002\u4ee5\u4e0b\u662f Gradio \u4ee3\u7801\u7684\u793a\u4f8b\uff08\u8bf7\u6ce8\u610f `batch=True` \u548c `max_batch_size=16` - \u8fd9\u4e24\u4e2a\u53c2\u6570\u90fd\u53ef\u4ee5\u4f20\u9012\u7ed9\u4e8b\u4ef6\u89e6\u53d1\u5668\u6216 `Interface` \u7c7b\uff09\n\nwith `Interface`\uff1a\n\n```python\ndemo = gr.Interface(trim_words, [\"textbox\", \"number\"], [\"output\"],\n                    batch=True, max_batch_size=16)\ndemo.queue()\ndemo.launch()\n```\n\nwith `Blocks`\uff1a\n\n```python\nimport gradio as gr\n\nwith gr.Blocks() as demo:\n    with gr.Row():\n        word = gr.Textbox(label=\"word\")\n        leng = gr.Number(label=\"leng\")\n        output = gr.Textbox(label=\"Output\")\n    with gr.Row():\n        run = gr.Button()\n\n    event = run.click(trim_words, [word, leng], output, batch=True, max_batch_size=16)\n\ndemo.queue()\ndemo.launch()\n```\n\n\u5728\u4e0a\u9762\u7684\u793a\u4f8b\u4e2d\uff0c\u53ef\u4ee5\u5e76\u884c\u5904\u7406 16 \u4e2a\u8bf7\u6c42\uff08\u603b\u63a8\u7406\u65f6\u95f4\u4e3a 5 \u79d2\uff09\uff0c\u800c\u4e0d\u662f\u5206\u522b\u5904\u7406\u6bcf\u4e2a\u8bf7\u6c42\uff08\u603b\u63a8\u7406\u65f6\u95f4\u4e3a 80 \u79d2\uff09\u3002\u8bb8\u591a Hugging Face \u7684 `transformers` \u548c `diffusers` \u6a21\u578b\u5728 Gradio \u7684\u6279\u5904\u7406\u6a21\u5f0f\u4e0b\u81ea\u7136\u5de5\u4f5c\uff1a\u8fd9\u662f[\u4f7f\u7528\u6279\u5904\u7406\u751f\u6210\u56fe\u50cf\u7684\u793a\u4f8b\u6f14\u793a](https://github.com/gradio-app/gradio/blob/main/demo/diffusers_with_batching/run.py)\n\n\u6ce8\u610f\uff1a\u4f7f\u7528 Gradio \u7684\u6279\u5904\u7406\u51fd\u6570 **requires** \u5728\u5e95\u5c42 Interface \u6216 Blocks \u4e2d\u542f\u7528\u961f\u5217\uff08\u8bf7\u53c2\u9605\u4e0a\u9762\u7684\u961f\u5217\u90e8\u5206\uff09\u3002\n\n## Gradio \u7b14\u8bb0\u672c (Colab Notebooks)\n\nGradio \u53ef\u4ee5\u5728\u4efb\u4f55\u8fd0\u884c Python \u7684\u5730\u65b9\u8fd0\u884c\uff0c\u5305\u62ec\u672c\u5730 Jupyter \u7b14\u8bb0\u672c\u548c\u534f\u4f5c\u7b14\u8bb0\u672c\uff0c\u5982[Google Colab](https://colab.research.google.com/)\u3002\u5bf9\u4e8e\u672c\u5730 Jupyter \u7b14\u8bb0\u672c\u548c Google Colab \u7b14\u8bb0\u672c\uff0cGradio \u5728\u672c\u5730\u670d\u52a1\u5668\u4e0a\u8fd0\u884c\uff0c\u60a8\u53ef\u4ee5\u5728\u6d4f\u89c8\u5668\u4e2d\u4e0e\u4e4b\u4ea4\u4e92\u3002\uff08\u6ce8\u610f\uff1a\u5bf9\u4e8e Google Colab\uff0c\u8fd9\u662f\u901a\u8fc7[\u670d\u52a1\u5de5\u4f5c\u5668\u96a7\u9053](https://github.com/tensorflow/tensorboard/blob/master/docs/design/colab_integration.md)\u5b9e\u73b0\u7684\uff0c\u60a8\u7684\u6d4f\u89c8\u5668\u9700\u8981\u542f\u7528 cookies\u3002\uff09\u5bf9\u4e8e\u5176\u4ed6\u8fdc\u7a0b\u7b14\u8bb0\u672c\uff0cGradio \u4e5f\u5c06\u5728\u670d\u52a1\u5668\u4e0a\u8fd0\u884c\uff0c\u4f46\u60a8\u9700\u8981\u4f7f\u7528[SSH \u96a7\u9053](https://coderwall.com/p/ohk6cg/remote-access-to-ipython-notebooks-via-ssh)\u5728\u672c\u5730\u6d4f\u89c8\u5668\u4e2d\u67e5\u770b\u5e94\u7528\u7a0b\u5e8f\u3002\u901a\u5e38\uff0c\u66f4\u7b80\u5355\u7684\u9009\u62e9\u662f\u4f7f\u7528 Gradio \u5185\u7f6e\u7684\u516c\u5171\u94fe\u63a5\uff0c[\u5728\u4e0b\u4e00\u7bc7\u6307\u5357\u4e2d\u8ba8\u8bba](/sharing-your-app/#sharing-demos)\u3002\n--New Chunk--\n[Created at: 2025-03-24 13:16:48]\n\u65f6\u5fc5\u987b\u9009\u62e9\u5176\u4e2d\u4e00\u4e2a\u5b57\u7b26\u4e32\uff0c\u8fd9\u5c06\u4f5c\u4e3a\u9644\u52a0\u5217\u4fdd\u5b58\u5230 CSV \u4e2d\u3002\n\n## \u9884\u5904\u7406\u548c\u540e\u5904\u7406 (Preprocessing and Postprocessing)\n\n![annotated](/assets/img/dataflow.svg)\n\n\u5982\u60a8\u6240\u89c1\uff0cGradio \u5305\u62ec\u53ef\u4ee5\u5904\u7406\u5404\u79cd\u4e0d\u540c\u6570\u636e\u7c7b\u578b\u7684\u7ec4\u4ef6\uff0c\u4f8b\u5982\u56fe\u50cf\u3001\u97f3\u9891\u548c\u89c6\u9891\u3002\u5927\u591a\u6570\u7ec4\u4ef6\u90fd\u53ef\u4ee5\u7528\u4f5c\u8f93\u5165\u6216\u8f93\u51fa\u3002\n\n\u5f53\u7ec4\u4ef6\u7528\u4f5c\u8f93\u5165\u65f6\uff0cGradio \u81ea\u52a8\u5904\u7406*\u9884\u5904\u7406*\uff0c\u5c06\u6570\u636e\u4ece\u7528\u6237\u6d4f\u89c8\u5668\u53d1\u9001\u7684\u7c7b\u578b\uff08\u4f8b\u5982\u7f51\u7edc\u6444\u50cf\u5934\u5feb\u7167\u7684 base64 \u8868\u793a\uff09\u8f6c\u6362\u4e3a\u60a8\u7684\u51fd\u6570\u53ef\u4ee5\u63a5\u53d7\u7684\u5f62\u5f0f\uff08\u4f8b\u5982 `numpy` \u6570\u7ec4\uff09\u3002\n\n\u540c\u6837\uff0c\u5f53\u7ec4\u4ef6\u7528\u4f5c\u8f93\u51fa\u65f6\uff0cGradio \u81ea\u52a8\u5904\u7406*\u540e\u5904\u7406*\uff0c\u5c06\u6570\u636e\u4ece\u51fd\u6570\u8fd4\u56de\u7684\u5f62\u5f0f\uff08\u4f8b\u5982\u56fe\u50cf\u8def\u5f84\u5217\u8868\uff09\u8f6c\u6362\u4e3a\u53ef\u4ee5\u5728\u7528\u6237\u6d4f\u89c8\u5668\u4e2d\u663e\u793a\u7684\u5f62\u5f0f\uff08\u4f8b\u5982\u4ee5 base64 \u683c\u5f0f\u663e\u793a\u56fe\u50cf\u7684 `Gallery`\uff09\u3002\n\n\u60a8\u53ef\u4ee5\u4f7f\u7528\u6784\u5efa\u56fe\u50cf\u7ec4\u4ef6\u65f6\u7684\u53c2\u6570\u63a7\u5236*\u9884\u5904\u7406*\u3002\u4f8b\u5982\uff0c\u5982\u679c\u60a8\u4f7f\u7528\u4ee5\u4e0b\u53c2\u6570\u5b9e\u4f8b\u5316 `Image` \u7ec4\u4ef6\uff0c\u5b83\u5c06\u5c06\u56fe\u50cf\u8f6c\u6362\u4e3a `PIL` \u7c7b\u578b\uff0c\u5e76\u5c06\u5176\u91cd\u5851\u4e3a`(100, 100)`\uff0c\u800c\u4e0d\u7ba1\u63d0\u4ea4\u65f6\u7684\u539f\u59cb\u5927\u5c0f\u5982\u4f55\uff1a\n\n```py\nimg = gr.Image(shape=(100, 100), type=\"pil\")\n```\n\n\u76f8\u53cd\uff0c\u8fd9\u91cc\u6211\u4eec\u4fdd\u7559\u56fe\u50cf\u7684\u539f\u59cb\u5927\u5c0f\uff0c\u4f46\u5728\u5c06\u5176\u8f6c\u6362\u4e3a numpy \u6570\u7ec4\u4e4b\u524d\u53cd\u8f6c\u989c\u8272\uff1a\n\n```py\nimg = gr.Image(invert_colors=True, type=\"numpy\")\n```\n\n\u540e\u5904\u7406\u8981\u5bb9\u6613\u5f97\u591a\uff01Gradio \u81ea\u52a8\u8bc6\u522b\u8fd4\u56de\u6570\u636e\u7684\u683c\u5f0f\uff08\u4f8b\u5982 `Image` \u662f `numpy` \u6570\u7ec4\u8fd8\u662f `str` \u6587\u4ef6\u8def\u5f84\uff1f\uff09\uff0c\u5e76\u5c06\u5176\u540e\u5904\u7406\u4e3a\u53ef\u4ee5\u7531\u6d4f\u89c8\u5668\u663e\u793a\u7684\u683c\u5f0f\u3002\n\n\u8bf7\u67e5\u770b[\u6587\u6863](https://gradio.app/docs)\uff0c\u4e86\u89e3\u6bcf\u4e2a\u7ec4\u4ef6\u7684\u6240\u6709\u4e0e\u9884\u5904\u7406\u76f8\u5173\u7684\u53c2\u6570\u3002\n\n## \u6837\u5f0f (Styling)\n\nGradio \u4e3b\u9898\u662f\u81ea\u5b9a\u4e49\u5e94\u7528\u7a0b\u5e8f\u5916\u89c2\u548c\u611f\u89c9\u7684\u6700\u7b80\u5355\u65b9\u6cd5\u3002\u60a8\u53ef\u4ee5\u9009\u62e9\u591a\u79cd\u4e3b\u9898\u6216\u521b\u5efa\u81ea\u5df1\u7684\u4e3b\u9898\u3002\u8981\u8fd9\u6837\u505a\uff0c\u8bf7\u5c06 `theme=` \u53c2\u6570\u4f20\u9012\u7ed9 `Interface` \u6784\u9020\u51fd\u6570\u3002\u4f8b\u5982\uff1a\n\n```python\ndemo = gr.Interface(..., theme=gr.themes.Monochrome())\n```\n\nGradio \u5e26\u6709\u4e00\u7ec4\u9884\u5148\u6784\u5efa\u7684\u4e3b\u9898\uff0c\u60a8\u53ef\u4ee5\u4ece `gr.themes.*` \u52a0\u8f7d\u3002\u60a8\u53ef\u4ee5\u6269\u5c55\u8fd9\u4e9b\u4e3b\u9898\u6216\u4ece\u5934\u5f00\u59cb\u521b\u5efa\u81ea\u5df1\u7684\u4e3b\u9898 - \u6709\u5173\u66f4\u591a\u8be6\u7ec6\u4fe1\u606f\uff0c\u8bf7\u53c2\u9605[\u4e3b\u9898\u6307\u5357](https://gradio.app/theming-guide)\u3002\n\n\u8981\u589e\u52a0\u989d\u5916\u7684\u6837\u5f0f\u80fd\u529b\uff0c\u60a8\u53ef\u4ee5 with `css=` \u5173\u952e\u5b57\u5c06\u4efb\u4f55 CSS \u4f20\u9012\u7ed9\u60a8\u7684\u5e94\u7528\u7a0b\u5e8f\u3002\nGradio \u5e94\u7528\u7a0b\u5e8f\u7684\u57fa\u7c7b\u662f `gradio-container`\uff0c\u56e0\u6b64\u4ee5\u4e0b\u662f\u4e00\u4e2a\u66f4\u6539 Gradio \u5e94\u7528\u7a0b\u5e8f\u80cc\u666f\u989c\u8272\u7684\u793a\u4f8b\uff1a\n\n```python\nwith `gr.Interface(css=\".gradio-container {background-color: red}\") as demo:\n    ...\n```\n\n## \u961f\u5217 (Queuing)\n\n\u5982\u679c\u60a8\u7684\u5e94\u7528\u7a0b\u5e8f\u9884\u8ba1\u4f1a\u6709\u5927\u91cf\u6d41\u91cf\uff0c\u8bf7 with `queue()` \u65b9\u6cd5\u6765\u63a7\u5236\u5904\u7406\u901f\u7387\u3002\u8fd9\u5c06\u6392\u961f\u5904\u7406\u8c03\u7528\uff0c\u56e0\u6b64\u4e00\u6b21\u53ea\u5904\u7406\u4e00\u5b9a\u6570\u91cf\u7684\u8bf7\u6c42\u3002\u961f\u5217\u4f7f\u7528 Websockets\uff0c\u8fd8\u53ef\u4ee5\u9632\u6b62\u7f51\u7edc\u8d85\u65f6\uff0c\u56e0\u6b64\u5982\u679c\u60a8\u7684\u51fd\u6570\u7684\u63a8\u7406\u65f6\u95f4\u5f88\u957f\uff08> 1 \u5206\u949f\uff09\uff0c\u5e94\u4f7f\u7528\u961f\u5217\u3002\n\nwith `Interface`\uff1a\n\n```python\ndemo = gr.Interface(...).queue()\ndemo.launch()\n```\n\nwith `Blocks`\uff1a\n\n```python\nwith gr.Blocks() as demo\uff1a\n    #...\ndemo.queue()\ndemo.launch()\n```\n\n\u60a8\u53ef\u4ee5\u901a\u8fc7\u4ee5\u4e0b\u65b9\u5f0f\u63a7\u5236\u4e00\u6b21\u5904\u7406\u7684\u8bf7\u6c42\u6570\u91cf\uff1a\n\n```python\ndemo.queue(concurrency_count=3)\n```\n\n\u67e5\u770b\u6709\u5173\u914d\u7f6e\u5176\u4ed6\u961f\u5217\u53c2\u6570\u7684[\u961f\u5217\u6587\u6863](/docs/#queue)\u3002\n\n\u5728 Blocks \u4e2d\u6307\u5b9a\u4ec5\u5bf9\u67d0\u4e9b\u51fd\u6570\u8fdb\u884c\u6392\u961f\uff1a\n\n```python\nwith gr.Blocks() as demo2\uff1a\n    num1 = gr.Number()\n    num2 = gr.Number()\n    output = gr.Number()\n    gr.Button(\"Add\").click(\n        lambda a, b: a + b, [num1, num2], output)\n    gr.Button(\"Multiply\").click(\n        lambda a, b: a * b, [num1, num2], output, queue=True)\ndemo2.launch()\n```\n\n## \u8fed\u4ee3\u8f93\u51fa (Iterative Outputs)\n\n\u5728\u67d0\u4e9b\u60c5\u51b5\u4e0b\uff0c\u60a8\u53ef\u80fd\u9700\u8981\u4f20\u8f93\u4e00\u7cfb\u5217\u8f93\u51fa\u800c\u4e0d\u662f\u4e00\u6b21\u663e\u793a\u5355\u4e2a\u8f93\u51fa\u3002\u4f8b\u5982\uff0c\u60a8\u53ef\u80fd\u6709\u4e00\u4e2a\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5e0c\u671b\u663e\u793a\u751f\u6210\u7684\u6bcf\u4e2a\u6b65\u9aa4\u7684\u56fe\u50cf\uff0c\u76f4\u5230\u6700\u7ec8\u56fe\u50cf\u3002\u6216\u8005\u60a8\u53ef\u80fd\u6709\u4e00\u4e2a\u804a\u5929\u673a\u5668\u4eba\uff0c\u5b83\u9010\u5b57\u9010\u53e5\u5730\u6d41\u5f0f\u4f20\u8f93\u54cd\u5e94\uff0c\u800c\u4e0d\u662f\u4e00\u6b21\u8fd4\u56de\u5168\u90e8\u54cd\u5e94\u3002\n\n\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u60a8\u53ef\u4ee5\u5c06**\u751f\u6210\u5668**\u51fd\u6570\u63d0\u4f9b\u7ed9 Gradio\uff0c\u800c\u4e0d\u662f\u5e38\u89c4\u51fd\u6570\u3002\u5728 Python \u4e2d\u521b\u5efa\u751f\u6210\u5668\u975e\u5e38\u7b80\u5355\uff1a\u51fd\u6570\u4e0d\u5e94\u8be5\u6709\u4e00\u4e2a\u5355\u72ec\u7684 `return` \u503c\uff0c\u800c\u662f\u5e94\u8be5 with `yield` \u8fde\u7eed\u8fd4\u56de\u4e00\u7cfb\u5217\u503c\u3002\u901a\u5e38\uff0c`yield` \u8bed\u53e5\u653e\u7f6e\u5728\u67d0\u79cd\u5faa\u73af\u4e2d\u3002\u4e0b\u9762\u662f\u4e00\u4e2a\u7b80\u5355\u793a\u4f8b\uff0c\u751f\u6210\u5668\u53ea\u662f\u7b80\u5355\u8ba1\u6570\u5230\u7ed9\u5b9a\u6570\u5b57\uff1a\n\n```python\ndef my_generator(x):\n    for i in range(x):\n        yield i\n```\n\n\u60a8\u4ee5\u4e0e\u5e38\u89c4\u51fd\u6570\u76f8\u540c\u7684\u65b9\u5f0f\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio\u3002\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\uff08\u865a\u62df\u7684\uff09\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5b83\u5728\u8f93\u51fa\u56fe\u50cf\u4e4b\u524d\u751f\u6210\u6570\u4e2a\u6b65\u9aa4\u7684\u566a\u97f3\uff1a\n\n$code_fake_diffusion\n$demo_fake_diffusion\n\n\u8bf7\u6ce8\u610f\uff0c\u6211\u4eec\u5728\u8fed\u4ee3\u5668\u4e2d\u6dfb\u52a0\u4e86 `time.sleep(1)`\uff0c\u4ee5\u521b\u5efa\u6b65\u9aa4\u4e4b\u95f4\u7684\u4eba\u5de5\u6682\u505c\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u89c2\u5bdf\u8fed\u4ee3\u5668\u7684\u6b65\u9aa4\uff08\u5728\u771f\u5b9e\u7684\u56fe\u50cf\u751f\u6210\u6a21\u578b\u4e2d\uff0c\u8fd9"
        }
    },
    {
        "sample_idx": 134,
        "question": "What is the top 1 accuracy of the model on ImageNet?",
        "answer": "80.26%",
        "rag_answer": "The provided Data Sources do not mention the top 1 accuracy of the model on ImageNet. The conversation is focused on choosing an evaluation metric for a machine learning model, and the Data Sources provide information on different types of metrics (generic, task-specific, and dataset-specific) and how to choose the right one for a given task. Additionally, the Data Sources provide examples of fine-tuning a LayoutLMv3 model on form understanding datasets, such as FUNSD and CORD. However, there is no mention of ImageNet or the top 1 accuracy of a model on this dataset.\n\nReferences:\n[KG] Machine Learning category\n[DC] Choosing a metric for your task\n[DC] Token classification with LayoutLMv3 (PyTorch version)",
        "rag_score": 1,
        "rag_feedback": "The system's response does not provide the top 1 accuracy of the model on ImageNet, which is the expected answer. Instead, it provides a lengthy response about choosing an evaluation metric for a machine learning model, which is not relevant to the question. The response does not contain any information about ImageNet or the top 1 accuracy of a model on this dataset.",
        "rag_context": {
            "kg_context": "-----Entities-----\n    ```csv\n    id,\tentity,\ttype,\tdescription,\trankcreated_at\n1,\tMachine Learning,category,Machine Learning is a field of study that involves training models to make predictions.,5,2025-03-24 13:16:48\n2,\tModel,category,Model refers to a machine learning model being evaluated.,3,2025-03-24 13:16:48\n3,\tprecision,category,precision is a category of evaluation metrics for machine learning models.,1,2025-03-24 13:16:48\n4,\tExact Match,category,Exact Match is a metric used to evaluate the performance of a model.,1,2025-03-24 13:16:48\n5,\tF1,category,F1 is a metric used to evaluate the performance of a model.,1,2025-03-24 13:16:48\n6,\taccuracy,category,accuracy is a category of evaluation metrics for machine learning models.,1,UNKNOWN\n7,\tprecision,category,precision is a category of evaluation metrics for machine learning models.,1,UNKNOWN\n8,\tDatasets library,technology,Datasets library is a tool used for fine-tuning the LayoutLMv3 model.,1,UNKNOWN\n    ```\n    -----Relationships-----\n    ```csv\n    id,\tsource,\ttarget,\tdescription,\tkeywords,\tweight,\trank,\tcreated_at\n1,\tMachine Learning,Model,Machine Learning involves training models to make predictions.,field of study, model training,9.0,8,2025-03-24 13:16:48\n2,\tMachine Learning,precision,precision is a metric used to evaluate machine learning models.,evaluation metric, task,9.0,6,2025-03-24 13:16:48\n3,\tExact Match,F1,Exact Match and F1 are both metrics used to evaluate the performance of a model.,evaluation metrics, performance assessment,8.0,2,2025-03-24 13:16:48\n4,\tDatasets library,LayoutLMv3,Datasets library is a tool used for fine-tuning the LayoutLMv3 model.,tool, model fine-tuning,7.0,12,UNKNOWN\n5,\tMachine Learning,accuracy,accuracy is a metric used to evaluate machine learning models.,evaluation metric, task,9.0,6,UNKNOWN\n6,\tMachine Learning,precision,precision is a metric used to evaluate machine learning models.,evaluation metric, task,9.0,6,UNKNOWN\n    ```\n    -----Sources-----\n    ```csv\n    id,\tcontent\n1,\t=predictions, references=references)\n>>> results\n{'exact_match': 100.0, 'f1': 100.0}\n```\n\nYou can find examples of dataset structures by consulting the \"Dataset Preview\" function or the dataset card for a given dataset, and you can see how to use its dedicated evaluation function based on the metric card.\n2,\tChoosing a metric for your task\n\n**So you've trained your model and want to see how well it\u2019s doing on a dataset of your choice. Where do you start?**\n\nThere is no \u201cone size fits all\u201d approach to choosing an evaluation metric, but some good guidelines to keep in mind are:\n\n## Categories of metrics\n\nThere are 3 high-level categories of metrics:\n\n1. *Generic metrics*, which can be applied to a variety of situations and datasets, such as precision and accuracy.\n2. *Task-specific metrics*, which are limited to a given task, such as Machine Translation (often evaluated using metrics [BLEU](https://huggingface.co/metrics/bleu) or [ROUGE](https://huggingface.co/metrics/rouge)) or Named Entity Recognition (often evaluated with [seqeval](https://huggingface.co/metrics/seqeval)).\n3. *Dataset-specific metrics*, which aim to measure model performance on specific benchmarks: for instance, the [GLUE benchmark](https://huggingface.co/datasets/glue) has a dedicated [evaluation metric](https://huggingface.co/metrics/glue).\n\nLet's look at each of these three cases:\n\n### Generic metrics\n\nMany of the metrics used in the Machine Learning community are quite generic and can be applied in a variety of tasks and datasets.\n\nThis is the case for metrics like [accuracy](https://huggingface.co/metrics/accuracy) and [precision](https://huggingface.co/metrics/precision), which can be used for evaluating labeled (supervised) datasets, as well as [perplexity](https://huggingface.co/metrics/perplexity), which can be used for evaluating different kinds of (unsupervised) generative tasks.\n\nTo see the input structure of a given metric, you can look at its metric card. For example, in the case of [precision](https://huggingface.co/metrics/precision), the format is:\n```\n>>> precision_metric = evaluate.load(\"precision\")\n>>> results = precision_metric.compute(references=[0, 1], predictions=[0, 1])\n>>> print(results)\n{'precision': 1.0}\n```\n\n### Task-specific metrics\n\nPopular ML tasks like Machine Translation and Named Entity Recognition have specific metrics that can be used to compare models. For example, a series of different metrics have been proposed for text generation, ranging from [BLEU](https://huggingface.co/metrics/bleu) and its derivatives such as [GoogleBLEU](https://huggingface.co/metrics/google_bleu) and [GLEU](https://huggingface.co/metrics/gleu), but also [ROUGE](https://huggingface.co/metrics/rouge), [MAUVE](https://huggingface.co/metrics/mauve), etc.\n\nYou can find the right metric for your task by:\n\n- **Looking at the [Task pages](https://huggingface.co/tasks)** to see what metrics can be used for evaluating models for a given task.\n- **Checking out leaderboards** on sites like [Papers With Code](https://paperswithcode.com/) (you can search by task and by dataset).\n-  **Reading the metric cards** for the relevant metrics and see which ones are a good fit for your use case. For example, see the [BLEU metric card](https://github.com/huggingface/evaluate/tree/main/metrics/bleu) or [SQuaD metric card](https://github.com/huggingface/evaluate/tree/main/metrics/squad).\n- **Looking at papers and blog posts** published on the topic and see what metrics they report. This can change over time, so try to pick papers from the last couple of years!\n\n### Dataset-specific metrics\n\nSome datasets have specific metrics associated with them -- this is especially in the case of popular benchmarks like [GLUE](https://huggingface.co/metrics/glue) and [SQuAD](https://huggingface.co/metrics/squad).\n\n<Tip warning={true}>\n\ud83d\udca1\nGLUE is actually a collection of different subsets on different tasks, so first you need to choose the one that corresponds to the NLI task, such as mnli, which is described as \u201ccrowdsourced collection of sentence pairs with textual entailment annotations\u201d\n</Tip>\n\n\nIf you are evaluating your model on a benchmark dataset like the ones mentioned above, you can use its dedicated evaluation metric. Make sure you respect the format that they require. For example, to evaluate your model on the [SQuAD](https://huggingface.co/datasets/squad) dataset, you need to feed the `question` and `context` into your model and return the `prediction_text`, which should be compared with the `references` (based on matching the `id` of the question) :\n\n```\n>>> from evaluate import load\n>>> squad_metric = load(\"squad\")\n>>> predictions = [{'prediction_text': '1976', 'id': '56e10a3be3433e1400422b22'}]\n>>> references = [{'answers': {'answer_start': [97], 'text': ['1976']}, 'id': '56e10a3be3433e1400422b22'}]\n>>> results = squad_metric.compute(predictions=predictions, references=references)\n>>> results\n{'exact_match': 100.0, 'f1': 100.0}\n```\n\nYou can find examples of dataset structures by consulting the \"Dataset Preview\" function or the dataset card for a given dataset, and you can see how to use its dedicated evaluation function based on the metric card.\n3,\t!---\nCopyright 2022 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n-->\n\n# Token classification with LayoutLMv3 (PyTorch version)\n\nThis directory contains a script, `run_funsd_cord.py`, that can be used to fine-tune (or evaluate) LayoutLMv3 on form understanding datasets, such as [FUNSD](https://guillaumejaume.github.io/FUNSD/) and [CORD](https://github.com/clovaai/cord).\n\nThe script `run_funsd_cord.py` leverages the \ud83e\udd17 Datasets library and the Trainer API. You can easily customize it to your needs.\n\n## Fine-tuning on FUNSD\n\nFine-tuning LayoutLMv3 for token classification on [FUNSD](https://guillaumejaume.github.io/FUNSD/) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name funsd \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 1e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-funsd\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd. By specifying the `push_to_hub` flag, the model gets uploaded automatically to the hub (regularly), together with a model card, which includes metrics such as precision, recall and F1. Note that you can easily update the model card, as it's just a README file of the respective repo on the hub.\n\nThere's also the \"Training metrics\" [tab](https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd/tensorboard), which shows Tensorboard logs over the course of training. Pretty neat, huh?\n\n## Fine-tuning on CORD\n\nFine-tuning LayoutLMv3 for token classification on [CORD](https://github.com/clovaai/cord) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name cord \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 5e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-cord\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-cord. Note that a model card gets generated automatically in case you specify the `push_to_hub` flag.\n    ```",
            "vector_context": "[Created at: 2025-03-24 13:16:13]\nChoosing a metric for your task\n\n**So you've trained your model and want to see how well it\u2019s doing on a dataset of your choice. Where do you start?**\n\nThere is no \u201cone size fits all\u201d approach to choosing an evaluation metric, but some good guidelines to keep in mind are:\n\n## Categories of metrics\n\nThere are 3 high-level categories of metrics:\n\n1. *Generic metrics*, which can be applied to a variety of situations and datasets, such as precision and accuracy.\n2. *Task-specific metrics*, which are limited to a given task, such as Machine Translation (often evaluated using metrics [BLEU](https://huggingface.co/metrics/bleu) or [ROUGE](https://huggingface.co/metrics/rouge)) or Named Entity Recognition (often evaluated with [seqeval](https://huggingface.co/metrics/seqeval)).\n3. *Dataset-specific metrics*, which aim to measure model performance on specific benchmarks: for instance, the [GLUE benchmark](https://huggingface.co/datasets/glue) has a dedicated [evaluation metric](https://huggingface.co/metrics/glue).\n\nLet's look at each of these three cases:\n\n### Generic metrics\n\nMany of the metrics used in the Machine Learning community are quite generic and can be applied in a variety of tasks and datasets.\n\nThis is the case for metrics like [accuracy](https://huggingface.co/metrics/accuracy) and [precision](https://huggingface.co/metrics/precision), which can be used for evaluating labeled (supervised) datasets, as well as [perplexity](https://huggingface.co/metrics/perplexity), which can be used for evaluating different kinds of (unsupervised) generative tasks.\n\nTo see the input structure of a given metric, you can look at its metric card. For example, in the case of [precision](https://huggingface.co/metrics/precision), the format is:\n```\n>>> precision_metric = evaluate.load(\"precision\")\n>>> results = precision_metric.compute(references=[0, 1], predictions=[0, 1])\n>>> print(results)\n{'precision': 1.0}\n```\n\n### Task-specific metrics\n\nPopular ML tasks like Machine Translation and Named Entity Recognition have specific metrics that can be used to compare models. For example, a series of different metrics have been proposed for text generation, ranging from [BLEU](https://huggingface.co/metrics/bleu) and its derivatives such as [GoogleBLEU](https://huggingface.co/metrics/google_bleu) and [GLEU](https://huggingface.co/metrics/gleu), but also [ROUGE](https://huggingface.co/metrics/rouge), [MAUVE](https://huggingface.co/metrics/mauve), etc.\n\nYou can find the right metric for your task by:\n\n- **Looking at the [Task pages](https://huggingface.co/tasks)** to see what metrics can be used for evaluating models for a given task.\n- **Checking out leaderboards** on sites like [Papers With Code](https://paperswithcode.com/) (you can search by task and by dataset).\n-  **Reading the metric cards** for the relevant metrics and see which ones are a good fit for your use case. For example, see the [BLEU metric card](https://github.com/huggingface/evaluate/tree/main/metrics/bleu) or [SQuaD metric card](https://github.com/huggingface/evaluate/tree/main/metrics/squad).\n- **Looking at papers and blog posts** published on the topic and see what metrics they report. This can change over time, so try to pick papers from the last couple of years!\n\n### Dataset-specific metrics\n\nSome datasets have specific metrics associated with them -- this is especially in the case of popular benchmarks like [GLUE](https://huggingface.co/metrics/glue) and [SQuAD](https://huggingface.co/metrics/squad).\n\n<Tip warning={true}>\n\ud83d\udca1\nGLUE is actually a collection of different subsets on different tasks, so first you need to choose the one that corresponds to the NLI task, such as mnli, which is described as \u201ccrowdsourced collection of sentence pairs with textual entailment annotations\u201d\n</Tip>\n\n\nIf you are evaluating your model on a benchmark dataset like the ones mentioned above, you can use its dedicated evaluation metric. Make sure you respect the format that they require. For example, to evaluate your model on the [SQuAD](https://huggingface.co/datasets/squad) dataset, you need to feed the `question` and `context` into your model and return the `prediction_text`, which should be compared with the `references` (based on matching the `id` of the question) :\n\n```\n>>> from evaluate import load\n>>> squad_metric = load(\"squad\")\n>>> predictions = [{'prediction_text': '1976', 'id': '56e10a3be3433e1400422b22'}]\n>>> references = [{'answers': {'answer_start': [97], 'text': ['1976']}, 'id': '56e10a3be3433e1400422b22'}]\n>>> results = squad_metric.compute(predictions=predictions, references=references)\n>>> results\n{'exact_match': 100.0, 'f1': 100.0}\n```\n\nYou can find examples of dataset structures by consulting the \"Dataset Preview\" function or the dataset card for a given dataset, and you can see how to use its dedicated evaluation function based on the metric card.\n--New Chunk--\n[Created at: 2025-03-24 13:16:13]\n=predictions, references=references)\n>>> results\n{'exact_match': 100.0, 'f1': 100.0}\n```\n\nYou can find examples of dataset structures by consulting the \"Dataset Preview\" function or the dataset card for a given dataset, and you can see how to use its dedicated evaluation function based on the metric card.\n--New Chunk--\n[Created at: 2025-03-24 13:19:17]\n!---\nCopyright 2022 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n-->\n\n# Token classification with LayoutLMv3 (PyTorch version)\n\nThis directory contains a script, `run_funsd_cord.py`, that can be used to fine-tune (or evaluate) LayoutLMv3 on form understanding datasets, such as [FUNSD](https://guillaumejaume.github.io/FUNSD/) and [CORD](https://github.com/clovaai/cord).\n\nThe script `run_funsd_cord.py` leverages the \ud83e\udd17 Datasets library and the Trainer API. You can easily customize it to your needs.\n\n## Fine-tuning on FUNSD\n\nFine-tuning LayoutLMv3 for token classification on [FUNSD](https://guillaumejaume.github.io/FUNSD/) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name funsd \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 1e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-funsd\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd. By specifying the `push_to_hub` flag, the model gets uploaded automatically to the hub (regularly), together with a model card, which includes metrics such as precision, recall and F1. Note that you can easily update the model card, as it's just a README file of the respective repo on the hub.\n\nThere's also the \"Training metrics\" [tab](https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd/tensorboard), which shows Tensorboard logs over the course of training. Pretty neat, huh?\n\n## Fine-tuning on CORD\n\nFine-tuning LayoutLMv3 for token classification on [CORD](https://github.com/clovaai/cord) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name cord \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 5e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-cord\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-cord. Note that a model card gets generated automatically in case you specify the `push_to_hub` flag."
        }
    },
    {
        "sample_idx": 135,
        "question": "What is the top 5 accuracy of the model on ImageNet?",
        "answer": "95.07%",
        "rag_answer": "The provided Data Sources do not mention the top 5 accuracy of a model on ImageNet. The discussion is focused on machine learning, evaluation metrics, and fine-tuning LayoutLMv3 on form understanding datasets such as FUNSD and CORD. There is no mention of ImageNet or a specific model's performance on it.\n\nReferences:\nNone",
        "rag_score": 1,
        "rag_feedback": "The system's response does not provide the top 5 accuracy of the model on ImageNet, which is the expected answer. Instead, it provides a lengthy text discussing machine learning, evaluation metrics, and fine-tuning LayoutLMv3 on form understanding datasets. The response is completely incorrect, inaccurate, and not factual.",
        "rag_context": {
            "kg_context": "-----Entities-----\n    ```csv\n    id,\tentity,\ttype,\tdescription,\trankcreated_at\n1,\tMachine Learning,category,Machine Learning is a field of study that involves training models to make predictions.,5,2025-03-24 13:16:48\n2,\tModel,category,Model refers to a machine learning model being evaluated.,3,2025-03-24 13:16:48\n3,\taccuracy,category,accuracy is a category of evaluation metrics for machine learning models.,1,2025-03-24 13:16:48\n4,\tprecision,category,precision is a category of evaluation metrics for machine learning models.,1,2025-03-24 13:16:48\n5,\tDatasets library,technology,Datasets library is a tool used for fine-tuning the LayoutLMv3 model.,1,UNKNOWN\n6,\tCORD,geo,CORD is a form understanding dataset used for fine-tuning LayoutLMv3.,1,UNKNOWN\n7,\tGLUE,dataset,GLUE is a benchmark dataset for evaluating natural language processing models.,1,UNKNOWN\n    ```\n    -----Relationships-----\n    ```csv\n    id,\tsource,\ttarget,\tdescription,\tkeywords,\tweight,\trank,\tcreated_at\n1,\tMachine Learning,Model,Machine Learning involves training models to make predictions.,field of study, model training,9.0,8,2025-03-24 13:16:48\n2,\tMachine Learning,accuracy,accuracy is a metric used to evaluate machine learning models.,evaluation metric, task,9.0,6,2025-03-24 13:16:48\n3,\tMachine Learning,precision,precision is a metric used to evaluate machine learning models.,evaluation metric, task,9.0,6,2025-03-24 13:16:48\n4,\tCORD,LayoutLMv3,CORD is a dataset used for fine-tuning the LayoutLMv3 model.,dataset, model training,14.0,12,UNKNOWN\n5,\tDatasets library,LayoutLMv3,Datasets library is a tool used for fine-tuning the LayoutLMv3 model.,tool, model fine-tuning,7.0,12,UNKNOWN\n6,\tGLUE,Hugging Face,Hugging Face provides a platform for evaluating models on the GLUE benchmark dataset.,evaluation platform, benchmark dataset,16.0,9,UNKNOWN\n    ```\n    -----Sources-----\n    ```csv\n    id,\tcontent\n1,\t=predictions, references=references)\n>>> results\n{'exact_match': 100.0, 'f1': 100.0}\n```\n\nYou can find examples of dataset structures by consulting the \"Dataset Preview\" function or the dataset card for a given dataset, and you can see how to use its dedicated evaluation function based on the metric card.\n2,\tChoosing a metric for your task\n\n**So you've trained your model and want to see how well it\u2019s doing on a dataset of your choice. Where do you start?**\n\nThere is no \u201cone size fits all\u201d approach to choosing an evaluation metric, but some good guidelines to keep in mind are:\n\n## Categories of metrics\n\nThere are 3 high-level categories of metrics:\n\n1. *Generic metrics*, which can be applied to a variety of situations and datasets, such as precision and accuracy.\n2. *Task-specific metrics*, which are limited to a given task, such as Machine Translation (often evaluated using metrics [BLEU](https://huggingface.co/metrics/bleu) or [ROUGE](https://huggingface.co/metrics/rouge)) or Named Entity Recognition (often evaluated with [seqeval](https://huggingface.co/metrics/seqeval)).\n3. *Dataset-specific metrics*, which aim to measure model performance on specific benchmarks: for instance, the [GLUE benchmark](https://huggingface.co/datasets/glue) has a dedicated [evaluation metric](https://huggingface.co/metrics/glue).\n\nLet's look at each of these three cases:\n\n### Generic metrics\n\nMany of the metrics used in the Machine Learning community are quite generic and can be applied in a variety of tasks and datasets.\n\nThis is the case for metrics like [accuracy](https://huggingface.co/metrics/accuracy) and [precision](https://huggingface.co/metrics/precision), which can be used for evaluating labeled (supervised) datasets, as well as [perplexity](https://huggingface.co/metrics/perplexity), which can be used for evaluating different kinds of (unsupervised) generative tasks.\n\nTo see the input structure of a given metric, you can look at its metric card. For example, in the case of [precision](https://huggingface.co/metrics/precision), the format is:\n```\n>>> precision_metric = evaluate.load(\"precision\")\n>>> results = precision_metric.compute(references=[0, 1], predictions=[0, 1])\n>>> print(results)\n{'precision': 1.0}\n```\n\n### Task-specific metrics\n\nPopular ML tasks like Machine Translation and Named Entity Recognition have specific metrics that can be used to compare models. For example, a series of different metrics have been proposed for text generation, ranging from [BLEU](https://huggingface.co/metrics/bleu) and its derivatives such as [GoogleBLEU](https://huggingface.co/metrics/google_bleu) and [GLEU](https://huggingface.co/metrics/gleu), but also [ROUGE](https://huggingface.co/metrics/rouge), [MAUVE](https://huggingface.co/metrics/mauve), etc.\n\nYou can find the right metric for your task by:\n\n- **Looking at the [Task pages](https://huggingface.co/tasks)** to see what metrics can be used for evaluating models for a given task.\n- **Checking out leaderboards** on sites like [Papers With Code](https://paperswithcode.com/) (you can search by task and by dataset).\n-  **Reading the metric cards** for the relevant metrics and see which ones are a good fit for your use case. For example, see the [BLEU metric card](https://github.com/huggingface/evaluate/tree/main/metrics/bleu) or [SQuaD metric card](https://github.com/huggingface/evaluate/tree/main/metrics/squad).\n- **Looking at papers and blog posts** published on the topic and see what metrics they report. This can change over time, so try to pick papers from the last couple of years!\n\n### Dataset-specific metrics\n\nSome datasets have specific metrics associated with them -- this is especially in the case of popular benchmarks like [GLUE](https://huggingface.co/metrics/glue) and [SQuAD](https://huggingface.co/metrics/squad).\n\n<Tip warning={true}>\n\ud83d\udca1\nGLUE is actually a collection of different subsets on different tasks, so first you need to choose the one that corresponds to the NLI task, such as mnli, which is described as \u201ccrowdsourced collection of sentence pairs with textual entailment annotations\u201d\n</Tip>\n\n\nIf you are evaluating your model on a benchmark dataset like the ones mentioned above, you can use its dedicated evaluation metric. Make sure you respect the format that they require. For example, to evaluate your model on the [SQuAD](https://huggingface.co/datasets/squad) dataset, you need to feed the `question` and `context` into your model and return the `prediction_text`, which should be compared with the `references` (based on matching the `id` of the question) :\n\n```\n>>> from evaluate import load\n>>> squad_metric = load(\"squad\")\n>>> predictions = [{'prediction_text': '1976', 'id': '56e10a3be3433e1400422b22'}]\n>>> references = [{'answers': {'answer_start': [97], 'text': ['1976']}, 'id': '56e10a3be3433e1400422b22'}]\n>>> results = squad_metric.compute(predictions=predictions, references=references)\n>>> results\n{'exact_match': 100.0, 'f1': 100.0}\n```\n\nYou can find examples of dataset structures by consulting the \"Dataset Preview\" function or the dataset card for a given dataset, and you can see how to use its dedicated evaluation function based on the metric card.\n3,\t!---\nCopyright 2022 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n-->\n\n# Token classification with LayoutLMv3 (PyTorch version)\n\nThis directory contains a script, `run_funsd_cord.py`, that can be used to fine-tune (or evaluate) LayoutLMv3 on form understanding datasets, such as [FUNSD](https://guillaumejaume.github.io/FUNSD/) and [CORD](https://github.com/clovaai/cord).\n\nThe script `run_funsd_cord.py` leverages the \ud83e\udd17 Datasets library and the Trainer API. You can easily customize it to your needs.\n\n## Fine-tuning on FUNSD\n\nFine-tuning LayoutLMv3 for token classification on [FUNSD](https://guillaumejaume.github.io/FUNSD/) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name funsd \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 1e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-funsd\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd. By specifying the `push_to_hub` flag, the model gets uploaded automatically to the hub (regularly), together with a model card, which includes metrics such as precision, recall and F1. Note that you can easily update the model card, as it's just a README file of the respective repo on the hub.\n\nThere's also the \"Training metrics\" [tab](https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd/tensorboard), which shows Tensorboard logs over the course of training. Pretty neat, huh?\n\n## Fine-tuning on CORD\n\nFine-tuning LayoutLMv3 for token classification on [CORD](https://github.com/clovaai/cord) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name cord \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 5e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-cord\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-cord. Note that a model card gets generated automatically in case you specify the `push_to_hub` flag.\n    ```",
            "vector_context": "[Created at: 2025-03-24 13:16:13]\nChoosing a metric for your task\n\n**So you've trained your model and want to see how well it\u2019s doing on a dataset of your choice. Where do you start?**\n\nThere is no \u201cone size fits all\u201d approach to choosing an evaluation metric, but some good guidelines to keep in mind are:\n\n## Categories of metrics\n\nThere are 3 high-level categories of metrics:\n\n1. *Generic metrics*, which can be applied to a variety of situations and datasets, such as precision and accuracy.\n2. *Task-specific metrics*, which are limited to a given task, such as Machine Translation (often evaluated using metrics [BLEU](https://huggingface.co/metrics/bleu) or [ROUGE](https://huggingface.co/metrics/rouge)) or Named Entity Recognition (often evaluated with [seqeval](https://huggingface.co/metrics/seqeval)).\n3. *Dataset-specific metrics*, which aim to measure model performance on specific benchmarks: for instance, the [GLUE benchmark](https://huggingface.co/datasets/glue) has a dedicated [evaluation metric](https://huggingface.co/metrics/glue).\n\nLet's look at each of these three cases:\n\n### Generic metrics\n\nMany of the metrics used in the Machine Learning community are quite generic and can be applied in a variety of tasks and datasets.\n\nThis is the case for metrics like [accuracy](https://huggingface.co/metrics/accuracy) and [precision](https://huggingface.co/metrics/precision), which can be used for evaluating labeled (supervised) datasets, as well as [perplexity](https://huggingface.co/metrics/perplexity), which can be used for evaluating different kinds of (unsupervised) generative tasks.\n\nTo see the input structure of a given metric, you can look at its metric card. For example, in the case of [precision](https://huggingface.co/metrics/precision), the format is:\n```\n>>> precision_metric = evaluate.load(\"precision\")\n>>> results = precision_metric.compute(references=[0, 1], predictions=[0, 1])\n>>> print(results)\n{'precision': 1.0}\n```\n\n### Task-specific metrics\n\nPopular ML tasks like Machine Translation and Named Entity Recognition have specific metrics that can be used to compare models. For example, a series of different metrics have been proposed for text generation, ranging from [BLEU](https://huggingface.co/metrics/bleu) and its derivatives such as [GoogleBLEU](https://huggingface.co/metrics/google_bleu) and [GLEU](https://huggingface.co/metrics/gleu), but also [ROUGE](https://huggingface.co/metrics/rouge), [MAUVE](https://huggingface.co/metrics/mauve), etc.\n\nYou can find the right metric for your task by:\n\n- **Looking at the [Task pages](https://huggingface.co/tasks)** to see what metrics can be used for evaluating models for a given task.\n- **Checking out leaderboards** on sites like [Papers With Code](https://paperswithcode.com/) (you can search by task and by dataset).\n-  **Reading the metric cards** for the relevant metrics and see which ones are a good fit for your use case. For example, see the [BLEU metric card](https://github.com/huggingface/evaluate/tree/main/metrics/bleu) or [SQuaD metric card](https://github.com/huggingface/evaluate/tree/main/metrics/squad).\n- **Looking at papers and blog posts** published on the topic and see what metrics they report. This can change over time, so try to pick papers from the last couple of years!\n\n### Dataset-specific metrics\n\nSome datasets have specific metrics associated with them -- this is especially in the case of popular benchmarks like [GLUE](https://huggingface.co/metrics/glue) and [SQuAD](https://huggingface.co/metrics/squad).\n\n<Tip warning={true}>\n\ud83d\udca1\nGLUE is actually a collection of different subsets on different tasks, so first you need to choose the one that corresponds to the NLI task, such as mnli, which is described as \u201ccrowdsourced collection of sentence pairs with textual entailment annotations\u201d\n</Tip>\n\n\nIf you are evaluating your model on a benchmark dataset like the ones mentioned above, you can use its dedicated evaluation metric. Make sure you respect the format that they require. For example, to evaluate your model on the [SQuAD](https://huggingface.co/datasets/squad) dataset, you need to feed the `question` and `context` into your model and return the `prediction_text`, which should be compared with the `references` (based on matching the `id` of the question) :\n\n```\n>>> from evaluate import load\n>>> squad_metric = load(\"squad\")\n>>> predictions = [{'prediction_text': '1976', 'id': '56e10a3be3433e1400422b22'}]\n>>> references = [{'answers': {'answer_start': [97], 'text': ['1976']}, 'id': '56e10a3be3433e1400422b22'}]\n>>> results = squad_metric.compute(predictions=predictions, references=references)\n>>> results\n{'exact_match': 100.0, 'f1': 100.0}\n```\n\nYou can find examples of dataset structures by consulting the \"Dataset Preview\" function or the dataset card for a given dataset, and you can see how to use its dedicated evaluation function based on the metric card.\n--New Chunk--\n[Created at: 2025-03-24 13:16:13]\n=predictions, references=references)\n>>> results\n{'exact_match': 100.0, 'f1': 100.0}\n```\n\nYou can find examples of dataset structures by consulting the \"Dataset Preview\" function or the dataset card for a given dataset, and you can see how to use its dedicated evaluation function based on the metric card.\n--New Chunk--\n[Created at: 2025-03-24 13:19:17]\n!---\nCopyright 2022 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n-->\n\n# Token classification with LayoutLMv3 (PyTorch version)\n\nThis directory contains a script, `run_funsd_cord.py`, that can be used to fine-tune (or evaluate) LayoutLMv3 on form understanding datasets, such as [FUNSD](https://guillaumejaume.github.io/FUNSD/) and [CORD](https://github.com/clovaai/cord).\n\nThe script `run_funsd_cord.py` leverages the \ud83e\udd17 Datasets library and the Trainer API. You can easily customize it to your needs.\n\n## Fine-tuning on FUNSD\n\nFine-tuning LayoutLMv3 for token classification on [FUNSD](https://guillaumejaume.github.io/FUNSD/) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name funsd \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 1e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-funsd\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd. By specifying the `push_to_hub` flag, the model gets uploaded automatically to the hub (regularly), together with a model card, which includes metrics such as precision, recall and F1. Note that you can easily update the model card, as it's just a README file of the respective repo on the hub.\n\nThere's also the \"Training metrics\" [tab](https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd/tensorboard), which shows Tensorboard logs over the course of training. Pretty neat, huh?\n\n## Fine-tuning on CORD\n\nFine-tuning LayoutLMv3 for token classification on [CORD](https://github.com/clovaai/cord) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name cord \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 5e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-cord\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-cord. Note that a model card gets generated automatically in case you specify the `push_to_hub` flag."
        }
    },
    {
        "sample_idx": 136,
        "question": "What dataset is used for training the model?",
        "answer": "ImageNet",
        "rag_answer": "The dataset used for training the model is FUNSD (Form Understanding in Noisy Scanned Documents) and CORD (Clova OCR Dataset). These are form understanding datasets used for fine-tuning LayoutLMv3 on token classification tasks.",
        "rag_score": 1,
        "rag_feedback": "The system's response is completely incorrect, inaccurate, and/or not factual. The expected answer is 'ImageNet', but the system's response mentions 'FUNSD (Form Understanding in Noisy Scanned Documents) and CORD (Clova OCR Dataset)' which are unrelated to the question.",
        "rag_context": {
            "kg_context": "-----Entities-----\n    ```csv\n    id,\tentity,\ttype,\tdescription,\trankcreated_at\n1,\tFUNSD,geo,FUNSD is a form understanding dataset used for fine-tuning LayoutLMv3.,1,2025-03-24 13:16:48\n2,\tLayoutLMv3,technology,LayoutLMv3 is a model used for token classification and form understanding tasks.,11,2025-03-24 13:16:48\n3,\tDatasets library,technology,Datasets library is a tool used for fine-tuning the LayoutLMv3 model.,1,2025-03-24 13:16:48\n4,\tMachine Learning,category,Machine Learning is a field of study that involves training models to make predictions.,5,2025-03-24 13:16:48\n5,\tModel,category,Model refers to a machine learning model being evaluated.,3,2025-03-24 13:16:48\n6,\tPreprocessing,concept,Preprocessing refers to the process of preparing data for use in machine learning models.,1,UNKNOWN\n7,\tMachine Learning,category,Machine Learning is a field of study that involves training models to make predictions.,5,UNKNOWN\n8,\tPostprocessing,concept,Postprocessing refers to the process of transforming output from machine learning models into a usable format.,1,UNKNOWN\n    ```\n    -----Relationships-----\n    ```csv\n    id,\tsource,\ttarget,\tdescription,\tkeywords,\tweight,\trank,\tcreated_at\n1,\tFUNSD,LayoutLMv3,FUNSD is a dataset used for fine-tuning the LayoutLMv3 model.,dataset, model training,14.0,12,2025-03-24 13:19:57\n2,\tDatasets library,LayoutLMv3,Datasets library is a tool used for fine-tuning the LayoutLMv3 model.,tool, model fine-tuning,7.0,12,2025-03-24 13:19:57\n3,\tMachine Learning,Model,Machine Learning involves training models to make predictions.,field of study, model training,9.0,8,2025-03-24 13:16:48\n4,\tGradio,Preprocessing,Gradio supports preprocessing of data for machine learning models.,data preprocessing, machine learning,8.0,37,UNKNOWN\n5,\tGradio,Postprocessing,Gradio supports postprocessing of output from machine learning models.,output transformation, machine learning,8.0,37,UNKNOWN\n6,\tMachine Learning,Model,Machine Learning involves training models to make predictions.,field of study, model training,9.0,8,UNKNOWN\n7,\tMachine Learning,accuracy,accuracy is a metric used to evaluate machine learning models.,evaluation metric, task,9.0,6,UNKNOWN\n8,\tMachine Learning,precision,precision is a metric used to evaluate machine learning models.,evaluation metric, task,9.0,6,UNKNOWN\n9,\tMachine Learning,perplexity,perplexity is a metric used to evaluate machine learning models.,evaluation metric, task,9.0,6,UNKNOWN\n10,\tMachine Learning,Papers With Code,Papers With Code provides a platform for tracking machine learning papers and their corresponding code.,research platform, machine learning,8.0,6,UNKNOWN\n    ```\n    -----Sources-----\n    ```csv\n    id,\tcontent\n1,\t!---\nCopyright 2022 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n-->\n\n# Token classification with LayoutLMv3 (PyTorch version)\n\nThis directory contains a script, `run_funsd_cord.py`, that can be used to fine-tune (or evaluate) LayoutLMv3 on form understanding datasets, such as [FUNSD](https://guillaumejaume.github.io/FUNSD/) and [CORD](https://github.com/clovaai/cord).\n\nThe script `run_funsd_cord.py` leverages the \ud83e\udd17 Datasets library and the Trainer API. You can easily customize it to your needs.\n\n## Fine-tuning on FUNSD\n\nFine-tuning LayoutLMv3 for token classification on [FUNSD](https://guillaumejaume.github.io/FUNSD/) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name funsd \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 1e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-funsd\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd. By specifying the `push_to_hub` flag, the model gets uploaded automatically to the hub (regularly), together with a model card, which includes metrics such as precision, recall and F1. Note that you can easily update the model card, as it's just a README file of the respective repo on the hub.\n\nThere's also the \"Training metrics\" [tab](https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd/tensorboard), which shows Tensorboard logs over the course of training. Pretty neat, huh?\n\n## Fine-tuning on CORD\n\nFine-tuning LayoutLMv3 for token classification on [CORD](https://github.com/clovaai/cord) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name cord \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 5e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-cord\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-cord. Note that a model card gets generated automatically in case you specify the `push_to_hub` flag.\n2,\t=predictions, references=references)\n>>> results\n{'exact_match': 100.0, 'f1': 100.0}\n```\n\nYou can find examples of dataset structures by consulting the \"Dataset Preview\" function or the dataset card for a given dataset, and you can see how to use its dedicated evaluation function based on the metric card.\n3,\t\u65f6\u5fc5\u987b\u9009\u62e9\u5176\u4e2d\u4e00\u4e2a\u5b57\u7b26\u4e32\uff0c\u8fd9\u5c06\u4f5c\u4e3a\u9644\u52a0\u5217\u4fdd\u5b58\u5230 CSV \u4e2d\u3002\n\n## \u9884\u5904\u7406\u548c\u540e\u5904\u7406 (Preprocessing and Postprocessing)\n\n![annotated](/assets/img/dataflow.svg)\n\n\u5982\u60a8\u6240\u89c1\uff0cGradio \u5305\u62ec\u53ef\u4ee5\u5904\u7406\u5404\u79cd\u4e0d\u540c\u6570\u636e\u7c7b\u578b\u7684\u7ec4\u4ef6\uff0c\u4f8b\u5982\u56fe\u50cf\u3001\u97f3\u9891\u548c\u89c6\u9891\u3002\u5927\u591a\u6570\u7ec4\u4ef6\u90fd\u53ef\u4ee5\u7528\u4f5c\u8f93\u5165\u6216\u8f93\u51fa\u3002\n\n\u5f53\u7ec4\u4ef6\u7528\u4f5c\u8f93\u5165\u65f6\uff0cGradio \u81ea\u52a8\u5904\u7406*\u9884\u5904\u7406*\uff0c\u5c06\u6570\u636e\u4ece\u7528\u6237\u6d4f\u89c8\u5668\u53d1\u9001\u7684\u7c7b\u578b\uff08\u4f8b\u5982\u7f51\u7edc\u6444\u50cf\u5934\u5feb\u7167\u7684 base64 \u8868\u793a\uff09\u8f6c\u6362\u4e3a\u60a8\u7684\u51fd\u6570\u53ef\u4ee5\u63a5\u53d7\u7684\u5f62\u5f0f\uff08\u4f8b\u5982 `numpy` \u6570\u7ec4\uff09\u3002\n\n\u540c\u6837\uff0c\u5f53\u7ec4\u4ef6\u7528\u4f5c\u8f93\u51fa\u65f6\uff0cGradio \u81ea\u52a8\u5904\u7406*\u540e\u5904\u7406*\uff0c\u5c06\u6570\u636e\u4ece\u51fd\u6570\u8fd4\u56de\u7684\u5f62\u5f0f\uff08\u4f8b\u5982\u56fe\u50cf\u8def\u5f84\u5217\u8868\uff09\u8f6c\u6362\u4e3a\u53ef\u4ee5\u5728\u7528\u6237\u6d4f\u89c8\u5668\u4e2d\u663e\u793a\u7684\u5f62\u5f0f\uff08\u4f8b\u5982\u4ee5 base64 \u683c\u5f0f\u663e\u793a\u56fe\u50cf\u7684 `Gallery`\uff09\u3002\n\n\u60a8\u53ef\u4ee5\u4f7f\u7528\u6784\u5efa\u56fe\u50cf\u7ec4\u4ef6\u65f6\u7684\u53c2\u6570\u63a7\u5236*\u9884\u5904\u7406*\u3002\u4f8b\u5982\uff0c\u5982\u679c\u60a8\u4f7f\u7528\u4ee5\u4e0b\u53c2\u6570\u5b9e\u4f8b\u5316 `Image` \u7ec4\u4ef6\uff0c\u5b83\u5c06\u5c06\u56fe\u50cf\u8f6c\u6362\u4e3a `PIL` \u7c7b\u578b\uff0c\u5e76\u5c06\u5176\u91cd\u5851\u4e3a`(100, 100)`\uff0c\u800c\u4e0d\u7ba1\u63d0\u4ea4\u65f6\u7684\u539f\u59cb\u5927\u5c0f\u5982\u4f55\uff1a\n\n```py\nimg = gr.Image(shape=(100, 100), type=\"pil\")\n```\n\n\u76f8\u53cd\uff0c\u8fd9\u91cc\u6211\u4eec\u4fdd\u7559\u56fe\u50cf\u7684\u539f\u59cb\u5927\u5c0f\uff0c\u4f46\u5728\u5c06\u5176\u8f6c\u6362\u4e3a numpy \u6570\u7ec4\u4e4b\u524d\u53cd\u8f6c\u989c\u8272\uff1a\n\n```py\nimg = gr.Image(invert_colors=True, type=\"numpy\")\n```\n\n\u540e\u5904\u7406\u8981\u5bb9\u6613\u5f97\u591a\uff01Gradio \u81ea\u52a8\u8bc6\u522b\u8fd4\u56de\u6570\u636e\u7684\u683c\u5f0f\uff08\u4f8b\u5982 `Image` \u662f `numpy` \u6570\u7ec4\u8fd8\u662f `str` \u6587\u4ef6\u8def\u5f84\uff1f\uff09\uff0c\u5e76\u5c06\u5176\u540e\u5904\u7406\u4e3a\u53ef\u4ee5\u7531\u6d4f\u89c8\u5668\u663e\u793a\u7684\u683c\u5f0f\u3002\n\n\u8bf7\u67e5\u770b[\u6587\u6863](https://gradio.app/docs)\uff0c\u4e86\u89e3\u6bcf\u4e2a\u7ec4\u4ef6\u7684\u6240\u6709\u4e0e\u9884\u5904\u7406\u76f8\u5173\u7684\u53c2\u6570\u3002\n\n## \u6837\u5f0f (Styling)\n\nGradio \u4e3b\u9898\u662f\u81ea\u5b9a\u4e49\u5e94\u7528\u7a0b\u5e8f\u5916\u89c2\u548c\u611f\u89c9\u7684\u6700\u7b80\u5355\u65b9\u6cd5\u3002\u60a8\u53ef\u4ee5\u9009\u62e9\u591a\u79cd\u4e3b\u9898\u6216\u521b\u5efa\u81ea\u5df1\u7684\u4e3b\u9898\u3002\u8981\u8fd9\u6837\u505a\uff0c\u8bf7\u5c06 `theme=` \u53c2\u6570\u4f20\u9012\u7ed9 `Interface` \u6784\u9020\u51fd\u6570\u3002\u4f8b\u5982\uff1a\n\n```python\ndemo = gr.Interface(..., theme=gr.themes.Monochrome())\n```\n\nGradio \u5e26\u6709\u4e00\u7ec4\u9884\u5148\u6784\u5efa\u7684\u4e3b\u9898\uff0c\u60a8\u53ef\u4ee5\u4ece `gr.themes.*` \u52a0\u8f7d\u3002\u60a8\u53ef\u4ee5\u6269\u5c55\u8fd9\u4e9b\u4e3b\u9898\u6216\u4ece\u5934\u5f00\u59cb\u521b\u5efa\u81ea\u5df1\u7684\u4e3b\u9898 - \u6709\u5173\u66f4\u591a\u8be6\u7ec6\u4fe1\u606f\uff0c\u8bf7\u53c2\u9605[\u4e3b\u9898\u6307\u5357](https://gradio.app/theming-guide)\u3002\n\n\u8981\u589e\u52a0\u989d\u5916\u7684\u6837\u5f0f\u80fd\u529b\uff0c\u60a8\u53ef\u4ee5 with `css=` \u5173\u952e\u5b57\u5c06\u4efb\u4f55 CSS \u4f20\u9012\u7ed9\u60a8\u7684\u5e94\u7528\u7a0b\u5e8f\u3002\nGradio \u5e94\u7528\u7a0b\u5e8f\u7684\u57fa\u7c7b\u662f `gradio-container`\uff0c\u56e0\u6b64\u4ee5\u4e0b\u662f\u4e00\u4e2a\u66f4\u6539 Gradio \u5e94\u7528\u7a0b\u5e8f\u80cc\u666f\u989c\u8272\u7684\u793a\u4f8b\uff1a\n\n```python\nwith `gr.Interface(css=\".gradio-container {background-color: red}\") as demo:\n    ...\n```\n\n## \u961f\u5217 (Queuing)\n\n\u5982\u679c\u60a8\u7684\u5e94\u7528\u7a0b\u5e8f\u9884\u8ba1\u4f1a\u6709\u5927\u91cf\u6d41\u91cf\uff0c\u8bf7 with `queue()` \u65b9\u6cd5\u6765\u63a7\u5236\u5904\u7406\u901f\u7387\u3002\u8fd9\u5c06\u6392\u961f\u5904\u7406\u8c03\u7528\uff0c\u56e0\u6b64\u4e00\u6b21\u53ea\u5904\u7406\u4e00\u5b9a\u6570\u91cf\u7684\u8bf7\u6c42\u3002\u961f\u5217\u4f7f\u7528 Websockets\uff0c\u8fd8\u53ef\u4ee5\u9632\u6b62\u7f51\u7edc\u8d85\u65f6\uff0c\u56e0\u6b64\u5982\u679c\u60a8\u7684\u51fd\u6570\u7684\u63a8\u7406\u65f6\u95f4\u5f88\u957f\uff08> 1 \u5206\u949f\uff09\uff0c\u5e94\u4f7f\u7528\u961f\u5217\u3002\n\nwith `Interface`\uff1a\n\n```python\ndemo = gr.Interface(...).queue()\ndemo.launch()\n```\n\nwith `Blocks`\uff1a\n\n```python\nwith gr.Blocks() as demo\uff1a\n    #...\ndemo.queue()\ndemo.launch()\n```\n\n\u60a8\u53ef\u4ee5\u901a\u8fc7\u4ee5\u4e0b\u65b9\u5f0f\u63a7\u5236\u4e00\u6b21\u5904\u7406\u7684\u8bf7\u6c42\u6570\u91cf\uff1a\n\n```python\ndemo.queue(concurrency_count=3)\n```\n\n\u67e5\u770b\u6709\u5173\u914d\u7f6e\u5176\u4ed6\u961f\u5217\u53c2\u6570\u7684[\u961f\u5217\u6587\u6863](/docs/#queue)\u3002\n\n\u5728 Blocks \u4e2d\u6307\u5b9a\u4ec5\u5bf9\u67d0\u4e9b\u51fd\u6570\u8fdb\u884c\u6392\u961f\uff1a\n\n```python\nwith gr.Blocks() as demo2\uff1a\n    num1 = gr.Number()\n    num2 = gr.Number()\n    output = gr.Number()\n    gr.Button(\"Add\").click(\n        lambda a, b: a + b, [num1, num2], output)\n    gr.Button(\"Multiply\").click(\n        lambda a, b: a * b, [num1, num2], output, queue=True)\ndemo2.launch()\n```\n\n## \u8fed\u4ee3\u8f93\u51fa (Iterative Outputs)\n\n\u5728\u67d0\u4e9b\u60c5\u51b5\u4e0b\uff0c\u60a8\u53ef\u80fd\u9700\u8981\u4f20\u8f93\u4e00\u7cfb\u5217\u8f93\u51fa\u800c\u4e0d\u662f\u4e00\u6b21\u663e\u793a\u5355\u4e2a\u8f93\u51fa\u3002\u4f8b\u5982\uff0c\u60a8\u53ef\u80fd\u6709\u4e00\u4e2a\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5e0c\u671b\u663e\u793a\u751f\u6210\u7684\u6bcf\u4e2a\u6b65\u9aa4\u7684\u56fe\u50cf\uff0c\u76f4\u5230\u6700\u7ec8\u56fe\u50cf\u3002\u6216\u8005\u60a8\u53ef\u80fd\u6709\u4e00\u4e2a\u804a\u5929\u673a\u5668\u4eba\uff0c\u5b83\u9010\u5b57\u9010\u53e5\u5730\u6d41\u5f0f\u4f20\u8f93\u54cd\u5e94\uff0c\u800c\u4e0d\u662f\u4e00\u6b21\u8fd4\u56de\u5168\u90e8\u54cd\u5e94\u3002\n\n\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u60a8\u53ef\u4ee5\u5c06**\u751f\u6210\u5668**\u51fd\u6570\u63d0\u4f9b\u7ed9 Gradio\uff0c\u800c\u4e0d\u662f\u5e38\u89c4\u51fd\u6570\u3002\u5728 Python \u4e2d\u521b\u5efa\u751f\u6210\u5668\u975e\u5e38\u7b80\u5355\uff1a\u51fd\u6570\u4e0d\u5e94\u8be5\u6709\u4e00\u4e2a\u5355\u72ec\u7684 `return` \u503c\uff0c\u800c\u662f\u5e94\u8be5 with `yield` \u8fde\u7eed\u8fd4\u56de\u4e00\u7cfb\u5217\u503c\u3002\u901a\u5e38\uff0c`yield` \u8bed\u53e5\u653e\u7f6e\u5728\u67d0\u79cd\u5faa\u73af\u4e2d\u3002\u4e0b\u9762\u662f\u4e00\u4e2a\u7b80\u5355\u793a\u4f8b\uff0c\u751f\u6210\u5668\u53ea\u662f\u7b80\u5355\u8ba1\u6570\u5230\u7ed9\u5b9a\u6570\u5b57\uff1a\n\n```python\ndef my_generator(x):\n    for i in range(x):\n        yield i\n```\n\n\u60a8\u4ee5\u4e0e\u5e38\u89c4\u51fd\u6570\u76f8\u540c\u7684\u65b9\u5f0f\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio\u3002\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\uff08\u865a\u62df\u7684\uff09\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5b83\u5728\u8f93\u51fa\u56fe\u50cf\u4e4b\u524d\u751f\u6210\u6570\u4e2a\u6b65\u9aa4\u7684\u566a\u97f3\uff1a\n\n$code_fake_diffusion\n$demo_fake_diffusion\n\n\u8bf7\u6ce8\u610f\uff0c\u6211\u4eec\u5728\u8fed\u4ee3\u5668\u4e2d\u6dfb\u52a0\u4e86 `time.sleep(1)`\uff0c\u4ee5\u521b\u5efa\u6b65\u9aa4\u4e4b\u95f4\u7684\u4eba\u5de5\u6682\u505c\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u89c2\u5bdf\u8fed\u4ee3\u5668\u7684\u6b65\u9aa4\uff08\u5728\u771f\u5b9e\u7684\u56fe\u50cf\u751f\u6210\u6a21\u578b\u4e2d\uff0c\u8fd9\n    ```",
            "vector_context": "[Created at: 2025-03-24 13:16:13]\n=predictions, references=references)\n>>> results\n{'exact_match': 100.0, 'f1': 100.0}\n```\n\nYou can find examples of dataset structures by consulting the \"Dataset Preview\" function or the dataset card for a given dataset, and you can see how to use its dedicated evaluation function based on the metric card.\n--New Chunk--\n[Created at: 2025-03-24 13:19:17]\n!---\nCopyright 2022 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n-->\n\n# Token classification with LayoutLMv3 (PyTorch version)\n\nThis directory contains a script, `run_funsd_cord.py`, that can be used to fine-tune (or evaluate) LayoutLMv3 on form understanding datasets, such as [FUNSD](https://guillaumejaume.github.io/FUNSD/) and [CORD](https://github.com/clovaai/cord).\n\nThe script `run_funsd_cord.py` leverages the \ud83e\udd17 Datasets library and the Trainer API. You can easily customize it to your needs.\n\n## Fine-tuning on FUNSD\n\nFine-tuning LayoutLMv3 for token classification on [FUNSD](https://guillaumejaume.github.io/FUNSD/) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name funsd \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 1e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-funsd\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd. By specifying the `push_to_hub` flag, the model gets uploaded automatically to the hub (regularly), together with a model card, which includes metrics such as precision, recall and F1. Note that you can easily update the model card, as it's just a README file of the respective repo on the hub.\n\nThere's also the \"Training metrics\" [tab](https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd/tensorboard), which shows Tensorboard logs over the course of training. Pretty neat, huh?\n\n## Fine-tuning on CORD\n\nFine-tuning LayoutLMv3 for token classification on [CORD](https://github.com/clovaai/cord) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name cord \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 5e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-cord\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-cord. Note that a model card gets generated automatically in case you specify the `push_to_hub` flag.\n--New Chunk--\n[Created at: 2025-03-24 13:16:13]\nChoosing a metric for your task\n\n**So you've trained your model and want to see how well it\u2019s doing on a dataset of your choice. Where do you start?**\n\nThere is no \u201cone size fits all\u201d approach to choosing an evaluation metric, but some good guidelines to keep in mind are:\n\n## Categories of metrics\n\nThere are 3 high-level categories of metrics:\n\n1. *Generic metrics*, which can be applied to a variety of situations and datasets, such as precision and accuracy.\n2. *Task-specific metrics*, which are limited to a given task, such as Machine Translation (often evaluated using metrics [BLEU](https://huggingface.co/metrics/bleu) or [ROUGE](https://huggingface.co/metrics/rouge)) or Named Entity Recognition (often evaluated with [seqeval](https://huggingface.co/metrics/seqeval)).\n3. *Dataset-specific metrics*, which aim to measure model performance on specific benchmarks: for instance, the [GLUE benchmark](https://huggingface.co/datasets/glue) has a dedicated [evaluation metric](https://huggingface.co/metrics/glue).\n\nLet's look at each of these three cases:\n\n### Generic metrics\n\nMany of the metrics used in the Machine Learning community are quite generic and can be applied in a variety of tasks and datasets.\n\nThis is the case for metrics like [accuracy](https://huggingface.co/metrics/accuracy) and [precision](https://huggingface.co/metrics/precision), which can be used for evaluating labeled (supervised) datasets, as well as [perplexity](https://huggingface.co/metrics/perplexity), which can be used for evaluating different kinds of (unsupervised) generative tasks.\n\nTo see the input structure of a given metric, you can look at its metric card. For example, in the case of [precision](https://huggingface.co/metrics/precision), the format is:\n```\n>>> precision_metric = evaluate.load(\"precision\")\n>>> results = precision_metric.compute(references=[0, 1], predictions=[0, 1])\n>>> print(results)\n{'precision': 1.0}\n```\n\n### Task-specific metrics\n\nPopular ML tasks like Machine Translation and Named Entity Recognition have specific metrics that can be used to compare models. For example, a series of different metrics have been proposed for text generation, ranging from [BLEU](https://huggingface.co/metrics/bleu) and its derivatives such as [GoogleBLEU](https://huggingface.co/metrics/google_bleu) and [GLEU](https://huggingface.co/metrics/gleu), but also [ROUGE](https://huggingface.co/metrics/rouge), [MAUVE](https://huggingface.co/metrics/mauve), etc.\n\nYou can find the right metric for your task by:\n\n- **Looking at the [Task pages](https://huggingface.co/tasks)** to see what metrics can be used for evaluating models for a given task.\n- **Checking out leaderboards** on sites like [Papers With Code](https://paperswithcode.com/) (you can search by task and by dataset).\n-  **Reading the metric cards** for the relevant metrics and see which ones are a good fit for your use case. For example, see the [BLEU metric card](https://github.com/huggingface/evaluate/tree/main/metrics/bleu) or [SQuaD metric card](https://github.com/huggingface/evaluate/tree/main/metrics/squad).\n- **Looking at papers and blog posts** published on the topic and see what metrics they report. This can change over time, so try to pick papers from the last couple of years!\n\n### Dataset-specific metrics\n\nSome datasets have specific metrics associated with them -- this is especially in the case of popular benchmarks like [GLUE](https://huggingface.co/metrics/glue) and [SQuAD](https://huggingface.co/metrics/squad).\n\n<Tip warning={true}>\n\ud83d\udca1\nGLUE is actually a collection of different subsets on different tasks, so first you need to choose the one that corresponds to the NLI task, such as mnli, which is described as \u201ccrowdsourced collection of sentence pairs with textual entailment annotations\u201d\n</Tip>\n\n\nIf you are evaluating your model on a benchmark dataset like the ones mentioned above, you can use its dedicated evaluation metric. Make sure you respect the format that they require. For example, to evaluate your model on the [SQuAD](https://huggingface.co/datasets/squad) dataset, you need to feed the `question` and `context` into your model and return the `prediction_text`, which should be compared with the `references` (based on matching the `id` of the question) :\n\n```\n>>> from evaluate import load\n>>> squad_metric = load(\"squad\")\n>>> predictions = [{'prediction_text': '1976', 'id': '56e10a3be3433e1400422b22'}]\n>>> references = [{'answers': {'answer_start': [97], 'text': ['1976']}, 'id': '56e10a3be3433e1400422b22'}]\n>>> results = squad_metric.compute(predictions=predictions, references=references)\n>>> results\n{'exact_match': 100.0, 'f1': 100.0}\n```\n\nYou can find examples of dataset structures by consulting the \"Dataset Preview\" function or the dataset card for a given dataset, and you can see how to use its dedicated evaluation function based on the metric card."
        }
    },
    {
        "sample_idx": 137,
        "question": "What training techniques are used by the model?",
        "answer": "Label Smoothing, SGD with Momentum, Weight Decay",
        "rag_answer": "The model uses various training techniques to fine-tune the LayoutLMv3 model for token classification tasks on form understanding datasets such as FUNSD and CORD. Some of the techniques used include:\n\n### Fine-tuning on FUNSD and CORD\n\nThe model is fine-tuned on the FUNSD and CORD datasets using the `run_funsd_cord.py` script, which leverages the `Trainer API` and the `Datasets` library.\n\n### Hyperparameter Tuning\n\nThe model uses hyperparameter tuning to optimize the performance on the evaluation metrics. The hyperparameters tuned include:\n\n* `--max_steps`: The maximum number of training steps.\n* `--evaluation_strategy`: The evaluation strategy used during training.\n* `--eval_steps`: The frequency of evaluation during training.\n* `--learning_rate`: The learning rate used for training.\n* `--load_best_model_at_end`: Whether to load the best model at the end of training.\n* `--metric_for_best_model`: The metric used to determine the best model.\n\n### Push to Hub\n\nThe model is pushed to the Hugging Face model hub using the `--push_to_hub` flag, which allows for easy sharing and deployment of the model.\n\n### Model Card Generation\n\nThe model card is generated automatically during training, which includes metrics such as precision, recall, and F1.\n\nReferences:\n[KG] LayoutLMv3\n[KG] Trainer API\n[KG] Datasets library\n[DC] Token classification with LayoutLMv3 (PyTorch version)",
        "rag_score": null,
        "rag_feedback": null,
        "rag_context": {
            "kg_context": "-----Entities-----\n    ```csv\n    id,\tentity,\ttype,\tdescription,\trankcreated_at\n1,\tLayoutLMv3,technology,LayoutLMv3 is a model used for token classification and form understanding tasks.,11,2025-03-24 13:18:20\n2,\tTrainer API,technology,Trainer API is a tool used for fine-tuning the LayoutLMv3 model.,1,2025-03-24 13:18:20\n3,\tMachine Learning,category,Machine Learning is a field of study that involves training models to make predictions.,5,2025-03-24 13:18:20\n4,\tModel,category,Model refers to a machine learning model being evaluated.,3,2025-03-24 13:18:20\n5,\tKeras,category,Keras is a high-level neural networks API, used for building and training neural networks.<SEP>Keras is a machine learning framework that uses XLA for optimization.,2,2025-03-24 13:18:20\n6,\tXLA,technology,XLA is a technology that compiles TensorFlow graphs into executable code for various platforms.<SEP>XLA is an optimizing compiler used by TensorFlow and JAX to improve performance.<SEP>XLA is an optimizing compiler, used by both TensorFlow and JAX to optimize computations.,6,2025-03-24 13:18:20\n7,\tPreprocessing,concept,Preprocessing refers to the process of preparing data for use in machine learning models.,1,UNKNOWN\n8,\tNeural Networks,category,Neural Networks are a type of machine learning model used for various tasks such as image recognition and natural language processing.,0,UNKNOWN\n9,\tPostprocessing,concept,Postprocessing refers to the process of transforming output from machine learning models into a usable format.,1,UNKNOWN\n    ```\n    -----Relationships-----\n    ```csv\n    id,\tsource,\ttarget,\tdescription,\tkeywords,\tweight,\trank,\tcreated_at\n1,\tLayoutLMv3,Trainer API,Trainer API is a tool used for fine-tuning the LayoutLMv3 model.,tool, model fine-tuning,7.0,12,2025-03-24 13:19:57\n2,\tMachine Learning,Model,Machine Learning involves training models to make predictions.,field of study, model training,9.0,8,2025-03-24 13:16:48\n3,\tKeras,XLA,Keras uses XLA for optimization.,compiler, performance optimization,8.0,8,2025-03-24 13:18:20\n4,\tGradio,Preprocessing,Gradio supports preprocessing of data for machine learning models.,data preprocessing, machine learning,8.0,37,UNKNOWN\n5,\tGradio,Postprocessing,Gradio supports postprocessing of output from machine learning models.,output transformation, machine learning,8.0,37,UNKNOWN\n    ```\n    -----Sources-----\n    ```csv\n    id,\tcontent\n1,\t!---\nCopyright 2022 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n-->\n\n# Token classification with LayoutLMv3 (PyTorch version)\n\nThis directory contains a script, `run_funsd_cord.py`, that can be used to fine-tune (or evaluate) LayoutLMv3 on form understanding datasets, such as [FUNSD](https://guillaumejaume.github.io/FUNSD/) and [CORD](https://github.com/clovaai/cord).\n\nThe script `run_funsd_cord.py` leverages the \ud83e\udd17 Datasets library and the Trainer API. You can easily customize it to your needs.\n\n## Fine-tuning on FUNSD\n\nFine-tuning LayoutLMv3 for token classification on [FUNSD](https://guillaumejaume.github.io/FUNSD/) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name funsd \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 1e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-funsd\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd. By specifying the `push_to_hub` flag, the model gets uploaded automatically to the hub (regularly), together with a model card, which includes metrics such as precision, recall and F1. Note that you can easily update the model card, as it's just a README file of the respective repo on the hub.\n\nThere's also the \"Training metrics\" [tab](https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd/tensorboard), which shows Tensorboard logs over the course of training. Pretty neat, huh?\n\n## Fine-tuning on CORD\n\nFine-tuning LayoutLMv3 for token classification on [CORD](https://github.com/clovaai/cord) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name cord \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 5e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-cord\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-cord. Note that a model card gets generated automatically in case you specify the `push_to_hub` flag.\n2,\t=predictions, references=references)\n>>> results\n{'exact_match': 100.0, 'f1': 100.0}\n```\n\nYou can find examples of dataset structures by consulting the \"Dataset Preview\" function or the dataset card for a given dataset, and you can see how to use its dedicated evaluation function based on the metric card.\n3,\t(for example, a v3-32), your TPU fleet is referred to as a **pod slice.**\n\nWhen you access a free TPU via Colab, you generally get a single v2-8 TPU.\n\n### I keep hearing about this XLA thing. What\u2019s XLA, and how does it relate to TPUs?\n\nXLA is an optimizing compiler, used by both TensorFlow and JAX. In JAX it is the only compiler, whereas in TensorFlow it is optional (but mandatory on TPU!). The easiest way to enable it when training a Keras model is to pass the argument `jit_compile=True` to `model.compile()`. If you don\u2019t get any errors and performance is good, that\u2019s a great sign that you\u2019re ready to move to TPU!\n\nDebugging on TPU is generally a bit harder than on CPU/GPU, so we recommend getting your code running on CPU/GPU with XLA first before trying it on TPU. You don\u2019t have to train for long, of course - just for a few steps to make sure that your model and data pipeline are working like you expect them to.\n\n<Tip>\n\nXLA compiled code is usually faster - so even if you\u2019re not planning to run on TPU, adding `jit_compile=True` can improve your performance. Be sure to note the caveats below about XLA compatibility, though!\n\n</Tip>\n\n<Tip warning={true}>\n\n**Tip born of painful experience:** Although using `jit_compile=True` is a good way to get a speed boost and test if your CPU/GPU code is XLA-compatible, it can actually cause a lot of problems if you leave it in when actually training on TPU. XLA compilation will happen implicitly on TPU, so remember to remove that line before actually running your code on a TPU!\n\n</Tip>\n\n### How do I make my model XLA compatible?\n\nIn many cases, your code is probably XLA-compatible already! However, there are a few things that work in normal TensorFlow that don\u2019t work in XLA. We\u2019ve distilled them into three core rules below:\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** We\u2019ve put a lot of effort into rewriting our TensorFlow models and loss functions to be XLA-compatible. Our models and loss functions generally obey rule #1 and #2 by default, so you can skip over them if you\u2019re using `transformers` models. Don\u2019t forget about these rules when writing your own models and loss functions, though!\n\n</Tip>\n\n#### XLA Rule #1: Your code cannot have \u201cdata-dependent conditionals\u201d\n\nWhat that means is that any `if` statement cannot depend on values inside a `tf.Tensor`. For example, this code block cannot be compiled with XLA!\n\n```python\nif tf.reduce_sum(tensor) > 10:\n    tensor = tensor / 2.0\n```\n\nThis might seem very restrictive at first, but most neural net code doesn\u2019t need to do this. You can often get around this restriction by using `tf.cond` (see the documentation [here](https://www.tensorflow.org/api_docs/python/tf/cond)) or by removing the conditional and finding a clever math trick with indicator variables instead, like so:\n\n```python\nsum_over_10 = tf.cast(tf.reduce_sum(tensor) > 10, tf.float32)\ntensor = tensor / (1.0 + sum_over_10)\n```\n\nThis code has exactly the same effect as the code above, but by avoiding a conditional, we ensure it will compile with XLA without problems!\n\n#### XLA Rule #2: Your code cannot have \u201cdata-dependent shapes\u201d\n\nWhat this means is that the shape of all of the `tf.Tensor` objects in your code cannot depend on their values. For example, the function `tf.unique` cannot be compiled with XLA, because it returns a `tensor` containing one instance of each unique value in the input. The shape of this output will obviously be different depending on how repetitive the input `Tensor` was, and so XLA refuses to handle it!\n\nIn general, most neural network code obeys rule #2 by default. However, there are a few common cases where it becomes a problem. One very common one is when you use **label masking**, setting your labels to a negative value to indicate that those positions should be ignored when computing the loss. If you look at NumPy or PyTorch loss functions that support label masking, you will often see code like this that uses [boolean indexing](https://numpy.org/doc/stable/user/basics.indexing.html#boolean-array-indexing):\n\n```python\nlabel_mask = labels >= 0\nmasked_outputs = outputs[label_mask]\nmasked_labels = labels[label_mask]\nloss = compute_loss(masked_outputs, masked_labels)\nmean_loss = torch.mean(loss)\n```\n\nThis code is totally fine in NumPy or PyTorch, but it breaks in XLA! Why? Because the shape of `masked_outputs` and `masked_labels` depends on how many positions are masked - that makes it a **data-dependent shape.** However, just like for rule #1, we can often rewrite this code to yield exactly the same output without any data-dependent shapes.\n\n```python\nlabel_mask = tf.cast(labels >= 0, tf.float32)\nloss = compute_loss(outputs, labels)\nloss = loss * label_mask  # Set negative label positions to 0\nmean_loss = tf.reduce_sum(loss) / tf.reduce_sum(label_mask)\n```\n\nHere, we avoid data-dependent shapes by computing the loss for every position, but zeroing out the masked positions in both the numerator and denominator when we calculate the mean, which yields exactly the same result as the first block while maintaining XLA compatibility. Note that we use the same trick as in rule #1 - converting a `tf.bool` to `\n4,\t!--Copyright 2023 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\nthe License. You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under the License is distributed on\nan \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n\n\u26a0\ufe0f Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be\nrendered properly in your Markdown viewer.\n\n-->\n\n# Training on TPU with TensorFlow\n\n<Tip>\n\nIf you don't need long explanations and just want TPU code samples to get started with, check out [our TPU example notebook!](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb)\n\n</Tip>\n\n### What is a TPU?\n\nA TPU is a **Tensor Processing Unit.** They are hardware designed by Google, which are used to greatly speed up the tensor computations within neural networks, much like GPUs. They can be used for both network training and inference. They are generally accessed through Google\u2019s cloud services, but small TPUs can also be accessed directly for free through Google Colab and Kaggle Kernels.\n\nBecause [all TensorFlow models in \ud83e\udd17 Transformers are Keras models](https://huggingface.co/blog/tensorflow-philosophy), most of the methods in this document are generally applicable to TPU training for any Keras model! However, there are a few points that are specific to the HuggingFace ecosystem (hug-o-system?) of Transformers and Datasets, and we\u2019ll make sure to flag them up when we get to them.\n\n### What kinds of TPU are available?\n\nNew users are often very confused by the range of TPUs, and the different ways to access them. The first key distinction to understand is the difference between **TPU Nodes** and **TPU VMs.**\n\nWhen you use a **TPU Node**, you are effectively indirectly accessing a remote TPU. You will need a separate VM, which will initialize your network and data pipeline and then forward them to the remote node. When you use a TPU on Google Colab, you are accessing it in the **TPU Node** style.\n\nUsing TPU Nodes can have some quite unexpected behaviour for people who aren\u2019t used to them! In particular, because the TPU is located on a physically different system to the machine you\u2019re running your Python code on, your data cannot be local to your machine - any data pipeline that loads from your machine\u2019s internal storage will totally fail! Instead, data must be stored in Google Cloud Storage where your data pipeline can still access it, even when the pipeline is running on the remote TPU node.\n\n<Tip>\n\nIf you can fit all your data in memory as `np.ndarray` or `tf.Tensor`, then you can `fit()` on that data even when using Colab or a TPU Node, without needing to upload it to Google Cloud Storage.\n\n</Tip>\n\n<Tip>\n\n**\ud83e\udd17Specific Hugging Face Tip\ud83e\udd17:** The methods `Dataset.to_tf_dataset()` and its higher-level wrapper `model.prepare_tf_dataset()` , which you will see throughout our TF code examples, will both fail on a TPU Node. The reason for this is that even though they create a `tf.data.Dataset` it is not a \u201cpure\u201d `tf.data` pipeline and uses `tf.numpy_function` or `Dataset.from_generator()` to stream data from the underlying HuggingFace `Dataset`. This HuggingFace `Dataset` is backed by data that is on a local disc and which the remote TPU Node will not be able to read.\n\n</Tip>\n\nThe second way to access a TPU is via a **TPU VM.** When using a TPU VM, you connect directly to the machine that the TPU is attached to, much like training on a GPU VM. TPU VMs are generally easier to work with, particularly when it comes to your data pipeline. All of the above warnings do not apply to TPU VMs!\n\nThis is an opinionated document, so here\u2019s our opinion: **Avoid using TPU Node if possible.** It is more confusing and more difficult to debug than TPU VMs. It is also likely to be unsupported in future - Google\u2019s latest TPU, TPUv4, can only be accessed as a TPU VM, which suggests that TPU Nodes are increasingly going to become a \u201clegacy\u201d access method. However, we understand that the only free TPU access is on Colab and Kaggle Kernels, which uses TPU Node - so we\u2019ll try to explain how to handle it if you have to! Check the [TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) for code samples that explain this in more detail.\n\n### What sizes of TPU are available?\n\nA single TPU (a v2-8/v3-8/v4-8) runs 8 replicas. TPUs exist in **pods** that can run hundreds or thousands of replicas simultaneously. When you use more than a single TPU but less than a whole pod (for example, a v3-32), your TPU fleet is referred to as a **pod slice.**\n\nWhen you access a free TPU via Colab, you generally get a single v2-8 TPU.\n\n### I keep hearing about this XLA thing. What\u2019s XLA, and how does it relate to TPUs?\n\nXLA is an optimizing compiler, used by both TensorFlow and JAX. In JAX it is the only compiler, whereas in TensorFlow it is optional\n5,\t\u65f6\u5fc5\u987b\u9009\u62e9\u5176\u4e2d\u4e00\u4e2a\u5b57\u7b26\u4e32\uff0c\u8fd9\u5c06\u4f5c\u4e3a\u9644\u52a0\u5217\u4fdd\u5b58\u5230 CSV \u4e2d\u3002\n\n## \u9884\u5904\u7406\u548c\u540e\u5904\u7406 (Preprocessing and Postprocessing)\n\n![annotated](/assets/img/dataflow.svg)\n\n\u5982\u60a8\u6240\u89c1\uff0cGradio \u5305\u62ec\u53ef\u4ee5\u5904\u7406\u5404\u79cd\u4e0d\u540c\u6570\u636e\u7c7b\u578b\u7684\u7ec4\u4ef6\uff0c\u4f8b\u5982\u56fe\u50cf\u3001\u97f3\u9891\u548c\u89c6\u9891\u3002\u5927\u591a\u6570\u7ec4\u4ef6\u90fd\u53ef\u4ee5\u7528\u4f5c\u8f93\u5165\u6216\u8f93\u51fa\u3002\n\n\u5f53\u7ec4\u4ef6\u7528\u4f5c\u8f93\u5165\u65f6\uff0cGradio \u81ea\u52a8\u5904\u7406*\u9884\u5904\u7406*\uff0c\u5c06\u6570\u636e\u4ece\u7528\u6237\u6d4f\u89c8\u5668\u53d1\u9001\u7684\u7c7b\u578b\uff08\u4f8b\u5982\u7f51\u7edc\u6444\u50cf\u5934\u5feb\u7167\u7684 base64 \u8868\u793a\uff09\u8f6c\u6362\u4e3a\u60a8\u7684\u51fd\u6570\u53ef\u4ee5\u63a5\u53d7\u7684\u5f62\u5f0f\uff08\u4f8b\u5982 `numpy` \u6570\u7ec4\uff09\u3002\n\n\u540c\u6837\uff0c\u5f53\u7ec4\u4ef6\u7528\u4f5c\u8f93\u51fa\u65f6\uff0cGradio \u81ea\u52a8\u5904\u7406*\u540e\u5904\u7406*\uff0c\u5c06\u6570\u636e\u4ece\u51fd\u6570\u8fd4\u56de\u7684\u5f62\u5f0f\uff08\u4f8b\u5982\u56fe\u50cf\u8def\u5f84\u5217\u8868\uff09\u8f6c\u6362\u4e3a\u53ef\u4ee5\u5728\u7528\u6237\u6d4f\u89c8\u5668\u4e2d\u663e\u793a\u7684\u5f62\u5f0f\uff08\u4f8b\u5982\u4ee5 base64 \u683c\u5f0f\u663e\u793a\u56fe\u50cf\u7684 `Gallery`\uff09\u3002\n\n\u60a8\u53ef\u4ee5\u4f7f\u7528\u6784\u5efa\u56fe\u50cf\u7ec4\u4ef6\u65f6\u7684\u53c2\u6570\u63a7\u5236*\u9884\u5904\u7406*\u3002\u4f8b\u5982\uff0c\u5982\u679c\u60a8\u4f7f\u7528\u4ee5\u4e0b\u53c2\u6570\u5b9e\u4f8b\u5316 `Image` \u7ec4\u4ef6\uff0c\u5b83\u5c06\u5c06\u56fe\u50cf\u8f6c\u6362\u4e3a `PIL` \u7c7b\u578b\uff0c\u5e76\u5c06\u5176\u91cd\u5851\u4e3a`(100, 100)`\uff0c\u800c\u4e0d\u7ba1\u63d0\u4ea4\u65f6\u7684\u539f\u59cb\u5927\u5c0f\u5982\u4f55\uff1a\n\n```py\nimg = gr.Image(shape=(100, 100), type=\"pil\")\n```\n\n\u76f8\u53cd\uff0c\u8fd9\u91cc\u6211\u4eec\u4fdd\u7559\u56fe\u50cf\u7684\u539f\u59cb\u5927\u5c0f\uff0c\u4f46\u5728\u5c06\u5176\u8f6c\u6362\u4e3a numpy \u6570\u7ec4\u4e4b\u524d\u53cd\u8f6c\u989c\u8272\uff1a\n\n```py\nimg = gr.Image(invert_colors=True, type=\"numpy\")\n```\n\n\u540e\u5904\u7406\u8981\u5bb9\u6613\u5f97\u591a\uff01Gradio \u81ea\u52a8\u8bc6\u522b\u8fd4\u56de\u6570\u636e\u7684\u683c\u5f0f\uff08\u4f8b\u5982 `Image` \u662f `numpy` \u6570\u7ec4\u8fd8\u662f `str` \u6587\u4ef6\u8def\u5f84\uff1f\uff09\uff0c\u5e76\u5c06\u5176\u540e\u5904\u7406\u4e3a\u53ef\u4ee5\u7531\u6d4f\u89c8\u5668\u663e\u793a\u7684\u683c\u5f0f\u3002\n\n\u8bf7\u67e5\u770b[\u6587\u6863](https://gradio.app/docs)\uff0c\u4e86\u89e3\u6bcf\u4e2a\u7ec4\u4ef6\u7684\u6240\u6709\u4e0e\u9884\u5904\u7406\u76f8\u5173\u7684\u53c2\u6570\u3002\n\n## \u6837\u5f0f (Styling)\n\nGradio \u4e3b\u9898\u662f\u81ea\u5b9a\u4e49\u5e94\u7528\u7a0b\u5e8f\u5916\u89c2\u548c\u611f\u89c9\u7684\u6700\u7b80\u5355\u65b9\u6cd5\u3002\u60a8\u53ef\u4ee5\u9009\u62e9\u591a\u79cd\u4e3b\u9898\u6216\u521b\u5efa\u81ea\u5df1\u7684\u4e3b\u9898\u3002\u8981\u8fd9\u6837\u505a\uff0c\u8bf7\u5c06 `theme=` \u53c2\u6570\u4f20\u9012\u7ed9 `Interface` \u6784\u9020\u51fd\u6570\u3002\u4f8b\u5982\uff1a\n\n```python\ndemo = gr.Interface(..., theme=gr.themes.Monochrome())\n```\n\nGradio \u5e26\u6709\u4e00\u7ec4\u9884\u5148\u6784\u5efa\u7684\u4e3b\u9898\uff0c\u60a8\u53ef\u4ee5\u4ece `gr.themes.*` \u52a0\u8f7d\u3002\u60a8\u53ef\u4ee5\u6269\u5c55\u8fd9\u4e9b\u4e3b\u9898\u6216\u4ece\u5934\u5f00\u59cb\u521b\u5efa\u81ea\u5df1\u7684\u4e3b\u9898 - \u6709\u5173\u66f4\u591a\u8be6\u7ec6\u4fe1\u606f\uff0c\u8bf7\u53c2\u9605[\u4e3b\u9898\u6307\u5357](https://gradio.app/theming-guide)\u3002\n\n\u8981\u589e\u52a0\u989d\u5916\u7684\u6837\u5f0f\u80fd\u529b\uff0c\u60a8\u53ef\u4ee5 with `css=` \u5173\u952e\u5b57\u5c06\u4efb\u4f55 CSS \u4f20\u9012\u7ed9\u60a8\u7684\u5e94\u7528\u7a0b\u5e8f\u3002\nGradio \u5e94\u7528\u7a0b\u5e8f\u7684\u57fa\u7c7b\u662f `gradio-container`\uff0c\u56e0\u6b64\u4ee5\u4e0b\u662f\u4e00\u4e2a\u66f4\u6539 Gradio \u5e94\u7528\u7a0b\u5e8f\u80cc\u666f\u989c\u8272\u7684\u793a\u4f8b\uff1a\n\n```python\nwith `gr.Interface(css=\".gradio-container {background-color: red}\") as demo:\n    ...\n```\n\n## \u961f\u5217 (Queuing)\n\n\u5982\u679c\u60a8\u7684\u5e94\u7528\u7a0b\u5e8f\u9884\u8ba1\u4f1a\u6709\u5927\u91cf\u6d41\u91cf\uff0c\u8bf7 with `queue()` \u65b9\u6cd5\u6765\u63a7\u5236\u5904\u7406\u901f\u7387\u3002\u8fd9\u5c06\u6392\u961f\u5904\u7406\u8c03\u7528\uff0c\u56e0\u6b64\u4e00\u6b21\u53ea\u5904\u7406\u4e00\u5b9a\u6570\u91cf\u7684\u8bf7\u6c42\u3002\u961f\u5217\u4f7f\u7528 Websockets\uff0c\u8fd8\u53ef\u4ee5\u9632\u6b62\u7f51\u7edc\u8d85\u65f6\uff0c\u56e0\u6b64\u5982\u679c\u60a8\u7684\u51fd\u6570\u7684\u63a8\u7406\u65f6\u95f4\u5f88\u957f\uff08> 1 \u5206\u949f\uff09\uff0c\u5e94\u4f7f\u7528\u961f\u5217\u3002\n\nwith `Interface`\uff1a\n\n```python\ndemo = gr.Interface(...).queue()\ndemo.launch()\n```\n\nwith `Blocks`\uff1a\n\n```python\nwith gr.Blocks() as demo\uff1a\n    #...\ndemo.queue()\ndemo.launch()\n```\n\n\u60a8\u53ef\u4ee5\u901a\u8fc7\u4ee5\u4e0b\u65b9\u5f0f\u63a7\u5236\u4e00\u6b21\u5904\u7406\u7684\u8bf7\u6c42\u6570\u91cf\uff1a\n\n```python\ndemo.queue(concurrency_count=3)\n```\n\n\u67e5\u770b\u6709\u5173\u914d\u7f6e\u5176\u4ed6\u961f\u5217\u53c2\u6570\u7684[\u961f\u5217\u6587\u6863](/docs/#queue)\u3002\n\n\u5728 Blocks \u4e2d\u6307\u5b9a\u4ec5\u5bf9\u67d0\u4e9b\u51fd\u6570\u8fdb\u884c\u6392\u961f\uff1a\n\n```python\nwith gr.Blocks() as demo2\uff1a\n    num1 = gr.Number()\n    num2 = gr.Number()\n    output = gr.Number()\n    gr.Button(\"Add\").click(\n        lambda a, b: a + b, [num1, num2], output)\n    gr.Button(\"Multiply\").click(\n        lambda a, b: a * b, [num1, num2], output, queue=True)\ndemo2.launch()\n```\n\n## \u8fed\u4ee3\u8f93\u51fa (Iterative Outputs)\n\n\u5728\u67d0\u4e9b\u60c5\u51b5\u4e0b\uff0c\u60a8\u53ef\u80fd\u9700\u8981\u4f20\u8f93\u4e00\u7cfb\u5217\u8f93\u51fa\u800c\u4e0d\u662f\u4e00\u6b21\u663e\u793a\u5355\u4e2a\u8f93\u51fa\u3002\u4f8b\u5982\uff0c\u60a8\u53ef\u80fd\u6709\u4e00\u4e2a\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5e0c\u671b\u663e\u793a\u751f\u6210\u7684\u6bcf\u4e2a\u6b65\u9aa4\u7684\u56fe\u50cf\uff0c\u76f4\u5230\u6700\u7ec8\u56fe\u50cf\u3002\u6216\u8005\u60a8\u53ef\u80fd\u6709\u4e00\u4e2a\u804a\u5929\u673a\u5668\u4eba\uff0c\u5b83\u9010\u5b57\u9010\u53e5\u5730\u6d41\u5f0f\u4f20\u8f93\u54cd\u5e94\uff0c\u800c\u4e0d\u662f\u4e00\u6b21\u8fd4\u56de\u5168\u90e8\u54cd\u5e94\u3002\n\n\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u60a8\u53ef\u4ee5\u5c06**\u751f\u6210\u5668**\u51fd\u6570\u63d0\u4f9b\u7ed9 Gradio\uff0c\u800c\u4e0d\u662f\u5e38\u89c4\u51fd\u6570\u3002\u5728 Python \u4e2d\u521b\u5efa\u751f\u6210\u5668\u975e\u5e38\u7b80\u5355\uff1a\u51fd\u6570\u4e0d\u5e94\u8be5\u6709\u4e00\u4e2a\u5355\u72ec\u7684 `return` \u503c\uff0c\u800c\u662f\u5e94\u8be5 with `yield` \u8fde\u7eed\u8fd4\u56de\u4e00\u7cfb\u5217\u503c\u3002\u901a\u5e38\uff0c`yield` \u8bed\u53e5\u653e\u7f6e\u5728\u67d0\u79cd\u5faa\u73af\u4e2d\u3002\u4e0b\u9762\u662f\u4e00\u4e2a\u7b80\u5355\u793a\u4f8b\uff0c\u751f\u6210\u5668\u53ea\u662f\u7b80\u5355\u8ba1\u6570\u5230\u7ed9\u5b9a\u6570\u5b57\uff1a\n\n```python\ndef my_generator(x):\n    for i in range(x):\n        yield i\n```\n\n\u60a8\u4ee5\u4e0e\u5e38\u89c4\u51fd\u6570\u76f8\u540c\u7684\u65b9\u5f0f\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio\u3002\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\uff08\u865a\u62df\u7684\uff09\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5b83\u5728\u8f93\u51fa\u56fe\u50cf\u4e4b\u524d\u751f\u6210\u6570\u4e2a\u6b65\u9aa4\u7684\u566a\u97f3\uff1a\n\n$code_fake_diffusion\n$demo_fake_diffusion\n\n\u8bf7\u6ce8\u610f\uff0c\u6211\u4eec\u5728\u8fed\u4ee3\u5668\u4e2d\u6dfb\u52a0\u4e86 `time.sleep(1)`\uff0c\u4ee5\u521b\u5efa\u6b65\u9aa4\u4e4b\u95f4\u7684\u4eba\u5de5\u6682\u505c\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u89c2\u5bdf\u8fed\u4ee3\u5668\u7684\u6b65\u9aa4\uff08\u5728\u771f\u5b9e\u7684\u56fe\u50cf\u751f\u6210\u6a21\u578b\u4e2d\uff0c\u8fd9\n    ```",
            "vector_context": "[Created at: 2025-03-24 13:19:17]\n!---\nCopyright 2022 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n-->\n\n# Token classification with LayoutLMv3 (PyTorch version)\n\nThis directory contains a script, `run_funsd_cord.py`, that can be used to fine-tune (or evaluate) LayoutLMv3 on form understanding datasets, such as [FUNSD](https://guillaumejaume.github.io/FUNSD/) and [CORD](https://github.com/clovaai/cord).\n\nThe script `run_funsd_cord.py` leverages the \ud83e\udd17 Datasets library and the Trainer API. You can easily customize it to your needs.\n\n## Fine-tuning on FUNSD\n\nFine-tuning LayoutLMv3 for token classification on [FUNSD](https://guillaumejaume.github.io/FUNSD/) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name funsd \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 1e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-funsd\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd. By specifying the `push_to_hub` flag, the model gets uploaded automatically to the hub (regularly), together with a model card, which includes metrics such as precision, recall and F1. Note that you can easily update the model card, as it's just a README file of the respective repo on the hub.\n\nThere's also the \"Training metrics\" [tab](https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd/tensorboard), which shows Tensorboard logs over the course of training. Pretty neat, huh?\n\n## Fine-tuning on CORD\n\nFine-tuning LayoutLMv3 for token classification on [CORD](https://github.com/clovaai/cord) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name cord \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 5e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-cord\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-cord. Note that a model card gets generated automatically in case you specify the `push_to_hub` flag.\n--New Chunk--\n[Created at: 2025-03-24 13:16:13]\n=predictions, references=references)\n>>> results\n{'exact_match': 100.0, 'f1': 100.0}\n```\n\nYou can find examples of dataset structures by consulting the \"Dataset Preview\" function or the dataset card for a given dataset, and you can see how to use its dedicated evaluation function based on the metric card.\n--New Chunk--\n[Created at: 2025-03-24 13:16:13]\nChoosing a metric for your task\n\n**So you've trained your model and want to see how well it\u2019s doing on a dataset of your choice. Where do you start?**\n\nThere is no \u201cone size fits all\u201d approach to choosing an evaluation metric, but some good guidelines to keep in mind are:\n\n## Categories of metrics\n\nThere are 3 high-level categories of metrics:\n\n1. *Generic metrics*, which can be applied to a variety of situations and datasets, such as precision and accuracy.\n2. *Task-specific metrics*, which are limited to a given task, such as Machine Translation (often evaluated using metrics [BLEU](https://huggingface.co/metrics/bleu) or [ROUGE](https://huggingface.co/metrics/rouge)) or Named Entity Recognition (often evaluated with [seqeval](https://huggingface.co/metrics/seqeval)).\n3. *Dataset-specific metrics*, which aim to measure model performance on specific benchmarks: for instance, the [GLUE benchmark](https://huggingface.co/datasets/glue) has a dedicated [evaluation metric](https://huggingface.co/metrics/glue).\n\nLet's look at each of these three cases:\n\n### Generic metrics\n\nMany of the metrics used in the Machine Learning community are quite generic and can be applied in a variety of tasks and datasets.\n\nThis is the case for metrics like [accuracy](https://huggingface.co/metrics/accuracy) and [precision](https://huggingface.co/metrics/precision), which can be used for evaluating labeled (supervised) datasets, as well as [perplexity](https://huggingface.co/metrics/perplexity), which can be used for evaluating different kinds of (unsupervised) generative tasks.\n\nTo see the input structure of a given metric, you can look at its metric card. For example, in the case of [precision](https://huggingface.co/metrics/precision), the format is:\n```\n>>> precision_metric = evaluate.load(\"precision\")\n>>> results = precision_metric.compute(references=[0, 1], predictions=[0, 1])\n>>> print(results)\n{'precision': 1.0}\n```\n\n### Task-specific metrics\n\nPopular ML tasks like Machine Translation and Named Entity Recognition have specific metrics that can be used to compare models. For example, a series of different metrics have been proposed for text generation, ranging from [BLEU](https://huggingface.co/metrics/bleu) and its derivatives such as [GoogleBLEU](https://huggingface.co/metrics/google_bleu) and [GLEU](https://huggingface.co/metrics/gleu), but also [ROUGE](https://huggingface.co/metrics/rouge), [MAUVE](https://huggingface.co/metrics/mauve), etc.\n\nYou can find the right metric for your task by:\n\n- **Looking at the [Task pages](https://huggingface.co/tasks)** to see what metrics can be used for evaluating models for a given task.\n- **Checking out leaderboards** on sites like [Papers With Code](https://paperswithcode.com/) (you can search by task and by dataset).\n-  **Reading the metric cards** for the relevant metrics and see which ones are a good fit for your use case. For example, see the [BLEU metric card](https://github.com/huggingface/evaluate/tree/main/metrics/bleu) or [SQuaD metric card](https://github.com/huggingface/evaluate/tree/main/metrics/squad).\n- **Looking at papers and blog posts** published on the topic and see what metrics they report. This can change over time, so try to pick papers from the last couple of years!\n\n### Dataset-specific metrics\n\nSome datasets have specific metrics associated with them -- this is especially in the case of popular benchmarks like [GLUE](https://huggingface.co/metrics/glue) and [SQuAD](https://huggingface.co/metrics/squad).\n\n<Tip warning={true}>\n\ud83d\udca1\nGLUE is actually a collection of different subsets on different tasks, so first you need to choose the one that corresponds to the NLI task, such as mnli, which is described as \u201ccrowdsourced collection of sentence pairs with textual entailment annotations\u201d\n</Tip>\n\n\nIf you are evaluating your model on a benchmark dataset like the ones mentioned above, you can use its dedicated evaluation metric. Make sure you respect the format that they require. For example, to evaluate your model on the [SQuAD](https://huggingface.co/datasets/squad) dataset, you need to feed the `question` and `context` into your model and return the `prediction_text`, which should be compared with the `references` (based on matching the `id` of the question) :\n\n```\n>>> from evaluate import load\n>>> squad_metric = load(\"squad\")\n>>> predictions = [{'prediction_text': '1976', 'id': '56e10a3be3433e1400422b22'}]\n>>> references = [{'answers': {'answer_start': [97], 'text': ['1976']}, 'id': '56e10a3be3433e1400422b22'}]\n>>> results = squad_metric.compute(predictions=predictions, references=references)\n>>> results\n{'exact_match': 100.0, 'f1': 100.0}\n```\n\nYou can find examples of dataset structures by consulting the \"Dataset Preview\" function or the dataset card for a given dataset, and you can see how to use its dedicated evaluation function based on the metric card."
        }
    },
    {
        "sample_idx": 138,
        "question": "How many NVIDIA Titan X GPUs are used for training?",
        "answer": "8",
        "rag_answer": "There is no mention of NVIDIA Titan X GPUs being used for training in the provided Data Sources. The data sources primarily discuss TPUs (Tensor Processing Units) and their usage for training models, particularly in the context of Google Colab and Kaggle Kernels. There is no mention of NVIDIA Titan X GPUs or any other type of GPU being used for training.",
        "rag_score": 1,
        "rag_feedback": "The system's response is completely incorrect, inaccurate, and/or not factual. The question asks about the number of NVIDIA Titan X GPUs used for training, but the system's response does not provide a direct answer and instead discusses TPUs (Tensor Processing Units) and their usage for training models.",
        "rag_context": {
            "kg_context": "-----Entities-----\n    ```csv\n    id,\tentity,\ttype,\tdescription,\trankcreated_at\n1,\tMachine Learning,category,Machine Learning is a field of study that involves training models to make predictions.,5,2025-03-24 13:18:20\n2,\tModel,category,Model refers to a machine learning model being evaluated.,3,2025-03-24 13:18:20\n3,\tGoogle,organization,Google is the company that designs and provides TPUs, which are used to speed up tensor computations within neural networks.,3,2025-03-24 13:18:20\n4,\tTPU,technology,TPU is a Tensor Processing Unit, a hardware designed by Google to speed up tensor computations within neural networks.<SEP>TPU is a type of hardware accelerator designed for machine learning workloads.<SEP>TPU is a type of hardware accelerator used for machine learning computations.,4,2025-03-24 13:18:20\n5,\tCPU,technology,CPU is a type of computer processor.<SEP>CPU is a type of hardware processor used for general-purpose computations.,1,2025-03-24 13:18:20\n6,\tGPU,technology,GPU is a type of computer processor.<SEP>GPU is a type of hardware accelerator used for graphics processing.,1,2025-03-24 13:18:20\n7,\tGoogle,organization,Google is the company that designs and provides TPUs, which are used to speed up tensor computations within neural networks.,3,UNKNOWN\n8,\tTPUv4,category,TPUv4 is a type of TPU, a hardware designed by Google to speed up tensor computations within neural networks.,0,UNKNOWN\n9,\tGPUs,category,GPUs are Graphics Processing Units, a type of hardware used for accelerating computations.,0,UNKNOWN\n    ```\n    -----Relationships-----\n    ```csv\n    id,\tsource,\ttarget,\tdescription,\tkeywords,\tweight,\trank,\tcreated_at\n1,\tMachine Learning,Model,Machine Learning involves training models to make predictions.,field of study, model training,9.0,8,2025-03-24 13:16:48\n2,\tGoogle,TPU,Google designs and provides TPUs, which are used to speed up tensor computations within neural networks.,hardware design, acceleration,18.0,7,2025-03-24 13:18:20\n3,\tCPU,GPU,CPU and GPU are types of computer processors that can be used for machine learning workloads.,hardware comparison, processing power,4.0,2,2025-03-24 13:18:20\n4,\tGoogle,TPU,Google designs and provides TPUs, which are used to speed up tensor computations within neural networks.,hardware design, acceleration,18.0,7,UNKNOWN\n5,\tColab,Google,Colab is a cloud-based platform provided by Google for data science and machine learning.,platform provision, cloud computing,16.0,6,UNKNOWN\n6,\tGoogle,Kaggle Kernels,Kaggle Kernels is a cloud-based platform provided by Google for data science and machine learning competitions.,platform provision, cloud computing,16.0,4,UNKNOWN\n    ```\n    -----Sources-----\n    ```csv\n    id,\tcontent\n1,\t=predictions, references=references)\n>>> results\n{'exact_match': 100.0, 'f1': 100.0}\n```\n\nYou can find examples of dataset structures by consulting the \"Dataset Preview\" function or the dataset card for a given dataset, and you can see how to use its dedicated evaluation function based on the metric card.\n2,\t!--Copyright 2023 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\nthe License. You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under the License is distributed on\nan \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n\n\u26a0\ufe0f Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be\nrendered properly in your Markdown viewer.\n\n-->\n\n# Training on TPU with TensorFlow\n\n<Tip>\n\nIf you don't need long explanations and just want TPU code samples to get started with, check out [our TPU example notebook!](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb)\n\n</Tip>\n\n### What is a TPU?\n\nA TPU is a **Tensor Processing Unit.** They are hardware designed by Google, which are used to greatly speed up the tensor computations within neural networks, much like GPUs. They can be used for both network training and inference. They are generally accessed through Google\u2019s cloud services, but small TPUs can also be accessed directly for free through Google Colab and Kaggle Kernels.\n\nBecause [all TensorFlow models in \ud83e\udd17 Transformers are Keras models](https://huggingface.co/blog/tensorflow-philosophy), most of the methods in this document are generally applicable to TPU training for any Keras model! However, there are a few points that are specific to the HuggingFace ecosystem (hug-o-system?) of Transformers and Datasets, and we\u2019ll make sure to flag them up when we get to them.\n\n### What kinds of TPU are available?\n\nNew users are often very confused by the range of TPUs, and the different ways to access them. The first key distinction to understand is the difference between **TPU Nodes** and **TPU VMs.**\n\nWhen you use a **TPU Node**, you are effectively indirectly accessing a remote TPU. You will need a separate VM, which will initialize your network and data pipeline and then forward them to the remote node. When you use a TPU on Google Colab, you are accessing it in the **TPU Node** style.\n\nUsing TPU Nodes can have some quite unexpected behaviour for people who aren\u2019t used to them! In particular, because the TPU is located on a physically different system to the machine you\u2019re running your Python code on, your data cannot be local to your machine - any data pipeline that loads from your machine\u2019s internal storage will totally fail! Instead, data must be stored in Google Cloud Storage where your data pipeline can still access it, even when the pipeline is running on the remote TPU node.\n\n<Tip>\n\nIf you can fit all your data in memory as `np.ndarray` or `tf.Tensor`, then you can `fit()` on that data even when using Colab or a TPU Node, without needing to upload it to Google Cloud Storage.\n\n</Tip>\n\n<Tip>\n\n**\ud83e\udd17Specific Hugging Face Tip\ud83e\udd17:** The methods `Dataset.to_tf_dataset()` and its higher-level wrapper `model.prepare_tf_dataset()` , which you will see throughout our TF code examples, will both fail on a TPU Node. The reason for this is that even though they create a `tf.data.Dataset` it is not a \u201cpure\u201d `tf.data` pipeline and uses `tf.numpy_function` or `Dataset.from_generator()` to stream data from the underlying HuggingFace `Dataset`. This HuggingFace `Dataset` is backed by data that is on a local disc and which the remote TPU Node will not be able to read.\n\n</Tip>\n\nThe second way to access a TPU is via a **TPU VM.** When using a TPU VM, you connect directly to the machine that the TPU is attached to, much like training on a GPU VM. TPU VMs are generally easier to work with, particularly when it comes to your data pipeline. All of the above warnings do not apply to TPU VMs!\n\nThis is an opinionated document, so here\u2019s our opinion: **Avoid using TPU Node if possible.** It is more confusing and more difficult to debug than TPU VMs. It is also likely to be unsupported in future - Google\u2019s latest TPU, TPUv4, can only be accessed as a TPU VM, which suggests that TPU Nodes are increasingly going to become a \u201clegacy\u201d access method. However, we understand that the only free TPU access is on Colab and Kaggle Kernels, which uses TPU Node - so we\u2019ll try to explain how to handle it if you have to! Check the [TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) for code samples that explain this in more detail.\n\n### What sizes of TPU are available?\n\nA single TPU (a v2-8/v3-8/v4-8) runs 8 replicas. TPUs exist in **pods** that can run hundreds or thousands of replicas simultaneously. When you use more than a single TPU but less than a whole pod (for example, a v3-32), your TPU fleet is referred to as a **pod slice.**\n\nWhen you access a free TPU via Colab, you generally get a single v2-8 TPU.\n\n### I keep hearing about this XLA thing. What\u2019s XLA, and how does it relate to TPUs?\n\nXLA is an optimizing compiler, used by both TensorFlow and JAX. In JAX it is the only compiler, whereas in TensorFlow it is optional\n3,\tlabel_mask  # Set negative label positions to 0\nmean_loss = tf.reduce_sum(loss) / tf.reduce_sum(label_mask)\n```\n\nHere, we avoid data-dependent shapes by computing the loss for every position, but zeroing out the masked positions in both the numerator and denominator when we calculate the mean, which yields exactly the same result as the first block while maintaining XLA compatibility. Note that we use the same trick as in rule #1 - converting a `tf.bool` to `tf.float32` and using it as an indicator variable. This is a really useful trick, so remember it if you need to convert your own code to XLA!\n\n#### XLA Rule #3: XLA will need to recompile your model for every different input shape it sees\n\nThis is the big one. What this means is that if your input shapes are very variable, XLA will have to recompile your model over and over, which will create huge performance problems. This commonly arises in NLP models, where input texts have variable lengths after tokenization. In other modalities, static shapes are more common and this rule is much less of a problem.\n\nHow can you get around rule #3? The key is **padding** - if you pad all your inputs to the same length, and then use an `attention_mask`, you can get the same results as you\u2019d get from variable shapes, but without any XLA issues. However, excessive padding can cause severe slowdown too - if you pad all your samples to the maximum length in the whole dataset, you might end up with batches consisting endless padding tokens, which will waste a lot of compute and memory!\n\nThere isn\u2019t a perfect solution to this problem. However, you can try some tricks. One very useful trick is to **pad batches of samples up to a multiple of a number like 32 or 64 tokens.** This often only increases the number of tokens by a small amount, but it hugely reduces the number of unique input shapes, because every input shape now has to be a multiple of 32 or 64. Fewer unique input shapes means fewer XLA compilations!\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** Our tokenizers and data collators have methods that can help you here. You can use `padding=\"max_length\"` or `padding=\"longest\"` when calling tokenizers to get them to output padded data. Our tokenizers and data collators also have a `pad_to_multiple_of` argument that you can use to reduce the number of unique input shapes you see!\n\n</Tip>\n\n### How do I actually train my model on TPU?\n\nOnce your training is XLA-compatible and (if you\u2019re using TPU Node / Colab) your dataset has been prepared appropriately, running on TPU is surprisingly easy! All you really need to change in your code is to add a few lines to initialize your TPU, and to ensure that your model and dataset are created inside a `TPUStrategy` scope. Take a look at [our TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) to see this in action!\n\n### Summary\n\nThere was a lot in here, so let\u2019s summarize with a quick checklist you can follow when you want to get your model ready for TPU training:\n\n- Make sure your code follows the three rules of XLA\n- Compile your model with `jit_compile=True` on CPU/GPU and confirm that you can train it with XLA\n- Either load your dataset into memory or use a TPU-compatible dataset loading approach (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Migrate your code either to Colab (with accelerator set to \u201cTPU\u201d) or a TPU VM on Google Cloud\n- Add TPU initializer code (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Create your `TPUStrategy` and make sure dataset loading and model creation are inside the `strategy.scope()` (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Don\u2019t forget to take `jit_compile=True` out again when you move to TPU!\n- \ud83d\ude4f\ud83d\ude4f\ud83d\ude4f\ud83e\udd7a\ud83e\udd7a\ud83e\udd7a\n- Call model.fit()\n- You did it!\n    ```",
            "vector_context": "[Created at: 2025-03-24 13:17:32]\n!--Copyright 2023 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\nthe License. You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under the License is distributed on\nan \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n\n\u26a0\ufe0f Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be\nrendered properly in your Markdown viewer.\n\n-->\n\n# Training on TPU with TensorFlow\n\n<Tip>\n\nIf you don't need long explanations and just want TPU code samples to get started with, check out [our TPU example notebook!](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb)\n\n</Tip>\n\n### What is a TPU?\n\nA TPU is a **Tensor Processing Unit.** They are hardware designed by Google, which are used to greatly speed up the tensor computations within neural networks, much like GPUs. They can be used for both network training and inference. They are generally accessed through Google\u2019s cloud services, but small TPUs can also be accessed directly for free through Google Colab and Kaggle Kernels.\n\nBecause [all TensorFlow models in \ud83e\udd17 Transformers are Keras models](https://huggingface.co/blog/tensorflow-philosophy), most of the methods in this document are generally applicable to TPU training for any Keras model! However, there are a few points that are specific to the HuggingFace ecosystem (hug-o-system?) of Transformers and Datasets, and we\u2019ll make sure to flag them up when we get to them.\n\n### What kinds of TPU are available?\n\nNew users are often very confused by the range of TPUs, and the different ways to access them. The first key distinction to understand is the difference between **TPU Nodes** and **TPU VMs.**\n\nWhen you use a **TPU Node**, you are effectively indirectly accessing a remote TPU. You will need a separate VM, which will initialize your network and data pipeline and then forward them to the remote node. When you use a TPU on Google Colab, you are accessing it in the **TPU Node** style.\n\nUsing TPU Nodes can have some quite unexpected behaviour for people who aren\u2019t used to them! In particular, because the TPU is located on a physically different system to the machine you\u2019re running your Python code on, your data cannot be local to your machine - any data pipeline that loads from your machine\u2019s internal storage will totally fail! Instead, data must be stored in Google Cloud Storage where your data pipeline can still access it, even when the pipeline is running on the remote TPU node.\n\n<Tip>\n\nIf you can fit all your data in memory as `np.ndarray` or `tf.Tensor`, then you can `fit()` on that data even when using Colab or a TPU Node, without needing to upload it to Google Cloud Storage.\n\n</Tip>\n\n<Tip>\n\n**\ud83e\udd17Specific Hugging Face Tip\ud83e\udd17:** The methods `Dataset.to_tf_dataset()` and its higher-level wrapper `model.prepare_tf_dataset()` , which you will see throughout our TF code examples, will both fail on a TPU Node. The reason for this is that even though they create a `tf.data.Dataset` it is not a \u201cpure\u201d `tf.data` pipeline and uses `tf.numpy_function` or `Dataset.from_generator()` to stream data from the underlying HuggingFace `Dataset`. This HuggingFace `Dataset` is backed by data that is on a local disc and which the remote TPU Node will not be able to read.\n\n</Tip>\n\nThe second way to access a TPU is via a **TPU VM.** When using a TPU VM, you connect directly to the machine that the TPU is attached to, much like training on a GPU VM. TPU VMs are generally easier to work with, particularly when it comes to your data pipeline. All of the above warnings do not apply to TPU VMs!\n\nThis is an opinionated document, so here\u2019s our opinion: **Avoid using TPU Node if possible.** It is more confusing and more difficult to debug than TPU VMs. It is also likely to be unsupported in future - Google\u2019s latest TPU, TPUv4, can only be accessed as a TPU VM, which suggests that TPU Nodes are increasingly going to become a \u201clegacy\u201d access method. However, we understand that the only free TPU access is on Colab and Kaggle Kernels, which uses TPU Node - so we\u2019ll try to explain how to handle it if you have to! Check the [TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) for code samples that explain this in more detail.\n\n### What sizes of TPU are available?\n\nA single TPU (a v2-8/v3-8/v4-8) runs 8 replicas. TPUs exist in **pods** that can run hundreds or thousands of replicas simultaneously. When you use more than a single TPU but less than a whole pod (for example, a v3-32), your TPU fleet is referred to as a **pod slice.**\n\nWhen you access a free TPU via Colab, you generally get a single v2-8 TPU.\n\n### I keep hearing about this XLA thing. What\u2019s XLA, and how does it relate to TPUs?\n\nXLA is an optimizing compiler, used by both TensorFlow and JAX. In JAX it is the only compiler, whereas in TensorFlow it is optional\n--New Chunk--\n[Created at: 2025-03-24 13:19:17]\n!---\nCopyright 2022 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n-->\n\n# Token classification with LayoutLMv3 (PyTorch version)\n\nThis directory contains a script, `run_funsd_cord.py`, that can be used to fine-tune (or evaluate) LayoutLMv3 on form understanding datasets, such as [FUNSD](https://guillaumejaume.github.io/FUNSD/) and [CORD](https://github.com/clovaai/cord).\n\nThe script `run_funsd_cord.py` leverages the \ud83e\udd17 Datasets library and the Trainer API. You can easily customize it to your needs.\n\n## Fine-tuning on FUNSD\n\nFine-tuning LayoutLMv3 for token classification on [FUNSD](https://guillaumejaume.github.io/FUNSD/) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name funsd \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 1e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-funsd\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd. By specifying the `push_to_hub` flag, the model gets uploaded automatically to the hub (regularly), together with a model card, which includes metrics such as precision, recall and F1. Note that you can easily update the model card, as it's just a README file of the respective repo on the hub.\n\nThere's also the \"Training metrics\" [tab](https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd/tensorboard), which shows Tensorboard logs over the course of training. Pretty neat, huh?\n\n## Fine-tuning on CORD\n\nFine-tuning LayoutLMv3 for token classification on [CORD](https://github.com/clovaai/cord) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name cord \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 5e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-cord\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-cord. Note that a model card gets generated automatically in case you specify the `push_to_hub` flag.\n--New Chunk--\n[Created at: 2025-03-24 13:17:32]\n(for example, a v3-32), your TPU fleet is referred to as a **pod slice.**\n\nWhen you access a free TPU via Colab, you generally get a single v2-8 TPU.\n\n### I keep hearing about this XLA thing. What\u2019s XLA, and how does it relate to TPUs?\n\nXLA is an optimizing compiler, used by both TensorFlow and JAX. In JAX it is the only compiler, whereas in TensorFlow it is optional (but mandatory on TPU!). The easiest way to enable it when training a Keras model is to pass the argument `jit_compile=True` to `model.compile()`. If you don\u2019t get any errors and performance is good, that\u2019s a great sign that you\u2019re ready to move to TPU!\n\nDebugging on TPU is generally a bit harder than on CPU/GPU, so we recommend getting your code running on CPU/GPU with XLA first before trying it on TPU. You don\u2019t have to train for long, of course - just for a few steps to make sure that your model and data pipeline are working like you expect them to.\n\n<Tip>\n\nXLA compiled code is usually faster - so even if you\u2019re not planning to run on TPU, adding `jit_compile=True` can improve your performance. Be sure to note the caveats below about XLA compatibility, though!\n\n</Tip>\n\n<Tip warning={true}>\n\n**Tip born of painful experience:** Although using `jit_compile=True` is a good way to get a speed boost and test if your CPU/GPU code is XLA-compatible, it can actually cause a lot of problems if you leave it in when actually training on TPU. XLA compilation will happen implicitly on TPU, so remember to remove that line before actually running your code on a TPU!\n\n</Tip>\n\n### How do I make my model XLA compatible?\n\nIn many cases, your code is probably XLA-compatible already! However, there are a few things that work in normal TensorFlow that don\u2019t work in XLA. We\u2019ve distilled them into three core rules below:\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** We\u2019ve put a lot of effort into rewriting our TensorFlow models and loss functions to be XLA-compatible. Our models and loss functions generally obey rule #1 and #2 by default, so you can skip over them if you\u2019re using `transformers` models. Don\u2019t forget about these rules when writing your own models and loss functions, though!\n\n</Tip>\n\n#### XLA Rule #1: Your code cannot have \u201cdata-dependent conditionals\u201d\n\nWhat that means is that any `if` statement cannot depend on values inside a `tf.Tensor`. For example, this code block cannot be compiled with XLA!\n\n```python\nif tf.reduce_sum(tensor) > 10:\n    tensor = tensor / 2.0\n```\n\nThis might seem very restrictive at first, but most neural net code doesn\u2019t need to do this. You can often get around this restriction by using `tf.cond` (see the documentation [here](https://www.tensorflow.org/api_docs/python/tf/cond)) or by removing the conditional and finding a clever math trick with indicator variables instead, like so:\n\n```python\nsum_over_10 = tf.cast(tf.reduce_sum(tensor) > 10, tf.float32)\ntensor = tensor / (1.0 + sum_over_10)\n```\n\nThis code has exactly the same effect as the code above, but by avoiding a conditional, we ensure it will compile with XLA without problems!\n\n#### XLA Rule #2: Your code cannot have \u201cdata-dependent shapes\u201d\n\nWhat this means is that the shape of all of the `tf.Tensor` objects in your code cannot depend on their values. For example, the function `tf.unique` cannot be compiled with XLA, because it returns a `tensor` containing one instance of each unique value in the input. The shape of this output will obviously be different depending on how repetitive the input `Tensor` was, and so XLA refuses to handle it!\n\nIn general, most neural network code obeys rule #2 by default. However, there are a few common cases where it becomes a problem. One very common one is when you use **label masking**, setting your labels to a negative value to indicate that those positions should be ignored when computing the loss. If you look at NumPy or PyTorch loss functions that support label masking, you will often see code like this that uses [boolean indexing](https://numpy.org/doc/stable/user/basics.indexing.html#boolean-array-indexing):\n\n```python\nlabel_mask = labels >= 0\nmasked_outputs = outputs[label_mask]\nmasked_labels = labels[label_mask]\nloss = compute_loss(masked_outputs, masked_labels)\nmean_loss = torch.mean(loss)\n```\n\nThis code is totally fine in NumPy or PyTorch, but it breaks in XLA! Why? Because the shape of `masked_outputs` and `masked_labels` depends on how many positions are masked - that makes it a **data-dependent shape.** However, just like for rule #1, we can often rewrite this code to yield exactly the same output without any data-dependent shapes.\n\n```python\nlabel_mask = tf.cast(labels >= 0, tf.float32)\nloss = compute_loss(outputs, labels)\nloss = loss * label_mask  # Set negative label positions to 0\nmean_loss = tf.reduce_sum(loss) / tf.reduce_sum(label_mask)\n```\n\nHere, we avoid data-dependent shapes by computing the loss for every position, but zeroing out the masked positions in both the numerator and denominator when we calculate the mean, which yields exactly the same result as the first block while maintaining XLA compatibility. Note that we use the same trick as in rule #1 - converting a `tf.bool` to `"
        }
    }
]