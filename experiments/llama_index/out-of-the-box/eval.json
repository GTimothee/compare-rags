[
    {
        "sample_idx": 0,
        "question": "What is the default CPU configuration for a created Endpoint?",
        "answer": "2 x 4GB vCPUs with Intel Xeon Ice Lake.",
        "rag_answer": "The default CPU configuration for a created Endpoint is 2 x 4GB vCPUs with Intel Xeon Ice Lake, which is considered a medium CPU.",
        "rag_score": 5,
        "rag_feedback": "The system's response is completely correct, accurate, and factual. It provides the exact default CPU configuration for a created Endpoint, which is 2 x 4GB vCPUs with Intel Xeon Ice Lake, and also adds additional context about it being considered a medium CPU.",
        "rag_context": [
            {
                "score": 0.6628142409248189,
                "node_text": "Here are some facts extracted from the provided text:\n\nEndpoint creation page -> Is located at -> Https://ui.endpoints.huggingface.co/new\nHugging face repository id -> Is required for -> Endpoint creation\nEndpoint name -> Is desired by -> User\nEndpoint -> Is created with -> Medium cpu\n\nCreate an Endpoint\n\nAfter your first login, you will be directed to the [Endpoint creation page](https://ui.endpoints.huggingface.co/new). As an example, this guide will go through the steps to deploy [distilbert-base-uncased-finetuned-sst-2-english](https://huggingface.co/distilbert-base-uncased-finetuned-sst-2-english) for text classification. \n\n## 1. Enter the Hugging Face Repository ID and your desired endpoint name:\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_repository.png\" alt=\"select repository\" />\n\n## 2. Select your Cloud Provider and region. Initially, only AWS will be available as a Cloud Provider with the `us-east-1` and `eu-west-1` regions. We will add Azure soon, and if you need to test Endpoints with other Cloud Providers or regions, please let us know.\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_region.png\" alt=\"select region\" />\n\n## 3. Define the [Security Level](security) for the Endpoint:\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_security.png\" alt=\"define security\" />\n\n## 4. Create your Endpoint by clicking **Create Endpoint**. By default, your Endpoint is created with a medium CPU (2 x 4GB vCPUs with Intel Xeon Ice Lake) The cost estimate assumes the Endpoint will be up for an entire month, and does not take autoscaling into account.\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_create_cost.png\" alt=\"create endpoint\" />\n\n## 5. Wait for the Endpoint to build, initialize and run which can take between 1 to 5 minutes.\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/overview.png\" alt=\"overview\" />\n\n## 6. Test your Endpoint in the overview with the Inference widget \ud83c\udfc1 \ud83c\udf89!\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_inference.png\" alt=\"run inference\" />"
            }
        ]
    },
    {
        "sample_idx": 1,
        "question": "How long does it take for an Endpoint to build, initialize, and run?",
        "answer": "Between 1 to 5 minutes.",
        "rag_answer": "It takes between 1 to 5 minutes for an Endpoint to build, initialize, and run.",
        "rag_score": 5,
        "rag_feedback": "The system's response is completely correct, accurate, and factual. It directly quotes the expected answer from the provided context, which is a reliable source of information.",
        "rag_context": [
            {
                "score": 0.7088262529858329,
                "node_text": "Here are some facts extracted from the provided text:\n\nEndpoint creation page -> Is located at -> Https://ui.endpoints.huggingface.co/new\nHugging face repository id -> Is required for -> Endpoint creation\nEndpoint name -> Is desired by -> User\nSecurity level -> Is defined for -> Endpoint\nEndpoint -> Is created with -> Medium cpu\n\nCreate an Endpoint\n\nAfter your first login, you will be directed to the [Endpoint creation page](https://ui.endpoints.huggingface.co/new). As an example, this guide will go through the steps to deploy [distilbert-base-uncased-finetuned-sst-2-english](https://huggingface.co/distilbert-base-uncased-finetuned-sst-2-english) for text classification. \n\n## 1. Enter the Hugging Face Repository ID and your desired endpoint name:\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_repository.png\" alt=\"select repository\" />\n\n## 2. Select your Cloud Provider and region. Initially, only AWS will be available as a Cloud Provider with the `us-east-1` and `eu-west-1` regions. We will add Azure soon, and if you need to test Endpoints with other Cloud Providers or regions, please let us know.\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_region.png\" alt=\"select region\" />\n\n## 3. Define the [Security Level](security) for the Endpoint:\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_security.png\" alt=\"define security\" />\n\n## 4. Create your Endpoint by clicking **Create Endpoint**. By default, your Endpoint is created with a medium CPU (2 x 4GB vCPUs with Intel Xeon Ice Lake) The cost estimate assumes the Endpoint will be up for an entire month, and does not take autoscaling into account.\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_create_cost.png\" alt=\"create endpoint\" />\n\n## 5. Wait for the Endpoint to build, initialize and run which can take between 1 to 5 minutes.\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/overview.png\" alt=\"overview\" />\n\n## 6. Test your Endpoint in the overview with the Inference widget \ud83c\udfc1 \ud83c\udf89!\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_inference.png\" alt=\"run inference\" />"
            }
        ]
    },
    {
        "sample_idx": 2,
        "question": "What is the initial Cloud Provider available for Endpoint creation?",
        "answer": "AWS.",
        "rag_answer": "AWS",
        "rag_score": 5,
        "rag_feedback": "The system's response is completely correct, accurate, and factual. It directly answers the question by stating that the initial Cloud Provider available for Endpoint creation is AWS, which is supported by the provided context.",
        "rag_context": [
            {
                "score": 1.0,
                "node_text": "Here are some facts extracted from the provided text:\n\nHugging face repository id -> Is required for -> Endpoint creation\n\nCreate an Endpoint\n\nAfter your first login, you will be directed to the [Endpoint creation page](https://ui.endpoints.huggingface.co/new). As an example, this guide will go through the steps to deploy [distilbert-base-uncased-finetuned-sst-2-english](https://huggingface.co/distilbert-base-uncased-finetuned-sst-2-english) for text classification. \n\n## 1. Enter the Hugging Face Repository ID and your desired endpoint name:\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_repository.png\" alt=\"select repository\" />\n\n## 2. Select your Cloud Provider and region. Initially, only AWS will be available as a Cloud Provider with the `us-east-1` and `eu-west-1` regions. We will add Azure soon, and if you need to test Endpoints with other Cloud Providers or regions, please let us know.\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_region.png\" alt=\"select region\" />\n\n## 3. Define the [Security Level](security) for the Endpoint:\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_security.png\" alt=\"define security\" />\n\n## 4. Create your Endpoint by clicking **Create Endpoint**. By default, your Endpoint is created with a medium CPU (2 x 4GB vCPUs with Intel Xeon Ice Lake) The cost estimate assumes the Endpoint will be up for an entire month, and does not take autoscaling into account.\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_create_cost.png\" alt=\"create endpoint\" />\n\n## 5. Wait for the Endpoint to build, initialize and run which can take between 1 to 5 minutes.\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/overview.png\" alt=\"overview\" />\n\n## 6. Test your Endpoint in the overview with the Inference widget \ud83c\udfc1 \ud83c\udf89!\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_inference.png\" alt=\"run inference\" />"
            },
            {
                "score": 0.7374259037564369,
                "node_text": "Here are some facts extracted from the provided text:\n\nEndpoint creation page -> Is located at -> Https://ui.endpoints.huggingface.co/new\nHugging face repository id -> Is required for -> Endpoint creation\nEndpoint name -> Is desired by -> User\nAws -> Is a -> Cloud provider\n\nCreate an Endpoint\n\nAfter your first login, you will be directed to the [Endpoint creation page](https://ui.endpoints.huggingface.co/new). As an example, this guide will go through the steps to deploy [distilbert-base-uncased-finetuned-sst-2-english](https://huggingface.co/distilbert-base-uncased-finetuned-sst-2-english) for text classification. \n\n## 1. Enter the Hugging Face Repository ID and your desired endpoint name:\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_repository.png\" alt=\"select repository\" />\n\n## 2. Select your Cloud Provider and region. Initially, only AWS will be available as a Cloud Provider with the `us-east-1` and `eu-west-1` regions. We will add Azure soon, and if you need to test Endpoints with other Cloud Providers or regions, please let us know.\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_region.png\" alt=\"select region\" />\n\n## 3. Define the [Security Level](security) for the Endpoint:\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_security.png\" alt=\"define security\" />\n\n## 4. Create your Endpoint by clicking **Create Endpoint**. By default, your Endpoint is created with a medium CPU (2 x 4GB vCPUs with Intel Xeon Ice Lake) The cost estimate assumes the Endpoint will be up for an entire month, and does not take autoscaling into account.\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_create_cost.png\" alt=\"create endpoint\" />\n\n## 5. Wait for the Endpoint to build, initialize and run which can take between 1 to 5 minutes.\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/overview.png\" alt=\"overview\" />\n\n## 6. Test your Endpoint in the overview with the Inference widget \ud83c\udfc1 \ud83c\udf89!\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_inference.png\" alt=\"run inference\" />"
            }
        ]
    },
    {
        "sample_idx": 3,
        "question": "What are the initial regions available for Endpoint creation on AWS?",
        "answer": "us-east-1 and eu-west-1.",
        "rag_answer": "The initial regions available for Endpoint creation on AWS are us-east-1 and eu-west-1.",
        "rag_score": 5,
        "rag_feedback": "The system's response is completely correct, accurate, and factual. It directly answers the question by stating that the initial regions available for Endpoint creation on AWS are us-east-1 and eu-west-1, which matches the expected answer.",
        "rag_context": [
            {
                "score": 1.0,
                "node_text": "Here are some facts extracted from the provided text:\n\nHugging face repository id -> Is required for -> Endpoint creation\n\nCreate an Endpoint\n\nAfter your first login, you will be directed to the [Endpoint creation page](https://ui.endpoints.huggingface.co/new). As an example, this guide will go through the steps to deploy [distilbert-base-uncased-finetuned-sst-2-english](https://huggingface.co/distilbert-base-uncased-finetuned-sst-2-english) for text classification. \n\n## 1. Enter the Hugging Face Repository ID and your desired endpoint name:\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_repository.png\" alt=\"select repository\" />\n\n## 2. Select your Cloud Provider and region. Initially, only AWS will be available as a Cloud Provider with the `us-east-1` and `eu-west-1` regions. We will add Azure soon, and if you need to test Endpoints with other Cloud Providers or regions, please let us know.\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_region.png\" alt=\"select region\" />\n\n## 3. Define the [Security Level](security) for the Endpoint:\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_security.png\" alt=\"define security\" />\n\n## 4. Create your Endpoint by clicking **Create Endpoint**. By default, your Endpoint is created with a medium CPU (2 x 4GB vCPUs with Intel Xeon Ice Lake) The cost estimate assumes the Endpoint will be up for an entire month, and does not take autoscaling into account.\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_create_cost.png\" alt=\"create endpoint\" />\n\n## 5. Wait for the Endpoint to build, initialize and run which can take between 1 to 5 minutes.\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/overview.png\" alt=\"overview\" />\n\n## 6. Test your Endpoint in the overview with the Inference widget \ud83c\udfc1 \ud83c\udf89!\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_inference.png\" alt=\"run inference\" />"
            },
            {
                "score": 0.6866615282670918,
                "node_text": "Here are some facts extracted from the provided text:\n\nEndpoint creation page -> Is located at -> Https://ui.endpoints.huggingface.co/new\nHugging face repository id -> Is required for -> Endpoint creation\nEndpoint name -> Is desired by -> User\nAws -> Is a -> Cloud provider\n\nCreate an Endpoint\n\nAfter your first login, you will be directed to the [Endpoint creation page](https://ui.endpoints.huggingface.co/new). As an example, this guide will go through the steps to deploy [distilbert-base-uncased-finetuned-sst-2-english](https://huggingface.co/distilbert-base-uncased-finetuned-sst-2-english) for text classification. \n\n## 1. Enter the Hugging Face Repository ID and your desired endpoint name:\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_repository.png\" alt=\"select repository\" />\n\n## 2. Select your Cloud Provider and region. Initially, only AWS will be available as a Cloud Provider with the `us-east-1` and `eu-west-1` regions. We will add Azure soon, and if you need to test Endpoints with other Cloud Providers or regions, please let us know.\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_region.png\" alt=\"select region\" />\n\n## 3. Define the [Security Level](security) for the Endpoint:\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_security.png\" alt=\"define security\" />\n\n## 4. Create your Endpoint by clicking **Create Endpoint**. By default, your Endpoint is created with a medium CPU (2 x 4GB vCPUs with Intel Xeon Ice Lake) The cost estimate assumes the Endpoint will be up for an entire month, and does not take autoscaling into account.\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_create_cost.png\" alt=\"create endpoint\" />\n\n## 5. Wait for the Endpoint to build, initialize and run which can take between 1 to 5 minutes.\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/overview.png\" alt=\"overview\" />\n\n## 6. Test your Endpoint in the overview with the Inference widget \ud83c\udfc1 \ud83c\udf89!\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_inference.png\" alt=\"run inference\" />"
            }
        ]
    },
    {
        "sample_idx": 4,
        "question": "What is the number of the step to test your Endpoint in the overview with the Inference widget?",
        "answer": "6",
        "rag_answer": "6",
        "rag_score": 5,
        "rag_feedback": "The system's response is completely correct, accurate, and factual. It provides the correct answer '6' and also provides additional context and information related to the question, which is not required but does not detract from the correctness of the answer.",
        "rag_context": [
            {
                "score": 0.6817237736105564,
                "node_text": "Here are some facts extracted from the provided text:\n\nInference widget -> Is used for -> Testing endpoint\nEndpoint name -> Is desired by -> User\nHugging face repository id -> Is required for -> Endpoint creation\nEndpoint creation page -> Is located at -> Https://ui.endpoints.huggingface.co/new\n\nCreate an Endpoint\n\nAfter your first login, you will be directed to the [Endpoint creation page](https://ui.endpoints.huggingface.co/new). As an example, this guide will go through the steps to deploy [distilbert-base-uncased-finetuned-sst-2-english](https://huggingface.co/distilbert-base-uncased-finetuned-sst-2-english) for text classification. \n\n## 1. Enter the Hugging Face Repository ID and your desired endpoint name:\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_repository.png\" alt=\"select repository\" />\n\n## 2. Select your Cloud Provider and region. Initially, only AWS will be available as a Cloud Provider with the `us-east-1` and `eu-west-1` regions. We will add Azure soon, and if you need to test Endpoints with other Cloud Providers or regions, please let us know.\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_region.png\" alt=\"select region\" />\n\n## 3. Define the [Security Level](security) for the Endpoint:\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_security.png\" alt=\"define security\" />\n\n## 4. Create your Endpoint by clicking **Create Endpoint**. By default, your Endpoint is created with a medium CPU (2 x 4GB vCPUs with Intel Xeon Ice Lake) The cost estimate assumes the Endpoint will be up for an entire month, and does not take autoscaling into account.\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_create_cost.png\" alt=\"create endpoint\" />\n\n## 5. Wait for the Endpoint to build, initialize and run which can take between 1 to 5 minutes.\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/overview.png\" alt=\"overview\" />\n\n## 6. Test your Endpoint in the overview with the Inference widget \ud83c\udfc1 \ud83c\udf89!\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_inference.png\" alt=\"run inference\" />"
            }
        ]
    },
    {
        "sample_idx": 5,
        "question": "What is the name of the widget used to test your Endpoint in the overview?",
        "answer": "Inference widget",
        "rag_answer": "The name of the widget used to test your Endpoint in the overview is the Inference widget.",
        "rag_score": 5,
        "rag_feedback": "The response is completely correct, accurate, and factual. It correctly identifies the Inference widget as the widget used to test the Endpoint in the overview, and the context provided is relevant and supports the answer.",
        "rag_context": [
            {
                "score": 0.7210805924026203,
                "node_text": "Here are some facts extracted from the provided text:\n\nInference widget -> Is used for -> Testing endpoint\nEndpoint creation page -> Is located at -> Https://ui.endpoints.huggingface.co/new\nEndpoint name -> Is desired by -> User\nHugging face repository id -> Is required for -> Endpoint creation\n\nCreate an Endpoint\n\nAfter your first login, you will be directed to the [Endpoint creation page](https://ui.endpoints.huggingface.co/new). As an example, this guide will go through the steps to deploy [distilbert-base-uncased-finetuned-sst-2-english](https://huggingface.co/distilbert-base-uncased-finetuned-sst-2-english) for text classification. \n\n## 1. Enter the Hugging Face Repository ID and your desired endpoint name:\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_repository.png\" alt=\"select repository\" />\n\n## 2. Select your Cloud Provider and region. Initially, only AWS will be available as a Cloud Provider with the `us-east-1` and `eu-west-1` regions. We will add Azure soon, and if you need to test Endpoints with other Cloud Providers or regions, please let us know.\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_region.png\" alt=\"select region\" />\n\n## 3. Define the [Security Level](security) for the Endpoint:\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_security.png\" alt=\"define security\" />\n\n## 4. Create your Endpoint by clicking **Create Endpoint**. By default, your Endpoint is created with a medium CPU (2 x 4GB vCPUs with Intel Xeon Ice Lake) The cost estimate assumes the Endpoint will be up for an entire month, and does not take autoscaling into account.\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_create_cost.png\" alt=\"create endpoint\" />\n\n## 5. Wait for the Endpoint to build, initialize and run which can take between 1 to 5 minutes.\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/overview.png\" alt=\"overview\" />\n\n## 6. Test your Endpoint in the overview with the Inference widget \ud83c\udfc1 \ud83c\udf89!\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_inference.png\" alt=\"run inference\" />"
            }
        ]
    },
    {
        "sample_idx": 6,
        "question": "How many high-level categories of metrics are there?",
        "answer": "There are 3 high-level categories of metrics.",
        "rag_answer": "There are 3 high-level categories of metrics.",
        "rag_score": 5,
        "rag_feedback": "The system's response is completely correct, accurate, and factual. It exactly matches the expected answer, stating that there are 3 high-level categories of metrics.",
        "rag_context": [
            {
                "score": 0.7247388063301609,
                "node_text": "Here are some facts extracted from the provided text:\n\nGeneric metrics -> Can be applied to -> Variety of situations\nBleu -> Is -> Task-specific metric\nGlue benchmark -> Has -> Dedicated evaluation metric\nMetric -> Is -> Evaluation metric\n\nChoosing a metric for your task\n\n**So you've trained your model and want to see how well it\u2019s doing on a dataset of your choice. Where do you start?**\n\nThere is no \u201cone size fits all\u201d approach to choosing an evaluation metric, but some good guidelines to keep in mind are:\n\n## Categories of metrics\n\nThere are 3 high-level categories of metrics:\n\n1. *Generic metrics*, which can be applied to a variety of situations and datasets, such as precision and accuracy.\n2. *Task-specific metrics*, which are limited to a given task, such as Machine Translation (often evaluated using metrics [BLEU](https://huggingface.co/metrics/bleu) or [ROUGE](https://huggingface.co/metrics/rouge)) or Named Entity Recognition (often evaluated with [seqeval](https://huggingface.co/metrics/seqeval)).\n3. *Dataset-specific metrics*, which aim to measure model performance on specific benchmarks: for instance, the [GLUE benchmark](https://huggingface.co/datasets/glue) has a dedicated [evaluation metric](https://huggingface.co/metrics/glue).\n\nLet's look at each of these three cases:\n\n### Generic metrics\n\nMany of the metrics used in the Machine Learning community are quite generic and can be applied in a variety of tasks and datasets.\n\nThis is the case for metrics like [accuracy](https://huggingface.co/metrics/accuracy) and [precision](https://huggingface.co/metrics/precision), which can be used for evaluating labeled (supervised) datasets, as well as [perplexity](https://huggingface.co/metrics/perplexity), which can be used for evaluating different kinds of (unsupervised) generative tasks.\n\nTo see the input structure of a given metric, you can look at its metric card. For example, in the case of [precision](https://huggingface.co/metrics/precision), the format is:\n```\n>>> precision_metric = evaluate.load(\"precision\")\n>>> results = precision_metric.compute(references=[0, 1], predictions=[0, 1])\n>>> print(results)\n{'precision': 1.0}\n```\n\n### Task-specific metrics\n\nPopular ML tasks like Machine Translation and Named Entity Recognition have specific metrics that can be used to compare models. For example, a series of different metrics have been proposed for text generation, ranging from [BLEU](https://huggingface.co/metrics/bleu) and its derivatives such as [GoogleBLEU](https://huggingface.co/metrics/google_bleu) and [GLEU](https://huggingface.co/metrics/gleu), but also [ROUGE](https://huggingface.co/metrics/rouge), [MAUVE](https://huggingface.co/metrics/mauve), etc.\n\nYou can find the right metric for your task by:\n\n- **Looking at the [Task pages](https://huggingface.co/tasks)** to see what metrics can be used for evaluating models for a given task.\n- **Checking out leaderboards** on sites like [Papers With Code](https://paperswithcode.com/) (you can search by task and by dataset).\n-  **Reading the metric cards** for the relevant metrics and see which ones are a good fit for your use case. For example, see the [BLEU metric card](https://github.com/huggingface/evaluate/tree/main/metrics/bleu) or [SQuaD metric card](https://github.com/huggingface/evaluate/tree/main/metrics/squad).\n- **Looking at papers and blog posts** published on the topic and see what metrics they report. This can change over time, so try to pick papers from the last couple of years!\n\n### Dataset-specific metrics\n\nSome datasets have specific metrics associated with them -- this is especially in the case of popular benchmarks like [GLUE](https://huggingface.co/metrics/glue) and [SQuAD](https://huggingface.co/metrics/squad).\n\n<Tip warning={true}>\n\ud83d\udca1\nGLUE is actually a collection of different subsets on different tasks, so first you need to choose the one that corresponds to the NLI task, such as mnli, which is described as \u201ccrowdsourced collection of sentence pairs with textual entailment annotations\u201d\n</Tip>"
            },
            {
                "score": 0.6375465216847686,
                "node_text": "Here are some facts extracted from the provided text:\n\nSquad -> Has -> Evaluation metric\nEvaluation metric -> Requires -> Format\n\nIf you are evaluating your model on a benchmark dataset like the ones mentioned above, you can use its dedicated evaluation metric. Make sure you respect the format that they require. For example, to evaluate your model on the [SQuAD](https://huggingface.co/datasets/squad) dataset, you need to feed the `question` and `context` into your model and return the `prediction_text`, which should be compared with the `references` (based on matching the `id` of the question) :\n\n```\n>>> from evaluate import load\n>>> squad_metric = load(\"squad\")\n>>> predictions = [{'prediction_text': '1976', 'id': '56e10a3be3433e1400422b22'}]\n>>> references = [{'answers': {'answer_start': [97], 'text': ['1976']}, 'id': '56e10a3be3433e1400422b22'}]\n>>> results = squad_metric.compute(predictions=predictions, references=references)\n>>> results\n{'exact_match': 100.0, 'f1': 100.0}\n```\n\nYou can find examples of dataset structures by consulting the \"Dataset Preview\" function or the dataset card for a given dataset, and you can see how to use its dedicated evaluation function based on the metric card."
            }
        ]
    },
    {
        "sample_idx": 7,
        "question": "What are the three high-level categories of metrics?",
        "answer": "The three high-level categories of metrics are generic metrics, task-specific metrics, and dataset-specific metrics.",
        "rag_answer": "The three high-level categories of metrics are: Generic metrics, Task-specific metrics, and Dataset-specific metrics.",
        "rag_score": 5,
        "rag_feedback": "The system's response is completely correct, accurate, and factual. It exactly matches the expected answer, providing the three high-level categories of metrics as generic metrics, task-specific metrics, and dataset-specific metrics.",
        "rag_context": [
            {
                "score": 0.7282921507430341,
                "node_text": "Here are some facts extracted from the provided text:\n\nGeneric metrics -> Can be applied to -> Variety of situations\nBleu -> Is -> Task-specific metric\nAccuracy -> Is -> Generic metric\nPerplexity -> Is -> Generic metric\nPrecision -> Is -> Generic metric\nMetric -> Is -> Evaluation metric\n\nChoosing a metric for your task\n\n**So you've trained your model and want to see how well it\u2019s doing on a dataset of your choice. Where do you start?**\n\nThere is no \u201cone size fits all\u201d approach to choosing an evaluation metric, but some good guidelines to keep in mind are:\n\n## Categories of metrics\n\nThere are 3 high-level categories of metrics:\n\n1. *Generic metrics*, which can be applied to a variety of situations and datasets, such as precision and accuracy.\n2. *Task-specific metrics*, which are limited to a given task, such as Machine Translation (often evaluated using metrics [BLEU](https://huggingface.co/metrics/bleu) or [ROUGE](https://huggingface.co/metrics/rouge)) or Named Entity Recognition (often evaluated with [seqeval](https://huggingface.co/metrics/seqeval)).\n3. *Dataset-specific metrics*, which aim to measure model performance on specific benchmarks: for instance, the [GLUE benchmark](https://huggingface.co/datasets/glue) has a dedicated [evaluation metric](https://huggingface.co/metrics/glue).\n\nLet's look at each of these three cases:\n\n### Generic metrics\n\nMany of the metrics used in the Machine Learning community are quite generic and can be applied in a variety of tasks and datasets.\n\nThis is the case for metrics like [accuracy](https://huggingface.co/metrics/accuracy) and [precision](https://huggingface.co/metrics/precision), which can be used for evaluating labeled (supervised) datasets, as well as [perplexity](https://huggingface.co/metrics/perplexity), which can be used for evaluating different kinds of (unsupervised) generative tasks.\n\nTo see the input structure of a given metric, you can look at its metric card. For example, in the case of [precision](https://huggingface.co/metrics/precision), the format is:\n```\n>>> precision_metric = evaluate.load(\"precision\")\n>>> results = precision_metric.compute(references=[0, 1], predictions=[0, 1])\n>>> print(results)\n{'precision': 1.0}\n```\n\n### Task-specific metrics\n\nPopular ML tasks like Machine Translation and Named Entity Recognition have specific metrics that can be used to compare models. For example, a series of different metrics have been proposed for text generation, ranging from [BLEU](https://huggingface.co/metrics/bleu) and its derivatives such as [GoogleBLEU](https://huggingface.co/metrics/google_bleu) and [GLEU](https://huggingface.co/metrics/gleu), but also [ROUGE](https://huggingface.co/metrics/rouge), [MAUVE](https://huggingface.co/metrics/mauve), etc.\n\nYou can find the right metric for your task by:\n\n- **Looking at the [Task pages](https://huggingface.co/tasks)** to see what metrics can be used for evaluating models for a given task.\n- **Checking out leaderboards** on sites like [Papers With Code](https://paperswithcode.com/) (you can search by task and by dataset).\n-  **Reading the metric cards** for the relevant metrics and see which ones are a good fit for your use case. For example, see the [BLEU metric card](https://github.com/huggingface/evaluate/tree/main/metrics/bleu) or [SQuaD metric card](https://github.com/huggingface/evaluate/tree/main/metrics/squad).\n- **Looking at papers and blog posts** published on the topic and see what metrics they report. This can change over time, so try to pick papers from the last couple of years!\n\n### Dataset-specific metrics\n\nSome datasets have specific metrics associated with them -- this is especially in the case of popular benchmarks like [GLUE](https://huggingface.co/metrics/glue) and [SQuAD](https://huggingface.co/metrics/squad).\n\n<Tip warning={true}>\n\ud83d\udca1\nGLUE is actually a collection of different subsets on different tasks, so first you need to choose the one that corresponds to the NLI task, such as mnli, which is described as \u201ccrowdsourced collection of sentence pairs with textual entailment annotations\u201d\n</Tip>"
            },
            {
                "score": 0.6394141808450154,
                "node_text": "Here are some facts extracted from the provided text:\n\nSquad -> Has -> Evaluation metric\nEvaluation metric -> Requires -> Format\n\nIf you are evaluating your model on a benchmark dataset like the ones mentioned above, you can use its dedicated evaluation metric. Make sure you respect the format that they require. For example, to evaluate your model on the [SQuAD](https://huggingface.co/datasets/squad) dataset, you need to feed the `question` and `context` into your model and return the `prediction_text`, which should be compared with the `references` (based on matching the `id` of the question) :\n\n```\n>>> from evaluate import load\n>>> squad_metric = load(\"squad\")\n>>> predictions = [{'prediction_text': '1976', 'id': '56e10a3be3433e1400422b22'}]\n>>> references = [{'answers': {'answer_start': [97], 'text': ['1976']}, 'id': '56e10a3be3433e1400422b22'}]\n>>> results = squad_metric.compute(predictions=predictions, references=references)\n>>> results\n{'exact_match': 100.0, 'f1': 100.0}\n```\n\nYou can find examples of dataset structures by consulting the \"Dataset Preview\" function or the dataset card for a given dataset, and you can see how to use its dedicated evaluation function based on the metric card."
            }
        ]
    },
    {
        "sample_idx": 8,
        "question": "What is an example of a task-specific metric for Machine Translation?",
        "answer": "BLEU and ROUGE are examples of task-specific metrics for Machine Translation.",
        "rag_answer": "BLEU is an example of a task-specific metric for Machine Translation.",
        "rag_score": 4,
        "rag_feedback": "The response is mostly correct, accurate, and factual, but it only mentions BLEU as an example of a task-specific metric for Machine Translation, whereas the expected answer also includes ROUGE.",
        "rag_context": [
            {
                "score": 0.8240757170830898,
                "node_text": "Here are some facts extracted from the provided text:\n\nBleu -> Is -> Task-specific metric\nGeneric metrics -> Can be applied to -> Variety of situations\nGlue benchmark -> Has -> Dedicated evaluation metric\nMetric -> Is -> Evaluation metric\n\nChoosing a metric for your task\n\n**So you've trained your model and want to see how well it\u2019s doing on a dataset of your choice. Where do you start?**\n\nThere is no \u201cone size fits all\u201d approach to choosing an evaluation metric, but some good guidelines to keep in mind are:\n\n## Categories of metrics\n\nThere are 3 high-level categories of metrics:\n\n1. *Generic metrics*, which can be applied to a variety of situations and datasets, such as precision and accuracy.\n2. *Task-specific metrics*, which are limited to a given task, such as Machine Translation (often evaluated using metrics [BLEU](https://huggingface.co/metrics/bleu) or [ROUGE](https://huggingface.co/metrics/rouge)) or Named Entity Recognition (often evaluated with [seqeval](https://huggingface.co/metrics/seqeval)).\n3. *Dataset-specific metrics*, which aim to measure model performance on specific benchmarks: for instance, the [GLUE benchmark](https://huggingface.co/datasets/glue) has a dedicated [evaluation metric](https://huggingface.co/metrics/glue).\n\nLet's look at each of these three cases:\n\n### Generic metrics\n\nMany of the metrics used in the Machine Learning community are quite generic and can be applied in a variety of tasks and datasets.\n\nThis is the case for metrics like [accuracy](https://huggingface.co/metrics/accuracy) and [precision](https://huggingface.co/metrics/precision), which can be used for evaluating labeled (supervised) datasets, as well as [perplexity](https://huggingface.co/metrics/perplexity), which can be used for evaluating different kinds of (unsupervised) generative tasks.\n\nTo see the input structure of a given metric, you can look at its metric card. For example, in the case of [precision](https://huggingface.co/metrics/precision), the format is:\n```\n>>> precision_metric = evaluate.load(\"precision\")\n>>> results = precision_metric.compute(references=[0, 1], predictions=[0, 1])\n>>> print(results)\n{'precision': 1.0}\n```\n\n### Task-specific metrics\n\nPopular ML tasks like Machine Translation and Named Entity Recognition have specific metrics that can be used to compare models. For example, a series of different metrics have been proposed for text generation, ranging from [BLEU](https://huggingface.co/metrics/bleu) and its derivatives such as [GoogleBLEU](https://huggingface.co/metrics/google_bleu) and [GLEU](https://huggingface.co/metrics/gleu), but also [ROUGE](https://huggingface.co/metrics/rouge), [MAUVE](https://huggingface.co/metrics/mauve), etc.\n\nYou can find the right metric for your task by:\n\n- **Looking at the [Task pages](https://huggingface.co/tasks)** to see what metrics can be used for evaluating models for a given task.\n- **Checking out leaderboards** on sites like [Papers With Code](https://paperswithcode.com/) (you can search by task and by dataset).\n-  **Reading the metric cards** for the relevant metrics and see which ones are a good fit for your use case. For example, see the [BLEU metric card](https://github.com/huggingface/evaluate/tree/main/metrics/bleu) or [SQuaD metric card](https://github.com/huggingface/evaluate/tree/main/metrics/squad).\n- **Looking at papers and blog posts** published on the topic and see what metrics they report. This can change over time, so try to pick papers from the last couple of years!\n\n### Dataset-specific metrics\n\nSome datasets have specific metrics associated with them -- this is especially in the case of popular benchmarks like [GLUE](https://huggingface.co/metrics/glue) and [SQuAD](https://huggingface.co/metrics/squad).\n\n<Tip warning={true}>\n\ud83d\udca1\nGLUE is actually a collection of different subsets on different tasks, so first you need to choose the one that corresponds to the NLI task, such as mnli, which is described as \u201ccrowdsourced collection of sentence pairs with textual entailment annotations\u201d\n</Tip>"
            },
            {
                "score": 0.6060490776283599,
                "node_text": "Here are some facts extracted from the provided text:\n\nSquad -> Has -> Evaluation metric\nEvaluation metric -> Requires -> Format\n\nIf you are evaluating your model on a benchmark dataset like the ones mentioned above, you can use its dedicated evaluation metric. Make sure you respect the format that they require. For example, to evaluate your model on the [SQuAD](https://huggingface.co/datasets/squad) dataset, you need to feed the `question` and `context` into your model and return the `prediction_text`, which should be compared with the `references` (based on matching the `id` of the question) :\n\n```\n>>> from evaluate import load\n>>> squad_metric = load(\"squad\")\n>>> predictions = [{'prediction_text': '1976', 'id': '56e10a3be3433e1400422b22'}]\n>>> references = [{'answers': {'answer_start': [97], 'text': ['1976']}, 'id': '56e10a3be3433e1400422b22'}]\n>>> results = squad_metric.compute(predictions=predictions, references=references)\n>>> results\n{'exact_match': 100.0, 'f1': 100.0}\n```\n\nYou can find examples of dataset structures by consulting the \"Dataset Preview\" function or the dataset card for a given dataset, and you can see how to use its dedicated evaluation function based on the metric card."
            }
        ]
    },
    {
        "sample_idx": 9,
        "question": "What is an example of a task-specific metric for Named Entity Recognition?",
        "answer": "Seqeval is an example of a task-specific metric for Named Entity Recognition.",
        "rag_answer": "Seqeval is an example of a task-specific metric for Named Entity Recognition.",
        "rag_score": 5,
        "rag_feedback": "The system's response is completely correct, accurate, and factual. It provides the exact answer 'Seqeval is an example of a task-specific metric for Named Entity Recognition.' within a larger context that discusses task-specific metrics, including Named Entity Recognition and its evaluation with Seqeval.",
        "rag_context": [
            {
                "score": 0.7537260922873521,
                "node_text": "Here are some facts extracted from the provided text:\n\nBleu -> Is -> Task-specific metric\nNamed entity recognition -> Evaluated with -> Seqeval\nGlue benchmark -> Has -> Dedicated evaluation metric\nMetric -> Is -> Evaluation metric\n\nChoosing a metric for your task\n\n**So you've trained your model and want to see how well it\u2019s doing on a dataset of your choice. Where do you start?**\n\nThere is no \u201cone size fits all\u201d approach to choosing an evaluation metric, but some good guidelines to keep in mind are:\n\n## Categories of metrics\n\nThere are 3 high-level categories of metrics:\n\n1. *Generic metrics*, which can be applied to a variety of situations and datasets, such as precision and accuracy.\n2. *Task-specific metrics*, which are limited to a given task, such as Machine Translation (often evaluated using metrics [BLEU](https://huggingface.co/metrics/bleu) or [ROUGE](https://huggingface.co/metrics/rouge)) or Named Entity Recognition (often evaluated with [seqeval](https://huggingface.co/metrics/seqeval)).\n3. *Dataset-specific metrics*, which aim to measure model performance on specific benchmarks: for instance, the [GLUE benchmark](https://huggingface.co/datasets/glue) has a dedicated [evaluation metric](https://huggingface.co/metrics/glue).\n\nLet's look at each of these three cases:\n\n### Generic metrics\n\nMany of the metrics used in the Machine Learning community are quite generic and can be applied in a variety of tasks and datasets.\n\nThis is the case for metrics like [accuracy](https://huggingface.co/metrics/accuracy) and [precision](https://huggingface.co/metrics/precision), which can be used for evaluating labeled (supervised) datasets, as well as [perplexity](https://huggingface.co/metrics/perplexity), which can be used for evaluating different kinds of (unsupervised) generative tasks.\n\nTo see the input structure of a given metric, you can look at its metric card. For example, in the case of [precision](https://huggingface.co/metrics/precision), the format is:\n```\n>>> precision_metric = evaluate.load(\"precision\")\n>>> results = precision_metric.compute(references=[0, 1], predictions=[0, 1])\n>>> print(results)\n{'precision': 1.0}\n```\n\n### Task-specific metrics\n\nPopular ML tasks like Machine Translation and Named Entity Recognition have specific metrics that can be used to compare models. For example, a series of different metrics have been proposed for text generation, ranging from [BLEU](https://huggingface.co/metrics/bleu) and its derivatives such as [GoogleBLEU](https://huggingface.co/metrics/google_bleu) and [GLEU](https://huggingface.co/metrics/gleu), but also [ROUGE](https://huggingface.co/metrics/rouge), [MAUVE](https://huggingface.co/metrics/mauve), etc.\n\nYou can find the right metric for your task by:\n\n- **Looking at the [Task pages](https://huggingface.co/tasks)** to see what metrics can be used for evaluating models for a given task.\n- **Checking out leaderboards** on sites like [Papers With Code](https://paperswithcode.com/) (you can search by task and by dataset).\n-  **Reading the metric cards** for the relevant metrics and see which ones are a good fit for your use case. For example, see the [BLEU metric card](https://github.com/huggingface/evaluate/tree/main/metrics/bleu) or [SQuaD metric card](https://github.com/huggingface/evaluate/tree/main/metrics/squad).\n- **Looking at papers and blog posts** published on the topic and see what metrics they report. This can change over time, so try to pick papers from the last couple of years!\n\n### Dataset-specific metrics\n\nSome datasets have specific metrics associated with them -- this is especially in the case of popular benchmarks like [GLUE](https://huggingface.co/metrics/glue) and [SQuAD](https://huggingface.co/metrics/squad).\n\n<Tip warning={true}>\n\ud83d\udca1\nGLUE is actually a collection of different subsets on different tasks, so first you need to choose the one that corresponds to the NLI task, such as mnli, which is described as \u201ccrowdsourced collection of sentence pairs with textual entailment annotations\u201d\n</Tip>"
            },
            {
                "score": 0.598791599406331,
                "node_text": "Here are some facts extracted from the provided text:\n\nSquad -> Has -> Evaluation metric\nEvaluation metric -> Requires -> Format\n\nIf you are evaluating your model on a benchmark dataset like the ones mentioned above, you can use its dedicated evaluation metric. Make sure you respect the format that they require. For example, to evaluate your model on the [SQuAD](https://huggingface.co/datasets/squad) dataset, you need to feed the `question` and `context` into your model and return the `prediction_text`, which should be compared with the `references` (based on matching the `id` of the question) :\n\n```\n>>> from evaluate import load\n>>> squad_metric = load(\"squad\")\n>>> predictions = [{'prediction_text': '1976', 'id': '56e10a3be3433e1400422b22'}]\n>>> references = [{'answers': {'answer_start': [97], 'text': ['1976']}, 'id': '56e10a3be3433e1400422b22'}]\n>>> results = squad_metric.compute(predictions=predictions, references=references)\n>>> results\n{'exact_match': 100.0, 'f1': 100.0}\n```\n\nYou can find examples of dataset structures by consulting the \"Dataset Preview\" function or the dataset card for a given dataset, and you can see how to use its dedicated evaluation function based on the metric card."
            }
        ]
    },
    {
        "sample_idx": 10,
        "question": "What is an example of a dataset-specific metric?",
        "answer": "The GLUE benchmark has a dedicated evaluation metric.",
        "rag_answer": "An example of a dataset-specific metric is the GLUE metric, which is used to measure model performance on the GLUE benchmark.",
        "rag_score": 5,
        "rag_feedback": "The system's response is completely correct, accurate, and factual. It provides a clear and concise example of a dataset-specific metric, which is the GLUE metric used to measure model performance on the GLUE benchmark. The response is well-supported by the context and provides relevant information about the categories of metrics, including generic, task-specific, and dataset-specific metrics.",
        "rag_context": [
            {
                "score": 1.0,
                "node_text": "Here are some facts extracted from the provided text:\n\nMetric -> Is -> Evaluation metric\nBleu -> Is -> Task-specific metric\n\nChoosing a metric for your task\n\n**So you've trained your model and want to see how well it\u2019s doing on a dataset of your choice. Where do you start?**\n\nThere is no \u201cone size fits all\u201d approach to choosing an evaluation metric, but some good guidelines to keep in mind are:\n\n## Categories of metrics\n\nThere are 3 high-level categories of metrics:\n\n1. *Generic metrics*, which can be applied to a variety of situations and datasets, such as precision and accuracy.\n2. *Task-specific metrics*, which are limited to a given task, such as Machine Translation (often evaluated using metrics [BLEU](https://huggingface.co/metrics/bleu) or [ROUGE](https://huggingface.co/metrics/rouge)) or Named Entity Recognition (often evaluated with [seqeval](https://huggingface.co/metrics/seqeval)).\n3. *Dataset-specific metrics*, which aim to measure model performance on specific benchmarks: for instance, the [GLUE benchmark](https://huggingface.co/datasets/glue) has a dedicated [evaluation metric](https://huggingface.co/metrics/glue).\n\nLet's look at each of these three cases:\n\n### Generic metrics\n\nMany of the metrics used in the Machine Learning community are quite generic and can be applied in a variety of tasks and datasets.\n\nThis is the case for metrics like [accuracy](https://huggingface.co/metrics/accuracy) and [precision](https://huggingface.co/metrics/precision), which can be used for evaluating labeled (supervised) datasets, as well as [perplexity](https://huggingface.co/metrics/perplexity), which can be used for evaluating different kinds of (unsupervised) generative tasks.\n\nTo see the input structure of a given metric, you can look at its metric card. For example, in the case of [precision](https://huggingface.co/metrics/precision), the format is:\n```\n>>> precision_metric = evaluate.load(\"precision\")\n>>> results = precision_metric.compute(references=[0, 1], predictions=[0, 1])\n>>> print(results)\n{'precision': 1.0}\n```\n\n### Task-specific metrics\n\nPopular ML tasks like Machine Translation and Named Entity Recognition have specific metrics that can be used to compare models. For example, a series of different metrics have been proposed for text generation, ranging from [BLEU](https://huggingface.co/metrics/bleu) and its derivatives such as [GoogleBLEU](https://huggingface.co/metrics/google_bleu) and [GLEU](https://huggingface.co/metrics/gleu), but also [ROUGE](https://huggingface.co/metrics/rouge), [MAUVE](https://huggingface.co/metrics/mauve), etc.\n\nYou can find the right metric for your task by:\n\n- **Looking at the [Task pages](https://huggingface.co/tasks)** to see what metrics can be used for evaluating models for a given task.\n- **Checking out leaderboards** on sites like [Papers With Code](https://paperswithcode.com/) (you can search by task and by dataset).\n-  **Reading the metric cards** for the relevant metrics and see which ones are a good fit for your use case. For example, see the [BLEU metric card](https://github.com/huggingface/evaluate/tree/main/metrics/bleu) or [SQuaD metric card](https://github.com/huggingface/evaluate/tree/main/metrics/squad).\n- **Looking at papers and blog posts** published on the topic and see what metrics they report. This can change over time, so try to pick papers from the last couple of years!\n\n### Dataset-specific metrics\n\nSome datasets have specific metrics associated with them -- this is especially in the case of popular benchmarks like [GLUE](https://huggingface.co/metrics/glue) and [SQuAD](https://huggingface.co/metrics/squad).\n\n<Tip warning={true}>\n\ud83d\udca1\nGLUE is actually a collection of different subsets on different tasks, so first you need to choose the one that corresponds to the NLI task, such as mnli, which is described as \u201ccrowdsourced collection of sentence pairs with textual entailment annotations\u201d\n</Tip>"
            },
            {
                "score": 1.0,
                "node_text": "Here are some facts extracted from the provided text:\n\nSquad -> Has -> Evaluation metric\nEvaluation metric -> Requires -> Format\n\nIf you are evaluating your model on a benchmark dataset like the ones mentioned above, you can use its dedicated evaluation metric. Make sure you respect the format that they require. For example, to evaluate your model on the [SQuAD](https://huggingface.co/datasets/squad) dataset, you need to feed the `question` and `context` into your model and return the `prediction_text`, which should be compared with the `references` (based on matching the `id` of the question) :\n\n```\n>>> from evaluate import load\n>>> squad_metric = load(\"squad\")\n>>> predictions = [{'prediction_text': '1976', 'id': '56e10a3be3433e1400422b22'}]\n>>> references = [{'answers': {'answer_start': [97], 'text': ['1976']}, 'id': '56e10a3be3433e1400422b22'}]\n>>> results = squad_metric.compute(predictions=predictions, references=references)\n>>> results\n{'exact_match': 100.0, 'f1': 100.0}\n```\n\nYou can find examples of dataset structures by consulting the \"Dataset Preview\" function or the dataset card for a given dataset, and you can see how to use its dedicated evaluation function based on the metric card."
            },
            {
                "score": 0.7439785838011657,
                "node_text": "Here are some facts extracted from the provided text:\n\nBleu -> Is -> Task-specific metric\nGeneric metrics -> Can be applied to -> Variety of situations\nGlue benchmark -> Has -> Dedicated evaluation metric\nMetric -> Is -> Evaluation metric\n\nChoosing a metric for your task\n\n**So you've trained your model and want to see how well it\u2019s doing on a dataset of your choice. Where do you start?**\n\nThere is no \u201cone size fits all\u201d approach to choosing an evaluation metric, but some good guidelines to keep in mind are:\n\n## Categories of metrics\n\nThere are 3 high-level categories of metrics:\n\n1. *Generic metrics*, which can be applied to a variety of situations and datasets, such as precision and accuracy.\n2. *Task-specific metrics*, which are limited to a given task, such as Machine Translation (often evaluated using metrics [BLEU](https://huggingface.co/metrics/bleu) or [ROUGE](https://huggingface.co/metrics/rouge)) or Named Entity Recognition (often evaluated with [seqeval](https://huggingface.co/metrics/seqeval)).\n3. *Dataset-specific metrics*, which aim to measure model performance on specific benchmarks: for instance, the [GLUE benchmark](https://huggingface.co/datasets/glue) has a dedicated [evaluation metric](https://huggingface.co/metrics/glue).\n\nLet's look at each of these three cases:\n\n### Generic metrics\n\nMany of the metrics used in the Machine Learning community are quite generic and can be applied in a variety of tasks and datasets.\n\nThis is the case for metrics like [accuracy](https://huggingface.co/metrics/accuracy) and [precision](https://huggingface.co/metrics/precision), which can be used for evaluating labeled (supervised) datasets, as well as [perplexity](https://huggingface.co/metrics/perplexity), which can be used for evaluating different kinds of (unsupervised) generative tasks.\n\nTo see the input structure of a given metric, you can look at its metric card. For example, in the case of [precision](https://huggingface.co/metrics/precision), the format is:\n```\n>>> precision_metric = evaluate.load(\"precision\")\n>>> results = precision_metric.compute(references=[0, 1], predictions=[0, 1])\n>>> print(results)\n{'precision': 1.0}\n```\n\n### Task-specific metrics\n\nPopular ML tasks like Machine Translation and Named Entity Recognition have specific metrics that can be used to compare models. For example, a series of different metrics have been proposed for text generation, ranging from [BLEU](https://huggingface.co/metrics/bleu) and its derivatives such as [GoogleBLEU](https://huggingface.co/metrics/google_bleu) and [GLEU](https://huggingface.co/metrics/gleu), but also [ROUGE](https://huggingface.co/metrics/rouge), [MAUVE](https://huggingface.co/metrics/mauve), etc.\n\nYou can find the right metric for your task by:\n\n- **Looking at the [Task pages](https://huggingface.co/tasks)** to see what metrics can be used for evaluating models for a given task.\n- **Checking out leaderboards** on sites like [Papers With Code](https://paperswithcode.com/) (you can search by task and by dataset).\n-  **Reading the metric cards** for the relevant metrics and see which ones are a good fit for your use case. For example, see the [BLEU metric card](https://github.com/huggingface/evaluate/tree/main/metrics/bleu) or [SQuaD metric card](https://github.com/huggingface/evaluate/tree/main/metrics/squad).\n- **Looking at papers and blog posts** published on the topic and see what metrics they report. This can change over time, so try to pick papers from the last couple of years!\n\n### Dataset-specific metrics\n\nSome datasets have specific metrics associated with them -- this is especially in the case of popular benchmarks like [GLUE](https://huggingface.co/metrics/glue) and [SQuAD](https://huggingface.co/metrics/squad).\n\n<Tip warning={true}>\n\ud83d\udca1\nGLUE is actually a collection of different subsets on different tasks, so first you need to choose the one that corresponds to the NLI task, such as mnli, which is described as \u201ccrowdsourced collection of sentence pairs with textual entailment annotations\u201d\n</Tip>"
            }
        ]
    },
    {
        "sample_idx": 11,
        "question": "What are some examples of generic metrics?",
        "answer": "Accuracy, precision, and perplexity are examples of generic metrics.",
        "rag_answer": "Some examples of generic metrics are accuracy, precision, and perplexity.",
        "rag_score": 5,
        "rag_feedback": "The system's response is completely correct, accurate, and factual. It provides the exact examples of generic metrics mentioned in the expected answer, which are accuracy, precision, and perplexity.",
        "rag_context": [
            {
                "score": 0.8857661395475317,
                "node_text": "Here are some facts extracted from the provided text:\n\nGeneric metrics -> Can be applied to -> Variety of situations\nAccuracy -> Is -> Generic metric\nPerplexity -> Is -> Generic metric\nPrecision -> Is -> Generic metric\nBleu -> Is -> Task-specific metric\nMetric -> Is -> Evaluation metric\n\nChoosing a metric for your task\n\n**So you've trained your model and want to see how well it\u2019s doing on a dataset of your choice. Where do you start?**\n\nThere is no \u201cone size fits all\u201d approach to choosing an evaluation metric, but some good guidelines to keep in mind are:\n\n## Categories of metrics\n\nThere are 3 high-level categories of metrics:\n\n1. *Generic metrics*, which can be applied to a variety of situations and datasets, such as precision and accuracy.\n2. *Task-specific metrics*, which are limited to a given task, such as Machine Translation (often evaluated using metrics [BLEU](https://huggingface.co/metrics/bleu) or [ROUGE](https://huggingface.co/metrics/rouge)) or Named Entity Recognition (often evaluated with [seqeval](https://huggingface.co/metrics/seqeval)).\n3. *Dataset-specific metrics*, which aim to measure model performance on specific benchmarks: for instance, the [GLUE benchmark](https://huggingface.co/datasets/glue) has a dedicated [evaluation metric](https://huggingface.co/metrics/glue).\n\nLet's look at each of these three cases:\n\n### Generic metrics\n\nMany of the metrics used in the Machine Learning community are quite generic and can be applied in a variety of tasks and datasets.\n\nThis is the case for metrics like [accuracy](https://huggingface.co/metrics/accuracy) and [precision](https://huggingface.co/metrics/precision), which can be used for evaluating labeled (supervised) datasets, as well as [perplexity](https://huggingface.co/metrics/perplexity), which can be used for evaluating different kinds of (unsupervised) generative tasks.\n\nTo see the input structure of a given metric, you can look at its metric card. For example, in the case of [precision](https://huggingface.co/metrics/precision), the format is:\n```\n>>> precision_metric = evaluate.load(\"precision\")\n>>> results = precision_metric.compute(references=[0, 1], predictions=[0, 1])\n>>> print(results)\n{'precision': 1.0}\n```\n\n### Task-specific metrics\n\nPopular ML tasks like Machine Translation and Named Entity Recognition have specific metrics that can be used to compare models. For example, a series of different metrics have been proposed for text generation, ranging from [BLEU](https://huggingface.co/metrics/bleu) and its derivatives such as [GoogleBLEU](https://huggingface.co/metrics/google_bleu) and [GLEU](https://huggingface.co/metrics/gleu), but also [ROUGE](https://huggingface.co/metrics/rouge), [MAUVE](https://huggingface.co/metrics/mauve), etc.\n\nYou can find the right metric for your task by:\n\n- **Looking at the [Task pages](https://huggingface.co/tasks)** to see what metrics can be used for evaluating models for a given task.\n- **Checking out leaderboards** on sites like [Papers With Code](https://paperswithcode.com/) (you can search by task and by dataset).\n-  **Reading the metric cards** for the relevant metrics and see which ones are a good fit for your use case. For example, see the [BLEU metric card](https://github.com/huggingface/evaluate/tree/main/metrics/bleu) or [SQuaD metric card](https://github.com/huggingface/evaluate/tree/main/metrics/squad).\n- **Looking at papers and blog posts** published on the topic and see what metrics they report. This can change over time, so try to pick papers from the last couple of years!\n\n### Dataset-specific metrics\n\nSome datasets have specific metrics associated with them -- this is especially in the case of popular benchmarks like [GLUE](https://huggingface.co/metrics/glue) and [SQuAD](https://huggingface.co/metrics/squad).\n\n<Tip warning={true}>\n\ud83d\udca1\nGLUE is actually a collection of different subsets on different tasks, so first you need to choose the one that corresponds to the NLI task, such as mnli, which is described as \u201ccrowdsourced collection of sentence pairs with textual entailment annotations\u201d\n</Tip>"
            }
        ]
    },
    {
        "sample_idx": 12,
        "question": "What type of tasks can accuracy and precision be used for?",
        "answer": "Accuracy and precision can be used for evaluating labeled (supervised) datasets.",
        "rag_answer": "Accuracy and precision can be used for evaluating labeled (supervised) datasets.",
        "rag_score": 5,
        "rag_feedback": "The system's response is completely correct, accurate, and factual. It exactly matches the expected answer, stating that accuracy and precision can be used for evaluating labeled (supervised) datasets.",
        "rag_context": [
            {
                "score": 1.0,
                "node_text": "Here are some facts extracted from the provided text:\n\nPrecision -> Is -> Generic metric\n\nChoosing a metric for your task\n\n**So you've trained your model and want to see how well it\u2019s doing on a dataset of your choice. Where do you start?**\n\nThere is no \u201cone size fits all\u201d approach to choosing an evaluation metric, but some good guidelines to keep in mind are:\n\n## Categories of metrics\n\nThere are 3 high-level categories of metrics:\n\n1. *Generic metrics*, which can be applied to a variety of situations and datasets, such as precision and accuracy.\n2. *Task-specific metrics*, which are limited to a given task, such as Machine Translation (often evaluated using metrics [BLEU](https://huggingface.co/metrics/bleu) or [ROUGE](https://huggingface.co/metrics/rouge)) or Named Entity Recognition (often evaluated with [seqeval](https://huggingface.co/metrics/seqeval)).\n3. *Dataset-specific metrics*, which aim to measure model performance on specific benchmarks: for instance, the [GLUE benchmark](https://huggingface.co/datasets/glue) has a dedicated [evaluation metric](https://huggingface.co/metrics/glue).\n\nLet's look at each of these three cases:\n\n### Generic metrics\n\nMany of the metrics used in the Machine Learning community are quite generic and can be applied in a variety of tasks and datasets.\n\nThis is the case for metrics like [accuracy](https://huggingface.co/metrics/accuracy) and [precision](https://huggingface.co/metrics/precision), which can be used for evaluating labeled (supervised) datasets, as well as [perplexity](https://huggingface.co/metrics/perplexity), which can be used for evaluating different kinds of (unsupervised) generative tasks.\n\nTo see the input structure of a given metric, you can look at its metric card. For example, in the case of [precision](https://huggingface.co/metrics/precision), the format is:\n```\n>>> precision_metric = evaluate.load(\"precision\")\n>>> results = precision_metric.compute(references=[0, 1], predictions=[0, 1])\n>>> print(results)\n{'precision': 1.0}\n```\n\n### Task-specific metrics\n\nPopular ML tasks like Machine Translation and Named Entity Recognition have specific metrics that can be used to compare models. For example, a series of different metrics have been proposed for text generation, ranging from [BLEU](https://huggingface.co/metrics/bleu) and its derivatives such as [GoogleBLEU](https://huggingface.co/metrics/google_bleu) and [GLEU](https://huggingface.co/metrics/gleu), but also [ROUGE](https://huggingface.co/metrics/rouge), [MAUVE](https://huggingface.co/metrics/mauve), etc.\n\nYou can find the right metric for your task by:\n\n- **Looking at the [Task pages](https://huggingface.co/tasks)** to see what metrics can be used for evaluating models for a given task.\n- **Checking out leaderboards** on sites like [Papers With Code](https://paperswithcode.com/) (you can search by task and by dataset).\n-  **Reading the metric cards** for the relevant metrics and see which ones are a good fit for your use case. For example, see the [BLEU metric card](https://github.com/huggingface/evaluate/tree/main/metrics/bleu) or [SQuaD metric card](https://github.com/huggingface/evaluate/tree/main/metrics/squad).\n- **Looking at papers and blog posts** published on the topic and see what metrics they report. This can change over time, so try to pick papers from the last couple of years!\n\n### Dataset-specific metrics\n\nSome datasets have specific metrics associated with them -- this is especially in the case of popular benchmarks like [GLUE](https://huggingface.co/metrics/glue) and [SQuAD](https://huggingface.co/metrics/squad).\n\n<Tip warning={true}>\n\ud83d\udca1\nGLUE is actually a collection of different subsets on different tasks, so first you need to choose the one that corresponds to the NLI task, such as mnli, which is described as \u201ccrowdsourced collection of sentence pairs with textual entailment annotations\u201d\n</Tip>"
            },
            {
                "score": 0.6261251353058274,
                "node_text": "Here are some facts extracted from the provided text:\n\nBleu -> Is -> Task-specific metric\nPrecision -> Is -> Generic metric\nAccuracy -> Is -> Generic metric\n\nChoosing a metric for your task\n\n**So you've trained your model and want to see how well it\u2019s doing on a dataset of your choice. Where do you start?**\n\nThere is no \u201cone size fits all\u201d approach to choosing an evaluation metric, but some good guidelines to keep in mind are:\n\n## Categories of metrics\n\nThere are 3 high-level categories of metrics:\n\n1. *Generic metrics*, which can be applied to a variety of situations and datasets, such as precision and accuracy.\n2. *Task-specific metrics*, which are limited to a given task, such as Machine Translation (often evaluated using metrics [BLEU](https://huggingface.co/metrics/bleu) or [ROUGE](https://huggingface.co/metrics/rouge)) or Named Entity Recognition (often evaluated with [seqeval](https://huggingface.co/metrics/seqeval)).\n3. *Dataset-specific metrics*, which aim to measure model performance on specific benchmarks: for instance, the [GLUE benchmark](https://huggingface.co/datasets/glue) has a dedicated [evaluation metric](https://huggingface.co/metrics/glue).\n\nLet's look at each of these three cases:\n\n### Generic metrics\n\nMany of the metrics used in the Machine Learning community are quite generic and can be applied in a variety of tasks and datasets.\n\nThis is the case for metrics like [accuracy](https://huggingface.co/metrics/accuracy) and [precision](https://huggingface.co/metrics/precision), which can be used for evaluating labeled (supervised) datasets, as well as [perplexity](https://huggingface.co/metrics/perplexity), which can be used for evaluating different kinds of (unsupervised) generative tasks.\n\nTo see the input structure of a given metric, you can look at its metric card. For example, in the case of [precision](https://huggingface.co/metrics/precision), the format is:\n```\n>>> precision_metric = evaluate.load(\"precision\")\n>>> results = precision_metric.compute(references=[0, 1], predictions=[0, 1])\n>>> print(results)\n{'precision': 1.0}\n```\n\n### Task-specific metrics\n\nPopular ML tasks like Machine Translation and Named Entity Recognition have specific metrics that can be used to compare models. For example, a series of different metrics have been proposed for text generation, ranging from [BLEU](https://huggingface.co/metrics/bleu) and its derivatives such as [GoogleBLEU](https://huggingface.co/metrics/google_bleu) and [GLEU](https://huggingface.co/metrics/gleu), but also [ROUGE](https://huggingface.co/metrics/rouge), [MAUVE](https://huggingface.co/metrics/mauve), etc.\n\nYou can find the right metric for your task by:\n\n- **Looking at the [Task pages](https://huggingface.co/tasks)** to see what metrics can be used for evaluating models for a given task.\n- **Checking out leaderboards** on sites like [Papers With Code](https://paperswithcode.com/) (you can search by task and by dataset).\n-  **Reading the metric cards** for the relevant metrics and see which ones are a good fit for your use case. For example, see the [BLEU metric card](https://github.com/huggingface/evaluate/tree/main/metrics/bleu) or [SQuaD metric card](https://github.com/huggingface/evaluate/tree/main/metrics/squad).\n- **Looking at papers and blog posts** published on the topic and see what metrics they report. This can change over time, so try to pick papers from the last couple of years!\n\n### Dataset-specific metrics\n\nSome datasets have specific metrics associated with them -- this is especially in the case of popular benchmarks like [GLUE](https://huggingface.co/metrics/glue) and [SQuAD](https://huggingface.co/metrics/squad).\n\n<Tip warning={true}>\n\ud83d\udca1\nGLUE is actually a collection of different subsets on different tasks, so first you need to choose the one that corresponds to the NLI task, such as mnli, which is described as \u201ccrowdsourced collection of sentence pairs with textual entailment annotations\u201d\n</Tip>"
            },
            {
                "score": 0.5096290479934853,
                "node_text": "Here are some facts extracted from the provided text:\n\nQueue -> Controls -> Processing rate\n\nBlocks() as demo\uff1a\n    #.\ndemo.queue()\ndemo.launch()\n```\n\n\u60a8\u53ef\u4ee5\u901a\u8fc7\u4ee5\u4e0b\u65b9\u5f0f\u63a7\u5236\u4e00\u6b21\u5904\u7406\u7684\u8bf7\u6c42\u6570\u91cf\uff1a\n\n```python\ndemo.queue(concurrency_count=3)\n```\n\n\u67e5\u770b\u6709\u5173\u914d\u7f6e\u5176\u4ed6\u961f\u5217\u53c2\u6570\u7684[\u961f\u5217\u6587\u6863](/docs/#queue)\u3002\n\n\u5728 Blocks \u4e2d\u6307\u5b9a\u4ec5\u5bf9\u67d0\u4e9b\u51fd\u6570\u8fdb\u884c\u6392\u961f\uff1a\n\n```python\nwith gr.Blocks() as demo2\uff1a\n    num1 = gr.Number()\n    num2 = gr.Number()\n    output = gr.Number()\n    gr.Button(\"Add\").click(\n        lambda a, b: a + b, [num1, num2], output)\n    gr.Button(\"Multiply\").click(\n        lambda a, b: a * b, [num1, num2], output, queue=True)\ndemo2.launch()\n```\n\n## \u8fed\u4ee3\u8f93\u51fa (Iterative Outputs)\n\n\u5728\u67d0\u4e9b\u60c5\u51b5\u4e0b\uff0c\u60a8\u53ef\u80fd\u9700\u8981\u4f20\u8f93\u4e00\u7cfb\u5217\u8f93\u51fa\u800c\u4e0d\u662f\u4e00\u6b21\u663e\u793a\u5355\u4e2a\u8f93\u51fa\u3002\u4f8b\u5982\uff0c\u60a8\u53ef\u80fd\u6709\u4e00\u4e2a\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5e0c\u671b\u663e\u793a\u751f\u6210\u7684\u6bcf\u4e2a\u6b65\u9aa4\u7684\u56fe\u50cf\uff0c\u76f4\u5230\u6700\u7ec8\u56fe\u50cf\u3002\u6216\u8005\u60a8\u53ef\u80fd\u6709\u4e00\u4e2a\u804a\u5929\u673a\u5668\u4eba\uff0c\u5b83\u9010\u5b57\u9010\u53e5\u5730\u6d41\u5f0f\u4f20\u8f93\u54cd\u5e94\uff0c\u800c\u4e0d\u662f\u4e00\u6b21\u8fd4\u56de\u5168\u90e8\u54cd\u5e94\u3002\n\n\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u60a8\u53ef\u4ee5\u5c06**\u751f\u6210\u5668**\u51fd\u6570\u63d0\u4f9b\u7ed9 Gradio\uff0c\u800c\u4e0d\u662f\u5e38\u89c4\u51fd\u6570\u3002\u5728 Python \u4e2d\u521b\u5efa\u751f\u6210\u5668\u975e\u5e38\u7b80\u5355\uff1a\u51fd\u6570\u4e0d\u5e94\u8be5\u6709\u4e00\u4e2a\u5355\u72ec\u7684 `return` \u503c\uff0c\u800c\u662f\u5e94\u8be5 with `yield` \u8fde\u7eed\u8fd4\u56de\u4e00\u7cfb\u5217\u503c\u3002\u901a\u5e38\uff0c`yield` \u8bed\u53e5\u653e\u7f6e\u5728\u67d0\u79cd\u5faa\u73af\u4e2d\u3002\u4e0b\u9762\u662f\u4e00\u4e2a\u7b80\u5355\u793a\u4f8b\uff0c\u751f\u6210\u5668\u53ea\u662f\u7b80\u5355\u8ba1\u6570\u5230\u7ed9\u5b9a\u6570\u5b57\uff1a\n\n```python\ndef my_generator(x):\n    for i in range(x):\n        yield i\n```\n\n\u60a8\u4ee5\u4e0e\u5e38\u89c4\u51fd\u6570\u76f8\u540c\u7684\u65b9\u5f0f\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio\u3002\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\uff08\u865a\u62df\u7684\uff09\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5b83\u5728\u8f93\u51fa\u56fe\u50cf\u4e4b\u524d\u751f\u6210\u6570\u4e2a\u6b65\u9aa4\u7684\u566a\u97f3\uff1a\n\n$code_fake_diffusion\n$demo_fake_diffusion\n\n\u8bf7\u6ce8\u610f\uff0c\u6211\u4eec\u5728\u8fed\u4ee3\u5668\u4e2d\u6dfb\u52a0\u4e86 `time.sleep(1)`\uff0c\u4ee5\u521b\u5efa\u6b65\u9aa4\u4e4b\u95f4\u7684\u4eba\u5de5\u6682\u505c\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u89c2\u5bdf\u8fed\u4ee3\u5668\u7684\u6b65\u9aa4\uff08\u5728\u771f\u5b9e\u7684\u56fe\u50cf\u751f\u6210\u6a21\u578b\u4e2d\uff0c\u8fd9\u53ef\u80fd\u662f\u4e0d\u5fc5\u8981\u7684\uff09\u3002\n\n\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio **\u9700\u8981**\u5728\u5e95\u5c42 Interface \u6216 Blocks \u4e2d\u542f\u7528\u961f\u5217\uff08\u8bf7\u53c2\u9605\u4e0a\u9762\u7684\u961f\u5217\u90e8\u5206\uff09\u3002\n\n## \u8fdb\u5ea6\u6761\n\nGradio \u652f\u6301\u521b\u5efa\u81ea\u5b9a\u4e49\u8fdb\u5ea6\u6761\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u81ea\u5b9a\u4e49\u548c\u63a7\u5236\u5411\u7528\u6237\u663e\u793a\u7684\u8fdb\u5ea6\u66f4\u65b0\u3002\u8981\u542f\u7528\u6b64\u529f\u80fd\uff0c\u53ea\u9700\u4e3a\u65b9\u6cd5\u6dfb\u52a0\u4e00\u4e2a\u9ed8\u8ba4\u503c\u4e3a `gr.Progress` \u5b9e\u4f8b\u7684\u53c2\u6570\u5373\u53ef\u3002\u7136\u540e\uff0c\u60a8\u53ef\u4ee5\u76f4\u63a5\u8c03\u7528\u6b64\u5b9e\u4f8b\u5e76\u4f20\u5165 0 \u5230 1 \u4e4b\u95f4\u7684\u6d6e\u70b9\u6570\u6765\u66f4\u65b0\u8fdb\u5ea6\u7ea7\u522b\uff0c\u6216\u8005 with `Progress` \u5b9e\u4f8b\u7684 `tqdm()` \u65b9\u6cd5\u6765\u8ddf\u8e2a\u53ef\u8fed\u4ee3\u5bf9\u8c61\u4e0a\u7684\u8fdb\u5ea6\uff0c\u5982\u4e0b\u6240\u793a\u3002\u5fc5\u987b\u542f\u7528\u961f\u5217\u4ee5\u8fdb\u884c\u8fdb\u5ea6\u66f4\u65b0\u3002\n\n$code_progress_simple\n$demo_progress_simple\n\n\u5982\u679c\u60a8 with `tqdm` \u5e93\uff0c\u5e76\u4e14\u5e0c\u671b\u4ece\u51fd\u6570\u5185\u90e8\u7684\u4efb\u4f55 `tqdm.tqdm` \u81ea\u52a8\u62a5\u544a\u8fdb\u5ea6\u66f4\u65b0\uff0c\u8bf7\u5c06\u9ed8\u8ba4\u53c2\u6570\u8bbe\u7f6e\u4e3a `gr.Progress(track_tqdm=True)`\uff01\n\n## \u6279\u5904\u7406\u51fd\u6570 (Batch Functions)\n\nGradio \u652f\u6301\u4f20\u9012*\u6279\u5904\u7406*\u51fd\u6570\u3002\u6279\u5904\u7406\u51fd\u6570\u53ea\u662f\u63a5\u53d7\u8f93\u5165\u5217\u8868\u5e76\u8fd4\u56de\u9884\u6d4b\u5217\u8868\u7684\u51fd\u6570\u3002\n\n\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\u6279\u5904\u7406\u51fd\u6570\uff0c\u5b83\u63a5\u53d7\u4e24\u4e2a\u8f93\u5165\u5217\u8868\uff08\u4e00\u4e2a\u5355\u8bcd\u5217\u8868\u548c\u4e00\u4e2a\u6574\u6570\u5217\u8868\uff09\uff0c\u5e76\u8fd4\u56de\u4fee\u526a\u8fc7\u7684\u5355\u8bcd\u5217\u8868\u4f5c\u4e3a\u8f93\u51fa\uff1a\n\n```python\nimport time\n\ndef trim_words(words, lens):\n    trimmed_words = []\n    time.sleep(5)\n    for w, l in zip(words, lens):\n        trimmed_words.append(w[:int(l)])\n    return [trimmed_words]\n    for w, l in zip(words,"
            }
        ]
    },
    {
        "sample_idx": 13,
        "question": "What type of tasks can perplexity be used for?",
        "answer": "Perplexity can be used for evaluating different kinds of (unsupervised) generative tasks.",
        "rag_answer": "Perplexity can be used for evaluating different kinds of unsupervised generative tasks.",
        "rag_score": 5,
        "rag_feedback": "The system's response is completely correct, accurate, and factual. It exactly matches the expected answer, stating that perplexity can be used for evaluating different kinds of unsupervised generative tasks.",
        "rag_context": [
            {
                "score": 0.6887583243356593,
                "node_text": "Here are some facts extracted from the provided text:\n\nPerplexity -> Is -> Generic metric\nBleu -> Is -> Task-specific metric\nGlue benchmark -> Has -> Dedicated evaluation metric\n\nChoosing a metric for your task\n\n**So you've trained your model and want to see how well it\u2019s doing on a dataset of your choice. Where do you start?**\n\nThere is no \u201cone size fits all\u201d approach to choosing an evaluation metric, but some good guidelines to keep in mind are:\n\n## Categories of metrics\n\nThere are 3 high-level categories of metrics:\n\n1. *Generic metrics*, which can be applied to a variety of situations and datasets, such as precision and accuracy.\n2. *Task-specific metrics*, which are limited to a given task, such as Machine Translation (often evaluated using metrics [BLEU](https://huggingface.co/metrics/bleu) or [ROUGE](https://huggingface.co/metrics/rouge)) or Named Entity Recognition (often evaluated with [seqeval](https://huggingface.co/metrics/seqeval)).\n3. *Dataset-specific metrics*, which aim to measure model performance on specific benchmarks: for instance, the [GLUE benchmark](https://huggingface.co/datasets/glue) has a dedicated [evaluation metric](https://huggingface.co/metrics/glue).\n\nLet's look at each of these three cases:\n\n### Generic metrics\n\nMany of the metrics used in the Machine Learning community are quite generic and can be applied in a variety of tasks and datasets.\n\nThis is the case for metrics like [accuracy](https://huggingface.co/metrics/accuracy) and [precision](https://huggingface.co/metrics/precision), which can be used for evaluating labeled (supervised) datasets, as well as [perplexity](https://huggingface.co/metrics/perplexity), which can be used for evaluating different kinds of (unsupervised) generative tasks.\n\nTo see the input structure of a given metric, you can look at its metric card. For example, in the case of [precision](https://huggingface.co/metrics/precision), the format is:\n```\n>>> precision_metric = evaluate.load(\"precision\")\n>>> results = precision_metric.compute(references=[0, 1], predictions=[0, 1])\n>>> print(results)\n{'precision': 1.0}\n```\n\n### Task-specific metrics\n\nPopular ML tasks like Machine Translation and Named Entity Recognition have specific metrics that can be used to compare models. For example, a series of different metrics have been proposed for text generation, ranging from [BLEU](https://huggingface.co/metrics/bleu) and its derivatives such as [GoogleBLEU](https://huggingface.co/metrics/google_bleu) and [GLEU](https://huggingface.co/metrics/gleu), but also [ROUGE](https://huggingface.co/metrics/rouge), [MAUVE](https://huggingface.co/metrics/mauve), etc.\n\nYou can find the right metric for your task by:\n\n- **Looking at the [Task pages](https://huggingface.co/tasks)** to see what metrics can be used for evaluating models for a given task.\n- **Checking out leaderboards** on sites like [Papers With Code](https://paperswithcode.com/) (you can search by task and by dataset).\n-  **Reading the metric cards** for the relevant metrics and see which ones are a good fit for your use case. For example, see the [BLEU metric card](https://github.com/huggingface/evaluate/tree/main/metrics/bleu) or [SQuaD metric card](https://github.com/huggingface/evaluate/tree/main/metrics/squad).\n- **Looking at papers and blog posts** published on the topic and see what metrics they report. This can change over time, so try to pick papers from the last couple of years!\n\n### Dataset-specific metrics\n\nSome datasets have specific metrics associated with them -- this is especially in the case of popular benchmarks like [GLUE](https://huggingface.co/metrics/glue) and [SQuAD](https://huggingface.co/metrics/squad).\n\n<Tip warning={true}>\n\ud83d\udca1\nGLUE is actually a collection of different subsets on different tasks, so first you need to choose the one that corresponds to the NLI task, such as mnli, which is described as \u201ccrowdsourced collection of sentence pairs with textual entailment annotations\u201d\n</Tip>"
            },
            {
                "score": 0.5323282957541862,
                "node_text": "Here are some facts extracted from the provided text:\n\nTpu -> Is -> Tensor processing unit\n\nThis is a really useful trick, so remember it if you need to convert your own code to XLA!\n\n#### XLA Rule #3: XLA will need to recompile your model for every different input shape it sees\n\nThis is the big one. What this means is that if your input shapes are very variable, XLA will have to recompile your model over and over, which will create huge performance problems. This commonly arises in NLP models, where input texts have variable lengths after tokenization. In other modalities, static shapes are more common and this rule is much less of a problem.\n\nHow can you get around rule #3? The key is **padding** - if you pad all your inputs to the same length, and then use an `attention_mask`, you can get the same results as you\u2019d get from variable shapes, but without any XLA issues. However, excessive padding can cause severe slowdown too - if you pad all your samples to the maximum length in the whole dataset, you might end up with batches consisting endless padding tokens, which will waste a lot of compute and memory!\n\nThere isn\u2019t a perfect solution to this problem. However, you can try some tricks. One very useful trick is to **pad batches of samples up to a multiple of a number like 32 or 64 tokens.** This often only increases the number of tokens by a small amount, but it hugely reduces the number of unique input shapes, because every input shape now has to be a multiple of 32 or 64. Fewer unique input shapes means fewer XLA compilations!\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** Our tokenizers and data collators have methods that can help you here. You can use `padding=\"max_length\"` or `padding=\"longest\"` when calling tokenizers to get them to output padded data. Our tokenizers and data collators also have a `pad_to_multiple_of` argument that you can use to reduce the number of unique input shapes you see!\n\n</Tip>\n\n### How do I actually train my model on TPU?\n\nOnce your training is XLA-compatible and (if you\u2019re using TPU Node / Colab) your dataset has been prepared appropriately, running on TPU is surprisingly easy! All you really need to change in your code is to add a few lines to initialize your TPU, and to ensure that your model and dataset are created inside a `TPUStrategy` scope. Take a look at [our TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) to see this in action!\n\n### Summary\n\nThere was a lot in here, so let\u2019s summarize with a quick checklist you can follow when you want to get your model ready for TPU training:\n\n- Make sure your code follows the three rules of XLA\n- Compile your model with `jit_compile=True` on CPU/GPU and confirm that you can train it with XLA\n- Either load your dataset into memory or use a TPU-compatible dataset loading approach (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Migrate your code either to Colab (with accelerator set to \u201cTPU\u201d) or a TPU VM on Google Cloud\n- Add TPU initializer code (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Create your `TPUStrategy` and make sure dataset loading and model creation are inside the `strategy.scope()` (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Don\u2019t forget to take `jit_compile=True` out again when you move to TPU!\n- \ud83d\ude4f\ud83d\ude4f\ud83d\ude4f\ud83e\udd7a\ud83e\udd7a\ud83e\udd7a\n- Call model.fit()\n- You did it!"
            }
        ]
    },
    {
        "sample_idx": 14,
        "question": "What is the name of the metric used for evaluating models in Machine Translation and Named Entity Recognition tasks?",
        "answer": "Metrics such as BLEU, GoogleBLEU, GLEU, ROUGE, and MAUVE are used for evaluating models in Machine Translation and Named Entity Recognition tasks.",
        "rag_answer": "The names of the metrics used for evaluating models in Machine Translation and Named Entity Recognition tasks are BLEU and ROUGE for Machine Translation, and seqeval for Named Entity Recognition.",
        "rag_score": 4,
        "rag_feedback": "The system's response is mostly correct, accurate, and factual. It correctly identifies BLEU and ROUGE as metrics used for evaluating models in Machine Translation, and seqeval for Named Entity Recognition. However, it does not mention other metrics such as GoogleBLEU, GLEU, and MAUVE, which are also used for evaluating models in Machine Translation and Named Entity Recognition tasks.",
        "rag_context": [
            {
                "score": 1.0,
                "node_text": "Here are some facts extracted from the provided text:\n\nMachine translation -> Evaluated using -> Rouge\nBleu -> Is -> Task-specific metric\nMachine translation -> Evaluated using -> Bleu\n\nChoosing a metric for your task\n\n**So you've trained your model and want to see how well it\u2019s doing on a dataset of your choice. Where do you start?**\n\nThere is no \u201cone size fits all\u201d approach to choosing an evaluation metric, but some good guidelines to keep in mind are:\n\n## Categories of metrics\n\nThere are 3 high-level categories of metrics:\n\n1. *Generic metrics*, which can be applied to a variety of situations and datasets, such as precision and accuracy.\n2. *Task-specific metrics*, which are limited to a given task, such as Machine Translation (often evaluated using metrics [BLEU](https://huggingface.co/metrics/bleu) or [ROUGE](https://huggingface.co/metrics/rouge)) or Named Entity Recognition (often evaluated with [seqeval](https://huggingface.co/metrics/seqeval)).\n3. *Dataset-specific metrics*, which aim to measure model performance on specific benchmarks: for instance, the [GLUE benchmark](https://huggingface.co/datasets/glue) has a dedicated [evaluation metric](https://huggingface.co/metrics/glue).\n\nLet's look at each of these three cases:\n\n### Generic metrics\n\nMany of the metrics used in the Machine Learning community are quite generic and can be applied in a variety of tasks and datasets.\n\nThis is the case for metrics like [accuracy](https://huggingface.co/metrics/accuracy) and [precision](https://huggingface.co/metrics/precision), which can be used for evaluating labeled (supervised) datasets, as well as [perplexity](https://huggingface.co/metrics/perplexity), which can be used for evaluating different kinds of (unsupervised) generative tasks.\n\nTo see the input structure of a given metric, you can look at its metric card. For example, in the case of [precision](https://huggingface.co/metrics/precision), the format is:\n```\n>>> precision_metric = evaluate.load(\"precision\")\n>>> results = precision_metric.compute(references=[0, 1], predictions=[0, 1])\n>>> print(results)\n{'precision': 1.0}\n```\n\n### Task-specific metrics\n\nPopular ML tasks like Machine Translation and Named Entity Recognition have specific metrics that can be used to compare models. For example, a series of different metrics have been proposed for text generation, ranging from [BLEU](https://huggingface.co/metrics/bleu) and its derivatives such as [GoogleBLEU](https://huggingface.co/metrics/google_bleu) and [GLEU](https://huggingface.co/metrics/gleu), but also [ROUGE](https://huggingface.co/metrics/rouge), [MAUVE](https://huggingface.co/metrics/mauve), etc.\n\nYou can find the right metric for your task by:\n\n- **Looking at the [Task pages](https://huggingface.co/tasks)** to see what metrics can be used for evaluating models for a given task.\n- **Checking out leaderboards** on sites like [Papers With Code](https://paperswithcode.com/) (you can search by task and by dataset).\n-  **Reading the metric cards** for the relevant metrics and see which ones are a good fit for your use case. For example, see the [BLEU metric card](https://github.com/huggingface/evaluate/tree/main/metrics/bleu) or [SQuaD metric card](https://github.com/huggingface/evaluate/tree/main/metrics/squad).\n- **Looking at papers and blog posts** published on the topic and see what metrics they report. This can change over time, so try to pick papers from the last couple of years!\n\n### Dataset-specific metrics\n\nSome datasets have specific metrics associated with them -- this is especially in the case of popular benchmarks like [GLUE](https://huggingface.co/metrics/glue) and [SQuAD](https://huggingface.co/metrics/squad).\n\n<Tip warning={true}>\n\ud83d\udca1\nGLUE is actually a collection of different subsets on different tasks, so first you need to choose the one that corresponds to the NLI task, such as mnli, which is described as \u201ccrowdsourced collection of sentence pairs with textual entailment annotations\u201d\n</Tip>"
            },
            {
                "score": 0.6640715003991724,
                "node_text": "Here are some facts extracted from the provided text:\n\nBleu -> Is -> Task-specific metric\nGlue benchmark -> Has -> Dedicated evaluation metric\nMetric -> Is -> Evaluation metric\nNamed entity recognition -> Evaluated with -> Seqeval\n\nChoosing a metric for your task\n\n**So you've trained your model and want to see how well it\u2019s doing on a dataset of your choice. Where do you start?**\n\nThere is no \u201cone size fits all\u201d approach to choosing an evaluation metric, but some good guidelines to keep in mind are:\n\n## Categories of metrics\n\nThere are 3 high-level categories of metrics:\n\n1. *Generic metrics*, which can be applied to a variety of situations and datasets, such as precision and accuracy.\n2. *Task-specific metrics*, which are limited to a given task, such as Machine Translation (often evaluated using metrics [BLEU](https://huggingface.co/metrics/bleu) or [ROUGE](https://huggingface.co/metrics/rouge)) or Named Entity Recognition (often evaluated with [seqeval](https://huggingface.co/metrics/seqeval)).\n3. *Dataset-specific metrics*, which aim to measure model performance on specific benchmarks: for instance, the [GLUE benchmark](https://huggingface.co/datasets/glue) has a dedicated [evaluation metric](https://huggingface.co/metrics/glue).\n\nLet's look at each of these three cases:\n\n### Generic metrics\n\nMany of the metrics used in the Machine Learning community are quite generic and can be applied in a variety of tasks and datasets.\n\nThis is the case for metrics like [accuracy](https://huggingface.co/metrics/accuracy) and [precision](https://huggingface.co/metrics/precision), which can be used for evaluating labeled (supervised) datasets, as well as [perplexity](https://huggingface.co/metrics/perplexity), which can be used for evaluating different kinds of (unsupervised) generative tasks.\n\nTo see the input structure of a given metric, you can look at its metric card. For example, in the case of [precision](https://huggingface.co/metrics/precision), the format is:\n```\n>>> precision_metric = evaluate.load(\"precision\")\n>>> results = precision_metric.compute(references=[0, 1], predictions=[0, 1])\n>>> print(results)\n{'precision': 1.0}\n```\n\n### Task-specific metrics\n\nPopular ML tasks like Machine Translation and Named Entity Recognition have specific metrics that can be used to compare models. For example, a series of different metrics have been proposed for text generation, ranging from [BLEU](https://huggingface.co/metrics/bleu) and its derivatives such as [GoogleBLEU](https://huggingface.co/metrics/google_bleu) and [GLEU](https://huggingface.co/metrics/gleu), but also [ROUGE](https://huggingface.co/metrics/rouge), [MAUVE](https://huggingface.co/metrics/mauve), etc.\n\nYou can find the right metric for your task by:\n\n- **Looking at the [Task pages](https://huggingface.co/tasks)** to see what metrics can be used for evaluating models for a given task.\n- **Checking out leaderboards** on sites like [Papers With Code](https://paperswithcode.com/) (you can search by task and by dataset).\n-  **Reading the metric cards** for the relevant metrics and see which ones are a good fit for your use case. For example, see the [BLEU metric card](https://github.com/huggingface/evaluate/tree/main/metrics/bleu) or [SQuaD metric card](https://github.com/huggingface/evaluate/tree/main/metrics/squad).\n- **Looking at papers and blog posts** published on the topic and see what metrics they report. This can change over time, so try to pick papers from the last couple of years!\n\n### Dataset-specific metrics\n\nSome datasets have specific metrics associated with them -- this is especially in the case of popular benchmarks like [GLUE](https://huggingface.co/metrics/glue) and [SQuAD](https://huggingface.co/metrics/squad).\n\n<Tip warning={true}>\n\ud83d\udca1\nGLUE is actually a collection of different subsets on different tasks, so first you need to choose the one that corresponds to the NLI task, such as mnli, which is described as \u201ccrowdsourced collection of sentence pairs with textual entailment annotations\u201d\n</Tip>"
            },
            {
                "score": 0.6404157445297284,
                "node_text": "Here are some facts extracted from the provided text:\n\nSquad -> Has -> Evaluation metric\nEvaluation metric -> Requires -> Format\n\nIf you are evaluating your model on a benchmark dataset like the ones mentioned above, you can use its dedicated evaluation metric. Make sure you respect the format that they require. For example, to evaluate your model on the [SQuAD](https://huggingface.co/datasets/squad) dataset, you need to feed the `question` and `context` into your model and return the `prediction_text`, which should be compared with the `references` (based on matching the `id` of the question) :\n\n```\n>>> from evaluate import load\n>>> squad_metric = load(\"squad\")\n>>> predictions = [{'prediction_text': '1976', 'id': '56e10a3be3433e1400422b22'}]\n>>> references = [{'answers': {'answer_start': [97], 'text': ['1976']}, 'id': '56e10a3be3433e1400422b22'}]\n>>> results = squad_metric.compute(predictions=predictions, references=references)\n>>> results\n{'exact_match': 100.0, 'f1': 100.0}\n```\n\nYou can find examples of dataset structures by consulting the \"Dataset Preview\" function or the dataset card for a given dataset, and you can see how to use its dedicated evaluation function based on the metric card."
            }
        ]
    },
    {
        "sample_idx": 15,
        "question": "Where can I find the right metric for my task?",
        "answer": "You can find the right metric for your task by looking at the Task pages, checking out leaderboards, reading the metric cards, and looking at papers and blog posts published on the topic.",
        "rag_answer": "You can find the right metric for your task by looking at the Task pages to see what metrics can be used for evaluating models for a given task, checking out leaderboards on sites like Papers With Code, reading the metric cards for the relevant metrics, and looking at papers and blog posts published on the topic.",
        "rag_score": 5,
        "rag_feedback": "The system's response is completely correct, accurate, and factual. It provides a detailed and relevant answer to the question, matching the expected answer. The response is well-structured and easy to follow, and it provides additional information that is relevant to the topic.",
        "rag_context": [
            {
                "score": 1.0,
                "node_text": "Here are some facts extracted from the provided text:\n\nMetric -> Is -> Evaluation metric\n\nChoosing a metric for your task\n\n**So you've trained your model and want to see how well it\u2019s doing on a dataset of your choice. Where do you start?**\n\nThere is no \u201cone size fits all\u201d approach to choosing an evaluation metric, but some good guidelines to keep in mind are:\n\n## Categories of metrics\n\nThere are 3 high-level categories of metrics:\n\n1. *Generic metrics*, which can be applied to a variety of situations and datasets, such as precision and accuracy.\n2. *Task-specific metrics*, which are limited to a given task, such as Machine Translation (often evaluated using metrics [BLEU](https://huggingface.co/metrics/bleu) or [ROUGE](https://huggingface.co/metrics/rouge)) or Named Entity Recognition (often evaluated with [seqeval](https://huggingface.co/metrics/seqeval)).\n3. *Dataset-specific metrics*, which aim to measure model performance on specific benchmarks: for instance, the [GLUE benchmark](https://huggingface.co/datasets/glue) has a dedicated [evaluation metric](https://huggingface.co/metrics/glue).\n\nLet's look at each of these three cases:\n\n### Generic metrics\n\nMany of the metrics used in the Machine Learning community are quite generic and can be applied in a variety of tasks and datasets.\n\nThis is the case for metrics like [accuracy](https://huggingface.co/metrics/accuracy) and [precision](https://huggingface.co/metrics/precision), which can be used for evaluating labeled (supervised) datasets, as well as [perplexity](https://huggingface.co/metrics/perplexity), which can be used for evaluating different kinds of (unsupervised) generative tasks.\n\nTo see the input structure of a given metric, you can look at its metric card. For example, in the case of [precision](https://huggingface.co/metrics/precision), the format is:\n```\n>>> precision_metric = evaluate.load(\"precision\")\n>>> results = precision_metric.compute(references=[0, 1], predictions=[0, 1])\n>>> print(results)\n{'precision': 1.0}\n```\n\n### Task-specific metrics\n\nPopular ML tasks like Machine Translation and Named Entity Recognition have specific metrics that can be used to compare models. For example, a series of different metrics have been proposed for text generation, ranging from [BLEU](https://huggingface.co/metrics/bleu) and its derivatives such as [GoogleBLEU](https://huggingface.co/metrics/google_bleu) and [GLEU](https://huggingface.co/metrics/gleu), but also [ROUGE](https://huggingface.co/metrics/rouge), [MAUVE](https://huggingface.co/metrics/mauve), etc.\n\nYou can find the right metric for your task by:\n\n- **Looking at the [Task pages](https://huggingface.co/tasks)** to see what metrics can be used for evaluating models for a given task.\n- **Checking out leaderboards** on sites like [Papers With Code](https://paperswithcode.com/) (you can search by task and by dataset).\n-  **Reading the metric cards** for the relevant metrics and see which ones are a good fit for your use case. For example, see the [BLEU metric card](https://github.com/huggingface/evaluate/tree/main/metrics/bleu) or [SQuaD metric card](https://github.com/huggingface/evaluate/tree/main/metrics/squad).\n- **Looking at papers and blog posts** published on the topic and see what metrics they report. This can change over time, so try to pick papers from the last couple of years!\n\n### Dataset-specific metrics\n\nSome datasets have specific metrics associated with them -- this is especially in the case of popular benchmarks like [GLUE](https://huggingface.co/metrics/glue) and [SQuAD](https://huggingface.co/metrics/squad).\n\n<Tip warning={true}>\n\ud83d\udca1\nGLUE is actually a collection of different subsets on different tasks, so first you need to choose the one that corresponds to the NLI task, such as mnli, which is described as \u201ccrowdsourced collection of sentence pairs with textual entailment annotations\u201d\n</Tip>"
            },
            {
                "score": 1.0,
                "node_text": "Here are some facts extracted from the provided text:\n\nSquad -> Has -> Evaluation metric\nEvaluation metric -> Requires -> Format\n\nIf you are evaluating your model on a benchmark dataset like the ones mentioned above, you can use its dedicated evaluation metric. Make sure you respect the format that they require. For example, to evaluate your model on the [SQuAD](https://huggingface.co/datasets/squad) dataset, you need to feed the `question` and `context` into your model and return the `prediction_text`, which should be compared with the `references` (based on matching the `id` of the question) :\n\n```\n>>> from evaluate import load\n>>> squad_metric = load(\"squad\")\n>>> predictions = [{'prediction_text': '1976', 'id': '56e10a3be3433e1400422b22'}]\n>>> references = [{'answers': {'answer_start': [97], 'text': ['1976']}, 'id': '56e10a3be3433e1400422b22'}]\n>>> results = squad_metric.compute(predictions=predictions, references=references)\n>>> results\n{'exact_match': 100.0, 'f1': 100.0}\n```\n\nYou can find examples of dataset structures by consulting the \"Dataset Preview\" function or the dataset card for a given dataset, and you can see how to use its dedicated evaluation function based on the metric card."
            },
            {
                "score": 0.7984254196034876,
                "node_text": "Here are some facts extracted from the provided text:\n\nBleu -> Is -> Task-specific metric\nGeneric metrics -> Can be applied to -> Variety of situations\nGlue benchmark -> Has -> Dedicated evaluation metric\nMetric -> Is -> Evaluation metric\n\nChoosing a metric for your task\n\n**So you've trained your model and want to see how well it\u2019s doing on a dataset of your choice. Where do you start?**\n\nThere is no \u201cone size fits all\u201d approach to choosing an evaluation metric, but some good guidelines to keep in mind are:\n\n## Categories of metrics\n\nThere are 3 high-level categories of metrics:\n\n1. *Generic metrics*, which can be applied to a variety of situations and datasets, such as precision and accuracy.\n2. *Task-specific metrics*, which are limited to a given task, such as Machine Translation (often evaluated using metrics [BLEU](https://huggingface.co/metrics/bleu) or [ROUGE](https://huggingface.co/metrics/rouge)) or Named Entity Recognition (often evaluated with [seqeval](https://huggingface.co/metrics/seqeval)).\n3. *Dataset-specific metrics*, which aim to measure model performance on specific benchmarks: for instance, the [GLUE benchmark](https://huggingface.co/datasets/glue) has a dedicated [evaluation metric](https://huggingface.co/metrics/glue).\n\nLet's look at each of these three cases:\n\n### Generic metrics\n\nMany of the metrics used in the Machine Learning community are quite generic and can be applied in a variety of tasks and datasets.\n\nThis is the case for metrics like [accuracy](https://huggingface.co/metrics/accuracy) and [precision](https://huggingface.co/metrics/precision), which can be used for evaluating labeled (supervised) datasets, as well as [perplexity](https://huggingface.co/metrics/perplexity), which can be used for evaluating different kinds of (unsupervised) generative tasks.\n\nTo see the input structure of a given metric, you can look at its metric card. For example, in the case of [precision](https://huggingface.co/metrics/precision), the format is:\n```\n>>> precision_metric = evaluate.load(\"precision\")\n>>> results = precision_metric.compute(references=[0, 1], predictions=[0, 1])\n>>> print(results)\n{'precision': 1.0}\n```\n\n### Task-specific metrics\n\nPopular ML tasks like Machine Translation and Named Entity Recognition have specific metrics that can be used to compare models. For example, a series of different metrics have been proposed for text generation, ranging from [BLEU](https://huggingface.co/metrics/bleu) and its derivatives such as [GoogleBLEU](https://huggingface.co/metrics/google_bleu) and [GLEU](https://huggingface.co/metrics/gleu), but also [ROUGE](https://huggingface.co/metrics/rouge), [MAUVE](https://huggingface.co/metrics/mauve), etc.\n\nYou can find the right metric for your task by:\n\n- **Looking at the [Task pages](https://huggingface.co/tasks)** to see what metrics can be used for evaluating models for a given task.\n- **Checking out leaderboards** on sites like [Papers With Code](https://paperswithcode.com/) (you can search by task and by dataset).\n-  **Reading the metric cards** for the relevant metrics and see which ones are a good fit for your use case. For example, see the [BLEU metric card](https://github.com/huggingface/evaluate/tree/main/metrics/bleu) or [SQuaD metric card](https://github.com/huggingface/evaluate/tree/main/metrics/squad).\n- **Looking at papers and blog posts** published on the topic and see what metrics they report. This can change over time, so try to pick papers from the last couple of years!\n\n### Dataset-specific metrics\n\nSome datasets have specific metrics associated with them -- this is especially in the case of popular benchmarks like [GLUE](https://huggingface.co/metrics/glue) and [SQuAD](https://huggingface.co/metrics/squad).\n\n<Tip warning={true}>\n\ud83d\udca1\nGLUE is actually a collection of different subsets on different tasks, so first you need to choose the one that corresponds to the NLI task, such as mnli, which is described as \u201ccrowdsourced collection of sentence pairs with textual entailment annotations\u201d\n</Tip>"
            }
        ]
    },
    {
        "sample_idx": 16,
        "question": "What is GLUE?",
        "answer": "GLUE is a collection of different subsets on different tasks.",
        "rag_answer": "GLUE is a collection of different subsets on different tasks, and it has a dedicated evaluation metric.",
        "rag_score": 4,
        "rag_feedback": "The system's response is mostly correct, accurate, and factual. It provides additional information about GLUE, including its evaluation metric, which is not present in the expected answer. However, the core information about GLUE being a collection of different subsets on different tasks is present in the response.",
        "rag_context": [
            {
                "score": 0.6971587180722213,
                "node_text": "Here are some facts extracted from the provided text:\n\nGlue benchmark -> Has -> Dedicated evaluation metric\nBleu -> Is -> Task-specific metric\nMachine translation -> Evaluated using -> Bleu\n\nChoosing a metric for your task\n\n**So you've trained your model and want to see how well it\u2019s doing on a dataset of your choice. Where do you start?**\n\nThere is no \u201cone size fits all\u201d approach to choosing an evaluation metric, but some good guidelines to keep in mind are:\n\n## Categories of metrics\n\nThere are 3 high-level categories of metrics:\n\n1. *Generic metrics*, which can be applied to a variety of situations and datasets, such as precision and accuracy.\n2. *Task-specific metrics*, which are limited to a given task, such as Machine Translation (often evaluated using metrics [BLEU](https://huggingface.co/metrics/bleu) or [ROUGE](https://huggingface.co/metrics/rouge)) or Named Entity Recognition (often evaluated with [seqeval](https://huggingface.co/metrics/seqeval)).\n3. *Dataset-specific metrics*, which aim to measure model performance on specific benchmarks: for instance, the [GLUE benchmark](https://huggingface.co/datasets/glue) has a dedicated [evaluation metric](https://huggingface.co/metrics/glue).\n\nLet's look at each of these three cases:\n\n### Generic metrics\n\nMany of the metrics used in the Machine Learning community are quite generic and can be applied in a variety of tasks and datasets.\n\nThis is the case for metrics like [accuracy](https://huggingface.co/metrics/accuracy) and [precision](https://huggingface.co/metrics/precision), which can be used for evaluating labeled (supervised) datasets, as well as [perplexity](https://huggingface.co/metrics/perplexity), which can be used for evaluating different kinds of (unsupervised) generative tasks.\n\nTo see the input structure of a given metric, you can look at its metric card. For example, in the case of [precision](https://huggingface.co/metrics/precision), the format is:\n```\n>>> precision_metric = evaluate.load(\"precision\")\n>>> results = precision_metric.compute(references=[0, 1], predictions=[0, 1])\n>>> print(results)\n{'precision': 1.0}\n```\n\n### Task-specific metrics\n\nPopular ML tasks like Machine Translation and Named Entity Recognition have specific metrics that can be used to compare models. For example, a series of different metrics have been proposed for text generation, ranging from [BLEU](https://huggingface.co/metrics/bleu) and its derivatives such as [GoogleBLEU](https://huggingface.co/metrics/google_bleu) and [GLEU](https://huggingface.co/metrics/gleu), but also [ROUGE](https://huggingface.co/metrics/rouge), [MAUVE](https://huggingface.co/metrics/mauve), etc.\n\nYou can find the right metric for your task by:\n\n- **Looking at the [Task pages](https://huggingface.co/tasks)** to see what metrics can be used for evaluating models for a given task.\n- **Checking out leaderboards** on sites like [Papers With Code](https://paperswithcode.com/) (you can search by task and by dataset).\n-  **Reading the metric cards** for the relevant metrics and see which ones are a good fit for your use case. For example, see the [BLEU metric card](https://github.com/huggingface/evaluate/tree/main/metrics/bleu) or [SQuaD metric card](https://github.com/huggingface/evaluate/tree/main/metrics/squad).\n- **Looking at papers and blog posts** published on the topic and see what metrics they report. This can change over time, so try to pick papers from the last couple of years!\n\n### Dataset-specific metrics\n\nSome datasets have specific metrics associated with them -- this is especially in the case of popular benchmarks like [GLUE](https://huggingface.co/metrics/glue) and [SQuAD](https://huggingface.co/metrics/squad).\n\n<Tip warning={true}>\n\ud83d\udca1\nGLUE is actually a collection of different subsets on different tasks, so first you need to choose the one that corresponds to the NLI task, such as mnli, which is described as \u201ccrowdsourced collection of sentence pairs with textual entailment annotations\u201d\n</Tip>"
            },
            {
                "score": 0.5059551633678128,
                "node_text": "Here are some facts extracted from the provided text:\n\nGoogle -> Designed -> Tpu\n\n!--Copyright 2023 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\nthe License. You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under the License is distributed on\nan \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n\n\u26a0\ufe0f Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be\nrendered properly in your Markdown viewer.\n\n-->\n\n# Training on TPU with TensorFlow\n\n<Tip>\n\nIf you don't need long explanations and just want TPU code samples to get started with, check out [our TPU example notebook!](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb)\n\n</Tip>\n\n### What is a TPU?\n\nA TPU is a **Tensor Processing Unit.** They are hardware designed by Google, which are used to greatly speed up the tensor computations within neural networks, much like GPUs. They can be used for both network training and inference. They are generally accessed through Google\u2019s cloud services, but small TPUs can also be accessed directly for free through Google Colab and Kaggle Kernels.\n\nBecause [all TensorFlow models in \ud83e\udd17 Transformers are Keras models](https://huggingface.co/blog/tensorflow-philosophy), most of the methods in this document are generally applicable to TPU training for any Keras model! However, there are a few points that are specific to the HuggingFace ecosystem (hug-o-system?) of Transformers and Datasets, and we\u2019ll make sure to flag them up when we get to them.\n\n### What kinds of TPU are available?\n\nNew users are often very confused by the range of TPUs, and the different ways to access them. The first key distinction to understand is the difference between **TPU Nodes** and **TPU VMs.**\n\nWhen you use a **TPU Node**, you are effectively indirectly accessing a remote TPU. You will need a separate VM, which will initialize your network and data pipeline and then forward them to the remote node. When you use a TPU on Google Colab, you are accessing it in the **TPU Node** style.\n\nUsing TPU Nodes can have some quite unexpected behaviour for people who aren\u2019t used to them! In particular, because the TPU is located on a physically different system to the machine you\u2019re running your Python code on, your data cannot be local to your machine - any data pipeline that loads from your machine\u2019s internal storage will totally fail! Instead, data must be stored in Google Cloud Storage where your data pipeline can still access it, even when the pipeline is running on the remote TPU node.\n\n<Tip>\n\nIf you can fit all your data in memory as `np.ndarray` or `tf.Tensor`, then you can `fit()` on that data even when using Colab or a TPU Node, without needing to upload it to Google Cloud Storage.\n\n</Tip>\n\n<Tip>\n\n**\ud83e\udd17Specific Hugging Face Tip\ud83e\udd17:** The methods `Dataset.to_tf_dataset()` and its higher-level wrapper `model.prepare_tf_dataset()` , which you will see throughout our TF code examples, will both fail on a TPU Node. The reason for this is that even though they create a `tf.data.Dataset` it is not a \u201cpure\u201d `tf.data` pipeline and uses `tf.numpy_function` or `Dataset.from_generator()` to stream data from the underlying HuggingFace `Dataset`. This HuggingFace `Dataset` is backed by data that is on a local disc and which the remote TPU Node will not be able to read.\n\n</Tip>\n\nThe second way to access a TPU is via a **TPU VM.** When using a TPU VM, you connect directly to the machine that the TPU is attached to, much like training on a GPU VM. TPU VMs are generally easier to work with, particularly when it comes to your data pipeline. All of the above warnings do not apply to TPU VMs!\n\nThis is an opinionated document, so here\u2019s our opinion: **Avoid using TPU Node if possible.** It is more confusing and more difficult to debug than TPU VMs. It is also likely to be unsupported in future - Google\u2019s latest TPU, TPUv4, can only be accessed as a TPU VM, which suggests that TPU Nodes are increasingly going to become a \u201clegacy\u201d access method."
            },
            {
                "score": 0.5004005658812395,
                "node_text": "Here are some facts extracted from the provided text:\n\nTpu -> Accessed through -> Google's cloud services\n\nThis is a really useful trick, so remember it if you need to convert your own code to XLA!\n\n#### XLA Rule #3: XLA will need to recompile your model for every different input shape it sees\n\nThis is the big one. What this means is that if your input shapes are very variable, XLA will have to recompile your model over and over, which will create huge performance problems. This commonly arises in NLP models, where input texts have variable lengths after tokenization. In other modalities, static shapes are more common and this rule is much less of a problem.\n\nHow can you get around rule #3? The key is **padding** - if you pad all your inputs to the same length, and then use an `attention_mask`, you can get the same results as you\u2019d get from variable shapes, but without any XLA issues. However, excessive padding can cause severe slowdown too - if you pad all your samples to the maximum length in the whole dataset, you might end up with batches consisting endless padding tokens, which will waste a lot of compute and memory!\n\nThere isn\u2019t a perfect solution to this problem. However, you can try some tricks. One very useful trick is to **pad batches of samples up to a multiple of a number like 32 or 64 tokens.** This often only increases the number of tokens by a small amount, but it hugely reduces the number of unique input shapes, because every input shape now has to be a multiple of 32 or 64. Fewer unique input shapes means fewer XLA compilations!\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** Our tokenizers and data collators have methods that can help you here. You can use `padding=\"max_length\"` or `padding=\"longest\"` when calling tokenizers to get them to output padded data. Our tokenizers and data collators also have a `pad_to_multiple_of` argument that you can use to reduce the number of unique input shapes you see!\n\n</Tip>\n\n### How do I actually train my model on TPU?\n\nOnce your training is XLA-compatible and (if you\u2019re using TPU Node / Colab) your dataset has been prepared appropriately, running on TPU is surprisingly easy! All you really need to change in your code is to add a few lines to initialize your TPU, and to ensure that your model and dataset are created inside a `TPUStrategy` scope. Take a look at [our TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) to see this in action!\n\n### Summary\n\nThere was a lot in here, so let\u2019s summarize with a quick checklist you can follow when you want to get your model ready for TPU training:\n\n- Make sure your code follows the three rules of XLA\n- Compile your model with `jit_compile=True` on CPU/GPU and confirm that you can train it with XLA\n- Either load your dataset into memory or use a TPU-compatible dataset loading approach (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Migrate your code either to Colab (with accelerator set to \u201cTPU\u201d) or a TPU VM on Google Cloud\n- Add TPU initializer code (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Create your `TPUStrategy` and make sure dataset loading and model creation are inside the `strategy.scope()` (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Don\u2019t forget to take `jit_compile=True` out again when you move to TPU!\n- \ud83d\ude4f\ud83d\ude4f\ud83d\ude4f\ud83e\udd7a\ud83e\udd7a\ud83e\udd7a\n- Call model.fit()\n- You did it!"
            }
        ]
    },
    {
        "sample_idx": 17,
        "question": "What is mnli?",
        "answer": "mnli is a crowdsourced collection of sentence pairs with textual entailment annotations, which is a subset of GLUE corresponding to the NLI task.",
        "rag_answer": "There is no information about \"mnli\" in the provided context. The context only talks about LayoutLMv3, fine-tuning, token classification, and Gradio library. It does not mention \"mnli\" at all.",
        "rag_score": 1,
        "rag_feedback": "The system's response is completely incorrect, inaccurate, and not factual. The system failed to provide any information about MNLI, instead, it mentioned that there is no information about MNLI in the provided context, which is not relevant to the question.",
        "rag_context": [
            {
                "score": 0.49238753595370965,
                "node_text": "Here are some facts extracted from the provided text:\n\nLayoutlmv3 -> Is -> Pytorch version\nScript -> Fine-tunes -> Layoutlmv3\nNielsr/layoutlmv3-finetuned-funsd -> Is -> Model\nMicrosoft/layoutlmv3-base -> Is -> Model name or path\n\n!---\nCopyright 2022 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n-->\n\n# Token classification with LayoutLMv3 (PyTorch version)\n\nThis directory contains a script, `run_funsd_cord.py`, that can be used to fine-tune (or evaluate) LayoutLMv3 on form understanding datasets, such as [FUNSD](https://guillaumejaume.github.io/FUNSD/) and [CORD](https://github.com/clovaai/cord).\n\nThe script `run_funsd_cord.py` leverages the \ud83e\udd17 Datasets library and the Trainer API. You can easily customize it to your needs.\n\n## Fine-tuning on FUNSD\n\nFine-tuning LayoutLMv3 for token classification on [FUNSD](https://guillaumejaume.github.io/FUNSD/) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name funsd \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 1e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-funsd\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd. By specifying the `push_to_hub` flag, the model gets uploaded automatically to the hub (regularly), together with a model card, which includes metrics such as precision, recall and F1. Note that you can easily update the model card, as it's just a README file of the respective repo on the hub.\n\nThere's also the \"Training metrics\" [tab](https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd/tensorboard), which shows Tensorboard logs over the course of training. Pretty neat, huh?\n\n## Fine-tuning on CORD\n\nFine-tuning LayoutLMv3 for token classification on [CORD](https://github.com/clovaai/cord) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name cord \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 5e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-cord\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-cord. Note that a model card gets generated automatically in case you specify the `push_to_hub` flag."
            },
            {
                "score": 0.4740713593075071,
                "node_text": "Here are some facts extracted from the provided text:\n\nGradio -> Is -> Library\n\nGradio Demo: blocks_random_slider\n\n\n```\n!pip install -q gradio \n```\n\n\n```\n\nimport gradio as gr\n\n\ndef func(slider_1, slider_2):\n    return slider_1 * 5 + slider_2\n\n\nwith gr.Blocks() as demo:\n    slider = gr.Slider(minimum=-10.2, maximum=15, label=\"Random Slider (Static)\", randomize=True)\n    slider_1 = gr.Slider(minimum=100, maximum=200, label=\"Random Slider (Input 1)\", randomize=True)\n    slider_2 = gr.Slider(minimum=10, maximum=23.2, label=\"Random Slider (Input 2)\", randomize=True)\n    slider_3 = gr.Slider(value=3, label=\"Non random slider\")\n    btn = gr.Button(\"Run\")\n    btn.click(func, inputs=[slider_1, slider_2], outputs=gr.Number())\n\nif __name__ == \"__main__\":\n    demo.launch()\n\n```"
            }
        ]
    },
    {
        "sample_idx": 18,
        "question": "What is the name of the dataset that requires feeding the 'question' and 'context' into the model and returning the 'prediction_text'?",
        "answer": "SQuAD",
        "rag_answer": "There is no specific dataset mentioned in the context information that requires feeding the 'question' and 'context' into the model and returning the 'prediction_text'. The context information discusses XLA rules, TPU training, and HuggingFace ecosystem, but it does not mention a specific dataset with the mentioned requirements.",
        "rag_score": 1,
        "rag_feedback": "The system's response is completely incorrect, inaccurate, and/or not factual. The question asks about a specific dataset that requires feeding the 'question' and 'context' into the model and returning the 'prediction_text', and the expected answer is SQuAD. However, the system's response does not mention SQuAD at all and instead provides a lengthy and irrelevant text about XLA rules, TPU training, and HuggingFace ecosystem.",
        "rag_context": [
            {
                "score": 0.6541497633134005,
                "node_text": "Here are some facts extracted from the provided text:\n\nNlp models -> Have -> Variable lengths\nTpu -> Is used -> For training\n\nThis is a really useful trick, so remember it if you need to convert your own code to XLA!\n\n#### XLA Rule #3: XLA will need to recompile your model for every different input shape it sees\n\nThis is the big one. What this means is that if your input shapes are very variable, XLA will have to recompile your model over and over, which will create huge performance problems. This commonly arises in NLP models, where input texts have variable lengths after tokenization. In other modalities, static shapes are more common and this rule is much less of a problem.\n\nHow can you get around rule #3? The key is **padding** - if you pad all your inputs to the same length, and then use an `attention_mask`, you can get the same results as you\u2019d get from variable shapes, but without any XLA issues. However, excessive padding can cause severe slowdown too - if you pad all your samples to the maximum length in the whole dataset, you might end up with batches consisting endless padding tokens, which will waste a lot of compute and memory!\n\nThere isn\u2019t a perfect solution to this problem. However, you can try some tricks. One very useful trick is to **pad batches of samples up to a multiple of a number like 32 or 64 tokens.** This often only increases the number of tokens by a small amount, but it hugely reduces the number of unique input shapes, because every input shape now has to be a multiple of 32 or 64. Fewer unique input shapes means fewer XLA compilations!\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** Our tokenizers and data collators have methods that can help you here. You can use `padding=\"max_length\"` or `padding=\"longest\"` when calling tokenizers to get them to output padded data. Our tokenizers and data collators also have a `pad_to_multiple_of` argument that you can use to reduce the number of unique input shapes you see!\n\n</Tip>\n\n### How do I actually train my model on TPU?\n\nOnce your training is XLA-compatible and (if you\u2019re using TPU Node / Colab) your dataset has been prepared appropriately, running on TPU is surprisingly easy! All you really need to change in your code is to add a few lines to initialize your TPU, and to ensure that your model and dataset are created inside a `TPUStrategy` scope. Take a look at [our TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) to see this in action!\n\n### Summary\n\nThere was a lot in here, so let\u2019s summarize with a quick checklist you can follow when you want to get your model ready for TPU training:\n\n- Make sure your code follows the three rules of XLA\n- Compile your model with `jit_compile=True` on CPU/GPU and confirm that you can train it with XLA\n- Either load your dataset into memory or use a TPU-compatible dataset loading approach (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Migrate your code either to Colab (with accelerator set to \u201cTPU\u201d) or a TPU VM on Google Cloud\n- Add TPU initializer code (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Create your `TPUStrategy` and make sure dataset loading and model creation are inside the `strategy.scope()` (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Don\u2019t forget to take `jit_compile=True` out again when you move to TPU!\n- \ud83d\ude4f\ud83d\ude4f\ud83d\ude4f\ud83e\udd7a\ud83e\udd7a\ud83e\udd7a\n- Call model.fit()\n- You did it!"
            },
            {
                "score": 0.6376637594528044,
                "node_text": "Here are some facts extracted from the provided text:\n\nTensorflow models -> Are -> Keras models\nHuggingface ecosystem -> Includes -> Transformers and datasets\n\n!--Copyright 2023 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\nthe License. You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under the License is distributed on\nan \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n\n\u26a0\ufe0f Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be\nrendered properly in your Markdown viewer.\n\n-->\n\n# Training on TPU with TensorFlow\n\n<Tip>\n\nIf you don't need long explanations and just want TPU code samples to get started with, check out [our TPU example notebook!](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb)\n\n</Tip>\n\n### What is a TPU?\n\nA TPU is a **Tensor Processing Unit.** They are hardware designed by Google, which are used to greatly speed up the tensor computations within neural networks, much like GPUs. They can be used for both network training and inference. They are generally accessed through Google\u2019s cloud services, but small TPUs can also be accessed directly for free through Google Colab and Kaggle Kernels.\n\nBecause [all TensorFlow models in \ud83e\udd17 Transformers are Keras models](https://huggingface.co/blog/tensorflow-philosophy), most of the methods in this document are generally applicable to TPU training for any Keras model! However, there are a few points that are specific to the HuggingFace ecosystem (hug-o-system?) of Transformers and Datasets, and we\u2019ll make sure to flag them up when we get to them.\n\n### What kinds of TPU are available?\n\nNew users are often very confused by the range of TPUs, and the different ways to access them. The first key distinction to understand is the difference between **TPU Nodes** and **TPU VMs.**\n\nWhen you use a **TPU Node**, you are effectively indirectly accessing a remote TPU. You will need a separate VM, which will initialize your network and data pipeline and then forward them to the remote node. When you use a TPU on Google Colab, you are accessing it in the **TPU Node** style.\n\nUsing TPU Nodes can have some quite unexpected behaviour for people who aren\u2019t used to them! In particular, because the TPU is located on a physically different system to the machine you\u2019re running your Python code on, your data cannot be local to your machine - any data pipeline that loads from your machine\u2019s internal storage will totally fail! Instead, data must be stored in Google Cloud Storage where your data pipeline can still access it, even when the pipeline is running on the remote TPU node.\n\n<Tip>\n\nIf you can fit all your data in memory as `np.ndarray` or `tf.Tensor`, then you can `fit()` on that data even when using Colab or a TPU Node, without needing to upload it to Google Cloud Storage.\n\n</Tip>\n\n<Tip>\n\n**\ud83e\udd17Specific Hugging Face Tip\ud83e\udd17:** The methods `Dataset.to_tf_dataset()` and its higher-level wrapper `model.prepare_tf_dataset()` , which you will see throughout our TF code examples, will both fail on a TPU Node. The reason for this is that even though they create a `tf.data.Dataset` it is not a \u201cpure\u201d `tf.data` pipeline and uses `tf.numpy_function` or `Dataset.from_generator()` to stream data from the underlying HuggingFace `Dataset`. This HuggingFace `Dataset` is backed by data that is on a local disc and which the remote TPU Node will not be able to read.\n\n</Tip>\n\nThe second way to access a TPU is via a **TPU VM.** When using a TPU VM, you connect directly to the machine that the TPU is attached to, much like training on a GPU VM. TPU VMs are generally easier to work with, particularly when it comes to your data pipeline. All of the above warnings do not apply to TPU VMs!\n\nThis is an opinionated document, so here\u2019s our opinion: **Avoid using TPU Node if possible.** It is more confusing and more difficult to debug than TPU VMs. It is also likely to be unsupported in future - Google\u2019s latest TPU, TPUv4, can only be accessed as a TPU VM, which suggests that TPU Nodes are increasingly going to become a \u201clegacy\u201d access method."
            }
        ]
    },
    {
        "sample_idx": 19,
        "question": "What is the name of the function used to compute the evaluation results in the example code?",
        "answer": "compute",
        "rag_answer": "The name of the function used to compute the evaluation results in the example code is `compute`.",
        "rag_score": 5,
        "rag_feedback": "The system's response is completely correct, accurate, and factual. It correctly identifies the function name 'compute' as the answer to the question.",
        "rag_context": [
            {
                "score": 1.0,
                "node_text": "Here are some facts extracted from the provided text:\n\nMetric -> Is -> Evaluation metric\n\nChoosing a metric for your task\n\n**So you've trained your model and want to see how well it\u2019s doing on a dataset of your choice. Where do you start?**\n\nThere is no \u201cone size fits all\u201d approach to choosing an evaluation metric, but some good guidelines to keep in mind are:\n\n## Categories of metrics\n\nThere are 3 high-level categories of metrics:\n\n1. *Generic metrics*, which can be applied to a variety of situations and datasets, such as precision and accuracy.\n2. *Task-specific metrics*, which are limited to a given task, such as Machine Translation (often evaluated using metrics [BLEU](https://huggingface.co/metrics/bleu) or [ROUGE](https://huggingface.co/metrics/rouge)) or Named Entity Recognition (often evaluated with [seqeval](https://huggingface.co/metrics/seqeval)).\n3. *Dataset-specific metrics*, which aim to measure model performance on specific benchmarks: for instance, the [GLUE benchmark](https://huggingface.co/datasets/glue) has a dedicated [evaluation metric](https://huggingface.co/metrics/glue).\n\nLet's look at each of these three cases:\n\n### Generic metrics\n\nMany of the metrics used in the Machine Learning community are quite generic and can be applied in a variety of tasks and datasets.\n\nThis is the case for metrics like [accuracy](https://huggingface.co/metrics/accuracy) and [precision](https://huggingface.co/metrics/precision), which can be used for evaluating labeled (supervised) datasets, as well as [perplexity](https://huggingface.co/metrics/perplexity), which can be used for evaluating different kinds of (unsupervised) generative tasks.\n\nTo see the input structure of a given metric, you can look at its metric card. For example, in the case of [precision](https://huggingface.co/metrics/precision), the format is:\n```\n>>> precision_metric = evaluate.load(\"precision\")\n>>> results = precision_metric.compute(references=[0, 1], predictions=[0, 1])\n>>> print(results)\n{'precision': 1.0}\n```\n\n### Task-specific metrics\n\nPopular ML tasks like Machine Translation and Named Entity Recognition have specific metrics that can be used to compare models. For example, a series of different metrics have been proposed for text generation, ranging from [BLEU](https://huggingface.co/metrics/bleu) and its derivatives such as [GoogleBLEU](https://huggingface.co/metrics/google_bleu) and [GLEU](https://huggingface.co/metrics/gleu), but also [ROUGE](https://huggingface.co/metrics/rouge), [MAUVE](https://huggingface.co/metrics/mauve), etc.\n\nYou can find the right metric for your task by:\n\n- **Looking at the [Task pages](https://huggingface.co/tasks)** to see what metrics can be used for evaluating models for a given task.\n- **Checking out leaderboards** on sites like [Papers With Code](https://paperswithcode.com/) (you can search by task and by dataset).\n-  **Reading the metric cards** for the relevant metrics and see which ones are a good fit for your use case. For example, see the [BLEU metric card](https://github.com/huggingface/evaluate/tree/main/metrics/bleu) or [SQuaD metric card](https://github.com/huggingface/evaluate/tree/main/metrics/squad).\n- **Looking at papers and blog posts** published on the topic and see what metrics they report. This can change over time, so try to pick papers from the last couple of years!\n\n### Dataset-specific metrics\n\nSome datasets have specific metrics associated with them -- this is especially in the case of popular benchmarks like [GLUE](https://huggingface.co/metrics/glue) and [SQuAD](https://huggingface.co/metrics/squad).\n\n<Tip warning={true}>\n\ud83d\udca1\nGLUE is actually a collection of different subsets on different tasks, so first you need to choose the one that corresponds to the NLI task, such as mnli, which is described as \u201ccrowdsourced collection of sentence pairs with textual entailment annotations\u201d\n</Tip>"
            },
            {
                "score": 0.670244622610751,
                "node_text": "Here are some facts extracted from the provided text:\n\nGlue benchmark -> Has -> Dedicated evaluation metric\nMetric -> Is -> Evaluation metric\n\nChoosing a metric for your task\n\n**So you've trained your model and want to see how well it\u2019s doing on a dataset of your choice. Where do you start?**\n\nThere is no \u201cone size fits all\u201d approach to choosing an evaluation metric, but some good guidelines to keep in mind are:\n\n## Categories of metrics\n\nThere are 3 high-level categories of metrics:\n\n1. *Generic metrics*, which can be applied to a variety of situations and datasets, such as precision and accuracy.\n2. *Task-specific metrics*, which are limited to a given task, such as Machine Translation (often evaluated using metrics [BLEU](https://huggingface.co/metrics/bleu) or [ROUGE](https://huggingface.co/metrics/rouge)) or Named Entity Recognition (often evaluated with [seqeval](https://huggingface.co/metrics/seqeval)).\n3. *Dataset-specific metrics*, which aim to measure model performance on specific benchmarks: for instance, the [GLUE benchmark](https://huggingface.co/datasets/glue) has a dedicated [evaluation metric](https://huggingface.co/metrics/glue).\n\nLet's look at each of these three cases:\n\n### Generic metrics\n\nMany of the metrics used in the Machine Learning community are quite generic and can be applied in a variety of tasks and datasets.\n\nThis is the case for metrics like [accuracy](https://huggingface.co/metrics/accuracy) and [precision](https://huggingface.co/metrics/precision), which can be used for evaluating labeled (supervised) datasets, as well as [perplexity](https://huggingface.co/metrics/perplexity), which can be used for evaluating different kinds of (unsupervised) generative tasks.\n\nTo see the input structure of a given metric, you can look at its metric card. For example, in the case of [precision](https://huggingface.co/metrics/precision), the format is:\n```\n>>> precision_metric = evaluate.load(\"precision\")\n>>> results = precision_metric.compute(references=[0, 1], predictions=[0, 1])\n>>> print(results)\n{'precision': 1.0}\n```\n\n### Task-specific metrics\n\nPopular ML tasks like Machine Translation and Named Entity Recognition have specific metrics that can be used to compare models. For example, a series of different metrics have been proposed for text generation, ranging from [BLEU](https://huggingface.co/metrics/bleu) and its derivatives such as [GoogleBLEU](https://huggingface.co/metrics/google_bleu) and [GLEU](https://huggingface.co/metrics/gleu), but also [ROUGE](https://huggingface.co/metrics/rouge), [MAUVE](https://huggingface.co/metrics/mauve), etc.\n\nYou can find the right metric for your task by:\n\n- **Looking at the [Task pages](https://huggingface.co/tasks)** to see what metrics can be used for evaluating models for a given task.\n- **Checking out leaderboards** on sites like [Papers With Code](https://paperswithcode.com/) (you can search by task and by dataset).\n-  **Reading the metric cards** for the relevant metrics and see which ones are a good fit for your use case. For example, see the [BLEU metric card](https://github.com/huggingface/evaluate/tree/main/metrics/bleu) or [SQuaD metric card](https://github.com/huggingface/evaluate/tree/main/metrics/squad).\n- **Looking at papers and blog posts** published on the topic and see what metrics they report. This can change over time, so try to pick papers from the last couple of years!\n\n### Dataset-specific metrics\n\nSome datasets have specific metrics associated with them -- this is especially in the case of popular benchmarks like [GLUE](https://huggingface.co/metrics/glue) and [SQuAD](https://huggingface.co/metrics/squad).\n\n<Tip warning={true}>\n\ud83d\udca1\nGLUE is actually a collection of different subsets on different tasks, so first you need to choose the one that corresponds to the NLI task, such as mnli, which is described as \u201ccrowdsourced collection of sentence pairs with textual entailment annotations\u201d\n</Tip>"
            },
            {
                "score": 0.6605889552617101,
                "node_text": "Here are some facts extracted from the provided text:\n\nSquad -> Has -> Evaluation metric\nEvaluation metric -> Requires -> Format\n\nIf you are evaluating your model on a benchmark dataset like the ones mentioned above, you can use its dedicated evaluation metric. Make sure you respect the format that they require. For example, to evaluate your model on the [SQuAD](https://huggingface.co/datasets/squad) dataset, you need to feed the `question` and `context` into your model and return the `prediction_text`, which should be compared with the `references` (based on matching the `id` of the question) :\n\n```\n>>> from evaluate import load\n>>> squad_metric = load(\"squad\")\n>>> predictions = [{'prediction_text': '1976', 'id': '56e10a3be3433e1400422b22'}]\n>>> references = [{'answers': {'answer_start': [97], 'text': ['1976']}, 'id': '56e10a3be3433e1400422b22'}]\n>>> results = squad_metric.compute(predictions=predictions, references=references)\n>>> results\n{'exact_match': 100.0, 'f1': 100.0}\n```\n\nYou can find examples of dataset structures by consulting the \"Dataset Preview\" function or the dataset card for a given dataset, and you can see how to use its dedicated evaluation function based on the metric card."
            },
            {
                "score": 0.6250191239847644,
                "node_text": "Here are some facts extracted from the provided text:\n\nRun_funsd_cord.py -> Is -> Script\n\n!---\nCopyright 2022 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n-->\n\n# Token classification with LayoutLMv3 (PyTorch version)\n\nThis directory contains a script, `run_funsd_cord.py`, that can be used to fine-tune (or evaluate) LayoutLMv3 on form understanding datasets, such as [FUNSD](https://guillaumejaume.github.io/FUNSD/) and [CORD](https://github.com/clovaai/cord).\n\nThe script `run_funsd_cord.py` leverages the \ud83e\udd17 Datasets library and the Trainer API. You can easily customize it to your needs.\n\n## Fine-tuning on FUNSD\n\nFine-tuning LayoutLMv3 for token classification on [FUNSD](https://guillaumejaume.github.io/FUNSD/) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name funsd \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 1e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-funsd\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd. By specifying the `push_to_hub` flag, the model gets uploaded automatically to the hub (regularly), together with a model card, which includes metrics such as precision, recall and F1. Note that you can easily update the model card, as it's just a README file of the respective repo on the hub.\n\nThere's also the \"Training metrics\" [tab](https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd/tensorboard), which shows Tensorboard logs over the course of training. Pretty neat, huh?\n\n## Fine-tuning on CORD\n\nFine-tuning LayoutLMv3 for token classification on [CORD](https://github.com/clovaai/cord) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name cord \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 5e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-cord\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-cord. Note that a model card gets generated automatically in case you specify the `push_to_hub` flag."
            }
        ]
    },
    {
        "sample_idx": 20,
        "question": "What are the two metrics returned by the 'compute' function in the example code?",
        "answer": "exact_match and f1",
        "rag_answer": "The two metrics returned by the 'compute' function in the example code are 'exact_match' and 'f1'.",
        "rag_score": 5,
        "rag_feedback": "The system's response is completely correct, accurate, and factual. It directly answers the question by stating that the two metrics returned by the 'compute' function in the example code are 'exact_match' and 'f1'.",
        "rag_context": [
            {
                "score": 0.7081720872325176,
                "node_text": "Here are some facts extracted from the provided text:\n\nBleu -> Is -> Task-specific metric\nMetric -> Is -> Evaluation metric\nGlue benchmark -> Has -> Dedicated evaluation metric\nGeneric metrics -> Can be applied to -> Variety of situations\n\nChoosing a metric for your task\n\n**So you've trained your model and want to see how well it\u2019s doing on a dataset of your choice. Where do you start?**\n\nThere is no \u201cone size fits all\u201d approach to choosing an evaluation metric, but some good guidelines to keep in mind are:\n\n## Categories of metrics\n\nThere are 3 high-level categories of metrics:\n\n1. *Generic metrics*, which can be applied to a variety of situations and datasets, such as precision and accuracy.\n2. *Task-specific metrics*, which are limited to a given task, such as Machine Translation (often evaluated using metrics [BLEU](https://huggingface.co/metrics/bleu) or [ROUGE](https://huggingface.co/metrics/rouge)) or Named Entity Recognition (often evaluated with [seqeval](https://huggingface.co/metrics/seqeval)).\n3. *Dataset-specific metrics*, which aim to measure model performance on specific benchmarks: for instance, the [GLUE benchmark](https://huggingface.co/datasets/glue) has a dedicated [evaluation metric](https://huggingface.co/metrics/glue).\n\nLet's look at each of these three cases:\n\n### Generic metrics\n\nMany of the metrics used in the Machine Learning community are quite generic and can be applied in a variety of tasks and datasets.\n\nThis is the case for metrics like [accuracy](https://huggingface.co/metrics/accuracy) and [precision](https://huggingface.co/metrics/precision), which can be used for evaluating labeled (supervised) datasets, as well as [perplexity](https://huggingface.co/metrics/perplexity), which can be used for evaluating different kinds of (unsupervised) generative tasks.\n\nTo see the input structure of a given metric, you can look at its metric card. For example, in the case of [precision](https://huggingface.co/metrics/precision), the format is:\n```\n>>> precision_metric = evaluate.load(\"precision\")\n>>> results = precision_metric.compute(references=[0, 1], predictions=[0, 1])\n>>> print(results)\n{'precision': 1.0}\n```\n\n### Task-specific metrics\n\nPopular ML tasks like Machine Translation and Named Entity Recognition have specific metrics that can be used to compare models. For example, a series of different metrics have been proposed for text generation, ranging from [BLEU](https://huggingface.co/metrics/bleu) and its derivatives such as [GoogleBLEU](https://huggingface.co/metrics/google_bleu) and [GLEU](https://huggingface.co/metrics/gleu), but also [ROUGE](https://huggingface.co/metrics/rouge), [MAUVE](https://huggingface.co/metrics/mauve), etc.\n\nYou can find the right metric for your task by:\n\n- **Looking at the [Task pages](https://huggingface.co/tasks)** to see what metrics can be used for evaluating models for a given task.\n- **Checking out leaderboards** on sites like [Papers With Code](https://paperswithcode.com/) (you can search by task and by dataset).\n-  **Reading the metric cards** for the relevant metrics and see which ones are a good fit for your use case. For example, see the [BLEU metric card](https://github.com/huggingface/evaluate/tree/main/metrics/bleu) or [SQuaD metric card](https://github.com/huggingface/evaluate/tree/main/metrics/squad).\n- **Looking at papers and blog posts** published on the topic and see what metrics they report. This can change over time, so try to pick papers from the last couple of years!\n\n### Dataset-specific metrics\n\nSome datasets have specific metrics associated with them -- this is especially in the case of popular benchmarks like [GLUE](https://huggingface.co/metrics/glue) and [SQuAD](https://huggingface.co/metrics/squad).\n\n<Tip warning={true}>\n\ud83d\udca1\nGLUE is actually a collection of different subsets on different tasks, so first you need to choose the one that corresponds to the NLI task, such as mnli, which is described as \u201ccrowdsourced collection of sentence pairs with textual entailment annotations\u201d\n</Tip>"
            },
            {
                "score": 0.7017040672081323,
                "node_text": "Here are some facts extracted from the provided text:\n\nSquad -> Has -> Evaluation metric\nEvaluation metric -> Requires -> Format\n\nIf you are evaluating your model on a benchmark dataset like the ones mentioned above, you can use its dedicated evaluation metric. Make sure you respect the format that they require. For example, to evaluate your model on the [SQuAD](https://huggingface.co/datasets/squad) dataset, you need to feed the `question` and `context` into your model and return the `prediction_text`, which should be compared with the `references` (based on matching the `id` of the question) :\n\n```\n>>> from evaluate import load\n>>> squad_metric = load(\"squad\")\n>>> predictions = [{'prediction_text': '1976', 'id': '56e10a3be3433e1400422b22'}]\n>>> references = [{'answers': {'answer_start': [97], 'text': ['1976']}, 'id': '56e10a3be3433e1400422b22'}]\n>>> results = squad_metric.compute(predictions=predictions, references=references)\n>>> results\n{'exact_match': 100.0, 'f1': 100.0}\n```\n\nYou can find examples of dataset structures by consulting the \"Dataset Preview\" function or the dataset card for a given dataset, and you can see how to use its dedicated evaluation function based on the metric card."
            }
        ]
    },
    {
        "sample_idx": 21,
        "question": "Where can you find examples of dataset structures?",
        "answer": "The 'Dataset Preview' function or the dataset card for a given dataset",
        "rag_answer": "You can find examples of dataset structures by consulting the \"Dataset Preview\" function or the dataset card for a given dataset.",
        "rag_score": 5,
        "rag_feedback": "The system's response is completely correct, accurate, and factual. It directly answers the question by stating that examples of dataset structures can be found in the 'Dataset Preview' function or the dataset card for a given dataset.",
        "rag_context": [
            {
                "score": 0.6007859458704219,
                "node_text": "Here are some facts extracted from the provided text:\n\nHuggingface ecosystem -> Includes -> Transformers and datasets\n\n!--Copyright 2023 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\nthe License. You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under the License is distributed on\nan \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n\n\u26a0\ufe0f Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be\nrendered properly in your Markdown viewer.\n\n-->\n\n# Training on TPU with TensorFlow\n\n<Tip>\n\nIf you don't need long explanations and just want TPU code samples to get started with, check out [our TPU example notebook!](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb)\n\n</Tip>\n\n### What is a TPU?\n\nA TPU is a **Tensor Processing Unit.** They are hardware designed by Google, which are used to greatly speed up the tensor computations within neural networks, much like GPUs. They can be used for both network training and inference. They are generally accessed through Google\u2019s cloud services, but small TPUs can also be accessed directly for free through Google Colab and Kaggle Kernels.\n\nBecause [all TensorFlow models in \ud83e\udd17 Transformers are Keras models](https://huggingface.co/blog/tensorflow-philosophy), most of the methods in this document are generally applicable to TPU training for any Keras model! However, there are a few points that are specific to the HuggingFace ecosystem (hug-o-system?) of Transformers and Datasets, and we\u2019ll make sure to flag them up when we get to them.\n\n### What kinds of TPU are available?\n\nNew users are often very confused by the range of TPUs, and the different ways to access them. The first key distinction to understand is the difference between **TPU Nodes** and **TPU VMs.**\n\nWhen you use a **TPU Node**, you are effectively indirectly accessing a remote TPU. You will need a separate VM, which will initialize your network and data pipeline and then forward them to the remote node. When you use a TPU on Google Colab, you are accessing it in the **TPU Node** style.\n\nUsing TPU Nodes can have some quite unexpected behaviour for people who aren\u2019t used to them! In particular, because the TPU is located on a physically different system to the machine you\u2019re running your Python code on, your data cannot be local to your machine - any data pipeline that loads from your machine\u2019s internal storage will totally fail! Instead, data must be stored in Google Cloud Storage where your data pipeline can still access it, even when the pipeline is running on the remote TPU node.\n\n<Tip>\n\nIf you can fit all your data in memory as `np.ndarray` or `tf.Tensor`, then you can `fit()` on that data even when using Colab or a TPU Node, without needing to upload it to Google Cloud Storage.\n\n</Tip>\n\n<Tip>\n\n**\ud83e\udd17Specific Hugging Face Tip\ud83e\udd17:** The methods `Dataset.to_tf_dataset()` and its higher-level wrapper `model.prepare_tf_dataset()` , which you will see throughout our TF code examples, will both fail on a TPU Node. The reason for this is that even though they create a `tf.data.Dataset` it is not a \u201cpure\u201d `tf.data` pipeline and uses `tf.numpy_function` or `Dataset.from_generator()` to stream data from the underlying HuggingFace `Dataset`. This HuggingFace `Dataset` is backed by data that is on a local disc and which the remote TPU Node will not be able to read.\n\n</Tip>\n\nThe second way to access a TPU is via a **TPU VM.** When using a TPU VM, you connect directly to the machine that the TPU is attached to, much like training on a GPU VM. TPU VMs are generally easier to work with, particularly when it comes to your data pipeline. All of the above warnings do not apply to TPU VMs!\n\nThis is an opinionated document, so here\u2019s our opinion: **Avoid using TPU Node if possible.** It is more confusing and more difficult to debug than TPU VMs. It is also likely to be unsupported in future - Google\u2019s latest TPU, TPUv4, can only be accessed as a TPU VM, which suggests that TPU Nodes are increasingly going to become a \u201clegacy\u201d access method."
            },
            {
                "score": 0.5737043830017042,
                "node_text": "Here are some facts extracted from the provided text:\n\nRule #2 -> Prohibits -> Data-dependent shapes\n\nWe\u2019ve distilled them into three core rules below:\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** We\u2019ve put a lot of effort into rewriting our TensorFlow models and loss functions to be XLA-compatible. Our models and loss functions generally obey rule #1 and #2 by default, so you can skip over them if you\u2019re using `transformers` models. Don\u2019t forget about these rules when writing your own models and loss functions, though!\n\n</Tip>\n\n#### XLA Rule #1: Your code cannot have \u201cdata-dependent conditionals\u201d\n\nWhat that means is that any `if` statement cannot depend on values inside a `tf.Tensor`. For example, this code block cannot be compiled with XLA!\n\n```python\nif tf.reduce_sum(tensor) > 10:\n    tensor = tensor / 2.0\n```\n\nThis might seem very restrictive at first, but most neural net code doesn\u2019t need to do this. You can often get around this restriction by using `tf.cond` (see the documentation [here](https://www.tensorflow.org/api_docs/python/tf/cond)) or by removing the conditional and finding a clever math trick with indicator variables instead, like so:\n\n```python\nsum_over_10 = tf.cast(tf.reduce_sum(tensor) > 10, tf.float32)\ntensor = tensor / (1.0 + sum_over_10)\n```\n\nThis code has exactly the same effect as the code above, but by avoiding a conditional, we ensure it will compile with XLA without problems!\n\n#### XLA Rule #2: Your code cannot have \u201cdata-dependent shapes\u201d\n\nWhat this means is that the shape of all of the `tf.Tensor` objects in your code cannot depend on their values. For example, the function `tf.unique` cannot be compiled with XLA, because it returns a `tensor` containing one instance of each unique value in the input. The shape of this output will obviously be different depending on how repetitive the input `Tensor` was, and so XLA refuses to handle it!\n\nIn general, most neural network code obeys rule #2 by default. However, there are a few common cases where it becomes a problem. One very common one is when you use **label masking**, setting your labels to a negative value to indicate that those positions should be ignored when computing the loss. If you look at NumPy or PyTorch loss functions that support label masking, you will often see code like this that uses [boolean indexing](https://numpy.org/doc/stable/user/basics.indexing.html#boolean-array-indexing):\n\n```python\nlabel_mask = labels >= 0\nmasked_outputs = outputs[label_mask]\nmasked_labels = labels[label_mask]\nloss = compute_loss(masked_outputs, masked_labels)\nmean_loss = torch.mean(loss)\n```\n\nThis code is totally fine in NumPy or PyTorch, but it breaks in XLA! Why? Because the shape of `masked_outputs` and `masked_labels` depends on how many positions are masked - that makes it a **data-dependent shape.** However, just like for rule #1, we can often rewrite this code to yield exactly the same output without any data-dependent shapes.\n\n```python\nlabel_mask = tf.cast(labels >= 0, tf.float32)\nloss = compute_loss(outputs, labels)\nloss = loss * label_mask  # Set negative label positions to 0\nmean_loss = tf.reduce_sum(loss) / tf.reduce_sum(label_mask)\n```\n\nHere, we avoid data-dependent shapes by computing the loss for every position, but zeroing out the masked positions in both the numerator and denominator when we calculate the mean, which yields exactly the same result as the first block while maintaining XLA compatibility. Note that we use the same trick as in rule #1 - converting a `tf.bool` to `tf.float32` and using it as an indicator variable. This is a really useful trick, so remember it if you need to convert your own code to XLA!\n\n#### XLA Rule #3: XLA will need to recompile your model for every different input shape it sees\n\nThis is the big one. What this means is that if your input shapes are very variable, XLA will have to recompile your model over and over, which will create huge performance problems. This commonly arises in NLP models, where input texts have variable lengths after tokenization. In other modalities, static shapes are more common and this rule is much less of a problem.\n\nHow can you get around rule #3? The key is **padding** - if you pad all your inputs to the same length, and then use an `attention_mask`, you can get the same results as you\u2019d get from variable shapes, but without any XLA issues."
            },
            {
                "score": 0.5564803329329735,
                "node_text": "Here are some facts extracted from the provided text:\n\nSquad -> Is -> Dataset\n\nIf you are evaluating your model on a benchmark dataset like the ones mentioned above, you can use its dedicated evaluation metric. Make sure you respect the format that they require. For example, to evaluate your model on the [SQuAD](https://huggingface.co/datasets/squad) dataset, you need to feed the `question` and `context` into your model and return the `prediction_text`, which should be compared with the `references` (based on matching the `id` of the question) :\n\n```\n>>> from evaluate import load\n>>> squad_metric = load(\"squad\")\n>>> predictions = [{'prediction_text': '1976', 'id': '56e10a3be3433e1400422b22'}]\n>>> references = [{'answers': {'answer_start': [97], 'text': ['1976']}, 'id': '56e10a3be3433e1400422b22'}]\n>>> results = squad_metric.compute(predictions=predictions, references=references)\n>>> results\n{'exact_match': 100.0, 'f1': 100.0}\n```\n\nYou can find examples of dataset structures by consulting the \"Dataset Preview\" function or the dataset card for a given dataset, and you can see how to use its dedicated evaluation function based on the metric card."
            },
            {
                "score": 0.5428589659258918,
                "node_text": "Here are some facts extracted from the provided text:\n\nFunsd -> Is -> Form understanding dataset\nCord -> Is -> Form understanding dataset\n\n!---\nCopyright 2022 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n-->\n\n# Token classification with LayoutLMv3 (PyTorch version)\n\nThis directory contains a script, `run_funsd_cord.py`, that can be used to fine-tune (or evaluate) LayoutLMv3 on form understanding datasets, such as [FUNSD](https://guillaumejaume.github.io/FUNSD/) and [CORD](https://github.com/clovaai/cord).\n\nThe script `run_funsd_cord.py` leverages the \ud83e\udd17 Datasets library and the Trainer API. You can easily customize it to your needs.\n\n## Fine-tuning on FUNSD\n\nFine-tuning LayoutLMv3 for token classification on [FUNSD](https://guillaumejaume.github.io/FUNSD/) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name funsd \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 1e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-funsd\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd. By specifying the `push_to_hub` flag, the model gets uploaded automatically to the hub (regularly), together with a model card, which includes metrics such as precision, recall and F1. Note that you can easily update the model card, as it's just a README file of the respective repo on the hub.\n\nThere's also the \"Training metrics\" [tab](https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd/tensorboard), which shows Tensorboard logs over the course of training. Pretty neat, huh?\n\n## Fine-tuning on CORD\n\nFine-tuning LayoutLMv3 for token classification on [CORD](https://github.com/clovaai/cord) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name cord \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 5e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-cord\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-cord. Note that a model card gets generated automatically in case you specify the `push_to_hub` flag."
            }
        ]
    },
    {
        "sample_idx": 22,
        "question": "Where can you see how to use a dataset's dedicated evaluation function?",
        "answer": "The metric card",
        "rag_answer": "You can see how to use a dataset's dedicated evaluation function based on the metric card.",
        "rag_score": 4,
        "rag_feedback": "The system's response is mostly correct, accurate, and factual. It provides a relevant and coherent answer to the question, mentioning the metric card as the place to see how to use a dataset's dedicated evaluation function. However, the response is not a direct and concise answer to the question, but rather a lengthy passage that includes extraneous information.",
        "rag_context": [
            {
                "score": 0.6804417917771584,
                "node_text": "Here are some facts extracted from the provided text:\n\nHuggingface ecosystem -> Includes -> Transformers and datasets\n\n!--Copyright 2023 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\nthe License. You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under the License is distributed on\nan \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n\n\u26a0\ufe0f Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be\nrendered properly in your Markdown viewer.\n\n-->\n\n# Training on TPU with TensorFlow\n\n<Tip>\n\nIf you don't need long explanations and just want TPU code samples to get started with, check out [our TPU example notebook!](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb)\n\n</Tip>\n\n### What is a TPU?\n\nA TPU is a **Tensor Processing Unit.** They are hardware designed by Google, which are used to greatly speed up the tensor computations within neural networks, much like GPUs. They can be used for both network training and inference. They are generally accessed through Google\u2019s cloud services, but small TPUs can also be accessed directly for free through Google Colab and Kaggle Kernels.\n\nBecause [all TensorFlow models in \ud83e\udd17 Transformers are Keras models](https://huggingface.co/blog/tensorflow-philosophy), most of the methods in this document are generally applicable to TPU training for any Keras model! However, there are a few points that are specific to the HuggingFace ecosystem (hug-o-system?) of Transformers and Datasets, and we\u2019ll make sure to flag them up when we get to them.\n\n### What kinds of TPU are available?\n\nNew users are often very confused by the range of TPUs, and the different ways to access them. The first key distinction to understand is the difference between **TPU Nodes** and **TPU VMs.**\n\nWhen you use a **TPU Node**, you are effectively indirectly accessing a remote TPU. You will need a separate VM, which will initialize your network and data pipeline and then forward them to the remote node. When you use a TPU on Google Colab, you are accessing it in the **TPU Node** style.\n\nUsing TPU Nodes can have some quite unexpected behaviour for people who aren\u2019t used to them! In particular, because the TPU is located on a physically different system to the machine you\u2019re running your Python code on, your data cannot be local to your machine - any data pipeline that loads from your machine\u2019s internal storage will totally fail! Instead, data must be stored in Google Cloud Storage where your data pipeline can still access it, even when the pipeline is running on the remote TPU node.\n\n<Tip>\n\nIf you can fit all your data in memory as `np.ndarray` or `tf.Tensor`, then you can `fit()` on that data even when using Colab or a TPU Node, without needing to upload it to Google Cloud Storage.\n\n</Tip>\n\n<Tip>\n\n**\ud83e\udd17Specific Hugging Face Tip\ud83e\udd17:** The methods `Dataset.to_tf_dataset()` and its higher-level wrapper `model.prepare_tf_dataset()` , which you will see throughout our TF code examples, will both fail on a TPU Node. The reason for this is that even though they create a `tf.data.Dataset` it is not a \u201cpure\u201d `tf.data` pipeline and uses `tf.numpy_function` or `Dataset.from_generator()` to stream data from the underlying HuggingFace `Dataset`. This HuggingFace `Dataset` is backed by data that is on a local disc and which the remote TPU Node will not be able to read.\n\n</Tip>\n\nThe second way to access a TPU is via a **TPU VM.** When using a TPU VM, you connect directly to the machine that the TPU is attached to, much like training on a GPU VM. TPU VMs are generally easier to work with, particularly when it comes to your data pipeline. All of the above warnings do not apply to TPU VMs!\n\nThis is an opinionated document, so here\u2019s our opinion: **Avoid using TPU Node if possible.** It is more confusing and more difficult to debug than TPU VMs. It is also likely to be unsupported in future - Google\u2019s latest TPU, TPUv4, can only be accessed as a TPU VM, which suggests that TPU Nodes are increasingly going to become a \u201clegacy\u201d access method."
            },
            {
                "score": 0.6150390151960704,
                "node_text": "Here are some facts extracted from the provided text:\n\nGlue benchmark -> Has -> Dedicated evaluation metric\nMetric -> Is -> Evaluation metric\n\nChoosing a metric for your task\n\n**So you've trained your model and want to see how well it\u2019s doing on a dataset of your choice. Where do you start?**\n\nThere is no \u201cone size fits all\u201d approach to choosing an evaluation metric, but some good guidelines to keep in mind are:\n\n## Categories of metrics\n\nThere are 3 high-level categories of metrics:\n\n1. *Generic metrics*, which can be applied to a variety of situations and datasets, such as precision and accuracy.\n2. *Task-specific metrics*, which are limited to a given task, such as Machine Translation (often evaluated using metrics [BLEU](https://huggingface.co/metrics/bleu) or [ROUGE](https://huggingface.co/metrics/rouge)) or Named Entity Recognition (often evaluated with [seqeval](https://huggingface.co/metrics/seqeval)).\n3. *Dataset-specific metrics*, which aim to measure model performance on specific benchmarks: for instance, the [GLUE benchmark](https://huggingface.co/datasets/glue) has a dedicated [evaluation metric](https://huggingface.co/metrics/glue).\n\nLet's look at each of these three cases:\n\n### Generic metrics\n\nMany of the metrics used in the Machine Learning community are quite generic and can be applied in a variety of tasks and datasets.\n\nThis is the case for metrics like [accuracy](https://huggingface.co/metrics/accuracy) and [precision](https://huggingface.co/metrics/precision), which can be used for evaluating labeled (supervised) datasets, as well as [perplexity](https://huggingface.co/metrics/perplexity), which can be used for evaluating different kinds of (unsupervised) generative tasks.\n\nTo see the input structure of a given metric, you can look at its metric card. For example, in the case of [precision](https://huggingface.co/metrics/precision), the format is:\n```\n>>> precision_metric = evaluate.load(\"precision\")\n>>> results = precision_metric.compute(references=[0, 1], predictions=[0, 1])\n>>> print(results)\n{'precision': 1.0}\n```\n\n### Task-specific metrics\n\nPopular ML tasks like Machine Translation and Named Entity Recognition have specific metrics that can be used to compare models. For example, a series of different metrics have been proposed for text generation, ranging from [BLEU](https://huggingface.co/metrics/bleu) and its derivatives such as [GoogleBLEU](https://huggingface.co/metrics/google_bleu) and [GLEU](https://huggingface.co/metrics/gleu), but also [ROUGE](https://huggingface.co/metrics/rouge), [MAUVE](https://huggingface.co/metrics/mauve), etc.\n\nYou can find the right metric for your task by:\n\n- **Looking at the [Task pages](https://huggingface.co/tasks)** to see what metrics can be used for evaluating models for a given task.\n- **Checking out leaderboards** on sites like [Papers With Code](https://paperswithcode.com/) (you can search by task and by dataset).\n-  **Reading the metric cards** for the relevant metrics and see which ones are a good fit for your use case. For example, see the [BLEU metric card](https://github.com/huggingface/evaluate/tree/main/metrics/bleu) or [SQuaD metric card](https://github.com/huggingface/evaluate/tree/main/metrics/squad).\n- **Looking at papers and blog posts** published on the topic and see what metrics they report. This can change over time, so try to pick papers from the last couple of years!\n\n### Dataset-specific metrics\n\nSome datasets have specific metrics associated with them -- this is especially in the case of popular benchmarks like [GLUE](https://huggingface.co/metrics/glue) and [SQuAD](https://huggingface.co/metrics/squad).\n\n<Tip warning={true}>\n\ud83d\udca1\nGLUE is actually a collection of different subsets on different tasks, so first you need to choose the one that corresponds to the NLI task, such as mnli, which is described as \u201ccrowdsourced collection of sentence pairs with textual entailment annotations\u201d\n</Tip>"
            },
            {
                "score": 0.6021709830861959,
                "node_text": "Here are some facts extracted from the provided text:\n\nRule #1 -> Prohibits -> Data-dependent conditionals\n\nWe\u2019ve distilled them into three core rules below:\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** We\u2019ve put a lot of effort into rewriting our TensorFlow models and loss functions to be XLA-compatible. Our models and loss functions generally obey rule #1 and #2 by default, so you can skip over them if you\u2019re using `transformers` models. Don\u2019t forget about these rules when writing your own models and loss functions, though!\n\n</Tip>\n\n#### XLA Rule #1: Your code cannot have \u201cdata-dependent conditionals\u201d\n\nWhat that means is that any `if` statement cannot depend on values inside a `tf.Tensor`. For example, this code block cannot be compiled with XLA!\n\n```python\nif tf.reduce_sum(tensor) > 10:\n    tensor = tensor / 2.0\n```\n\nThis might seem very restrictive at first, but most neural net code doesn\u2019t need to do this. You can often get around this restriction by using `tf.cond` (see the documentation [here](https://www.tensorflow.org/api_docs/python/tf/cond)) or by removing the conditional and finding a clever math trick with indicator variables instead, like so:\n\n```python\nsum_over_10 = tf.cast(tf.reduce_sum(tensor) > 10, tf.float32)\ntensor = tensor / (1.0 + sum_over_10)\n```\n\nThis code has exactly the same effect as the code above, but by avoiding a conditional, we ensure it will compile with XLA without problems!\n\n#### XLA Rule #2: Your code cannot have \u201cdata-dependent shapes\u201d\n\nWhat this means is that the shape of all of the `tf.Tensor` objects in your code cannot depend on their values. For example, the function `tf.unique` cannot be compiled with XLA, because it returns a `tensor` containing one instance of each unique value in the input. The shape of this output will obviously be different depending on how repetitive the input `Tensor` was, and so XLA refuses to handle it!\n\nIn general, most neural network code obeys rule #2 by default. However, there are a few common cases where it becomes a problem. One very common one is when you use **label masking**, setting your labels to a negative value to indicate that those positions should be ignored when computing the loss. If you look at NumPy or PyTorch loss functions that support label masking, you will often see code like this that uses [boolean indexing](https://numpy.org/doc/stable/user/basics.indexing.html#boolean-array-indexing):\n\n```python\nlabel_mask = labels >= 0\nmasked_outputs = outputs[label_mask]\nmasked_labels = labels[label_mask]\nloss = compute_loss(masked_outputs, masked_labels)\nmean_loss = torch.mean(loss)\n```\n\nThis code is totally fine in NumPy or PyTorch, but it breaks in XLA! Why? Because the shape of `masked_outputs` and `masked_labels` depends on how many positions are masked - that makes it a **data-dependent shape.** However, just like for rule #1, we can often rewrite this code to yield exactly the same output without any data-dependent shapes.\n\n```python\nlabel_mask = tf.cast(labels >= 0, tf.float32)\nloss = compute_loss(outputs, labels)\nloss = loss * label_mask  # Set negative label positions to 0\nmean_loss = tf.reduce_sum(loss) / tf.reduce_sum(label_mask)\n```\n\nHere, we avoid data-dependent shapes by computing the loss for every position, but zeroing out the masked positions in both the numerator and denominator when we calculate the mean, which yields exactly the same result as the first block while maintaining XLA compatibility. Note that we use the same trick as in rule #1 - converting a `tf.bool` to `tf.float32` and using it as an indicator variable. This is a really useful trick, so remember it if you need to convert your own code to XLA!\n\n#### XLA Rule #3: XLA will need to recompile your model for every different input shape it sees\n\nThis is the big one. What this means is that if your input shapes are very variable, XLA will have to recompile your model over and over, which will create huge performance problems. This commonly arises in NLP models, where input texts have variable lengths after tokenization. In other modalities, static shapes are more common and this rule is much less of a problem.\n\nHow can you get around rule #3? The key is **padding** - if you pad all your inputs to the same length, and then use an `attention_mask`, you can get the same results as you\u2019d get from variable shapes, but without any XLA issues."
            },
            {
                "score": 0.601705794813942,
                "node_text": "Here are some facts extracted from the provided text:\n\nSquad -> Has -> Evaluation metric\nEvaluation metric -> Requires -> Format\n\nIf you are evaluating your model on a benchmark dataset like the ones mentioned above, you can use its dedicated evaluation metric. Make sure you respect the format that they require. For example, to evaluate your model on the [SQuAD](https://huggingface.co/datasets/squad) dataset, you need to feed the `question` and `context` into your model and return the `prediction_text`, which should be compared with the `references` (based on matching the `id` of the question) :\n\n```\n>>> from evaluate import load\n>>> squad_metric = load(\"squad\")\n>>> predictions = [{'prediction_text': '1976', 'id': '56e10a3be3433e1400422b22'}]\n>>> references = [{'answers': {'answer_start': [97], 'text': ['1976']}, 'id': '56e10a3be3433e1400422b22'}]\n>>> results = squad_metric.compute(predictions=predictions, references=references)\n>>> results\n{'exact_match': 100.0, 'f1': 100.0}\n```\n\nYou can find examples of dataset structures by consulting the \"Dataset Preview\" function or the dataset card for a given dataset, and you can see how to use its dedicated evaluation function based on the metric card."
            }
        ]
    },
    {
        "sample_idx": 23,
        "question": "What is the purpose of using the `queue()` method in Gradio?",
        "answer": "To control the processing rate and handle a large amount of traffic.",
        "rag_answer": "The purpose of using the `queue()` method in Gradio is to control the number of requests processed at once, allowing you to specify the concurrency count and control the processing rate.",
        "rag_score": 4,
        "rag_feedback": "The system's response is mostly correct, accurate, and factual. It provides a clear explanation of the purpose of the `queue()` method in Gradio, which is to control the number of requests processed at once, allowing you to specify the concurrency count and control the processing rate. The response also provides additional information about Gradio's features, such as iterative outputs, progress bars, and batch functions, but these are not directly related to the question.",
        "rag_context": [
            {
                "score": 0.6831098082113426,
                "node_text": "Here are some facts extracted from the provided text:\n\nGr -> Is -> Alias of gradio\nDemo -> Has method -> Queue\nGradio -> Provides -> Pre-built themes\nGradio -> Is -> Library\nGradio -> Supports -> Iterative outputs\nGradio -> Has feature -> \u6dfb\u52a0\u63cf\u8ff0\u5185\u5bb9\nGradio -> Converts -> Data format\nGradio -> Has feature -> \u8fdb\u5ea6\u6761\nGradio -> Automatically handles -> Preprocessing\nGradio -> Has feature -> \u8bbe\u7f6e\u65d7\u6807\nGradio -> Has feature -> \u8fed\u4ee3\u8f93\u51fa\nGradio -> Has feature -> \u9884\u5904\u7406\u548c\u540e\u5904\u7406\nGradio -> Installed by -> Pip\nGradio -> Has feature -> \u6392\u961f\u7528\u6237\nGradio -> Recognizes -> Data format\nGradio -> Automatically handles -> Postprocessing\nGradio -> Supports -> Hugging face models\nGradio -> Supports -> Batch functions\nGradio -> Enables -> Parallel processing\nGradio -> Has feature -> \u6279\u5904\u7406\u51fd\u6570\nGradio -> Has feature -> \u4f20\u9012\u81ea\u5b9a\u4e49\u9519\u8bef\u6d88\u606f\nGradio -> Can run -> In colab notebooks\nGradio -> Supports -> Progress bars\nGradio -> Includes -> Components\nGradio -> Has feature -> \u6837\u5f0f\u5316\u6f14\u793a\nGradio -> Has feature -> \u6dfb\u52a0\u793a\u4f8b\u8f93\u5165\n\nGradio Demo: blocks_random_slider\n\n\n```\n!pip install -q gradio \n```\n\n\n```\n\nimport gradio as gr\n\n\ndef func(slider_1, slider_2):\n    return slider_1 * 5 + slider_2\n\n\nwith gr.Blocks() as demo:\n    slider = gr.Slider(minimum=-10.2, maximum=15, label=\"Random Slider (Static)\", randomize=True)\n    slider_1 = gr.Slider(minimum=100, maximum=200, label=\"Random Slider (Input 1)\", randomize=True)\n    slider_2 = gr.Slider(minimum=10, maximum=23.2, label=\"Random Slider (Input 2)\", randomize=True)\n    slider_3 = gr.Slider(value=3, label=\"Non random slider\")\n    btn = gr.Button(\"Run\")\n    btn.click(func, inputs=[slider_1, slider_2], outputs=gr.Number())\n\nif __name__ == \"__main__\":\n    demo.launch()\n\n```"
            },
            {
                "score": 0.6708785258268846,
                "node_text": "Here are some facts extracted from the provided text:\n\nClick -> Has parameter -> Queue\nQueue -> Has parameter -> Concurrency_count\nQueue -> Controls -> Processing rate\nGenerator function -> Is -> Provided to gradio\n\nBlocks() as demo\uff1a\n    #.\ndemo.queue()\ndemo.launch()\n```\n\n\u60a8\u53ef\u4ee5\u901a\u8fc7\u4ee5\u4e0b\u65b9\u5f0f\u63a7\u5236\u4e00\u6b21\u5904\u7406\u7684\u8bf7\u6c42\u6570\u91cf\uff1a\n\n```python\ndemo.queue(concurrency_count=3)\n```\n\n\u67e5\u770b\u6709\u5173\u914d\u7f6e\u5176\u4ed6\u961f\u5217\u53c2\u6570\u7684[\u961f\u5217\u6587\u6863](/docs/#queue)\u3002\n\n\u5728 Blocks \u4e2d\u6307\u5b9a\u4ec5\u5bf9\u67d0\u4e9b\u51fd\u6570\u8fdb\u884c\u6392\u961f\uff1a\n\n```python\nwith gr.Blocks() as demo2\uff1a\n    num1 = gr.Number()\n    num2 = gr.Number()\n    output = gr.Number()\n    gr.Button(\"Add\").click(\n        lambda a, b: a + b, [num1, num2], output)\n    gr.Button(\"Multiply\").click(\n        lambda a, b: a * b, [num1, num2], output, queue=True)\ndemo2.launch()\n```\n\n## \u8fed\u4ee3\u8f93\u51fa (Iterative Outputs)\n\n\u5728\u67d0\u4e9b\u60c5\u51b5\u4e0b\uff0c\u60a8\u53ef\u80fd\u9700\u8981\u4f20\u8f93\u4e00\u7cfb\u5217\u8f93\u51fa\u800c\u4e0d\u662f\u4e00\u6b21\u663e\u793a\u5355\u4e2a\u8f93\u51fa\u3002\u4f8b\u5982\uff0c\u60a8\u53ef\u80fd\u6709\u4e00\u4e2a\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5e0c\u671b\u663e\u793a\u751f\u6210\u7684\u6bcf\u4e2a\u6b65\u9aa4\u7684\u56fe\u50cf\uff0c\u76f4\u5230\u6700\u7ec8\u56fe\u50cf\u3002\u6216\u8005\u60a8\u53ef\u80fd\u6709\u4e00\u4e2a\u804a\u5929\u673a\u5668\u4eba\uff0c\u5b83\u9010\u5b57\u9010\u53e5\u5730\u6d41\u5f0f\u4f20\u8f93\u54cd\u5e94\uff0c\u800c\u4e0d\u662f\u4e00\u6b21\u8fd4\u56de\u5168\u90e8\u54cd\u5e94\u3002\n\n\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u60a8\u53ef\u4ee5\u5c06**\u751f\u6210\u5668**\u51fd\u6570\u63d0\u4f9b\u7ed9 Gradio\uff0c\u800c\u4e0d\u662f\u5e38\u89c4\u51fd\u6570\u3002\u5728 Python \u4e2d\u521b\u5efa\u751f\u6210\u5668\u975e\u5e38\u7b80\u5355\uff1a\u51fd\u6570\u4e0d\u5e94\u8be5\u6709\u4e00\u4e2a\u5355\u72ec\u7684 `return` \u503c\uff0c\u800c\u662f\u5e94\u8be5 with `yield` \u8fde\u7eed\u8fd4\u56de\u4e00\u7cfb\u5217\u503c\u3002\u901a\u5e38\uff0c`yield` \u8bed\u53e5\u653e\u7f6e\u5728\u67d0\u79cd\u5faa\u73af\u4e2d\u3002\u4e0b\u9762\u662f\u4e00\u4e2a\u7b80\u5355\u793a\u4f8b\uff0c\u751f\u6210\u5668\u53ea\u662f\u7b80\u5355\u8ba1\u6570\u5230\u7ed9\u5b9a\u6570\u5b57\uff1a\n\n```python\ndef my_generator(x):\n    for i in range(x):\n        yield i\n```\n\n\u60a8\u4ee5\u4e0e\u5e38\u89c4\u51fd\u6570\u76f8\u540c\u7684\u65b9\u5f0f\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio\u3002\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\uff08\u865a\u62df\u7684\uff09\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5b83\u5728\u8f93\u51fa\u56fe\u50cf\u4e4b\u524d\u751f\u6210\u6570\u4e2a\u6b65\u9aa4\u7684\u566a\u97f3\uff1a\n\n$code_fake_diffusion\n$demo_fake_diffusion\n\n\u8bf7\u6ce8\u610f\uff0c\u6211\u4eec\u5728\u8fed\u4ee3\u5668\u4e2d\u6dfb\u52a0\u4e86 `time.sleep(1)`\uff0c\u4ee5\u521b\u5efa\u6b65\u9aa4\u4e4b\u95f4\u7684\u4eba\u5de5\u6682\u505c\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u89c2\u5bdf\u8fed\u4ee3\u5668\u7684\u6b65\u9aa4\uff08\u5728\u771f\u5b9e\u7684\u56fe\u50cf\u751f\u6210\u6a21\u578b\u4e2d\uff0c\u8fd9\u53ef\u80fd\u662f\u4e0d\u5fc5\u8981\u7684\uff09\u3002\n\n\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio **\u9700\u8981**\u5728\u5e95\u5c42 Interface \u6216 Blocks \u4e2d\u542f\u7528\u961f\u5217\uff08\u8bf7\u53c2\u9605\u4e0a\u9762\u7684\u961f\u5217\u90e8\u5206\uff09\u3002\n\n## \u8fdb\u5ea6\u6761\n\nGradio \u652f\u6301\u521b\u5efa\u81ea\u5b9a\u4e49\u8fdb\u5ea6\u6761\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u81ea\u5b9a\u4e49\u548c\u63a7\u5236\u5411\u7528\u6237\u663e\u793a\u7684\u8fdb\u5ea6\u66f4\u65b0\u3002\u8981\u542f\u7528\u6b64\u529f\u80fd\uff0c\u53ea\u9700\u4e3a\u65b9\u6cd5\u6dfb\u52a0\u4e00\u4e2a\u9ed8\u8ba4\u503c\u4e3a `gr.Progress` \u5b9e\u4f8b\u7684\u53c2\u6570\u5373\u53ef\u3002\u7136\u540e\uff0c\u60a8\u53ef\u4ee5\u76f4\u63a5\u8c03\u7528\u6b64\u5b9e\u4f8b\u5e76\u4f20\u5165 0 \u5230 1 \u4e4b\u95f4\u7684\u6d6e\u70b9\u6570\u6765\u66f4\u65b0\u8fdb\u5ea6\u7ea7\u522b\uff0c\u6216\u8005 with `Progress` \u5b9e\u4f8b\u7684 `tqdm()` \u65b9\u6cd5\u6765\u8ddf\u8e2a\u53ef\u8fed\u4ee3\u5bf9\u8c61\u4e0a\u7684\u8fdb\u5ea6\uff0c\u5982\u4e0b\u6240\u793a\u3002\u5fc5\u987b\u542f\u7528\u961f\u5217\u4ee5\u8fdb\u884c\u8fdb\u5ea6\u66f4\u65b0\u3002\n\n$code_progress_simple\n$demo_progress_simple\n\n\u5982\u679c\u60a8 with `tqdm` \u5e93\uff0c\u5e76\u4e14\u5e0c\u671b\u4ece\u51fd\u6570\u5185\u90e8\u7684\u4efb\u4f55 `tqdm.tqdm` \u81ea\u52a8\u62a5\u544a\u8fdb\u5ea6\u66f4\u65b0\uff0c\u8bf7\u5c06\u9ed8\u8ba4\u53c2\u6570\u8bbe\u7f6e\u4e3a `gr.Progress(track_tqdm=True)`\uff01\n\n## \u6279\u5904\u7406\u51fd\u6570 (Batch Functions)\n\nGradio \u652f\u6301\u4f20\u9012*\u6279\u5904\u7406*\u51fd\u6570\u3002\u6279\u5904\u7406\u51fd\u6570\u53ea\u662f\u63a5\u53d7\u8f93\u5165\u5217\u8868\u5e76\u8fd4\u56de\u9884\u6d4b\u5217\u8868\u7684\u51fd\u6570\u3002\n\n\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\u6279\u5904\u7406\u51fd\u6570\uff0c\u5b83\u63a5\u53d7\u4e24\u4e2a\u8f93\u5165\u5217\u8868\uff08\u4e00\u4e2a\u5355\u8bcd\u5217\u8868\u548c\u4e00\u4e2a\u6574\u6570\u5217\u8868\uff09\uff0c\u5e76\u8fd4\u56de\u4fee\u526a\u8fc7\u7684\u5355\u8bcd\u5217\u8868\u4f5c\u4e3a\u8f93\u51fa\uff1a\n\n```python\nimport time\n\ndef trim_words(words, lens):\n    trimmed_words = []\n    time.sleep(5)\n    for w, l in zip(words, lens):\n        trimmed_words.append(w[:int(l)])\n    return [trimmed_words]\n    for w, l in zip(words,"
            }
        ]
    },
    {
        "sample_idx": 24,
        "question": "How can you specify the number of requests to process at once in Gradio?",
        "answer": "By using the `concurrency_count` parameter, for example: `demo.queue(concurrency_count=3)`.",
        "rag_answer": "You can specify the number of requests to process at once in Gradio by using the `queue` method with the `concurrency_count` parameter. For example, `demo.queue(concurrency_count=3)` would process 3 requests at a time.",
        "rag_score": 5,
        "rag_feedback": "The response is completely correct, accurate, and factual. It provides the exact syntax and example of how to specify the number of requests to process at once in Gradio using the `concurrency_count` parameter.",
        "rag_context": [
            {
                "score": 0.6640950119773621,
                "node_text": "Here are some facts extracted from the provided text:\n\nGr -> Is -> Alias of gradio\nGradio -> Provides -> Pre-built themes\nGradio -> Is -> Library\nGradio -> Supports -> Iterative outputs\nGradio -> Has feature -> \u6dfb\u52a0\u63cf\u8ff0\u5185\u5bb9\nGradio -> Converts -> Data format\nGradio -> Has feature -> \u8fdb\u5ea6\u6761\nGradio -> Automatically handles -> Preprocessing\nGradio -> Has feature -> \u8bbe\u7f6e\u65d7\u6807\nGradio -> Has feature -> \u8fed\u4ee3\u8f93\u51fa\nGradio -> Has feature -> \u9884\u5904\u7406\u548c\u540e\u5904\u7406\nGradio -> Installed by -> Pip\nGradio -> Has feature -> \u6392\u961f\u7528\u6237\nGradio -> Recognizes -> Data format\nGradio -> Automatically handles -> Postprocessing\nGradio -> Supports -> Hugging face models\nGradio -> Supports -> Batch functions\nGradio -> Enables -> Parallel processing\nGradio -> Has feature -> \u6279\u5904\u7406\u51fd\u6570\nGradio -> Has feature -> \u4f20\u9012\u81ea\u5b9a\u4e49\u9519\u8bef\u6d88\u606f\nGradio -> Can run -> In colab notebooks\nGradio -> Supports -> Progress bars\nGradio -> Includes -> Components\nGradio -> Has feature -> \u6837\u5f0f\u5316\u6f14\u793a\nGradio -> Has feature -> \u6dfb\u52a0\u793a\u4f8b\u8f93\u5165\n\nGradio Demo: blocks_random_slider\n\n\n```\n!pip install -q gradio \n```\n\n\n```\n\nimport gradio as gr\n\n\ndef func(slider_1, slider_2):\n    return slider_1 * 5 + slider_2\n\n\nwith gr.Blocks() as demo:\n    slider = gr.Slider(minimum=-10.2, maximum=15, label=\"Random Slider (Static)\", randomize=True)\n    slider_1 = gr.Slider(minimum=100, maximum=200, label=\"Random Slider (Input 1)\", randomize=True)\n    slider_2 = gr.Slider(minimum=10, maximum=23.2, label=\"Random Slider (Input 2)\", randomize=True)\n    slider_3 = gr.Slider(value=3, label=\"Non random slider\")\n    btn = gr.Button(\"Run\")\n    btn.click(func, inputs=[slider_1, slider_2], outputs=gr.Number())\n\nif __name__ == \"__main__\":\n    demo.launch()\n\n```"
            },
            {
                "score": 0.6339250573261479,
                "node_text": "Here are some facts extracted from the provided text:\n\nGenerator function -> Is -> Provided to gradio\n\nBlocks() as demo\uff1a\n    #.\ndemo.queue()\ndemo.launch()\n```\n\n\u60a8\u53ef\u4ee5\u901a\u8fc7\u4ee5\u4e0b\u65b9\u5f0f\u63a7\u5236\u4e00\u6b21\u5904\u7406\u7684\u8bf7\u6c42\u6570\u91cf\uff1a\n\n```python\ndemo.queue(concurrency_count=3)\n```\n\n\u67e5\u770b\u6709\u5173\u914d\u7f6e\u5176\u4ed6\u961f\u5217\u53c2\u6570\u7684[\u961f\u5217\u6587\u6863](/docs/#queue)\u3002\n\n\u5728 Blocks \u4e2d\u6307\u5b9a\u4ec5\u5bf9\u67d0\u4e9b\u51fd\u6570\u8fdb\u884c\u6392\u961f\uff1a\n\n```python\nwith gr.Blocks() as demo2\uff1a\n    num1 = gr.Number()\n    num2 = gr.Number()\n    output = gr.Number()\n    gr.Button(\"Add\").click(\n        lambda a, b: a + b, [num1, num2], output)\n    gr.Button(\"Multiply\").click(\n        lambda a, b: a * b, [num1, num2], output, queue=True)\ndemo2.launch()\n```\n\n## \u8fed\u4ee3\u8f93\u51fa (Iterative Outputs)\n\n\u5728\u67d0\u4e9b\u60c5\u51b5\u4e0b\uff0c\u60a8\u53ef\u80fd\u9700\u8981\u4f20\u8f93\u4e00\u7cfb\u5217\u8f93\u51fa\u800c\u4e0d\u662f\u4e00\u6b21\u663e\u793a\u5355\u4e2a\u8f93\u51fa\u3002\u4f8b\u5982\uff0c\u60a8\u53ef\u80fd\u6709\u4e00\u4e2a\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5e0c\u671b\u663e\u793a\u751f\u6210\u7684\u6bcf\u4e2a\u6b65\u9aa4\u7684\u56fe\u50cf\uff0c\u76f4\u5230\u6700\u7ec8\u56fe\u50cf\u3002\u6216\u8005\u60a8\u53ef\u80fd\u6709\u4e00\u4e2a\u804a\u5929\u673a\u5668\u4eba\uff0c\u5b83\u9010\u5b57\u9010\u53e5\u5730\u6d41\u5f0f\u4f20\u8f93\u54cd\u5e94\uff0c\u800c\u4e0d\u662f\u4e00\u6b21\u8fd4\u56de\u5168\u90e8\u54cd\u5e94\u3002\n\n\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u60a8\u53ef\u4ee5\u5c06**\u751f\u6210\u5668**\u51fd\u6570\u63d0\u4f9b\u7ed9 Gradio\uff0c\u800c\u4e0d\u662f\u5e38\u89c4\u51fd\u6570\u3002\u5728 Python \u4e2d\u521b\u5efa\u751f\u6210\u5668\u975e\u5e38\u7b80\u5355\uff1a\u51fd\u6570\u4e0d\u5e94\u8be5\u6709\u4e00\u4e2a\u5355\u72ec\u7684 `return` \u503c\uff0c\u800c\u662f\u5e94\u8be5 with `yield` \u8fde\u7eed\u8fd4\u56de\u4e00\u7cfb\u5217\u503c\u3002\u901a\u5e38\uff0c`yield` \u8bed\u53e5\u653e\u7f6e\u5728\u67d0\u79cd\u5faa\u73af\u4e2d\u3002\u4e0b\u9762\u662f\u4e00\u4e2a\u7b80\u5355\u793a\u4f8b\uff0c\u751f\u6210\u5668\u53ea\u662f\u7b80\u5355\u8ba1\u6570\u5230\u7ed9\u5b9a\u6570\u5b57\uff1a\n\n```python\ndef my_generator(x):\n    for i in range(x):\n        yield i\n```\n\n\u60a8\u4ee5\u4e0e\u5e38\u89c4\u51fd\u6570\u76f8\u540c\u7684\u65b9\u5f0f\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio\u3002\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\uff08\u865a\u62df\u7684\uff09\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5b83\u5728\u8f93\u51fa\u56fe\u50cf\u4e4b\u524d\u751f\u6210\u6570\u4e2a\u6b65\u9aa4\u7684\u566a\u97f3\uff1a\n\n$code_fake_diffusion\n$demo_fake_diffusion\n\n\u8bf7\u6ce8\u610f\uff0c\u6211\u4eec\u5728\u8fed\u4ee3\u5668\u4e2d\u6dfb\u52a0\u4e86 `time.sleep(1)`\uff0c\u4ee5\u521b\u5efa\u6b65\u9aa4\u4e4b\u95f4\u7684\u4eba\u5de5\u6682\u505c\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u89c2\u5bdf\u8fed\u4ee3\u5668\u7684\u6b65\u9aa4\uff08\u5728\u771f\u5b9e\u7684\u56fe\u50cf\u751f\u6210\u6a21\u578b\u4e2d\uff0c\u8fd9\u53ef\u80fd\u662f\u4e0d\u5fc5\u8981\u7684\uff09\u3002\n\n\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio **\u9700\u8981**\u5728\u5e95\u5c42 Interface \u6216 Blocks \u4e2d\u542f\u7528\u961f\u5217\uff08\u8bf7\u53c2\u9605\u4e0a\u9762\u7684\u961f\u5217\u90e8\u5206\uff09\u3002\n\n## \u8fdb\u5ea6\u6761\n\nGradio \u652f\u6301\u521b\u5efa\u81ea\u5b9a\u4e49\u8fdb\u5ea6\u6761\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u81ea\u5b9a\u4e49\u548c\u63a7\u5236\u5411\u7528\u6237\u663e\u793a\u7684\u8fdb\u5ea6\u66f4\u65b0\u3002\u8981\u542f\u7528\u6b64\u529f\u80fd\uff0c\u53ea\u9700\u4e3a\u65b9\u6cd5\u6dfb\u52a0\u4e00\u4e2a\u9ed8\u8ba4\u503c\u4e3a `gr.Progress` \u5b9e\u4f8b\u7684\u53c2\u6570\u5373\u53ef\u3002\u7136\u540e\uff0c\u60a8\u53ef\u4ee5\u76f4\u63a5\u8c03\u7528\u6b64\u5b9e\u4f8b\u5e76\u4f20\u5165 0 \u5230 1 \u4e4b\u95f4\u7684\u6d6e\u70b9\u6570\u6765\u66f4\u65b0\u8fdb\u5ea6\u7ea7\u522b\uff0c\u6216\u8005 with `Progress` \u5b9e\u4f8b\u7684 `tqdm()` \u65b9\u6cd5\u6765\u8ddf\u8e2a\u53ef\u8fed\u4ee3\u5bf9\u8c61\u4e0a\u7684\u8fdb\u5ea6\uff0c\u5982\u4e0b\u6240\u793a\u3002\u5fc5\u987b\u542f\u7528\u961f\u5217\u4ee5\u8fdb\u884c\u8fdb\u5ea6\u66f4\u65b0\u3002\n\n$code_progress_simple\n$demo_progress_simple\n\n\u5982\u679c\u60a8 with `tqdm` \u5e93\uff0c\u5e76\u4e14\u5e0c\u671b\u4ece\u51fd\u6570\u5185\u90e8\u7684\u4efb\u4f55 `tqdm.tqdm` \u81ea\u52a8\u62a5\u544a\u8fdb\u5ea6\u66f4\u65b0\uff0c\u8bf7\u5c06\u9ed8\u8ba4\u53c2\u6570\u8bbe\u7f6e\u4e3a `gr.Progress(track_tqdm=True)`\uff01\n\n## \u6279\u5904\u7406\u51fd\u6570 (Batch Functions)\n\nGradio \u652f\u6301\u4f20\u9012*\u6279\u5904\u7406*\u51fd\u6570\u3002\u6279\u5904\u7406\u51fd\u6570\u53ea\u662f\u63a5\u53d7\u8f93\u5165\u5217\u8868\u5e76\u8fd4\u56de\u9884\u6d4b\u5217\u8868\u7684\u51fd\u6570\u3002\n\n\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\u6279\u5904\u7406\u51fd\u6570\uff0c\u5b83\u63a5\u53d7\u4e24\u4e2a\u8f93\u5165\u5217\u8868\uff08\u4e00\u4e2a\u5355\u8bcd\u5217\u8868\u548c\u4e00\u4e2a\u6574\u6570\u5217\u8868\uff09\uff0c\u5e76\u8fd4\u56de\u4fee\u526a\u8fc7\u7684\u5355\u8bcd\u5217\u8868\u4f5c\u4e3a\u8f93\u51fa\uff1a\n\n```python\nimport time\n\ndef trim_words(words, lens):\n    trimmed_words = []\n    time.sleep(5)\n    for w, l in zip(words, lens):\n        trimmed_words.append(w[:int(l)])\n    return [trimmed_words]\n    for w, l in zip(words,"
            }
        ]
    },
    {
        "sample_idx": 25,
        "question": "What is required to enable iterative outputs in Gradio?",
        "answer": "Enabling queuing in the underlying Interface or Blocks.",
        "rag_answer": "To enable iterative outputs in Gradio, you need to provide a generator function instead of a regular function, and you must enable queuing in the underlying Interface or Blocks.",
        "rag_score": 4,
        "rag_feedback": "The system's response is mostly correct, accurate, and factual. It provides a detailed explanation of how to enable iterative outputs in Gradio, including the requirement to provide a generator function and enable queuing in the underlying Interface or Blocks. The response also includes relevant code examples and additional information about Gradio's features, such as progress bars and batch functions.",
        "rag_context": [
            {
                "score": 0.7251843693757029,
                "node_text": "Here are some facts extracted from the provided text:\n\nGr -> Is -> Alias of gradio\nGradio -> Provides -> Pre-built themes\nGradio -> Is -> Library\nGradio -> Supports -> Iterative outputs\nGradio -> Has feature -> \u6dfb\u52a0\u63cf\u8ff0\u5185\u5bb9\nGradio -> Converts -> Data format\nGradio -> Has feature -> \u8fdb\u5ea6\u6761\nGradio -> Automatically handles -> Preprocessing\nGradio -> Has feature -> \u8bbe\u7f6e\u65d7\u6807\nGradio -> Has feature -> \u8fed\u4ee3\u8f93\u51fa\nGradio -> Has feature -> \u9884\u5904\u7406\u548c\u540e\u5904\u7406\nGradio -> Installed by -> Pip\nGradio -> Has feature -> \u6392\u961f\u7528\u6237\nGradio -> Recognizes -> Data format\nGradio -> Automatically handles -> Postprocessing\nGradio -> Supports -> Hugging face models\nGradio -> Supports -> Batch functions\nGradio -> Enables -> Parallel processing\nGradio -> Has feature -> \u6279\u5904\u7406\u51fd\u6570\nGradio -> Has feature -> \u4f20\u9012\u81ea\u5b9a\u4e49\u9519\u8bef\u6d88\u606f\nGradio -> Can run -> In colab notebooks\nGradio -> Supports -> Progress bars\nGradio -> Includes -> Components\nGradio -> Has feature -> \u6837\u5f0f\u5316\u6f14\u793a\nGradio -> Has feature -> \u6dfb\u52a0\u793a\u4f8b\u8f93\u5165\n\nGradio Demo: blocks_random_slider\n\n\n```\n!pip install -q gradio \n```\n\n\n```\n\nimport gradio as gr\n\n\ndef func(slider_1, slider_2):\n    return slider_1 * 5 + slider_2\n\n\nwith gr.Blocks() as demo:\n    slider = gr.Slider(minimum=-10.2, maximum=15, label=\"Random Slider (Static)\", randomize=True)\n    slider_1 = gr.Slider(minimum=100, maximum=200, label=\"Random Slider (Input 1)\", randomize=True)\n    slider_2 = gr.Slider(minimum=10, maximum=23.2, label=\"Random Slider (Input 2)\", randomize=True)\n    slider_3 = gr.Slider(value=3, label=\"Non random slider\")\n    btn = gr.Button(\"Run\")\n    btn.click(func, inputs=[slider_1, slider_2], outputs=gr.Number())\n\nif __name__ == \"__main__\":\n    demo.launch()\n\n```"
            },
            {
                "score": 0.6919939860364254,
                "node_text": "Here are some facts extracted from the provided text:\n\nGenerator function -> Is -> Provided to gradio\n\nBlocks() as demo\uff1a\n    #.\ndemo.queue()\ndemo.launch()\n```\n\n\u60a8\u53ef\u4ee5\u901a\u8fc7\u4ee5\u4e0b\u65b9\u5f0f\u63a7\u5236\u4e00\u6b21\u5904\u7406\u7684\u8bf7\u6c42\u6570\u91cf\uff1a\n\n```python\ndemo.queue(concurrency_count=3)\n```\n\n\u67e5\u770b\u6709\u5173\u914d\u7f6e\u5176\u4ed6\u961f\u5217\u53c2\u6570\u7684[\u961f\u5217\u6587\u6863](/docs/#queue)\u3002\n\n\u5728 Blocks \u4e2d\u6307\u5b9a\u4ec5\u5bf9\u67d0\u4e9b\u51fd\u6570\u8fdb\u884c\u6392\u961f\uff1a\n\n```python\nwith gr.Blocks() as demo2\uff1a\n    num1 = gr.Number()\n    num2 = gr.Number()\n    output = gr.Number()\n    gr.Button(\"Add\").click(\n        lambda a, b: a + b, [num1, num2], output)\n    gr.Button(\"Multiply\").click(\n        lambda a, b: a * b, [num1, num2], output, queue=True)\ndemo2.launch()\n```\n\n## \u8fed\u4ee3\u8f93\u51fa (Iterative Outputs)\n\n\u5728\u67d0\u4e9b\u60c5\u51b5\u4e0b\uff0c\u60a8\u53ef\u80fd\u9700\u8981\u4f20\u8f93\u4e00\u7cfb\u5217\u8f93\u51fa\u800c\u4e0d\u662f\u4e00\u6b21\u663e\u793a\u5355\u4e2a\u8f93\u51fa\u3002\u4f8b\u5982\uff0c\u60a8\u53ef\u80fd\u6709\u4e00\u4e2a\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5e0c\u671b\u663e\u793a\u751f\u6210\u7684\u6bcf\u4e2a\u6b65\u9aa4\u7684\u56fe\u50cf\uff0c\u76f4\u5230\u6700\u7ec8\u56fe\u50cf\u3002\u6216\u8005\u60a8\u53ef\u80fd\u6709\u4e00\u4e2a\u804a\u5929\u673a\u5668\u4eba\uff0c\u5b83\u9010\u5b57\u9010\u53e5\u5730\u6d41\u5f0f\u4f20\u8f93\u54cd\u5e94\uff0c\u800c\u4e0d\u662f\u4e00\u6b21\u8fd4\u56de\u5168\u90e8\u54cd\u5e94\u3002\n\n\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u60a8\u53ef\u4ee5\u5c06**\u751f\u6210\u5668**\u51fd\u6570\u63d0\u4f9b\u7ed9 Gradio\uff0c\u800c\u4e0d\u662f\u5e38\u89c4\u51fd\u6570\u3002\u5728 Python \u4e2d\u521b\u5efa\u751f\u6210\u5668\u975e\u5e38\u7b80\u5355\uff1a\u51fd\u6570\u4e0d\u5e94\u8be5\u6709\u4e00\u4e2a\u5355\u72ec\u7684 `return` \u503c\uff0c\u800c\u662f\u5e94\u8be5 with `yield` \u8fde\u7eed\u8fd4\u56de\u4e00\u7cfb\u5217\u503c\u3002\u901a\u5e38\uff0c`yield` \u8bed\u53e5\u653e\u7f6e\u5728\u67d0\u79cd\u5faa\u73af\u4e2d\u3002\u4e0b\u9762\u662f\u4e00\u4e2a\u7b80\u5355\u793a\u4f8b\uff0c\u751f\u6210\u5668\u53ea\u662f\u7b80\u5355\u8ba1\u6570\u5230\u7ed9\u5b9a\u6570\u5b57\uff1a\n\n```python\ndef my_generator(x):\n    for i in range(x):\n        yield i\n```\n\n\u60a8\u4ee5\u4e0e\u5e38\u89c4\u51fd\u6570\u76f8\u540c\u7684\u65b9\u5f0f\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio\u3002\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\uff08\u865a\u62df\u7684\uff09\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5b83\u5728\u8f93\u51fa\u56fe\u50cf\u4e4b\u524d\u751f\u6210\u6570\u4e2a\u6b65\u9aa4\u7684\u566a\u97f3\uff1a\n\n$code_fake_diffusion\n$demo_fake_diffusion\n\n\u8bf7\u6ce8\u610f\uff0c\u6211\u4eec\u5728\u8fed\u4ee3\u5668\u4e2d\u6dfb\u52a0\u4e86 `time.sleep(1)`\uff0c\u4ee5\u521b\u5efa\u6b65\u9aa4\u4e4b\u95f4\u7684\u4eba\u5de5\u6682\u505c\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u89c2\u5bdf\u8fed\u4ee3\u5668\u7684\u6b65\u9aa4\uff08\u5728\u771f\u5b9e\u7684\u56fe\u50cf\u751f\u6210\u6a21\u578b\u4e2d\uff0c\u8fd9\u53ef\u80fd\u662f\u4e0d\u5fc5\u8981\u7684\uff09\u3002\n\n\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio **\u9700\u8981**\u5728\u5e95\u5c42 Interface \u6216 Blocks \u4e2d\u542f\u7528\u961f\u5217\uff08\u8bf7\u53c2\u9605\u4e0a\u9762\u7684\u961f\u5217\u90e8\u5206\uff09\u3002\n\n## \u8fdb\u5ea6\u6761\n\nGradio \u652f\u6301\u521b\u5efa\u81ea\u5b9a\u4e49\u8fdb\u5ea6\u6761\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u81ea\u5b9a\u4e49\u548c\u63a7\u5236\u5411\u7528\u6237\u663e\u793a\u7684\u8fdb\u5ea6\u66f4\u65b0\u3002\u8981\u542f\u7528\u6b64\u529f\u80fd\uff0c\u53ea\u9700\u4e3a\u65b9\u6cd5\u6dfb\u52a0\u4e00\u4e2a\u9ed8\u8ba4\u503c\u4e3a `gr.Progress` \u5b9e\u4f8b\u7684\u53c2\u6570\u5373\u53ef\u3002\u7136\u540e\uff0c\u60a8\u53ef\u4ee5\u76f4\u63a5\u8c03\u7528\u6b64\u5b9e\u4f8b\u5e76\u4f20\u5165 0 \u5230 1 \u4e4b\u95f4\u7684\u6d6e\u70b9\u6570\u6765\u66f4\u65b0\u8fdb\u5ea6\u7ea7\u522b\uff0c\u6216\u8005 with `Progress` \u5b9e\u4f8b\u7684 `tqdm()` \u65b9\u6cd5\u6765\u8ddf\u8e2a\u53ef\u8fed\u4ee3\u5bf9\u8c61\u4e0a\u7684\u8fdb\u5ea6\uff0c\u5982\u4e0b\u6240\u793a\u3002\u5fc5\u987b\u542f\u7528\u961f\u5217\u4ee5\u8fdb\u884c\u8fdb\u5ea6\u66f4\u65b0\u3002\n\n$code_progress_simple\n$demo_progress_simple\n\n\u5982\u679c\u60a8 with `tqdm` \u5e93\uff0c\u5e76\u4e14\u5e0c\u671b\u4ece\u51fd\u6570\u5185\u90e8\u7684\u4efb\u4f55 `tqdm.tqdm` \u81ea\u52a8\u62a5\u544a\u8fdb\u5ea6\u66f4\u65b0\uff0c\u8bf7\u5c06\u9ed8\u8ba4\u53c2\u6570\u8bbe\u7f6e\u4e3a `gr.Progress(track_tqdm=True)`\uff01\n\n## \u6279\u5904\u7406\u51fd\u6570 (Batch Functions)\n\nGradio \u652f\u6301\u4f20\u9012*\u6279\u5904\u7406*\u51fd\u6570\u3002\u6279\u5904\u7406\u51fd\u6570\u53ea\u662f\u63a5\u53d7\u8f93\u5165\u5217\u8868\u5e76\u8fd4\u56de\u9884\u6d4b\u5217\u8868\u7684\u51fd\u6570\u3002\n\n\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\u6279\u5904\u7406\u51fd\u6570\uff0c\u5b83\u63a5\u53d7\u4e24\u4e2a\u8f93\u5165\u5217\u8868\uff08\u4e00\u4e2a\u5355\u8bcd\u5217\u8868\u548c\u4e00\u4e2a\u6574\u6570\u5217\u8868\uff09\uff0c\u5e76\u8fd4\u56de\u4fee\u526a\u8fc7\u7684\u5355\u8bcd\u5217\u8868\u4f5c\u4e3a\u8f93\u51fa\uff1a\n\n```python\nimport time\n\ndef trim_words(words, lens):\n    trimmed_words = []\n    time.sleep(5)\n    for w, l in zip(words, lens):\n        trimmed_words.append(w[:int(l)])\n    return [trimmed_words]\n    for w, l in zip(words,"
            }
        ]
    },
    {
        "sample_idx": 26,
        "question": "How do you create a generator function in Python?",
        "answer": "By using the `yield` statement instead of a single `return` value, often within a loop.",
        "rag_answer": "In Python, you can create a generator function by not having a single `return` value, but instead using `yield` to continuously return a series of values. Typically, the `yield` statement is placed within a loop.",
        "rag_score": 5,
        "rag_feedback": "The system's response is completely correct, accurate, and factual. It provides a clear and concise explanation of how to create a generator function in Python, which matches the expected answer.",
        "rag_context": [
            {
                "score": 0.6869664974389973,
                "node_text": "Here are some facts extracted from the provided text:\n\nGenerator function -> Is -> Provided to gradio\n\nBlocks() as demo\uff1a\n    #.\ndemo.queue()\ndemo.launch()\n```\n\n\u60a8\u53ef\u4ee5\u901a\u8fc7\u4ee5\u4e0b\u65b9\u5f0f\u63a7\u5236\u4e00\u6b21\u5904\u7406\u7684\u8bf7\u6c42\u6570\u91cf\uff1a\n\n```python\ndemo.queue(concurrency_count=3)\n```\n\n\u67e5\u770b\u6709\u5173\u914d\u7f6e\u5176\u4ed6\u961f\u5217\u53c2\u6570\u7684[\u961f\u5217\u6587\u6863](/docs/#queue)\u3002\n\n\u5728 Blocks \u4e2d\u6307\u5b9a\u4ec5\u5bf9\u67d0\u4e9b\u51fd\u6570\u8fdb\u884c\u6392\u961f\uff1a\n\n```python\nwith gr.Blocks() as demo2\uff1a\n    num1 = gr.Number()\n    num2 = gr.Number()\n    output = gr.Number()\n    gr.Button(\"Add\").click(\n        lambda a, b: a + b, [num1, num2], output)\n    gr.Button(\"Multiply\").click(\n        lambda a, b: a * b, [num1, num2], output, queue=True)\ndemo2.launch()\n```\n\n## \u8fed\u4ee3\u8f93\u51fa (Iterative Outputs)\n\n\u5728\u67d0\u4e9b\u60c5\u51b5\u4e0b\uff0c\u60a8\u53ef\u80fd\u9700\u8981\u4f20\u8f93\u4e00\u7cfb\u5217\u8f93\u51fa\u800c\u4e0d\u662f\u4e00\u6b21\u663e\u793a\u5355\u4e2a\u8f93\u51fa\u3002\u4f8b\u5982\uff0c\u60a8\u53ef\u80fd\u6709\u4e00\u4e2a\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5e0c\u671b\u663e\u793a\u751f\u6210\u7684\u6bcf\u4e2a\u6b65\u9aa4\u7684\u56fe\u50cf\uff0c\u76f4\u5230\u6700\u7ec8\u56fe\u50cf\u3002\u6216\u8005\u60a8\u53ef\u80fd\u6709\u4e00\u4e2a\u804a\u5929\u673a\u5668\u4eba\uff0c\u5b83\u9010\u5b57\u9010\u53e5\u5730\u6d41\u5f0f\u4f20\u8f93\u54cd\u5e94\uff0c\u800c\u4e0d\u662f\u4e00\u6b21\u8fd4\u56de\u5168\u90e8\u54cd\u5e94\u3002\n\n\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u60a8\u53ef\u4ee5\u5c06**\u751f\u6210\u5668**\u51fd\u6570\u63d0\u4f9b\u7ed9 Gradio\uff0c\u800c\u4e0d\u662f\u5e38\u89c4\u51fd\u6570\u3002\u5728 Python \u4e2d\u521b\u5efa\u751f\u6210\u5668\u975e\u5e38\u7b80\u5355\uff1a\u51fd\u6570\u4e0d\u5e94\u8be5\u6709\u4e00\u4e2a\u5355\u72ec\u7684 `return` \u503c\uff0c\u800c\u662f\u5e94\u8be5 with `yield` \u8fde\u7eed\u8fd4\u56de\u4e00\u7cfb\u5217\u503c\u3002\u901a\u5e38\uff0c`yield` \u8bed\u53e5\u653e\u7f6e\u5728\u67d0\u79cd\u5faa\u73af\u4e2d\u3002\u4e0b\u9762\u662f\u4e00\u4e2a\u7b80\u5355\u793a\u4f8b\uff0c\u751f\u6210\u5668\u53ea\u662f\u7b80\u5355\u8ba1\u6570\u5230\u7ed9\u5b9a\u6570\u5b57\uff1a\n\n```python\ndef my_generator(x):\n    for i in range(x):\n        yield i\n```\n\n\u60a8\u4ee5\u4e0e\u5e38\u89c4\u51fd\u6570\u76f8\u540c\u7684\u65b9\u5f0f\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio\u3002\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\uff08\u865a\u62df\u7684\uff09\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5b83\u5728\u8f93\u51fa\u56fe\u50cf\u4e4b\u524d\u751f\u6210\u6570\u4e2a\u6b65\u9aa4\u7684\u566a\u97f3\uff1a\n\n$code_fake_diffusion\n$demo_fake_diffusion\n\n\u8bf7\u6ce8\u610f\uff0c\u6211\u4eec\u5728\u8fed\u4ee3\u5668\u4e2d\u6dfb\u52a0\u4e86 `time.sleep(1)`\uff0c\u4ee5\u521b\u5efa\u6b65\u9aa4\u4e4b\u95f4\u7684\u4eba\u5de5\u6682\u505c\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u89c2\u5bdf\u8fed\u4ee3\u5668\u7684\u6b65\u9aa4\uff08\u5728\u771f\u5b9e\u7684\u56fe\u50cf\u751f\u6210\u6a21\u578b\u4e2d\uff0c\u8fd9\u53ef\u80fd\u662f\u4e0d\u5fc5\u8981\u7684\uff09\u3002\n\n\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio **\u9700\u8981**\u5728\u5e95\u5c42 Interface \u6216 Blocks \u4e2d\u542f\u7528\u961f\u5217\uff08\u8bf7\u53c2\u9605\u4e0a\u9762\u7684\u961f\u5217\u90e8\u5206\uff09\u3002\n\n## \u8fdb\u5ea6\u6761\n\nGradio \u652f\u6301\u521b\u5efa\u81ea\u5b9a\u4e49\u8fdb\u5ea6\u6761\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u81ea\u5b9a\u4e49\u548c\u63a7\u5236\u5411\u7528\u6237\u663e\u793a\u7684\u8fdb\u5ea6\u66f4\u65b0\u3002\u8981\u542f\u7528\u6b64\u529f\u80fd\uff0c\u53ea\u9700\u4e3a\u65b9\u6cd5\u6dfb\u52a0\u4e00\u4e2a\u9ed8\u8ba4\u503c\u4e3a `gr.Progress` \u5b9e\u4f8b\u7684\u53c2\u6570\u5373\u53ef\u3002\u7136\u540e\uff0c\u60a8\u53ef\u4ee5\u76f4\u63a5\u8c03\u7528\u6b64\u5b9e\u4f8b\u5e76\u4f20\u5165 0 \u5230 1 \u4e4b\u95f4\u7684\u6d6e\u70b9\u6570\u6765\u66f4\u65b0\u8fdb\u5ea6\u7ea7\u522b\uff0c\u6216\u8005 with `Progress` \u5b9e\u4f8b\u7684 `tqdm()` \u65b9\u6cd5\u6765\u8ddf\u8e2a\u53ef\u8fed\u4ee3\u5bf9\u8c61\u4e0a\u7684\u8fdb\u5ea6\uff0c\u5982\u4e0b\u6240\u793a\u3002\u5fc5\u987b\u542f\u7528\u961f\u5217\u4ee5\u8fdb\u884c\u8fdb\u5ea6\u66f4\u65b0\u3002\n\n$code_progress_simple\n$demo_progress_simple\n\n\u5982\u679c\u60a8 with `tqdm` \u5e93\uff0c\u5e76\u4e14\u5e0c\u671b\u4ece\u51fd\u6570\u5185\u90e8\u7684\u4efb\u4f55 `tqdm.tqdm` \u81ea\u52a8\u62a5\u544a\u8fdb\u5ea6\u66f4\u65b0\uff0c\u8bf7\u5c06\u9ed8\u8ba4\u53c2\u6570\u8bbe\u7f6e\u4e3a `gr.Progress(track_tqdm=True)`\uff01\n\n## \u6279\u5904\u7406\u51fd\u6570 (Batch Functions)\n\nGradio \u652f\u6301\u4f20\u9012*\u6279\u5904\u7406*\u51fd\u6570\u3002\u6279\u5904\u7406\u51fd\u6570\u53ea\u662f\u63a5\u53d7\u8f93\u5165\u5217\u8868\u5e76\u8fd4\u56de\u9884\u6d4b\u5217\u8868\u7684\u51fd\u6570\u3002\n\n\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\u6279\u5904\u7406\u51fd\u6570\uff0c\u5b83\u63a5\u53d7\u4e24\u4e2a\u8f93\u5165\u5217\u8868\uff08\u4e00\u4e2a\u5355\u8bcd\u5217\u8868\u548c\u4e00\u4e2a\u6574\u6570\u5217\u8868\uff09\uff0c\u5e76\u8fd4\u56de\u4fee\u526a\u8fc7\u7684\u5355\u8bcd\u5217\u8868\u4f5c\u4e3a\u8f93\u51fa\uff1a\n\n```python\nimport time\n\ndef trim_words(words, lens):\n    trimmed_words = []\n    time.sleep(5)\n    for w, l in zip(words, lens):\n        trimmed_words.append(w[:int(l)])\n    return [trimmed_words]\n    for w, l in zip(words,"
            },
            {
                "score": 0.6264007115691217,
                "node_text": "Here are some facts extracted from the provided text:\n\nRun_funsd_cord.py -> Is -> Script\n\n!---\nCopyright 2022 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n-->\n\n# Token classification with LayoutLMv3 (PyTorch version)\n\nThis directory contains a script, `run_funsd_cord.py`, that can be used to fine-tune (or evaluate) LayoutLMv3 on form understanding datasets, such as [FUNSD](https://guillaumejaume.github.io/FUNSD/) and [CORD](https://github.com/clovaai/cord).\n\nThe script `run_funsd_cord.py` leverages the \ud83e\udd17 Datasets library and the Trainer API. You can easily customize it to your needs.\n\n## Fine-tuning on FUNSD\n\nFine-tuning LayoutLMv3 for token classification on [FUNSD](https://guillaumejaume.github.io/FUNSD/) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name funsd \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 1e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-funsd\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd. By specifying the `push_to_hub` flag, the model gets uploaded automatically to the hub (regularly), together with a model card, which includes metrics such as precision, recall and F1. Note that you can easily update the model card, as it's just a README file of the respective repo on the hub.\n\nThere's also the \"Training metrics\" [tab](https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd/tensorboard), which shows Tensorboard logs over the course of training. Pretty neat, huh?\n\n## Fine-tuning on CORD\n\nFine-tuning LayoutLMv3 for token classification on [CORD](https://github.com/clovaai/cord) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name cord \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 5e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-cord\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-cord. Note that a model card gets generated automatically in case you specify the `push_to_hub` flag."
            },
            {
                "score": 0.5523841787666607,
                "node_text": "Here are some facts extracted from the provided text:\n\nEvent listener function -> Adds -> Variable to input parameters and return value\n\nState in Blocks\n\nWe covered [State in Interfaces](https://gradio.app/interface-state), this guide takes a look at state in Blocks, which works mostly the same.\n\n## Global State\n\nGlobal state in Blocks works the same as in Interface. Any variable created outside a function call is a reference shared between all users.\n\n## Session State\n\nGradio supports session **state**, where data persists across multiple submits within a page session, in Blocks apps as well. To reiterate, session data is _not_ shared between different users of your model. To store data in a session state, you need to do three things:\n\n1. Create a `gr.State()` object. If there is a default value to this stateful object, pass that into the constructor.\n2. In the event listener, put the `State` object as an input and output.\n3. In the event listener function, add the variable to the input parameters and the return value.\n\nLet's take a look at a game of hangman.\n\n$code_hangman\n$demo_hangman\n\nLet's see how we do each of the 3 steps listed above in this game:\n\n1. We store the used letters in `used_letters_var`. In the constructor of `State`, we set the initial value of this to `[]`, an empty list.\n2. In `btn.click()`, we have a reference to `used_letters_var` in both the inputs and outputs.\n3. In `guess_letter`, we pass the value of this `State` to `used_letters`, and then return an updated value of this `State` in the return statement.\n\nWith more complex apps, you will likely have many State variables storing session state in a single Blocks app.\n\nLearn more about `State` in the [docs](https://gradio.app/docs#state)."
            },
            {
                "score": 0.5434802710417177,
                "node_text": "Here are some facts extracted from the provided text:\n\nBatch functions -> Accept -> Input lists\nBatch functions -> Return -> Prediction lists\n\ntqdm` \u81ea\u52a8\u62a5\u544a\u8fdb\u5ea6\u66f4\u65b0\uff0c\u8bf7\u5c06\u9ed8\u8ba4\u53c2\u6570\u8bbe\u7f6e\u4e3a `gr.Progress(track_tqdm=True)`\uff01\n\n## \u6279\u5904\u7406\u51fd\u6570 (Batch Functions)\n\nGradio \u652f\u6301\u4f20\u9012*\u6279\u5904\u7406*\u51fd\u6570\u3002\u6279\u5904\u7406\u51fd\u6570\u53ea\u662f\u63a5\u53d7\u8f93\u5165\u5217\u8868\u5e76\u8fd4\u56de\u9884\u6d4b\u5217\u8868\u7684\u51fd\u6570\u3002\n\n\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\u6279\u5904\u7406\u51fd\u6570\uff0c\u5b83\u63a5\u53d7\u4e24\u4e2a\u8f93\u5165\u5217\u8868\uff08\u4e00\u4e2a\u5355\u8bcd\u5217\u8868\u548c\u4e00\u4e2a\u6574\u6570\u5217\u8868\uff09\uff0c\u5e76\u8fd4\u56de\u4fee\u526a\u8fc7\u7684\u5355\u8bcd\u5217\u8868\u4f5c\u4e3a\u8f93\u51fa\uff1a\n\n```python\nimport time\n\ndef trim_words(words, lens):\n    trimmed_words = []\n    time.sleep(5)\n    for w, l in zip(words, lens):\n        trimmed_words.append(w[:int(l)])\n    return [trimmed_words]\n    for w, l in zip(words, lens):\n```\n\n\u4f7f\u7528\u6279\u5904\u7406\u51fd\u6570\u7684\u4f18\u70b9\u662f\uff0c\u5982\u679c\u542f\u7528\u4e86\u961f\u5217\uff0cGradio \u670d\u52a1\u5668\u53ef\u4ee5\u81ea\u52a8*\u6279\u5904\u7406*\u4f20\u5165\u7684\u8bf7\u6c42\u5e76\u5e76\u884c\u5904\u7406\u5b83\u4eec\uff0c\u4ece\u800c\u53ef\u80fd\u52a0\u5feb\u6f14\u793a\u901f\u5ea6\u3002\u4ee5\u4e0b\u662f Gradio \u4ee3\u7801\u7684\u793a\u4f8b\uff08\u8bf7\u6ce8\u610f `batch=True` \u548c `max_batch_size=16` - \u8fd9\u4e24\u4e2a\u53c2\u6570\u90fd\u53ef\u4ee5\u4f20\u9012\u7ed9\u4e8b\u4ef6\u89e6\u53d1\u5668\u6216 `Interface` \u7c7b\uff09\n\nwith `Interface`\uff1a\n\n```python\ndemo = gr.Interface(trim_words, [\"textbox\", \"number\"], [\"output\"],\n                    batch=True, max_batch_size=16)\ndemo.queue()\ndemo.launch()\n```\n\nwith `Blocks`\uff1a\n\n```python\nimport gradio as gr\n\nwith gr.Blocks() as demo:\n    with gr.Row():\n        word = gr.Textbox(label=\"word\")\n        leng = gr.Number(label=\"leng\")\n        output = gr.Textbox(label=\"Output\")\n    with gr.Row():\n        run = gr.Button()\n\n    event = run.click(trim_words, [word, leng], output, batch=True, max_batch_size=16)\n\ndemo.queue()\ndemo.launch()\n```\n\n\u5728\u4e0a\u9762\u7684\u793a\u4f8b\u4e2d\uff0c\u53ef\u4ee5\u5e76\u884c\u5904\u7406 16 \u4e2a\u8bf7\u6c42\uff08\u603b\u63a8\u7406\u65f6\u95f4\u4e3a 5 \u79d2\uff09\uff0c\u800c\u4e0d\u662f\u5206\u522b\u5904\u7406\u6bcf\u4e2a\u8bf7\u6c42\uff08\u603b\u63a8\u7406\u65f6\u95f4\u4e3a 80 \u79d2\uff09\u3002\u8bb8\u591a Hugging Face \u7684 `transformers` \u548c `diffusers` \u6a21\u578b\u5728 Gradio \u7684\u6279\u5904\u7406\u6a21\u5f0f\u4e0b\u81ea\u7136\u5de5\u4f5c\uff1a\u8fd9\u662f[\u4f7f\u7528\u6279\u5904\u7406\u751f\u6210\u56fe\u50cf\u7684\u793a\u4f8b\u6f14\u793a](https://github.com/gradio-app/gradio/blob/main/demo/diffusers_with_batching/run.py)\n\n\u6ce8\u610f\uff1a\u4f7f\u7528 Gradio \u7684\u6279\u5904\u7406\u51fd\u6570 **requires** \u5728\u5e95\u5c42 Interface \u6216 Blocks \u4e2d\u542f\u7528\u961f\u5217\uff08\u8bf7\u53c2\u9605\u4e0a\u9762\u7684\u961f\u5217\u90e8\u5206\uff09\u3002\n\n## Gradio \u7b14\u8bb0\u672c (Colab Notebooks)\n\nGradio \u53ef\u4ee5\u5728\u4efb\u4f55\u8fd0\u884c Python \u7684\u5730\u65b9\u8fd0\u884c\uff0c\u5305\u62ec\u672c\u5730 Jupyter \u7b14\u8bb0\u672c\u548c\u534f\u4f5c\u7b14\u8bb0\u672c\uff0c\u5982[Google Colab](https://colab.research.google.com/)\u3002\u5bf9\u4e8e\u672c\u5730 Jupyter \u7b14\u8bb0\u672c\u548c Google Colab \u7b14\u8bb0\u672c\uff0cGradio \u5728\u672c\u5730\u670d\u52a1\u5668\u4e0a\u8fd0\u884c\uff0c\u60a8\u53ef\u4ee5\u5728\u6d4f\u89c8\u5668\u4e2d\u4e0e\u4e4b\u4ea4\u4e92\u3002\uff08\u6ce8\u610f\uff1a\u5bf9\u4e8e Google Colab\uff0c\u8fd9\u662f\u901a\u8fc7[\u670d\u52a1\u5de5\u4f5c\u5668\u96a7\u9053](https://github.com/tensorflow/tensorboard/blob/master/docs/design/colab_integration.md)\u5b9e\u73b0\u7684\uff0c\u60a8\u7684\u6d4f\u89c8\u5668\u9700\u8981\u542f\u7528 cookies\u3002\uff09\u5bf9\u4e8e\u5176\u4ed6\u8fdc\u7a0b\u7b14\u8bb0\u672c\uff0cGradio \u4e5f\u5c06\u5728\u670d\u52a1\u5668\u4e0a\u8fd0\u884c\uff0c\u4f46\u60a8\u9700\u8981\u4f7f\u7528[SSH \u96a7\u9053](https://coderwall.com/p/ohk6cg/remote-access-to-ipython-notebooks-via-ssh)\u5728\u672c\u5730\u6d4f\u89c8\u5668\u4e2d\u67e5\u770b\u5e94\u7528\u7a0b\u5e8f\u3002\u901a\u5e38\uff0c\u66f4\u7b80\u5355\u7684\u9009\u62e9\u662f\u4f7f\u7528 Gradio \u5185\u7f6e\u7684\u516c\u5171\u94fe\u63a5\uff0c[\u5728\u4e0b\u4e00\u7bc7\u6307\u5357\u4e2d\u8ba8\u8bba](/sharing-your-app/#sharing-demos)\u3002"
            },
            {
                "score": 0.5434802710417177,
                "node_text": "Here are some facts extracted from the provided text:\n\nGradio -> Supports -> Batch functions\n\nGradio Demo: blocks_random_slider\n\n\n```\n!pip install -q gradio \n```\n\n\n```\n\nimport gradio as gr\n\n\ndef func(slider_1, slider_2):\n    return slider_1 * 5 + slider_2\n\n\nwith gr.Blocks() as demo:\n    slider = gr.Slider(minimum=-10.2, maximum=15, label=\"Random Slider (Static)\", randomize=True)\n    slider_1 = gr.Slider(minimum=100, maximum=200, label=\"Random Slider (Input 1)\", randomize=True)\n    slider_2 = gr.Slider(minimum=10, maximum=23.2, label=\"Random Slider (Input 2)\", randomize=True)\n    slider_3 = gr.Slider(value=3, label=\"Non random slider\")\n    btn = gr.Button(\"Run\")\n    btn.click(func, inputs=[slider_1, slider_2], outputs=gr.Number())\n\nif __name__ == \"__main__\":\n    demo.launch()\n\n```"
            }
        ]
    },
    {
        "sample_idx": 27,
        "question": "What is required to enable progress updates in Gradio?",
        "answer": "Enabling queuing and adding a `gr.Progress` instance as a parameter to the method.",
        "rag_answer": "To enable progress updates in Gradio, it is required to enable the queue in the underlying Interface or Blocks.",
        "rag_score": 2,
        "rag_feedback": "The system's response is mostly incorrect, inaccurate, and/or not factual. While it provides some relevant information about Gradio, it does not directly answer the question about enabling progress updates. The correct answer is to enable queuing and add a `gr.Progress` instance as a parameter to the method, which is not clearly stated in the response.",
        "rag_context": [
            {
                "score": 0.6751115783183279,
                "node_text": "Here are some facts extracted from the provided text:\n\nGr -> Is -> Alias of gradio\nGradio -> Provides -> Pre-built themes\nGradio -> Is -> Library\nGradio -> Supports -> Iterative outputs\nGradio -> Has feature -> \u6dfb\u52a0\u63cf\u8ff0\u5185\u5bb9\nGradio -> Converts -> Data format\nGradio -> Has feature -> \u8fdb\u5ea6\u6761\nGradio -> Automatically handles -> Preprocessing\nGradio -> Has feature -> \u8bbe\u7f6e\u65d7\u6807\nGradio -> Has feature -> \u8fed\u4ee3\u8f93\u51fa\nGradio -> Has feature -> \u9884\u5904\u7406\u548c\u540e\u5904\u7406\nGradio -> Installed by -> Pip\nGradio -> Has feature -> \u6392\u961f\u7528\u6237\nGradio -> Recognizes -> Data format\nGradio -> Automatically handles -> Postprocessing\nGradio -> Supports -> Hugging face models\nGradio -> Supports -> Batch functions\nGradio -> Enables -> Parallel processing\nGradio -> Has feature -> \u6279\u5904\u7406\u51fd\u6570\nGradio -> Has feature -> \u4f20\u9012\u81ea\u5b9a\u4e49\u9519\u8bef\u6d88\u606f\nGradio -> Can run -> In colab notebooks\nGradio -> Supports -> Progress bars\nGradio -> Includes -> Components\nGradio -> Has feature -> \u6837\u5f0f\u5316\u6f14\u793a\nGradio -> Has feature -> \u6dfb\u52a0\u793a\u4f8b\u8f93\u5165\n\nGradio Demo: blocks_random_slider\n\n\n```\n!pip install -q gradio \n```\n\n\n```\n\nimport gradio as gr\n\n\ndef func(slider_1, slider_2):\n    return slider_1 * 5 + slider_2\n\n\nwith gr.Blocks() as demo:\n    slider = gr.Slider(minimum=-10.2, maximum=15, label=\"Random Slider (Static)\", randomize=True)\n    slider_1 = gr.Slider(minimum=100, maximum=200, label=\"Random Slider (Input 1)\", randomize=True)\n    slider_2 = gr.Slider(minimum=10, maximum=23.2, label=\"Random Slider (Input 2)\", randomize=True)\n    slider_3 = gr.Slider(value=3, label=\"Non random slider\")\n    btn = gr.Button(\"Run\")\n    btn.click(func, inputs=[slider_1, slider_2], outputs=gr.Number())\n\nif __name__ == \"__main__\":\n    demo.launch()\n\n```"
            },
            {
                "score": 0.6620384448274435,
                "node_text": "Here are some facts extracted from the provided text:\n\nTqdm -> Reports -> Progress updates\n\ntqdm` \u81ea\u52a8\u62a5\u544a\u8fdb\u5ea6\u66f4\u65b0\uff0c\u8bf7\u5c06\u9ed8\u8ba4\u53c2\u6570\u8bbe\u7f6e\u4e3a `gr.Progress(track_tqdm=True)`\uff01\n\n## \u6279\u5904\u7406\u51fd\u6570 (Batch Functions)\n\nGradio \u652f\u6301\u4f20\u9012*\u6279\u5904\u7406*\u51fd\u6570\u3002\u6279\u5904\u7406\u51fd\u6570\u53ea\u662f\u63a5\u53d7\u8f93\u5165\u5217\u8868\u5e76\u8fd4\u56de\u9884\u6d4b\u5217\u8868\u7684\u51fd\u6570\u3002\n\n\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\u6279\u5904\u7406\u51fd\u6570\uff0c\u5b83\u63a5\u53d7\u4e24\u4e2a\u8f93\u5165\u5217\u8868\uff08\u4e00\u4e2a\u5355\u8bcd\u5217\u8868\u548c\u4e00\u4e2a\u6574\u6570\u5217\u8868\uff09\uff0c\u5e76\u8fd4\u56de\u4fee\u526a\u8fc7\u7684\u5355\u8bcd\u5217\u8868\u4f5c\u4e3a\u8f93\u51fa\uff1a\n\n```python\nimport time\n\ndef trim_words(words, lens):\n    trimmed_words = []\n    time.sleep(5)\n    for w, l in zip(words, lens):\n        trimmed_words.append(w[:int(l)])\n    return [trimmed_words]\n    for w, l in zip(words, lens):\n```\n\n\u4f7f\u7528\u6279\u5904\u7406\u51fd\u6570\u7684\u4f18\u70b9\u662f\uff0c\u5982\u679c\u542f\u7528\u4e86\u961f\u5217\uff0cGradio \u670d\u52a1\u5668\u53ef\u4ee5\u81ea\u52a8*\u6279\u5904\u7406*\u4f20\u5165\u7684\u8bf7\u6c42\u5e76\u5e76\u884c\u5904\u7406\u5b83\u4eec\uff0c\u4ece\u800c\u53ef\u80fd\u52a0\u5feb\u6f14\u793a\u901f\u5ea6\u3002\u4ee5\u4e0b\u662f Gradio \u4ee3\u7801\u7684\u793a\u4f8b\uff08\u8bf7\u6ce8\u610f `batch=True` \u548c `max_batch_size=16` - \u8fd9\u4e24\u4e2a\u53c2\u6570\u90fd\u53ef\u4ee5\u4f20\u9012\u7ed9\u4e8b\u4ef6\u89e6\u53d1\u5668\u6216 `Interface` \u7c7b\uff09\n\nwith `Interface`\uff1a\n\n```python\ndemo = gr.Interface(trim_words, [\"textbox\", \"number\"], [\"output\"],\n                    batch=True, max_batch_size=16)\ndemo.queue()\ndemo.launch()\n```\n\nwith `Blocks`\uff1a\n\n```python\nimport gradio as gr\n\nwith gr.Blocks() as demo:\n    with gr.Row():\n        word = gr.Textbox(label=\"word\")\n        leng = gr.Number(label=\"leng\")\n        output = gr.Textbox(label=\"Output\")\n    with gr.Row():\n        run = gr.Button()\n\n    event = run.click(trim_words, [word, leng], output, batch=True, max_batch_size=16)\n\ndemo.queue()\ndemo.launch()\n```\n\n\u5728\u4e0a\u9762\u7684\u793a\u4f8b\u4e2d\uff0c\u53ef\u4ee5\u5e76\u884c\u5904\u7406 16 \u4e2a\u8bf7\u6c42\uff08\u603b\u63a8\u7406\u65f6\u95f4\u4e3a 5 \u79d2\uff09\uff0c\u800c\u4e0d\u662f\u5206\u522b\u5904\u7406\u6bcf\u4e2a\u8bf7\u6c42\uff08\u603b\u63a8\u7406\u65f6\u95f4\u4e3a 80 \u79d2\uff09\u3002\u8bb8\u591a Hugging Face \u7684 `transformers` \u548c `diffusers` \u6a21\u578b\u5728 Gradio \u7684\u6279\u5904\u7406\u6a21\u5f0f\u4e0b\u81ea\u7136\u5de5\u4f5c\uff1a\u8fd9\u662f[\u4f7f\u7528\u6279\u5904\u7406\u751f\u6210\u56fe\u50cf\u7684\u793a\u4f8b\u6f14\u793a](https://github.com/gradio-app/gradio/blob/main/demo/diffusers_with_batching/run.py)\n\n\u6ce8\u610f\uff1a\u4f7f\u7528 Gradio \u7684\u6279\u5904\u7406\u51fd\u6570 **requires** \u5728\u5e95\u5c42 Interface \u6216 Blocks \u4e2d\u542f\u7528\u961f\u5217\uff08\u8bf7\u53c2\u9605\u4e0a\u9762\u7684\u961f\u5217\u90e8\u5206\uff09\u3002\n\n## Gradio \u7b14\u8bb0\u672c (Colab Notebooks)\n\nGradio \u53ef\u4ee5\u5728\u4efb\u4f55\u8fd0\u884c Python \u7684\u5730\u65b9\u8fd0\u884c\uff0c\u5305\u62ec\u672c\u5730 Jupyter \u7b14\u8bb0\u672c\u548c\u534f\u4f5c\u7b14\u8bb0\u672c\uff0c\u5982[Google Colab](https://colab.research.google.com/)\u3002\u5bf9\u4e8e\u672c\u5730 Jupyter \u7b14\u8bb0\u672c\u548c Google Colab \u7b14\u8bb0\u672c\uff0cGradio \u5728\u672c\u5730\u670d\u52a1\u5668\u4e0a\u8fd0\u884c\uff0c\u60a8\u53ef\u4ee5\u5728\u6d4f\u89c8\u5668\u4e2d\u4e0e\u4e4b\u4ea4\u4e92\u3002\uff08\u6ce8\u610f\uff1a\u5bf9\u4e8e Google Colab\uff0c\u8fd9\u662f\u901a\u8fc7[\u670d\u52a1\u5de5\u4f5c\u5668\u96a7\u9053](https://github.com/tensorflow/tensorboard/blob/master/docs/design/colab_integration.md)\u5b9e\u73b0\u7684\uff0c\u60a8\u7684\u6d4f\u89c8\u5668\u9700\u8981\u542f\u7528 cookies\u3002\uff09\u5bf9\u4e8e\u5176\u4ed6\u8fdc\u7a0b\u7b14\u8bb0\u672c\uff0cGradio \u4e5f\u5c06\u5728\u670d\u52a1\u5668\u4e0a\u8fd0\u884c\uff0c\u4f46\u60a8\u9700\u8981\u4f7f\u7528[SSH \u96a7\u9053](https://coderwall.com/p/ohk6cg/remote-access-to-ipython-notebooks-via-ssh)\u5728\u672c\u5730\u6d4f\u89c8\u5668\u4e2d\u67e5\u770b\u5e94\u7528\u7a0b\u5e8f\u3002\u901a\u5e38\uff0c\u66f4\u7b80\u5355\u7684\u9009\u62e9\u662f\u4f7f\u7528 Gradio \u5185\u7f6e\u7684\u516c\u5171\u94fe\u63a5\uff0c[\u5728\u4e0b\u4e00\u7bc7\u6307\u5357\u4e2d\u8ba8\u8bba](/sharing-your-app/#sharing-demos)\u3002"
            },
            {
                "score": 0.659616605108807,
                "node_text": "Here are some facts extracted from the provided text:\n\nGenerator function -> Is -> Provided to gradio\n\nBlocks() as demo\uff1a\n    #.\ndemo.queue()\ndemo.launch()\n```\n\n\u60a8\u53ef\u4ee5\u901a\u8fc7\u4ee5\u4e0b\u65b9\u5f0f\u63a7\u5236\u4e00\u6b21\u5904\u7406\u7684\u8bf7\u6c42\u6570\u91cf\uff1a\n\n```python\ndemo.queue(concurrency_count=3)\n```\n\n\u67e5\u770b\u6709\u5173\u914d\u7f6e\u5176\u4ed6\u961f\u5217\u53c2\u6570\u7684[\u961f\u5217\u6587\u6863](/docs/#queue)\u3002\n\n\u5728 Blocks \u4e2d\u6307\u5b9a\u4ec5\u5bf9\u67d0\u4e9b\u51fd\u6570\u8fdb\u884c\u6392\u961f\uff1a\n\n```python\nwith gr.Blocks() as demo2\uff1a\n    num1 = gr.Number()\n    num2 = gr.Number()\n    output = gr.Number()\n    gr.Button(\"Add\").click(\n        lambda a, b: a + b, [num1, num2], output)\n    gr.Button(\"Multiply\").click(\n        lambda a, b: a * b, [num1, num2], output, queue=True)\ndemo2.launch()\n```\n\n## \u8fed\u4ee3\u8f93\u51fa (Iterative Outputs)\n\n\u5728\u67d0\u4e9b\u60c5\u51b5\u4e0b\uff0c\u60a8\u53ef\u80fd\u9700\u8981\u4f20\u8f93\u4e00\u7cfb\u5217\u8f93\u51fa\u800c\u4e0d\u662f\u4e00\u6b21\u663e\u793a\u5355\u4e2a\u8f93\u51fa\u3002\u4f8b\u5982\uff0c\u60a8\u53ef\u80fd\u6709\u4e00\u4e2a\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5e0c\u671b\u663e\u793a\u751f\u6210\u7684\u6bcf\u4e2a\u6b65\u9aa4\u7684\u56fe\u50cf\uff0c\u76f4\u5230\u6700\u7ec8\u56fe\u50cf\u3002\u6216\u8005\u60a8\u53ef\u80fd\u6709\u4e00\u4e2a\u804a\u5929\u673a\u5668\u4eba\uff0c\u5b83\u9010\u5b57\u9010\u53e5\u5730\u6d41\u5f0f\u4f20\u8f93\u54cd\u5e94\uff0c\u800c\u4e0d\u662f\u4e00\u6b21\u8fd4\u56de\u5168\u90e8\u54cd\u5e94\u3002\n\n\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u60a8\u53ef\u4ee5\u5c06**\u751f\u6210\u5668**\u51fd\u6570\u63d0\u4f9b\u7ed9 Gradio\uff0c\u800c\u4e0d\u662f\u5e38\u89c4\u51fd\u6570\u3002\u5728 Python \u4e2d\u521b\u5efa\u751f\u6210\u5668\u975e\u5e38\u7b80\u5355\uff1a\u51fd\u6570\u4e0d\u5e94\u8be5\u6709\u4e00\u4e2a\u5355\u72ec\u7684 `return` \u503c\uff0c\u800c\u662f\u5e94\u8be5 with `yield` \u8fde\u7eed\u8fd4\u56de\u4e00\u7cfb\u5217\u503c\u3002\u901a\u5e38\uff0c`yield` \u8bed\u53e5\u653e\u7f6e\u5728\u67d0\u79cd\u5faa\u73af\u4e2d\u3002\u4e0b\u9762\u662f\u4e00\u4e2a\u7b80\u5355\u793a\u4f8b\uff0c\u751f\u6210\u5668\u53ea\u662f\u7b80\u5355\u8ba1\u6570\u5230\u7ed9\u5b9a\u6570\u5b57\uff1a\n\n```python\ndef my_generator(x):\n    for i in range(x):\n        yield i\n```\n\n\u60a8\u4ee5\u4e0e\u5e38\u89c4\u51fd\u6570\u76f8\u540c\u7684\u65b9\u5f0f\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio\u3002\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\uff08\u865a\u62df\u7684\uff09\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5b83\u5728\u8f93\u51fa\u56fe\u50cf\u4e4b\u524d\u751f\u6210\u6570\u4e2a\u6b65\u9aa4\u7684\u566a\u97f3\uff1a\n\n$code_fake_diffusion\n$demo_fake_diffusion\n\n\u8bf7\u6ce8\u610f\uff0c\u6211\u4eec\u5728\u8fed\u4ee3\u5668\u4e2d\u6dfb\u52a0\u4e86 `time.sleep(1)`\uff0c\u4ee5\u521b\u5efa\u6b65\u9aa4\u4e4b\u95f4\u7684\u4eba\u5de5\u6682\u505c\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u89c2\u5bdf\u8fed\u4ee3\u5668\u7684\u6b65\u9aa4\uff08\u5728\u771f\u5b9e\u7684\u56fe\u50cf\u751f\u6210\u6a21\u578b\u4e2d\uff0c\u8fd9\u53ef\u80fd\u662f\u4e0d\u5fc5\u8981\u7684\uff09\u3002\n\n\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio **\u9700\u8981**\u5728\u5e95\u5c42 Interface \u6216 Blocks \u4e2d\u542f\u7528\u961f\u5217\uff08\u8bf7\u53c2\u9605\u4e0a\u9762\u7684\u961f\u5217\u90e8\u5206\uff09\u3002\n\n## \u8fdb\u5ea6\u6761\n\nGradio \u652f\u6301\u521b\u5efa\u81ea\u5b9a\u4e49\u8fdb\u5ea6\u6761\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u81ea\u5b9a\u4e49\u548c\u63a7\u5236\u5411\u7528\u6237\u663e\u793a\u7684\u8fdb\u5ea6\u66f4\u65b0\u3002\u8981\u542f\u7528\u6b64\u529f\u80fd\uff0c\u53ea\u9700\u4e3a\u65b9\u6cd5\u6dfb\u52a0\u4e00\u4e2a\u9ed8\u8ba4\u503c\u4e3a `gr.Progress` \u5b9e\u4f8b\u7684\u53c2\u6570\u5373\u53ef\u3002\u7136\u540e\uff0c\u60a8\u53ef\u4ee5\u76f4\u63a5\u8c03\u7528\u6b64\u5b9e\u4f8b\u5e76\u4f20\u5165 0 \u5230 1 \u4e4b\u95f4\u7684\u6d6e\u70b9\u6570\u6765\u66f4\u65b0\u8fdb\u5ea6\u7ea7\u522b\uff0c\u6216\u8005 with `Progress` \u5b9e\u4f8b\u7684 `tqdm()` \u65b9\u6cd5\u6765\u8ddf\u8e2a\u53ef\u8fed\u4ee3\u5bf9\u8c61\u4e0a\u7684\u8fdb\u5ea6\uff0c\u5982\u4e0b\u6240\u793a\u3002\u5fc5\u987b\u542f\u7528\u961f\u5217\u4ee5\u8fdb\u884c\u8fdb\u5ea6\u66f4\u65b0\u3002\n\n$code_progress_simple\n$demo_progress_simple\n\n\u5982\u679c\u60a8 with `tqdm` \u5e93\uff0c\u5e76\u4e14\u5e0c\u671b\u4ece\u51fd\u6570\u5185\u90e8\u7684\u4efb\u4f55 `tqdm.tqdm` \u81ea\u52a8\u62a5\u544a\u8fdb\u5ea6\u66f4\u65b0\uff0c\u8bf7\u5c06\u9ed8\u8ba4\u53c2\u6570\u8bbe\u7f6e\u4e3a `gr.Progress(track_tqdm=True)`\uff01\n\n## \u6279\u5904\u7406\u51fd\u6570 (Batch Functions)\n\nGradio \u652f\u6301\u4f20\u9012*\u6279\u5904\u7406*\u51fd\u6570\u3002\u6279\u5904\u7406\u51fd\u6570\u53ea\u662f\u63a5\u53d7\u8f93\u5165\u5217\u8868\u5e76\u8fd4\u56de\u9884\u6d4b\u5217\u8868\u7684\u51fd\u6570\u3002\n\n\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\u6279\u5904\u7406\u51fd\u6570\uff0c\u5b83\u63a5\u53d7\u4e24\u4e2a\u8f93\u5165\u5217\u8868\uff08\u4e00\u4e2a\u5355\u8bcd\u5217\u8868\u548c\u4e00\u4e2a\u6574\u6570\u5217\u8868\uff09\uff0c\u5e76\u8fd4\u56de\u4fee\u526a\u8fc7\u7684\u5355\u8bcd\u5217\u8868\u4f5c\u4e3a\u8f93\u51fa\uff1a\n\n```python\nimport time\n\ndef trim_words(words, lens):\n    trimmed_words = []\n    time.sleep(5)\n    for w, l in zip(words, lens):\n        trimmed_words.append(w[:int(l)])\n    return [trimmed_words]\n    for w, l in zip(words,"
            }
        ]
    },
    {
        "sample_idx": 28,
        "question": "What is a batch function in Gradio?",
        "answer": "A function that accepts input lists and returns prediction lists.",
        "rag_answer": "A batch function in Gradio is a function that accepts input lists and returns prediction lists.",
        "rag_score": 5,
        "rag_feedback": "The system's response is completely correct, accurate, and factual. It provides a clear and concise definition of a batch function in Gradio, which matches the expected answer.",
        "rag_context": [
            {
                "score": 0.7271403465071004,
                "node_text": "Here are some facts extracted from the provided text:\n\nBatch functions -> Accept -> Input lists\nBatch functions -> Return -> Prediction lists\nTrim_words -> Is -> Batch function\n\ntqdm` \u81ea\u52a8\u62a5\u544a\u8fdb\u5ea6\u66f4\u65b0\uff0c\u8bf7\u5c06\u9ed8\u8ba4\u53c2\u6570\u8bbe\u7f6e\u4e3a `gr.Progress(track_tqdm=True)`\uff01\n\n## \u6279\u5904\u7406\u51fd\u6570 (Batch Functions)\n\nGradio \u652f\u6301\u4f20\u9012*\u6279\u5904\u7406*\u51fd\u6570\u3002\u6279\u5904\u7406\u51fd\u6570\u53ea\u662f\u63a5\u53d7\u8f93\u5165\u5217\u8868\u5e76\u8fd4\u56de\u9884\u6d4b\u5217\u8868\u7684\u51fd\u6570\u3002\n\n\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\u6279\u5904\u7406\u51fd\u6570\uff0c\u5b83\u63a5\u53d7\u4e24\u4e2a\u8f93\u5165\u5217\u8868\uff08\u4e00\u4e2a\u5355\u8bcd\u5217\u8868\u548c\u4e00\u4e2a\u6574\u6570\u5217\u8868\uff09\uff0c\u5e76\u8fd4\u56de\u4fee\u526a\u8fc7\u7684\u5355\u8bcd\u5217\u8868\u4f5c\u4e3a\u8f93\u51fa\uff1a\n\n```python\nimport time\n\ndef trim_words(words, lens):\n    trimmed_words = []\n    time.sleep(5)\n    for w, l in zip(words, lens):\n        trimmed_words.append(w[:int(l)])\n    return [trimmed_words]\n    for w, l in zip(words, lens):\n```\n\n\u4f7f\u7528\u6279\u5904\u7406\u51fd\u6570\u7684\u4f18\u70b9\u662f\uff0c\u5982\u679c\u542f\u7528\u4e86\u961f\u5217\uff0cGradio \u670d\u52a1\u5668\u53ef\u4ee5\u81ea\u52a8*\u6279\u5904\u7406*\u4f20\u5165\u7684\u8bf7\u6c42\u5e76\u5e76\u884c\u5904\u7406\u5b83\u4eec\uff0c\u4ece\u800c\u53ef\u80fd\u52a0\u5feb\u6f14\u793a\u901f\u5ea6\u3002\u4ee5\u4e0b\u662f Gradio \u4ee3\u7801\u7684\u793a\u4f8b\uff08\u8bf7\u6ce8\u610f `batch=True` \u548c `max_batch_size=16` - \u8fd9\u4e24\u4e2a\u53c2\u6570\u90fd\u53ef\u4ee5\u4f20\u9012\u7ed9\u4e8b\u4ef6\u89e6\u53d1\u5668\u6216 `Interface` \u7c7b\uff09\n\nwith `Interface`\uff1a\n\n```python\ndemo = gr.Interface(trim_words, [\"textbox\", \"number\"], [\"output\"],\n                    batch=True, max_batch_size=16)\ndemo.queue()\ndemo.launch()\n```\n\nwith `Blocks`\uff1a\n\n```python\nimport gradio as gr\n\nwith gr.Blocks() as demo:\n    with gr.Row():\n        word = gr.Textbox(label=\"word\")\n        leng = gr.Number(label=\"leng\")\n        output = gr.Textbox(label=\"Output\")\n    with gr.Row():\n        run = gr.Button()\n\n    event = run.click(trim_words, [word, leng], output, batch=True, max_batch_size=16)\n\ndemo.queue()\ndemo.launch()\n```\n\n\u5728\u4e0a\u9762\u7684\u793a\u4f8b\u4e2d\uff0c\u53ef\u4ee5\u5e76\u884c\u5904\u7406 16 \u4e2a\u8bf7\u6c42\uff08\u603b\u63a8\u7406\u65f6\u95f4\u4e3a 5 \u79d2\uff09\uff0c\u800c\u4e0d\u662f\u5206\u522b\u5904\u7406\u6bcf\u4e2a\u8bf7\u6c42\uff08\u603b\u63a8\u7406\u65f6\u95f4\u4e3a 80 \u79d2\uff09\u3002\u8bb8\u591a Hugging Face \u7684 `transformers` \u548c `diffusers` \u6a21\u578b\u5728 Gradio \u7684\u6279\u5904\u7406\u6a21\u5f0f\u4e0b\u81ea\u7136\u5de5\u4f5c\uff1a\u8fd9\u662f[\u4f7f\u7528\u6279\u5904\u7406\u751f\u6210\u56fe\u50cf\u7684\u793a\u4f8b\u6f14\u793a](https://github.com/gradio-app/gradio/blob/main/demo/diffusers_with_batching/run.py)\n\n\u6ce8\u610f\uff1a\u4f7f\u7528 Gradio \u7684\u6279\u5904\u7406\u51fd\u6570 **requires** \u5728\u5e95\u5c42 Interface \u6216 Blocks \u4e2d\u542f\u7528\u961f\u5217\uff08\u8bf7\u53c2\u9605\u4e0a\u9762\u7684\u961f\u5217\u90e8\u5206\uff09\u3002\n\n## Gradio \u7b14\u8bb0\u672c (Colab Notebooks)\n\nGradio \u53ef\u4ee5\u5728\u4efb\u4f55\u8fd0\u884c Python \u7684\u5730\u65b9\u8fd0\u884c\uff0c\u5305\u62ec\u672c\u5730 Jupyter \u7b14\u8bb0\u672c\u548c\u534f\u4f5c\u7b14\u8bb0\u672c\uff0c\u5982[Google Colab](https://colab.research.google.com/)\u3002\u5bf9\u4e8e\u672c\u5730 Jupyter \u7b14\u8bb0\u672c\u548c Google Colab \u7b14\u8bb0\u672c\uff0cGradio \u5728\u672c\u5730\u670d\u52a1\u5668\u4e0a\u8fd0\u884c\uff0c\u60a8\u53ef\u4ee5\u5728\u6d4f\u89c8\u5668\u4e2d\u4e0e\u4e4b\u4ea4\u4e92\u3002\uff08\u6ce8\u610f\uff1a\u5bf9\u4e8e Google Colab\uff0c\u8fd9\u662f\u901a\u8fc7[\u670d\u52a1\u5de5\u4f5c\u5668\u96a7\u9053](https://github.com/tensorflow/tensorboard/blob/master/docs/design/colab_integration.md)\u5b9e\u73b0\u7684\uff0c\u60a8\u7684\u6d4f\u89c8\u5668\u9700\u8981\u542f\u7528 cookies\u3002\uff09\u5bf9\u4e8e\u5176\u4ed6\u8fdc\u7a0b\u7b14\u8bb0\u672c\uff0cGradio \u4e5f\u5c06\u5728\u670d\u52a1\u5668\u4e0a\u8fd0\u884c\uff0c\u4f46\u60a8\u9700\u8981\u4f7f\u7528[SSH \u96a7\u9053](https://coderwall.com/p/ohk6cg/remote-access-to-ipython-notebooks-via-ssh)\u5728\u672c\u5730\u6d4f\u89c8\u5668\u4e2d\u67e5\u770b\u5e94\u7528\u7a0b\u5e8f\u3002\u901a\u5e38\uff0c\u66f4\u7b80\u5355\u7684\u9009\u62e9\u662f\u4f7f\u7528 Gradio \u5185\u7f6e\u7684\u516c\u5171\u94fe\u63a5\uff0c[\u5728\u4e0b\u4e00\u7bc7\u6307\u5357\u4e2d\u8ba8\u8bba](/sharing-your-app/#sharing-demos)\u3002"
            },
            {
                "score": 0.7271403465071004,
                "node_text": "Here are some facts extracted from the provided text:\n\nGradio -> Supports -> Batch functions\nGr -> Is -> Alias of gradio\n\nGradio Demo: blocks_random_slider\n\n\n```\n!pip install -q gradio \n```\n\n\n```\n\nimport gradio as gr\n\n\ndef func(slider_1, slider_2):\n    return slider_1 * 5 + slider_2\n\n\nwith gr.Blocks() as demo:\n    slider = gr.Slider(minimum=-10.2, maximum=15, label=\"Random Slider (Static)\", randomize=True)\n    slider_1 = gr.Slider(minimum=100, maximum=200, label=\"Random Slider (Input 1)\", randomize=True)\n    slider_2 = gr.Slider(minimum=10, maximum=23.2, label=\"Random Slider (Input 2)\", randomize=True)\n    slider_3 = gr.Slider(value=3, label=\"Non random slider\")\n    btn = gr.Button(\"Run\")\n    btn.click(func, inputs=[slider_1, slider_2], outputs=gr.Number())\n\nif __name__ == \"__main__\":\n    demo.launch()\n\n```"
            },
            {
                "score": 0.6781540162604789,
                "node_text": "Here are some facts extracted from the provided text:\n\nGenerator function -> Is -> Provided to gradio\n\nBlocks() as demo\uff1a\n    #.\ndemo.queue()\ndemo.launch()\n```\n\n\u60a8\u53ef\u4ee5\u901a\u8fc7\u4ee5\u4e0b\u65b9\u5f0f\u63a7\u5236\u4e00\u6b21\u5904\u7406\u7684\u8bf7\u6c42\u6570\u91cf\uff1a\n\n```python\ndemo.queue(concurrency_count=3)\n```\n\n\u67e5\u770b\u6709\u5173\u914d\u7f6e\u5176\u4ed6\u961f\u5217\u53c2\u6570\u7684[\u961f\u5217\u6587\u6863](/docs/#queue)\u3002\n\n\u5728 Blocks \u4e2d\u6307\u5b9a\u4ec5\u5bf9\u67d0\u4e9b\u51fd\u6570\u8fdb\u884c\u6392\u961f\uff1a\n\n```python\nwith gr.Blocks() as demo2\uff1a\n    num1 = gr.Number()\n    num2 = gr.Number()\n    output = gr.Number()\n    gr.Button(\"Add\").click(\n        lambda a, b: a + b, [num1, num2], output)\n    gr.Button(\"Multiply\").click(\n        lambda a, b: a * b, [num1, num2], output, queue=True)\ndemo2.launch()\n```\n\n## \u8fed\u4ee3\u8f93\u51fa (Iterative Outputs)\n\n\u5728\u67d0\u4e9b\u60c5\u51b5\u4e0b\uff0c\u60a8\u53ef\u80fd\u9700\u8981\u4f20\u8f93\u4e00\u7cfb\u5217\u8f93\u51fa\u800c\u4e0d\u662f\u4e00\u6b21\u663e\u793a\u5355\u4e2a\u8f93\u51fa\u3002\u4f8b\u5982\uff0c\u60a8\u53ef\u80fd\u6709\u4e00\u4e2a\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5e0c\u671b\u663e\u793a\u751f\u6210\u7684\u6bcf\u4e2a\u6b65\u9aa4\u7684\u56fe\u50cf\uff0c\u76f4\u5230\u6700\u7ec8\u56fe\u50cf\u3002\u6216\u8005\u60a8\u53ef\u80fd\u6709\u4e00\u4e2a\u804a\u5929\u673a\u5668\u4eba\uff0c\u5b83\u9010\u5b57\u9010\u53e5\u5730\u6d41\u5f0f\u4f20\u8f93\u54cd\u5e94\uff0c\u800c\u4e0d\u662f\u4e00\u6b21\u8fd4\u56de\u5168\u90e8\u54cd\u5e94\u3002\n\n\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u60a8\u53ef\u4ee5\u5c06**\u751f\u6210\u5668**\u51fd\u6570\u63d0\u4f9b\u7ed9 Gradio\uff0c\u800c\u4e0d\u662f\u5e38\u89c4\u51fd\u6570\u3002\u5728 Python \u4e2d\u521b\u5efa\u751f\u6210\u5668\u975e\u5e38\u7b80\u5355\uff1a\u51fd\u6570\u4e0d\u5e94\u8be5\u6709\u4e00\u4e2a\u5355\u72ec\u7684 `return` \u503c\uff0c\u800c\u662f\u5e94\u8be5 with `yield` \u8fde\u7eed\u8fd4\u56de\u4e00\u7cfb\u5217\u503c\u3002\u901a\u5e38\uff0c`yield` \u8bed\u53e5\u653e\u7f6e\u5728\u67d0\u79cd\u5faa\u73af\u4e2d\u3002\u4e0b\u9762\u662f\u4e00\u4e2a\u7b80\u5355\u793a\u4f8b\uff0c\u751f\u6210\u5668\u53ea\u662f\u7b80\u5355\u8ba1\u6570\u5230\u7ed9\u5b9a\u6570\u5b57\uff1a\n\n```python\ndef my_generator(x):\n    for i in range(x):\n        yield i\n```\n\n\u60a8\u4ee5\u4e0e\u5e38\u89c4\u51fd\u6570\u76f8\u540c\u7684\u65b9\u5f0f\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio\u3002\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\uff08\u865a\u62df\u7684\uff09\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5b83\u5728\u8f93\u51fa\u56fe\u50cf\u4e4b\u524d\u751f\u6210\u6570\u4e2a\u6b65\u9aa4\u7684\u566a\u97f3\uff1a\n\n$code_fake_diffusion\n$demo_fake_diffusion\n\n\u8bf7\u6ce8\u610f\uff0c\u6211\u4eec\u5728\u8fed\u4ee3\u5668\u4e2d\u6dfb\u52a0\u4e86 `time.sleep(1)`\uff0c\u4ee5\u521b\u5efa\u6b65\u9aa4\u4e4b\u95f4\u7684\u4eba\u5de5\u6682\u505c\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u89c2\u5bdf\u8fed\u4ee3\u5668\u7684\u6b65\u9aa4\uff08\u5728\u771f\u5b9e\u7684\u56fe\u50cf\u751f\u6210\u6a21\u578b\u4e2d\uff0c\u8fd9\u53ef\u80fd\u662f\u4e0d\u5fc5\u8981\u7684\uff09\u3002\n\n\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio **\u9700\u8981**\u5728\u5e95\u5c42 Interface \u6216 Blocks \u4e2d\u542f\u7528\u961f\u5217\uff08\u8bf7\u53c2\u9605\u4e0a\u9762\u7684\u961f\u5217\u90e8\u5206\uff09\u3002\n\n## \u8fdb\u5ea6\u6761\n\nGradio \u652f\u6301\u521b\u5efa\u81ea\u5b9a\u4e49\u8fdb\u5ea6\u6761\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u81ea\u5b9a\u4e49\u548c\u63a7\u5236\u5411\u7528\u6237\u663e\u793a\u7684\u8fdb\u5ea6\u66f4\u65b0\u3002\u8981\u542f\u7528\u6b64\u529f\u80fd\uff0c\u53ea\u9700\u4e3a\u65b9\u6cd5\u6dfb\u52a0\u4e00\u4e2a\u9ed8\u8ba4\u503c\u4e3a `gr.Progress` \u5b9e\u4f8b\u7684\u53c2\u6570\u5373\u53ef\u3002\u7136\u540e\uff0c\u60a8\u53ef\u4ee5\u76f4\u63a5\u8c03\u7528\u6b64\u5b9e\u4f8b\u5e76\u4f20\u5165 0 \u5230 1 \u4e4b\u95f4\u7684\u6d6e\u70b9\u6570\u6765\u66f4\u65b0\u8fdb\u5ea6\u7ea7\u522b\uff0c\u6216\u8005 with `Progress` \u5b9e\u4f8b\u7684 `tqdm()` \u65b9\u6cd5\u6765\u8ddf\u8e2a\u53ef\u8fed\u4ee3\u5bf9\u8c61\u4e0a\u7684\u8fdb\u5ea6\uff0c\u5982\u4e0b\u6240\u793a\u3002\u5fc5\u987b\u542f\u7528\u961f\u5217\u4ee5\u8fdb\u884c\u8fdb\u5ea6\u66f4\u65b0\u3002\n\n$code_progress_simple\n$demo_progress_simple\n\n\u5982\u679c\u60a8 with `tqdm` \u5e93\uff0c\u5e76\u4e14\u5e0c\u671b\u4ece\u51fd\u6570\u5185\u90e8\u7684\u4efb\u4f55 `tqdm.tqdm` \u81ea\u52a8\u62a5\u544a\u8fdb\u5ea6\u66f4\u65b0\uff0c\u8bf7\u5c06\u9ed8\u8ba4\u53c2\u6570\u8bbe\u7f6e\u4e3a `gr.Progress(track_tqdm=True)`\uff01\n\n## \u6279\u5904\u7406\u51fd\u6570 (Batch Functions)\n\nGradio \u652f\u6301\u4f20\u9012*\u6279\u5904\u7406*\u51fd\u6570\u3002\u6279\u5904\u7406\u51fd\u6570\u53ea\u662f\u63a5\u53d7\u8f93\u5165\u5217\u8868\u5e76\u8fd4\u56de\u9884\u6d4b\u5217\u8868\u7684\u51fd\u6570\u3002\n\n\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\u6279\u5904\u7406\u51fd\u6570\uff0c\u5b83\u63a5\u53d7\u4e24\u4e2a\u8f93\u5165\u5217\u8868\uff08\u4e00\u4e2a\u5355\u8bcd\u5217\u8868\u548c\u4e00\u4e2a\u6574\u6570\u5217\u8868\uff09\uff0c\u5e76\u8fd4\u56de\u4fee\u526a\u8fc7\u7684\u5355\u8bcd\u5217\u8868\u4f5c\u4e3a\u8f93\u51fa\uff1a\n\n```python\nimport time\n\ndef trim_words(words, lens):\n    trimmed_words = []\n    time.sleep(5)\n    for w, l in zip(words, lens):\n        trimmed_words.append(w[:int(l)])\n    return [trimmed_words]\n    for w, l in zip(words,"
            }
        ]
    },
    {
        "sample_idx": 29,
        "question": "What is a batch function in Gradio?",
        "answer": "A batch function is a function that accepts input lists and returns prediction lists.",
        "rag_answer": "A batch function in Gradio is a function that accepts input lists and returns prediction lists.",
        "rag_score": 5,
        "rag_feedback": "The system's response is completely correct, accurate, and factual. It provides a clear and concise definition of a batch function in Gradio, which matches the expected answer.",
        "rag_context": [
            {
                "score": 0.7271403465071004,
                "node_text": "Here are some facts extracted from the provided text:\n\nBatch functions -> Accept -> Input lists\nBatch functions -> Return -> Prediction lists\nTrim_words -> Is -> Batch function\n\ntqdm` \u81ea\u52a8\u62a5\u544a\u8fdb\u5ea6\u66f4\u65b0\uff0c\u8bf7\u5c06\u9ed8\u8ba4\u53c2\u6570\u8bbe\u7f6e\u4e3a `gr.Progress(track_tqdm=True)`\uff01\n\n## \u6279\u5904\u7406\u51fd\u6570 (Batch Functions)\n\nGradio \u652f\u6301\u4f20\u9012*\u6279\u5904\u7406*\u51fd\u6570\u3002\u6279\u5904\u7406\u51fd\u6570\u53ea\u662f\u63a5\u53d7\u8f93\u5165\u5217\u8868\u5e76\u8fd4\u56de\u9884\u6d4b\u5217\u8868\u7684\u51fd\u6570\u3002\n\n\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\u6279\u5904\u7406\u51fd\u6570\uff0c\u5b83\u63a5\u53d7\u4e24\u4e2a\u8f93\u5165\u5217\u8868\uff08\u4e00\u4e2a\u5355\u8bcd\u5217\u8868\u548c\u4e00\u4e2a\u6574\u6570\u5217\u8868\uff09\uff0c\u5e76\u8fd4\u56de\u4fee\u526a\u8fc7\u7684\u5355\u8bcd\u5217\u8868\u4f5c\u4e3a\u8f93\u51fa\uff1a\n\n```python\nimport time\n\ndef trim_words(words, lens):\n    trimmed_words = []\n    time.sleep(5)\n    for w, l in zip(words, lens):\n        trimmed_words.append(w[:int(l)])\n    return [trimmed_words]\n    for w, l in zip(words, lens):\n```\n\n\u4f7f\u7528\u6279\u5904\u7406\u51fd\u6570\u7684\u4f18\u70b9\u662f\uff0c\u5982\u679c\u542f\u7528\u4e86\u961f\u5217\uff0cGradio \u670d\u52a1\u5668\u53ef\u4ee5\u81ea\u52a8*\u6279\u5904\u7406*\u4f20\u5165\u7684\u8bf7\u6c42\u5e76\u5e76\u884c\u5904\u7406\u5b83\u4eec\uff0c\u4ece\u800c\u53ef\u80fd\u52a0\u5feb\u6f14\u793a\u901f\u5ea6\u3002\u4ee5\u4e0b\u662f Gradio \u4ee3\u7801\u7684\u793a\u4f8b\uff08\u8bf7\u6ce8\u610f `batch=True` \u548c `max_batch_size=16` - \u8fd9\u4e24\u4e2a\u53c2\u6570\u90fd\u53ef\u4ee5\u4f20\u9012\u7ed9\u4e8b\u4ef6\u89e6\u53d1\u5668\u6216 `Interface` \u7c7b\uff09\n\nwith `Interface`\uff1a\n\n```python\ndemo = gr.Interface(trim_words, [\"textbox\", \"number\"], [\"output\"],\n                    batch=True, max_batch_size=16)\ndemo.queue()\ndemo.launch()\n```\n\nwith `Blocks`\uff1a\n\n```python\nimport gradio as gr\n\nwith gr.Blocks() as demo:\n    with gr.Row():\n        word = gr.Textbox(label=\"word\")\n        leng = gr.Number(label=\"leng\")\n        output = gr.Textbox(label=\"Output\")\n    with gr.Row():\n        run = gr.Button()\n\n    event = run.click(trim_words, [word, leng], output, batch=True, max_batch_size=16)\n\ndemo.queue()\ndemo.launch()\n```\n\n\u5728\u4e0a\u9762\u7684\u793a\u4f8b\u4e2d\uff0c\u53ef\u4ee5\u5e76\u884c\u5904\u7406 16 \u4e2a\u8bf7\u6c42\uff08\u603b\u63a8\u7406\u65f6\u95f4\u4e3a 5 \u79d2\uff09\uff0c\u800c\u4e0d\u662f\u5206\u522b\u5904\u7406\u6bcf\u4e2a\u8bf7\u6c42\uff08\u603b\u63a8\u7406\u65f6\u95f4\u4e3a 80 \u79d2\uff09\u3002\u8bb8\u591a Hugging Face \u7684 `transformers` \u548c `diffusers` \u6a21\u578b\u5728 Gradio \u7684\u6279\u5904\u7406\u6a21\u5f0f\u4e0b\u81ea\u7136\u5de5\u4f5c\uff1a\u8fd9\u662f[\u4f7f\u7528\u6279\u5904\u7406\u751f\u6210\u56fe\u50cf\u7684\u793a\u4f8b\u6f14\u793a](https://github.com/gradio-app/gradio/blob/main/demo/diffusers_with_batching/run.py)\n\n\u6ce8\u610f\uff1a\u4f7f\u7528 Gradio \u7684\u6279\u5904\u7406\u51fd\u6570 **requires** \u5728\u5e95\u5c42 Interface \u6216 Blocks \u4e2d\u542f\u7528\u961f\u5217\uff08\u8bf7\u53c2\u9605\u4e0a\u9762\u7684\u961f\u5217\u90e8\u5206\uff09\u3002\n\n## Gradio \u7b14\u8bb0\u672c (Colab Notebooks)\n\nGradio \u53ef\u4ee5\u5728\u4efb\u4f55\u8fd0\u884c Python \u7684\u5730\u65b9\u8fd0\u884c\uff0c\u5305\u62ec\u672c\u5730 Jupyter \u7b14\u8bb0\u672c\u548c\u534f\u4f5c\u7b14\u8bb0\u672c\uff0c\u5982[Google Colab](https://colab.research.google.com/)\u3002\u5bf9\u4e8e\u672c\u5730 Jupyter \u7b14\u8bb0\u672c\u548c Google Colab \u7b14\u8bb0\u672c\uff0cGradio \u5728\u672c\u5730\u670d\u52a1\u5668\u4e0a\u8fd0\u884c\uff0c\u60a8\u53ef\u4ee5\u5728\u6d4f\u89c8\u5668\u4e2d\u4e0e\u4e4b\u4ea4\u4e92\u3002\uff08\u6ce8\u610f\uff1a\u5bf9\u4e8e Google Colab\uff0c\u8fd9\u662f\u901a\u8fc7[\u670d\u52a1\u5de5\u4f5c\u5668\u96a7\u9053](https://github.com/tensorflow/tensorboard/blob/master/docs/design/colab_integration.md)\u5b9e\u73b0\u7684\uff0c\u60a8\u7684\u6d4f\u89c8\u5668\u9700\u8981\u542f\u7528 cookies\u3002\uff09\u5bf9\u4e8e\u5176\u4ed6\u8fdc\u7a0b\u7b14\u8bb0\u672c\uff0cGradio \u4e5f\u5c06\u5728\u670d\u52a1\u5668\u4e0a\u8fd0\u884c\uff0c\u4f46\u60a8\u9700\u8981\u4f7f\u7528[SSH \u96a7\u9053](https://coderwall.com/p/ohk6cg/remote-access-to-ipython-notebooks-via-ssh)\u5728\u672c\u5730\u6d4f\u89c8\u5668\u4e2d\u67e5\u770b\u5e94\u7528\u7a0b\u5e8f\u3002\u901a\u5e38\uff0c\u66f4\u7b80\u5355\u7684\u9009\u62e9\u662f\u4f7f\u7528 Gradio \u5185\u7f6e\u7684\u516c\u5171\u94fe\u63a5\uff0c[\u5728\u4e0b\u4e00\u7bc7\u6307\u5357\u4e2d\u8ba8\u8bba](/sharing-your-app/#sharing-demos)\u3002"
            },
            {
                "score": 0.7271403465071004,
                "node_text": "Here are some facts extracted from the provided text:\n\nGradio -> Supports -> Batch functions\nGr -> Is -> Alias of gradio\n\nGradio Demo: blocks_random_slider\n\n\n```\n!pip install -q gradio \n```\n\n\n```\n\nimport gradio as gr\n\n\ndef func(slider_1, slider_2):\n    return slider_1 * 5 + slider_2\n\n\nwith gr.Blocks() as demo:\n    slider = gr.Slider(minimum=-10.2, maximum=15, label=\"Random Slider (Static)\", randomize=True)\n    slider_1 = gr.Slider(minimum=100, maximum=200, label=\"Random Slider (Input 1)\", randomize=True)\n    slider_2 = gr.Slider(minimum=10, maximum=23.2, label=\"Random Slider (Input 2)\", randomize=True)\n    slider_3 = gr.Slider(value=3, label=\"Non random slider\")\n    btn = gr.Button(\"Run\")\n    btn.click(func, inputs=[slider_1, slider_2], outputs=gr.Number())\n\nif __name__ == \"__main__\":\n    demo.launch()\n\n```"
            },
            {
                "score": 0.6781540162604789,
                "node_text": "Here are some facts extracted from the provided text:\n\nGenerator function -> Is -> Provided to gradio\n\nBlocks() as demo\uff1a\n    #.\ndemo.queue()\ndemo.launch()\n```\n\n\u60a8\u53ef\u4ee5\u901a\u8fc7\u4ee5\u4e0b\u65b9\u5f0f\u63a7\u5236\u4e00\u6b21\u5904\u7406\u7684\u8bf7\u6c42\u6570\u91cf\uff1a\n\n```python\ndemo.queue(concurrency_count=3)\n```\n\n\u67e5\u770b\u6709\u5173\u914d\u7f6e\u5176\u4ed6\u961f\u5217\u53c2\u6570\u7684[\u961f\u5217\u6587\u6863](/docs/#queue)\u3002\n\n\u5728 Blocks \u4e2d\u6307\u5b9a\u4ec5\u5bf9\u67d0\u4e9b\u51fd\u6570\u8fdb\u884c\u6392\u961f\uff1a\n\n```python\nwith gr.Blocks() as demo2\uff1a\n    num1 = gr.Number()\n    num2 = gr.Number()\n    output = gr.Number()\n    gr.Button(\"Add\").click(\n        lambda a, b: a + b, [num1, num2], output)\n    gr.Button(\"Multiply\").click(\n        lambda a, b: a * b, [num1, num2], output, queue=True)\ndemo2.launch()\n```\n\n## \u8fed\u4ee3\u8f93\u51fa (Iterative Outputs)\n\n\u5728\u67d0\u4e9b\u60c5\u51b5\u4e0b\uff0c\u60a8\u53ef\u80fd\u9700\u8981\u4f20\u8f93\u4e00\u7cfb\u5217\u8f93\u51fa\u800c\u4e0d\u662f\u4e00\u6b21\u663e\u793a\u5355\u4e2a\u8f93\u51fa\u3002\u4f8b\u5982\uff0c\u60a8\u53ef\u80fd\u6709\u4e00\u4e2a\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5e0c\u671b\u663e\u793a\u751f\u6210\u7684\u6bcf\u4e2a\u6b65\u9aa4\u7684\u56fe\u50cf\uff0c\u76f4\u5230\u6700\u7ec8\u56fe\u50cf\u3002\u6216\u8005\u60a8\u53ef\u80fd\u6709\u4e00\u4e2a\u804a\u5929\u673a\u5668\u4eba\uff0c\u5b83\u9010\u5b57\u9010\u53e5\u5730\u6d41\u5f0f\u4f20\u8f93\u54cd\u5e94\uff0c\u800c\u4e0d\u662f\u4e00\u6b21\u8fd4\u56de\u5168\u90e8\u54cd\u5e94\u3002\n\n\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u60a8\u53ef\u4ee5\u5c06**\u751f\u6210\u5668**\u51fd\u6570\u63d0\u4f9b\u7ed9 Gradio\uff0c\u800c\u4e0d\u662f\u5e38\u89c4\u51fd\u6570\u3002\u5728 Python \u4e2d\u521b\u5efa\u751f\u6210\u5668\u975e\u5e38\u7b80\u5355\uff1a\u51fd\u6570\u4e0d\u5e94\u8be5\u6709\u4e00\u4e2a\u5355\u72ec\u7684 `return` \u503c\uff0c\u800c\u662f\u5e94\u8be5 with `yield` \u8fde\u7eed\u8fd4\u56de\u4e00\u7cfb\u5217\u503c\u3002\u901a\u5e38\uff0c`yield` \u8bed\u53e5\u653e\u7f6e\u5728\u67d0\u79cd\u5faa\u73af\u4e2d\u3002\u4e0b\u9762\u662f\u4e00\u4e2a\u7b80\u5355\u793a\u4f8b\uff0c\u751f\u6210\u5668\u53ea\u662f\u7b80\u5355\u8ba1\u6570\u5230\u7ed9\u5b9a\u6570\u5b57\uff1a\n\n```python\ndef my_generator(x):\n    for i in range(x):\n        yield i\n```\n\n\u60a8\u4ee5\u4e0e\u5e38\u89c4\u51fd\u6570\u76f8\u540c\u7684\u65b9\u5f0f\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio\u3002\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\uff08\u865a\u62df\u7684\uff09\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5b83\u5728\u8f93\u51fa\u56fe\u50cf\u4e4b\u524d\u751f\u6210\u6570\u4e2a\u6b65\u9aa4\u7684\u566a\u97f3\uff1a\n\n$code_fake_diffusion\n$demo_fake_diffusion\n\n\u8bf7\u6ce8\u610f\uff0c\u6211\u4eec\u5728\u8fed\u4ee3\u5668\u4e2d\u6dfb\u52a0\u4e86 `time.sleep(1)`\uff0c\u4ee5\u521b\u5efa\u6b65\u9aa4\u4e4b\u95f4\u7684\u4eba\u5de5\u6682\u505c\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u89c2\u5bdf\u8fed\u4ee3\u5668\u7684\u6b65\u9aa4\uff08\u5728\u771f\u5b9e\u7684\u56fe\u50cf\u751f\u6210\u6a21\u578b\u4e2d\uff0c\u8fd9\u53ef\u80fd\u662f\u4e0d\u5fc5\u8981\u7684\uff09\u3002\n\n\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio **\u9700\u8981**\u5728\u5e95\u5c42 Interface \u6216 Blocks \u4e2d\u542f\u7528\u961f\u5217\uff08\u8bf7\u53c2\u9605\u4e0a\u9762\u7684\u961f\u5217\u90e8\u5206\uff09\u3002\n\n## \u8fdb\u5ea6\u6761\n\nGradio \u652f\u6301\u521b\u5efa\u81ea\u5b9a\u4e49\u8fdb\u5ea6\u6761\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u81ea\u5b9a\u4e49\u548c\u63a7\u5236\u5411\u7528\u6237\u663e\u793a\u7684\u8fdb\u5ea6\u66f4\u65b0\u3002\u8981\u542f\u7528\u6b64\u529f\u80fd\uff0c\u53ea\u9700\u4e3a\u65b9\u6cd5\u6dfb\u52a0\u4e00\u4e2a\u9ed8\u8ba4\u503c\u4e3a `gr.Progress` \u5b9e\u4f8b\u7684\u53c2\u6570\u5373\u53ef\u3002\u7136\u540e\uff0c\u60a8\u53ef\u4ee5\u76f4\u63a5\u8c03\u7528\u6b64\u5b9e\u4f8b\u5e76\u4f20\u5165 0 \u5230 1 \u4e4b\u95f4\u7684\u6d6e\u70b9\u6570\u6765\u66f4\u65b0\u8fdb\u5ea6\u7ea7\u522b\uff0c\u6216\u8005 with `Progress` \u5b9e\u4f8b\u7684 `tqdm()` \u65b9\u6cd5\u6765\u8ddf\u8e2a\u53ef\u8fed\u4ee3\u5bf9\u8c61\u4e0a\u7684\u8fdb\u5ea6\uff0c\u5982\u4e0b\u6240\u793a\u3002\u5fc5\u987b\u542f\u7528\u961f\u5217\u4ee5\u8fdb\u884c\u8fdb\u5ea6\u66f4\u65b0\u3002\n\n$code_progress_simple\n$demo_progress_simple\n\n\u5982\u679c\u60a8 with `tqdm` \u5e93\uff0c\u5e76\u4e14\u5e0c\u671b\u4ece\u51fd\u6570\u5185\u90e8\u7684\u4efb\u4f55 `tqdm.tqdm` \u81ea\u52a8\u62a5\u544a\u8fdb\u5ea6\u66f4\u65b0\uff0c\u8bf7\u5c06\u9ed8\u8ba4\u53c2\u6570\u8bbe\u7f6e\u4e3a `gr.Progress(track_tqdm=True)`\uff01\n\n## \u6279\u5904\u7406\u51fd\u6570 (Batch Functions)\n\nGradio \u652f\u6301\u4f20\u9012*\u6279\u5904\u7406*\u51fd\u6570\u3002\u6279\u5904\u7406\u51fd\u6570\u53ea\u662f\u63a5\u53d7\u8f93\u5165\u5217\u8868\u5e76\u8fd4\u56de\u9884\u6d4b\u5217\u8868\u7684\u51fd\u6570\u3002\n\n\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\u6279\u5904\u7406\u51fd\u6570\uff0c\u5b83\u63a5\u53d7\u4e24\u4e2a\u8f93\u5165\u5217\u8868\uff08\u4e00\u4e2a\u5355\u8bcd\u5217\u8868\u548c\u4e00\u4e2a\u6574\u6570\u5217\u8868\uff09\uff0c\u5e76\u8fd4\u56de\u4fee\u526a\u8fc7\u7684\u5355\u8bcd\u5217\u8868\u4f5c\u4e3a\u8f93\u51fa\uff1a\n\n```python\nimport time\n\ndef trim_words(words, lens):\n    trimmed_words = []\n    time.sleep(5)\n    for w, l in zip(words, lens):\n        trimmed_words.append(w[:int(l)])\n    return [trimmed_words]\n    for w, l in zip(words,"
            }
        ]
    },
    {
        "sample_idx": 30,
        "question": "What is the advantage of using batch functions in Gradio?",
        "answer": "Using batch functions allows Gradio servers to automatically batch incoming requests and process them in parallel, potentially speeding up demo speed.",
        "rag_answer": "The advantage of using batch functions in Gradio is that if queuing is enabled, the Gradio server can automatically batch incoming requests and process them in parallel, which can potentially speed up the demo.",
        "rag_score": 4,
        "rag_feedback": "The system's response is mostly correct, accurate, and factual. It provides a detailed explanation of batch functions in Gradio, including their advantages and how they can be used to speed up demo speed. The response also includes relevant code examples and additional information about Gradio's features. However, the response is not a direct answer to the question and includes unnecessary information.",
        "rag_context": [
            {
                "score": 0.6833897461285855,
                "node_text": "Here are some facts extracted from the provided text:\n\nGr -> Is -> Alias of gradio\nGradio -> Supports -> Batch functions\nGradio -> Provides -> Pre-built themes\nGradio -> Is -> Library\nGradio -> Supports -> Iterative outputs\nGradio -> Has feature -> \u6dfb\u52a0\u63cf\u8ff0\u5185\u5bb9\nGradio -> Converts -> Data format\nGradio -> Has feature -> \u8fdb\u5ea6\u6761\nGradio -> Automatically handles -> Preprocessing\nGradio -> Has feature -> \u8bbe\u7f6e\u65d7\u6807\nGradio -> Has feature -> \u8fed\u4ee3\u8f93\u51fa\nGradio -> Has feature -> \u9884\u5904\u7406\u548c\u540e\u5904\u7406\nGradio -> Installed by -> Pip\nGradio -> Has feature -> \u6392\u961f\u7528\u6237\nGradio -> Recognizes -> Data format\nGradio -> Automatically handles -> Postprocessing\nGradio -> Supports -> Hugging face models\nGradio -> Enables -> Parallel processing\nGradio -> Has feature -> \u6279\u5904\u7406\u51fd\u6570\nGradio -> Has feature -> \u4f20\u9012\u81ea\u5b9a\u4e49\u9519\u8bef\u6d88\u606f\nGradio -> Can run -> In colab notebooks\nGradio -> Supports -> Progress bars\nGradio -> Includes -> Components\nGradio -> Has feature -> \u6837\u5f0f\u5316\u6f14\u793a\nGradio -> Has feature -> \u6dfb\u52a0\u793a\u4f8b\u8f93\u5165\n\nGradio Demo: blocks_random_slider\n\n\n```\n!pip install -q gradio \n```\n\n\n```\n\nimport gradio as gr\n\n\ndef func(slider_1, slider_2):\n    return slider_1 * 5 + slider_2\n\n\nwith gr.Blocks() as demo:\n    slider = gr.Slider(minimum=-10.2, maximum=15, label=\"Random Slider (Static)\", randomize=True)\n    slider_1 = gr.Slider(minimum=100, maximum=200, label=\"Random Slider (Input 1)\", randomize=True)\n    slider_2 = gr.Slider(minimum=10, maximum=23.2, label=\"Random Slider (Input 2)\", randomize=True)\n    slider_3 = gr.Slider(value=3, label=\"Non random slider\")\n    btn = gr.Button(\"Run\")\n    btn.click(func, inputs=[slider_1, slider_2], outputs=gr.Number())\n\nif __name__ == \"__main__\":\n    demo.launch()\n\n```"
            },
            {
                "score": 0.6465626797898758,
                "node_text": "Here are some facts extracted from the provided text:\n\nBatch functions -> Accept -> Input lists\nBatch functions -> Return -> Prediction lists\n\ntqdm` \u81ea\u52a8\u62a5\u544a\u8fdb\u5ea6\u66f4\u65b0\uff0c\u8bf7\u5c06\u9ed8\u8ba4\u53c2\u6570\u8bbe\u7f6e\u4e3a `gr.Progress(track_tqdm=True)`\uff01\n\n## \u6279\u5904\u7406\u51fd\u6570 (Batch Functions)\n\nGradio \u652f\u6301\u4f20\u9012*\u6279\u5904\u7406*\u51fd\u6570\u3002\u6279\u5904\u7406\u51fd\u6570\u53ea\u662f\u63a5\u53d7\u8f93\u5165\u5217\u8868\u5e76\u8fd4\u56de\u9884\u6d4b\u5217\u8868\u7684\u51fd\u6570\u3002\n\n\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\u6279\u5904\u7406\u51fd\u6570\uff0c\u5b83\u63a5\u53d7\u4e24\u4e2a\u8f93\u5165\u5217\u8868\uff08\u4e00\u4e2a\u5355\u8bcd\u5217\u8868\u548c\u4e00\u4e2a\u6574\u6570\u5217\u8868\uff09\uff0c\u5e76\u8fd4\u56de\u4fee\u526a\u8fc7\u7684\u5355\u8bcd\u5217\u8868\u4f5c\u4e3a\u8f93\u51fa\uff1a\n\n```python\nimport time\n\ndef trim_words(words, lens):\n    trimmed_words = []\n    time.sleep(5)\n    for w, l in zip(words, lens):\n        trimmed_words.append(w[:int(l)])\n    return [trimmed_words]\n    for w, l in zip(words, lens):\n```\n\n\u4f7f\u7528\u6279\u5904\u7406\u51fd\u6570\u7684\u4f18\u70b9\u662f\uff0c\u5982\u679c\u542f\u7528\u4e86\u961f\u5217\uff0cGradio \u670d\u52a1\u5668\u53ef\u4ee5\u81ea\u52a8*\u6279\u5904\u7406*\u4f20\u5165\u7684\u8bf7\u6c42\u5e76\u5e76\u884c\u5904\u7406\u5b83\u4eec\uff0c\u4ece\u800c\u53ef\u80fd\u52a0\u5feb\u6f14\u793a\u901f\u5ea6\u3002\u4ee5\u4e0b\u662f Gradio \u4ee3\u7801\u7684\u793a\u4f8b\uff08\u8bf7\u6ce8\u610f `batch=True` \u548c `max_batch_size=16` - \u8fd9\u4e24\u4e2a\u53c2\u6570\u90fd\u53ef\u4ee5\u4f20\u9012\u7ed9\u4e8b\u4ef6\u89e6\u53d1\u5668\u6216 `Interface` \u7c7b\uff09\n\nwith `Interface`\uff1a\n\n```python\ndemo = gr.Interface(trim_words, [\"textbox\", \"number\"], [\"output\"],\n                    batch=True, max_batch_size=16)\ndemo.queue()\ndemo.launch()\n```\n\nwith `Blocks`\uff1a\n\n```python\nimport gradio as gr\n\nwith gr.Blocks() as demo:\n    with gr.Row():\n        word = gr.Textbox(label=\"word\")\n        leng = gr.Number(label=\"leng\")\n        output = gr.Textbox(label=\"Output\")\n    with gr.Row():\n        run = gr.Button()\n\n    event = run.click(trim_words, [word, leng], output, batch=True, max_batch_size=16)\n\ndemo.queue()\ndemo.launch()\n```\n\n\u5728\u4e0a\u9762\u7684\u793a\u4f8b\u4e2d\uff0c\u53ef\u4ee5\u5e76\u884c\u5904\u7406 16 \u4e2a\u8bf7\u6c42\uff08\u603b\u63a8\u7406\u65f6\u95f4\u4e3a 5 \u79d2\uff09\uff0c\u800c\u4e0d\u662f\u5206\u522b\u5904\u7406\u6bcf\u4e2a\u8bf7\u6c42\uff08\u603b\u63a8\u7406\u65f6\u95f4\u4e3a 80 \u79d2\uff09\u3002\u8bb8\u591a Hugging Face \u7684 `transformers` \u548c `diffusers` \u6a21\u578b\u5728 Gradio \u7684\u6279\u5904\u7406\u6a21\u5f0f\u4e0b\u81ea\u7136\u5de5\u4f5c\uff1a\u8fd9\u662f[\u4f7f\u7528\u6279\u5904\u7406\u751f\u6210\u56fe\u50cf\u7684\u793a\u4f8b\u6f14\u793a](https://github.com/gradio-app/gradio/blob/main/demo/diffusers_with_batching/run.py)\n\n\u6ce8\u610f\uff1a\u4f7f\u7528 Gradio \u7684\u6279\u5904\u7406\u51fd\u6570 **requires** \u5728\u5e95\u5c42 Interface \u6216 Blocks \u4e2d\u542f\u7528\u961f\u5217\uff08\u8bf7\u53c2\u9605\u4e0a\u9762\u7684\u961f\u5217\u90e8\u5206\uff09\u3002\n\n## Gradio \u7b14\u8bb0\u672c (Colab Notebooks)\n\nGradio \u53ef\u4ee5\u5728\u4efb\u4f55\u8fd0\u884c Python \u7684\u5730\u65b9\u8fd0\u884c\uff0c\u5305\u62ec\u672c\u5730 Jupyter \u7b14\u8bb0\u672c\u548c\u534f\u4f5c\u7b14\u8bb0\u672c\uff0c\u5982[Google Colab](https://colab.research.google.com/)\u3002\u5bf9\u4e8e\u672c\u5730 Jupyter \u7b14\u8bb0\u672c\u548c Google Colab \u7b14\u8bb0\u672c\uff0cGradio \u5728\u672c\u5730\u670d\u52a1\u5668\u4e0a\u8fd0\u884c\uff0c\u60a8\u53ef\u4ee5\u5728\u6d4f\u89c8\u5668\u4e2d\u4e0e\u4e4b\u4ea4\u4e92\u3002\uff08\u6ce8\u610f\uff1a\u5bf9\u4e8e Google Colab\uff0c\u8fd9\u662f\u901a\u8fc7[\u670d\u52a1\u5de5\u4f5c\u5668\u96a7\u9053](https://github.com/tensorflow/tensorboard/blob/master/docs/design/colab_integration.md)\u5b9e\u73b0\u7684\uff0c\u60a8\u7684\u6d4f\u89c8\u5668\u9700\u8981\u542f\u7528 cookies\u3002\uff09\u5bf9\u4e8e\u5176\u4ed6\u8fdc\u7a0b\u7b14\u8bb0\u672c\uff0cGradio \u4e5f\u5c06\u5728\u670d\u52a1\u5668\u4e0a\u8fd0\u884c\uff0c\u4f46\u60a8\u9700\u8981\u4f7f\u7528[SSH \u96a7\u9053](https://coderwall.com/p/ohk6cg/remote-access-to-ipython-notebooks-via-ssh)\u5728\u672c\u5730\u6d4f\u89c8\u5668\u4e2d\u67e5\u770b\u5e94\u7528\u7a0b\u5e8f\u3002\u901a\u5e38\uff0c\u66f4\u7b80\u5355\u7684\u9009\u62e9\u662f\u4f7f\u7528 Gradio \u5185\u7f6e\u7684\u516c\u5171\u94fe\u63a5\uff0c[\u5728\u4e0b\u4e00\u7bc7\u6307\u5357\u4e2d\u8ba8\u8bba](/sharing-your-app/#sharing-demos)\u3002"
            },
            {
                "score": 0.643111836391873,
                "node_text": "Here are some facts extracted from the provided text:\n\nGenerator function -> Is -> Provided to gradio\n\nBlocks() as demo\uff1a\n    #.\ndemo.queue()\ndemo.launch()\n```\n\n\u60a8\u53ef\u4ee5\u901a\u8fc7\u4ee5\u4e0b\u65b9\u5f0f\u63a7\u5236\u4e00\u6b21\u5904\u7406\u7684\u8bf7\u6c42\u6570\u91cf\uff1a\n\n```python\ndemo.queue(concurrency_count=3)\n```\n\n\u67e5\u770b\u6709\u5173\u914d\u7f6e\u5176\u4ed6\u961f\u5217\u53c2\u6570\u7684[\u961f\u5217\u6587\u6863](/docs/#queue)\u3002\n\n\u5728 Blocks \u4e2d\u6307\u5b9a\u4ec5\u5bf9\u67d0\u4e9b\u51fd\u6570\u8fdb\u884c\u6392\u961f\uff1a\n\n```python\nwith gr.Blocks() as demo2\uff1a\n    num1 = gr.Number()\n    num2 = gr.Number()\n    output = gr.Number()\n    gr.Button(\"Add\").click(\n        lambda a, b: a + b, [num1, num2], output)\n    gr.Button(\"Multiply\").click(\n        lambda a, b: a * b, [num1, num2], output, queue=True)\ndemo2.launch()\n```\n\n## \u8fed\u4ee3\u8f93\u51fa (Iterative Outputs)\n\n\u5728\u67d0\u4e9b\u60c5\u51b5\u4e0b\uff0c\u60a8\u53ef\u80fd\u9700\u8981\u4f20\u8f93\u4e00\u7cfb\u5217\u8f93\u51fa\u800c\u4e0d\u662f\u4e00\u6b21\u663e\u793a\u5355\u4e2a\u8f93\u51fa\u3002\u4f8b\u5982\uff0c\u60a8\u53ef\u80fd\u6709\u4e00\u4e2a\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5e0c\u671b\u663e\u793a\u751f\u6210\u7684\u6bcf\u4e2a\u6b65\u9aa4\u7684\u56fe\u50cf\uff0c\u76f4\u5230\u6700\u7ec8\u56fe\u50cf\u3002\u6216\u8005\u60a8\u53ef\u80fd\u6709\u4e00\u4e2a\u804a\u5929\u673a\u5668\u4eba\uff0c\u5b83\u9010\u5b57\u9010\u53e5\u5730\u6d41\u5f0f\u4f20\u8f93\u54cd\u5e94\uff0c\u800c\u4e0d\u662f\u4e00\u6b21\u8fd4\u56de\u5168\u90e8\u54cd\u5e94\u3002\n\n\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u60a8\u53ef\u4ee5\u5c06**\u751f\u6210\u5668**\u51fd\u6570\u63d0\u4f9b\u7ed9 Gradio\uff0c\u800c\u4e0d\u662f\u5e38\u89c4\u51fd\u6570\u3002\u5728 Python \u4e2d\u521b\u5efa\u751f\u6210\u5668\u975e\u5e38\u7b80\u5355\uff1a\u51fd\u6570\u4e0d\u5e94\u8be5\u6709\u4e00\u4e2a\u5355\u72ec\u7684 `return` \u503c\uff0c\u800c\u662f\u5e94\u8be5 with `yield` \u8fde\u7eed\u8fd4\u56de\u4e00\u7cfb\u5217\u503c\u3002\u901a\u5e38\uff0c`yield` \u8bed\u53e5\u653e\u7f6e\u5728\u67d0\u79cd\u5faa\u73af\u4e2d\u3002\u4e0b\u9762\u662f\u4e00\u4e2a\u7b80\u5355\u793a\u4f8b\uff0c\u751f\u6210\u5668\u53ea\u662f\u7b80\u5355\u8ba1\u6570\u5230\u7ed9\u5b9a\u6570\u5b57\uff1a\n\n```python\ndef my_generator(x):\n    for i in range(x):\n        yield i\n```\n\n\u60a8\u4ee5\u4e0e\u5e38\u89c4\u51fd\u6570\u76f8\u540c\u7684\u65b9\u5f0f\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio\u3002\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\uff08\u865a\u62df\u7684\uff09\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5b83\u5728\u8f93\u51fa\u56fe\u50cf\u4e4b\u524d\u751f\u6210\u6570\u4e2a\u6b65\u9aa4\u7684\u566a\u97f3\uff1a\n\n$code_fake_diffusion\n$demo_fake_diffusion\n\n\u8bf7\u6ce8\u610f\uff0c\u6211\u4eec\u5728\u8fed\u4ee3\u5668\u4e2d\u6dfb\u52a0\u4e86 `time.sleep(1)`\uff0c\u4ee5\u521b\u5efa\u6b65\u9aa4\u4e4b\u95f4\u7684\u4eba\u5de5\u6682\u505c\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u89c2\u5bdf\u8fed\u4ee3\u5668\u7684\u6b65\u9aa4\uff08\u5728\u771f\u5b9e\u7684\u56fe\u50cf\u751f\u6210\u6a21\u578b\u4e2d\uff0c\u8fd9\u53ef\u80fd\u662f\u4e0d\u5fc5\u8981\u7684\uff09\u3002\n\n\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio **\u9700\u8981**\u5728\u5e95\u5c42 Interface \u6216 Blocks \u4e2d\u542f\u7528\u961f\u5217\uff08\u8bf7\u53c2\u9605\u4e0a\u9762\u7684\u961f\u5217\u90e8\u5206\uff09\u3002\n\n## \u8fdb\u5ea6\u6761\n\nGradio \u652f\u6301\u521b\u5efa\u81ea\u5b9a\u4e49\u8fdb\u5ea6\u6761\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u81ea\u5b9a\u4e49\u548c\u63a7\u5236\u5411\u7528\u6237\u663e\u793a\u7684\u8fdb\u5ea6\u66f4\u65b0\u3002\u8981\u542f\u7528\u6b64\u529f\u80fd\uff0c\u53ea\u9700\u4e3a\u65b9\u6cd5\u6dfb\u52a0\u4e00\u4e2a\u9ed8\u8ba4\u503c\u4e3a `gr.Progress` \u5b9e\u4f8b\u7684\u53c2\u6570\u5373\u53ef\u3002\u7136\u540e\uff0c\u60a8\u53ef\u4ee5\u76f4\u63a5\u8c03\u7528\u6b64\u5b9e\u4f8b\u5e76\u4f20\u5165 0 \u5230 1 \u4e4b\u95f4\u7684\u6d6e\u70b9\u6570\u6765\u66f4\u65b0\u8fdb\u5ea6\u7ea7\u522b\uff0c\u6216\u8005 with `Progress` \u5b9e\u4f8b\u7684 `tqdm()` \u65b9\u6cd5\u6765\u8ddf\u8e2a\u53ef\u8fed\u4ee3\u5bf9\u8c61\u4e0a\u7684\u8fdb\u5ea6\uff0c\u5982\u4e0b\u6240\u793a\u3002\u5fc5\u987b\u542f\u7528\u961f\u5217\u4ee5\u8fdb\u884c\u8fdb\u5ea6\u66f4\u65b0\u3002\n\n$code_progress_simple\n$demo_progress_simple\n\n\u5982\u679c\u60a8 with `tqdm` \u5e93\uff0c\u5e76\u4e14\u5e0c\u671b\u4ece\u51fd\u6570\u5185\u90e8\u7684\u4efb\u4f55 `tqdm.tqdm` \u81ea\u52a8\u62a5\u544a\u8fdb\u5ea6\u66f4\u65b0\uff0c\u8bf7\u5c06\u9ed8\u8ba4\u53c2\u6570\u8bbe\u7f6e\u4e3a `gr.Progress(track_tqdm=True)`\uff01\n\n## \u6279\u5904\u7406\u51fd\u6570 (Batch Functions)\n\nGradio \u652f\u6301\u4f20\u9012*\u6279\u5904\u7406*\u51fd\u6570\u3002\u6279\u5904\u7406\u51fd\u6570\u53ea\u662f\u63a5\u53d7\u8f93\u5165\u5217\u8868\u5e76\u8fd4\u56de\u9884\u6d4b\u5217\u8868\u7684\u51fd\u6570\u3002\n\n\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\u6279\u5904\u7406\u51fd\u6570\uff0c\u5b83\u63a5\u53d7\u4e24\u4e2a\u8f93\u5165\u5217\u8868\uff08\u4e00\u4e2a\u5355\u8bcd\u5217\u8868\u548c\u4e00\u4e2a\u6574\u6570\u5217\u8868\uff09\uff0c\u5e76\u8fd4\u56de\u4fee\u526a\u8fc7\u7684\u5355\u8bcd\u5217\u8868\u4f5c\u4e3a\u8f93\u51fa\uff1a\n\n```python\nimport time\n\ndef trim_words(words, lens):\n    trimmed_words = []\n    time.sleep(5)\n    for w, l in zip(words, lens):\n        trimmed_words.append(w[:int(l)])\n    return [trimmed_words]\n    for w, l in zip(words,"
            }
        ]
    },
    {
        "sample_idx": 31,
        "question": "What are the two parameters that can be passed to event triggers or the Interface class in Gradio?",
        "answer": "The two parameters are batch=True and max_batch_size=16.",
        "rag_answer": "The two parameters that can be passed to event triggers or the Interface class in Gradio are inputs and outputs.",
        "rag_score": 1,
        "rag_feedback": "The system's response is completely incorrect, inaccurate, and/or not factual. The expected answer is 'batch=True and max_batch_size=16', but the system's response is 'inputs and outputs', which is not related to the correct answer.",
        "rag_context": [
            {
                "score": 0.6856947343094533,
                "node_text": "Here are some facts extracted from the provided text:\n\nGr -> Is -> Alias of gradio\nGradio -> Provides -> Pre-built themes\nGradio -> Is -> Library\nGradio -> Supports -> Iterative outputs\nGradio -> Has feature -> \u6dfb\u52a0\u63cf\u8ff0\u5185\u5bb9\nGradio -> Converts -> Data format\nGradio -> Has feature -> \u8fdb\u5ea6\u6761\nGradio -> Automatically handles -> Preprocessing\nGradio -> Has feature -> \u8bbe\u7f6e\u65d7\u6807\nGradio -> Has feature -> \u8fed\u4ee3\u8f93\u51fa\nGradio -> Has feature -> \u9884\u5904\u7406\u548c\u540e\u5904\u7406\nGradio -> Installed by -> Pip\nGradio -> Has feature -> \u6392\u961f\u7528\u6237\nGradio -> Recognizes -> Data format\nGradio -> Automatically handles -> Postprocessing\nGradio -> Supports -> Hugging face models\nGradio -> Supports -> Batch functions\nGradio -> Enables -> Parallel processing\nGradio -> Has feature -> \u6279\u5904\u7406\u51fd\u6570\nGradio -> Has feature -> \u4f20\u9012\u81ea\u5b9a\u4e49\u9519\u8bef\u6d88\u606f\nGradio -> Can run -> In colab notebooks\nGradio -> Supports -> Progress bars\nGradio -> Includes -> Components\nGradio -> Has feature -> \u6837\u5f0f\u5316\u6f14\u793a\nGradio -> Has feature -> \u6dfb\u52a0\u793a\u4f8b\u8f93\u5165\n\nGradio Demo: blocks_random_slider\n\n\n```\n!pip install -q gradio \n```\n\n\n```\n\nimport gradio as gr\n\n\ndef func(slider_1, slider_2):\n    return slider_1 * 5 + slider_2\n\n\nwith gr.Blocks() as demo:\n    slider = gr.Slider(minimum=-10.2, maximum=15, label=\"Random Slider (Static)\", randomize=True)\n    slider_1 = gr.Slider(minimum=100, maximum=200, label=\"Random Slider (Input 1)\", randomize=True)\n    slider_2 = gr.Slider(minimum=10, maximum=23.2, label=\"Random Slider (Input 2)\", randomize=True)\n    slider_3 = gr.Slider(value=3, label=\"Non random slider\")\n    btn = gr.Button(\"Run\")\n    btn.click(func, inputs=[slider_1, slider_2], outputs=gr.Number())\n\nif __name__ == \"__main__\":\n    demo.launch()\n\n```"
            },
            {
                "score": 0.6637789469327401,
                "node_text": "Here are some facts extracted from the provided text:\n\nGenerator function -> Is -> Provided to gradio\nGr.button -> Has method -> Click\n\nBlocks() as demo\uff1a\n    #.\ndemo.queue()\ndemo.launch()\n```\n\n\u60a8\u53ef\u4ee5\u901a\u8fc7\u4ee5\u4e0b\u65b9\u5f0f\u63a7\u5236\u4e00\u6b21\u5904\u7406\u7684\u8bf7\u6c42\u6570\u91cf\uff1a\n\n```python\ndemo.queue(concurrency_count=3)\n```\n\n\u67e5\u770b\u6709\u5173\u914d\u7f6e\u5176\u4ed6\u961f\u5217\u53c2\u6570\u7684[\u961f\u5217\u6587\u6863](/docs/#queue)\u3002\n\n\u5728 Blocks \u4e2d\u6307\u5b9a\u4ec5\u5bf9\u67d0\u4e9b\u51fd\u6570\u8fdb\u884c\u6392\u961f\uff1a\n\n```python\nwith gr.Blocks() as demo2\uff1a\n    num1 = gr.Number()\n    num2 = gr.Number()\n    output = gr.Number()\n    gr.Button(\"Add\").click(\n        lambda a, b: a + b, [num1, num2], output)\n    gr.Button(\"Multiply\").click(\n        lambda a, b: a * b, [num1, num2], output, queue=True)\ndemo2.launch()\n```\n\n## \u8fed\u4ee3\u8f93\u51fa (Iterative Outputs)\n\n\u5728\u67d0\u4e9b\u60c5\u51b5\u4e0b\uff0c\u60a8\u53ef\u80fd\u9700\u8981\u4f20\u8f93\u4e00\u7cfb\u5217\u8f93\u51fa\u800c\u4e0d\u662f\u4e00\u6b21\u663e\u793a\u5355\u4e2a\u8f93\u51fa\u3002\u4f8b\u5982\uff0c\u60a8\u53ef\u80fd\u6709\u4e00\u4e2a\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5e0c\u671b\u663e\u793a\u751f\u6210\u7684\u6bcf\u4e2a\u6b65\u9aa4\u7684\u56fe\u50cf\uff0c\u76f4\u5230\u6700\u7ec8\u56fe\u50cf\u3002\u6216\u8005\u60a8\u53ef\u80fd\u6709\u4e00\u4e2a\u804a\u5929\u673a\u5668\u4eba\uff0c\u5b83\u9010\u5b57\u9010\u53e5\u5730\u6d41\u5f0f\u4f20\u8f93\u54cd\u5e94\uff0c\u800c\u4e0d\u662f\u4e00\u6b21\u8fd4\u56de\u5168\u90e8\u54cd\u5e94\u3002\n\n\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u60a8\u53ef\u4ee5\u5c06**\u751f\u6210\u5668**\u51fd\u6570\u63d0\u4f9b\u7ed9 Gradio\uff0c\u800c\u4e0d\u662f\u5e38\u89c4\u51fd\u6570\u3002\u5728 Python \u4e2d\u521b\u5efa\u751f\u6210\u5668\u975e\u5e38\u7b80\u5355\uff1a\u51fd\u6570\u4e0d\u5e94\u8be5\u6709\u4e00\u4e2a\u5355\u72ec\u7684 `return` \u503c\uff0c\u800c\u662f\u5e94\u8be5 with `yield` \u8fde\u7eed\u8fd4\u56de\u4e00\u7cfb\u5217\u503c\u3002\u901a\u5e38\uff0c`yield` \u8bed\u53e5\u653e\u7f6e\u5728\u67d0\u79cd\u5faa\u73af\u4e2d\u3002\u4e0b\u9762\u662f\u4e00\u4e2a\u7b80\u5355\u793a\u4f8b\uff0c\u751f\u6210\u5668\u53ea\u662f\u7b80\u5355\u8ba1\u6570\u5230\u7ed9\u5b9a\u6570\u5b57\uff1a\n\n```python\ndef my_generator(x):\n    for i in range(x):\n        yield i\n```\n\n\u60a8\u4ee5\u4e0e\u5e38\u89c4\u51fd\u6570\u76f8\u540c\u7684\u65b9\u5f0f\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio\u3002\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\uff08\u865a\u62df\u7684\uff09\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5b83\u5728\u8f93\u51fa\u56fe\u50cf\u4e4b\u524d\u751f\u6210\u6570\u4e2a\u6b65\u9aa4\u7684\u566a\u97f3\uff1a\n\n$code_fake_diffusion\n$demo_fake_diffusion\n\n\u8bf7\u6ce8\u610f\uff0c\u6211\u4eec\u5728\u8fed\u4ee3\u5668\u4e2d\u6dfb\u52a0\u4e86 `time.sleep(1)`\uff0c\u4ee5\u521b\u5efa\u6b65\u9aa4\u4e4b\u95f4\u7684\u4eba\u5de5\u6682\u505c\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u89c2\u5bdf\u8fed\u4ee3\u5668\u7684\u6b65\u9aa4\uff08\u5728\u771f\u5b9e\u7684\u56fe\u50cf\u751f\u6210\u6a21\u578b\u4e2d\uff0c\u8fd9\u53ef\u80fd\u662f\u4e0d\u5fc5\u8981\u7684\uff09\u3002\n\n\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio **\u9700\u8981**\u5728\u5e95\u5c42 Interface \u6216 Blocks \u4e2d\u542f\u7528\u961f\u5217\uff08\u8bf7\u53c2\u9605\u4e0a\u9762\u7684\u961f\u5217\u90e8\u5206\uff09\u3002\n\n## \u8fdb\u5ea6\u6761\n\nGradio \u652f\u6301\u521b\u5efa\u81ea\u5b9a\u4e49\u8fdb\u5ea6\u6761\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u81ea\u5b9a\u4e49\u548c\u63a7\u5236\u5411\u7528\u6237\u663e\u793a\u7684\u8fdb\u5ea6\u66f4\u65b0\u3002\u8981\u542f\u7528\u6b64\u529f\u80fd\uff0c\u53ea\u9700\u4e3a\u65b9\u6cd5\u6dfb\u52a0\u4e00\u4e2a\u9ed8\u8ba4\u503c\u4e3a `gr.Progress` \u5b9e\u4f8b\u7684\u53c2\u6570\u5373\u53ef\u3002\u7136\u540e\uff0c\u60a8\u53ef\u4ee5\u76f4\u63a5\u8c03\u7528\u6b64\u5b9e\u4f8b\u5e76\u4f20\u5165 0 \u5230 1 \u4e4b\u95f4\u7684\u6d6e\u70b9\u6570\u6765\u66f4\u65b0\u8fdb\u5ea6\u7ea7\u522b\uff0c\u6216\u8005 with `Progress` \u5b9e\u4f8b\u7684 `tqdm()` \u65b9\u6cd5\u6765\u8ddf\u8e2a\u53ef\u8fed\u4ee3\u5bf9\u8c61\u4e0a\u7684\u8fdb\u5ea6\uff0c\u5982\u4e0b\u6240\u793a\u3002\u5fc5\u987b\u542f\u7528\u961f\u5217\u4ee5\u8fdb\u884c\u8fdb\u5ea6\u66f4\u65b0\u3002\n\n$code_progress_simple\n$demo_progress_simple\n\n\u5982\u679c\u60a8 with `tqdm` \u5e93\uff0c\u5e76\u4e14\u5e0c\u671b\u4ece\u51fd\u6570\u5185\u90e8\u7684\u4efb\u4f55 `tqdm.tqdm` \u81ea\u52a8\u62a5\u544a\u8fdb\u5ea6\u66f4\u65b0\uff0c\u8bf7\u5c06\u9ed8\u8ba4\u53c2\u6570\u8bbe\u7f6e\u4e3a `gr.Progress(track_tqdm=True)`\uff01\n\n## \u6279\u5904\u7406\u51fd\u6570 (Batch Functions)\n\nGradio \u652f\u6301\u4f20\u9012*\u6279\u5904\u7406*\u51fd\u6570\u3002\u6279\u5904\u7406\u51fd\u6570\u53ea\u662f\u63a5\u53d7\u8f93\u5165\u5217\u8868\u5e76\u8fd4\u56de\u9884\u6d4b\u5217\u8868\u7684\u51fd\u6570\u3002\n\n\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\u6279\u5904\u7406\u51fd\u6570\uff0c\u5b83\u63a5\u53d7\u4e24\u4e2a\u8f93\u5165\u5217\u8868\uff08\u4e00\u4e2a\u5355\u8bcd\u5217\u8868\u548c\u4e00\u4e2a\u6574\u6570\u5217\u8868\uff09\uff0c\u5e76\u8fd4\u56de\u4fee\u526a\u8fc7\u7684\u5355\u8bcd\u5217\u8868\u4f5c\u4e3a\u8f93\u51fa\uff1a\n\n```python\nimport time\n\ndef trim_words(words, lens):\n    trimmed_words = []\n    time.sleep(5)\n    for w, l in zip(words, lens):\n        trimmed_words.append(w[:int(l)])\n    return [trimmed_words]\n    for w, l in zip(words,"
            }
        ]
    },
    {
        "sample_idx": 32,
        "question": "How many requests can be processed in parallel in the example code?",
        "answer": "16 requests can be processed in parallel.",
        "rag_answer": "The example code does not specify the number of requests that can be processed in parallel. However, it is mentioned that you can control the number of requests processed in parallel by using the `concurrency_count` parameter when calling `demo.queue()`. For example, `demo.queue(concurrency_count=3)` would allow 3 requests to be processed in parallel.",
        "rag_score": 3,
        "rag_feedback": "The system's response is somewhat correct, accurate, and factual. It correctly mentions that the number of requests that can be processed in parallel can be controlled by using the `concurrency_count` parameter when calling `demo.queue()`. However, it does not provide the exact answer to the question, which is 16 requests can be processed in parallel.",
        "rag_context": [
            {
                "score": 1.0,
                "node_text": "Here are some facts extracted from the provided text:\n\nGradio -> Enables -> Parallel processing\n\nGradio Demo: blocks_random_slider\n\n\n```\n!pip install -q gradio \n```\n\n\n```\n\nimport gradio as gr\n\n\ndef func(slider_1, slider_2):\n    return slider_1 * 5 + slider_2\n\n\nwith gr.Blocks() as demo:\n    slider = gr.Slider(minimum=-10.2, maximum=15, label=\"Random Slider (Static)\", randomize=True)\n    slider_1 = gr.Slider(minimum=100, maximum=200, label=\"Random Slider (Input 1)\", randomize=True)\n    slider_2 = gr.Slider(minimum=10, maximum=23.2, label=\"Random Slider (Input 2)\", randomize=True)\n    slider_3 = gr.Slider(value=3, label=\"Non random slider\")\n    btn = gr.Button(\"Run\")\n    btn.click(func, inputs=[slider_1, slider_2], outputs=gr.Number())\n\nif __name__ == \"__main__\":\n    demo.launch()\n\n```"
            },
            {
                "score": 0.6741405270535616,
                "node_text": "Here are some facts extracted from the provided text:\n\nGradio -> Enables -> Parallel processing\nSlider -> Has -> Maximum 15\n\nGradio Demo: blocks_random_slider\n\n\n```\n!pip install -q gradio \n```\n\n\n```\n\nimport gradio as gr\n\n\ndef func(slider_1, slider_2):\n    return slider_1 * 5 + slider_2\n\n\nwith gr.Blocks() as demo:\n    slider = gr.Slider(minimum=-10.2, maximum=15, label=\"Random Slider (Static)\", randomize=True)\n    slider_1 = gr.Slider(minimum=100, maximum=200, label=\"Random Slider (Input 1)\", randomize=True)\n    slider_2 = gr.Slider(minimum=10, maximum=23.2, label=\"Random Slider (Input 2)\", randomize=True)\n    slider_3 = gr.Slider(value=3, label=\"Non random slider\")\n    btn = gr.Button(\"Run\")\n    btn.click(func, inputs=[slider_1, slider_2], outputs=gr.Number())\n\nif __name__ == \"__main__\":\n    demo.launch()\n\n```"
            },
            {
                "score": 0.6536358782532394,
                "node_text": "Here are some facts extracted from the provided text:\n\nGr.blocks -> Has parameter -> Concurrency_count\nQueue -> Has parameter -> Concurrency_count\n\nBlocks() as demo\uff1a\n    #.\ndemo.queue()\ndemo.launch()\n```\n\n\u60a8\u53ef\u4ee5\u901a\u8fc7\u4ee5\u4e0b\u65b9\u5f0f\u63a7\u5236\u4e00\u6b21\u5904\u7406\u7684\u8bf7\u6c42\u6570\u91cf\uff1a\n\n```python\ndemo.queue(concurrency_count=3)\n```\n\n\u67e5\u770b\u6709\u5173\u914d\u7f6e\u5176\u4ed6\u961f\u5217\u53c2\u6570\u7684[\u961f\u5217\u6587\u6863](/docs/#queue)\u3002\n\n\u5728 Blocks \u4e2d\u6307\u5b9a\u4ec5\u5bf9\u67d0\u4e9b\u51fd\u6570\u8fdb\u884c\u6392\u961f\uff1a\n\n```python\nwith gr.Blocks() as demo2\uff1a\n    num1 = gr.Number()\n    num2 = gr.Number()\n    output = gr.Number()\n    gr.Button(\"Add\").click(\n        lambda a, b: a + b, [num1, num2], output)\n    gr.Button(\"Multiply\").click(\n        lambda a, b: a * b, [num1, num2], output, queue=True)\ndemo2.launch()\n```\n\n## \u8fed\u4ee3\u8f93\u51fa (Iterative Outputs)\n\n\u5728\u67d0\u4e9b\u60c5\u51b5\u4e0b\uff0c\u60a8\u53ef\u80fd\u9700\u8981\u4f20\u8f93\u4e00\u7cfb\u5217\u8f93\u51fa\u800c\u4e0d\u662f\u4e00\u6b21\u663e\u793a\u5355\u4e2a\u8f93\u51fa\u3002\u4f8b\u5982\uff0c\u60a8\u53ef\u80fd\u6709\u4e00\u4e2a\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5e0c\u671b\u663e\u793a\u751f\u6210\u7684\u6bcf\u4e2a\u6b65\u9aa4\u7684\u56fe\u50cf\uff0c\u76f4\u5230\u6700\u7ec8\u56fe\u50cf\u3002\u6216\u8005\u60a8\u53ef\u80fd\u6709\u4e00\u4e2a\u804a\u5929\u673a\u5668\u4eba\uff0c\u5b83\u9010\u5b57\u9010\u53e5\u5730\u6d41\u5f0f\u4f20\u8f93\u54cd\u5e94\uff0c\u800c\u4e0d\u662f\u4e00\u6b21\u8fd4\u56de\u5168\u90e8\u54cd\u5e94\u3002\n\n\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u60a8\u53ef\u4ee5\u5c06**\u751f\u6210\u5668**\u51fd\u6570\u63d0\u4f9b\u7ed9 Gradio\uff0c\u800c\u4e0d\u662f\u5e38\u89c4\u51fd\u6570\u3002\u5728 Python \u4e2d\u521b\u5efa\u751f\u6210\u5668\u975e\u5e38\u7b80\u5355\uff1a\u51fd\u6570\u4e0d\u5e94\u8be5\u6709\u4e00\u4e2a\u5355\u72ec\u7684 `return` \u503c\uff0c\u800c\u662f\u5e94\u8be5 with `yield` \u8fde\u7eed\u8fd4\u56de\u4e00\u7cfb\u5217\u503c\u3002\u901a\u5e38\uff0c`yield` \u8bed\u53e5\u653e\u7f6e\u5728\u67d0\u79cd\u5faa\u73af\u4e2d\u3002\u4e0b\u9762\u662f\u4e00\u4e2a\u7b80\u5355\u793a\u4f8b\uff0c\u751f\u6210\u5668\u53ea\u662f\u7b80\u5355\u8ba1\u6570\u5230\u7ed9\u5b9a\u6570\u5b57\uff1a\n\n```python\ndef my_generator(x):\n    for i in range(x):\n        yield i\n```\n\n\u60a8\u4ee5\u4e0e\u5e38\u89c4\u51fd\u6570\u76f8\u540c\u7684\u65b9\u5f0f\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio\u3002\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\uff08\u865a\u62df\u7684\uff09\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5b83\u5728\u8f93\u51fa\u56fe\u50cf\u4e4b\u524d\u751f\u6210\u6570\u4e2a\u6b65\u9aa4\u7684\u566a\u97f3\uff1a\n\n$code_fake_diffusion\n$demo_fake_diffusion\n\n\u8bf7\u6ce8\u610f\uff0c\u6211\u4eec\u5728\u8fed\u4ee3\u5668\u4e2d\u6dfb\u52a0\u4e86 `time.sleep(1)`\uff0c\u4ee5\u521b\u5efa\u6b65\u9aa4\u4e4b\u95f4\u7684\u4eba\u5de5\u6682\u505c\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u89c2\u5bdf\u8fed\u4ee3\u5668\u7684\u6b65\u9aa4\uff08\u5728\u771f\u5b9e\u7684\u56fe\u50cf\u751f\u6210\u6a21\u578b\u4e2d\uff0c\u8fd9\u53ef\u80fd\u662f\u4e0d\u5fc5\u8981\u7684\uff09\u3002\n\n\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio **\u9700\u8981**\u5728\u5e95\u5c42 Interface \u6216 Blocks \u4e2d\u542f\u7528\u961f\u5217\uff08\u8bf7\u53c2\u9605\u4e0a\u9762\u7684\u961f\u5217\u90e8\u5206\uff09\u3002\n\n## \u8fdb\u5ea6\u6761\n\nGradio \u652f\u6301\u521b\u5efa\u81ea\u5b9a\u4e49\u8fdb\u5ea6\u6761\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u81ea\u5b9a\u4e49\u548c\u63a7\u5236\u5411\u7528\u6237\u663e\u793a\u7684\u8fdb\u5ea6\u66f4\u65b0\u3002\u8981\u542f\u7528\u6b64\u529f\u80fd\uff0c\u53ea\u9700\u4e3a\u65b9\u6cd5\u6dfb\u52a0\u4e00\u4e2a\u9ed8\u8ba4\u503c\u4e3a `gr.Progress` \u5b9e\u4f8b\u7684\u53c2\u6570\u5373\u53ef\u3002\u7136\u540e\uff0c\u60a8\u53ef\u4ee5\u76f4\u63a5\u8c03\u7528\u6b64\u5b9e\u4f8b\u5e76\u4f20\u5165 0 \u5230 1 \u4e4b\u95f4\u7684\u6d6e\u70b9\u6570\u6765\u66f4\u65b0\u8fdb\u5ea6\u7ea7\u522b\uff0c\u6216\u8005 with `Progress` \u5b9e\u4f8b\u7684 `tqdm()` \u65b9\u6cd5\u6765\u8ddf\u8e2a\u53ef\u8fed\u4ee3\u5bf9\u8c61\u4e0a\u7684\u8fdb\u5ea6\uff0c\u5982\u4e0b\u6240\u793a\u3002\u5fc5\u987b\u542f\u7528\u961f\u5217\u4ee5\u8fdb\u884c\u8fdb\u5ea6\u66f4\u65b0\u3002\n\n$code_progress_simple\n$demo_progress_simple\n\n\u5982\u679c\u60a8 with `tqdm` \u5e93\uff0c\u5e76\u4e14\u5e0c\u671b\u4ece\u51fd\u6570\u5185\u90e8\u7684\u4efb\u4f55 `tqdm.tqdm` \u81ea\u52a8\u62a5\u544a\u8fdb\u5ea6\u66f4\u65b0\uff0c\u8bf7\u5c06\u9ed8\u8ba4\u53c2\u6570\u8bbe\u7f6e\u4e3a `gr.Progress(track_tqdm=True)`\uff01\n\n## \u6279\u5904\u7406\u51fd\u6570 (Batch Functions)\n\nGradio \u652f\u6301\u4f20\u9012*\u6279\u5904\u7406*\u51fd\u6570\u3002\u6279\u5904\u7406\u51fd\u6570\u53ea\u662f\u63a5\u53d7\u8f93\u5165\u5217\u8868\u5e76\u8fd4\u56de\u9884\u6d4b\u5217\u8868\u7684\u51fd\u6570\u3002\n\n\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\u6279\u5904\u7406\u51fd\u6570\uff0c\u5b83\u63a5\u53d7\u4e24\u4e2a\u8f93\u5165\u5217\u8868\uff08\u4e00\u4e2a\u5355\u8bcd\u5217\u8868\u548c\u4e00\u4e2a\u6574\u6570\u5217\u8868\uff09\uff0c\u5e76\u8fd4\u56de\u4fee\u526a\u8fc7\u7684\u5355\u8bcd\u5217\u8868\u4f5c\u4e3a\u8f93\u51fa\uff1a\n\n```python\nimport time\n\ndef trim_words(words, lens):\n    trimmed_words = []\n    time.sleep(5)\n    for w, l in zip(words, lens):\n        trimmed_words.append(w[:int(l)])\n    return [trimmed_words]\n    for w, l in zip(words,"
            },
            {
                "score": 0.6143787495261943,
                "node_text": "Here are some facts extracted from the provided text:\n\nSession state -> Persists -> Across multiple submits within a page session\n\nState in Blocks\n\nWe covered [State in Interfaces](https://gradio.app/interface-state), this guide takes a look at state in Blocks, which works mostly the same.\n\n## Global State\n\nGlobal state in Blocks works the same as in Interface. Any variable created outside a function call is a reference shared between all users.\n\n## Session State\n\nGradio supports session **state**, where data persists across multiple submits within a page session, in Blocks apps as well. To reiterate, session data is _not_ shared between different users of your model. To store data in a session state, you need to do three things:\n\n1. Create a `gr.State()` object. If there is a default value to this stateful object, pass that into the constructor.\n2. In the event listener, put the `State` object as an input and output.\n3. In the event listener function, add the variable to the input parameters and the return value.\n\nLet's take a look at a game of hangman.\n\n$code_hangman\n$demo_hangman\n\nLet's see how we do each of the 3 steps listed above in this game:\n\n1. We store the used letters in `used_letters_var`. In the constructor of `State`, we set the initial value of this to `[]`, an empty list.\n2. In `btn.click()`, we have a reference to `used_letters_var` in both the inputs and outputs.\n3. In `guess_letter`, we pass the value of this `State` to `used_letters`, and then return an updated value of this `State` in the return statement.\n\nWith more complex apps, you will likely have many State variables storing session state in a single Blocks app.\n\nLearn more about `State` in the [docs](https://gradio.app/docs#state)."
            }
        ]
    },
    {
        "sample_idx": 33,
        "question": "What is the total inference time for processing 16 requests separately in the example code?",
        "answer": "The total inference time is 80 seconds.",
        "rag_answer": "The total inference time for processing 16 requests separately in the example code is not explicitly stated. However, we can infer that the example code is using a queue with a concurrency count of 3, which means it can process 3 requests concurrently. \n\nIf we assume that each request takes 1-5 minutes to process (as mentioned in the context), the total inference time for processing 16 requests separately would depend on how the queue is utilized. \n\nIn the worst-case scenario, where the queue is not utilized concurrently, the total inference time would be 16 * (1-5 minutes) = 16-80 minutes.\n\nIn the best-case scenario, where the queue is utilized concurrently with a concurrency count of 3, the total inference time would be approximately (16/3) * (1-5 minutes) = 5.33-26.67 minutes.\n\nPlease note that these are rough estimates and the actual total inference time may vary depending on the specifics of the implementation and the underlying infrastructure.",
        "rag_score": 2,
        "rag_feedback": "The system's response is mostly incorrect, inaccurate, and/or not factual. It does not provide a direct answer to the question and instead provides a detailed explanation of how to estimate the total inference time. The response also includes irrelevant information from the context, which makes it difficult to understand. The expected answer is a simple statement of the total inference time, which is 80 seconds.",
        "rag_context": [
            {
                "score": 1.0,
                "node_text": "Here are some facts extracted from the provided text:\n\nGradio -> Enables -> Parallel processing\n\nGradio Demo: blocks_random_slider\n\n\n```\n!pip install -q gradio \n```\n\n\n```\n\nimport gradio as gr\n\n\ndef func(slider_1, slider_2):\n    return slider_1 * 5 + slider_2\n\n\nwith gr.Blocks() as demo:\n    slider = gr.Slider(minimum=-10.2, maximum=15, label=\"Random Slider (Static)\", randomize=True)\n    slider_1 = gr.Slider(minimum=100, maximum=200, label=\"Random Slider (Input 1)\", randomize=True)\n    slider_2 = gr.Slider(minimum=10, maximum=23.2, label=\"Random Slider (Input 2)\", randomize=True)\n    slider_3 = gr.Slider(value=3, label=\"Non random slider\")\n    btn = gr.Button(\"Run\")\n    btn.click(func, inputs=[slider_1, slider_2], outputs=gr.Number())\n\nif __name__ == \"__main__\":\n    demo.launch()\n\n```"
            },
            {
                "score": 0.6424477205206562,
                "node_text": "Here are some facts extracted from the provided text:\n\nInference widget -> Is used for -> Testing endpoint\n\nCreate an Endpoint\n\nAfter your first login, you will be directed to the [Endpoint creation page](https://ui.endpoints.huggingface.co/new). As an example, this guide will go through the steps to deploy [distilbert-base-uncased-finetuned-sst-2-english](https://huggingface.co/distilbert-base-uncased-finetuned-sst-2-english) for text classification. \n\n## 1. Enter the Hugging Face Repository ID and your desired endpoint name:\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_repository.png\" alt=\"select repository\" />\n\n## 2. Select your Cloud Provider and region. Initially, only AWS will be available as a Cloud Provider with the `us-east-1` and `eu-west-1` regions. We will add Azure soon, and if you need to test Endpoints with other Cloud Providers or regions, please let us know.\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_region.png\" alt=\"select region\" />\n\n## 3. Define the [Security Level](security) for the Endpoint:\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_security.png\" alt=\"define security\" />\n\n## 4. Create your Endpoint by clicking **Create Endpoint**. By default, your Endpoint is created with a medium CPU (2 x 4GB vCPUs with Intel Xeon Ice Lake) The cost estimate assumes the Endpoint will be up for an entire month, and does not take autoscaling into account.\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_create_cost.png\" alt=\"create endpoint\" />\n\n## 5. Wait for the Endpoint to build, initialize and run which can take between 1 to 5 minutes.\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/overview.png\" alt=\"overview\" />\n\n## 6. Test your Endpoint in the overview with the Inference widget \ud83c\udfc1 \ud83c\udf89!\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_inference.png\" alt=\"run inference\" />"
            },
            {
                "score": 0.5837700199887279,
                "node_text": "Here are some facts extracted from the provided text:\n\nQueue -> Controls -> Processing rate\n\nBlocks() as demo\uff1a\n    #.\ndemo.queue()\ndemo.launch()\n```\n\n\u60a8\u53ef\u4ee5\u901a\u8fc7\u4ee5\u4e0b\u65b9\u5f0f\u63a7\u5236\u4e00\u6b21\u5904\u7406\u7684\u8bf7\u6c42\u6570\u91cf\uff1a\n\n```python\ndemo.queue(concurrency_count=3)\n```\n\n\u67e5\u770b\u6709\u5173\u914d\u7f6e\u5176\u4ed6\u961f\u5217\u53c2\u6570\u7684[\u961f\u5217\u6587\u6863](/docs/#queue)\u3002\n\n\u5728 Blocks \u4e2d\u6307\u5b9a\u4ec5\u5bf9\u67d0\u4e9b\u51fd\u6570\u8fdb\u884c\u6392\u961f\uff1a\n\n```python\nwith gr.Blocks() as demo2\uff1a\n    num1 = gr.Number()\n    num2 = gr.Number()\n    output = gr.Number()\n    gr.Button(\"Add\").click(\n        lambda a, b: a + b, [num1, num2], output)\n    gr.Button(\"Multiply\").click(\n        lambda a, b: a * b, [num1, num2], output, queue=True)\ndemo2.launch()\n```\n\n## \u8fed\u4ee3\u8f93\u51fa (Iterative Outputs)\n\n\u5728\u67d0\u4e9b\u60c5\u51b5\u4e0b\uff0c\u60a8\u53ef\u80fd\u9700\u8981\u4f20\u8f93\u4e00\u7cfb\u5217\u8f93\u51fa\u800c\u4e0d\u662f\u4e00\u6b21\u663e\u793a\u5355\u4e2a\u8f93\u51fa\u3002\u4f8b\u5982\uff0c\u60a8\u53ef\u80fd\u6709\u4e00\u4e2a\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5e0c\u671b\u663e\u793a\u751f\u6210\u7684\u6bcf\u4e2a\u6b65\u9aa4\u7684\u56fe\u50cf\uff0c\u76f4\u5230\u6700\u7ec8\u56fe\u50cf\u3002\u6216\u8005\u60a8\u53ef\u80fd\u6709\u4e00\u4e2a\u804a\u5929\u673a\u5668\u4eba\uff0c\u5b83\u9010\u5b57\u9010\u53e5\u5730\u6d41\u5f0f\u4f20\u8f93\u54cd\u5e94\uff0c\u800c\u4e0d\u662f\u4e00\u6b21\u8fd4\u56de\u5168\u90e8\u54cd\u5e94\u3002\n\n\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u60a8\u53ef\u4ee5\u5c06**\u751f\u6210\u5668**\u51fd\u6570\u63d0\u4f9b\u7ed9 Gradio\uff0c\u800c\u4e0d\u662f\u5e38\u89c4\u51fd\u6570\u3002\u5728 Python \u4e2d\u521b\u5efa\u751f\u6210\u5668\u975e\u5e38\u7b80\u5355\uff1a\u51fd\u6570\u4e0d\u5e94\u8be5\u6709\u4e00\u4e2a\u5355\u72ec\u7684 `return` \u503c\uff0c\u800c\u662f\u5e94\u8be5 with `yield` \u8fde\u7eed\u8fd4\u56de\u4e00\u7cfb\u5217\u503c\u3002\u901a\u5e38\uff0c`yield` \u8bed\u53e5\u653e\u7f6e\u5728\u67d0\u79cd\u5faa\u73af\u4e2d\u3002\u4e0b\u9762\u662f\u4e00\u4e2a\u7b80\u5355\u793a\u4f8b\uff0c\u751f\u6210\u5668\u53ea\u662f\u7b80\u5355\u8ba1\u6570\u5230\u7ed9\u5b9a\u6570\u5b57\uff1a\n\n```python\ndef my_generator(x):\n    for i in range(x):\n        yield i\n```\n\n\u60a8\u4ee5\u4e0e\u5e38\u89c4\u51fd\u6570\u76f8\u540c\u7684\u65b9\u5f0f\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio\u3002\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\uff08\u865a\u62df\u7684\uff09\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5b83\u5728\u8f93\u51fa\u56fe\u50cf\u4e4b\u524d\u751f\u6210\u6570\u4e2a\u6b65\u9aa4\u7684\u566a\u97f3\uff1a\n\n$code_fake_diffusion\n$demo_fake_diffusion\n\n\u8bf7\u6ce8\u610f\uff0c\u6211\u4eec\u5728\u8fed\u4ee3\u5668\u4e2d\u6dfb\u52a0\u4e86 `time.sleep(1)`\uff0c\u4ee5\u521b\u5efa\u6b65\u9aa4\u4e4b\u95f4\u7684\u4eba\u5de5\u6682\u505c\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u89c2\u5bdf\u8fed\u4ee3\u5668\u7684\u6b65\u9aa4\uff08\u5728\u771f\u5b9e\u7684\u56fe\u50cf\u751f\u6210\u6a21\u578b\u4e2d\uff0c\u8fd9\u53ef\u80fd\u662f\u4e0d\u5fc5\u8981\u7684\uff09\u3002\n\n\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio **\u9700\u8981**\u5728\u5e95\u5c42 Interface \u6216 Blocks \u4e2d\u542f\u7528\u961f\u5217\uff08\u8bf7\u53c2\u9605\u4e0a\u9762\u7684\u961f\u5217\u90e8\u5206\uff09\u3002\n\n## \u8fdb\u5ea6\u6761\n\nGradio \u652f\u6301\u521b\u5efa\u81ea\u5b9a\u4e49\u8fdb\u5ea6\u6761\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u81ea\u5b9a\u4e49\u548c\u63a7\u5236\u5411\u7528\u6237\u663e\u793a\u7684\u8fdb\u5ea6\u66f4\u65b0\u3002\u8981\u542f\u7528\u6b64\u529f\u80fd\uff0c\u53ea\u9700\u4e3a\u65b9\u6cd5\u6dfb\u52a0\u4e00\u4e2a\u9ed8\u8ba4\u503c\u4e3a `gr.Progress` \u5b9e\u4f8b\u7684\u53c2\u6570\u5373\u53ef\u3002\u7136\u540e\uff0c\u60a8\u53ef\u4ee5\u76f4\u63a5\u8c03\u7528\u6b64\u5b9e\u4f8b\u5e76\u4f20\u5165 0 \u5230 1 \u4e4b\u95f4\u7684\u6d6e\u70b9\u6570\u6765\u66f4\u65b0\u8fdb\u5ea6\u7ea7\u522b\uff0c\u6216\u8005 with `Progress` \u5b9e\u4f8b\u7684 `tqdm()` \u65b9\u6cd5\u6765\u8ddf\u8e2a\u53ef\u8fed\u4ee3\u5bf9\u8c61\u4e0a\u7684\u8fdb\u5ea6\uff0c\u5982\u4e0b\u6240\u793a\u3002\u5fc5\u987b\u542f\u7528\u961f\u5217\u4ee5\u8fdb\u884c\u8fdb\u5ea6\u66f4\u65b0\u3002\n\n$code_progress_simple\n$demo_progress_simple\n\n\u5982\u679c\u60a8 with `tqdm` \u5e93\uff0c\u5e76\u4e14\u5e0c\u671b\u4ece\u51fd\u6570\u5185\u90e8\u7684\u4efb\u4f55 `tqdm.tqdm` \u81ea\u52a8\u62a5\u544a\u8fdb\u5ea6\u66f4\u65b0\uff0c\u8bf7\u5c06\u9ed8\u8ba4\u53c2\u6570\u8bbe\u7f6e\u4e3a `gr.Progress(track_tqdm=True)`\uff01\n\n## \u6279\u5904\u7406\u51fd\u6570 (Batch Functions)\n\nGradio \u652f\u6301\u4f20\u9012*\u6279\u5904\u7406*\u51fd\u6570\u3002\u6279\u5904\u7406\u51fd\u6570\u53ea\u662f\u63a5\u53d7\u8f93\u5165\u5217\u8868\u5e76\u8fd4\u56de\u9884\u6d4b\u5217\u8868\u7684\u51fd\u6570\u3002\n\n\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\u6279\u5904\u7406\u51fd\u6570\uff0c\u5b83\u63a5\u53d7\u4e24\u4e2a\u8f93\u5165\u5217\u8868\uff08\u4e00\u4e2a\u5355\u8bcd\u5217\u8868\u548c\u4e00\u4e2a\u6574\u6570\u5217\u8868\uff09\uff0c\u5e76\u8fd4\u56de\u4fee\u526a\u8fc7\u7684\u5355\u8bcd\u5217\u8868\u4f5c\u4e3a\u8f93\u51fa\uff1a\n\n```python\nimport time\n\ndef trim_words(words, lens):\n    trimmed_words = []\n    time.sleep(5)\n    for w, l in zip(words, lens):\n        trimmed_words.append(w[:int(l)])\n    return [trimmed_words]\n    for w, l in zip(words,"
            },
            {
                "score": 0.5787125648080428,
                "node_text": "Here are some facts extracted from the provided text:\n\nXla -> Is -> Optimizing compiler\n\nThis is a really useful trick, so remember it if you need to convert your own code to XLA!\n\n#### XLA Rule #3: XLA will need to recompile your model for every different input shape it sees\n\nThis is the big one. What this means is that if your input shapes are very variable, XLA will have to recompile your model over and over, which will create huge performance problems. This commonly arises in NLP models, where input texts have variable lengths after tokenization. In other modalities, static shapes are more common and this rule is much less of a problem.\n\nHow can you get around rule #3? The key is **padding** - if you pad all your inputs to the same length, and then use an `attention_mask`, you can get the same results as you\u2019d get from variable shapes, but without any XLA issues. However, excessive padding can cause severe slowdown too - if you pad all your samples to the maximum length in the whole dataset, you might end up with batches consisting endless padding tokens, which will waste a lot of compute and memory!\n\nThere isn\u2019t a perfect solution to this problem. However, you can try some tricks. One very useful trick is to **pad batches of samples up to a multiple of a number like 32 or 64 tokens.** This often only increases the number of tokens by a small amount, but it hugely reduces the number of unique input shapes, because every input shape now has to be a multiple of 32 or 64. Fewer unique input shapes means fewer XLA compilations!\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** Our tokenizers and data collators have methods that can help you here. You can use `padding=\"max_length\"` or `padding=\"longest\"` when calling tokenizers to get them to output padded data. Our tokenizers and data collators also have a `pad_to_multiple_of` argument that you can use to reduce the number of unique input shapes you see!\n\n</Tip>\n\n### How do I actually train my model on TPU?\n\nOnce your training is XLA-compatible and (if you\u2019re using TPU Node / Colab) your dataset has been prepared appropriately, running on TPU is surprisingly easy! All you really need to change in your code is to add a few lines to initialize your TPU, and to ensure that your model and dataset are created inside a `TPUStrategy` scope. Take a look at [our TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) to see this in action!\n\n### Summary\n\nThere was a lot in here, so let\u2019s summarize with a quick checklist you can follow when you want to get your model ready for TPU training:\n\n- Make sure your code follows the three rules of XLA\n- Compile your model with `jit_compile=True` on CPU/GPU and confirm that you can train it with XLA\n- Either load your dataset into memory or use a TPU-compatible dataset loading approach (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Migrate your code either to Colab (with accelerator set to \u201cTPU\u201d) or a TPU VM on Google Cloud\n- Add TPU initializer code (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Create your `TPUStrategy` and make sure dataset loading and model creation are inside the `strategy.scope()` (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Don\u2019t forget to take `jit_compile=True` out again when you move to TPU!\n- \ud83d\ude4f\ud83d\ude4f\ud83d\ude4f\ud83e\udd7a\ud83e\udd7a\ud83e\udd7a\n- Call model.fit()\n- You did it!"
            }
        ]
    },
    {
        "sample_idx": 34,
        "question": "What is required to use Gradio's batch function?",
        "answer": "Enabling the queue in the underlying Interface or Blocks is required.",
        "rag_answer": "Enabling queueing in the underlying Interface or Blocks is required to use Gradio's batch function.",
        "rag_score": 4,
        "rag_feedback": "The system's response is mostly correct, accurate, and factual. It provides a detailed explanation of Gradio's batch function, including the requirement to enable the queue in the underlying Interface or Blocks. The response also includes relevant code examples and additional information about Gradio's features, such as iterative outputs and progress bars. However, the response is not a direct answer to the question and includes unnecessary information.",
        "rag_context": [
            {
                "score": 0.7203685571573532,
                "node_text": "Here are some facts extracted from the provided text:\n\nGr -> Is -> Alias of gradio\nGradio -> Provides -> Pre-built themes\nGradio -> Is -> Library\nGradio -> Supports -> Iterative outputs\nGradio -> Has feature -> \u6dfb\u52a0\u63cf\u8ff0\u5185\u5bb9\nGradio -> Converts -> Data format\nGradio -> Has feature -> \u8fdb\u5ea6\u6761\nGradio -> Automatically handles -> Preprocessing\nGradio -> Has feature -> \u8bbe\u7f6e\u65d7\u6807\nGradio -> Has feature -> \u8fed\u4ee3\u8f93\u51fa\nGradio -> Has feature -> \u9884\u5904\u7406\u548c\u540e\u5904\u7406\nGradio -> Installed by -> Pip\nGradio -> Has feature -> \u6392\u961f\u7528\u6237\nGradio -> Recognizes -> Data format\nGradio -> Automatically handles -> Postprocessing\nGradio -> Supports -> Hugging face models\nGradio -> Supports -> Batch functions\nGradio -> Enables -> Parallel processing\nGradio -> Has feature -> \u6279\u5904\u7406\u51fd\u6570\nGradio -> Has feature -> \u4f20\u9012\u81ea\u5b9a\u4e49\u9519\u8bef\u6d88\u606f\nGradio -> Can run -> In colab notebooks\nGradio -> Supports -> Progress bars\nGradio -> Includes -> Components\nGradio -> Has feature -> \u6837\u5f0f\u5316\u6f14\u793a\nGradio -> Has feature -> \u6dfb\u52a0\u793a\u4f8b\u8f93\u5165\n\nGradio Demo: blocks_random_slider\n\n\n```\n!pip install -q gradio \n```\n\n\n```\n\nimport gradio as gr\n\n\ndef func(slider_1, slider_2):\n    return slider_1 * 5 + slider_2\n\n\nwith gr.Blocks() as demo:\n    slider = gr.Slider(minimum=-10.2, maximum=15, label=\"Random Slider (Static)\", randomize=True)\n    slider_1 = gr.Slider(minimum=100, maximum=200, label=\"Random Slider (Input 1)\", randomize=True)\n    slider_2 = gr.Slider(minimum=10, maximum=23.2, label=\"Random Slider (Input 2)\", randomize=True)\n    slider_3 = gr.Slider(value=3, label=\"Non random slider\")\n    btn = gr.Button(\"Run\")\n    btn.click(func, inputs=[slider_1, slider_2], outputs=gr.Number())\n\nif __name__ == \"__main__\":\n    demo.launch()\n\n```"
            },
            {
                "score": 0.6759417792352024,
                "node_text": "Here are some facts extracted from the provided text:\n\nGenerator function -> Is -> Provided to gradio\n\nBlocks() as demo\uff1a\n    #.\ndemo.queue()\ndemo.launch()\n```\n\n\u60a8\u53ef\u4ee5\u901a\u8fc7\u4ee5\u4e0b\u65b9\u5f0f\u63a7\u5236\u4e00\u6b21\u5904\u7406\u7684\u8bf7\u6c42\u6570\u91cf\uff1a\n\n```python\ndemo.queue(concurrency_count=3)\n```\n\n\u67e5\u770b\u6709\u5173\u914d\u7f6e\u5176\u4ed6\u961f\u5217\u53c2\u6570\u7684[\u961f\u5217\u6587\u6863](/docs/#queue)\u3002\n\n\u5728 Blocks \u4e2d\u6307\u5b9a\u4ec5\u5bf9\u67d0\u4e9b\u51fd\u6570\u8fdb\u884c\u6392\u961f\uff1a\n\n```python\nwith gr.Blocks() as demo2\uff1a\n    num1 = gr.Number()\n    num2 = gr.Number()\n    output = gr.Number()\n    gr.Button(\"Add\").click(\n        lambda a, b: a + b, [num1, num2], output)\n    gr.Button(\"Multiply\").click(\n        lambda a, b: a * b, [num1, num2], output, queue=True)\ndemo2.launch()\n```\n\n## \u8fed\u4ee3\u8f93\u51fa (Iterative Outputs)\n\n\u5728\u67d0\u4e9b\u60c5\u51b5\u4e0b\uff0c\u60a8\u53ef\u80fd\u9700\u8981\u4f20\u8f93\u4e00\u7cfb\u5217\u8f93\u51fa\u800c\u4e0d\u662f\u4e00\u6b21\u663e\u793a\u5355\u4e2a\u8f93\u51fa\u3002\u4f8b\u5982\uff0c\u60a8\u53ef\u80fd\u6709\u4e00\u4e2a\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5e0c\u671b\u663e\u793a\u751f\u6210\u7684\u6bcf\u4e2a\u6b65\u9aa4\u7684\u56fe\u50cf\uff0c\u76f4\u5230\u6700\u7ec8\u56fe\u50cf\u3002\u6216\u8005\u60a8\u53ef\u80fd\u6709\u4e00\u4e2a\u804a\u5929\u673a\u5668\u4eba\uff0c\u5b83\u9010\u5b57\u9010\u53e5\u5730\u6d41\u5f0f\u4f20\u8f93\u54cd\u5e94\uff0c\u800c\u4e0d\u662f\u4e00\u6b21\u8fd4\u56de\u5168\u90e8\u54cd\u5e94\u3002\n\n\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u60a8\u53ef\u4ee5\u5c06**\u751f\u6210\u5668**\u51fd\u6570\u63d0\u4f9b\u7ed9 Gradio\uff0c\u800c\u4e0d\u662f\u5e38\u89c4\u51fd\u6570\u3002\u5728 Python \u4e2d\u521b\u5efa\u751f\u6210\u5668\u975e\u5e38\u7b80\u5355\uff1a\u51fd\u6570\u4e0d\u5e94\u8be5\u6709\u4e00\u4e2a\u5355\u72ec\u7684 `return` \u503c\uff0c\u800c\u662f\u5e94\u8be5 with `yield` \u8fde\u7eed\u8fd4\u56de\u4e00\u7cfb\u5217\u503c\u3002\u901a\u5e38\uff0c`yield` \u8bed\u53e5\u653e\u7f6e\u5728\u67d0\u79cd\u5faa\u73af\u4e2d\u3002\u4e0b\u9762\u662f\u4e00\u4e2a\u7b80\u5355\u793a\u4f8b\uff0c\u751f\u6210\u5668\u53ea\u662f\u7b80\u5355\u8ba1\u6570\u5230\u7ed9\u5b9a\u6570\u5b57\uff1a\n\n```python\ndef my_generator(x):\n    for i in range(x):\n        yield i\n```\n\n\u60a8\u4ee5\u4e0e\u5e38\u89c4\u51fd\u6570\u76f8\u540c\u7684\u65b9\u5f0f\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio\u3002\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\uff08\u865a\u62df\u7684\uff09\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5b83\u5728\u8f93\u51fa\u56fe\u50cf\u4e4b\u524d\u751f\u6210\u6570\u4e2a\u6b65\u9aa4\u7684\u566a\u97f3\uff1a\n\n$code_fake_diffusion\n$demo_fake_diffusion\n\n\u8bf7\u6ce8\u610f\uff0c\u6211\u4eec\u5728\u8fed\u4ee3\u5668\u4e2d\u6dfb\u52a0\u4e86 `time.sleep(1)`\uff0c\u4ee5\u521b\u5efa\u6b65\u9aa4\u4e4b\u95f4\u7684\u4eba\u5de5\u6682\u505c\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u89c2\u5bdf\u8fed\u4ee3\u5668\u7684\u6b65\u9aa4\uff08\u5728\u771f\u5b9e\u7684\u56fe\u50cf\u751f\u6210\u6a21\u578b\u4e2d\uff0c\u8fd9\u53ef\u80fd\u662f\u4e0d\u5fc5\u8981\u7684\uff09\u3002\n\n\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio **\u9700\u8981**\u5728\u5e95\u5c42 Interface \u6216 Blocks \u4e2d\u542f\u7528\u961f\u5217\uff08\u8bf7\u53c2\u9605\u4e0a\u9762\u7684\u961f\u5217\u90e8\u5206\uff09\u3002\n\n## \u8fdb\u5ea6\u6761\n\nGradio \u652f\u6301\u521b\u5efa\u81ea\u5b9a\u4e49\u8fdb\u5ea6\u6761\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u81ea\u5b9a\u4e49\u548c\u63a7\u5236\u5411\u7528\u6237\u663e\u793a\u7684\u8fdb\u5ea6\u66f4\u65b0\u3002\u8981\u542f\u7528\u6b64\u529f\u80fd\uff0c\u53ea\u9700\u4e3a\u65b9\u6cd5\u6dfb\u52a0\u4e00\u4e2a\u9ed8\u8ba4\u503c\u4e3a `gr.Progress` \u5b9e\u4f8b\u7684\u53c2\u6570\u5373\u53ef\u3002\u7136\u540e\uff0c\u60a8\u53ef\u4ee5\u76f4\u63a5\u8c03\u7528\u6b64\u5b9e\u4f8b\u5e76\u4f20\u5165 0 \u5230 1 \u4e4b\u95f4\u7684\u6d6e\u70b9\u6570\u6765\u66f4\u65b0\u8fdb\u5ea6\u7ea7\u522b\uff0c\u6216\u8005 with `Progress` \u5b9e\u4f8b\u7684 `tqdm()` \u65b9\u6cd5\u6765\u8ddf\u8e2a\u53ef\u8fed\u4ee3\u5bf9\u8c61\u4e0a\u7684\u8fdb\u5ea6\uff0c\u5982\u4e0b\u6240\u793a\u3002\u5fc5\u987b\u542f\u7528\u961f\u5217\u4ee5\u8fdb\u884c\u8fdb\u5ea6\u66f4\u65b0\u3002\n\n$code_progress_simple\n$demo_progress_simple\n\n\u5982\u679c\u60a8 with `tqdm` \u5e93\uff0c\u5e76\u4e14\u5e0c\u671b\u4ece\u51fd\u6570\u5185\u90e8\u7684\u4efb\u4f55 `tqdm.tqdm` \u81ea\u52a8\u62a5\u544a\u8fdb\u5ea6\u66f4\u65b0\uff0c\u8bf7\u5c06\u9ed8\u8ba4\u53c2\u6570\u8bbe\u7f6e\u4e3a `gr.Progress(track_tqdm=True)`\uff01\n\n## \u6279\u5904\u7406\u51fd\u6570 (Batch Functions)\n\nGradio \u652f\u6301\u4f20\u9012*\u6279\u5904\u7406*\u51fd\u6570\u3002\u6279\u5904\u7406\u51fd\u6570\u53ea\u662f\u63a5\u53d7\u8f93\u5165\u5217\u8868\u5e76\u8fd4\u56de\u9884\u6d4b\u5217\u8868\u7684\u51fd\u6570\u3002\n\n\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\u6279\u5904\u7406\u51fd\u6570\uff0c\u5b83\u63a5\u53d7\u4e24\u4e2a\u8f93\u5165\u5217\u8868\uff08\u4e00\u4e2a\u5355\u8bcd\u5217\u8868\u548c\u4e00\u4e2a\u6574\u6570\u5217\u8868\uff09\uff0c\u5e76\u8fd4\u56de\u4fee\u526a\u8fc7\u7684\u5355\u8bcd\u5217\u8868\u4f5c\u4e3a\u8f93\u51fa\uff1a\n\n```python\nimport time\n\ndef trim_words(words, lens):\n    trimmed_words = []\n    time.sleep(5)\n    for w, l in zip(words, lens):\n        trimmed_words.append(w[:int(l)])\n    return [trimmed_words]\n    for w, l in zip(words,"
            },
            {
                "score": 0.6666359719280435,
                "node_text": "Here are some facts extracted from the provided text:\n\nBatch functions -> Accept -> Input lists\nBatch functions -> Return -> Prediction lists\n\ntqdm` \u81ea\u52a8\u62a5\u544a\u8fdb\u5ea6\u66f4\u65b0\uff0c\u8bf7\u5c06\u9ed8\u8ba4\u53c2\u6570\u8bbe\u7f6e\u4e3a `gr.Progress(track_tqdm=True)`\uff01\n\n## \u6279\u5904\u7406\u51fd\u6570 (Batch Functions)\n\nGradio \u652f\u6301\u4f20\u9012*\u6279\u5904\u7406*\u51fd\u6570\u3002\u6279\u5904\u7406\u51fd\u6570\u53ea\u662f\u63a5\u53d7\u8f93\u5165\u5217\u8868\u5e76\u8fd4\u56de\u9884\u6d4b\u5217\u8868\u7684\u51fd\u6570\u3002\n\n\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\u6279\u5904\u7406\u51fd\u6570\uff0c\u5b83\u63a5\u53d7\u4e24\u4e2a\u8f93\u5165\u5217\u8868\uff08\u4e00\u4e2a\u5355\u8bcd\u5217\u8868\u548c\u4e00\u4e2a\u6574\u6570\u5217\u8868\uff09\uff0c\u5e76\u8fd4\u56de\u4fee\u526a\u8fc7\u7684\u5355\u8bcd\u5217\u8868\u4f5c\u4e3a\u8f93\u51fa\uff1a\n\n```python\nimport time\n\ndef trim_words(words, lens):\n    trimmed_words = []\n    time.sleep(5)\n    for w, l in zip(words, lens):\n        trimmed_words.append(w[:int(l)])\n    return [trimmed_words]\n    for w, l in zip(words, lens):\n```\n\n\u4f7f\u7528\u6279\u5904\u7406\u51fd\u6570\u7684\u4f18\u70b9\u662f\uff0c\u5982\u679c\u542f\u7528\u4e86\u961f\u5217\uff0cGradio \u670d\u52a1\u5668\u53ef\u4ee5\u81ea\u52a8*\u6279\u5904\u7406*\u4f20\u5165\u7684\u8bf7\u6c42\u5e76\u5e76\u884c\u5904\u7406\u5b83\u4eec\uff0c\u4ece\u800c\u53ef\u80fd\u52a0\u5feb\u6f14\u793a\u901f\u5ea6\u3002\u4ee5\u4e0b\u662f Gradio \u4ee3\u7801\u7684\u793a\u4f8b\uff08\u8bf7\u6ce8\u610f `batch=True` \u548c `max_batch_size=16` - \u8fd9\u4e24\u4e2a\u53c2\u6570\u90fd\u53ef\u4ee5\u4f20\u9012\u7ed9\u4e8b\u4ef6\u89e6\u53d1\u5668\u6216 `Interface` \u7c7b\uff09\n\nwith `Interface`\uff1a\n\n```python\ndemo = gr.Interface(trim_words, [\"textbox\", \"number\"], [\"output\"],\n                    batch=True, max_batch_size=16)\ndemo.queue()\ndemo.launch()\n```\n\nwith `Blocks`\uff1a\n\n```python\nimport gradio as gr\n\nwith gr.Blocks() as demo:\n    with gr.Row():\n        word = gr.Textbox(label=\"word\")\n        leng = gr.Number(label=\"leng\")\n        output = gr.Textbox(label=\"Output\")\n    with gr.Row():\n        run = gr.Button()\n\n    event = run.click(trim_words, [word, leng], output, batch=True, max_batch_size=16)\n\ndemo.queue()\ndemo.launch()\n```\n\n\u5728\u4e0a\u9762\u7684\u793a\u4f8b\u4e2d\uff0c\u53ef\u4ee5\u5e76\u884c\u5904\u7406 16 \u4e2a\u8bf7\u6c42\uff08\u603b\u63a8\u7406\u65f6\u95f4\u4e3a 5 \u79d2\uff09\uff0c\u800c\u4e0d\u662f\u5206\u522b\u5904\u7406\u6bcf\u4e2a\u8bf7\u6c42\uff08\u603b\u63a8\u7406\u65f6\u95f4\u4e3a 80 \u79d2\uff09\u3002\u8bb8\u591a Hugging Face \u7684 `transformers` \u548c `diffusers` \u6a21\u578b\u5728 Gradio \u7684\u6279\u5904\u7406\u6a21\u5f0f\u4e0b\u81ea\u7136\u5de5\u4f5c\uff1a\u8fd9\u662f[\u4f7f\u7528\u6279\u5904\u7406\u751f\u6210\u56fe\u50cf\u7684\u793a\u4f8b\u6f14\u793a](https://github.com/gradio-app/gradio/blob/main/demo/diffusers_with_batching/run.py)\n\n\u6ce8\u610f\uff1a\u4f7f\u7528 Gradio \u7684\u6279\u5904\u7406\u51fd\u6570 **requires** \u5728\u5e95\u5c42 Interface \u6216 Blocks \u4e2d\u542f\u7528\u961f\u5217\uff08\u8bf7\u53c2\u9605\u4e0a\u9762\u7684\u961f\u5217\u90e8\u5206\uff09\u3002\n\n## Gradio \u7b14\u8bb0\u672c (Colab Notebooks)\n\nGradio \u53ef\u4ee5\u5728\u4efb\u4f55\u8fd0\u884c Python \u7684\u5730\u65b9\u8fd0\u884c\uff0c\u5305\u62ec\u672c\u5730 Jupyter \u7b14\u8bb0\u672c\u548c\u534f\u4f5c\u7b14\u8bb0\u672c\uff0c\u5982[Google Colab](https://colab.research.google.com/)\u3002\u5bf9\u4e8e\u672c\u5730 Jupyter \u7b14\u8bb0\u672c\u548c Google Colab \u7b14\u8bb0\u672c\uff0cGradio \u5728\u672c\u5730\u670d\u52a1\u5668\u4e0a\u8fd0\u884c\uff0c\u60a8\u53ef\u4ee5\u5728\u6d4f\u89c8\u5668\u4e2d\u4e0e\u4e4b\u4ea4\u4e92\u3002\uff08\u6ce8\u610f\uff1a\u5bf9\u4e8e Google Colab\uff0c\u8fd9\u662f\u901a\u8fc7[\u670d\u52a1\u5de5\u4f5c\u5668\u96a7\u9053](https://github.com/tensorflow/tensorboard/blob/master/docs/design/colab_integration.md)\u5b9e\u73b0\u7684\uff0c\u60a8\u7684\u6d4f\u89c8\u5668\u9700\u8981\u542f\u7528 cookies\u3002\uff09\u5bf9\u4e8e\u5176\u4ed6\u8fdc\u7a0b\u7b14\u8bb0\u672c\uff0cGradio \u4e5f\u5c06\u5728\u670d\u52a1\u5668\u4e0a\u8fd0\u884c\uff0c\u4f46\u60a8\u9700\u8981\u4f7f\u7528[SSH \u96a7\u9053](https://coderwall.com/p/ohk6cg/remote-access-to-ipython-notebooks-via-ssh)\u5728\u672c\u5730\u6d4f\u89c8\u5668\u4e2d\u67e5\u770b\u5e94\u7528\u7a0b\u5e8f\u3002\u901a\u5e38\uff0c\u66f4\u7b80\u5355\u7684\u9009\u62e9\u662f\u4f7f\u7528 Gradio \u5185\u7f6e\u7684\u516c\u5171\u94fe\u63a5\uff0c[\u5728\u4e0b\u4e00\u7bc7\u6307\u5357\u4e2d\u8ba8\u8bba](/sharing-your-app/#sharing-demos)\u3002"
            }
        ]
    },
    {
        "sample_idx": 35,
        "question": "Where can Gradio run?",
        "answer": "Gradio can run anywhere Python can run, including local Jupyter notebooks and collaborative notebooks like Google Colab.",
        "rag_answer": "Gradio can run in Colab notebooks.",
        "rag_score": 3,
        "rag_feedback": "The system's response is partially correct, but it does not fully answer the question. The response mentions that Gradio can run in Colab notebooks, which is correct, but it does not provide the complete information that Gradio can run anywhere Python can run, including local Jupyter notebooks and collaborative notebooks like Google Colab.",
        "rag_context": [
            {
                "score": 0.7291219486455554,
                "node_text": "Here are some facts extracted from the provided text:\n\nGr -> Is -> Alias of gradio\nGradio -> Provides -> Pre-built themes\nGradio -> Is -> Library\nGradio -> Supports -> Iterative outputs\nGradio -> Has feature -> \u6dfb\u52a0\u63cf\u8ff0\u5185\u5bb9\nGradio -> Converts -> Data format\nGradio -> Has feature -> \u8fdb\u5ea6\u6761\nGradio -> Automatically handles -> Preprocessing\nGradio -> Has feature -> \u8bbe\u7f6e\u65d7\u6807\nGradio -> Has feature -> \u8fed\u4ee3\u8f93\u51fa\nGradio -> Has feature -> \u9884\u5904\u7406\u548c\u540e\u5904\u7406\nGradio -> Installed by -> Pip\nGradio -> Has feature -> \u6392\u961f\u7528\u6237\nGradio -> Recognizes -> Data format\nGradio -> Automatically handles -> Postprocessing\nGradio -> Supports -> Hugging face models\nGradio -> Supports -> Batch functions\nGradio -> Enables -> Parallel processing\nGradio -> Has feature -> \u6279\u5904\u7406\u51fd\u6570\nGradio -> Has feature -> \u4f20\u9012\u81ea\u5b9a\u4e49\u9519\u8bef\u6d88\u606f\nGradio -> Can run -> In colab notebooks\nGradio -> Supports -> Progress bars\nGradio -> Includes -> Components\nGradio -> Has feature -> \u6837\u5f0f\u5316\u6f14\u793a\nGradio -> Has feature -> \u6dfb\u52a0\u793a\u4f8b\u8f93\u5165\n\nGradio Demo: blocks_random_slider\n\n\n```\n!pip install -q gradio \n```\n\n\n```\n\nimport gradio as gr\n\n\ndef func(slider_1, slider_2):\n    return slider_1 * 5 + slider_2\n\n\nwith gr.Blocks() as demo:\n    slider = gr.Slider(minimum=-10.2, maximum=15, label=\"Random Slider (Static)\", randomize=True)\n    slider_1 = gr.Slider(minimum=100, maximum=200, label=\"Random Slider (Input 1)\", randomize=True)\n    slider_2 = gr.Slider(minimum=10, maximum=23.2, label=\"Random Slider (Input 2)\", randomize=True)\n    slider_3 = gr.Slider(value=3, label=\"Non random slider\")\n    btn = gr.Button(\"Run\")\n    btn.click(func, inputs=[slider_1, slider_2], outputs=gr.Number())\n\nif __name__ == \"__main__\":\n    demo.launch()\n\n```"
            },
            {
                "score": 0.7158531927334928,
                "node_text": "Here are some facts extracted from the provided text:\n\nGenerator function -> Is -> Provided to gradio\n\nBlocks() as demo\uff1a\n    #.\ndemo.queue()\ndemo.launch()\n```\n\n\u60a8\u53ef\u4ee5\u901a\u8fc7\u4ee5\u4e0b\u65b9\u5f0f\u63a7\u5236\u4e00\u6b21\u5904\u7406\u7684\u8bf7\u6c42\u6570\u91cf\uff1a\n\n```python\ndemo.queue(concurrency_count=3)\n```\n\n\u67e5\u770b\u6709\u5173\u914d\u7f6e\u5176\u4ed6\u961f\u5217\u53c2\u6570\u7684[\u961f\u5217\u6587\u6863](/docs/#queue)\u3002\n\n\u5728 Blocks \u4e2d\u6307\u5b9a\u4ec5\u5bf9\u67d0\u4e9b\u51fd\u6570\u8fdb\u884c\u6392\u961f\uff1a\n\n```python\nwith gr.Blocks() as demo2\uff1a\n    num1 = gr.Number()\n    num2 = gr.Number()\n    output = gr.Number()\n    gr.Button(\"Add\").click(\n        lambda a, b: a + b, [num1, num2], output)\n    gr.Button(\"Multiply\").click(\n        lambda a, b: a * b, [num1, num2], output, queue=True)\ndemo2.launch()\n```\n\n## \u8fed\u4ee3\u8f93\u51fa (Iterative Outputs)\n\n\u5728\u67d0\u4e9b\u60c5\u51b5\u4e0b\uff0c\u60a8\u53ef\u80fd\u9700\u8981\u4f20\u8f93\u4e00\u7cfb\u5217\u8f93\u51fa\u800c\u4e0d\u662f\u4e00\u6b21\u663e\u793a\u5355\u4e2a\u8f93\u51fa\u3002\u4f8b\u5982\uff0c\u60a8\u53ef\u80fd\u6709\u4e00\u4e2a\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5e0c\u671b\u663e\u793a\u751f\u6210\u7684\u6bcf\u4e2a\u6b65\u9aa4\u7684\u56fe\u50cf\uff0c\u76f4\u5230\u6700\u7ec8\u56fe\u50cf\u3002\u6216\u8005\u60a8\u53ef\u80fd\u6709\u4e00\u4e2a\u804a\u5929\u673a\u5668\u4eba\uff0c\u5b83\u9010\u5b57\u9010\u53e5\u5730\u6d41\u5f0f\u4f20\u8f93\u54cd\u5e94\uff0c\u800c\u4e0d\u662f\u4e00\u6b21\u8fd4\u56de\u5168\u90e8\u54cd\u5e94\u3002\n\n\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u60a8\u53ef\u4ee5\u5c06**\u751f\u6210\u5668**\u51fd\u6570\u63d0\u4f9b\u7ed9 Gradio\uff0c\u800c\u4e0d\u662f\u5e38\u89c4\u51fd\u6570\u3002\u5728 Python \u4e2d\u521b\u5efa\u751f\u6210\u5668\u975e\u5e38\u7b80\u5355\uff1a\u51fd\u6570\u4e0d\u5e94\u8be5\u6709\u4e00\u4e2a\u5355\u72ec\u7684 `return` \u503c\uff0c\u800c\u662f\u5e94\u8be5 with `yield` \u8fde\u7eed\u8fd4\u56de\u4e00\u7cfb\u5217\u503c\u3002\u901a\u5e38\uff0c`yield` \u8bed\u53e5\u653e\u7f6e\u5728\u67d0\u79cd\u5faa\u73af\u4e2d\u3002\u4e0b\u9762\u662f\u4e00\u4e2a\u7b80\u5355\u793a\u4f8b\uff0c\u751f\u6210\u5668\u53ea\u662f\u7b80\u5355\u8ba1\u6570\u5230\u7ed9\u5b9a\u6570\u5b57\uff1a\n\n```python\ndef my_generator(x):\n    for i in range(x):\n        yield i\n```\n\n\u60a8\u4ee5\u4e0e\u5e38\u89c4\u51fd\u6570\u76f8\u540c\u7684\u65b9\u5f0f\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio\u3002\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\uff08\u865a\u62df\u7684\uff09\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5b83\u5728\u8f93\u51fa\u56fe\u50cf\u4e4b\u524d\u751f\u6210\u6570\u4e2a\u6b65\u9aa4\u7684\u566a\u97f3\uff1a\n\n$code_fake_diffusion\n$demo_fake_diffusion\n\n\u8bf7\u6ce8\u610f\uff0c\u6211\u4eec\u5728\u8fed\u4ee3\u5668\u4e2d\u6dfb\u52a0\u4e86 `time.sleep(1)`\uff0c\u4ee5\u521b\u5efa\u6b65\u9aa4\u4e4b\u95f4\u7684\u4eba\u5de5\u6682\u505c\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u89c2\u5bdf\u8fed\u4ee3\u5668\u7684\u6b65\u9aa4\uff08\u5728\u771f\u5b9e\u7684\u56fe\u50cf\u751f\u6210\u6a21\u578b\u4e2d\uff0c\u8fd9\u53ef\u80fd\u662f\u4e0d\u5fc5\u8981\u7684\uff09\u3002\n\n\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio **\u9700\u8981**\u5728\u5e95\u5c42 Interface \u6216 Blocks \u4e2d\u542f\u7528\u961f\u5217\uff08\u8bf7\u53c2\u9605\u4e0a\u9762\u7684\u961f\u5217\u90e8\u5206\uff09\u3002\n\n## \u8fdb\u5ea6\u6761\n\nGradio \u652f\u6301\u521b\u5efa\u81ea\u5b9a\u4e49\u8fdb\u5ea6\u6761\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u81ea\u5b9a\u4e49\u548c\u63a7\u5236\u5411\u7528\u6237\u663e\u793a\u7684\u8fdb\u5ea6\u66f4\u65b0\u3002\u8981\u542f\u7528\u6b64\u529f\u80fd\uff0c\u53ea\u9700\u4e3a\u65b9\u6cd5\u6dfb\u52a0\u4e00\u4e2a\u9ed8\u8ba4\u503c\u4e3a `gr.Progress` \u5b9e\u4f8b\u7684\u53c2\u6570\u5373\u53ef\u3002\u7136\u540e\uff0c\u60a8\u53ef\u4ee5\u76f4\u63a5\u8c03\u7528\u6b64\u5b9e\u4f8b\u5e76\u4f20\u5165 0 \u5230 1 \u4e4b\u95f4\u7684\u6d6e\u70b9\u6570\u6765\u66f4\u65b0\u8fdb\u5ea6\u7ea7\u522b\uff0c\u6216\u8005 with `Progress` \u5b9e\u4f8b\u7684 `tqdm()` \u65b9\u6cd5\u6765\u8ddf\u8e2a\u53ef\u8fed\u4ee3\u5bf9\u8c61\u4e0a\u7684\u8fdb\u5ea6\uff0c\u5982\u4e0b\u6240\u793a\u3002\u5fc5\u987b\u542f\u7528\u961f\u5217\u4ee5\u8fdb\u884c\u8fdb\u5ea6\u66f4\u65b0\u3002\n\n$code_progress_simple\n$demo_progress_simple\n\n\u5982\u679c\u60a8 with `tqdm` \u5e93\uff0c\u5e76\u4e14\u5e0c\u671b\u4ece\u51fd\u6570\u5185\u90e8\u7684\u4efb\u4f55 `tqdm.tqdm` \u81ea\u52a8\u62a5\u544a\u8fdb\u5ea6\u66f4\u65b0\uff0c\u8bf7\u5c06\u9ed8\u8ba4\u53c2\u6570\u8bbe\u7f6e\u4e3a `gr.Progress(track_tqdm=True)`\uff01\n\n## \u6279\u5904\u7406\u51fd\u6570 (Batch Functions)\n\nGradio \u652f\u6301\u4f20\u9012*\u6279\u5904\u7406*\u51fd\u6570\u3002\u6279\u5904\u7406\u51fd\u6570\u53ea\u662f\u63a5\u53d7\u8f93\u5165\u5217\u8868\u5e76\u8fd4\u56de\u9884\u6d4b\u5217\u8868\u7684\u51fd\u6570\u3002\n\n\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\u6279\u5904\u7406\u51fd\u6570\uff0c\u5b83\u63a5\u53d7\u4e24\u4e2a\u8f93\u5165\u5217\u8868\uff08\u4e00\u4e2a\u5355\u8bcd\u5217\u8868\u548c\u4e00\u4e2a\u6574\u6570\u5217\u8868\uff09\uff0c\u5e76\u8fd4\u56de\u4fee\u526a\u8fc7\u7684\u5355\u8bcd\u5217\u8868\u4f5c\u4e3a\u8f93\u51fa\uff1a\n\n```python\nimport time\n\ndef trim_words(words, lens):\n    trimmed_words = []\n    time.sleep(5)\n    for w, l in zip(words, lens):\n        trimmed_words.append(w[:int(l)])\n    return [trimmed_words]\n    for w, l in zip(words,"
            },
            {
                "score": 0.5950462312610177,
                "node_text": "Here are some facts extracted from the provided text:\n\nGradio theme -> Is -> Customizable\n\n[annotated](/assets/img/dataflow.svg)\n\n\u5982\u60a8\u6240\u89c1\uff0cGradio \u5305\u62ec\u53ef\u4ee5\u5904\u7406\u5404\u79cd\u4e0d\u540c\u6570\u636e\u7c7b\u578b\u7684\u7ec4\u4ef6\uff0c\u4f8b\u5982\u56fe\u50cf\u3001\u97f3\u9891\u548c\u89c6\u9891\u3002\u5927\u591a\u6570\u7ec4\u4ef6\u90fd\u53ef\u4ee5\u7528\u4f5c\u8f93\u5165\u6216\u8f93\u51fa\u3002\n\n\u5f53\u7ec4\u4ef6\u7528\u4f5c\u8f93\u5165\u65f6\uff0cGradio \u81ea\u52a8\u5904\u7406*\u9884\u5904\u7406*\uff0c\u5c06\u6570\u636e\u4ece\u7528\u6237\u6d4f\u89c8\u5668\u53d1\u9001\u7684\u7c7b\u578b\uff08\u4f8b\u5982\u7f51\u7edc\u6444\u50cf\u5934\u5feb\u7167\u7684 base64 \u8868\u793a\uff09\u8f6c\u6362\u4e3a\u60a8\u7684\u51fd\u6570\u53ef\u4ee5\u63a5\u53d7\u7684\u5f62\u5f0f\uff08\u4f8b\u5982 `numpy` \u6570\u7ec4\uff09\u3002\n\n\u540c\u6837\uff0c\u5f53\u7ec4\u4ef6\u7528\u4f5c\u8f93\u51fa\u65f6\uff0cGradio \u81ea\u52a8\u5904\u7406*\u540e\u5904\u7406*\uff0c\u5c06\u6570\u636e\u4ece\u51fd\u6570\u8fd4\u56de\u7684\u5f62\u5f0f\uff08\u4f8b\u5982\u56fe\u50cf\u8def\u5f84\u5217\u8868\uff09\u8f6c\u6362\u4e3a\u53ef\u4ee5\u5728\u7528\u6237\u6d4f\u89c8\u5668\u4e2d\u663e\u793a\u7684\u5f62\u5f0f\uff08\u4f8b\u5982\u4ee5 base64 \u683c\u5f0f\u663e\u793a\u56fe\u50cf\u7684 `Gallery`\uff09\u3002\n\n\u60a8\u53ef\u4ee5\u4f7f\u7528\u6784\u5efa\u56fe\u50cf\u7ec4\u4ef6\u65f6\u7684\u53c2\u6570\u63a7\u5236*\u9884\u5904\u7406*\u3002\u4f8b\u5982\uff0c\u5982\u679c\u60a8\u4f7f\u7528\u4ee5\u4e0b\u53c2\u6570\u5b9e\u4f8b\u5316 `Image` \u7ec4\u4ef6\uff0c\u5b83\u5c06\u5c06\u56fe\u50cf\u8f6c\u6362\u4e3a `PIL` \u7c7b\u578b\uff0c\u5e76\u5c06\u5176\u91cd\u5851\u4e3a`(100, 100)`\uff0c\u800c\u4e0d\u7ba1\u63d0\u4ea4\u65f6\u7684\u539f\u59cb\u5927\u5c0f\u5982\u4f55\uff1a\n\n```py\nimg = gr.Image(shape=(100, 100), type=\"pil\")\n```\n\n\u76f8\u53cd\uff0c\u8fd9\u91cc\u6211\u4eec\u4fdd\u7559\u56fe\u50cf\u7684\u539f\u59cb\u5927\u5c0f\uff0c\u4f46\u5728\u5c06\u5176\u8f6c\u6362\u4e3a numpy \u6570\u7ec4\u4e4b\u524d\u53cd\u8f6c\u989c\u8272\uff1a\n\n```py\nimg = gr.Image(invert_colors=True, type=\"numpy\")\n```\n\n\u540e\u5904\u7406\u8981\u5bb9\u6613\u5f97\u591a\uff01Gradio \u81ea\u52a8\u8bc6\u522b\u8fd4\u56de\u6570\u636e\u7684\u683c\u5f0f\uff08\u4f8b\u5982 `Image` \u662f `numpy` \u6570\u7ec4\u8fd8\u662f `str` \u6587\u4ef6\u8def\u5f84\uff1f\uff09\uff0c\u5e76\u5c06\u5176\u540e\u5904\u7406\u4e3a\u53ef\u4ee5\u7531\u6d4f\u89c8\u5668\u663e\u793a\u7684\u683c\u5f0f\u3002\n\n\u8bf7\u67e5\u770b[\u6587\u6863](https://gradio.app/docs)\uff0c\u4e86\u89e3\u6bcf\u4e2a\u7ec4\u4ef6\u7684\u6240\u6709\u4e0e\u9884\u5904\u7406\u76f8\u5173\u7684\u53c2\u6570\u3002\n\n## \u6837\u5f0f (Styling)\n\nGradio \u4e3b\u9898\u662f\u81ea\u5b9a\u4e49\u5e94\u7528\u7a0b\u5e8f\u5916\u89c2\u548c\u611f\u89c9\u7684\u6700\u7b80\u5355\u65b9\u6cd5\u3002\u60a8\u53ef\u4ee5\u9009\u62e9\u591a\u79cd\u4e3b\u9898\u6216\u521b\u5efa\u81ea\u5df1\u7684\u4e3b\u9898\u3002\u8981\u8fd9\u6837\u505a\uff0c\u8bf7\u5c06 `theme=` \u53c2\u6570\u4f20\u9012\u7ed9 `Interface` \u6784\u9020\u51fd\u6570\u3002\u4f8b\u5982\uff1a\n\n```python\ndemo = gr.Interface(..., theme=gr.themes.Monochrome())\n```\n\nGradio \u5e26\u6709\u4e00\u7ec4\u9884\u5148\u6784\u5efa\u7684\u4e3b\u9898\uff0c\u60a8\u53ef\u4ee5\u4ece `gr.themes.*` \u52a0\u8f7d\u3002\u60a8\u53ef\u4ee5\u6269\u5c55\u8fd9\u4e9b\u4e3b\u9898\u6216\u4ece\u5934\u5f00\u59cb\u521b\u5efa\u81ea\u5df1\u7684\u4e3b\u9898 - \u6709\u5173\u66f4\u591a\u8be6\u7ec6\u4fe1\u606f\uff0c\u8bf7\u53c2\u9605[\u4e3b\u9898\u6307\u5357](https://gradio.app/theming-guide)\u3002\n\n\u8981\u589e\u52a0\u989d\u5916\u7684\u6837\u5f0f\u80fd\u529b\uff0c\u60a8\u53ef\u4ee5 with `css=` \u5173\u952e\u5b57\u5c06\u4efb\u4f55 CSS \u4f20\u9012\u7ed9\u60a8\u7684\u5e94\u7528\u7a0b\u5e8f\u3002\nGradio \u5e94\u7528\u7a0b\u5e8f\u7684\u57fa\u7c7b\u662f `gradio-container`\uff0c\u56e0\u6b64\u4ee5\u4e0b\u662f\u4e00\u4e2a\u66f4\u6539 Gradio \u5e94\u7528\u7a0b\u5e8f\u80cc\u666f\u989c\u8272\u7684\u793a\u4f8b\uff1a\n\n```python\nwith `gr.Interface(css=\".gradio-container {background-color: red}\") as demo:\n    .\n```\n\n## \u961f\u5217 (Queuing)\n\n\u5982\u679c\u60a8\u7684\u5e94\u7528\u7a0b\u5e8f\u9884\u8ba1\u4f1a\u6709\u5927\u91cf\u6d41\u91cf\uff0c\u8bf7 with `queue()` \u65b9\u6cd5\u6765\u63a7\u5236\u5904\u7406\u901f\u7387\u3002\u8fd9\u5c06\u6392\u961f\u5904\u7406\u8c03\u7528\uff0c\u56e0\u6b64\u4e00\u6b21\u53ea\u5904\u7406\u4e00\u5b9a\u6570\u91cf\u7684\u8bf7\u6c42\u3002\u961f\u5217\u4f7f\u7528 Websockets\uff0c\u8fd8\u53ef\u4ee5\u9632\u6b62\u7f51\u7edc\u8d85\u65f6\uff0c\u56e0\u6b64\u5982\u679c\u60a8\u7684\u51fd\u6570\u7684\u63a8\u7406\u65f6\u95f4\u5f88\u957f\uff08> 1 \u5206\u949f\uff09\uff0c\u5e94\u4f7f\u7528\u961f\u5217\u3002\n\nwith `Interface`\uff1a\n\n```python\ndemo = gr.Interface(.).queue()\ndemo.launch()\n```\n\nwith `Blocks`\uff1a\n\n```python\nwith gr.Blocks() as demo\uff1a\n    #.\ndemo.queue()\ndemo.launch()\n```\n\n\u60a8\u53ef\u4ee5\u901a\u8fc7\u4ee5\u4e0b\u65b9\u5f0f\u63a7\u5236\u4e00\u6b21\u5904\u7406\u7684\u8bf7\u6c42\u6570\u91cf\uff1a\n\n```python\ndemo.queue(concurrency_count=3)\n```\n\n\u67e5\u770b\u6709\u5173\u914d\u7f6e\u5176\u4ed6\u961f\u5217\u53c2\u6570\u7684[\u961f\u5217\u6587\u6863](/docs/#queue)\u3002\n\n\u5728 Blocks \u4e2d\u6307\u5b9a\u4ec5\u5bf9\u67d0\u4e9b\u51fd\u6570\u8fdb\u884c\u6392\u961f\uff1a\n\n```python\nwith gr.Blocks() as demo2\uff1a\n    num1 = gr.Number()\n    num2 = gr.Number()\n    output = gr.Number()\n    gr.Button(\"Add\").click(\n        lambda a, b: a + b, [num1, num2], output)\n    gr.Button(\"Multiply\").click(\n        lambda a, b: a * b, [num1, num2], output, queue=True)\ndemo2."
            }
        ]
    },
    {
        "sample_idx": 36,
        "question": "How does Gradio run in Google Colab?",
        "answer": "Gradio runs on a local server in Google Colab through a service worker tunnel, and the browser needs to have cookies enabled.",
        "rag_answer": "Gradio can run in Google Colab notebooks.",
        "rag_score": 2,
        "rag_feedback": "The system's response is mostly incorrect, inaccurate, and/or not factual. While it provides some general information about Gradio and its features, it does not directly answer the question of how Gradio runs in Google Colab. The expected answer mentions a local server and service worker tunnel, which is not mentioned in the system's response.",
        "rag_context": [
            {
                "score": 0.7258694385487784,
                "node_text": "Here are some facts extracted from the provided text:\n\nGr -> Is -> Alias of gradio\nGradio -> Provides -> Pre-built themes\nGradio -> Is -> Library\nGradio -> Supports -> Iterative outputs\nGradio -> Has feature -> \u6dfb\u52a0\u63cf\u8ff0\u5185\u5bb9\nGradio -> Converts -> Data format\nGradio -> Has feature -> \u8fdb\u5ea6\u6761\nGradio -> Automatically handles -> Preprocessing\nGradio -> Has feature -> \u8bbe\u7f6e\u65d7\u6807\nGradio -> Has feature -> \u8fed\u4ee3\u8f93\u51fa\nGradio -> Has feature -> \u9884\u5904\u7406\u548c\u540e\u5904\u7406\nGradio -> Installed by -> Pip\nGradio -> Has feature -> \u6392\u961f\u7528\u6237\nGradio -> Recognizes -> Data format\nGradio -> Automatically handles -> Postprocessing\nGradio -> Supports -> Hugging face models\nGradio -> Supports -> Batch functions\nGradio -> Enables -> Parallel processing\nGradio -> Has feature -> \u6279\u5904\u7406\u51fd\u6570\nGradio -> Has feature -> \u4f20\u9012\u81ea\u5b9a\u4e49\u9519\u8bef\u6d88\u606f\nGradio -> Can run -> In colab notebooks\nGradio -> Supports -> Progress bars\nGradio -> Includes -> Components\nGradio -> Has feature -> \u6837\u5f0f\u5316\u6f14\u793a\nGradio -> Has feature -> \u6dfb\u52a0\u793a\u4f8b\u8f93\u5165\n\nGradio Demo: blocks_random_slider\n\n\n```\n!pip install -q gradio \n```\n\n\n```\n\nimport gradio as gr\n\n\ndef func(slider_1, slider_2):\n    return slider_1 * 5 + slider_2\n\n\nwith gr.Blocks() as demo:\n    slider = gr.Slider(minimum=-10.2, maximum=15, label=\"Random Slider (Static)\", randomize=True)\n    slider_1 = gr.Slider(minimum=100, maximum=200, label=\"Random Slider (Input 1)\", randomize=True)\n    slider_2 = gr.Slider(minimum=10, maximum=23.2, label=\"Random Slider (Input 2)\", randomize=True)\n    slider_3 = gr.Slider(value=3, label=\"Non random slider\")\n    btn = gr.Button(\"Run\")\n    btn.click(func, inputs=[slider_1, slider_2], outputs=gr.Number())\n\nif __name__ == \"__main__\":\n    demo.launch()\n\n```"
            },
            {
                "score": 0.7111052938286818,
                "node_text": "Here are some facts extracted from the provided text:\n\nGenerator function -> Is -> Provided to gradio\n\nBlocks() as demo\uff1a\n    #.\ndemo.queue()\ndemo.launch()\n```\n\n\u60a8\u53ef\u4ee5\u901a\u8fc7\u4ee5\u4e0b\u65b9\u5f0f\u63a7\u5236\u4e00\u6b21\u5904\u7406\u7684\u8bf7\u6c42\u6570\u91cf\uff1a\n\n```python\ndemo.queue(concurrency_count=3)\n```\n\n\u67e5\u770b\u6709\u5173\u914d\u7f6e\u5176\u4ed6\u961f\u5217\u53c2\u6570\u7684[\u961f\u5217\u6587\u6863](/docs/#queue)\u3002\n\n\u5728 Blocks \u4e2d\u6307\u5b9a\u4ec5\u5bf9\u67d0\u4e9b\u51fd\u6570\u8fdb\u884c\u6392\u961f\uff1a\n\n```python\nwith gr.Blocks() as demo2\uff1a\n    num1 = gr.Number()\n    num2 = gr.Number()\n    output = gr.Number()\n    gr.Button(\"Add\").click(\n        lambda a, b: a + b, [num1, num2], output)\n    gr.Button(\"Multiply\").click(\n        lambda a, b: a * b, [num1, num2], output, queue=True)\ndemo2.launch()\n```\n\n## \u8fed\u4ee3\u8f93\u51fa (Iterative Outputs)\n\n\u5728\u67d0\u4e9b\u60c5\u51b5\u4e0b\uff0c\u60a8\u53ef\u80fd\u9700\u8981\u4f20\u8f93\u4e00\u7cfb\u5217\u8f93\u51fa\u800c\u4e0d\u662f\u4e00\u6b21\u663e\u793a\u5355\u4e2a\u8f93\u51fa\u3002\u4f8b\u5982\uff0c\u60a8\u53ef\u80fd\u6709\u4e00\u4e2a\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5e0c\u671b\u663e\u793a\u751f\u6210\u7684\u6bcf\u4e2a\u6b65\u9aa4\u7684\u56fe\u50cf\uff0c\u76f4\u5230\u6700\u7ec8\u56fe\u50cf\u3002\u6216\u8005\u60a8\u53ef\u80fd\u6709\u4e00\u4e2a\u804a\u5929\u673a\u5668\u4eba\uff0c\u5b83\u9010\u5b57\u9010\u53e5\u5730\u6d41\u5f0f\u4f20\u8f93\u54cd\u5e94\uff0c\u800c\u4e0d\u662f\u4e00\u6b21\u8fd4\u56de\u5168\u90e8\u54cd\u5e94\u3002\n\n\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u60a8\u53ef\u4ee5\u5c06**\u751f\u6210\u5668**\u51fd\u6570\u63d0\u4f9b\u7ed9 Gradio\uff0c\u800c\u4e0d\u662f\u5e38\u89c4\u51fd\u6570\u3002\u5728 Python \u4e2d\u521b\u5efa\u751f\u6210\u5668\u975e\u5e38\u7b80\u5355\uff1a\u51fd\u6570\u4e0d\u5e94\u8be5\u6709\u4e00\u4e2a\u5355\u72ec\u7684 `return` \u503c\uff0c\u800c\u662f\u5e94\u8be5 with `yield` \u8fde\u7eed\u8fd4\u56de\u4e00\u7cfb\u5217\u503c\u3002\u901a\u5e38\uff0c`yield` \u8bed\u53e5\u653e\u7f6e\u5728\u67d0\u79cd\u5faa\u73af\u4e2d\u3002\u4e0b\u9762\u662f\u4e00\u4e2a\u7b80\u5355\u793a\u4f8b\uff0c\u751f\u6210\u5668\u53ea\u662f\u7b80\u5355\u8ba1\u6570\u5230\u7ed9\u5b9a\u6570\u5b57\uff1a\n\n```python\ndef my_generator(x):\n    for i in range(x):\n        yield i\n```\n\n\u60a8\u4ee5\u4e0e\u5e38\u89c4\u51fd\u6570\u76f8\u540c\u7684\u65b9\u5f0f\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio\u3002\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\uff08\u865a\u62df\u7684\uff09\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5b83\u5728\u8f93\u51fa\u56fe\u50cf\u4e4b\u524d\u751f\u6210\u6570\u4e2a\u6b65\u9aa4\u7684\u566a\u97f3\uff1a\n\n$code_fake_diffusion\n$demo_fake_diffusion\n\n\u8bf7\u6ce8\u610f\uff0c\u6211\u4eec\u5728\u8fed\u4ee3\u5668\u4e2d\u6dfb\u52a0\u4e86 `time.sleep(1)`\uff0c\u4ee5\u521b\u5efa\u6b65\u9aa4\u4e4b\u95f4\u7684\u4eba\u5de5\u6682\u505c\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u89c2\u5bdf\u8fed\u4ee3\u5668\u7684\u6b65\u9aa4\uff08\u5728\u771f\u5b9e\u7684\u56fe\u50cf\u751f\u6210\u6a21\u578b\u4e2d\uff0c\u8fd9\u53ef\u80fd\u662f\u4e0d\u5fc5\u8981\u7684\uff09\u3002\n\n\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio **\u9700\u8981**\u5728\u5e95\u5c42 Interface \u6216 Blocks \u4e2d\u542f\u7528\u961f\u5217\uff08\u8bf7\u53c2\u9605\u4e0a\u9762\u7684\u961f\u5217\u90e8\u5206\uff09\u3002\n\n## \u8fdb\u5ea6\u6761\n\nGradio \u652f\u6301\u521b\u5efa\u81ea\u5b9a\u4e49\u8fdb\u5ea6\u6761\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u81ea\u5b9a\u4e49\u548c\u63a7\u5236\u5411\u7528\u6237\u663e\u793a\u7684\u8fdb\u5ea6\u66f4\u65b0\u3002\u8981\u542f\u7528\u6b64\u529f\u80fd\uff0c\u53ea\u9700\u4e3a\u65b9\u6cd5\u6dfb\u52a0\u4e00\u4e2a\u9ed8\u8ba4\u503c\u4e3a `gr.Progress` \u5b9e\u4f8b\u7684\u53c2\u6570\u5373\u53ef\u3002\u7136\u540e\uff0c\u60a8\u53ef\u4ee5\u76f4\u63a5\u8c03\u7528\u6b64\u5b9e\u4f8b\u5e76\u4f20\u5165 0 \u5230 1 \u4e4b\u95f4\u7684\u6d6e\u70b9\u6570\u6765\u66f4\u65b0\u8fdb\u5ea6\u7ea7\u522b\uff0c\u6216\u8005 with `Progress` \u5b9e\u4f8b\u7684 `tqdm()` \u65b9\u6cd5\u6765\u8ddf\u8e2a\u53ef\u8fed\u4ee3\u5bf9\u8c61\u4e0a\u7684\u8fdb\u5ea6\uff0c\u5982\u4e0b\u6240\u793a\u3002\u5fc5\u987b\u542f\u7528\u961f\u5217\u4ee5\u8fdb\u884c\u8fdb\u5ea6\u66f4\u65b0\u3002\n\n$code_progress_simple\n$demo_progress_simple\n\n\u5982\u679c\u60a8 with `tqdm` \u5e93\uff0c\u5e76\u4e14\u5e0c\u671b\u4ece\u51fd\u6570\u5185\u90e8\u7684\u4efb\u4f55 `tqdm.tqdm` \u81ea\u52a8\u62a5\u544a\u8fdb\u5ea6\u66f4\u65b0\uff0c\u8bf7\u5c06\u9ed8\u8ba4\u53c2\u6570\u8bbe\u7f6e\u4e3a `gr.Progress(track_tqdm=True)`\uff01\n\n## \u6279\u5904\u7406\u51fd\u6570 (Batch Functions)\n\nGradio \u652f\u6301\u4f20\u9012*\u6279\u5904\u7406*\u51fd\u6570\u3002\u6279\u5904\u7406\u51fd\u6570\u53ea\u662f\u63a5\u53d7\u8f93\u5165\u5217\u8868\u5e76\u8fd4\u56de\u9884\u6d4b\u5217\u8868\u7684\u51fd\u6570\u3002\n\n\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\u6279\u5904\u7406\u51fd\u6570\uff0c\u5b83\u63a5\u53d7\u4e24\u4e2a\u8f93\u5165\u5217\u8868\uff08\u4e00\u4e2a\u5355\u8bcd\u5217\u8868\u548c\u4e00\u4e2a\u6574\u6570\u5217\u8868\uff09\uff0c\u5e76\u8fd4\u56de\u4fee\u526a\u8fc7\u7684\u5355\u8bcd\u5217\u8868\u4f5c\u4e3a\u8f93\u51fa\uff1a\n\n```python\nimport time\n\ndef trim_words(words, lens):\n    trimmed_words = []\n    time.sleep(5)\n    for w, l in zip(words, lens):\n        trimmed_words.append(w[:int(l)])\n    return [trimmed_words]\n    for w, l in zip(words,"
            }
        ]
    },
    {
        "sample_idx": 37,
        "question": "What does TPU stand for?",
        "answer": "TPU stands for Tensor Processing Unit.",
        "rag_answer": "TPU stands for Tensor Processing Unit.",
        "rag_score": 5,
        "rag_feedback": "The system's response is completely correct, accurate, and factual. It directly answers the question by stating that TPU stands for Tensor Processing Unit.",
        "rag_context": [
            {
                "score": 1.0,
                "node_text": "Here are some facts extracted from the provided text:\n\nTpu -> Is -> Tensor processing unit\n\nThis is a really useful trick, so remember it if you need to convert your own code to XLA!\n\n#### XLA Rule #3: XLA will need to recompile your model for every different input shape it sees\n\nThis is the big one. What this means is that if your input shapes are very variable, XLA will have to recompile your model over and over, which will create huge performance problems. This commonly arises in NLP models, where input texts have variable lengths after tokenization. In other modalities, static shapes are more common and this rule is much less of a problem.\n\nHow can you get around rule #3? The key is **padding** - if you pad all your inputs to the same length, and then use an `attention_mask`, you can get the same results as you\u2019d get from variable shapes, but without any XLA issues. However, excessive padding can cause severe slowdown too - if you pad all your samples to the maximum length in the whole dataset, you might end up with batches consisting endless padding tokens, which will waste a lot of compute and memory!\n\nThere isn\u2019t a perfect solution to this problem. However, you can try some tricks. One very useful trick is to **pad batches of samples up to a multiple of a number like 32 or 64 tokens.** This often only increases the number of tokens by a small amount, but it hugely reduces the number of unique input shapes, because every input shape now has to be a multiple of 32 or 64. Fewer unique input shapes means fewer XLA compilations!\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** Our tokenizers and data collators have methods that can help you here. You can use `padding=\"max_length\"` or `padding=\"longest\"` when calling tokenizers to get them to output padded data. Our tokenizers and data collators also have a `pad_to_multiple_of` argument that you can use to reduce the number of unique input shapes you see!\n\n</Tip>\n\n### How do I actually train my model on TPU?\n\nOnce your training is XLA-compatible and (if you\u2019re using TPU Node / Colab) your dataset has been prepared appropriately, running on TPU is surprisingly easy! All you really need to change in your code is to add a few lines to initialize your TPU, and to ensure that your model and dataset are created inside a `TPUStrategy` scope. Take a look at [our TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) to see this in action!\n\n### Summary\n\nThere was a lot in here, so let\u2019s summarize with a quick checklist you can follow when you want to get your model ready for TPU training:\n\n- Make sure your code follows the three rules of XLA\n- Compile your model with `jit_compile=True` on CPU/GPU and confirm that you can train it with XLA\n- Either load your dataset into memory or use a TPU-compatible dataset loading approach (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Migrate your code either to Colab (with accelerator set to \u201cTPU\u201d) or a TPU VM on Google Cloud\n- Add TPU initializer code (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Create your `TPUStrategy` and make sure dataset loading and model creation are inside the `strategy.scope()` (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Don\u2019t forget to take `jit_compile=True` out again when you move to TPU!\n- \ud83d\ude4f\ud83d\ude4f\ud83d\ude4f\ud83e\udd7a\ud83e\udd7a\ud83e\udd7a\n- Call model.fit()\n- You did it!"
            },
            {
                "score": 0.8102168966016403,
                "node_text": "Here are some facts extracted from the provided text:\n\nTpu -> Is used -> For training\nXla -> Is mandatory on -> Tpu\nTpu -> Accessed through -> Google's cloud services\nTpu -> Is -> Tensor processing unit\nTpu -> Used for -> Neural networks\nTpu -> Exists in -> Pods\n\nThis is a really useful trick, so remember it if you need to convert your own code to XLA!\n\n#### XLA Rule #3: XLA will need to recompile your model for every different input shape it sees\n\nThis is the big one. What this means is that if your input shapes are very variable, XLA will have to recompile your model over and over, which will create huge performance problems. This commonly arises in NLP models, where input texts have variable lengths after tokenization. In other modalities, static shapes are more common and this rule is much less of a problem.\n\nHow can you get around rule #3? The key is **padding** - if you pad all your inputs to the same length, and then use an `attention_mask`, you can get the same results as you\u2019d get from variable shapes, but without any XLA issues. However, excessive padding can cause severe slowdown too - if you pad all your samples to the maximum length in the whole dataset, you might end up with batches consisting endless padding tokens, which will waste a lot of compute and memory!\n\nThere isn\u2019t a perfect solution to this problem. However, you can try some tricks. One very useful trick is to **pad batches of samples up to a multiple of a number like 32 or 64 tokens.** This often only increases the number of tokens by a small amount, but it hugely reduces the number of unique input shapes, because every input shape now has to be a multiple of 32 or 64. Fewer unique input shapes means fewer XLA compilations!\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** Our tokenizers and data collators have methods that can help you here. You can use `padding=\"max_length\"` or `padding=\"longest\"` when calling tokenizers to get them to output padded data. Our tokenizers and data collators also have a `pad_to_multiple_of` argument that you can use to reduce the number of unique input shapes you see!\n\n</Tip>\n\n### How do I actually train my model on TPU?\n\nOnce your training is XLA-compatible and (if you\u2019re using TPU Node / Colab) your dataset has been prepared appropriately, running on TPU is surprisingly easy! All you really need to change in your code is to add a few lines to initialize your TPU, and to ensure that your model and dataset are created inside a `TPUStrategy` scope. Take a look at [our TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) to see this in action!\n\n### Summary\n\nThere was a lot in here, so let\u2019s summarize with a quick checklist you can follow when you want to get your model ready for TPU training:\n\n- Make sure your code follows the three rules of XLA\n- Compile your model with `jit_compile=True` on CPU/GPU and confirm that you can train it with XLA\n- Either load your dataset into memory or use a TPU-compatible dataset loading approach (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Migrate your code either to Colab (with accelerator set to \u201cTPU\u201d) or a TPU VM on Google Cloud\n- Add TPU initializer code (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Create your `TPUStrategy` and make sure dataset loading and model creation are inside the `strategy.scope()` (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Don\u2019t forget to take `jit_compile=True` out again when you move to TPU!\n- \ud83d\ude4f\ud83d\ude4f\ud83d\ude4f\ud83e\udd7a\ud83e\udd7a\ud83e\udd7a\n- Call model.fit()\n- You did it!"
            },
            {
                "score": 0.8102168966016403,
                "node_text": "Here are some facts extracted from the provided text:\n\nGoogle -> Designed -> Tpu\n\n!--Copyright 2023 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\nthe License. You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under the License is distributed on\nan \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n\n\u26a0\ufe0f Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be\nrendered properly in your Markdown viewer.\n\n-->\n\n# Training on TPU with TensorFlow\n\n<Tip>\n\nIf you don't need long explanations and just want TPU code samples to get started with, check out [our TPU example notebook!](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb)\n\n</Tip>\n\n### What is a TPU?\n\nA TPU is a **Tensor Processing Unit.** They are hardware designed by Google, which are used to greatly speed up the tensor computations within neural networks, much like GPUs. They can be used for both network training and inference. They are generally accessed through Google\u2019s cloud services, but small TPUs can also be accessed directly for free through Google Colab and Kaggle Kernels.\n\nBecause [all TensorFlow models in \ud83e\udd17 Transformers are Keras models](https://huggingface.co/blog/tensorflow-philosophy), most of the methods in this document are generally applicable to TPU training for any Keras model! However, there are a few points that are specific to the HuggingFace ecosystem (hug-o-system?) of Transformers and Datasets, and we\u2019ll make sure to flag them up when we get to them.\n\n### What kinds of TPU are available?\n\nNew users are often very confused by the range of TPUs, and the different ways to access them. The first key distinction to understand is the difference between **TPU Nodes** and **TPU VMs.**\n\nWhen you use a **TPU Node**, you are effectively indirectly accessing a remote TPU. You will need a separate VM, which will initialize your network and data pipeline and then forward them to the remote node. When you use a TPU on Google Colab, you are accessing it in the **TPU Node** style.\n\nUsing TPU Nodes can have some quite unexpected behaviour for people who aren\u2019t used to them! In particular, because the TPU is located on a physically different system to the machine you\u2019re running your Python code on, your data cannot be local to your machine - any data pipeline that loads from your machine\u2019s internal storage will totally fail! Instead, data must be stored in Google Cloud Storage where your data pipeline can still access it, even when the pipeline is running on the remote TPU node.\n\n<Tip>\n\nIf you can fit all your data in memory as `np.ndarray` or `tf.Tensor`, then you can `fit()` on that data even when using Colab or a TPU Node, without needing to upload it to Google Cloud Storage.\n\n</Tip>\n\n<Tip>\n\n**\ud83e\udd17Specific Hugging Face Tip\ud83e\udd17:** The methods `Dataset.to_tf_dataset()` and its higher-level wrapper `model.prepare_tf_dataset()` , which you will see throughout our TF code examples, will both fail on a TPU Node. The reason for this is that even though they create a `tf.data.Dataset` it is not a \u201cpure\u201d `tf.data` pipeline and uses `tf.numpy_function` or `Dataset.from_generator()` to stream data from the underlying HuggingFace `Dataset`. This HuggingFace `Dataset` is backed by data that is on a local disc and which the remote TPU Node will not be able to read.\n\n</Tip>\n\nThe second way to access a TPU is via a **TPU VM.** When using a TPU VM, you connect directly to the machine that the TPU is attached to, much like training on a GPU VM. TPU VMs are generally easier to work with, particularly when it comes to your data pipeline. All of the above warnings do not apply to TPU VMs!\n\nThis is an opinionated document, so here\u2019s our opinion: **Avoid using TPU Node if possible.** It is more confusing and more difficult to debug than TPU VMs. It is also likely to be unsupported in future - Google\u2019s latest TPU, TPUv4, can only be accessed as a TPU VM, which suggests that TPU Nodes are increasingly going to become a \u201clegacy\u201d access method."
            },
            {
                "score": 0.8102168966016403,
                "node_text": "Here are some facts extracted from the provided text:\n\nTpu vm -> Connects to -> Tpu\nTpu node -> Is -> Difficult to debug\nTpu node -> Is -> Confusing\nTpu node -> Is -> Remote tpu\nTpuv4 -> Can be accessed as -> Tpu vm\nTpu vm -> Is -> Machine\nTpu vm -> Is -> Machine with tpu attached\n\n</Tip>\n\nThe second way to access a TPU is via a **TPU VM.** When using a TPU VM, you connect directly to the machine that the TPU is attached to, much like training on a GPU VM. TPU VMs are generally easier to work with, particularly when it comes to your data pipeline. All of the above warnings do not apply to TPU VMs!\n\nThis is an opinionated document, so here\u2019s our opinion: **Avoid using TPU Node if possible.** It is more confusing and more difficult to debug than TPU VMs. It is also likely to be unsupported in future - Google\u2019s latest TPU, TPUv4, can only be accessed as a TPU VM, which suggests that TPU Nodes are increasingly going to become a \u201clegacy\u201d access method. However, we understand that the only free TPU access is on Colab and Kaggle Kernels, which uses TPU Node - so we\u2019ll try to explain how to handle it if you have to! Check the [TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) for code samples that explain this in more detail.\n\n### What sizes of TPU are available?\n\nA single TPU (a v2-8/v3-8/v4-8) runs 8 replicas. TPUs exist in **pods** that can run hundreds or thousands of replicas simultaneously. When you use more than a single TPU but less than a whole pod (for example, a v3-32), your TPU fleet is referred to as a **pod slice.**\n\nWhen you access a free TPU via Colab, you generally get a single v2-8 TPU.\n\n### I keep hearing about this XLA thing. What\u2019s XLA, and how does it relate to TPUs?\n\nXLA is an optimizing compiler, used by both TensorFlow and JAX. In JAX it is the only compiler, whereas in TensorFlow it is optional (but mandatory on TPU!). The easiest way to enable it when training a Keras model is to pass the argument `jit_compile=True` to `model.compile()`. If you don\u2019t get any errors and performance is good, that\u2019s a great sign that you\u2019re ready to move to TPU!\n\nDebugging on TPU is generally a bit harder than on CPU/GPU, so we recommend getting your code running on CPU/GPU with XLA first before trying it on TPU. You don\u2019t have to train for long, of course - just for a few steps to make sure that your model and data pipeline are working like you expect them to.\n\n<Tip>\n\nXLA compiled code is usually faster - so even if you\u2019re not planning to run on TPU, adding `jit_compile=True` can improve your performance. Be sure to note the caveats below about XLA compatibility, though!\n\n</Tip>\n\n<Tip warning={true}>\n\n**Tip born of painful experience:** Although using `jit_compile=True` is a good way to get a speed boost and test if your CPU/GPU code is XLA-compatible, it can actually cause a lot of problems if you leave it in when actually training on TPU. XLA compilation will happen implicitly on TPU, so remember to remove that line before actually running your code on a TPU!\n\n</Tip>\n\n### How do I make my model XLA compatible?\n\nIn many cases, your code is probably XLA-compatible already! However, there are a few things that work in normal TensorFlow that don\u2019t work in XLA. We\u2019ve distilled them into three core rules below:\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** We\u2019ve put a lot of effort into rewriting our TensorFlow models and loss functions to be XLA-compatible. Our models and loss functions generally obey rule #1 and #2 by default, so you can skip over them if you\u2019re using `transformers` models. Don\u2019t forget about these rules when writing your own models and loss functions, though!\n\n</Tip>\n\n#### XLA Rule #1: Your code cannot have \u201cdata-dependent conditionals\u201d\n\nWhat that means is that any `if` statement cannot depend on values inside a `tf.Tensor`. For example, this code block cannot be compiled with XLA!\n\n```python\nif tf.reduce_sum(tensor) > 10:\n    tensor = tensor / 2.0\n```\n\nThis might seem very restrictive at first, but most neural net code doesn\u2019t need to do this."
            }
        ]
    },
    {
        "sample_idx": 38,
        "question": "What is the purpose of a TPU?",
        "answer": "TPUs are used to greatly speed up the tensor computations within neural networks.",
        "rag_answer": "A TPU (Tensor Processing Unit) is designed to greatly speed up the tensor computations within neural networks, much like GPUs. They can be used for both network training and inference, and their scalability allows them to run hundreds or thousands of replicas simultaneously, making them particularly useful for large-scale machine learning tasks.",
        "rag_score": 5,
        "rag_feedback": "The system's response is completely correct, accurate, and factual. It provides a detailed explanation of what a TPU is, its purpose, and how it is used for neural networks, which aligns with the expected answer.",
        "rag_context": [
            {
                "score": 1.0,
                "node_text": "Here are some facts extracted from the provided text:\n\nTpu -> Is -> Tensor processing unit\n\nThis is a really useful trick, so remember it if you need to convert your own code to XLA!\n\n#### XLA Rule #3: XLA will need to recompile your model for every different input shape it sees\n\nThis is the big one. What this means is that if your input shapes are very variable, XLA will have to recompile your model over and over, which will create huge performance problems. This commonly arises in NLP models, where input texts have variable lengths after tokenization. In other modalities, static shapes are more common and this rule is much less of a problem.\n\nHow can you get around rule #3? The key is **padding** - if you pad all your inputs to the same length, and then use an `attention_mask`, you can get the same results as you\u2019d get from variable shapes, but without any XLA issues. However, excessive padding can cause severe slowdown too - if you pad all your samples to the maximum length in the whole dataset, you might end up with batches consisting endless padding tokens, which will waste a lot of compute and memory!\n\nThere isn\u2019t a perfect solution to this problem. However, you can try some tricks. One very useful trick is to **pad batches of samples up to a multiple of a number like 32 or 64 tokens.** This often only increases the number of tokens by a small amount, but it hugely reduces the number of unique input shapes, because every input shape now has to be a multiple of 32 or 64. Fewer unique input shapes means fewer XLA compilations!\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** Our tokenizers and data collators have methods that can help you here. You can use `padding=\"max_length\"` or `padding=\"longest\"` when calling tokenizers to get them to output padded data. Our tokenizers and data collators also have a `pad_to_multiple_of` argument that you can use to reduce the number of unique input shapes you see!\n\n</Tip>\n\n### How do I actually train my model on TPU?\n\nOnce your training is XLA-compatible and (if you\u2019re using TPU Node / Colab) your dataset has been prepared appropriately, running on TPU is surprisingly easy! All you really need to change in your code is to add a few lines to initialize your TPU, and to ensure that your model and dataset are created inside a `TPUStrategy` scope. Take a look at [our TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) to see this in action!\n\n### Summary\n\nThere was a lot in here, so let\u2019s summarize with a quick checklist you can follow when you want to get your model ready for TPU training:\n\n- Make sure your code follows the three rules of XLA\n- Compile your model with `jit_compile=True` on CPU/GPU and confirm that you can train it with XLA\n- Either load your dataset into memory or use a TPU-compatible dataset loading approach (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Migrate your code either to Colab (with accelerator set to \u201cTPU\u201d) or a TPU VM on Google Cloud\n- Add TPU initializer code (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Create your `TPUStrategy` and make sure dataset loading and model creation are inside the `strategy.scope()` (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Don\u2019t forget to take `jit_compile=True` out again when you move to TPU!\n- \ud83d\ude4f\ud83d\ude4f\ud83d\ude4f\ud83e\udd7a\ud83e\udd7a\ud83e\udd7a\n- Call model.fit()\n- You did it!"
            },
            {
                "score": 0.7750322038112106,
                "node_text": "Here are some facts extracted from the provided text:\n\nTpu -> Is used -> For training\nXla -> Is mandatory on -> Tpu\nTpu -> Accessed through -> Google's cloud services\nTpu -> Is -> Tensor processing unit\nTpu -> Used for -> Neural networks\nTpu -> Exists in -> Pods\n\nThis is a really useful trick, so remember it if you need to convert your own code to XLA!\n\n#### XLA Rule #3: XLA will need to recompile your model for every different input shape it sees\n\nThis is the big one. What this means is that if your input shapes are very variable, XLA will have to recompile your model over and over, which will create huge performance problems. This commonly arises in NLP models, where input texts have variable lengths after tokenization. In other modalities, static shapes are more common and this rule is much less of a problem.\n\nHow can you get around rule #3? The key is **padding** - if you pad all your inputs to the same length, and then use an `attention_mask`, you can get the same results as you\u2019d get from variable shapes, but without any XLA issues. However, excessive padding can cause severe slowdown too - if you pad all your samples to the maximum length in the whole dataset, you might end up with batches consisting endless padding tokens, which will waste a lot of compute and memory!\n\nThere isn\u2019t a perfect solution to this problem. However, you can try some tricks. One very useful trick is to **pad batches of samples up to a multiple of a number like 32 or 64 tokens.** This often only increases the number of tokens by a small amount, but it hugely reduces the number of unique input shapes, because every input shape now has to be a multiple of 32 or 64. Fewer unique input shapes means fewer XLA compilations!\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** Our tokenizers and data collators have methods that can help you here. You can use `padding=\"max_length\"` or `padding=\"longest\"` when calling tokenizers to get them to output padded data. Our tokenizers and data collators also have a `pad_to_multiple_of` argument that you can use to reduce the number of unique input shapes you see!\n\n</Tip>\n\n### How do I actually train my model on TPU?\n\nOnce your training is XLA-compatible and (if you\u2019re using TPU Node / Colab) your dataset has been prepared appropriately, running on TPU is surprisingly easy! All you really need to change in your code is to add a few lines to initialize your TPU, and to ensure that your model and dataset are created inside a `TPUStrategy` scope. Take a look at [our TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) to see this in action!\n\n### Summary\n\nThere was a lot in here, so let\u2019s summarize with a quick checklist you can follow when you want to get your model ready for TPU training:\n\n- Make sure your code follows the three rules of XLA\n- Compile your model with `jit_compile=True` on CPU/GPU and confirm that you can train it with XLA\n- Either load your dataset into memory or use a TPU-compatible dataset loading approach (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Migrate your code either to Colab (with accelerator set to \u201cTPU\u201d) or a TPU VM on Google Cloud\n- Add TPU initializer code (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Create your `TPUStrategy` and make sure dataset loading and model creation are inside the `strategy.scope()` (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Don\u2019t forget to take `jit_compile=True` out again when you move to TPU!\n- \ud83d\ude4f\ud83d\ude4f\ud83d\ude4f\ud83e\udd7a\ud83e\udd7a\ud83e\udd7a\n- Call model.fit()\n- You did it!"
            },
            {
                "score": 0.7750322038112106,
                "node_text": "Here are some facts extracted from the provided text:\n\nGoogle -> Designed -> Tpu\n\n!--Copyright 2023 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\nthe License. You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under the License is distributed on\nan \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n\n\u26a0\ufe0f Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be\nrendered properly in your Markdown viewer.\n\n-->\n\n# Training on TPU with TensorFlow\n\n<Tip>\n\nIf you don't need long explanations and just want TPU code samples to get started with, check out [our TPU example notebook!](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb)\n\n</Tip>\n\n### What is a TPU?\n\nA TPU is a **Tensor Processing Unit.** They are hardware designed by Google, which are used to greatly speed up the tensor computations within neural networks, much like GPUs. They can be used for both network training and inference. They are generally accessed through Google\u2019s cloud services, but small TPUs can also be accessed directly for free through Google Colab and Kaggle Kernels.\n\nBecause [all TensorFlow models in \ud83e\udd17 Transformers are Keras models](https://huggingface.co/blog/tensorflow-philosophy), most of the methods in this document are generally applicable to TPU training for any Keras model! However, there are a few points that are specific to the HuggingFace ecosystem (hug-o-system?) of Transformers and Datasets, and we\u2019ll make sure to flag them up when we get to them.\n\n### What kinds of TPU are available?\n\nNew users are often very confused by the range of TPUs, and the different ways to access them. The first key distinction to understand is the difference between **TPU Nodes** and **TPU VMs.**\n\nWhen you use a **TPU Node**, you are effectively indirectly accessing a remote TPU. You will need a separate VM, which will initialize your network and data pipeline and then forward them to the remote node. When you use a TPU on Google Colab, you are accessing it in the **TPU Node** style.\n\nUsing TPU Nodes can have some quite unexpected behaviour for people who aren\u2019t used to them! In particular, because the TPU is located on a physically different system to the machine you\u2019re running your Python code on, your data cannot be local to your machine - any data pipeline that loads from your machine\u2019s internal storage will totally fail! Instead, data must be stored in Google Cloud Storage where your data pipeline can still access it, even when the pipeline is running on the remote TPU node.\n\n<Tip>\n\nIf you can fit all your data in memory as `np.ndarray` or `tf.Tensor`, then you can `fit()` on that data even when using Colab or a TPU Node, without needing to upload it to Google Cloud Storage.\n\n</Tip>\n\n<Tip>\n\n**\ud83e\udd17Specific Hugging Face Tip\ud83e\udd17:** The methods `Dataset.to_tf_dataset()` and its higher-level wrapper `model.prepare_tf_dataset()` , which you will see throughout our TF code examples, will both fail on a TPU Node. The reason for this is that even though they create a `tf.data.Dataset` it is not a \u201cpure\u201d `tf.data` pipeline and uses `tf.numpy_function` or `Dataset.from_generator()` to stream data from the underlying HuggingFace `Dataset`. This HuggingFace `Dataset` is backed by data that is on a local disc and which the remote TPU Node will not be able to read.\n\n</Tip>\n\nThe second way to access a TPU is via a **TPU VM.** When using a TPU VM, you connect directly to the machine that the TPU is attached to, much like training on a GPU VM. TPU VMs are generally easier to work with, particularly when it comes to your data pipeline. All of the above warnings do not apply to TPU VMs!\n\nThis is an opinionated document, so here\u2019s our opinion: **Avoid using TPU Node if possible.** It is more confusing and more difficult to debug than TPU VMs. It is also likely to be unsupported in future - Google\u2019s latest TPU, TPUv4, can only be accessed as a TPU VM, which suggests that TPU Nodes are increasingly going to become a \u201clegacy\u201d access method."
            },
            {
                "score": 0.7750322038112106,
                "node_text": "Here are some facts extracted from the provided text:\n\nTpu vm -> Connects to -> Tpu\nTpu node -> Is -> Difficult to debug\nTpu node -> Is -> Confusing\nTpu node -> Is -> Remote tpu\nTpuv4 -> Can be accessed as -> Tpu vm\nTpu vm -> Is -> Machine\nTpu vm -> Is -> Machine with tpu attached\n\n</Tip>\n\nThe second way to access a TPU is via a **TPU VM.** When using a TPU VM, you connect directly to the machine that the TPU is attached to, much like training on a GPU VM. TPU VMs are generally easier to work with, particularly when it comes to your data pipeline. All of the above warnings do not apply to TPU VMs!\n\nThis is an opinionated document, so here\u2019s our opinion: **Avoid using TPU Node if possible.** It is more confusing and more difficult to debug than TPU VMs. It is also likely to be unsupported in future - Google\u2019s latest TPU, TPUv4, can only be accessed as a TPU VM, which suggests that TPU Nodes are increasingly going to become a \u201clegacy\u201d access method. However, we understand that the only free TPU access is on Colab and Kaggle Kernels, which uses TPU Node - so we\u2019ll try to explain how to handle it if you have to! Check the [TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) for code samples that explain this in more detail.\n\n### What sizes of TPU are available?\n\nA single TPU (a v2-8/v3-8/v4-8) runs 8 replicas. TPUs exist in **pods** that can run hundreds or thousands of replicas simultaneously. When you use more than a single TPU but less than a whole pod (for example, a v3-32), your TPU fleet is referred to as a **pod slice.**\n\nWhen you access a free TPU via Colab, you generally get a single v2-8 TPU.\n\n### I keep hearing about this XLA thing. What\u2019s XLA, and how does it relate to TPUs?\n\nXLA is an optimizing compiler, used by both TensorFlow and JAX. In JAX it is the only compiler, whereas in TensorFlow it is optional (but mandatory on TPU!). The easiest way to enable it when training a Keras model is to pass the argument `jit_compile=True` to `model.compile()`. If you don\u2019t get any errors and performance is good, that\u2019s a great sign that you\u2019re ready to move to TPU!\n\nDebugging on TPU is generally a bit harder than on CPU/GPU, so we recommend getting your code running on CPU/GPU with XLA first before trying it on TPU. You don\u2019t have to train for long, of course - just for a few steps to make sure that your model and data pipeline are working like you expect them to.\n\n<Tip>\n\nXLA compiled code is usually faster - so even if you\u2019re not planning to run on TPU, adding `jit_compile=True` can improve your performance. Be sure to note the caveats below about XLA compatibility, though!\n\n</Tip>\n\n<Tip warning={true}>\n\n**Tip born of painful experience:** Although using `jit_compile=True` is a good way to get a speed boost and test if your CPU/GPU code is XLA-compatible, it can actually cause a lot of problems if you leave it in when actually training on TPU. XLA compilation will happen implicitly on TPU, so remember to remove that line before actually running your code on a TPU!\n\n</Tip>\n\n### How do I make my model XLA compatible?\n\nIn many cases, your code is probably XLA-compatible already! However, there are a few things that work in normal TensorFlow that don\u2019t work in XLA. We\u2019ve distilled them into three core rules below:\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** We\u2019ve put a lot of effort into rewriting our TensorFlow models and loss functions to be XLA-compatible. Our models and loss functions generally obey rule #1 and #2 by default, so you can skip over them if you\u2019re using `transformers` models. Don\u2019t forget about these rules when writing your own models and loss functions, though!\n\n</Tip>\n\n#### XLA Rule #1: Your code cannot have \u201cdata-dependent conditionals\u201d\n\nWhat that means is that any `if` statement cannot depend on values inside a `tf.Tensor`. For example, this code block cannot be compiled with XLA!\n\n```python\nif tf.reduce_sum(tensor) > 10:\n    tensor = tensor / 2.0\n```\n\nThis might seem very restrictive at first, but most neural net code doesn\u2019t need to do this."
            }
        ]
    },
    {
        "sample_idx": 39,
        "question": "What are TPUs generally accessed through?",
        "answer": "TPUs are generally accessed through Google\u2019s cloud services.",
        "rag_answer": "TPUs are generally accessed through Google's cloud services.",
        "rag_score": 5,
        "rag_feedback": "The system's response is completely correct, accurate, and factual. It matches the expected answer, stating that TPUs are generally accessed through Google's cloud services.",
        "rag_context": [
            {
                "score": 0.7328297922259412,
                "node_text": "Here are some facts extracted from the provided text:\n\nTpu node -> Is -> Remote tpu\nTpuv4 -> Can be accessed as -> Tpu vm\nTpu vm -> Is -> Machine\nTpu vm -> Is -> Machine with tpu attached\nTpu vm -> Connects to -> Tpu\n\n</Tip>\n\nThe second way to access a TPU is via a **TPU VM.** When using a TPU VM, you connect directly to the machine that the TPU is attached to, much like training on a GPU VM. TPU VMs are generally easier to work with, particularly when it comes to your data pipeline. All of the above warnings do not apply to TPU VMs!\n\nThis is an opinionated document, so here\u2019s our opinion: **Avoid using TPU Node if possible.** It is more confusing and more difficult to debug than TPU VMs. It is also likely to be unsupported in future - Google\u2019s latest TPU, TPUv4, can only be accessed as a TPU VM, which suggests that TPU Nodes are increasingly going to become a \u201clegacy\u201d access method. However, we understand that the only free TPU access is on Colab and Kaggle Kernels, which uses TPU Node - so we\u2019ll try to explain how to handle it if you have to! Check the [TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) for code samples that explain this in more detail.\n\n### What sizes of TPU are available?\n\nA single TPU (a v2-8/v3-8/v4-8) runs 8 replicas. TPUs exist in **pods** that can run hundreds or thousands of replicas simultaneously. When you use more than a single TPU but less than a whole pod (for example, a v3-32), your TPU fleet is referred to as a **pod slice.**\n\nWhen you access a free TPU via Colab, you generally get a single v2-8 TPU.\n\n### I keep hearing about this XLA thing. What\u2019s XLA, and how does it relate to TPUs?\n\nXLA is an optimizing compiler, used by both TensorFlow and JAX. In JAX it is the only compiler, whereas in TensorFlow it is optional (but mandatory on TPU!). The easiest way to enable it when training a Keras model is to pass the argument `jit_compile=True` to `model.compile()`. If you don\u2019t get any errors and performance is good, that\u2019s a great sign that you\u2019re ready to move to TPU!\n\nDebugging on TPU is generally a bit harder than on CPU/GPU, so we recommend getting your code running on CPU/GPU with XLA first before trying it on TPU. You don\u2019t have to train for long, of course - just for a few steps to make sure that your model and data pipeline are working like you expect them to.\n\n<Tip>\n\nXLA compiled code is usually faster - so even if you\u2019re not planning to run on TPU, adding `jit_compile=True` can improve your performance. Be sure to note the caveats below about XLA compatibility, though!\n\n</Tip>\n\n<Tip warning={true}>\n\n**Tip born of painful experience:** Although using `jit_compile=True` is a good way to get a speed boost and test if your CPU/GPU code is XLA-compatible, it can actually cause a lot of problems if you leave it in when actually training on TPU. XLA compilation will happen implicitly on TPU, so remember to remove that line before actually running your code on a TPU!\n\n</Tip>\n\n### How do I make my model XLA compatible?\n\nIn many cases, your code is probably XLA-compatible already! However, there are a few things that work in normal TensorFlow that don\u2019t work in XLA. We\u2019ve distilled them into three core rules below:\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** We\u2019ve put a lot of effort into rewriting our TensorFlow models and loss functions to be XLA-compatible. Our models and loss functions generally obey rule #1 and #2 by default, so you can skip over them if you\u2019re using `transformers` models. Don\u2019t forget about these rules when writing your own models and loss functions, though!\n\n</Tip>\n\n#### XLA Rule #1: Your code cannot have \u201cdata-dependent conditionals\u201d\n\nWhat that means is that any `if` statement cannot depend on values inside a `tf.Tensor`. For example, this code block cannot be compiled with XLA!\n\n```python\nif tf.reduce_sum(tensor) > 10:\n    tensor = tensor / 2.0\n```\n\nThis might seem very restrictive at first, but most neural net code doesn\u2019t need to do this."
            },
            {
                "score": 0.6454837021034087,
                "node_text": "Here are some facts extracted from the provided text:\n\nTpu -> Is used -> For training\nXla -> Is mandatory on -> Tpu\nTpu -> Accessed through -> Google's cloud services\nTpu -> Is -> Tensor processing unit\nTpu -> Used for -> Neural networks\nTpu -> Exists in -> Pods\n\nThis is a really useful trick, so remember it if you need to convert your own code to XLA!\n\n#### XLA Rule #3: XLA will need to recompile your model for every different input shape it sees\n\nThis is the big one. What this means is that if your input shapes are very variable, XLA will have to recompile your model over and over, which will create huge performance problems. This commonly arises in NLP models, where input texts have variable lengths after tokenization. In other modalities, static shapes are more common and this rule is much less of a problem.\n\nHow can you get around rule #3? The key is **padding** - if you pad all your inputs to the same length, and then use an `attention_mask`, you can get the same results as you\u2019d get from variable shapes, but without any XLA issues. However, excessive padding can cause severe slowdown too - if you pad all your samples to the maximum length in the whole dataset, you might end up with batches consisting endless padding tokens, which will waste a lot of compute and memory!\n\nThere isn\u2019t a perfect solution to this problem. However, you can try some tricks. One very useful trick is to **pad batches of samples up to a multiple of a number like 32 or 64 tokens.** This often only increases the number of tokens by a small amount, but it hugely reduces the number of unique input shapes, because every input shape now has to be a multiple of 32 or 64. Fewer unique input shapes means fewer XLA compilations!\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** Our tokenizers and data collators have methods that can help you here. You can use `padding=\"max_length\"` or `padding=\"longest\"` when calling tokenizers to get them to output padded data. Our tokenizers and data collators also have a `pad_to_multiple_of` argument that you can use to reduce the number of unique input shapes you see!\n\n</Tip>\n\n### How do I actually train my model on TPU?\n\nOnce your training is XLA-compatible and (if you\u2019re using TPU Node / Colab) your dataset has been prepared appropriately, running on TPU is surprisingly easy! All you really need to change in your code is to add a few lines to initialize your TPU, and to ensure that your model and dataset are created inside a `TPUStrategy` scope. Take a look at [our TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) to see this in action!\n\n### Summary\n\nThere was a lot in here, so let\u2019s summarize with a quick checklist you can follow when you want to get your model ready for TPU training:\n\n- Make sure your code follows the three rules of XLA\n- Compile your model with `jit_compile=True` on CPU/GPU and confirm that you can train it with XLA\n- Either load your dataset into memory or use a TPU-compatible dataset loading approach (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Migrate your code either to Colab (with accelerator set to \u201cTPU\u201d) or a TPU VM on Google Cloud\n- Add TPU initializer code (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Create your `TPUStrategy` and make sure dataset loading and model creation are inside the `strategy.scope()` (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Don\u2019t forget to take `jit_compile=True` out again when you move to TPU!\n- \ud83d\ude4f\ud83d\ude4f\ud83d\ude4f\ud83e\udd7a\ud83e\udd7a\ud83e\udd7a\n- Call model.fit()\n- You did it!"
            },
            {
                "score": 0.6454837021034087,
                "node_text": "Here are some facts extracted from the provided text:\n\nGoogle -> Designed -> Tpu\n\n!--Copyright 2023 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\nthe License. You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under the License is distributed on\nan \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n\n\u26a0\ufe0f Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be\nrendered properly in your Markdown viewer.\n\n-->\n\n# Training on TPU with TensorFlow\n\n<Tip>\n\nIf you don't need long explanations and just want TPU code samples to get started with, check out [our TPU example notebook!](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb)\n\n</Tip>\n\n### What is a TPU?\n\nA TPU is a **Tensor Processing Unit.** They are hardware designed by Google, which are used to greatly speed up the tensor computations within neural networks, much like GPUs. They can be used for both network training and inference. They are generally accessed through Google\u2019s cloud services, but small TPUs can also be accessed directly for free through Google Colab and Kaggle Kernels.\n\nBecause [all TensorFlow models in \ud83e\udd17 Transformers are Keras models](https://huggingface.co/blog/tensorflow-philosophy), most of the methods in this document are generally applicable to TPU training for any Keras model! However, there are a few points that are specific to the HuggingFace ecosystem (hug-o-system?) of Transformers and Datasets, and we\u2019ll make sure to flag them up when we get to them.\n\n### What kinds of TPU are available?\n\nNew users are often very confused by the range of TPUs, and the different ways to access them. The first key distinction to understand is the difference between **TPU Nodes** and **TPU VMs.**\n\nWhen you use a **TPU Node**, you are effectively indirectly accessing a remote TPU. You will need a separate VM, which will initialize your network and data pipeline and then forward them to the remote node. When you use a TPU on Google Colab, you are accessing it in the **TPU Node** style.\n\nUsing TPU Nodes can have some quite unexpected behaviour for people who aren\u2019t used to them! In particular, because the TPU is located on a physically different system to the machine you\u2019re running your Python code on, your data cannot be local to your machine - any data pipeline that loads from your machine\u2019s internal storage will totally fail! Instead, data must be stored in Google Cloud Storage where your data pipeline can still access it, even when the pipeline is running on the remote TPU node.\n\n<Tip>\n\nIf you can fit all your data in memory as `np.ndarray` or `tf.Tensor`, then you can `fit()` on that data even when using Colab or a TPU Node, without needing to upload it to Google Cloud Storage.\n\n</Tip>\n\n<Tip>\n\n**\ud83e\udd17Specific Hugging Face Tip\ud83e\udd17:** The methods `Dataset.to_tf_dataset()` and its higher-level wrapper `model.prepare_tf_dataset()` , which you will see throughout our TF code examples, will both fail on a TPU Node. The reason for this is that even though they create a `tf.data.Dataset` it is not a \u201cpure\u201d `tf.data` pipeline and uses `tf.numpy_function` or `Dataset.from_generator()` to stream data from the underlying HuggingFace `Dataset`. This HuggingFace `Dataset` is backed by data that is on a local disc and which the remote TPU Node will not be able to read.\n\n</Tip>\n\nThe second way to access a TPU is via a **TPU VM.** When using a TPU VM, you connect directly to the machine that the TPU is attached to, much like training on a GPU VM. TPU VMs are generally easier to work with, particularly when it comes to your data pipeline. All of the above warnings do not apply to TPU VMs!\n\nThis is an opinionated document, so here\u2019s our opinion: **Avoid using TPU Node if possible.** It is more confusing and more difficult to debug than TPU VMs. It is also likely to be unsupported in future - Google\u2019s latest TPU, TPUv4, can only be accessed as a TPU VM, which suggests that TPU Nodes are increasingly going to become a \u201clegacy\u201d access method."
            }
        ]
    },
    {
        "sample_idx": 40,
        "question": "Where can small TPUs be accessed directly for free?",
        "answer": "Small TPUs can also be accessed directly for free through Google Colab and Kaggle Kernels.",
        "rag_answer": "Small TPUs can be accessed directly for free through Google Colab and Kaggle Kernels.",
        "rag_score": 5,
        "rag_feedback": "The system's response is completely correct, accurate, and factual. It matches the expected answer and provides additional relevant information about TPUs and how to access them.",
        "rag_context": [
            {
                "score": 0.6627129723199505,
                "node_text": "Here are some facts extracted from the provided text:\n\nTpu node -> Is -> Remote tpu\nTpuv4 -> Can be accessed as -> Tpu vm\nTpu vm -> Is -> Machine\nTpu vm -> Is -> Machine with tpu attached\nTpu vm -> Connects to -> Tpu\n\n</Tip>\n\nThe second way to access a TPU is via a **TPU VM.** When using a TPU VM, you connect directly to the machine that the TPU is attached to, much like training on a GPU VM. TPU VMs are generally easier to work with, particularly when it comes to your data pipeline. All of the above warnings do not apply to TPU VMs!\n\nThis is an opinionated document, so here\u2019s our opinion: **Avoid using TPU Node if possible.** It is more confusing and more difficult to debug than TPU VMs. It is also likely to be unsupported in future - Google\u2019s latest TPU, TPUv4, can only be accessed as a TPU VM, which suggests that TPU Nodes are increasingly going to become a \u201clegacy\u201d access method. However, we understand that the only free TPU access is on Colab and Kaggle Kernels, which uses TPU Node - so we\u2019ll try to explain how to handle it if you have to! Check the [TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) for code samples that explain this in more detail.\n\n### What sizes of TPU are available?\n\nA single TPU (a v2-8/v3-8/v4-8) runs 8 replicas. TPUs exist in **pods** that can run hundreds or thousands of replicas simultaneously. When you use more than a single TPU but less than a whole pod (for example, a v3-32), your TPU fleet is referred to as a **pod slice.**\n\nWhen you access a free TPU via Colab, you generally get a single v2-8 TPU.\n\n### I keep hearing about this XLA thing. What\u2019s XLA, and how does it relate to TPUs?\n\nXLA is an optimizing compiler, used by both TensorFlow and JAX. In JAX it is the only compiler, whereas in TensorFlow it is optional (but mandatory on TPU!). The easiest way to enable it when training a Keras model is to pass the argument `jit_compile=True` to `model.compile()`. If you don\u2019t get any errors and performance is good, that\u2019s a great sign that you\u2019re ready to move to TPU!\n\nDebugging on TPU is generally a bit harder than on CPU/GPU, so we recommend getting your code running on CPU/GPU with XLA first before trying it on TPU. You don\u2019t have to train for long, of course - just for a few steps to make sure that your model and data pipeline are working like you expect them to.\n\n<Tip>\n\nXLA compiled code is usually faster - so even if you\u2019re not planning to run on TPU, adding `jit_compile=True` can improve your performance. Be sure to note the caveats below about XLA compatibility, though!\n\n</Tip>\n\n<Tip warning={true}>\n\n**Tip born of painful experience:** Although using `jit_compile=True` is a good way to get a speed boost and test if your CPU/GPU code is XLA-compatible, it can actually cause a lot of problems if you leave it in when actually training on TPU. XLA compilation will happen implicitly on TPU, so remember to remove that line before actually running your code on a TPU!\n\n</Tip>\n\n### How do I make my model XLA compatible?\n\nIn many cases, your code is probably XLA-compatible already! However, there are a few things that work in normal TensorFlow that don\u2019t work in XLA. We\u2019ve distilled them into three core rules below:\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** We\u2019ve put a lot of effort into rewriting our TensorFlow models and loss functions to be XLA-compatible. Our models and loss functions generally obey rule #1 and #2 by default, so you can skip over them if you\u2019re using `transformers` models. Don\u2019t forget about these rules when writing your own models and loss functions, though!\n\n</Tip>\n\n#### XLA Rule #1: Your code cannot have \u201cdata-dependent conditionals\u201d\n\nWhat that means is that any `if` statement cannot depend on values inside a `tf.Tensor`. For example, this code block cannot be compiled with XLA!\n\n```python\nif tf.reduce_sum(tensor) > 10:\n    tensor = tensor / 2.0\n```\n\nThis might seem very restrictive at first, but most neural net code doesn\u2019t need to do this."
            },
            {
                "score": 0.5826523645364383,
                "node_text": "Here are some facts extracted from the provided text:\n\nTpu -> Is used -> For training\nXla -> Is mandatory on -> Tpu\nTpu -> Accessed through -> Google's cloud services\nTpu -> Is -> Tensor processing unit\nTpu -> Used for -> Neural networks\nTpu -> Exists in -> Pods\n\nThis is a really useful trick, so remember it if you need to convert your own code to XLA!\n\n#### XLA Rule #3: XLA will need to recompile your model for every different input shape it sees\n\nThis is the big one. What this means is that if your input shapes are very variable, XLA will have to recompile your model over and over, which will create huge performance problems. This commonly arises in NLP models, where input texts have variable lengths after tokenization. In other modalities, static shapes are more common and this rule is much less of a problem.\n\nHow can you get around rule #3? The key is **padding** - if you pad all your inputs to the same length, and then use an `attention_mask`, you can get the same results as you\u2019d get from variable shapes, but without any XLA issues. However, excessive padding can cause severe slowdown too - if you pad all your samples to the maximum length in the whole dataset, you might end up with batches consisting endless padding tokens, which will waste a lot of compute and memory!\n\nThere isn\u2019t a perfect solution to this problem. However, you can try some tricks. One very useful trick is to **pad batches of samples up to a multiple of a number like 32 or 64 tokens.** This often only increases the number of tokens by a small amount, but it hugely reduces the number of unique input shapes, because every input shape now has to be a multiple of 32 or 64. Fewer unique input shapes means fewer XLA compilations!\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** Our tokenizers and data collators have methods that can help you here. You can use `padding=\"max_length\"` or `padding=\"longest\"` when calling tokenizers to get them to output padded data. Our tokenizers and data collators also have a `pad_to_multiple_of` argument that you can use to reduce the number of unique input shapes you see!\n\n</Tip>\n\n### How do I actually train my model on TPU?\n\nOnce your training is XLA-compatible and (if you\u2019re using TPU Node / Colab) your dataset has been prepared appropriately, running on TPU is surprisingly easy! All you really need to change in your code is to add a few lines to initialize your TPU, and to ensure that your model and dataset are created inside a `TPUStrategy` scope. Take a look at [our TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) to see this in action!\n\n### Summary\n\nThere was a lot in here, so let\u2019s summarize with a quick checklist you can follow when you want to get your model ready for TPU training:\n\n- Make sure your code follows the three rules of XLA\n- Compile your model with `jit_compile=True` on CPU/GPU and confirm that you can train it with XLA\n- Either load your dataset into memory or use a TPU-compatible dataset loading approach (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Migrate your code either to Colab (with accelerator set to \u201cTPU\u201d) or a TPU VM on Google Cloud\n- Add TPU initializer code (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Create your `TPUStrategy` and make sure dataset loading and model creation are inside the `strategy.scope()` (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Don\u2019t forget to take `jit_compile=True` out again when you move to TPU!\n- \ud83d\ude4f\ud83d\ude4f\ud83d\ude4f\ud83e\udd7a\ud83e\udd7a\ud83e\udd7a\n- Call model.fit()\n- You did it!"
            },
            {
                "score": 0.5826523645364383,
                "node_text": "Here are some facts extracted from the provided text:\n\nGoogle -> Designed -> Tpu\n\n!--Copyright 2023 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\nthe License. You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under the License is distributed on\nan \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n\n\u26a0\ufe0f Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be\nrendered properly in your Markdown viewer.\n\n-->\n\n# Training on TPU with TensorFlow\n\n<Tip>\n\nIf you don't need long explanations and just want TPU code samples to get started with, check out [our TPU example notebook!](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb)\n\n</Tip>\n\n### What is a TPU?\n\nA TPU is a **Tensor Processing Unit.** They are hardware designed by Google, which are used to greatly speed up the tensor computations within neural networks, much like GPUs. They can be used for both network training and inference. They are generally accessed through Google\u2019s cloud services, but small TPUs can also be accessed directly for free through Google Colab and Kaggle Kernels.\n\nBecause [all TensorFlow models in \ud83e\udd17 Transformers are Keras models](https://huggingface.co/blog/tensorflow-philosophy), most of the methods in this document are generally applicable to TPU training for any Keras model! However, there are a few points that are specific to the HuggingFace ecosystem (hug-o-system?) of Transformers and Datasets, and we\u2019ll make sure to flag them up when we get to them.\n\n### What kinds of TPU are available?\n\nNew users are often very confused by the range of TPUs, and the different ways to access them. The first key distinction to understand is the difference between **TPU Nodes** and **TPU VMs.**\n\nWhen you use a **TPU Node**, you are effectively indirectly accessing a remote TPU. You will need a separate VM, which will initialize your network and data pipeline and then forward them to the remote node. When you use a TPU on Google Colab, you are accessing it in the **TPU Node** style.\n\nUsing TPU Nodes can have some quite unexpected behaviour for people who aren\u2019t used to them! In particular, because the TPU is located on a physically different system to the machine you\u2019re running your Python code on, your data cannot be local to your machine - any data pipeline that loads from your machine\u2019s internal storage will totally fail! Instead, data must be stored in Google Cloud Storage where your data pipeline can still access it, even when the pipeline is running on the remote TPU node.\n\n<Tip>\n\nIf you can fit all your data in memory as `np.ndarray` or `tf.Tensor`, then you can `fit()` on that data even when using Colab or a TPU Node, without needing to upload it to Google Cloud Storage.\n\n</Tip>\n\n<Tip>\n\n**\ud83e\udd17Specific Hugging Face Tip\ud83e\udd17:** The methods `Dataset.to_tf_dataset()` and its higher-level wrapper `model.prepare_tf_dataset()` , which you will see throughout our TF code examples, will both fail on a TPU Node. The reason for this is that even though they create a `tf.data.Dataset` it is not a \u201cpure\u201d `tf.data` pipeline and uses `tf.numpy_function` or `Dataset.from_generator()` to stream data from the underlying HuggingFace `Dataset`. This HuggingFace `Dataset` is backed by data that is on a local disc and which the remote TPU Node will not be able to read.\n\n</Tip>\n\nThe second way to access a TPU is via a **TPU VM.** When using a TPU VM, you connect directly to the machine that the TPU is attached to, much like training on a GPU VM. TPU VMs are generally easier to work with, particularly when it comes to your data pipeline. All of the above warnings do not apply to TPU VMs!\n\nThis is an opinionated document, so here\u2019s our opinion: **Avoid using TPU Node if possible.** It is more confusing and more difficult to debug than TPU VMs. It is also likely to be unsupported in future - Google\u2019s latest TPU, TPUv4, can only be accessed as a TPU VM, which suggests that TPU Nodes are increasingly going to become a \u201clegacy\u201d access method."
            }
        ]
    },
    {
        "sample_idx": 41,
        "question": "What kind of models are all TensorFlow models in \ud83e\udd17 Transformers?",
        "answer": "All TensorFlow models in \ud83e\udd17 Transformers are Keras models.",
        "rag_answer": "All TensorFlow models in \ud83e\udd17 Transformers are Keras models.",
        "rag_score": 5,
        "rag_feedback": "The system's response is completely correct, accurate, and factual. It directly answers the question by stating that all TensorFlow models in \ud83e\udd17 Transformers are Keras models, which matches the expected answer.",
        "rag_context": [
            {
                "score": 1.0,
                "node_text": "Here are some facts extracted from the provided text:\n\nTpu -> Used for -> Neural networks\nNlp models -> Have -> Variable lengths\n\nThis is a really useful trick, so remember it if you need to convert your own code to XLA!\n\n#### XLA Rule #3: XLA will need to recompile your model for every different input shape it sees\n\nThis is the big one. What this means is that if your input shapes are very variable, XLA will have to recompile your model over and over, which will create huge performance problems. This commonly arises in NLP models, where input texts have variable lengths after tokenization. In other modalities, static shapes are more common and this rule is much less of a problem.\n\nHow can you get around rule #3? The key is **padding** - if you pad all your inputs to the same length, and then use an `attention_mask`, you can get the same results as you\u2019d get from variable shapes, but without any XLA issues. However, excessive padding can cause severe slowdown too - if you pad all your samples to the maximum length in the whole dataset, you might end up with batches consisting endless padding tokens, which will waste a lot of compute and memory!\n\nThere isn\u2019t a perfect solution to this problem. However, you can try some tricks. One very useful trick is to **pad batches of samples up to a multiple of a number like 32 or 64 tokens.** This often only increases the number of tokens by a small amount, but it hugely reduces the number of unique input shapes, because every input shape now has to be a multiple of 32 or 64. Fewer unique input shapes means fewer XLA compilations!\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** Our tokenizers and data collators have methods that can help you here. You can use `padding=\"max_length\"` or `padding=\"longest\"` when calling tokenizers to get them to output padded data. Our tokenizers and data collators also have a `pad_to_multiple_of` argument that you can use to reduce the number of unique input shapes you see!\n\n</Tip>\n\n### How do I actually train my model on TPU?\n\nOnce your training is XLA-compatible and (if you\u2019re using TPU Node / Colab) your dataset has been prepared appropriately, running on TPU is surprisingly easy! All you really need to change in your code is to add a few lines to initialize your TPU, and to ensure that your model and dataset are created inside a `TPUStrategy` scope. Take a look at [our TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) to see this in action!\n\n### Summary\n\nThere was a lot in here, so let\u2019s summarize with a quick checklist you can follow when you want to get your model ready for TPU training:\n\n- Make sure your code follows the three rules of XLA\n- Compile your model with `jit_compile=True` on CPU/GPU and confirm that you can train it with XLA\n- Either load your dataset into memory or use a TPU-compatible dataset loading approach (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Migrate your code either to Colab (with accelerator set to \u201cTPU\u201d) or a TPU VM on Google Cloud\n- Add TPU initializer code (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Create your `TPUStrategy` and make sure dataset loading and model creation are inside the `strategy.scope()` (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Don\u2019t forget to take `jit_compile=True` out again when you move to TPU!\n- \ud83d\ude4f\ud83d\ude4f\ud83d\ude4f\ud83e\udd7a\ud83e\udd7a\ud83e\udd7a\n- Call model.fit()\n- You did it!"
            },
            {
                "score": 0.7063994053587234,
                "node_text": "Here are some facts extracted from the provided text:\n\nTensorflow models -> Are -> Keras models\nHuggingface ecosystem -> Includes -> Transformers and datasets\n\n!--Copyright 2023 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\nthe License. You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under the License is distributed on\nan \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n\n\u26a0\ufe0f Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be\nrendered properly in your Markdown viewer.\n\n-->\n\n# Training on TPU with TensorFlow\n\n<Tip>\n\nIf you don't need long explanations and just want TPU code samples to get started with, check out [our TPU example notebook!](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb)\n\n</Tip>\n\n### What is a TPU?\n\nA TPU is a **Tensor Processing Unit.** They are hardware designed by Google, which are used to greatly speed up the tensor computations within neural networks, much like GPUs. They can be used for both network training and inference. They are generally accessed through Google\u2019s cloud services, but small TPUs can also be accessed directly for free through Google Colab and Kaggle Kernels.\n\nBecause [all TensorFlow models in \ud83e\udd17 Transformers are Keras models](https://huggingface.co/blog/tensorflow-philosophy), most of the methods in this document are generally applicable to TPU training for any Keras model! However, there are a few points that are specific to the HuggingFace ecosystem (hug-o-system?) of Transformers and Datasets, and we\u2019ll make sure to flag them up when we get to them.\n\n### What kinds of TPU are available?\n\nNew users are often very confused by the range of TPUs, and the different ways to access them. The first key distinction to understand is the difference between **TPU Nodes** and **TPU VMs.**\n\nWhen you use a **TPU Node**, you are effectively indirectly accessing a remote TPU. You will need a separate VM, which will initialize your network and data pipeline and then forward them to the remote node. When you use a TPU on Google Colab, you are accessing it in the **TPU Node** style.\n\nUsing TPU Nodes can have some quite unexpected behaviour for people who aren\u2019t used to them! In particular, because the TPU is located on a physically different system to the machine you\u2019re running your Python code on, your data cannot be local to your machine - any data pipeline that loads from your machine\u2019s internal storage will totally fail! Instead, data must be stored in Google Cloud Storage where your data pipeline can still access it, even when the pipeline is running on the remote TPU node.\n\n<Tip>\n\nIf you can fit all your data in memory as `np.ndarray` or `tf.Tensor`, then you can `fit()` on that data even when using Colab or a TPU Node, without needing to upload it to Google Cloud Storage.\n\n</Tip>\n\n<Tip>\n\n**\ud83e\udd17Specific Hugging Face Tip\ud83e\udd17:** The methods `Dataset.to_tf_dataset()` and its higher-level wrapper `model.prepare_tf_dataset()` , which you will see throughout our TF code examples, will both fail on a TPU Node. The reason for this is that even though they create a `tf.data.Dataset` it is not a \u201cpure\u201d `tf.data` pipeline and uses `tf.numpy_function` or `Dataset.from_generator()` to stream data from the underlying HuggingFace `Dataset`. This HuggingFace `Dataset` is backed by data that is on a local disc and which the remote TPU Node will not be able to read.\n\n</Tip>\n\nThe second way to access a TPU is via a **TPU VM.** When using a TPU VM, you connect directly to the machine that the TPU is attached to, much like training on a GPU VM. TPU VMs are generally easier to work with, particularly when it comes to your data pipeline. All of the above warnings do not apply to TPU VMs!\n\nThis is an opinionated document, so here\u2019s our opinion: **Avoid using TPU Node if possible.** It is more confusing and more difficult to debug than TPU VMs. It is also likely to be unsupported in future - Google\u2019s latest TPU, TPUv4, can only be accessed as a TPU VM, which suggests that TPU Nodes are increasingly going to become a \u201clegacy\u201d access method."
            },
            {
                "score": 0.6515935937647118,
                "node_text": "Here are some facts extracted from the provided text:\n\nXla -> Is used by -> Tensorflow and jax\nNlp models -> Have -> Variable lengths\n\nThis is a really useful trick, so remember it if you need to convert your own code to XLA!\n\n#### XLA Rule #3: XLA will need to recompile your model for every different input shape it sees\n\nThis is the big one. What this means is that if your input shapes are very variable, XLA will have to recompile your model over and over, which will create huge performance problems. This commonly arises in NLP models, where input texts have variable lengths after tokenization. In other modalities, static shapes are more common and this rule is much less of a problem.\n\nHow can you get around rule #3? The key is **padding** - if you pad all your inputs to the same length, and then use an `attention_mask`, you can get the same results as you\u2019d get from variable shapes, but without any XLA issues. However, excessive padding can cause severe slowdown too - if you pad all your samples to the maximum length in the whole dataset, you might end up with batches consisting endless padding tokens, which will waste a lot of compute and memory!\n\nThere isn\u2019t a perfect solution to this problem. However, you can try some tricks. One very useful trick is to **pad batches of samples up to a multiple of a number like 32 or 64 tokens.** This often only increases the number of tokens by a small amount, but it hugely reduces the number of unique input shapes, because every input shape now has to be a multiple of 32 or 64. Fewer unique input shapes means fewer XLA compilations!\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** Our tokenizers and data collators have methods that can help you here. You can use `padding=\"max_length\"` or `padding=\"longest\"` when calling tokenizers to get them to output padded data. Our tokenizers and data collators also have a `pad_to_multiple_of` argument that you can use to reduce the number of unique input shapes you see!\n\n</Tip>\n\n### How do I actually train my model on TPU?\n\nOnce your training is XLA-compatible and (if you\u2019re using TPU Node / Colab) your dataset has been prepared appropriately, running on TPU is surprisingly easy! All you really need to change in your code is to add a few lines to initialize your TPU, and to ensure that your model and dataset are created inside a `TPUStrategy` scope. Take a look at [our TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) to see this in action!\n\n### Summary\n\nThere was a lot in here, so let\u2019s summarize with a quick checklist you can follow when you want to get your model ready for TPU training:\n\n- Make sure your code follows the three rules of XLA\n- Compile your model with `jit_compile=True` on CPU/GPU and confirm that you can train it with XLA\n- Either load your dataset into memory or use a TPU-compatible dataset loading approach (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Migrate your code either to Colab (with accelerator set to \u201cTPU\u201d) or a TPU VM on Google Cloud\n- Add TPU initializer code (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Create your `TPUStrategy` and make sure dataset loading and model creation are inside the `strategy.scope()` (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Don\u2019t forget to take `jit_compile=True` out again when you move to TPU!\n- \ud83d\ude4f\ud83d\ude4f\ud83d\ude4f\ud83e\udd7a\ud83e\udd7a\ud83e\udd7a\n- Call model.fit()\n- You did it!"
            }
        ]
    },
    {
        "sample_idx": 42,
        "question": "What is the distinction between TPU Nodes and TPU VMs?",
        "answer": "The first key distinction to understand is the difference between TPU Nodes and TPU VMs.",
        "rag_answer": "The distinction between TPU Nodes and TPU VMs lies in how you access the TPU. With a TPU Node, you indirectly access a remote TPU, which requires a separate VM to initialize your network and data pipeline, and then forward them to the remote node. In contrast, a TPU VM allows you to connect directly to the machine that the TPU is attached to, making it easier to work with, especially when it comes to your data pipeline.",
        "rag_score": 5,
        "rag_feedback": "The system's response is completely correct, accurate, and factual. It provides a clear and detailed explanation of the distinction between TPU Nodes and TPU VMs, including how they access the TPU, their differences in terms of data pipeline, and the advantages of using TPU VMs.",
        "rag_context": [
            {
                "score": 1.0,
                "node_text": "Here are some facts extracted from the provided text:\n\nTpu node -> Is -> Difficult to debug\nTpu node -> Is -> Confusing\nTpu node -> Is -> Remote tpu\n\n</Tip>\n\nThe second way to access a TPU is via a **TPU VM.** When using a TPU VM, you connect directly to the machine that the TPU is attached to, much like training on a GPU VM. TPU VMs are generally easier to work with, particularly when it comes to your data pipeline. All of the above warnings do not apply to TPU VMs!\n\nThis is an opinionated document, so here\u2019s our opinion: **Avoid using TPU Node if possible.** It is more confusing and more difficult to debug than TPU VMs. It is also likely to be unsupported in future - Google\u2019s latest TPU, TPUv4, can only be accessed as a TPU VM, which suggests that TPU Nodes are increasingly going to become a \u201clegacy\u201d access method. However, we understand that the only free TPU access is on Colab and Kaggle Kernels, which uses TPU Node - so we\u2019ll try to explain how to handle it if you have to! Check the [TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) for code samples that explain this in more detail.\n\n### What sizes of TPU are available?\n\nA single TPU (a v2-8/v3-8/v4-8) runs 8 replicas. TPUs exist in **pods** that can run hundreds or thousands of replicas simultaneously. When you use more than a single TPU but less than a whole pod (for example, a v3-32), your TPU fleet is referred to as a **pod slice.**\n\nWhen you access a free TPU via Colab, you generally get a single v2-8 TPU.\n\n### I keep hearing about this XLA thing. What\u2019s XLA, and how does it relate to TPUs?\n\nXLA is an optimizing compiler, used by both TensorFlow and JAX. In JAX it is the only compiler, whereas in TensorFlow it is optional (but mandatory on TPU!). The easiest way to enable it when training a Keras model is to pass the argument `jit_compile=True` to `model.compile()`. If you don\u2019t get any errors and performance is good, that\u2019s a great sign that you\u2019re ready to move to TPU!\n\nDebugging on TPU is generally a bit harder than on CPU/GPU, so we recommend getting your code running on CPU/GPU with XLA first before trying it on TPU. You don\u2019t have to train for long, of course - just for a few steps to make sure that your model and data pipeline are working like you expect them to.\n\n<Tip>\n\nXLA compiled code is usually faster - so even if you\u2019re not planning to run on TPU, adding `jit_compile=True` can improve your performance. Be sure to note the caveats below about XLA compatibility, though!\n\n</Tip>\n\n<Tip warning={true}>\n\n**Tip born of painful experience:** Although using `jit_compile=True` is a good way to get a speed boost and test if your CPU/GPU code is XLA-compatible, it can actually cause a lot of problems if you leave it in when actually training on TPU. XLA compilation will happen implicitly on TPU, so remember to remove that line before actually running your code on a TPU!\n\n</Tip>\n\n### How do I make my model XLA compatible?\n\nIn many cases, your code is probably XLA-compatible already! However, there are a few things that work in normal TensorFlow that don\u2019t work in XLA. We\u2019ve distilled them into three core rules below:\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** We\u2019ve put a lot of effort into rewriting our TensorFlow models and loss functions to be XLA-compatible. Our models and loss functions generally obey rule #1 and #2 by default, so you can skip over them if you\u2019re using `transformers` models. Don\u2019t forget about these rules when writing your own models and loss functions, though!\n\n</Tip>\n\n#### XLA Rule #1: Your code cannot have \u201cdata-dependent conditionals\u201d\n\nWhat that means is that any `if` statement cannot depend on values inside a `tf.Tensor`. For example, this code block cannot be compiled with XLA!\n\n```python\nif tf.reduce_sum(tensor) > 10:\n    tensor = tensor / 2.0\n```\n\nThis might seem very restrictive at first, but most neural net code doesn\u2019t need to do this."
            },
            {
                "score": 1.0,
                "node_text": "Here are some facts extracted from the provided text:\n\nTpu -> Is -> Tensor processing unit\n\nThis is a really useful trick, so remember it if you need to convert your own code to XLA!\n\n#### XLA Rule #3: XLA will need to recompile your model for every different input shape it sees\n\nThis is the big one. What this means is that if your input shapes are very variable, XLA will have to recompile your model over and over, which will create huge performance problems. This commonly arises in NLP models, where input texts have variable lengths after tokenization. In other modalities, static shapes are more common and this rule is much less of a problem.\n\nHow can you get around rule #3? The key is **padding** - if you pad all your inputs to the same length, and then use an `attention_mask`, you can get the same results as you\u2019d get from variable shapes, but without any XLA issues. However, excessive padding can cause severe slowdown too - if you pad all your samples to the maximum length in the whole dataset, you might end up with batches consisting endless padding tokens, which will waste a lot of compute and memory!\n\nThere isn\u2019t a perfect solution to this problem. However, you can try some tricks. One very useful trick is to **pad batches of samples up to a multiple of a number like 32 or 64 tokens.** This often only increases the number of tokens by a small amount, but it hugely reduces the number of unique input shapes, because every input shape now has to be a multiple of 32 or 64. Fewer unique input shapes means fewer XLA compilations!\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** Our tokenizers and data collators have methods that can help you here. You can use `padding=\"max_length\"` or `padding=\"longest\"` when calling tokenizers to get them to output padded data. Our tokenizers and data collators also have a `pad_to_multiple_of` argument that you can use to reduce the number of unique input shapes you see!\n\n</Tip>\n\n### How do I actually train my model on TPU?\n\nOnce your training is XLA-compatible and (if you\u2019re using TPU Node / Colab) your dataset has been prepared appropriately, running on TPU is surprisingly easy! All you really need to change in your code is to add a few lines to initialize your TPU, and to ensure that your model and dataset are created inside a `TPUStrategy` scope. Take a look at [our TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) to see this in action!\n\n### Summary\n\nThere was a lot in here, so let\u2019s summarize with a quick checklist you can follow when you want to get your model ready for TPU training:\n\n- Make sure your code follows the three rules of XLA\n- Compile your model with `jit_compile=True` on CPU/GPU and confirm that you can train it with XLA\n- Either load your dataset into memory or use a TPU-compatible dataset loading approach (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Migrate your code either to Colab (with accelerator set to \u201cTPU\u201d) or a TPU VM on Google Cloud\n- Add TPU initializer code (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Create your `TPUStrategy` and make sure dataset loading and model creation are inside the `strategy.scope()` (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Don\u2019t forget to take `jit_compile=True` out again when you move to TPU!\n- \ud83d\ude4f\ud83d\ude4f\ud83d\ude4f\ud83e\udd7a\ud83e\udd7a\ud83e\udd7a\n- Call model.fit()\n- You did it!"
            },
            {
                "score": 0.7910484149761267,
                "node_text": "Here are some facts extracted from the provided text:\n\nTpuv4 -> Can be accessed as -> Tpu vm\nTpu vm -> Is -> Machine\nTpu vm -> Is -> Machine with tpu attached\nTpu vm -> Connects to -> Tpu\nTpu node -> Is -> Difficult to debug\nTpu node -> Is -> Confusing\nTpu node -> Is -> Remote tpu\n\n</Tip>\n\nThe second way to access a TPU is via a **TPU VM.** When using a TPU VM, you connect directly to the machine that the TPU is attached to, much like training on a GPU VM. TPU VMs are generally easier to work with, particularly when it comes to your data pipeline. All of the above warnings do not apply to TPU VMs!\n\nThis is an opinionated document, so here\u2019s our opinion: **Avoid using TPU Node if possible.** It is more confusing and more difficult to debug than TPU VMs. It is also likely to be unsupported in future - Google\u2019s latest TPU, TPUv4, can only be accessed as a TPU VM, which suggests that TPU Nodes are increasingly going to become a \u201clegacy\u201d access method. However, we understand that the only free TPU access is on Colab and Kaggle Kernels, which uses TPU Node - so we\u2019ll try to explain how to handle it if you have to! Check the [TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) for code samples that explain this in more detail.\n\n### What sizes of TPU are available?\n\nA single TPU (a v2-8/v3-8/v4-8) runs 8 replicas. TPUs exist in **pods** that can run hundreds or thousands of replicas simultaneously. When you use more than a single TPU but less than a whole pod (for example, a v3-32), your TPU fleet is referred to as a **pod slice.**\n\nWhen you access a free TPU via Colab, you generally get a single v2-8 TPU.\n\n### I keep hearing about this XLA thing. What\u2019s XLA, and how does it relate to TPUs?\n\nXLA is an optimizing compiler, used by both TensorFlow and JAX. In JAX it is the only compiler, whereas in TensorFlow it is optional (but mandatory on TPU!). The easiest way to enable it when training a Keras model is to pass the argument `jit_compile=True` to `model.compile()`. If you don\u2019t get any errors and performance is good, that\u2019s a great sign that you\u2019re ready to move to TPU!\n\nDebugging on TPU is generally a bit harder than on CPU/GPU, so we recommend getting your code running on CPU/GPU with XLA first before trying it on TPU. You don\u2019t have to train for long, of course - just for a few steps to make sure that your model and data pipeline are working like you expect them to.\n\n<Tip>\n\nXLA compiled code is usually faster - so even if you\u2019re not planning to run on TPU, adding `jit_compile=True` can improve your performance. Be sure to note the caveats below about XLA compatibility, though!\n\n</Tip>\n\n<Tip warning={true}>\n\n**Tip born of painful experience:** Although using `jit_compile=True` is a good way to get a speed boost and test if your CPU/GPU code is XLA-compatible, it can actually cause a lot of problems if you leave it in when actually training on TPU. XLA compilation will happen implicitly on TPU, so remember to remove that line before actually running your code on a TPU!\n\n</Tip>\n\n### How do I make my model XLA compatible?\n\nIn many cases, your code is probably XLA-compatible already! However, there are a few things that work in normal TensorFlow that don\u2019t work in XLA. We\u2019ve distilled them into three core rules below:\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** We\u2019ve put a lot of effort into rewriting our TensorFlow models and loss functions to be XLA-compatible. Our models and loss functions generally obey rule #1 and #2 by default, so you can skip over them if you\u2019re using `transformers` models. Don\u2019t forget about these rules when writing your own models and loss functions, though!\n\n</Tip>\n\n#### XLA Rule #1: Your code cannot have \u201cdata-dependent conditionals\u201d\n\nWhat that means is that any `if` statement cannot depend on values inside a `tf.Tensor`. For example, this code block cannot be compiled with XLA!\n\n```python\nif tf.reduce_sum(tensor) > 10:\n    tensor = tensor / 2.0\n```\n\nThis might seem very restrictive at first, but most neural net code doesn\u2019t need to do this."
            },
            {
                "score": 0.7307908889809468,
                "node_text": "Here are some facts extracted from the provided text:\n\nTpu -> Is used -> For training\nXla -> Is mandatory on -> Tpu\nTpu -> Accessed through -> Google's cloud services\nTpu -> Is -> Tensor processing unit\nTpu -> Used for -> Neural networks\nTpu -> Exists in -> Pods\n\nThis is a really useful trick, so remember it if you need to convert your own code to XLA!\n\n#### XLA Rule #3: XLA will need to recompile your model for every different input shape it sees\n\nThis is the big one. What this means is that if your input shapes are very variable, XLA will have to recompile your model over and over, which will create huge performance problems. This commonly arises in NLP models, where input texts have variable lengths after tokenization. In other modalities, static shapes are more common and this rule is much less of a problem.\n\nHow can you get around rule #3? The key is **padding** - if you pad all your inputs to the same length, and then use an `attention_mask`, you can get the same results as you\u2019d get from variable shapes, but without any XLA issues. However, excessive padding can cause severe slowdown too - if you pad all your samples to the maximum length in the whole dataset, you might end up with batches consisting endless padding tokens, which will waste a lot of compute and memory!\n\nThere isn\u2019t a perfect solution to this problem. However, you can try some tricks. One very useful trick is to **pad batches of samples up to a multiple of a number like 32 or 64 tokens.** This often only increases the number of tokens by a small amount, but it hugely reduces the number of unique input shapes, because every input shape now has to be a multiple of 32 or 64. Fewer unique input shapes means fewer XLA compilations!\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** Our tokenizers and data collators have methods that can help you here. You can use `padding=\"max_length\"` or `padding=\"longest\"` when calling tokenizers to get them to output padded data. Our tokenizers and data collators also have a `pad_to_multiple_of` argument that you can use to reduce the number of unique input shapes you see!\n\n</Tip>\n\n### How do I actually train my model on TPU?\n\nOnce your training is XLA-compatible and (if you\u2019re using TPU Node / Colab) your dataset has been prepared appropriately, running on TPU is surprisingly easy! All you really need to change in your code is to add a few lines to initialize your TPU, and to ensure that your model and dataset are created inside a `TPUStrategy` scope. Take a look at [our TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) to see this in action!\n\n### Summary\n\nThere was a lot in here, so let\u2019s summarize with a quick checklist you can follow when you want to get your model ready for TPU training:\n\n- Make sure your code follows the three rules of XLA\n- Compile your model with `jit_compile=True` on CPU/GPU and confirm that you can train it with XLA\n- Either load your dataset into memory or use a TPU-compatible dataset loading approach (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Migrate your code either to Colab (with accelerator set to \u201cTPU\u201d) or a TPU VM on Google Cloud\n- Add TPU initializer code (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Create your `TPUStrategy` and make sure dataset loading and model creation are inside the `strategy.scope()` (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Don\u2019t forget to take `jit_compile=True` out again when you move to TPU!\n- \ud83d\ude4f\ud83d\ude4f\ud83d\ude4f\ud83e\udd7a\ud83e\udd7a\ud83e\udd7a\n- Call model.fit()\n- You did it!"
            },
            {
                "score": 0.7307908889809468,
                "node_text": "Here are some facts extracted from the provided text:\n\nGoogle -> Designed -> Tpu\n\n!--Copyright 2023 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\nthe License. You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under the License is distributed on\nan \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n\n\u26a0\ufe0f Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be\nrendered properly in your Markdown viewer.\n\n-->\n\n# Training on TPU with TensorFlow\n\n<Tip>\n\nIf you don't need long explanations and just want TPU code samples to get started with, check out [our TPU example notebook!](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb)\n\n</Tip>\n\n### What is a TPU?\n\nA TPU is a **Tensor Processing Unit.** They are hardware designed by Google, which are used to greatly speed up the tensor computations within neural networks, much like GPUs. They can be used for both network training and inference. They are generally accessed through Google\u2019s cloud services, but small TPUs can also be accessed directly for free through Google Colab and Kaggle Kernels.\n\nBecause [all TensorFlow models in \ud83e\udd17 Transformers are Keras models](https://huggingface.co/blog/tensorflow-philosophy), most of the methods in this document are generally applicable to TPU training for any Keras model! However, there are a few points that are specific to the HuggingFace ecosystem (hug-o-system?) of Transformers and Datasets, and we\u2019ll make sure to flag them up when we get to them.\n\n### What kinds of TPU are available?\n\nNew users are often very confused by the range of TPUs, and the different ways to access them. The first key distinction to understand is the difference between **TPU Nodes** and **TPU VMs.**\n\nWhen you use a **TPU Node**, you are effectively indirectly accessing a remote TPU. You will need a separate VM, which will initialize your network and data pipeline and then forward them to the remote node. When you use a TPU on Google Colab, you are accessing it in the **TPU Node** style.\n\nUsing TPU Nodes can have some quite unexpected behaviour for people who aren\u2019t used to them! In particular, because the TPU is located on a physically different system to the machine you\u2019re running your Python code on, your data cannot be local to your machine - any data pipeline that loads from your machine\u2019s internal storage will totally fail! Instead, data must be stored in Google Cloud Storage where your data pipeline can still access it, even when the pipeline is running on the remote TPU node.\n\n<Tip>\n\nIf you can fit all your data in memory as `np.ndarray` or `tf.Tensor`, then you can `fit()` on that data even when using Colab or a TPU Node, without needing to upload it to Google Cloud Storage.\n\n</Tip>\n\n<Tip>\n\n**\ud83e\udd17Specific Hugging Face Tip\ud83e\udd17:** The methods `Dataset.to_tf_dataset()` and its higher-level wrapper `model.prepare_tf_dataset()` , which you will see throughout our TF code examples, will both fail on a TPU Node. The reason for this is that even though they create a `tf.data.Dataset` it is not a \u201cpure\u201d `tf.data` pipeline and uses `tf.numpy_function` or `Dataset.from_generator()` to stream data from the underlying HuggingFace `Dataset`. This HuggingFace `Dataset` is backed by data that is on a local disc and which the remote TPU Node will not be able to read.\n\n</Tip>\n\nThe second way to access a TPU is via a **TPU VM.** When using a TPU VM, you connect directly to the machine that the TPU is attached to, much like training on a GPU VM. TPU VMs are generally easier to work with, particularly when it comes to your data pipeline. All of the above warnings do not apply to TPU VMs!\n\nThis is an opinionated document, so here\u2019s our opinion: **Avoid using TPU Node if possible.** It is more confusing and more difficult to debug than TPU VMs. It is also likely to be unsupported in future - Google\u2019s latest TPU, TPUv4, can only be accessed as a TPU VM, which suggests that TPU Nodes are increasingly going to become a \u201clegacy\u201d access method."
            }
        ]
    },
    {
        "sample_idx": 43,
        "question": "What is the difference between TPU Nodes and TPU VMs?",
        "answer": "TPU Nodes allow indirect access to a remote TPU, requiring a separate VM to initialize the network and data pipeline, whereas TPU VMs are not explained in the passage.",
        "rag_answer": "One very useful trick to reduce the number of unique input shapes is to pad batches of samples up to a multiple of a number like 32 or 64 tokens. This often only increases the number of tokens by a small amount, but it hugely reduces the number of unique input shapes, because every input shape now has to be a multiple of 32 or 64. Fewer unique input shapes means fewer XLA compilations!",
        "rag_score": 1,
        "rag_feedback": "The system's response is completely incorrect, inaccurate, and not factual. It does not address the question about the difference between TPU Nodes and TPU VMs, instead providing a lengthy and unrelated text about XLA compilations and padding batches of samples.",
        "rag_context": [
            {
                "score": 1.0,
                "node_text": "Here are some facts extracted from the provided text:\n\nTpu node -> Is -> Difficult to debug\nTpu node -> Is -> Confusing\nTpu node -> Is -> Remote tpu\n\n</Tip>\n\nThe second way to access a TPU is via a **TPU VM.** When using a TPU VM, you connect directly to the machine that the TPU is attached to, much like training on a GPU VM. TPU VMs are generally easier to work with, particularly when it comes to your data pipeline. All of the above warnings do not apply to TPU VMs!\n\nThis is an opinionated document, so here\u2019s our opinion: **Avoid using TPU Node if possible.** It is more confusing and more difficult to debug than TPU VMs. It is also likely to be unsupported in future - Google\u2019s latest TPU, TPUv4, can only be accessed as a TPU VM, which suggests that TPU Nodes are increasingly going to become a \u201clegacy\u201d access method. However, we understand that the only free TPU access is on Colab and Kaggle Kernels, which uses TPU Node - so we\u2019ll try to explain how to handle it if you have to! Check the [TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) for code samples that explain this in more detail.\n\n### What sizes of TPU are available?\n\nA single TPU (a v2-8/v3-8/v4-8) runs 8 replicas. TPUs exist in **pods** that can run hundreds or thousands of replicas simultaneously. When you use more than a single TPU but less than a whole pod (for example, a v3-32), your TPU fleet is referred to as a **pod slice.**\n\nWhen you access a free TPU via Colab, you generally get a single v2-8 TPU.\n\n### I keep hearing about this XLA thing. What\u2019s XLA, and how does it relate to TPUs?\n\nXLA is an optimizing compiler, used by both TensorFlow and JAX. In JAX it is the only compiler, whereas in TensorFlow it is optional (but mandatory on TPU!). The easiest way to enable it when training a Keras model is to pass the argument `jit_compile=True` to `model.compile()`. If you don\u2019t get any errors and performance is good, that\u2019s a great sign that you\u2019re ready to move to TPU!\n\nDebugging on TPU is generally a bit harder than on CPU/GPU, so we recommend getting your code running on CPU/GPU with XLA first before trying it on TPU. You don\u2019t have to train for long, of course - just for a few steps to make sure that your model and data pipeline are working like you expect them to.\n\n<Tip>\n\nXLA compiled code is usually faster - so even if you\u2019re not planning to run on TPU, adding `jit_compile=True` can improve your performance. Be sure to note the caveats below about XLA compatibility, though!\n\n</Tip>\n\n<Tip warning={true}>\n\n**Tip born of painful experience:** Although using `jit_compile=True` is a good way to get a speed boost and test if your CPU/GPU code is XLA-compatible, it can actually cause a lot of problems if you leave it in when actually training on TPU. XLA compilation will happen implicitly on TPU, so remember to remove that line before actually running your code on a TPU!\n\n</Tip>\n\n### How do I make my model XLA compatible?\n\nIn many cases, your code is probably XLA-compatible already! However, there are a few things that work in normal TensorFlow that don\u2019t work in XLA. We\u2019ve distilled them into three core rules below:\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** We\u2019ve put a lot of effort into rewriting our TensorFlow models and loss functions to be XLA-compatible. Our models and loss functions generally obey rule #1 and #2 by default, so you can skip over them if you\u2019re using `transformers` models. Don\u2019t forget about these rules when writing your own models and loss functions, though!\n\n</Tip>\n\n#### XLA Rule #1: Your code cannot have \u201cdata-dependent conditionals\u201d\n\nWhat that means is that any `if` statement cannot depend on values inside a `tf.Tensor`. For example, this code block cannot be compiled with XLA!\n\n```python\nif tf.reduce_sum(tensor) > 10:\n    tensor = tensor / 2.0\n```\n\nThis might seem very restrictive at first, but most neural net code doesn\u2019t need to do this."
            },
            {
                "score": 1.0,
                "node_text": "Here are some facts extracted from the provided text:\n\nTpu -> Is -> Tensor processing unit\n\nThis is a really useful trick, so remember it if you need to convert your own code to XLA!\n\n#### XLA Rule #3: XLA will need to recompile your model for every different input shape it sees\n\nThis is the big one. What this means is that if your input shapes are very variable, XLA will have to recompile your model over and over, which will create huge performance problems. This commonly arises in NLP models, where input texts have variable lengths after tokenization. In other modalities, static shapes are more common and this rule is much less of a problem.\n\nHow can you get around rule #3? The key is **padding** - if you pad all your inputs to the same length, and then use an `attention_mask`, you can get the same results as you\u2019d get from variable shapes, but without any XLA issues. However, excessive padding can cause severe slowdown too - if you pad all your samples to the maximum length in the whole dataset, you might end up with batches consisting endless padding tokens, which will waste a lot of compute and memory!\n\nThere isn\u2019t a perfect solution to this problem. However, you can try some tricks. One very useful trick is to **pad batches of samples up to a multiple of a number like 32 or 64 tokens.** This often only increases the number of tokens by a small amount, but it hugely reduces the number of unique input shapes, because every input shape now has to be a multiple of 32 or 64. Fewer unique input shapes means fewer XLA compilations!\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** Our tokenizers and data collators have methods that can help you here. You can use `padding=\"max_length\"` or `padding=\"longest\"` when calling tokenizers to get them to output padded data. Our tokenizers and data collators also have a `pad_to_multiple_of` argument that you can use to reduce the number of unique input shapes you see!\n\n</Tip>\n\n### How do I actually train my model on TPU?\n\nOnce your training is XLA-compatible and (if you\u2019re using TPU Node / Colab) your dataset has been prepared appropriately, running on TPU is surprisingly easy! All you really need to change in your code is to add a few lines to initialize your TPU, and to ensure that your model and dataset are created inside a `TPUStrategy` scope. Take a look at [our TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) to see this in action!\n\n### Summary\n\nThere was a lot in here, so let\u2019s summarize with a quick checklist you can follow when you want to get your model ready for TPU training:\n\n- Make sure your code follows the three rules of XLA\n- Compile your model with `jit_compile=True` on CPU/GPU and confirm that you can train it with XLA\n- Either load your dataset into memory or use a TPU-compatible dataset loading approach (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Migrate your code either to Colab (with accelerator set to \u201cTPU\u201d) or a TPU VM on Google Cloud\n- Add TPU initializer code (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Create your `TPUStrategy` and make sure dataset loading and model creation are inside the `strategy.scope()` (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Don\u2019t forget to take `jit_compile=True` out again when you move to TPU!\n- \ud83d\ude4f\ud83d\ude4f\ud83d\ude4f\ud83e\udd7a\ud83e\udd7a\ud83e\udd7a\n- Call model.fit()\n- You did it!"
            },
            {
                "score": 0.7825545414174838,
                "node_text": "Here are some facts extracted from the provided text:\n\nTpuv4 -> Can be accessed as -> Tpu vm\nTpu vm -> Is -> Machine\nTpu vm -> Is -> Machine with tpu attached\nTpu vm -> Connects to -> Tpu\nTpu node -> Is -> Difficult to debug\nTpu node -> Is -> Confusing\nTpu node -> Is -> Remote tpu\n\n</Tip>\n\nThe second way to access a TPU is via a **TPU VM.** When using a TPU VM, you connect directly to the machine that the TPU is attached to, much like training on a GPU VM. TPU VMs are generally easier to work with, particularly when it comes to your data pipeline. All of the above warnings do not apply to TPU VMs!\n\nThis is an opinionated document, so here\u2019s our opinion: **Avoid using TPU Node if possible.** It is more confusing and more difficult to debug than TPU VMs. It is also likely to be unsupported in future - Google\u2019s latest TPU, TPUv4, can only be accessed as a TPU VM, which suggests that TPU Nodes are increasingly going to become a \u201clegacy\u201d access method. However, we understand that the only free TPU access is on Colab and Kaggle Kernels, which uses TPU Node - so we\u2019ll try to explain how to handle it if you have to! Check the [TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) for code samples that explain this in more detail.\n\n### What sizes of TPU are available?\n\nA single TPU (a v2-8/v3-8/v4-8) runs 8 replicas. TPUs exist in **pods** that can run hundreds or thousands of replicas simultaneously. When you use more than a single TPU but less than a whole pod (for example, a v3-32), your TPU fleet is referred to as a **pod slice.**\n\nWhen you access a free TPU via Colab, you generally get a single v2-8 TPU.\n\n### I keep hearing about this XLA thing. What\u2019s XLA, and how does it relate to TPUs?\n\nXLA is an optimizing compiler, used by both TensorFlow and JAX. In JAX it is the only compiler, whereas in TensorFlow it is optional (but mandatory on TPU!). The easiest way to enable it when training a Keras model is to pass the argument `jit_compile=True` to `model.compile()`. If you don\u2019t get any errors and performance is good, that\u2019s a great sign that you\u2019re ready to move to TPU!\n\nDebugging on TPU is generally a bit harder than on CPU/GPU, so we recommend getting your code running on CPU/GPU with XLA first before trying it on TPU. You don\u2019t have to train for long, of course - just for a few steps to make sure that your model and data pipeline are working like you expect them to.\n\n<Tip>\n\nXLA compiled code is usually faster - so even if you\u2019re not planning to run on TPU, adding `jit_compile=True` can improve your performance. Be sure to note the caveats below about XLA compatibility, though!\n\n</Tip>\n\n<Tip warning={true}>\n\n**Tip born of painful experience:** Although using `jit_compile=True` is a good way to get a speed boost and test if your CPU/GPU code is XLA-compatible, it can actually cause a lot of problems if you leave it in when actually training on TPU. XLA compilation will happen implicitly on TPU, so remember to remove that line before actually running your code on a TPU!\n\n</Tip>\n\n### How do I make my model XLA compatible?\n\nIn many cases, your code is probably XLA-compatible already! However, there are a few things that work in normal TensorFlow that don\u2019t work in XLA. We\u2019ve distilled them into three core rules below:\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** We\u2019ve put a lot of effort into rewriting our TensorFlow models and loss functions to be XLA-compatible. Our models and loss functions generally obey rule #1 and #2 by default, so you can skip over them if you\u2019re using `transformers` models. Don\u2019t forget about these rules when writing your own models and loss functions, though!\n\n</Tip>\n\n#### XLA Rule #1: Your code cannot have \u201cdata-dependent conditionals\u201d\n\nWhat that means is that any `if` statement cannot depend on values inside a `tf.Tensor`. For example, this code block cannot be compiled with XLA!\n\n```python\nif tf.reduce_sum(tensor) > 10:\n    tensor = tensor / 2.0\n```\n\nThis might seem very restrictive at first, but most neural net code doesn\u2019t need to do this."
            },
            {
                "score": 0.7153220241589848,
                "node_text": "Here are some facts extracted from the provided text:\n\nTpu -> Is used -> For training\nXla -> Is mandatory on -> Tpu\nTpu -> Accessed through -> Google's cloud services\nTpu -> Is -> Tensor processing unit\nTpu -> Used for -> Neural networks\nTpu -> Exists in -> Pods\n\nThis is a really useful trick, so remember it if you need to convert your own code to XLA!\n\n#### XLA Rule #3: XLA will need to recompile your model for every different input shape it sees\n\nThis is the big one. What this means is that if your input shapes are very variable, XLA will have to recompile your model over and over, which will create huge performance problems. This commonly arises in NLP models, where input texts have variable lengths after tokenization. In other modalities, static shapes are more common and this rule is much less of a problem.\n\nHow can you get around rule #3? The key is **padding** - if you pad all your inputs to the same length, and then use an `attention_mask`, you can get the same results as you\u2019d get from variable shapes, but without any XLA issues. However, excessive padding can cause severe slowdown too - if you pad all your samples to the maximum length in the whole dataset, you might end up with batches consisting endless padding tokens, which will waste a lot of compute and memory!\n\nThere isn\u2019t a perfect solution to this problem. However, you can try some tricks. One very useful trick is to **pad batches of samples up to a multiple of a number like 32 or 64 tokens.** This often only increases the number of tokens by a small amount, but it hugely reduces the number of unique input shapes, because every input shape now has to be a multiple of 32 or 64. Fewer unique input shapes means fewer XLA compilations!\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** Our tokenizers and data collators have methods that can help you here. You can use `padding=\"max_length\"` or `padding=\"longest\"` when calling tokenizers to get them to output padded data. Our tokenizers and data collators also have a `pad_to_multiple_of` argument that you can use to reduce the number of unique input shapes you see!\n\n</Tip>\n\n### How do I actually train my model on TPU?\n\nOnce your training is XLA-compatible and (if you\u2019re using TPU Node / Colab) your dataset has been prepared appropriately, running on TPU is surprisingly easy! All you really need to change in your code is to add a few lines to initialize your TPU, and to ensure that your model and dataset are created inside a `TPUStrategy` scope. Take a look at [our TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) to see this in action!\n\n### Summary\n\nThere was a lot in here, so let\u2019s summarize with a quick checklist you can follow when you want to get your model ready for TPU training:\n\n- Make sure your code follows the three rules of XLA\n- Compile your model with `jit_compile=True` on CPU/GPU and confirm that you can train it with XLA\n- Either load your dataset into memory or use a TPU-compatible dataset loading approach (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Migrate your code either to Colab (with accelerator set to \u201cTPU\u201d) or a TPU VM on Google Cloud\n- Add TPU initializer code (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Create your `TPUStrategy` and make sure dataset loading and model creation are inside the `strategy.scope()` (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Don\u2019t forget to take `jit_compile=True` out again when you move to TPU!\n- \ud83d\ude4f\ud83d\ude4f\ud83d\ude4f\ud83e\udd7a\ud83e\udd7a\ud83e\udd7a\n- Call model.fit()\n- You did it!"
            },
            {
                "score": 0.7153220241589848,
                "node_text": "Here are some facts extracted from the provided text:\n\nGoogle -> Designed -> Tpu\n\n!--Copyright 2023 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\nthe License. You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under the License is distributed on\nan \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n\n\u26a0\ufe0f Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be\nrendered properly in your Markdown viewer.\n\n-->\n\n# Training on TPU with TensorFlow\n\n<Tip>\n\nIf you don't need long explanations and just want TPU code samples to get started with, check out [our TPU example notebook!](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb)\n\n</Tip>\n\n### What is a TPU?\n\nA TPU is a **Tensor Processing Unit.** They are hardware designed by Google, which are used to greatly speed up the tensor computations within neural networks, much like GPUs. They can be used for both network training and inference. They are generally accessed through Google\u2019s cloud services, but small TPUs can also be accessed directly for free through Google Colab and Kaggle Kernels.\n\nBecause [all TensorFlow models in \ud83e\udd17 Transformers are Keras models](https://huggingface.co/blog/tensorflow-philosophy), most of the methods in this document are generally applicable to TPU training for any Keras model! However, there are a few points that are specific to the HuggingFace ecosystem (hug-o-system?) of Transformers and Datasets, and we\u2019ll make sure to flag them up when we get to them.\n\n### What kinds of TPU are available?\n\nNew users are often very confused by the range of TPUs, and the different ways to access them. The first key distinction to understand is the difference between **TPU Nodes** and **TPU VMs.**\n\nWhen you use a **TPU Node**, you are effectively indirectly accessing a remote TPU. You will need a separate VM, which will initialize your network and data pipeline and then forward them to the remote node. When you use a TPU on Google Colab, you are accessing it in the **TPU Node** style.\n\nUsing TPU Nodes can have some quite unexpected behaviour for people who aren\u2019t used to them! In particular, because the TPU is located on a physically different system to the machine you\u2019re running your Python code on, your data cannot be local to your machine - any data pipeline that loads from your machine\u2019s internal storage will totally fail! Instead, data must be stored in Google Cloud Storage where your data pipeline can still access it, even when the pipeline is running on the remote TPU node.\n\n<Tip>\n\nIf you can fit all your data in memory as `np.ndarray` or `tf.Tensor`, then you can `fit()` on that data even when using Colab or a TPU Node, without needing to upload it to Google Cloud Storage.\n\n</Tip>\n\n<Tip>\n\n**\ud83e\udd17Specific Hugging Face Tip\ud83e\udd17:** The methods `Dataset.to_tf_dataset()` and its higher-level wrapper `model.prepare_tf_dataset()` , which you will see throughout our TF code examples, will both fail on a TPU Node. The reason for this is that even though they create a `tf.data.Dataset` it is not a \u201cpure\u201d `tf.data` pipeline and uses `tf.numpy_function` or `Dataset.from_generator()` to stream data from the underlying HuggingFace `Dataset`. This HuggingFace `Dataset` is backed by data that is on a local disc and which the remote TPU Node will not be able to read.\n\n</Tip>\n\nThe second way to access a TPU is via a **TPU VM.** When using a TPU VM, you connect directly to the machine that the TPU is attached to, much like training on a GPU VM. TPU VMs are generally easier to work with, particularly when it comes to your data pipeline. All of the above warnings do not apply to TPU VMs!\n\nThis is an opinionated document, so here\u2019s our opinion: **Avoid using TPU Node if possible.** It is more confusing and more difficult to debug than TPU VMs. It is also likely to be unsupported in future - Google\u2019s latest TPU, TPUv4, can only be accessed as a TPU VM, which suggests that TPU Nodes are increasingly going to become a \u201clegacy\u201d access method."
            }
        ]
    },
    {
        "sample_idx": 44,
        "question": "How do you access a TPU on Google Colab?",
        "answer": "You access a TPU on Google Colab in the TPU Node style.",
        "rag_answer": "You can access a TPU on Google Colab via a TPU Node.",
        "rag_score": 4,
        "rag_feedback": "The system's response is mostly correct, accurate, and factual. It provides the correct information that a TPU on Google Colab can be accessed via a TPU Node. However, the response is not a direct answer to the question and includes a lot of unnecessary information, which makes it hard to extract the correct answer.",
        "rag_context": [
            {
                "score": 0.6897865728071301,
                "node_text": "Here are some facts extracted from the provided text:\n\nGradio -> Can run -> In colab notebooks\n\nGradio Demo: blocks_random_slider\n\n\n```\n!pip install -q gradio \n```\n\n\n```\n\nimport gradio as gr\n\n\ndef func(slider_1, slider_2):\n    return slider_1 * 5 + slider_2\n\n\nwith gr.Blocks() as demo:\n    slider = gr.Slider(minimum=-10.2, maximum=15, label=\"Random Slider (Static)\", randomize=True)\n    slider_1 = gr.Slider(minimum=100, maximum=200, label=\"Random Slider (Input 1)\", randomize=True)\n    slider_2 = gr.Slider(minimum=10, maximum=23.2, label=\"Random Slider (Input 2)\", randomize=True)\n    slider_3 = gr.Slider(value=3, label=\"Non random slider\")\n    btn = gr.Button(\"Run\")\n    btn.click(func, inputs=[slider_1, slider_2], outputs=gr.Number())\n\nif __name__ == \"__main__\":\n    demo.launch()\n\n```"
            },
            {
                "score": 0.6861757993271913,
                "node_text": "Here are some facts extracted from the provided text:\n\nTpu vm -> Is -> Machine with tpu attached\nTpuv4 -> Can be accessed as -> Tpu vm\nTpu vm -> Is -> Machine\nTpu vm -> Connects to -> Tpu\nTpu node -> Is -> Remote tpu\n\n</Tip>\n\nThe second way to access a TPU is via a **TPU VM.** When using a TPU VM, you connect directly to the machine that the TPU is attached to, much like training on a GPU VM. TPU VMs are generally easier to work with, particularly when it comes to your data pipeline. All of the above warnings do not apply to TPU VMs!\n\nThis is an opinionated document, so here\u2019s our opinion: **Avoid using TPU Node if possible.** It is more confusing and more difficult to debug than TPU VMs. It is also likely to be unsupported in future - Google\u2019s latest TPU, TPUv4, can only be accessed as a TPU VM, which suggests that TPU Nodes are increasingly going to become a \u201clegacy\u201d access method. However, we understand that the only free TPU access is on Colab and Kaggle Kernels, which uses TPU Node - so we\u2019ll try to explain how to handle it if you have to! Check the [TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) for code samples that explain this in more detail.\n\n### What sizes of TPU are available?\n\nA single TPU (a v2-8/v3-8/v4-8) runs 8 replicas. TPUs exist in **pods** that can run hundreds or thousands of replicas simultaneously. When you use more than a single TPU but less than a whole pod (for example, a v3-32), your TPU fleet is referred to as a **pod slice.**\n\nWhen you access a free TPU via Colab, you generally get a single v2-8 TPU.\n\n### I keep hearing about this XLA thing. What\u2019s XLA, and how does it relate to TPUs?\n\nXLA is an optimizing compiler, used by both TensorFlow and JAX. In JAX it is the only compiler, whereas in TensorFlow it is optional (but mandatory on TPU!). The easiest way to enable it when training a Keras model is to pass the argument `jit_compile=True` to `model.compile()`. If you don\u2019t get any errors and performance is good, that\u2019s a great sign that you\u2019re ready to move to TPU!\n\nDebugging on TPU is generally a bit harder than on CPU/GPU, so we recommend getting your code running on CPU/GPU with XLA first before trying it on TPU. You don\u2019t have to train for long, of course - just for a few steps to make sure that your model and data pipeline are working like you expect them to.\n\n<Tip>\n\nXLA compiled code is usually faster - so even if you\u2019re not planning to run on TPU, adding `jit_compile=True` can improve your performance. Be sure to note the caveats below about XLA compatibility, though!\n\n</Tip>\n\n<Tip warning={true}>\n\n**Tip born of painful experience:** Although using `jit_compile=True` is a good way to get a speed boost and test if your CPU/GPU code is XLA-compatible, it can actually cause a lot of problems if you leave it in when actually training on TPU. XLA compilation will happen implicitly on TPU, so remember to remove that line before actually running your code on a TPU!\n\n</Tip>\n\n### How do I make my model XLA compatible?\n\nIn many cases, your code is probably XLA-compatible already! However, there are a few things that work in normal TensorFlow that don\u2019t work in XLA. We\u2019ve distilled them into three core rules below:\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** We\u2019ve put a lot of effort into rewriting our TensorFlow models and loss functions to be XLA-compatible. Our models and loss functions generally obey rule #1 and #2 by default, so you can skip over them if you\u2019re using `transformers` models. Don\u2019t forget about these rules when writing your own models and loss functions, though!\n\n</Tip>\n\n#### XLA Rule #1: Your code cannot have \u201cdata-dependent conditionals\u201d\n\nWhat that means is that any `if` statement cannot depend on values inside a `tf.Tensor`. For example, this code block cannot be compiled with XLA!\n\n```python\nif tf.reduce_sum(tensor) > 10:\n    tensor = tensor / 2.0\n```\n\nThis might seem very restrictive at first, but most neural net code doesn\u2019t need to do this."
            }
        ]
    },
    {
        "sample_idx": 45,
        "question": "Why do data pipelines that load from a machine's internal storage fail when using a TPU Node?",
        "answer": "Data pipelines that load from a machine's internal storage fail when using a TPU Node because the TPU is located on a physically different system to the machine running the Python code.",
        "rag_answer": "The reason data pipelines that load from a machine's internal storage fail when using a TPU Node is not explicitly stated. However, it can be inferred that TPU Nodes are more confusing and difficult to debug, which might contribute to the failure of these data pipelines. In contrast, TPU VMs are generally easier to work with, particularly when it comes to data pipelines, which suggests that using a TPU VM might avoid these issues.",
        "rag_score": 2,
        "rag_feedback": "The system's response is not directly addressing the question and does not provide a clear explanation for why data pipelines that load from a machine's internal storage fail when using a TPU Node. The response mentions that TPU Nodes are more confusing and difficult to debug, but it does not provide a factual reason for the failure. The correct answer is that the TPU is located on a physically different system to the machine running the Python code, which is not mentioned in the system's response.",
        "rag_context": [
            {
                "score": 0.6918346936460743,
                "node_text": "Here are some facts extracted from the provided text:\n\nTpu node -> Is -> Difficult to debug\nTpu node -> Is -> Confusing\nTpu node -> Is -> Remote tpu\nTpu vm -> Is -> Machine with tpu attached\nTpuv4 -> Can be accessed as -> Tpu vm\nTpu vm -> Is -> Machine\nTpu vm -> Connects to -> Tpu\n\n</Tip>\n\nThe second way to access a TPU is via a **TPU VM.** When using a TPU VM, you connect directly to the machine that the TPU is attached to, much like training on a GPU VM. TPU VMs are generally easier to work with, particularly when it comes to your data pipeline. All of the above warnings do not apply to TPU VMs!\n\nThis is an opinionated document, so here\u2019s our opinion: **Avoid using TPU Node if possible.** It is more confusing and more difficult to debug than TPU VMs. It is also likely to be unsupported in future - Google\u2019s latest TPU, TPUv4, can only be accessed as a TPU VM, which suggests that TPU Nodes are increasingly going to become a \u201clegacy\u201d access method. However, we understand that the only free TPU access is on Colab and Kaggle Kernels, which uses TPU Node - so we\u2019ll try to explain how to handle it if you have to! Check the [TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) for code samples that explain this in more detail.\n\n### What sizes of TPU are available?\n\nA single TPU (a v2-8/v3-8/v4-8) runs 8 replicas. TPUs exist in **pods** that can run hundreds or thousands of replicas simultaneously. When you use more than a single TPU but less than a whole pod (for example, a v3-32), your TPU fleet is referred to as a **pod slice.**\n\nWhen you access a free TPU via Colab, you generally get a single v2-8 TPU.\n\n### I keep hearing about this XLA thing. What\u2019s XLA, and how does it relate to TPUs?\n\nXLA is an optimizing compiler, used by both TensorFlow and JAX. In JAX it is the only compiler, whereas in TensorFlow it is optional (but mandatory on TPU!). The easiest way to enable it when training a Keras model is to pass the argument `jit_compile=True` to `model.compile()`. If you don\u2019t get any errors and performance is good, that\u2019s a great sign that you\u2019re ready to move to TPU!\n\nDebugging on TPU is generally a bit harder than on CPU/GPU, so we recommend getting your code running on CPU/GPU with XLA first before trying it on TPU. You don\u2019t have to train for long, of course - just for a few steps to make sure that your model and data pipeline are working like you expect them to.\n\n<Tip>\n\nXLA compiled code is usually faster - so even if you\u2019re not planning to run on TPU, adding `jit_compile=True` can improve your performance. Be sure to note the caveats below about XLA compatibility, though!\n\n</Tip>\n\n<Tip warning={true}>\n\n**Tip born of painful experience:** Although using `jit_compile=True` is a good way to get a speed boost and test if your CPU/GPU code is XLA-compatible, it can actually cause a lot of problems if you leave it in when actually training on TPU. XLA compilation will happen implicitly on TPU, so remember to remove that line before actually running your code on a TPU!\n\n</Tip>\n\n### How do I make my model XLA compatible?\n\nIn many cases, your code is probably XLA-compatible already! However, there are a few things that work in normal TensorFlow that don\u2019t work in XLA. We\u2019ve distilled them into three core rules below:\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** We\u2019ve put a lot of effort into rewriting our TensorFlow models and loss functions to be XLA-compatible. Our models and loss functions generally obey rule #1 and #2 by default, so you can skip over them if you\u2019re using `transformers` models. Don\u2019t forget about these rules when writing your own models and loss functions, though!\n\n</Tip>\n\n#### XLA Rule #1: Your code cannot have \u201cdata-dependent conditionals\u201d\n\nWhat that means is that any `if` statement cannot depend on values inside a `tf.Tensor`. For example, this code block cannot be compiled with XLA!\n\n```python\nif tf.reduce_sum(tensor) > 10:\n    tensor = tensor / 2.0\n```\n\nThis might seem very restrictive at first, but most neural net code doesn\u2019t need to do this."
            }
        ]
    },
    {
        "context": "New users are often very confused by the range of TPUs, and the different ways to access them. The first key distinction to understand is the difference between **TPU Nodes** and **TPU VMs.**\n\nWhen you use a **TPU Node**, you are effectively indirectly accessing a remote TPU. You will need a separate VM, which will initialize your network and data pipeline and then forward them to the remote node. When you use a TPU on Google Colab, you are accessing it in the **TPU Node** style.\n\nUsing TPU Nodes can have some quite unexpected behaviour for people who aren\u2019t used to them! In particular, because the TPU is located on a physically different system to the machine you\u2019re running your Python code on, your data cannot be local to your machine - any data pipeline that loads from your machine\u2019s internal storage will totally fail! Instead, data must be stored in Google Cloud Storage where your data pipeline can still access it, even when the pipeline is running on the remote TPU node.\n\n<Tip>\n\nIf you can fit all your data in memory as `np.ndarray` or `tf.Tensor`, then you can `fit()` on that data even when using Colab or a TPU Node, without needing to upload it to Google Cloud Storage.\n\n</Tip>\n\n<Tip>\n\n**\ud83e\udd17Specific Hugging Face Tip\ud83e\udd17:** The methods `Dataset.to_tf_dataset()` and its higher-level wrapper `model.prepare_tf_dataset()` , which you will see throughout our TF code examples, will both fail on a TPU Node. The reason for this is that even though they create a `tf.data.Dataset` it is not a \u201cpure\u201d `tf.data` pipeline and uses `tf.numpy_function` or `Dataset.from_generator()` to stream data from the underlying HuggingFace `Dataset`. This HuggingFace `Dataset` is backed by data that is on a local disc and which the remote TPU Node will not be able to read.\n\n</Tip>",
        "question": "Where must data be stored when using a TPU Node?",
        "answer": "Data must be stored in Google Cloud Storage when using a TPU Node.",
        "source_doc": "huggingface/transformers/blob/main/docs/source/en/perf_train_tpu_tf.md",
        "rag_answer": null,
        "rag_context": null,
        "rag_score": null,
        "rag_feedback": null
    },
    {
        "sample_idx": 47,
        "question": "Can you fit data in memory as np.ndarray or tf.Tensor when using Colab or a TPU Node?",
        "answer": "Yes, you can fit data in memory as np.ndarray or tf.Tensor when using Colab or a TPU Node, without needing to upload it to Google Cloud Storage.",
        "rag_answer": "Yes, you can fit all your data in memory as `np.ndarray` or `tf.Tensor` when using Colab or a TPU Node, and then you can `fit()` on that data without needing to upload it to Google Cloud Storage.",
        "rag_score": 5,
        "rag_feedback": "The system's response is completely correct, accurate, and factual. It directly answers the question and provides additional relevant information from the context.",
        "rag_context": [
            {
                "score": 0.6669406021472792,
                "node_text": "Here are some facts extracted from the provided text:\n\nTpu -> Is -> Tensor processing unit\n\nThis is a really useful trick, so remember it if you need to convert your own code to XLA!\n\n#### XLA Rule #3: XLA will need to recompile your model for every different input shape it sees\n\nThis is the big one. What this means is that if your input shapes are very variable, XLA will have to recompile your model over and over, which will create huge performance problems. This commonly arises in NLP models, where input texts have variable lengths after tokenization. In other modalities, static shapes are more common and this rule is much less of a problem.\n\nHow can you get around rule #3? The key is **padding** - if you pad all your inputs to the same length, and then use an `attention_mask`, you can get the same results as you\u2019d get from variable shapes, but without any XLA issues. However, excessive padding can cause severe slowdown too - if you pad all your samples to the maximum length in the whole dataset, you might end up with batches consisting endless padding tokens, which will waste a lot of compute and memory!\n\nThere isn\u2019t a perfect solution to this problem. However, you can try some tricks. One very useful trick is to **pad batches of samples up to a multiple of a number like 32 or 64 tokens.** This often only increases the number of tokens by a small amount, but it hugely reduces the number of unique input shapes, because every input shape now has to be a multiple of 32 or 64. Fewer unique input shapes means fewer XLA compilations!\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** Our tokenizers and data collators have methods that can help you here. You can use `padding=\"max_length\"` or `padding=\"longest\"` when calling tokenizers to get them to output padded data. Our tokenizers and data collators also have a `pad_to_multiple_of` argument that you can use to reduce the number of unique input shapes you see!\n\n</Tip>\n\n### How do I actually train my model on TPU?\n\nOnce your training is XLA-compatible and (if you\u2019re using TPU Node / Colab) your dataset has been prepared appropriately, running on TPU is surprisingly easy! All you really need to change in your code is to add a few lines to initialize your TPU, and to ensure that your model and dataset are created inside a `TPUStrategy` scope. Take a look at [our TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) to see this in action!\n\n### Summary\n\nThere was a lot in here, so let\u2019s summarize with a quick checklist you can follow when you want to get your model ready for TPU training:\n\n- Make sure your code follows the three rules of XLA\n- Compile your model with `jit_compile=True` on CPU/GPU and confirm that you can train it with XLA\n- Either load your dataset into memory or use a TPU-compatible dataset loading approach (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Migrate your code either to Colab (with accelerator set to \u201cTPU\u201d) or a TPU VM on Google Cloud\n- Add TPU initializer code (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Create your `TPUStrategy` and make sure dataset loading and model creation are inside the `strategy.scope()` (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Don\u2019t forget to take `jit_compile=True` out again when you move to TPU!\n- \ud83d\ude4f\ud83d\ude4f\ud83d\ude4f\ud83e\udd7a\ud83e\udd7a\ud83e\udd7a\n- Call model.fit()\n- You did it!"
            },
            {
                "score": 0.6160581996417996,
                "node_text": "Here are some facts extracted from the provided text:\n\nTensorflow models -> Are -> Keras models\n\n!--Copyright 2023 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\nthe License. You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under the License is distributed on\nan \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n\n\u26a0\ufe0f Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be\nrendered properly in your Markdown viewer.\n\n-->\n\n# Training on TPU with TensorFlow\n\n<Tip>\n\nIf you don't need long explanations and just want TPU code samples to get started with, check out [our TPU example notebook!](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb)\n\n</Tip>\n\n### What is a TPU?\n\nA TPU is a **Tensor Processing Unit.** They are hardware designed by Google, which are used to greatly speed up the tensor computations within neural networks, much like GPUs. They can be used for both network training and inference. They are generally accessed through Google\u2019s cloud services, but small TPUs can also be accessed directly for free through Google Colab and Kaggle Kernels.\n\nBecause [all TensorFlow models in \ud83e\udd17 Transformers are Keras models](https://huggingface.co/blog/tensorflow-philosophy), most of the methods in this document are generally applicable to TPU training for any Keras model! However, there are a few points that are specific to the HuggingFace ecosystem (hug-o-system?) of Transformers and Datasets, and we\u2019ll make sure to flag them up when we get to them.\n\n### What kinds of TPU are available?\n\nNew users are often very confused by the range of TPUs, and the different ways to access them. The first key distinction to understand is the difference between **TPU Nodes** and **TPU VMs.**\n\nWhen you use a **TPU Node**, you are effectively indirectly accessing a remote TPU. You will need a separate VM, which will initialize your network and data pipeline and then forward them to the remote node. When you use a TPU on Google Colab, you are accessing it in the **TPU Node** style.\n\nUsing TPU Nodes can have some quite unexpected behaviour for people who aren\u2019t used to them! In particular, because the TPU is located on a physically different system to the machine you\u2019re running your Python code on, your data cannot be local to your machine - any data pipeline that loads from your machine\u2019s internal storage will totally fail! Instead, data must be stored in Google Cloud Storage where your data pipeline can still access it, even when the pipeline is running on the remote TPU node.\n\n<Tip>\n\nIf you can fit all your data in memory as `np.ndarray` or `tf.Tensor`, then you can `fit()` on that data even when using Colab or a TPU Node, without needing to upload it to Google Cloud Storage.\n\n</Tip>\n\n<Tip>\n\n**\ud83e\udd17Specific Hugging Face Tip\ud83e\udd17:** The methods `Dataset.to_tf_dataset()` and its higher-level wrapper `model.prepare_tf_dataset()` , which you will see throughout our TF code examples, will both fail on a TPU Node. The reason for this is that even though they create a `tf.data.Dataset` it is not a \u201cpure\u201d `tf.data` pipeline and uses `tf.numpy_function` or `Dataset.from_generator()` to stream data from the underlying HuggingFace `Dataset`. This HuggingFace `Dataset` is backed by data that is on a local disc and which the remote TPU Node will not be able to read.\n\n</Tip>\n\nThe second way to access a TPU is via a **TPU VM.** When using a TPU VM, you connect directly to the machine that the TPU is attached to, much like training on a GPU VM. TPU VMs are generally easier to work with, particularly when it comes to your data pipeline. All of the above warnings do not apply to TPU VMs!\n\nThis is an opinionated document, so here\u2019s our opinion: **Avoid using TPU Node if possible.** It is more confusing and more difficult to debug than TPU VMs. It is also likely to be unsupported in future - Google\u2019s latest TPU, TPUv4, can only be accessed as a TPU VM, which suggests that TPU Nodes are increasingly going to become a \u201clegacy\u201d access method."
            },
            {
                "score": 0.6062033436131066,
                "node_text": "Here are some facts extracted from the provided text:\n\nGradio -> Can run -> In colab notebooks\n\nGradio Demo: blocks_random_slider\n\n\n```\n!pip install -q gradio \n```\n\n\n```\n\nimport gradio as gr\n\n\ndef func(slider_1, slider_2):\n    return slider_1 * 5 + slider_2\n\n\nwith gr.Blocks() as demo:\n    slider = gr.Slider(minimum=-10.2, maximum=15, label=\"Random Slider (Static)\", randomize=True)\n    slider_1 = gr.Slider(minimum=100, maximum=200, label=\"Random Slider (Input 1)\", randomize=True)\n    slider_2 = gr.Slider(minimum=10, maximum=23.2, label=\"Random Slider (Input 2)\", randomize=True)\n    slider_3 = gr.Slider(value=3, label=\"Non random slider\")\n    btn = gr.Button(\"Run\")\n    btn.click(func, inputs=[slider_1, slider_2], outputs=gr.Number())\n\nif __name__ == \"__main__\":\n    demo.launch()\n\n```"
            }
        ]
    },
    {
        "sample_idx": 48,
        "question": "Why do the methods Dataset.to_tf_dataset() and model.prepare_tf_dataset() fail on a TPU Node?",
        "answer": "The methods Dataset.to_tf_dataset() and model.prepare_tf_dataset() fail on a TPU Node because they use tf.numpy_function or Dataset.from_generator() to stream data from the underlying HuggingFace Dataset, which is backed by data on a local disc that the remote TPU Node cannot read.",
        "rag_answer": "The methods Dataset.to_tf_dataset() and model.prepare_tf_dataset() fail on a TPU Node because TPU Node is more confusing and more difficult to debug than TPU VMs.",
        "rag_score": 1,
        "rag_feedback": "The system's response is completely incorrect, inaccurate, and/or not factual. The response does not address the question about why the methods Dataset.to_tf_dataset() and model.prepare_tf_dataset() fail on a TPU Node. Instead, it provides a general discussion about TPU Node, TPU VM, and XLA, which is not relevant to the question.",
        "rag_context": [
            {
                "score": 0.6776104293121223,
                "node_text": "Here are some facts extracted from the provided text:\n\nTpu node -> Is -> Difficult to debug\nTpu node -> Is -> Confusing\nTpu node -> Is -> Remote tpu\nTpuv4 -> Can be accessed as -> Tpu vm\nTpu vm -> Is -> Machine\nTpu vm -> Is -> Machine with tpu attached\nTpu vm -> Connects to -> Tpu\n\n</Tip>\n\nThe second way to access a TPU is via a **TPU VM.** When using a TPU VM, you connect directly to the machine that the TPU is attached to, much like training on a GPU VM. TPU VMs are generally easier to work with, particularly when it comes to your data pipeline. All of the above warnings do not apply to TPU VMs!\n\nThis is an opinionated document, so here\u2019s our opinion: **Avoid using TPU Node if possible.** It is more confusing and more difficult to debug than TPU VMs. It is also likely to be unsupported in future - Google\u2019s latest TPU, TPUv4, can only be accessed as a TPU VM, which suggests that TPU Nodes are increasingly going to become a \u201clegacy\u201d access method. However, we understand that the only free TPU access is on Colab and Kaggle Kernels, which uses TPU Node - so we\u2019ll try to explain how to handle it if you have to! Check the [TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) for code samples that explain this in more detail.\n\n### What sizes of TPU are available?\n\nA single TPU (a v2-8/v3-8/v4-8) runs 8 replicas. TPUs exist in **pods** that can run hundreds or thousands of replicas simultaneously. When you use more than a single TPU but less than a whole pod (for example, a v3-32), your TPU fleet is referred to as a **pod slice.**\n\nWhen you access a free TPU via Colab, you generally get a single v2-8 TPU.\n\n### I keep hearing about this XLA thing. What\u2019s XLA, and how does it relate to TPUs?\n\nXLA is an optimizing compiler, used by both TensorFlow and JAX. In JAX it is the only compiler, whereas in TensorFlow it is optional (but mandatory on TPU!). The easiest way to enable it when training a Keras model is to pass the argument `jit_compile=True` to `model.compile()`. If you don\u2019t get any errors and performance is good, that\u2019s a great sign that you\u2019re ready to move to TPU!\n\nDebugging on TPU is generally a bit harder than on CPU/GPU, so we recommend getting your code running on CPU/GPU with XLA first before trying it on TPU. You don\u2019t have to train for long, of course - just for a few steps to make sure that your model and data pipeline are working like you expect them to.\n\n<Tip>\n\nXLA compiled code is usually faster - so even if you\u2019re not planning to run on TPU, adding `jit_compile=True` can improve your performance. Be sure to note the caveats below about XLA compatibility, though!\n\n</Tip>\n\n<Tip warning={true}>\n\n**Tip born of painful experience:** Although using `jit_compile=True` is a good way to get a speed boost and test if your CPU/GPU code is XLA-compatible, it can actually cause a lot of problems if you leave it in when actually training on TPU. XLA compilation will happen implicitly on TPU, so remember to remove that line before actually running your code on a TPU!\n\n</Tip>\n\n### How do I make my model XLA compatible?\n\nIn many cases, your code is probably XLA-compatible already! However, there are a few things that work in normal TensorFlow that don\u2019t work in XLA. We\u2019ve distilled them into three core rules below:\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** We\u2019ve put a lot of effort into rewriting our TensorFlow models and loss functions to be XLA-compatible. Our models and loss functions generally obey rule #1 and #2 by default, so you can skip over them if you\u2019re using `transformers` models. Don\u2019t forget about these rules when writing your own models and loss functions, though!\n\n</Tip>\n\n#### XLA Rule #1: Your code cannot have \u201cdata-dependent conditionals\u201d\n\nWhat that means is that any `if` statement cannot depend on values inside a `tf.Tensor`. For example, this code block cannot be compiled with XLA!\n\n```python\nif tf.reduce_sum(tensor) > 10:\n    tensor = tensor / 2.0\n```\n\nThis might seem very restrictive at first, but most neural net code doesn\u2019t need to do this."
            },
            {
                "score": 0.6674522331664481,
                "node_text": "Here are some facts extracted from the provided text:\n\nTpu -> Is -> Tensor processing unit\nXla -> Is used by -> Tensorflow and jax\n\nThis is a really useful trick, so remember it if you need to convert your own code to XLA!\n\n#### XLA Rule #3: XLA will need to recompile your model for every different input shape it sees\n\nThis is the big one. What this means is that if your input shapes are very variable, XLA will have to recompile your model over and over, which will create huge performance problems. This commonly arises in NLP models, where input texts have variable lengths after tokenization. In other modalities, static shapes are more common and this rule is much less of a problem.\n\nHow can you get around rule #3? The key is **padding** - if you pad all your inputs to the same length, and then use an `attention_mask`, you can get the same results as you\u2019d get from variable shapes, but without any XLA issues. However, excessive padding can cause severe slowdown too - if you pad all your samples to the maximum length in the whole dataset, you might end up with batches consisting endless padding tokens, which will waste a lot of compute and memory!\n\nThere isn\u2019t a perfect solution to this problem. However, you can try some tricks. One very useful trick is to **pad batches of samples up to a multiple of a number like 32 or 64 tokens.** This often only increases the number of tokens by a small amount, but it hugely reduces the number of unique input shapes, because every input shape now has to be a multiple of 32 or 64. Fewer unique input shapes means fewer XLA compilations!\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** Our tokenizers and data collators have methods that can help you here. You can use `padding=\"max_length\"` or `padding=\"longest\"` when calling tokenizers to get them to output padded data. Our tokenizers and data collators also have a `pad_to_multiple_of` argument that you can use to reduce the number of unique input shapes you see!\n\n</Tip>\n\n### How do I actually train my model on TPU?\n\nOnce your training is XLA-compatible and (if you\u2019re using TPU Node / Colab) your dataset has been prepared appropriately, running on TPU is surprisingly easy! All you really need to change in your code is to add a few lines to initialize your TPU, and to ensure that your model and dataset are created inside a `TPUStrategy` scope. Take a look at [our TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) to see this in action!\n\n### Summary\n\nThere was a lot in here, so let\u2019s summarize with a quick checklist you can follow when you want to get your model ready for TPU training:\n\n- Make sure your code follows the three rules of XLA\n- Compile your model with `jit_compile=True` on CPU/GPU and confirm that you can train it with XLA\n- Either load your dataset into memory or use a TPU-compatible dataset loading approach (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Migrate your code either to Colab (with accelerator set to \u201cTPU\u201d) or a TPU VM on Google Cloud\n- Add TPU initializer code (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Create your `TPUStrategy` and make sure dataset loading and model creation are inside the `strategy.scope()` (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Don\u2019t forget to take `jit_compile=True` out again when you move to TPU!\n- \ud83d\ude4f\ud83d\ude4f\ud83d\ude4f\ud83e\udd7a\ud83e\udd7a\ud83e\udd7a\n- Call model.fit()\n- You did it!"
            }
        ]
    },
    {
        "sample_idx": 49,
        "question": "What is a TPU VM?",
        "answer": "A TPU VM is a machine that a TPU is attached to, allowing direct connection for training, similar to a GPU VM.",
        "rag_answer": "A TPU VM is a machine with a TPU attached, which can be connected to directly, similar to training on a GPU VM.",
        "rag_score": 5,
        "rag_feedback": "The system's response is almost identical to the expected answer, with only minor rephrasing. The response accurately conveys the same information as the expected answer, which is that a TPU VM is a machine with a TPU attached, allowing direct connection for training, similar to a GPU VM.",
        "rag_context": [
            {
                "score": 0.88351098236404,
                "node_text": "Here are some facts extracted from the provided text:\n\nTpuv4 -> Can be accessed as -> Tpu vm\nTpu vm -> Is -> Machine\nTpu vm -> Is -> Machine with tpu attached\nTpu vm -> Connects to -> Tpu\nTpu node -> Is -> Remote tpu\n\n</Tip>\n\nThe second way to access a TPU is via a **TPU VM.** When using a TPU VM, you connect directly to the machine that the TPU is attached to, much like training on a GPU VM. TPU VMs are generally easier to work with, particularly when it comes to your data pipeline. All of the above warnings do not apply to TPU VMs!\n\nThis is an opinionated document, so here\u2019s our opinion: **Avoid using TPU Node if possible.** It is more confusing and more difficult to debug than TPU VMs. It is also likely to be unsupported in future - Google\u2019s latest TPU, TPUv4, can only be accessed as a TPU VM, which suggests that TPU Nodes are increasingly going to become a \u201clegacy\u201d access method. However, we understand that the only free TPU access is on Colab and Kaggle Kernels, which uses TPU Node - so we\u2019ll try to explain how to handle it if you have to! Check the [TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) for code samples that explain this in more detail.\n\n### What sizes of TPU are available?\n\nA single TPU (a v2-8/v3-8/v4-8) runs 8 replicas. TPUs exist in **pods** that can run hundreds or thousands of replicas simultaneously. When you use more than a single TPU but less than a whole pod (for example, a v3-32), your TPU fleet is referred to as a **pod slice.**\n\nWhen you access a free TPU via Colab, you generally get a single v2-8 TPU.\n\n### I keep hearing about this XLA thing. What\u2019s XLA, and how does it relate to TPUs?\n\nXLA is an optimizing compiler, used by both TensorFlow and JAX. In JAX it is the only compiler, whereas in TensorFlow it is optional (but mandatory on TPU!). The easiest way to enable it when training a Keras model is to pass the argument `jit_compile=True` to `model.compile()`. If you don\u2019t get any errors and performance is good, that\u2019s a great sign that you\u2019re ready to move to TPU!\n\nDebugging on TPU is generally a bit harder than on CPU/GPU, so we recommend getting your code running on CPU/GPU with XLA first before trying it on TPU. You don\u2019t have to train for long, of course - just for a few steps to make sure that your model and data pipeline are working like you expect them to.\n\n<Tip>\n\nXLA compiled code is usually faster - so even if you\u2019re not planning to run on TPU, adding `jit_compile=True` can improve your performance. Be sure to note the caveats below about XLA compatibility, though!\n\n</Tip>\n\n<Tip warning={true}>\n\n**Tip born of painful experience:** Although using `jit_compile=True` is a good way to get a speed boost and test if your CPU/GPU code is XLA-compatible, it can actually cause a lot of problems if you leave it in when actually training on TPU. XLA compilation will happen implicitly on TPU, so remember to remove that line before actually running your code on a TPU!\n\n</Tip>\n\n### How do I make my model XLA compatible?\n\nIn many cases, your code is probably XLA-compatible already! However, there are a few things that work in normal TensorFlow that don\u2019t work in XLA. We\u2019ve distilled them into three core rules below:\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** We\u2019ve put a lot of effort into rewriting our TensorFlow models and loss functions to be XLA-compatible. Our models and loss functions generally obey rule #1 and #2 by default, so you can skip over them if you\u2019re using `transformers` models. Don\u2019t forget about these rules when writing your own models and loss functions, though!\n\n</Tip>\n\n#### XLA Rule #1: Your code cannot have \u201cdata-dependent conditionals\u201d\n\nWhat that means is that any `if` statement cannot depend on values inside a `tf.Tensor`. For example, this code block cannot be compiled with XLA!\n\n```python\nif tf.reduce_sum(tensor) > 10:\n    tensor = tensor / 2.0\n```\n\nThis might seem very restrictive at first, but most neural net code doesn\u2019t need to do this."
            }
        ]
    },
    {
        "sample_idx": 50,
        "question": "Why is it recommended to avoid using TPU Node?",
        "answer": "TPU Node is more confusing and difficult to debug than TPU VMs, and it is likely to be unsupported in the future.",
        "rag_answer": "It is recommended to avoid using TPU Node because it is more confusing and more difficult to debug than TPU VMs. Additionally, it is likely to be unsupported in the future, as Google's latest TPU, TPUv4, can only be accessed as a TPU VM, suggesting that TPU Nodes are increasingly going to become a \"legacy\" access method.",
        "rag_score": 5,
        "rag_feedback": "The system's response is completely correct, accurate, and factual. It provides a detailed explanation of why TPU Node is recommended to be avoided, citing its confusing and difficult debugging nature, as well as its likely future unavailability. The response also provides additional context and information about TPU VMs, XLA, and TPU training, which is not required by the question but adds value to the answer.",
        "rag_context": [
            {
                "score": 0.7767221782909381,
                "node_text": "Here are some facts extracted from the provided text:\n\nTpu node -> Is -> Difficult to debug\nTpu node -> Is -> Confusing\nTpu node -> Is -> Remote tpu\nTpu vm -> Connects to -> Tpu\nTpuv4 -> Can be accessed as -> Tpu vm\nTpu vm -> Is -> Machine\nTpu vm -> Is -> Machine with tpu attached\n\n</Tip>\n\nThe second way to access a TPU is via a **TPU VM.** When using a TPU VM, you connect directly to the machine that the TPU is attached to, much like training on a GPU VM. TPU VMs are generally easier to work with, particularly when it comes to your data pipeline. All of the above warnings do not apply to TPU VMs!\n\nThis is an opinionated document, so here\u2019s our opinion: **Avoid using TPU Node if possible.** It is more confusing and more difficult to debug than TPU VMs. It is also likely to be unsupported in future - Google\u2019s latest TPU, TPUv4, can only be accessed as a TPU VM, which suggests that TPU Nodes are increasingly going to become a \u201clegacy\u201d access method. However, we understand that the only free TPU access is on Colab and Kaggle Kernels, which uses TPU Node - so we\u2019ll try to explain how to handle it if you have to! Check the [TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) for code samples that explain this in more detail.\n\n### What sizes of TPU are available?\n\nA single TPU (a v2-8/v3-8/v4-8) runs 8 replicas. TPUs exist in **pods** that can run hundreds or thousands of replicas simultaneously. When you use more than a single TPU but less than a whole pod (for example, a v3-32), your TPU fleet is referred to as a **pod slice.**\n\nWhen you access a free TPU via Colab, you generally get a single v2-8 TPU.\n\n### I keep hearing about this XLA thing. What\u2019s XLA, and how does it relate to TPUs?\n\nXLA is an optimizing compiler, used by both TensorFlow and JAX. In JAX it is the only compiler, whereas in TensorFlow it is optional (but mandatory on TPU!). The easiest way to enable it when training a Keras model is to pass the argument `jit_compile=True` to `model.compile()`. If you don\u2019t get any errors and performance is good, that\u2019s a great sign that you\u2019re ready to move to TPU!\n\nDebugging on TPU is generally a bit harder than on CPU/GPU, so we recommend getting your code running on CPU/GPU with XLA first before trying it on TPU. You don\u2019t have to train for long, of course - just for a few steps to make sure that your model and data pipeline are working like you expect them to.\n\n<Tip>\n\nXLA compiled code is usually faster - so even if you\u2019re not planning to run on TPU, adding `jit_compile=True` can improve your performance. Be sure to note the caveats below about XLA compatibility, though!\n\n</Tip>\n\n<Tip warning={true}>\n\n**Tip born of painful experience:** Although using `jit_compile=True` is a good way to get a speed boost and test if your CPU/GPU code is XLA-compatible, it can actually cause a lot of problems if you leave it in when actually training on TPU. XLA compilation will happen implicitly on TPU, so remember to remove that line before actually running your code on a TPU!\n\n</Tip>\n\n### How do I make my model XLA compatible?\n\nIn many cases, your code is probably XLA-compatible already! However, there are a few things that work in normal TensorFlow that don\u2019t work in XLA. We\u2019ve distilled them into three core rules below:\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** We\u2019ve put a lot of effort into rewriting our TensorFlow models and loss functions to be XLA-compatible. Our models and loss functions generally obey rule #1 and #2 by default, so you can skip over them if you\u2019re using `transformers` models. Don\u2019t forget about these rules when writing your own models and loss functions, though!\n\n</Tip>\n\n#### XLA Rule #1: Your code cannot have \u201cdata-dependent conditionals\u201d\n\nWhat that means is that any `if` statement cannot depend on values inside a `tf.Tensor`. For example, this code block cannot be compiled with XLA!\n\n```python\nif tf.reduce_sum(tensor) > 10:\n    tensor = tensor / 2.0\n```\n\nThis might seem very restrictive at first, but most neural net code doesn\u2019t need to do this."
            },
            {
                "score": 0.7145945805141877,
                "node_text": "Here are some facts extracted from the provided text:\n\nTpu -> Is used -> For training\nXla -> Is mandatory on -> Tpu\nTpu -> Accessed through -> Google's cloud services\nTpu -> Is -> Tensor processing unit\nTpu -> Used for -> Neural networks\nTpu -> Exists in -> Pods\n\nThis is a really useful trick, so remember it if you need to convert your own code to XLA!\n\n#### XLA Rule #3: XLA will need to recompile your model for every different input shape it sees\n\nThis is the big one. What this means is that if your input shapes are very variable, XLA will have to recompile your model over and over, which will create huge performance problems. This commonly arises in NLP models, where input texts have variable lengths after tokenization. In other modalities, static shapes are more common and this rule is much less of a problem.\n\nHow can you get around rule #3? The key is **padding** - if you pad all your inputs to the same length, and then use an `attention_mask`, you can get the same results as you\u2019d get from variable shapes, but without any XLA issues. However, excessive padding can cause severe slowdown too - if you pad all your samples to the maximum length in the whole dataset, you might end up with batches consisting endless padding tokens, which will waste a lot of compute and memory!\n\nThere isn\u2019t a perfect solution to this problem. However, you can try some tricks. One very useful trick is to **pad batches of samples up to a multiple of a number like 32 or 64 tokens.** This often only increases the number of tokens by a small amount, but it hugely reduces the number of unique input shapes, because every input shape now has to be a multiple of 32 or 64. Fewer unique input shapes means fewer XLA compilations!\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** Our tokenizers and data collators have methods that can help you here. You can use `padding=\"max_length\"` or `padding=\"longest\"` when calling tokenizers to get them to output padded data. Our tokenizers and data collators also have a `pad_to_multiple_of` argument that you can use to reduce the number of unique input shapes you see!\n\n</Tip>\n\n### How do I actually train my model on TPU?\n\nOnce your training is XLA-compatible and (if you\u2019re using TPU Node / Colab) your dataset has been prepared appropriately, running on TPU is surprisingly easy! All you really need to change in your code is to add a few lines to initialize your TPU, and to ensure that your model and dataset are created inside a `TPUStrategy` scope. Take a look at [our TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) to see this in action!\n\n### Summary\n\nThere was a lot in here, so let\u2019s summarize with a quick checklist you can follow when you want to get your model ready for TPU training:\n\n- Make sure your code follows the three rules of XLA\n- Compile your model with `jit_compile=True` on CPU/GPU and confirm that you can train it with XLA\n- Either load your dataset into memory or use a TPU-compatible dataset loading approach (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Migrate your code either to Colab (with accelerator set to \u201cTPU\u201d) or a TPU VM on Google Cloud\n- Add TPU initializer code (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Create your `TPUStrategy` and make sure dataset loading and model creation are inside the `strategy.scope()` (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Don\u2019t forget to take `jit_compile=True` out again when you move to TPU!\n- \ud83d\ude4f\ud83d\ude4f\ud83d\ude4f\ud83e\udd7a\ud83e\udd7a\ud83e\udd7a\n- Call model.fit()\n- You did it!"
            },
            {
                "score": 0.7145945805141877,
                "node_text": "Here are some facts extracted from the provided text:\n\nGoogle -> Designed -> Tpu\n\n!--Copyright 2023 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\nthe License. You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under the License is distributed on\nan \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n\n\u26a0\ufe0f Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be\nrendered properly in your Markdown viewer.\n\n-->\n\n# Training on TPU with TensorFlow\n\n<Tip>\n\nIf you don't need long explanations and just want TPU code samples to get started with, check out [our TPU example notebook!](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb)\n\n</Tip>\n\n### What is a TPU?\n\nA TPU is a **Tensor Processing Unit.** They are hardware designed by Google, which are used to greatly speed up the tensor computations within neural networks, much like GPUs. They can be used for both network training and inference. They are generally accessed through Google\u2019s cloud services, but small TPUs can also be accessed directly for free through Google Colab and Kaggle Kernels.\n\nBecause [all TensorFlow models in \ud83e\udd17 Transformers are Keras models](https://huggingface.co/blog/tensorflow-philosophy), most of the methods in this document are generally applicable to TPU training for any Keras model! However, there are a few points that are specific to the HuggingFace ecosystem (hug-o-system?) of Transformers and Datasets, and we\u2019ll make sure to flag them up when we get to them.\n\n### What kinds of TPU are available?\n\nNew users are often very confused by the range of TPUs, and the different ways to access them. The first key distinction to understand is the difference between **TPU Nodes** and **TPU VMs.**\n\nWhen you use a **TPU Node**, you are effectively indirectly accessing a remote TPU. You will need a separate VM, which will initialize your network and data pipeline and then forward them to the remote node. When you use a TPU on Google Colab, you are accessing it in the **TPU Node** style.\n\nUsing TPU Nodes can have some quite unexpected behaviour for people who aren\u2019t used to them! In particular, because the TPU is located on a physically different system to the machine you\u2019re running your Python code on, your data cannot be local to your machine - any data pipeline that loads from your machine\u2019s internal storage will totally fail! Instead, data must be stored in Google Cloud Storage where your data pipeline can still access it, even when the pipeline is running on the remote TPU node.\n\n<Tip>\n\nIf you can fit all your data in memory as `np.ndarray` or `tf.Tensor`, then you can `fit()` on that data even when using Colab or a TPU Node, without needing to upload it to Google Cloud Storage.\n\n</Tip>\n\n<Tip>\n\n**\ud83e\udd17Specific Hugging Face Tip\ud83e\udd17:** The methods `Dataset.to_tf_dataset()` and its higher-level wrapper `model.prepare_tf_dataset()` , which you will see throughout our TF code examples, will both fail on a TPU Node. The reason for this is that even though they create a `tf.data.Dataset` it is not a \u201cpure\u201d `tf.data` pipeline and uses `tf.numpy_function` or `Dataset.from_generator()` to stream data from the underlying HuggingFace `Dataset`. This HuggingFace `Dataset` is backed by data that is on a local disc and which the remote TPU Node will not be able to read.\n\n</Tip>\n\nThe second way to access a TPU is via a **TPU VM.** When using a TPU VM, you connect directly to the machine that the TPU is attached to, much like training on a GPU VM. TPU VMs are generally easier to work with, particularly when it comes to your data pipeline. All of the above warnings do not apply to TPU VMs!\n\nThis is an opinionated document, so here\u2019s our opinion: **Avoid using TPU Node if possible.** It is more confusing and more difficult to debug than TPU VMs. It is also likely to be unsupported in future - Google\u2019s latest TPU, TPUv4, can only be accessed as a TPU VM, which suggests that TPU Nodes are increasingly going to become a \u201clegacy\u201d access method."
            }
        ]
    },
    {
        "context": "</Tip>\n\nThe second way to access a TPU is via a **TPU VM.** When using a TPU VM, you connect directly to the machine that the TPU is attached to, much like training on a GPU VM. TPU VMs are generally easier to work with, particularly when it comes to your data pipeline. All of the above warnings do not apply to TPU VMs!\n\nThis is an opinionated document, so here\u2019s our opinion: **Avoid using TPU Node if possible.** It is more confusing and more difficult to debug than TPU VMs. It is also likely to be unsupported in future - Google\u2019s latest TPU, TPUv4, can only be accessed as a TPU VM, which suggests that TPU Nodes are increasingly going to become a \u201clegacy\u201d access method. However, we understand that the only free TPU access is on Colab and Kaggle Kernels, which uses TPU Node - so we\u2019ll try to explain how to handle it if you have to! Check the [TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) for code samples that explain this in more detail.\n\n### What sizes of TPU are available?\n\nA single TPU (a v2-8/v3-8/v4-8) runs 8 replicas. TPUs exist in **pods** that can run hundreds or thousands of replicas simultaneously. When you use more than a single TPU but less than a whole pod (for example, a v3-32), your TPU fleet is referred to as a **pod slice.**\n\nWhen you access a free TPU via Colab, you generally get a single v2-8 TPU.\n\n### I keep hearing about this XLA thing. What\u2019s XLA, and how does it relate to TPUs?\n\nXLA is an optimizing compiler, used by both TensorFlow and JAX. In JAX it is the only compiler, whereas in TensorFlow it is optional (but mandatory on TPU!). The easiest way to enable it when training a Keras model is to pass the argument `jit_compile=True` to `model.compile()`. If you don\u2019t get any errors and performance is good, that\u2019s a great sign that you\u2019re ready to move to TPU!",
        "question": "How many replicas can a single TPU run?",
        "answer": "A single TPU can run 8 replicas.",
        "source_doc": "huggingface/transformers/blob/main/docs/source/en/perf_train_tpu_tf.md",
        "rag_answer": null,
        "rag_context": null,
        "rag_score": null,
        "rag_feedback": null
    },
    {
        "sample_idx": 52,
        "question": "What is a pod in the context of TPUs?",
        "answer": "A pod is a group of TPUs that can run hundreds or thousands of replicas simultaneously.",
        "rag_answer": "A pod is a unit that can run hundreds or thousands of replicas simultaneously.",
        "rag_score": 3,
        "rag_feedback": "The system's response is somewhat correct, accurate, and factual. It mentions that a pod can run hundreds or thousands of replicas simultaneously, which is in line with the expected answer. However, it does not explicitly state that a pod is a group of TPUs, which is a crucial part of the expected answer.",
        "rag_context": [
            {
                "score": 0.7218763832108102,
                "node_text": "Here are some facts extracted from the provided text:\n\nPods -> Can run -> Hundreds or thousands of replicas\nTpuv4 -> Can be accessed as -> Tpu vm\nTpu vm -> Is -> Machine\nTpu vm -> Is -> Machine with tpu attached\nTpu vm -> Connects to -> Tpu\nTpu node -> Is -> Remote tpu\n\n</Tip>\n\nThe second way to access a TPU is via a **TPU VM.** When using a TPU VM, you connect directly to the machine that the TPU is attached to, much like training on a GPU VM. TPU VMs are generally easier to work with, particularly when it comes to your data pipeline. All of the above warnings do not apply to TPU VMs!\n\nThis is an opinionated document, so here\u2019s our opinion: **Avoid using TPU Node if possible.** It is more confusing and more difficult to debug than TPU VMs. It is also likely to be unsupported in future - Google\u2019s latest TPU, TPUv4, can only be accessed as a TPU VM, which suggests that TPU Nodes are increasingly going to become a \u201clegacy\u201d access method. However, we understand that the only free TPU access is on Colab and Kaggle Kernels, which uses TPU Node - so we\u2019ll try to explain how to handle it if you have to! Check the [TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) for code samples that explain this in more detail.\n\n### What sizes of TPU are available?\n\nA single TPU (a v2-8/v3-8/v4-8) runs 8 replicas. TPUs exist in **pods** that can run hundreds or thousands of replicas simultaneously. When you use more than a single TPU but less than a whole pod (for example, a v3-32), your TPU fleet is referred to as a **pod slice.**\n\nWhen you access a free TPU via Colab, you generally get a single v2-8 TPU.\n\n### I keep hearing about this XLA thing. What\u2019s XLA, and how does it relate to TPUs?\n\nXLA is an optimizing compiler, used by both TensorFlow and JAX. In JAX it is the only compiler, whereas in TensorFlow it is optional (but mandatory on TPU!). The easiest way to enable it when training a Keras model is to pass the argument `jit_compile=True` to `model.compile()`. If you don\u2019t get any errors and performance is good, that\u2019s a great sign that you\u2019re ready to move to TPU!\n\nDebugging on TPU is generally a bit harder than on CPU/GPU, so we recommend getting your code running on CPU/GPU with XLA first before trying it on TPU. You don\u2019t have to train for long, of course - just for a few steps to make sure that your model and data pipeline are working like you expect them to.\n\n<Tip>\n\nXLA compiled code is usually faster - so even if you\u2019re not planning to run on TPU, adding `jit_compile=True` can improve your performance. Be sure to note the caveats below about XLA compatibility, though!\n\n</Tip>\n\n<Tip warning={true}>\n\n**Tip born of painful experience:** Although using `jit_compile=True` is a good way to get a speed boost and test if your CPU/GPU code is XLA-compatible, it can actually cause a lot of problems if you leave it in when actually training on TPU. XLA compilation will happen implicitly on TPU, so remember to remove that line before actually running your code on a TPU!\n\n</Tip>\n\n### How do I make my model XLA compatible?\n\nIn many cases, your code is probably XLA-compatible already! However, there are a few things that work in normal TensorFlow that don\u2019t work in XLA. We\u2019ve distilled them into three core rules below:\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** We\u2019ve put a lot of effort into rewriting our TensorFlow models and loss functions to be XLA-compatible. Our models and loss functions generally obey rule #1 and #2 by default, so you can skip over them if you\u2019re using `transformers` models. Don\u2019t forget about these rules when writing your own models and loss functions, though!\n\n</Tip>\n\n#### XLA Rule #1: Your code cannot have \u201cdata-dependent conditionals\u201d\n\nWhat that means is that any `if` statement cannot depend on values inside a `tf.Tensor`. For example, this code block cannot be compiled with XLA!\n\n```python\nif tf.reduce_sum(tensor) > 10:\n    tensor = tensor / 2.0\n```\n\nThis might seem very restrictive at first, but most neural net code doesn\u2019t need to do this."
            },
            {
                "score": 0.7218763832108102,
                "node_text": "Here are some facts extracted from the provided text:\n\nTpu -> Exists in -> Pods\n\nThis is a really useful trick, so remember it if you need to convert your own code to XLA!\n\n#### XLA Rule #3: XLA will need to recompile your model for every different input shape it sees\n\nThis is the big one. What this means is that if your input shapes are very variable, XLA will have to recompile your model over and over, which will create huge performance problems. This commonly arises in NLP models, where input texts have variable lengths after tokenization. In other modalities, static shapes are more common and this rule is much less of a problem.\n\nHow can you get around rule #3? The key is **padding** - if you pad all your inputs to the same length, and then use an `attention_mask`, you can get the same results as you\u2019d get from variable shapes, but without any XLA issues. However, excessive padding can cause severe slowdown too - if you pad all your samples to the maximum length in the whole dataset, you might end up with batches consisting endless padding tokens, which will waste a lot of compute and memory!\n\nThere isn\u2019t a perfect solution to this problem. However, you can try some tricks. One very useful trick is to **pad batches of samples up to a multiple of a number like 32 or 64 tokens.** This often only increases the number of tokens by a small amount, but it hugely reduces the number of unique input shapes, because every input shape now has to be a multiple of 32 or 64. Fewer unique input shapes means fewer XLA compilations!\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** Our tokenizers and data collators have methods that can help you here. You can use `padding=\"max_length\"` or `padding=\"longest\"` when calling tokenizers to get them to output padded data. Our tokenizers and data collators also have a `pad_to_multiple_of` argument that you can use to reduce the number of unique input shapes you see!\n\n</Tip>\n\n### How do I actually train my model on TPU?\n\nOnce your training is XLA-compatible and (if you\u2019re using TPU Node / Colab) your dataset has been prepared appropriately, running on TPU is surprisingly easy! All you really need to change in your code is to add a few lines to initialize your TPU, and to ensure that your model and dataset are created inside a `TPUStrategy` scope. Take a look at [our TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) to see this in action!\n\n### Summary\n\nThere was a lot in here, so let\u2019s summarize with a quick checklist you can follow when you want to get your model ready for TPU training:\n\n- Make sure your code follows the three rules of XLA\n- Compile your model with `jit_compile=True` on CPU/GPU and confirm that you can train it with XLA\n- Either load your dataset into memory or use a TPU-compatible dataset loading approach (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Migrate your code either to Colab (with accelerator set to \u201cTPU\u201d) or a TPU VM on Google Cloud\n- Add TPU initializer code (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Create your `TPUStrategy` and make sure dataset loading and model creation are inside the `strategy.scope()` (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Don\u2019t forget to take `jit_compile=True` out again when you move to TPU!\n- \ud83d\ude4f\ud83d\ude4f\ud83d\ude4f\ud83e\udd7a\ud83e\udd7a\ud83e\udd7a\n- Call model.fit()\n- You did it!"
            }
        ]
    },
    {
        "sample_idx": 53,
        "question": "What is a pod slice in the context of TPUs?",
        "answer": "A pod slice is a TPU fleet that uses more than a single TPU but less than a whole pod.",
        "rag_answer": "A pod slice is a TPU fleet that consists of more than a single TPU but less than a whole pod.",
        "rag_score": 5,
        "rag_feedback": "The system's response is completely correct, accurate, and factual. It provides a precise definition of a pod slice in the context of TPUs, which matches the expected answer.",
        "rag_context": [
            {
                "score": 0.7124430697702355,
                "node_text": "Here are some facts extracted from the provided text:\n\nPods -> Can run -> Hundreds or thousands of replicas\nTpuv4 -> Can be accessed as -> Tpu vm\nTpu node -> Is -> Remote tpu\nTpu vm -> Is -> Machine\nTpu vm -> Is -> Machine with tpu attached\nTpu vm -> Connects to -> Tpu\n\n</Tip>\n\nThe second way to access a TPU is via a **TPU VM.** When using a TPU VM, you connect directly to the machine that the TPU is attached to, much like training on a GPU VM. TPU VMs are generally easier to work with, particularly when it comes to your data pipeline. All of the above warnings do not apply to TPU VMs!\n\nThis is an opinionated document, so here\u2019s our opinion: **Avoid using TPU Node if possible.** It is more confusing and more difficult to debug than TPU VMs. It is also likely to be unsupported in future - Google\u2019s latest TPU, TPUv4, can only be accessed as a TPU VM, which suggests that TPU Nodes are increasingly going to become a \u201clegacy\u201d access method. However, we understand that the only free TPU access is on Colab and Kaggle Kernels, which uses TPU Node - so we\u2019ll try to explain how to handle it if you have to! Check the [TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) for code samples that explain this in more detail.\n\n### What sizes of TPU are available?\n\nA single TPU (a v2-8/v3-8/v4-8) runs 8 replicas. TPUs exist in **pods** that can run hundreds or thousands of replicas simultaneously. When you use more than a single TPU but less than a whole pod (for example, a v3-32), your TPU fleet is referred to as a **pod slice.**\n\nWhen you access a free TPU via Colab, you generally get a single v2-8 TPU.\n\n### I keep hearing about this XLA thing. What\u2019s XLA, and how does it relate to TPUs?\n\nXLA is an optimizing compiler, used by both TensorFlow and JAX. In JAX it is the only compiler, whereas in TensorFlow it is optional (but mandatory on TPU!). The easiest way to enable it when training a Keras model is to pass the argument `jit_compile=True` to `model.compile()`. If you don\u2019t get any errors and performance is good, that\u2019s a great sign that you\u2019re ready to move to TPU!\n\nDebugging on TPU is generally a bit harder than on CPU/GPU, so we recommend getting your code running on CPU/GPU with XLA first before trying it on TPU. You don\u2019t have to train for long, of course - just for a few steps to make sure that your model and data pipeline are working like you expect them to.\n\n<Tip>\n\nXLA compiled code is usually faster - so even if you\u2019re not planning to run on TPU, adding `jit_compile=True` can improve your performance. Be sure to note the caveats below about XLA compatibility, though!\n\n</Tip>\n\n<Tip warning={true}>\n\n**Tip born of painful experience:** Although using `jit_compile=True` is a good way to get a speed boost and test if your CPU/GPU code is XLA-compatible, it can actually cause a lot of problems if you leave it in when actually training on TPU. XLA compilation will happen implicitly on TPU, so remember to remove that line before actually running your code on a TPU!\n\n</Tip>\n\n### How do I make my model XLA compatible?\n\nIn many cases, your code is probably XLA-compatible already! However, there are a few things that work in normal TensorFlow that don\u2019t work in XLA. We\u2019ve distilled them into three core rules below:\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** We\u2019ve put a lot of effort into rewriting our TensorFlow models and loss functions to be XLA-compatible. Our models and loss functions generally obey rule #1 and #2 by default, so you can skip over them if you\u2019re using `transformers` models. Don\u2019t forget about these rules when writing your own models and loss functions, though!\n\n</Tip>\n\n#### XLA Rule #1: Your code cannot have \u201cdata-dependent conditionals\u201d\n\nWhat that means is that any `if` statement cannot depend on values inside a `tf.Tensor`. For example, this code block cannot be compiled with XLA!\n\n```python\nif tf.reduce_sum(tensor) > 10:\n    tensor = tensor / 2.0\n```\n\nThis might seem very restrictive at first, but most neural net code doesn\u2019t need to do this."
            },
            {
                "score": 0.7124430697702355,
                "node_text": "Here are some facts extracted from the provided text:\n\nTpu -> Exists in -> Pods\n\nThis is a really useful trick, so remember it if you need to convert your own code to XLA!\n\n#### XLA Rule #3: XLA will need to recompile your model for every different input shape it sees\n\nThis is the big one. What this means is that if your input shapes are very variable, XLA will have to recompile your model over and over, which will create huge performance problems. This commonly arises in NLP models, where input texts have variable lengths after tokenization. In other modalities, static shapes are more common and this rule is much less of a problem.\n\nHow can you get around rule #3? The key is **padding** - if you pad all your inputs to the same length, and then use an `attention_mask`, you can get the same results as you\u2019d get from variable shapes, but without any XLA issues. However, excessive padding can cause severe slowdown too - if you pad all your samples to the maximum length in the whole dataset, you might end up with batches consisting endless padding tokens, which will waste a lot of compute and memory!\n\nThere isn\u2019t a perfect solution to this problem. However, you can try some tricks. One very useful trick is to **pad batches of samples up to a multiple of a number like 32 or 64 tokens.** This often only increases the number of tokens by a small amount, but it hugely reduces the number of unique input shapes, because every input shape now has to be a multiple of 32 or 64. Fewer unique input shapes means fewer XLA compilations!\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** Our tokenizers and data collators have methods that can help you here. You can use `padding=\"max_length\"` or `padding=\"longest\"` when calling tokenizers to get them to output padded data. Our tokenizers and data collators also have a `pad_to_multiple_of` argument that you can use to reduce the number of unique input shapes you see!\n\n</Tip>\n\n### How do I actually train my model on TPU?\n\nOnce your training is XLA-compatible and (if you\u2019re using TPU Node / Colab) your dataset has been prepared appropriately, running on TPU is surprisingly easy! All you really need to change in your code is to add a few lines to initialize your TPU, and to ensure that your model and dataset are created inside a `TPUStrategy` scope. Take a look at [our TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) to see this in action!\n\n### Summary\n\nThere was a lot in here, so let\u2019s summarize with a quick checklist you can follow when you want to get your model ready for TPU training:\n\n- Make sure your code follows the three rules of XLA\n- Compile your model with `jit_compile=True` on CPU/GPU and confirm that you can train it with XLA\n- Either load your dataset into memory or use a TPU-compatible dataset loading approach (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Migrate your code either to Colab (with accelerator set to \u201cTPU\u201d) or a TPU VM on Google Cloud\n- Add TPU initializer code (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Create your `TPUStrategy` and make sure dataset loading and model creation are inside the `strategy.scope()` (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Don\u2019t forget to take `jit_compile=True` out again when you move to TPU!\n- \ud83d\ude4f\ud83d\ude4f\ud83d\ude4f\ud83e\udd7a\ud83e\udd7a\ud83e\udd7a\n- Call model.fit()\n- You did it!"
            }
        ]
    },
    {
        "sample_idx": 54,
        "question": "What type of TPU is typically provided for free via Colab?",
        "answer": "A single v2-8 TPU is typically provided for free via Colab.",
        "rag_answer": "A single v2-8 TPU.",
        "rag_score": 3,
        "rag_feedback": "The system's response is somewhat correct, accurate, and factual. It provides a relevant answer, but it is not a direct answer to the question. The response is a passage from a text that discusses TPUs, but it does not directly state that a single v2-8 TPU is typically provided for free via Colab.",
        "rag_context": [
            {
                "score": 1.0,
                "node_text": "Here are some facts extracted from the provided text:\n\nTpu -> Is -> Tensor processing unit\n\nThis is a really useful trick, so remember it if you need to convert your own code to XLA!\n\n#### XLA Rule #3: XLA will need to recompile your model for every different input shape it sees\n\nThis is the big one. What this means is that if your input shapes are very variable, XLA will have to recompile your model over and over, which will create huge performance problems. This commonly arises in NLP models, where input texts have variable lengths after tokenization. In other modalities, static shapes are more common and this rule is much less of a problem.\n\nHow can you get around rule #3? The key is **padding** - if you pad all your inputs to the same length, and then use an `attention_mask`, you can get the same results as you\u2019d get from variable shapes, but without any XLA issues. However, excessive padding can cause severe slowdown too - if you pad all your samples to the maximum length in the whole dataset, you might end up with batches consisting endless padding tokens, which will waste a lot of compute and memory!\n\nThere isn\u2019t a perfect solution to this problem. However, you can try some tricks. One very useful trick is to **pad batches of samples up to a multiple of a number like 32 or 64 tokens.** This often only increases the number of tokens by a small amount, but it hugely reduces the number of unique input shapes, because every input shape now has to be a multiple of 32 or 64. Fewer unique input shapes means fewer XLA compilations!\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** Our tokenizers and data collators have methods that can help you here. You can use `padding=\"max_length\"` or `padding=\"longest\"` when calling tokenizers to get them to output padded data. Our tokenizers and data collators also have a `pad_to_multiple_of` argument that you can use to reduce the number of unique input shapes you see!\n\n</Tip>\n\n### How do I actually train my model on TPU?\n\nOnce your training is XLA-compatible and (if you\u2019re using TPU Node / Colab) your dataset has been prepared appropriately, running on TPU is surprisingly easy! All you really need to change in your code is to add a few lines to initialize your TPU, and to ensure that your model and dataset are created inside a `TPUStrategy` scope. Take a look at [our TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) to see this in action!\n\n### Summary\n\nThere was a lot in here, so let\u2019s summarize with a quick checklist you can follow when you want to get your model ready for TPU training:\n\n- Make sure your code follows the three rules of XLA\n- Compile your model with `jit_compile=True` on CPU/GPU and confirm that you can train it with XLA\n- Either load your dataset into memory or use a TPU-compatible dataset loading approach (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Migrate your code either to Colab (with accelerator set to \u201cTPU\u201d) or a TPU VM on Google Cloud\n- Add TPU initializer code (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Create your `TPUStrategy` and make sure dataset loading and model creation are inside the `strategy.scope()` (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Don\u2019t forget to take `jit_compile=True` out again when you move to TPU!\n- \ud83d\ude4f\ud83d\ude4f\ud83d\ude4f\ud83e\udd7a\ud83e\udd7a\ud83e\udd7a\n- Call model.fit()\n- You did it!"
            },
            {
                "score": 0.7239413238097833,
                "node_text": "Here are some facts extracted from the provided text:\n\nTpu -> Is used -> For training\nXla -> Is mandatory on -> Tpu\nTpu -> Accessed through -> Google's cloud services\nTpu -> Is -> Tensor processing unit\nTpu -> Used for -> Neural networks\nTpu -> Exists in -> Pods\n\nThis is a really useful trick, so remember it if you need to convert your own code to XLA!\n\n#### XLA Rule #3: XLA will need to recompile your model for every different input shape it sees\n\nThis is the big one. What this means is that if your input shapes are very variable, XLA will have to recompile your model over and over, which will create huge performance problems. This commonly arises in NLP models, where input texts have variable lengths after tokenization. In other modalities, static shapes are more common and this rule is much less of a problem.\n\nHow can you get around rule #3? The key is **padding** - if you pad all your inputs to the same length, and then use an `attention_mask`, you can get the same results as you\u2019d get from variable shapes, but without any XLA issues. However, excessive padding can cause severe slowdown too - if you pad all your samples to the maximum length in the whole dataset, you might end up with batches consisting endless padding tokens, which will waste a lot of compute and memory!\n\nThere isn\u2019t a perfect solution to this problem. However, you can try some tricks. One very useful trick is to **pad batches of samples up to a multiple of a number like 32 or 64 tokens.** This often only increases the number of tokens by a small amount, but it hugely reduces the number of unique input shapes, because every input shape now has to be a multiple of 32 or 64. Fewer unique input shapes means fewer XLA compilations!\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** Our tokenizers and data collators have methods that can help you here. You can use `padding=\"max_length\"` or `padding=\"longest\"` when calling tokenizers to get them to output padded data. Our tokenizers and data collators also have a `pad_to_multiple_of` argument that you can use to reduce the number of unique input shapes you see!\n\n</Tip>\n\n### How do I actually train my model on TPU?\n\nOnce your training is XLA-compatible and (if you\u2019re using TPU Node / Colab) your dataset has been prepared appropriately, running on TPU is surprisingly easy! All you really need to change in your code is to add a few lines to initialize your TPU, and to ensure that your model and dataset are created inside a `TPUStrategy` scope. Take a look at [our TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) to see this in action!\n\n### Summary\n\nThere was a lot in here, so let\u2019s summarize with a quick checklist you can follow when you want to get your model ready for TPU training:\n\n- Make sure your code follows the three rules of XLA\n- Compile your model with `jit_compile=True` on CPU/GPU and confirm that you can train it with XLA\n- Either load your dataset into memory or use a TPU-compatible dataset loading approach (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Migrate your code either to Colab (with accelerator set to \u201cTPU\u201d) or a TPU VM on Google Cloud\n- Add TPU initializer code (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Create your `TPUStrategy` and make sure dataset loading and model creation are inside the `strategy.scope()` (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Don\u2019t forget to take `jit_compile=True` out again when you move to TPU!\n- \ud83d\ude4f\ud83d\ude4f\ud83d\ude4f\ud83e\udd7a\ud83e\udd7a\ud83e\udd7a\n- Call model.fit()\n- You did it!"
            },
            {
                "score": 0.7239413238097833,
                "node_text": "Here are some facts extracted from the provided text:\n\nGoogle -> Designed -> Tpu\n\n!--Copyright 2023 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\nthe License. You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under the License is distributed on\nan \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n\n\u26a0\ufe0f Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be\nrendered properly in your Markdown viewer.\n\n-->\n\n# Training on TPU with TensorFlow\n\n<Tip>\n\nIf you don't need long explanations and just want TPU code samples to get started with, check out [our TPU example notebook!](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb)\n\n</Tip>\n\n### What is a TPU?\n\nA TPU is a **Tensor Processing Unit.** They are hardware designed by Google, which are used to greatly speed up the tensor computations within neural networks, much like GPUs. They can be used for both network training and inference. They are generally accessed through Google\u2019s cloud services, but small TPUs can also be accessed directly for free through Google Colab and Kaggle Kernels.\n\nBecause [all TensorFlow models in \ud83e\udd17 Transformers are Keras models](https://huggingface.co/blog/tensorflow-philosophy), most of the methods in this document are generally applicable to TPU training for any Keras model! However, there are a few points that are specific to the HuggingFace ecosystem (hug-o-system?) of Transformers and Datasets, and we\u2019ll make sure to flag them up when we get to them.\n\n### What kinds of TPU are available?\n\nNew users are often very confused by the range of TPUs, and the different ways to access them. The first key distinction to understand is the difference between **TPU Nodes** and **TPU VMs.**\n\nWhen you use a **TPU Node**, you are effectively indirectly accessing a remote TPU. You will need a separate VM, which will initialize your network and data pipeline and then forward them to the remote node. When you use a TPU on Google Colab, you are accessing it in the **TPU Node** style.\n\nUsing TPU Nodes can have some quite unexpected behaviour for people who aren\u2019t used to them! In particular, because the TPU is located on a physically different system to the machine you\u2019re running your Python code on, your data cannot be local to your machine - any data pipeline that loads from your machine\u2019s internal storage will totally fail! Instead, data must be stored in Google Cloud Storage where your data pipeline can still access it, even when the pipeline is running on the remote TPU node.\n\n<Tip>\n\nIf you can fit all your data in memory as `np.ndarray` or `tf.Tensor`, then you can `fit()` on that data even when using Colab or a TPU Node, without needing to upload it to Google Cloud Storage.\n\n</Tip>\n\n<Tip>\n\n**\ud83e\udd17Specific Hugging Face Tip\ud83e\udd17:** The methods `Dataset.to_tf_dataset()` and its higher-level wrapper `model.prepare_tf_dataset()` , which you will see throughout our TF code examples, will both fail on a TPU Node. The reason for this is that even though they create a `tf.data.Dataset` it is not a \u201cpure\u201d `tf.data` pipeline and uses `tf.numpy_function` or `Dataset.from_generator()` to stream data from the underlying HuggingFace `Dataset`. This HuggingFace `Dataset` is backed by data that is on a local disc and which the remote TPU Node will not be able to read.\n\n</Tip>\n\nThe second way to access a TPU is via a **TPU VM.** When using a TPU VM, you connect directly to the machine that the TPU is attached to, much like training on a GPU VM. TPU VMs are generally easier to work with, particularly when it comes to your data pipeline. All of the above warnings do not apply to TPU VMs!\n\nThis is an opinionated document, so here\u2019s our opinion: **Avoid using TPU Node if possible.** It is more confusing and more difficult to debug than TPU VMs. It is also likely to be unsupported in future - Google\u2019s latest TPU, TPUv4, can only be accessed as a TPU VM, which suggests that TPU Nodes are increasingly going to become a \u201clegacy\u201d access method."
            },
            {
                "score": 0.7239413238097833,
                "node_text": "Here are some facts extracted from the provided text:\n\nTpu vm -> Connects to -> Tpu\nTpu vm -> Is -> Machine with tpu attached\nTpu node -> Is -> Difficult to debug\nTpu node -> Is -> Confusing\nTpu node -> Is -> Remote tpu\nTpuv4 -> Can be accessed as -> Tpu vm\nTpu vm -> Is -> Machine\n\n</Tip>\n\nThe second way to access a TPU is via a **TPU VM.** When using a TPU VM, you connect directly to the machine that the TPU is attached to, much like training on a GPU VM. TPU VMs are generally easier to work with, particularly when it comes to your data pipeline. All of the above warnings do not apply to TPU VMs!\n\nThis is an opinionated document, so here\u2019s our opinion: **Avoid using TPU Node if possible.** It is more confusing and more difficult to debug than TPU VMs. It is also likely to be unsupported in future - Google\u2019s latest TPU, TPUv4, can only be accessed as a TPU VM, which suggests that TPU Nodes are increasingly going to become a \u201clegacy\u201d access method. However, we understand that the only free TPU access is on Colab and Kaggle Kernels, which uses TPU Node - so we\u2019ll try to explain how to handle it if you have to! Check the [TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) for code samples that explain this in more detail.\n\n### What sizes of TPU are available?\n\nA single TPU (a v2-8/v3-8/v4-8) runs 8 replicas. TPUs exist in **pods** that can run hundreds or thousands of replicas simultaneously. When you use more than a single TPU but less than a whole pod (for example, a v3-32), your TPU fleet is referred to as a **pod slice.**\n\nWhen you access a free TPU via Colab, you generally get a single v2-8 TPU.\n\n### I keep hearing about this XLA thing. What\u2019s XLA, and how does it relate to TPUs?\n\nXLA is an optimizing compiler, used by both TensorFlow and JAX. In JAX it is the only compiler, whereas in TensorFlow it is optional (but mandatory on TPU!). The easiest way to enable it when training a Keras model is to pass the argument `jit_compile=True` to `model.compile()`. If you don\u2019t get any errors and performance is good, that\u2019s a great sign that you\u2019re ready to move to TPU!\n\nDebugging on TPU is generally a bit harder than on CPU/GPU, so we recommend getting your code running on CPU/GPU with XLA first before trying it on TPU. You don\u2019t have to train for long, of course - just for a few steps to make sure that your model and data pipeline are working like you expect them to.\n\n<Tip>\n\nXLA compiled code is usually faster - so even if you\u2019re not planning to run on TPU, adding `jit_compile=True` can improve your performance. Be sure to note the caveats below about XLA compatibility, though!\n\n</Tip>\n\n<Tip warning={true}>\n\n**Tip born of painful experience:** Although using `jit_compile=True` is a good way to get a speed boost and test if your CPU/GPU code is XLA-compatible, it can actually cause a lot of problems if you leave it in when actually training on TPU. XLA compilation will happen implicitly on TPU, so remember to remove that line before actually running your code on a TPU!\n\n</Tip>\n\n### How do I make my model XLA compatible?\n\nIn many cases, your code is probably XLA-compatible already! However, there are a few things that work in normal TensorFlow that don\u2019t work in XLA. We\u2019ve distilled them into three core rules below:\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** We\u2019ve put a lot of effort into rewriting our TensorFlow models and loss functions to be XLA-compatible. Our models and loss functions generally obey rule #1 and #2 by default, so you can skip over them if you\u2019re using `transformers` models. Don\u2019t forget about these rules when writing your own models and loss functions, though!\n\n</Tip>\n\n#### XLA Rule #1: Your code cannot have \u201cdata-dependent conditionals\u201d\n\nWhat that means is that any `if` statement cannot depend on values inside a `tf.Tensor`. For example, this code block cannot be compiled with XLA!\n\n```python\nif tf.reduce_sum(tensor) > 10:\n    tensor = tensor / 2.0\n```\n\nThis might seem very restrictive at first, but most neural net code doesn\u2019t need to do this."
            }
        ]
    },
    {
        "sample_idx": 55,
        "question": "What is XLA?",
        "answer": "XLA is an optimizing compiler used by both TensorFlow and JAX.",
        "rag_answer": "XLA is an optimizing compiler.",
        "rag_score": 3,
        "rag_feedback": "The system's response is partially correct, it mentions that XLA is an optimizing compiler, but it does not provide the complete information that it is used by both TensorFlow and JAX.",
        "rag_context": [
            {
                "score": 0.780883372484588,
                "node_text": "Here are some facts extracted from the provided text:\n\nPadding -> Helps -> Xla issues\nPadding -> Helps -> Avoid xla issues\nXla -> Is -> Optimizing compiler\nXla -> Is used by -> Tensorflow and jax\nXla -> Is mandatory on -> Tpu\nXla -> Recompile -> Model\nXla -> Has -> Rule #1\nXla -> Has -> Rule #2\nXla -> Needs -> Recompile\nXla -> Has -> Rule #3\n\nThis is a really useful trick, so remember it if you need to convert your own code to XLA!\n\n#### XLA Rule #3: XLA will need to recompile your model for every different input shape it sees\n\nThis is the big one. What this means is that if your input shapes are very variable, XLA will have to recompile your model over and over, which will create huge performance problems. This commonly arises in NLP models, where input texts have variable lengths after tokenization. In other modalities, static shapes are more common and this rule is much less of a problem.\n\nHow can you get around rule #3? The key is **padding** - if you pad all your inputs to the same length, and then use an `attention_mask`, you can get the same results as you\u2019d get from variable shapes, but without any XLA issues. However, excessive padding can cause severe slowdown too - if you pad all your samples to the maximum length in the whole dataset, you might end up with batches consisting endless padding tokens, which will waste a lot of compute and memory!\n\nThere isn\u2019t a perfect solution to this problem. However, you can try some tricks. One very useful trick is to **pad batches of samples up to a multiple of a number like 32 or 64 tokens.** This often only increases the number of tokens by a small amount, but it hugely reduces the number of unique input shapes, because every input shape now has to be a multiple of 32 or 64. Fewer unique input shapes means fewer XLA compilations!\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** Our tokenizers and data collators have methods that can help you here. You can use `padding=\"max_length\"` or `padding=\"longest\"` when calling tokenizers to get them to output padded data. Our tokenizers and data collators also have a `pad_to_multiple_of` argument that you can use to reduce the number of unique input shapes you see!\n\n</Tip>\n\n### How do I actually train my model on TPU?\n\nOnce your training is XLA-compatible and (if you\u2019re using TPU Node / Colab) your dataset has been prepared appropriately, running on TPU is surprisingly easy! All you really need to change in your code is to add a few lines to initialize your TPU, and to ensure that your model and dataset are created inside a `TPUStrategy` scope. Take a look at [our TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) to see this in action!\n\n### Summary\n\nThere was a lot in here, so let\u2019s summarize with a quick checklist you can follow when you want to get your model ready for TPU training:\n\n- Make sure your code follows the three rules of XLA\n- Compile your model with `jit_compile=True` on CPU/GPU and confirm that you can train it with XLA\n- Either load your dataset into memory or use a TPU-compatible dataset loading approach (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Migrate your code either to Colab (with accelerator set to \u201cTPU\u201d) or a TPU VM on Google Cloud\n- Add TPU initializer code (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Create your `TPUStrategy` and make sure dataset loading and model creation are inside the `strategy.scope()` (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Don\u2019t forget to take `jit_compile=True` out again when you move to TPU!\n- \ud83d\ude4f\ud83d\ude4f\ud83d\ude4f\ud83e\udd7a\ud83e\udd7a\ud83e\udd7a\n- Call model.fit()\n- You did it!"
            },
            {
                "score": 0.49769813477230984,
                "node_text": "Here are some facts extracted from the provided text:\n\nFunc -> Takes -> Slider_1\n\nGradio Demo: blocks_random_slider\n\n\n```\n!pip install -q gradio \n```\n\n\n```\n\nimport gradio as gr\n\n\ndef func(slider_1, slider_2):\n    return slider_1 * 5 + slider_2\n\n\nwith gr.Blocks() as demo:\n    slider = gr.Slider(minimum=-10.2, maximum=15, label=\"Random Slider (Static)\", randomize=True)\n    slider_1 = gr.Slider(minimum=100, maximum=200, label=\"Random Slider (Input 1)\", randomize=True)\n    slider_2 = gr.Slider(minimum=10, maximum=23.2, label=\"Random Slider (Input 2)\", randomize=True)\n    slider_3 = gr.Slider(value=3, label=\"Non random slider\")\n    btn = gr.Button(\"Run\")\n    btn.click(func, inputs=[slider_1, slider_2], outputs=gr.Number())\n\nif __name__ == \"__main__\":\n    demo.launch()\n\n```"
            }
        ]
    },
    {
        "sample_idx": 56,
        "question": "How can you enable XLA when training a Keras model?",
        "answer": "You can enable XLA by passing the argument `jit_compile=True` to `model.compile()`.",
        "rag_answer": "You can enable XLA when training a Keras model by compiling your model with `jit_compile=True` on CPU/GPU and confirming that you can train it with XLA.",
        "rag_score": 4,
        "rag_feedback": "The system's response is mostly correct, accurate, and factual. It provides a detailed explanation of how to enable XLA when training a Keras model, including compiling the model with `jit_compile=True` on CPU/GPU and confirming that it can be trained with XLA. However, the response is not a direct answer to the question and includes a lot of additional information that is not relevant to the question.",
        "rag_context": [
            {
                "score": 0.7057418853043336,
                "node_text": "Here are some facts extracted from the provided text:\n\nPadding -> Helps -> Avoid xla issues\nPadding -> Helps -> Xla issues\nXla -> Is -> Optimizing compiler\nXla -> Is used by -> Tensorflow and jax\nXla -> Is mandatory on -> Tpu\nXla -> Recompile -> Model\nXla -> Has -> Rule #1\nXla -> Has -> Rule #2\nXla -> Needs -> Recompile\nXla -> Has -> Rule #3\n\nThis is a really useful trick, so remember it if you need to convert your own code to XLA!\n\n#### XLA Rule #3: XLA will need to recompile your model for every different input shape it sees\n\nThis is the big one. What this means is that if your input shapes are very variable, XLA will have to recompile your model over and over, which will create huge performance problems. This commonly arises in NLP models, where input texts have variable lengths after tokenization. In other modalities, static shapes are more common and this rule is much less of a problem.\n\nHow can you get around rule #3? The key is **padding** - if you pad all your inputs to the same length, and then use an `attention_mask`, you can get the same results as you\u2019d get from variable shapes, but without any XLA issues. However, excessive padding can cause severe slowdown too - if you pad all your samples to the maximum length in the whole dataset, you might end up with batches consisting endless padding tokens, which will waste a lot of compute and memory!\n\nThere isn\u2019t a perfect solution to this problem. However, you can try some tricks. One very useful trick is to **pad batches of samples up to a multiple of a number like 32 or 64 tokens.** This often only increases the number of tokens by a small amount, but it hugely reduces the number of unique input shapes, because every input shape now has to be a multiple of 32 or 64. Fewer unique input shapes means fewer XLA compilations!\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** Our tokenizers and data collators have methods that can help you here. You can use `padding=\"max_length\"` or `padding=\"longest\"` when calling tokenizers to get them to output padded data. Our tokenizers and data collators also have a `pad_to_multiple_of` argument that you can use to reduce the number of unique input shapes you see!\n\n</Tip>\n\n### How do I actually train my model on TPU?\n\nOnce your training is XLA-compatible and (if you\u2019re using TPU Node / Colab) your dataset has been prepared appropriately, running on TPU is surprisingly easy! All you really need to change in your code is to add a few lines to initialize your TPU, and to ensure that your model and dataset are created inside a `TPUStrategy` scope. Take a look at [our TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) to see this in action!\n\n### Summary\n\nThere was a lot in here, so let\u2019s summarize with a quick checklist you can follow when you want to get your model ready for TPU training:\n\n- Make sure your code follows the three rules of XLA\n- Compile your model with `jit_compile=True` on CPU/GPU and confirm that you can train it with XLA\n- Either load your dataset into memory or use a TPU-compatible dataset loading approach (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Migrate your code either to Colab (with accelerator set to \u201cTPU\u201d) or a TPU VM on Google Cloud\n- Add TPU initializer code (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Create your `TPUStrategy` and make sure dataset loading and model creation are inside the `strategy.scope()` (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Don\u2019t forget to take `jit_compile=True` out again when you move to TPU!\n- \ud83d\ude4f\ud83d\ude4f\ud83d\ude4f\ud83e\udd7a\ud83e\udd7a\ud83e\udd7a\n- Call model.fit()\n- You did it!"
            },
            {
                "score": 0.6584289606559243,
                "node_text": "Here are some facts extracted from the provided text:\n\nTensorflow models -> Are -> Keras models\n\n!--Copyright 2023 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\nthe License. You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under the License is distributed on\nan \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n\n\u26a0\ufe0f Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be\nrendered properly in your Markdown viewer.\n\n-->\n\n# Training on TPU with TensorFlow\n\n<Tip>\n\nIf you don't need long explanations and just want TPU code samples to get started with, check out [our TPU example notebook!](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb)\n\n</Tip>\n\n### What is a TPU?\n\nA TPU is a **Tensor Processing Unit.** They are hardware designed by Google, which are used to greatly speed up the tensor computations within neural networks, much like GPUs. They can be used for both network training and inference. They are generally accessed through Google\u2019s cloud services, but small TPUs can also be accessed directly for free through Google Colab and Kaggle Kernels.\n\nBecause [all TensorFlow models in \ud83e\udd17 Transformers are Keras models](https://huggingface.co/blog/tensorflow-philosophy), most of the methods in this document are generally applicable to TPU training for any Keras model! However, there are a few points that are specific to the HuggingFace ecosystem (hug-o-system?) of Transformers and Datasets, and we\u2019ll make sure to flag them up when we get to them.\n\n### What kinds of TPU are available?\n\nNew users are often very confused by the range of TPUs, and the different ways to access them. The first key distinction to understand is the difference between **TPU Nodes** and **TPU VMs.**\n\nWhen you use a **TPU Node**, you are effectively indirectly accessing a remote TPU. You will need a separate VM, which will initialize your network and data pipeline and then forward them to the remote node. When you use a TPU on Google Colab, you are accessing it in the **TPU Node** style.\n\nUsing TPU Nodes can have some quite unexpected behaviour for people who aren\u2019t used to them! In particular, because the TPU is located on a physically different system to the machine you\u2019re running your Python code on, your data cannot be local to your machine - any data pipeline that loads from your machine\u2019s internal storage will totally fail! Instead, data must be stored in Google Cloud Storage where your data pipeline can still access it, even when the pipeline is running on the remote TPU node.\n\n<Tip>\n\nIf you can fit all your data in memory as `np.ndarray` or `tf.Tensor`, then you can `fit()` on that data even when using Colab or a TPU Node, without needing to upload it to Google Cloud Storage.\n\n</Tip>\n\n<Tip>\n\n**\ud83e\udd17Specific Hugging Face Tip\ud83e\udd17:** The methods `Dataset.to_tf_dataset()` and its higher-level wrapper `model.prepare_tf_dataset()` , which you will see throughout our TF code examples, will both fail on a TPU Node. The reason for this is that even though they create a `tf.data.Dataset` it is not a \u201cpure\u201d `tf.data` pipeline and uses `tf.numpy_function` or `Dataset.from_generator()` to stream data from the underlying HuggingFace `Dataset`. This HuggingFace `Dataset` is backed by data that is on a local disc and which the remote TPU Node will not be able to read.\n\n</Tip>\n\nThe second way to access a TPU is via a **TPU VM.** When using a TPU VM, you connect directly to the machine that the TPU is attached to, much like training on a GPU VM. TPU VMs are generally easier to work with, particularly when it comes to your data pipeline. All of the above warnings do not apply to TPU VMs!\n\nThis is an opinionated document, so here\u2019s our opinion: **Avoid using TPU Node if possible.** It is more confusing and more difficult to debug than TPU VMs. It is also likely to be unsupported in future - Google\u2019s latest TPU, TPUv4, can only be accessed as a TPU VM, which suggests that TPU Nodes are increasingly going to become a \u201clegacy\u201d access method."
            }
        ]
    },
    {
        "sample_idx": 57,
        "question": "What is recommended to do before trying to run code on TPU?",
        "answer": "Get your code running on CPU/GPU with XLA first.",
        "rag_answer": "Get your code running on CPU/GPU with XLA first before trying it on TPU.",
        "rag_score": 5,
        "rag_feedback": "The system's response is completely correct, accurate, and factual. It directly answers the question by stating that one should get their code running on CPU/GPU with XLA first before trying it on TPU, which is the expected answer.",
        "rag_context": [
            {
                "score": 0.6970223333666734,
                "node_text": "Here are some facts extracted from the provided text:\n\nTpuv4 -> Can be accessed as -> Tpu vm\nTpu vm -> Is -> Machine\nTpu vm -> Is -> Machine with tpu attached\nTpu vm -> Connects to -> Tpu\nTpu node -> Is -> Difficult to debug\nTpu node -> Is -> Confusing\nTpu node -> Is -> Remote tpu\n\n</Tip>\n\nThe second way to access a TPU is via a **TPU VM.** When using a TPU VM, you connect directly to the machine that the TPU is attached to, much like training on a GPU VM. TPU VMs are generally easier to work with, particularly when it comes to your data pipeline. All of the above warnings do not apply to TPU VMs!\n\nThis is an opinionated document, so here\u2019s our opinion: **Avoid using TPU Node if possible.** It is more confusing and more difficult to debug than TPU VMs. It is also likely to be unsupported in future - Google\u2019s latest TPU, TPUv4, can only be accessed as a TPU VM, which suggests that TPU Nodes are increasingly going to become a \u201clegacy\u201d access method. However, we understand that the only free TPU access is on Colab and Kaggle Kernels, which uses TPU Node - so we\u2019ll try to explain how to handle it if you have to! Check the [TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) for code samples that explain this in more detail.\n\n### What sizes of TPU are available?\n\nA single TPU (a v2-8/v3-8/v4-8) runs 8 replicas. TPUs exist in **pods** that can run hundreds or thousands of replicas simultaneously. When you use more than a single TPU but less than a whole pod (for example, a v3-32), your TPU fleet is referred to as a **pod slice.**\n\nWhen you access a free TPU via Colab, you generally get a single v2-8 TPU.\n\n### I keep hearing about this XLA thing. What\u2019s XLA, and how does it relate to TPUs?\n\nXLA is an optimizing compiler, used by both TensorFlow and JAX. In JAX it is the only compiler, whereas in TensorFlow it is optional (but mandatory on TPU!). The easiest way to enable it when training a Keras model is to pass the argument `jit_compile=True` to `model.compile()`. If you don\u2019t get any errors and performance is good, that\u2019s a great sign that you\u2019re ready to move to TPU!\n\nDebugging on TPU is generally a bit harder than on CPU/GPU, so we recommend getting your code running on CPU/GPU with XLA first before trying it on TPU. You don\u2019t have to train for long, of course - just for a few steps to make sure that your model and data pipeline are working like you expect them to.\n\n<Tip>\n\nXLA compiled code is usually faster - so even if you\u2019re not planning to run on TPU, adding `jit_compile=True` can improve your performance. Be sure to note the caveats below about XLA compatibility, though!\n\n</Tip>\n\n<Tip warning={true}>\n\n**Tip born of painful experience:** Although using `jit_compile=True` is a good way to get a speed boost and test if your CPU/GPU code is XLA-compatible, it can actually cause a lot of problems if you leave it in when actually training on TPU. XLA compilation will happen implicitly on TPU, so remember to remove that line before actually running your code on a TPU!\n\n</Tip>\n\n### How do I make my model XLA compatible?\n\nIn many cases, your code is probably XLA-compatible already! However, there are a few things that work in normal TensorFlow that don\u2019t work in XLA. We\u2019ve distilled them into three core rules below:\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** We\u2019ve put a lot of effort into rewriting our TensorFlow models and loss functions to be XLA-compatible. Our models and loss functions generally obey rule #1 and #2 by default, so you can skip over them if you\u2019re using `transformers` models. Don\u2019t forget about these rules when writing your own models and loss functions, though!\n\n</Tip>\n\n#### XLA Rule #1: Your code cannot have \u201cdata-dependent conditionals\u201d\n\nWhat that means is that any `if` statement cannot depend on values inside a `tf.Tensor`. For example, this code block cannot be compiled with XLA!\n\n```python\nif tf.reduce_sum(tensor) > 10:\n    tensor = tensor / 2.0\n```\n\nThis might seem very restrictive at first, but most neural net code doesn\u2019t need to do this."
            },
            {
                "score": 0.6848967403101867,
                "node_text": "Here are some facts extracted from the provided text:\n\nTpu -> Is used -> For training\nXla -> Is mandatory on -> Tpu\nTpu -> Accessed through -> Google's cloud services\nTpu -> Is -> Tensor processing unit\nTpu -> Used for -> Neural networks\nTpu -> Exists in -> Pods\n\nThis is a really useful trick, so remember it if you need to convert your own code to XLA!\n\n#### XLA Rule #3: XLA will need to recompile your model for every different input shape it sees\n\nThis is the big one. What this means is that if your input shapes are very variable, XLA will have to recompile your model over and over, which will create huge performance problems. This commonly arises in NLP models, where input texts have variable lengths after tokenization. In other modalities, static shapes are more common and this rule is much less of a problem.\n\nHow can you get around rule #3? The key is **padding** - if you pad all your inputs to the same length, and then use an `attention_mask`, you can get the same results as you\u2019d get from variable shapes, but without any XLA issues. However, excessive padding can cause severe slowdown too - if you pad all your samples to the maximum length in the whole dataset, you might end up with batches consisting endless padding tokens, which will waste a lot of compute and memory!\n\nThere isn\u2019t a perfect solution to this problem. However, you can try some tricks. One very useful trick is to **pad batches of samples up to a multiple of a number like 32 or 64 tokens.** This often only increases the number of tokens by a small amount, but it hugely reduces the number of unique input shapes, because every input shape now has to be a multiple of 32 or 64. Fewer unique input shapes means fewer XLA compilations!\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** Our tokenizers and data collators have methods that can help you here. You can use `padding=\"max_length\"` or `padding=\"longest\"` when calling tokenizers to get them to output padded data. Our tokenizers and data collators also have a `pad_to_multiple_of` argument that you can use to reduce the number of unique input shapes you see!\n\n</Tip>\n\n### How do I actually train my model on TPU?\n\nOnce your training is XLA-compatible and (if you\u2019re using TPU Node / Colab) your dataset has been prepared appropriately, running on TPU is surprisingly easy! All you really need to change in your code is to add a few lines to initialize your TPU, and to ensure that your model and dataset are created inside a `TPUStrategy` scope. Take a look at [our TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) to see this in action!\n\n### Summary\n\nThere was a lot in here, so let\u2019s summarize with a quick checklist you can follow when you want to get your model ready for TPU training:\n\n- Make sure your code follows the three rules of XLA\n- Compile your model with `jit_compile=True` on CPU/GPU and confirm that you can train it with XLA\n- Either load your dataset into memory or use a TPU-compatible dataset loading approach (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Migrate your code either to Colab (with accelerator set to \u201cTPU\u201d) or a TPU VM on Google Cloud\n- Add TPU initializer code (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Create your `TPUStrategy` and make sure dataset loading and model creation are inside the `strategy.scope()` (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Don\u2019t forget to take `jit_compile=True` out again when you move to TPU!\n- \ud83d\ude4f\ud83d\ude4f\ud83d\ude4f\ud83e\udd7a\ud83e\udd7a\ud83e\udd7a\n- Call model.fit()\n- You did it!"
            },
            {
                "score": 0.6848967403101867,
                "node_text": "Here are some facts extracted from the provided text:\n\nGoogle -> Designed -> Tpu\n\n!--Copyright 2023 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\nthe License. You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under the License is distributed on\nan \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n\n\u26a0\ufe0f Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be\nrendered properly in your Markdown viewer.\n\n-->\n\n# Training on TPU with TensorFlow\n\n<Tip>\n\nIf you don't need long explanations and just want TPU code samples to get started with, check out [our TPU example notebook!](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb)\n\n</Tip>\n\n### What is a TPU?\n\nA TPU is a **Tensor Processing Unit.** They are hardware designed by Google, which are used to greatly speed up the tensor computations within neural networks, much like GPUs. They can be used for both network training and inference. They are generally accessed through Google\u2019s cloud services, but small TPUs can also be accessed directly for free through Google Colab and Kaggle Kernels.\n\nBecause [all TensorFlow models in \ud83e\udd17 Transformers are Keras models](https://huggingface.co/blog/tensorflow-philosophy), most of the methods in this document are generally applicable to TPU training for any Keras model! However, there are a few points that are specific to the HuggingFace ecosystem (hug-o-system?) of Transformers and Datasets, and we\u2019ll make sure to flag them up when we get to them.\n\n### What kinds of TPU are available?\n\nNew users are often very confused by the range of TPUs, and the different ways to access them. The first key distinction to understand is the difference between **TPU Nodes** and **TPU VMs.**\n\nWhen you use a **TPU Node**, you are effectively indirectly accessing a remote TPU. You will need a separate VM, which will initialize your network and data pipeline and then forward them to the remote node. When you use a TPU on Google Colab, you are accessing it in the **TPU Node** style.\n\nUsing TPU Nodes can have some quite unexpected behaviour for people who aren\u2019t used to them! In particular, because the TPU is located on a physically different system to the machine you\u2019re running your Python code on, your data cannot be local to your machine - any data pipeline that loads from your machine\u2019s internal storage will totally fail! Instead, data must be stored in Google Cloud Storage where your data pipeline can still access it, even when the pipeline is running on the remote TPU node.\n\n<Tip>\n\nIf you can fit all your data in memory as `np.ndarray` or `tf.Tensor`, then you can `fit()` on that data even when using Colab or a TPU Node, without needing to upload it to Google Cloud Storage.\n\n</Tip>\n\n<Tip>\n\n**\ud83e\udd17Specific Hugging Face Tip\ud83e\udd17:** The methods `Dataset.to_tf_dataset()` and its higher-level wrapper `model.prepare_tf_dataset()` , which you will see throughout our TF code examples, will both fail on a TPU Node. The reason for this is that even though they create a `tf.data.Dataset` it is not a \u201cpure\u201d `tf.data` pipeline and uses `tf.numpy_function` or `Dataset.from_generator()` to stream data from the underlying HuggingFace `Dataset`. This HuggingFace `Dataset` is backed by data that is on a local disc and which the remote TPU Node will not be able to read.\n\n</Tip>\n\nThe second way to access a TPU is via a **TPU VM.** When using a TPU VM, you connect directly to the machine that the TPU is attached to, much like training on a GPU VM. TPU VMs are generally easier to work with, particularly when it comes to your data pipeline. All of the above warnings do not apply to TPU VMs!\n\nThis is an opinionated document, so here\u2019s our opinion: **Avoid using TPU Node if possible.** It is more confusing and more difficult to debug than TPU VMs. It is also likely to be unsupported in future - Google\u2019s latest TPU, TPUv4, can only be accessed as a TPU VM, which suggests that TPU Nodes are increasingly going to become a \u201clegacy\u201d access method."
            }
        ]
    },
    {
        "sample_idx": 58,
        "question": "What is the effect of adding jit_compile=True to code?",
        "answer": "XLA compiled code is usually faster.",
        "rag_answer": "The effect of adding `jit_compile=True` to code is that it compiles the model with XLA, which is necessary for TPU training.",
        "rag_score": 4,
        "rag_feedback": "The system's response is mostly correct, accurate, and factual. It provides relevant information about XLA compilation and its requirements, including the need to compile the model with `jit_compile=True` for TPU training. However, the response is not directly answering the question about the effect of adding `jit_compile=True` to code, which is that XLA compiled code is usually faster.",
        "rag_context": [
            {
                "score": 0.6319063061835837,
                "node_text": "Here are some facts extracted from the provided text:\n\nXla -> Is -> Optimizing compiler\nXla -> Needs -> Recompile\n\nThis is a really useful trick, so remember it if you need to convert your own code to XLA!\n\n#### XLA Rule #3: XLA will need to recompile your model for every different input shape it sees\n\nThis is the big one. What this means is that if your input shapes are very variable, XLA will have to recompile your model over and over, which will create huge performance problems. This commonly arises in NLP models, where input texts have variable lengths after tokenization. In other modalities, static shapes are more common and this rule is much less of a problem.\n\nHow can you get around rule #3? The key is **padding** - if you pad all your inputs to the same length, and then use an `attention_mask`, you can get the same results as you\u2019d get from variable shapes, but without any XLA issues. However, excessive padding can cause severe slowdown too - if you pad all your samples to the maximum length in the whole dataset, you might end up with batches consisting endless padding tokens, which will waste a lot of compute and memory!\n\nThere isn\u2019t a perfect solution to this problem. However, you can try some tricks. One very useful trick is to **pad batches of samples up to a multiple of a number like 32 or 64 tokens.** This often only increases the number of tokens by a small amount, but it hugely reduces the number of unique input shapes, because every input shape now has to be a multiple of 32 or 64. Fewer unique input shapes means fewer XLA compilations!\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** Our tokenizers and data collators have methods that can help you here. You can use `padding=\"max_length\"` or `padding=\"longest\"` when calling tokenizers to get them to output padded data. Our tokenizers and data collators also have a `pad_to_multiple_of` argument that you can use to reduce the number of unique input shapes you see!\n\n</Tip>\n\n### How do I actually train my model on TPU?\n\nOnce your training is XLA-compatible and (if you\u2019re using TPU Node / Colab) your dataset has been prepared appropriately, running on TPU is surprisingly easy! All you really need to change in your code is to add a few lines to initialize your TPU, and to ensure that your model and dataset are created inside a `TPUStrategy` scope. Take a look at [our TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) to see this in action!\n\n### Summary\n\nThere was a lot in here, so let\u2019s summarize with a quick checklist you can follow when you want to get your model ready for TPU training:\n\n- Make sure your code follows the three rules of XLA\n- Compile your model with `jit_compile=True` on CPU/GPU and confirm that you can train it with XLA\n- Either load your dataset into memory or use a TPU-compatible dataset loading approach (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Migrate your code either to Colab (with accelerator set to \u201cTPU\u201d) or a TPU VM on Google Cloud\n- Add TPU initializer code (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Create your `TPUStrategy` and make sure dataset loading and model creation are inside the `strategy.scope()` (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Don\u2019t forget to take `jit_compile=True` out again when you move to TPU!\n- \ud83d\ude4f\ud83d\ude4f\ud83d\ude4f\ud83e\udd7a\ud83e\udd7a\ud83e\udd7a\n- Call model.fit()\n- You did it!"
            },
            {
                "score": 0.5738044508533673,
                "node_text": "Here are some facts extracted from the provided text:\n\nRule #3 -> Requires -> Recompilation for different input shapes\n\nWe\u2019ve distilled them into three core rules below:\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** We\u2019ve put a lot of effort into rewriting our TensorFlow models and loss functions to be XLA-compatible. Our models and loss functions generally obey rule #1 and #2 by default, so you can skip over them if you\u2019re using `transformers` models. Don\u2019t forget about these rules when writing your own models and loss functions, though!\n\n</Tip>\n\n#### XLA Rule #1: Your code cannot have \u201cdata-dependent conditionals\u201d\n\nWhat that means is that any `if` statement cannot depend on values inside a `tf.Tensor`. For example, this code block cannot be compiled with XLA!\n\n```python\nif tf.reduce_sum(tensor) > 10:\n    tensor = tensor / 2.0\n```\n\nThis might seem very restrictive at first, but most neural net code doesn\u2019t need to do this. You can often get around this restriction by using `tf.cond` (see the documentation [here](https://www.tensorflow.org/api_docs/python/tf/cond)) or by removing the conditional and finding a clever math trick with indicator variables instead, like so:\n\n```python\nsum_over_10 = tf.cast(tf.reduce_sum(tensor) > 10, tf.float32)\ntensor = tensor / (1.0 + sum_over_10)\n```\n\nThis code has exactly the same effect as the code above, but by avoiding a conditional, we ensure it will compile with XLA without problems!\n\n#### XLA Rule #2: Your code cannot have \u201cdata-dependent shapes\u201d\n\nWhat this means is that the shape of all of the `tf.Tensor` objects in your code cannot depend on their values. For example, the function `tf.unique` cannot be compiled with XLA, because it returns a `tensor` containing one instance of each unique value in the input. The shape of this output will obviously be different depending on how repetitive the input `Tensor` was, and so XLA refuses to handle it!\n\nIn general, most neural network code obeys rule #2 by default. However, there are a few common cases where it becomes a problem. One very common one is when you use **label masking**, setting your labels to a negative value to indicate that those positions should be ignored when computing the loss. If you look at NumPy or PyTorch loss functions that support label masking, you will often see code like this that uses [boolean indexing](https://numpy.org/doc/stable/user/basics.indexing.html#boolean-array-indexing):\n\n```python\nlabel_mask = labels >= 0\nmasked_outputs = outputs[label_mask]\nmasked_labels = labels[label_mask]\nloss = compute_loss(masked_outputs, masked_labels)\nmean_loss = torch.mean(loss)\n```\n\nThis code is totally fine in NumPy or PyTorch, but it breaks in XLA! Why? Because the shape of `masked_outputs` and `masked_labels` depends on how many positions are masked - that makes it a **data-dependent shape.** However, just like for rule #1, we can often rewrite this code to yield exactly the same output without any data-dependent shapes.\n\n```python\nlabel_mask = tf.cast(labels >= 0, tf.float32)\nloss = compute_loss(outputs, labels)\nloss = loss * label_mask  # Set negative label positions to 0\nmean_loss = tf.reduce_sum(loss) / tf.reduce_sum(label_mask)\n```\n\nHere, we avoid data-dependent shapes by computing the loss for every position, but zeroing out the masked positions in both the numerator and denominator when we calculate the mean, which yields exactly the same result as the first block while maintaining XLA compatibility. Note that we use the same trick as in rule #1 - converting a `tf.bool` to `tf.float32` and using it as an indicator variable. This is a really useful trick, so remember it if you need to convert your own code to XLA!\n\n#### XLA Rule #3: XLA will need to recompile your model for every different input shape it sees\n\nThis is the big one. What this means is that if your input shapes are very variable, XLA will have to recompile your model over and over, which will create huge performance problems. This commonly arises in NLP models, where input texts have variable lengths after tokenization. In other modalities, static shapes are more common and this rule is much less of a problem.\n\nHow can you get around rule #3? The key is **padding** - if you pad all your inputs to the same length, and then use an `attention_mask`, you can get the same results as you\u2019d get from variable shapes, but without any XLA issues."
            },
            {
                "score": 0.5562652800852271,
                "node_text": "Here are some facts extracted from the provided text:\n\nGlue benchmark -> Has -> Dedicated evaluation metric\n\nChoosing a metric for your task\n\n**So you've trained your model and want to see how well it\u2019s doing on a dataset of your choice. Where do you start?**\n\nThere is no \u201cone size fits all\u201d approach to choosing an evaluation metric, but some good guidelines to keep in mind are:\n\n## Categories of metrics\n\nThere are 3 high-level categories of metrics:\n\n1. *Generic metrics*, which can be applied to a variety of situations and datasets, such as precision and accuracy.\n2. *Task-specific metrics*, which are limited to a given task, such as Machine Translation (often evaluated using metrics [BLEU](https://huggingface.co/metrics/bleu) or [ROUGE](https://huggingface.co/metrics/rouge)) or Named Entity Recognition (often evaluated with [seqeval](https://huggingface.co/metrics/seqeval)).\n3. *Dataset-specific metrics*, which aim to measure model performance on specific benchmarks: for instance, the [GLUE benchmark](https://huggingface.co/datasets/glue) has a dedicated [evaluation metric](https://huggingface.co/metrics/glue).\n\nLet's look at each of these three cases:\n\n### Generic metrics\n\nMany of the metrics used in the Machine Learning community are quite generic and can be applied in a variety of tasks and datasets.\n\nThis is the case for metrics like [accuracy](https://huggingface.co/metrics/accuracy) and [precision](https://huggingface.co/metrics/precision), which can be used for evaluating labeled (supervised) datasets, as well as [perplexity](https://huggingface.co/metrics/perplexity), which can be used for evaluating different kinds of (unsupervised) generative tasks.\n\nTo see the input structure of a given metric, you can look at its metric card. For example, in the case of [precision](https://huggingface.co/metrics/precision), the format is:\n```\n>>> precision_metric = evaluate.load(\"precision\")\n>>> results = precision_metric.compute(references=[0, 1], predictions=[0, 1])\n>>> print(results)\n{'precision': 1.0}\n```\n\n### Task-specific metrics\n\nPopular ML tasks like Machine Translation and Named Entity Recognition have specific metrics that can be used to compare models. For example, a series of different metrics have been proposed for text generation, ranging from [BLEU](https://huggingface.co/metrics/bleu) and its derivatives such as [GoogleBLEU](https://huggingface.co/metrics/google_bleu) and [GLEU](https://huggingface.co/metrics/gleu), but also [ROUGE](https://huggingface.co/metrics/rouge), [MAUVE](https://huggingface.co/metrics/mauve), etc.\n\nYou can find the right metric for your task by:\n\n- **Looking at the [Task pages](https://huggingface.co/tasks)** to see what metrics can be used for evaluating models for a given task.\n- **Checking out leaderboards** on sites like [Papers With Code](https://paperswithcode.com/) (you can search by task and by dataset).\n-  **Reading the metric cards** for the relevant metrics and see which ones are a good fit for your use case. For example, see the [BLEU metric card](https://github.com/huggingface/evaluate/tree/main/metrics/bleu) or [SQuaD metric card](https://github.com/huggingface/evaluate/tree/main/metrics/squad).\n- **Looking at papers and blog posts** published on the topic and see what metrics they report. This can change over time, so try to pick papers from the last couple of years!\n\n### Dataset-specific metrics\n\nSome datasets have specific metrics associated with them -- this is especially in the case of popular benchmarks like [GLUE](https://huggingface.co/metrics/glue) and [SQuAD](https://huggingface.co/metrics/squad).\n\n<Tip warning={true}>\n\ud83d\udca1\nGLUE is actually a collection of different subsets on different tasks, so first you need to choose the one that corresponds to the NLI task, such as mnli, which is described as \u201ccrowdsourced collection of sentence pairs with textual entailment annotations\u201d\n</Tip>"
            }
        ]
    },
    {
        "sample_idx": 59,
        "question": "What happens if you leave jit_compile=True when training on TPU?",
        "answer": "It can cause a lot of problems.",
        "rag_answer": "If you leave `jit_compile=True` when training on TPU, it can cause a lot of problems. XLA compilation will happen implicitly on TPU, so it's recommended to remove that line before actually running your code on a TPU.",
        "rag_score": 5,
        "rag_feedback": "The system's response is completely correct, accurate, and factual. It provides a clear and detailed explanation of what happens when you leave jit_compile=True when training on TPU, and it matches the expected answer.",
        "rag_context": [
            {
                "score": 1.0,
                "node_text": "Here are some facts extracted from the provided text:\n\nTpu -> Is -> Tensor processing unit\n\nThis is a really useful trick, so remember it if you need to convert your own code to XLA!\n\n#### XLA Rule #3: XLA will need to recompile your model for every different input shape it sees\n\nThis is the big one. What this means is that if your input shapes are very variable, XLA will have to recompile your model over and over, which will create huge performance problems. This commonly arises in NLP models, where input texts have variable lengths after tokenization. In other modalities, static shapes are more common and this rule is much less of a problem.\n\nHow can you get around rule #3? The key is **padding** - if you pad all your inputs to the same length, and then use an `attention_mask`, you can get the same results as you\u2019d get from variable shapes, but without any XLA issues. However, excessive padding can cause severe slowdown too - if you pad all your samples to the maximum length in the whole dataset, you might end up with batches consisting endless padding tokens, which will waste a lot of compute and memory!\n\nThere isn\u2019t a perfect solution to this problem. However, you can try some tricks. One very useful trick is to **pad batches of samples up to a multiple of a number like 32 or 64 tokens.** This often only increases the number of tokens by a small amount, but it hugely reduces the number of unique input shapes, because every input shape now has to be a multiple of 32 or 64. Fewer unique input shapes means fewer XLA compilations!\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** Our tokenizers and data collators have methods that can help you here. You can use `padding=\"max_length\"` or `padding=\"longest\"` when calling tokenizers to get them to output padded data. Our tokenizers and data collators also have a `pad_to_multiple_of` argument that you can use to reduce the number of unique input shapes you see!\n\n</Tip>\n\n### How do I actually train my model on TPU?\n\nOnce your training is XLA-compatible and (if you\u2019re using TPU Node / Colab) your dataset has been prepared appropriately, running on TPU is surprisingly easy! All you really need to change in your code is to add a few lines to initialize your TPU, and to ensure that your model and dataset are created inside a `TPUStrategy` scope. Take a look at [our TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) to see this in action!\n\n### Summary\n\nThere was a lot in here, so let\u2019s summarize with a quick checklist you can follow when you want to get your model ready for TPU training:\n\n- Make sure your code follows the three rules of XLA\n- Compile your model with `jit_compile=True` on CPU/GPU and confirm that you can train it with XLA\n- Either load your dataset into memory or use a TPU-compatible dataset loading approach (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Migrate your code either to Colab (with accelerator set to \u201cTPU\u201d) or a TPU VM on Google Cloud\n- Add TPU initializer code (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Create your `TPUStrategy` and make sure dataset loading and model creation are inside the `strategy.scope()` (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Don\u2019t forget to take `jit_compile=True` out again when you move to TPU!\n- \ud83d\ude4f\ud83d\ude4f\ud83d\ude4f\ud83e\udd7a\ud83e\udd7a\ud83e\udd7a\n- Call model.fit()\n- You did it!"
            },
            {
                "score": 0.6220477972731274,
                "node_text": "Here are some facts extracted from the provided text:\n\nTpuv4 -> Can be accessed as -> Tpu vm\nTpu vm -> Is -> Machine\nTpu vm -> Is -> Machine with tpu attached\nTpu vm -> Connects to -> Tpu\nTpu node -> Is -> Remote tpu\n\n</Tip>\n\nThe second way to access a TPU is via a **TPU VM.** When using a TPU VM, you connect directly to the machine that the TPU is attached to, much like training on a GPU VM. TPU VMs are generally easier to work with, particularly when it comes to your data pipeline. All of the above warnings do not apply to TPU VMs!\n\nThis is an opinionated document, so here\u2019s our opinion: **Avoid using TPU Node if possible.** It is more confusing and more difficult to debug than TPU VMs. It is also likely to be unsupported in future - Google\u2019s latest TPU, TPUv4, can only be accessed as a TPU VM, which suggests that TPU Nodes are increasingly going to become a \u201clegacy\u201d access method. However, we understand that the only free TPU access is on Colab and Kaggle Kernels, which uses TPU Node - so we\u2019ll try to explain how to handle it if you have to! Check the [TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) for code samples that explain this in more detail.\n\n### What sizes of TPU are available?\n\nA single TPU (a v2-8/v3-8/v4-8) runs 8 replicas. TPUs exist in **pods** that can run hundreds or thousands of replicas simultaneously. When you use more than a single TPU but less than a whole pod (for example, a v3-32), your TPU fleet is referred to as a **pod slice.**\n\nWhen you access a free TPU via Colab, you generally get a single v2-8 TPU.\n\n### I keep hearing about this XLA thing. What\u2019s XLA, and how does it relate to TPUs?\n\nXLA is an optimizing compiler, used by both TensorFlow and JAX. In JAX it is the only compiler, whereas in TensorFlow it is optional (but mandatory on TPU!). The easiest way to enable it when training a Keras model is to pass the argument `jit_compile=True` to `model.compile()`. If you don\u2019t get any errors and performance is good, that\u2019s a great sign that you\u2019re ready to move to TPU!\n\nDebugging on TPU is generally a bit harder than on CPU/GPU, so we recommend getting your code running on CPU/GPU with XLA first before trying it on TPU. You don\u2019t have to train for long, of course - just for a few steps to make sure that your model and data pipeline are working like you expect them to.\n\n<Tip>\n\nXLA compiled code is usually faster - so even if you\u2019re not planning to run on TPU, adding `jit_compile=True` can improve your performance. Be sure to note the caveats below about XLA compatibility, though!\n\n</Tip>\n\n<Tip warning={true}>\n\n**Tip born of painful experience:** Although using `jit_compile=True` is a good way to get a speed boost and test if your CPU/GPU code is XLA-compatible, it can actually cause a lot of problems if you leave it in when actually training on TPU. XLA compilation will happen implicitly on TPU, so remember to remove that line before actually running your code on a TPU!\n\n</Tip>\n\n### How do I make my model XLA compatible?\n\nIn many cases, your code is probably XLA-compatible already! However, there are a few things that work in normal TensorFlow that don\u2019t work in XLA. We\u2019ve distilled them into three core rules below:\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** We\u2019ve put a lot of effort into rewriting our TensorFlow models and loss functions to be XLA-compatible. Our models and loss functions generally obey rule #1 and #2 by default, so you can skip over them if you\u2019re using `transformers` models. Don\u2019t forget about these rules when writing your own models and loss functions, though!\n\n</Tip>\n\n#### XLA Rule #1: Your code cannot have \u201cdata-dependent conditionals\u201d\n\nWhat that means is that any `if` statement cannot depend on values inside a `tf.Tensor`. For example, this code block cannot be compiled with XLA!\n\n```python\nif tf.reduce_sum(tensor) > 10:\n    tensor = tensor / 2.0\n```\n\nThis might seem very restrictive at first, but most neural net code doesn\u2019t need to do this."
            }
        ]
    },
    {
        "sample_idx": 60,
        "question": "What is required to make a model XLA compatible?",
        "answer": "Following three core rules: no data-dependent conditionals, no dynamic shapes, and no Python control flow.",
        "rag_answer": "To make a model XLA compatible, it is required to follow three core rules. These rules are related to the model's code and ensure that it can be compiled with XLA.",
        "rag_score": 2,
        "rag_feedback": "The system's response does not directly answer the question about what is required to make a model XLA compatible. Although it provides some relevant information about XLA and its rules, it does not explicitly state the three core rules: no data-dependent conditionals, no dynamic shapes, and no Python control flow.",
        "rag_context": [
            {
                "score": 0.6573092212948675,
                "node_text": "Here are some facts extracted from the provided text:\n\nPadding -> Helps -> Xla issues\nPadding -> Helps -> Avoid xla issues\nXla -> Is -> Optimizing compiler\nXla -> Is used by -> Tensorflow and jax\nXla -> Is mandatory on -> Tpu\nXla -> Recompile -> Model\nXla -> Has -> Rule #1\nXla -> Has -> Rule #2\nXla -> Needs -> Recompile\nXla -> Has -> Rule #3\n\nThis is a really useful trick, so remember it if you need to convert your own code to XLA!\n\n#### XLA Rule #3: XLA will need to recompile your model for every different input shape it sees\n\nThis is the big one. What this means is that if your input shapes are very variable, XLA will have to recompile your model over and over, which will create huge performance problems. This commonly arises in NLP models, where input texts have variable lengths after tokenization. In other modalities, static shapes are more common and this rule is much less of a problem.\n\nHow can you get around rule #3? The key is **padding** - if you pad all your inputs to the same length, and then use an `attention_mask`, you can get the same results as you\u2019d get from variable shapes, but without any XLA issues. However, excessive padding can cause severe slowdown too - if you pad all your samples to the maximum length in the whole dataset, you might end up with batches consisting endless padding tokens, which will waste a lot of compute and memory!\n\nThere isn\u2019t a perfect solution to this problem. However, you can try some tricks. One very useful trick is to **pad batches of samples up to a multiple of a number like 32 or 64 tokens.** This often only increases the number of tokens by a small amount, but it hugely reduces the number of unique input shapes, because every input shape now has to be a multiple of 32 or 64. Fewer unique input shapes means fewer XLA compilations!\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** Our tokenizers and data collators have methods that can help you here. You can use `padding=\"max_length\"` or `padding=\"longest\"` when calling tokenizers to get them to output padded data. Our tokenizers and data collators also have a `pad_to_multiple_of` argument that you can use to reduce the number of unique input shapes you see!\n\n</Tip>\n\n### How do I actually train my model on TPU?\n\nOnce your training is XLA-compatible and (if you\u2019re using TPU Node / Colab) your dataset has been prepared appropriately, running on TPU is surprisingly easy! All you really need to change in your code is to add a few lines to initialize your TPU, and to ensure that your model and dataset are created inside a `TPUStrategy` scope. Take a look at [our TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) to see this in action!\n\n### Summary\n\nThere was a lot in here, so let\u2019s summarize with a quick checklist you can follow when you want to get your model ready for TPU training:\n\n- Make sure your code follows the three rules of XLA\n- Compile your model with `jit_compile=True` on CPU/GPU and confirm that you can train it with XLA\n- Either load your dataset into memory or use a TPU-compatible dataset loading approach (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Migrate your code either to Colab (with accelerator set to \u201cTPU\u201d) or a TPU VM on Google Cloud\n- Add TPU initializer code (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Create your `TPUStrategy` and make sure dataset loading and model creation are inside the `strategy.scope()` (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Don\u2019t forget to take `jit_compile=True` out again when you move to TPU!\n- \ud83d\ude4f\ud83d\ude4f\ud83d\ude4f\ud83e\udd7a\ud83e\udd7a\ud83e\udd7a\n- Call model.fit()\n- You did it!"
            },
            {
                "score": 0.500963328386409,
                "node_text": "Here are some facts extracted from the provided text:\n\nTpu vm -> Is -> Machine with tpu attached\n\n</Tip>\n\nThe second way to access a TPU is via a **TPU VM.** When using a TPU VM, you connect directly to the machine that the TPU is attached to, much like training on a GPU VM. TPU VMs are generally easier to work with, particularly when it comes to your data pipeline. All of the above warnings do not apply to TPU VMs!\n\nThis is an opinionated document, so here\u2019s our opinion: **Avoid using TPU Node if possible.** It is more confusing and more difficult to debug than TPU VMs. It is also likely to be unsupported in future - Google\u2019s latest TPU, TPUv4, can only be accessed as a TPU VM, which suggests that TPU Nodes are increasingly going to become a \u201clegacy\u201d access method. However, we understand that the only free TPU access is on Colab and Kaggle Kernels, which uses TPU Node - so we\u2019ll try to explain how to handle it if you have to! Check the [TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) for code samples that explain this in more detail.\n\n### What sizes of TPU are available?\n\nA single TPU (a v2-8/v3-8/v4-8) runs 8 replicas. TPUs exist in **pods** that can run hundreds or thousands of replicas simultaneously. When you use more than a single TPU but less than a whole pod (for example, a v3-32), your TPU fleet is referred to as a **pod slice.**\n\nWhen you access a free TPU via Colab, you generally get a single v2-8 TPU.\n\n### I keep hearing about this XLA thing. What\u2019s XLA, and how does it relate to TPUs?\n\nXLA is an optimizing compiler, used by both TensorFlow and JAX. In JAX it is the only compiler, whereas in TensorFlow it is optional (but mandatory on TPU!). The easiest way to enable it when training a Keras model is to pass the argument `jit_compile=True` to `model.compile()`. If you don\u2019t get any errors and performance is good, that\u2019s a great sign that you\u2019re ready to move to TPU!\n\nDebugging on TPU is generally a bit harder than on CPU/GPU, so we recommend getting your code running on CPU/GPU with XLA first before trying it on TPU. You don\u2019t have to train for long, of course - just for a few steps to make sure that your model and data pipeline are working like you expect them to.\n\n<Tip>\n\nXLA compiled code is usually faster - so even if you\u2019re not planning to run on TPU, adding `jit_compile=True` can improve your performance. Be sure to note the caveats below about XLA compatibility, though!\n\n</Tip>\n\n<Tip warning={true}>\n\n**Tip born of painful experience:** Although using `jit_compile=True` is a good way to get a speed boost and test if your CPU/GPU code is XLA-compatible, it can actually cause a lot of problems if you leave it in when actually training on TPU. XLA compilation will happen implicitly on TPU, so remember to remove that line before actually running your code on a TPU!\n\n</Tip>\n\n### How do I make my model XLA compatible?\n\nIn many cases, your code is probably XLA-compatible already! However, there are a few things that work in normal TensorFlow that don\u2019t work in XLA. We\u2019ve distilled them into three core rules below:\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** We\u2019ve put a lot of effort into rewriting our TensorFlow models and loss functions to be XLA-compatible. Our models and loss functions generally obey rule #1 and #2 by default, so you can skip over them if you\u2019re using `transformers` models. Don\u2019t forget about these rules when writing your own models and loss functions, though!\n\n</Tip>\n\n#### XLA Rule #1: Your code cannot have \u201cdata-dependent conditionals\u201d\n\nWhat that means is that any `if` statement cannot depend on values inside a `tf.Tensor`. For example, this code block cannot be compiled with XLA!\n\n```python\nif tf.reduce_sum(tensor) > 10:\n    tensor = tensor / 2.0\n```\n\nThis might seem very restrictive at first, but most neural net code doesn\u2019t need to do this."
            }
        ]
    },
    {
        "sample_idx": 61,
        "question": "What is meant by 'data-dependent conditionals' in XLA?",
        "answer": "Any if statement cannot depend on values inside a tf.Tensor.",
        "rag_answer": "In XLA, 'data-dependent conditionals' refer to `if` statements that depend on values inside a `tf.Tensor`. This means that the condition in the `if` statement is determined by the value of a tensor, which is not allowed in XLA-compatible code.",
        "rag_score": 5,
        "rag_feedback": "The system's response is completely correct, accurate, and factual. It provides a clear and concise definition of 'data-dependent conditionals' in XLA, which aligns with the expected answer. The response also provides additional context and examples to support the definition, making it a comprehensive and informative answer.",
        "rag_context": [
            {
                "score": 0.7350944085964541,
                "node_text": "Here are some facts extracted from the provided text:\n\nRule #1 -> Prohibits -> Data-dependent conditionals\n\nWe\u2019ve distilled them into three core rules below:\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** We\u2019ve put a lot of effort into rewriting our TensorFlow models and loss functions to be XLA-compatible. Our models and loss functions generally obey rule #1 and #2 by default, so you can skip over them if you\u2019re using `transformers` models. Don\u2019t forget about these rules when writing your own models and loss functions, though!\n\n</Tip>\n\n#### XLA Rule #1: Your code cannot have \u201cdata-dependent conditionals\u201d\n\nWhat that means is that any `if` statement cannot depend on values inside a `tf.Tensor`. For example, this code block cannot be compiled with XLA!\n\n```python\nif tf.reduce_sum(tensor) > 10:\n    tensor = tensor / 2.0\n```\n\nThis might seem very restrictive at first, but most neural net code doesn\u2019t need to do this. You can often get around this restriction by using `tf.cond` (see the documentation [here](https://www.tensorflow.org/api_docs/python/tf/cond)) or by removing the conditional and finding a clever math trick with indicator variables instead, like so:\n\n```python\nsum_over_10 = tf.cast(tf.reduce_sum(tensor) > 10, tf.float32)\ntensor = tensor / (1.0 + sum_over_10)\n```\n\nThis code has exactly the same effect as the code above, but by avoiding a conditional, we ensure it will compile with XLA without problems!\n\n#### XLA Rule #2: Your code cannot have \u201cdata-dependent shapes\u201d\n\nWhat this means is that the shape of all of the `tf.Tensor` objects in your code cannot depend on their values. For example, the function `tf.unique` cannot be compiled with XLA, because it returns a `tensor` containing one instance of each unique value in the input. The shape of this output will obviously be different depending on how repetitive the input `Tensor` was, and so XLA refuses to handle it!\n\nIn general, most neural network code obeys rule #2 by default. However, there are a few common cases where it becomes a problem. One very common one is when you use **label masking**, setting your labels to a negative value to indicate that those positions should be ignored when computing the loss. If you look at NumPy or PyTorch loss functions that support label masking, you will often see code like this that uses [boolean indexing](https://numpy.org/doc/stable/user/basics.indexing.html#boolean-array-indexing):\n\n```python\nlabel_mask = labels >= 0\nmasked_outputs = outputs[label_mask]\nmasked_labels = labels[label_mask]\nloss = compute_loss(masked_outputs, masked_labels)\nmean_loss = torch.mean(loss)\n```\n\nThis code is totally fine in NumPy or PyTorch, but it breaks in XLA! Why? Because the shape of `masked_outputs` and `masked_labels` depends on how many positions are masked - that makes it a **data-dependent shape.** However, just like for rule #1, we can often rewrite this code to yield exactly the same output without any data-dependent shapes.\n\n```python\nlabel_mask = tf.cast(labels >= 0, tf.float32)\nloss = compute_loss(outputs, labels)\nloss = loss * label_mask  # Set negative label positions to 0\nmean_loss = tf.reduce_sum(loss) / tf.reduce_sum(label_mask)\n```\n\nHere, we avoid data-dependent shapes by computing the loss for every position, but zeroing out the masked positions in both the numerator and denominator when we calculate the mean, which yields exactly the same result as the first block while maintaining XLA compatibility. Note that we use the same trick as in rule #1 - converting a `tf.bool` to `tf.float32` and using it as an indicator variable. This is a really useful trick, so remember it if you need to convert your own code to XLA!\n\n#### XLA Rule #3: XLA will need to recompile your model for every different input shape it sees\n\nThis is the big one. What this means is that if your input shapes are very variable, XLA will have to recompile your model over and over, which will create huge performance problems. This commonly arises in NLP models, where input texts have variable lengths after tokenization. In other modalities, static shapes are more common and this rule is much less of a problem.\n\nHow can you get around rule #3? The key is **padding** - if you pad all your inputs to the same length, and then use an `attention_mask`, you can get the same results as you\u2019d get from variable shapes, but without any XLA issues."
            },
            {
                "score": 0.6958558665536326,
                "node_text": "Here are some facts extracted from the provided text:\n\nPadding -> Helps -> Xla issues\nPadding -> Helps -> Avoid xla issues\nXla -> Is -> Optimizing compiler\nXla -> Is used by -> Tensorflow and jax\nXla -> Is mandatory on -> Tpu\nXla -> Recompile -> Model\nXla -> Has -> Rule #1\nXla -> Has -> Rule #2\nXla -> Needs -> Recompile\nXla -> Has -> Rule #3\n\nThis is a really useful trick, so remember it if you need to convert your own code to XLA!\n\n#### XLA Rule #3: XLA will need to recompile your model for every different input shape it sees\n\nThis is the big one. What this means is that if your input shapes are very variable, XLA will have to recompile your model over and over, which will create huge performance problems. This commonly arises in NLP models, where input texts have variable lengths after tokenization. In other modalities, static shapes are more common and this rule is much less of a problem.\n\nHow can you get around rule #3? The key is **padding** - if you pad all your inputs to the same length, and then use an `attention_mask`, you can get the same results as you\u2019d get from variable shapes, but without any XLA issues. However, excessive padding can cause severe slowdown too - if you pad all your samples to the maximum length in the whole dataset, you might end up with batches consisting endless padding tokens, which will waste a lot of compute and memory!\n\nThere isn\u2019t a perfect solution to this problem. However, you can try some tricks. One very useful trick is to **pad batches of samples up to a multiple of a number like 32 or 64 tokens.** This often only increases the number of tokens by a small amount, but it hugely reduces the number of unique input shapes, because every input shape now has to be a multiple of 32 or 64. Fewer unique input shapes means fewer XLA compilations!\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** Our tokenizers and data collators have methods that can help you here. You can use `padding=\"max_length\"` or `padding=\"longest\"` when calling tokenizers to get them to output padded data. Our tokenizers and data collators also have a `pad_to_multiple_of` argument that you can use to reduce the number of unique input shapes you see!\n\n</Tip>\n\n### How do I actually train my model on TPU?\n\nOnce your training is XLA-compatible and (if you\u2019re using TPU Node / Colab) your dataset has been prepared appropriately, running on TPU is surprisingly easy! All you really need to change in your code is to add a few lines to initialize your TPU, and to ensure that your model and dataset are created inside a `TPUStrategy` scope. Take a look at [our TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) to see this in action!\n\n### Summary\n\nThere was a lot in here, so let\u2019s summarize with a quick checklist you can follow when you want to get your model ready for TPU training:\n\n- Make sure your code follows the three rules of XLA\n- Compile your model with `jit_compile=True` on CPU/GPU and confirm that you can train it with XLA\n- Either load your dataset into memory or use a TPU-compatible dataset loading approach (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Migrate your code either to Colab (with accelerator set to \u201cTPU\u201d) or a TPU VM on Google Cloud\n- Add TPU initializer code (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Create your `TPUStrategy` and make sure dataset loading and model creation are inside the `strategy.scope()` (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Don\u2019t forget to take `jit_compile=True` out again when you move to TPU!\n- \ud83d\ude4f\ud83d\ude4f\ud83d\ude4f\ud83e\udd7a\ud83e\udd7a\ud83e\udd7a\n- Call model.fit()\n- You did it!"
            }
        ]
    },
    {
        "sample_idx": 62,
        "question": "What is the alternative to using a conditional statement in TensorFlow to avoid XLA compilation problems?",
        "answer": "Using tf.cond or removing the conditional and finding a clever math trick with indicator variables.",
        "rag_answer": "The alternative to using a conditional statement in TensorFlow to avoid XLA compilation problems is padding. Specifically, padding all inputs to the same length and using an attention mask can help avoid XLA issues. Additionally, padding batches of samples up to a multiple of a number like 32 or 64 tokens can also reduce the number of unique input shapes, resulting in fewer XLA compilations.",
        "rag_score": 2,
        "rag_feedback": "The system's response is mostly incorrect, inaccurate, and/or not factual. The expected answer is about using tf.cond or removing the conditional and finding a clever math trick with indicator variables, but the system's response is about padding inputs to avoid XLA compilation problems, which is a different topic.",
        "rag_context": [
            {
                "score": 1.0,
                "node_text": "Here are some facts extracted from the provided text:\n\nPadding -> Helps -> Avoid xla issues\n\nThis is a really useful trick, so remember it if you need to convert your own code to XLA!\n\n#### XLA Rule #3: XLA will need to recompile your model for every different input shape it sees\n\nThis is the big one. What this means is that if your input shapes are very variable, XLA will have to recompile your model over and over, which will create huge performance problems. This commonly arises in NLP models, where input texts have variable lengths after tokenization. In other modalities, static shapes are more common and this rule is much less of a problem.\n\nHow can you get around rule #3? The key is **padding** - if you pad all your inputs to the same length, and then use an `attention_mask`, you can get the same results as you\u2019d get from variable shapes, but without any XLA issues. However, excessive padding can cause severe slowdown too - if you pad all your samples to the maximum length in the whole dataset, you might end up with batches consisting endless padding tokens, which will waste a lot of compute and memory!\n\nThere isn\u2019t a perfect solution to this problem. However, you can try some tricks. One very useful trick is to **pad batches of samples up to a multiple of a number like 32 or 64 tokens.** This often only increases the number of tokens by a small amount, but it hugely reduces the number of unique input shapes, because every input shape now has to be a multiple of 32 or 64. Fewer unique input shapes means fewer XLA compilations!\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** Our tokenizers and data collators have methods that can help you here. You can use `padding=\"max_length\"` or `padding=\"longest\"` when calling tokenizers to get them to output padded data. Our tokenizers and data collators also have a `pad_to_multiple_of` argument that you can use to reduce the number of unique input shapes you see!\n\n</Tip>\n\n### How do I actually train my model on TPU?\n\nOnce your training is XLA-compatible and (if you\u2019re using TPU Node / Colab) your dataset has been prepared appropriately, running on TPU is surprisingly easy! All you really need to change in your code is to add a few lines to initialize your TPU, and to ensure that your model and dataset are created inside a `TPUStrategy` scope. Take a look at [our TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) to see this in action!\n\n### Summary\n\nThere was a lot in here, so let\u2019s summarize with a quick checklist you can follow when you want to get your model ready for TPU training:\n\n- Make sure your code follows the three rules of XLA\n- Compile your model with `jit_compile=True` on CPU/GPU and confirm that you can train it with XLA\n- Either load your dataset into memory or use a TPU-compatible dataset loading approach (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Migrate your code either to Colab (with accelerator set to \u201cTPU\u201d) or a TPU VM on Google Cloud\n- Add TPU initializer code (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Create your `TPUStrategy` and make sure dataset loading and model creation are inside the `strategy.scope()` (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Don\u2019t forget to take `jit_compile=True` out again when you move to TPU!\n- \ud83d\ude4f\ud83d\ude4f\ud83d\ude4f\ud83e\udd7a\ud83e\udd7a\ud83e\udd7a\n- Call model.fit()\n- You did it!"
            },
            {
                "score": 0.6524491208631503,
                "node_text": "Here are some facts extracted from the provided text:\n\nPadding -> Helps -> Avoid xla issues\nXla -> Is used by -> Tensorflow and jax\nTpu -> Is -> Tensor processing unit\n\nThis is a really useful trick, so remember it if you need to convert your own code to XLA!\n\n#### XLA Rule #3: XLA will need to recompile your model for every different input shape it sees\n\nThis is the big one. What this means is that if your input shapes are very variable, XLA will have to recompile your model over and over, which will create huge performance problems. This commonly arises in NLP models, where input texts have variable lengths after tokenization. In other modalities, static shapes are more common and this rule is much less of a problem.\n\nHow can you get around rule #3? The key is **padding** - if you pad all your inputs to the same length, and then use an `attention_mask`, you can get the same results as you\u2019d get from variable shapes, but without any XLA issues. However, excessive padding can cause severe slowdown too - if you pad all your samples to the maximum length in the whole dataset, you might end up with batches consisting endless padding tokens, which will waste a lot of compute and memory!\n\nThere isn\u2019t a perfect solution to this problem. However, you can try some tricks. One very useful trick is to **pad batches of samples up to a multiple of a number like 32 or 64 tokens.** This often only increases the number of tokens by a small amount, but it hugely reduces the number of unique input shapes, because every input shape now has to be a multiple of 32 or 64. Fewer unique input shapes means fewer XLA compilations!\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** Our tokenizers and data collators have methods that can help you here. You can use `padding=\"max_length\"` or `padding=\"longest\"` when calling tokenizers to get them to output padded data. Our tokenizers and data collators also have a `pad_to_multiple_of` argument that you can use to reduce the number of unique input shapes you see!\n\n</Tip>\n\n### How do I actually train my model on TPU?\n\nOnce your training is XLA-compatible and (if you\u2019re using TPU Node / Colab) your dataset has been prepared appropriately, running on TPU is surprisingly easy! All you really need to change in your code is to add a few lines to initialize your TPU, and to ensure that your model and dataset are created inside a `TPUStrategy` scope. Take a look at [our TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) to see this in action!\n\n### Summary\n\nThere was a lot in here, so let\u2019s summarize with a quick checklist you can follow when you want to get your model ready for TPU training:\n\n- Make sure your code follows the three rules of XLA\n- Compile your model with `jit_compile=True` on CPU/GPU and confirm that you can train it with XLA\n- Either load your dataset into memory or use a TPU-compatible dataset loading approach (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Migrate your code either to Colab (with accelerator set to \u201cTPU\u201d) or a TPU VM on Google Cloud\n- Add TPU initializer code (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Create your `TPUStrategy` and make sure dataset loading and model creation are inside the `strategy.scope()` (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Don\u2019t forget to take `jit_compile=True` out again when you move to TPU!\n- \ud83d\ude4f\ud83d\ude4f\ud83d\ude4f\ud83e\udd7a\ud83e\udd7a\ud83e\udd7a\n- Call model.fit()\n- You did it!"
            },
            {
                "score": 0.628949663579336,
                "node_text": "Here are some facts extracted from the provided text:\n\nTensorflow models -> Are -> Keras models\n\n!--Copyright 2023 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\nthe License. You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under the License is distributed on\nan \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n\n\u26a0\ufe0f Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be\nrendered properly in your Markdown viewer.\n\n-->\n\n# Training on TPU with TensorFlow\n\n<Tip>\n\nIf you don't need long explanations and just want TPU code samples to get started with, check out [our TPU example notebook!](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb)\n\n</Tip>\n\n### What is a TPU?\n\nA TPU is a **Tensor Processing Unit.** They are hardware designed by Google, which are used to greatly speed up the tensor computations within neural networks, much like GPUs. They can be used for both network training and inference. They are generally accessed through Google\u2019s cloud services, but small TPUs can also be accessed directly for free through Google Colab and Kaggle Kernels.\n\nBecause [all TensorFlow models in \ud83e\udd17 Transformers are Keras models](https://huggingface.co/blog/tensorflow-philosophy), most of the methods in this document are generally applicable to TPU training for any Keras model! However, there are a few points that are specific to the HuggingFace ecosystem (hug-o-system?) of Transformers and Datasets, and we\u2019ll make sure to flag them up when we get to them.\n\n### What kinds of TPU are available?\n\nNew users are often very confused by the range of TPUs, and the different ways to access them. The first key distinction to understand is the difference between **TPU Nodes** and **TPU VMs.**\n\nWhen you use a **TPU Node**, you are effectively indirectly accessing a remote TPU. You will need a separate VM, which will initialize your network and data pipeline and then forward them to the remote node. When you use a TPU on Google Colab, you are accessing it in the **TPU Node** style.\n\nUsing TPU Nodes can have some quite unexpected behaviour for people who aren\u2019t used to them! In particular, because the TPU is located on a physically different system to the machine you\u2019re running your Python code on, your data cannot be local to your machine - any data pipeline that loads from your machine\u2019s internal storage will totally fail! Instead, data must be stored in Google Cloud Storage where your data pipeline can still access it, even when the pipeline is running on the remote TPU node.\n\n<Tip>\n\nIf you can fit all your data in memory as `np.ndarray` or `tf.Tensor`, then you can `fit()` on that data even when using Colab or a TPU Node, without needing to upload it to Google Cloud Storage.\n\n</Tip>\n\n<Tip>\n\n**\ud83e\udd17Specific Hugging Face Tip\ud83e\udd17:** The methods `Dataset.to_tf_dataset()` and its higher-level wrapper `model.prepare_tf_dataset()` , which you will see throughout our TF code examples, will both fail on a TPU Node. The reason for this is that even though they create a `tf.data.Dataset` it is not a \u201cpure\u201d `tf.data` pipeline and uses `tf.numpy_function` or `Dataset.from_generator()` to stream data from the underlying HuggingFace `Dataset`. This HuggingFace `Dataset` is backed by data that is on a local disc and which the remote TPU Node will not be able to read.\n\n</Tip>\n\nThe second way to access a TPU is via a **TPU VM.** When using a TPU VM, you connect directly to the machine that the TPU is attached to, much like training on a GPU VM. TPU VMs are generally easier to work with, particularly when it comes to your data pipeline. All of the above warnings do not apply to TPU VMs!\n\nThis is an opinionated document, so here\u2019s our opinion: **Avoid using TPU Node if possible.** It is more confusing and more difficult to debug than TPU VMs. It is also likely to be unsupported in future - Google\u2019s latest TPU, TPUv4, can only be accessed as a TPU VM, which suggests that TPU Nodes are increasingly going to become a \u201clegacy\u201d access method."
            }
        ]
    },
    {
        "sample_idx": 63,
        "question": "What is XLA Rule #2?",
        "answer": "Your code cannot have 'data-dependent shapes'.",
        "rag_answer": "XLA Rule #2 prohibits data-dependent shapes, meaning the shape of all tf.Tensor objects in the code cannot depend on their values.",
        "rag_score": 5,
        "rag_feedback": "The response is completely correct, accurate, and factual. It directly answers the question by stating that XLA Rule #2 prohibits data-dependent shapes, meaning the shape of all tf.Tensor objects in the code cannot depend on their values.",
        "rag_context": [
            {
                "score": 0.6984234236140696,
                "node_text": "Here are some facts extracted from the provided text:\n\nPadding -> Helps -> Xla issues\nPadding -> Helps -> Avoid xla issues\nXla -> Is -> Optimizing compiler\nXla -> Is used by -> Tensorflow and jax\nXla -> Is mandatory on -> Tpu\nXla -> Recompile -> Model\nXla -> Has -> Rule #1\nXla -> Has -> Rule #2\nXla -> Needs -> Recompile\nXla -> Has -> Rule #3\n\nThis is a really useful trick, so remember it if you need to convert your own code to XLA!\n\n#### XLA Rule #3: XLA will need to recompile your model for every different input shape it sees\n\nThis is the big one. What this means is that if your input shapes are very variable, XLA will have to recompile your model over and over, which will create huge performance problems. This commonly arises in NLP models, where input texts have variable lengths after tokenization. In other modalities, static shapes are more common and this rule is much less of a problem.\n\nHow can you get around rule #3? The key is **padding** - if you pad all your inputs to the same length, and then use an `attention_mask`, you can get the same results as you\u2019d get from variable shapes, but without any XLA issues. However, excessive padding can cause severe slowdown too - if you pad all your samples to the maximum length in the whole dataset, you might end up with batches consisting endless padding tokens, which will waste a lot of compute and memory!\n\nThere isn\u2019t a perfect solution to this problem. However, you can try some tricks. One very useful trick is to **pad batches of samples up to a multiple of a number like 32 or 64 tokens.** This often only increases the number of tokens by a small amount, but it hugely reduces the number of unique input shapes, because every input shape now has to be a multiple of 32 or 64. Fewer unique input shapes means fewer XLA compilations!\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** Our tokenizers and data collators have methods that can help you here. You can use `padding=\"max_length\"` or `padding=\"longest\"` when calling tokenizers to get them to output padded data. Our tokenizers and data collators also have a `pad_to_multiple_of` argument that you can use to reduce the number of unique input shapes you see!\n\n</Tip>\n\n### How do I actually train my model on TPU?\n\nOnce your training is XLA-compatible and (if you\u2019re using TPU Node / Colab) your dataset has been prepared appropriately, running on TPU is surprisingly easy! All you really need to change in your code is to add a few lines to initialize your TPU, and to ensure that your model and dataset are created inside a `TPUStrategy` scope. Take a look at [our TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) to see this in action!\n\n### Summary\n\nThere was a lot in here, so let\u2019s summarize with a quick checklist you can follow when you want to get your model ready for TPU training:\n\n- Make sure your code follows the three rules of XLA\n- Compile your model with `jit_compile=True` on CPU/GPU and confirm that you can train it with XLA\n- Either load your dataset into memory or use a TPU-compatible dataset loading approach (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Migrate your code either to Colab (with accelerator set to \u201cTPU\u201d) or a TPU VM on Google Cloud\n- Add TPU initializer code (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Create your `TPUStrategy` and make sure dataset loading and model creation are inside the `strategy.scope()` (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Don\u2019t forget to take `jit_compile=True` out again when you move to TPU!\n- \ud83d\ude4f\ud83d\ude4f\ud83d\ude4f\ud83e\udd7a\ud83e\udd7a\ud83e\udd7a\n- Call model.fit()\n- You did it!"
            },
            {
                "score": 0.6256129865082642,
                "node_text": "Here are some facts extracted from the provided text:\n\nRule #2 -> Prohibits -> Data-dependent shapes\n\nWe\u2019ve distilled them into three core rules below:\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** We\u2019ve put a lot of effort into rewriting our TensorFlow models and loss functions to be XLA-compatible. Our models and loss functions generally obey rule #1 and #2 by default, so you can skip over them if you\u2019re using `transformers` models. Don\u2019t forget about these rules when writing your own models and loss functions, though!\n\n</Tip>\n\n#### XLA Rule #1: Your code cannot have \u201cdata-dependent conditionals\u201d\n\nWhat that means is that any `if` statement cannot depend on values inside a `tf.Tensor`. For example, this code block cannot be compiled with XLA!\n\n```python\nif tf.reduce_sum(tensor) > 10:\n    tensor = tensor / 2.0\n```\n\nThis might seem very restrictive at first, but most neural net code doesn\u2019t need to do this. You can often get around this restriction by using `tf.cond` (see the documentation [here](https://www.tensorflow.org/api_docs/python/tf/cond)) or by removing the conditional and finding a clever math trick with indicator variables instead, like so:\n\n```python\nsum_over_10 = tf.cast(tf.reduce_sum(tensor) > 10, tf.float32)\ntensor = tensor / (1.0 + sum_over_10)\n```\n\nThis code has exactly the same effect as the code above, but by avoiding a conditional, we ensure it will compile with XLA without problems!\n\n#### XLA Rule #2: Your code cannot have \u201cdata-dependent shapes\u201d\n\nWhat this means is that the shape of all of the `tf.Tensor` objects in your code cannot depend on their values. For example, the function `tf.unique` cannot be compiled with XLA, because it returns a `tensor` containing one instance of each unique value in the input. The shape of this output will obviously be different depending on how repetitive the input `Tensor` was, and so XLA refuses to handle it!\n\nIn general, most neural network code obeys rule #2 by default. However, there are a few common cases where it becomes a problem. One very common one is when you use **label masking**, setting your labels to a negative value to indicate that those positions should be ignored when computing the loss. If you look at NumPy or PyTorch loss functions that support label masking, you will often see code like this that uses [boolean indexing](https://numpy.org/doc/stable/user/basics.indexing.html#boolean-array-indexing):\n\n```python\nlabel_mask = labels >= 0\nmasked_outputs = outputs[label_mask]\nmasked_labels = labels[label_mask]\nloss = compute_loss(masked_outputs, masked_labels)\nmean_loss = torch.mean(loss)\n```\n\nThis code is totally fine in NumPy or PyTorch, but it breaks in XLA! Why? Because the shape of `masked_outputs` and `masked_labels` depends on how many positions are masked - that makes it a **data-dependent shape.** However, just like for rule #1, we can often rewrite this code to yield exactly the same output without any data-dependent shapes.\n\n```python\nlabel_mask = tf.cast(labels >= 0, tf.float32)\nloss = compute_loss(outputs, labels)\nloss = loss * label_mask  # Set negative label positions to 0\nmean_loss = tf.reduce_sum(loss) / tf.reduce_sum(label_mask)\n```\n\nHere, we avoid data-dependent shapes by computing the loss for every position, but zeroing out the masked positions in both the numerator and denominator when we calculate the mean, which yields exactly the same result as the first block while maintaining XLA compatibility. Note that we use the same trick as in rule #1 - converting a `tf.bool` to `tf.float32` and using it as an indicator variable. This is a really useful trick, so remember it if you need to convert your own code to XLA!\n\n#### XLA Rule #3: XLA will need to recompile your model for every different input shape it sees\n\nThis is the big one. What this means is that if your input shapes are very variable, XLA will have to recompile your model over and over, which will create huge performance problems. This commonly arises in NLP models, where input texts have variable lengths after tokenization. In other modalities, static shapes are more common and this rule is much less of a problem.\n\nHow can you get around rule #3? The key is **padding** - if you pad all your inputs to the same length, and then use an `attention_mask`, you can get the same results as you\u2019d get from variable shapes, but without any XLA issues."
            }
        ]
    },
    {
        "sample_idx": 64,
        "question": "What does XLA Rule #2 mean?",
        "answer": "The shape of all of the tf.Tensor objects in your code cannot depend on their values.",
        "rag_answer": "XLA Rule #2 means that the shape of all of the `tf.Tensor` objects in your code cannot depend on their values.",
        "rag_score": 5,
        "rag_feedback": "The system's response is completely correct, accurate, and factual. It directly answers the question by stating that XLA Rule #2 means that the shape of all of the tf.Tensor objects in your code cannot depend on their values.",
        "rag_context": [
            {
                "score": 0.6911447066160632,
                "node_text": "Here are some facts extracted from the provided text:\n\nPadding -> Helps -> Xla issues\nPadding -> Helps -> Avoid xla issues\nXla -> Is -> Optimizing compiler\nXla -> Is used by -> Tensorflow and jax\nXla -> Is mandatory on -> Tpu\nXla -> Recompile -> Model\nXla -> Has -> Rule #1\nXla -> Has -> Rule #2\nXla -> Needs -> Recompile\nXla -> Has -> Rule #3\n\nThis is a really useful trick, so remember it if you need to convert your own code to XLA!\n\n#### XLA Rule #3: XLA will need to recompile your model for every different input shape it sees\n\nThis is the big one. What this means is that if your input shapes are very variable, XLA will have to recompile your model over and over, which will create huge performance problems. This commonly arises in NLP models, where input texts have variable lengths after tokenization. In other modalities, static shapes are more common and this rule is much less of a problem.\n\nHow can you get around rule #3? The key is **padding** - if you pad all your inputs to the same length, and then use an `attention_mask`, you can get the same results as you\u2019d get from variable shapes, but without any XLA issues. However, excessive padding can cause severe slowdown too - if you pad all your samples to the maximum length in the whole dataset, you might end up with batches consisting endless padding tokens, which will waste a lot of compute and memory!\n\nThere isn\u2019t a perfect solution to this problem. However, you can try some tricks. One very useful trick is to **pad batches of samples up to a multiple of a number like 32 or 64 tokens.** This often only increases the number of tokens by a small amount, but it hugely reduces the number of unique input shapes, because every input shape now has to be a multiple of 32 or 64. Fewer unique input shapes means fewer XLA compilations!\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** Our tokenizers and data collators have methods that can help you here. You can use `padding=\"max_length\"` or `padding=\"longest\"` when calling tokenizers to get them to output padded data. Our tokenizers and data collators also have a `pad_to_multiple_of` argument that you can use to reduce the number of unique input shapes you see!\n\n</Tip>\n\n### How do I actually train my model on TPU?\n\nOnce your training is XLA-compatible and (if you\u2019re using TPU Node / Colab) your dataset has been prepared appropriately, running on TPU is surprisingly easy! All you really need to change in your code is to add a few lines to initialize your TPU, and to ensure that your model and dataset are created inside a `TPUStrategy` scope. Take a look at [our TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) to see this in action!\n\n### Summary\n\nThere was a lot in here, so let\u2019s summarize with a quick checklist you can follow when you want to get your model ready for TPU training:\n\n- Make sure your code follows the three rules of XLA\n- Compile your model with `jit_compile=True` on CPU/GPU and confirm that you can train it with XLA\n- Either load your dataset into memory or use a TPU-compatible dataset loading approach (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Migrate your code either to Colab (with accelerator set to \u201cTPU\u201d) or a TPU VM on Google Cloud\n- Add TPU initializer code (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Create your `TPUStrategy` and make sure dataset loading and model creation are inside the `strategy.scope()` (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Don\u2019t forget to take `jit_compile=True` out again when you move to TPU!\n- \ud83d\ude4f\ud83d\ude4f\ud83d\ude4f\ud83e\udd7a\ud83e\udd7a\ud83e\udd7a\n- Call model.fit()\n- You did it!"
            },
            {
                "score": 0.6198725052819992,
                "node_text": "Here are some facts extracted from the provided text:\n\nRule #2 -> Prohibits -> Data-dependent shapes\n\nWe\u2019ve distilled them into three core rules below:\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** We\u2019ve put a lot of effort into rewriting our TensorFlow models and loss functions to be XLA-compatible. Our models and loss functions generally obey rule #1 and #2 by default, so you can skip over them if you\u2019re using `transformers` models. Don\u2019t forget about these rules when writing your own models and loss functions, though!\n\n</Tip>\n\n#### XLA Rule #1: Your code cannot have \u201cdata-dependent conditionals\u201d\n\nWhat that means is that any `if` statement cannot depend on values inside a `tf.Tensor`. For example, this code block cannot be compiled with XLA!\n\n```python\nif tf.reduce_sum(tensor) > 10:\n    tensor = tensor / 2.0\n```\n\nThis might seem very restrictive at first, but most neural net code doesn\u2019t need to do this. You can often get around this restriction by using `tf.cond` (see the documentation [here](https://www.tensorflow.org/api_docs/python/tf/cond)) or by removing the conditional and finding a clever math trick with indicator variables instead, like so:\n\n```python\nsum_over_10 = tf.cast(tf.reduce_sum(tensor) > 10, tf.float32)\ntensor = tensor / (1.0 + sum_over_10)\n```\n\nThis code has exactly the same effect as the code above, but by avoiding a conditional, we ensure it will compile with XLA without problems!\n\n#### XLA Rule #2: Your code cannot have \u201cdata-dependent shapes\u201d\n\nWhat this means is that the shape of all of the `tf.Tensor` objects in your code cannot depend on their values. For example, the function `tf.unique` cannot be compiled with XLA, because it returns a `tensor` containing one instance of each unique value in the input. The shape of this output will obviously be different depending on how repetitive the input `Tensor` was, and so XLA refuses to handle it!\n\nIn general, most neural network code obeys rule #2 by default. However, there are a few common cases where it becomes a problem. One very common one is when you use **label masking**, setting your labels to a negative value to indicate that those positions should be ignored when computing the loss. If you look at NumPy or PyTorch loss functions that support label masking, you will often see code like this that uses [boolean indexing](https://numpy.org/doc/stable/user/basics.indexing.html#boolean-array-indexing):\n\n```python\nlabel_mask = labels >= 0\nmasked_outputs = outputs[label_mask]\nmasked_labels = labels[label_mask]\nloss = compute_loss(masked_outputs, masked_labels)\nmean_loss = torch.mean(loss)\n```\n\nThis code is totally fine in NumPy or PyTorch, but it breaks in XLA! Why? Because the shape of `masked_outputs` and `masked_labels` depends on how many positions are masked - that makes it a **data-dependent shape.** However, just like for rule #1, we can often rewrite this code to yield exactly the same output without any data-dependent shapes.\n\n```python\nlabel_mask = tf.cast(labels >= 0, tf.float32)\nloss = compute_loss(outputs, labels)\nloss = loss * label_mask  # Set negative label positions to 0\nmean_loss = tf.reduce_sum(loss) / tf.reduce_sum(label_mask)\n```\n\nHere, we avoid data-dependent shapes by computing the loss for every position, but zeroing out the masked positions in both the numerator and denominator when we calculate the mean, which yields exactly the same result as the first block while maintaining XLA compatibility. Note that we use the same trick as in rule #1 - converting a `tf.bool` to `tf.float32` and using it as an indicator variable. This is a really useful trick, so remember it if you need to convert your own code to XLA!\n\n#### XLA Rule #3: XLA will need to recompile your model for every different input shape it sees\n\nThis is the big one. What this means is that if your input shapes are very variable, XLA will have to recompile your model over and over, which will create huge performance problems. This commonly arises in NLP models, where input texts have variable lengths after tokenization. In other modalities, static shapes are more common and this rule is much less of a problem.\n\nHow can you get around rule #3? The key is **padding** - if you pad all your inputs to the same length, and then use an `attention_mask`, you can get the same results as you\u2019d get from variable shapes, but without any XLA issues."
            }
        ]
    },
    {
        "sample_idx": 65,
        "question": "Why can't the function tf.unique be compiled with XLA?",
        "answer": "Because it returns a tensor containing one instance of each unique value in the input, and the shape of this output will obviously be different depending on how repetitive the input Tensor was.",
        "rag_answer": "The function tf.unique cannot be compiled with XLA because it returns a tensor containing one instance of each unique value in the input, and the shape of this output depends on how repetitive the input tensor was.",
        "rag_score": 5,
        "rag_feedback": "The system's response is completely correct, accurate, and factual. It correctly explains why the function tf.unique cannot be compiled with XLA, which is because it returns a tensor containing one instance of each unique value in the input, and the shape of this output depends on how repetitive the input tensor was.",
        "rag_context": [
            {
                "score": 0.6957955879713967,
                "node_text": "Here are some facts extracted from the provided text:\n\nPadding -> Helps -> Avoid xla issues\nPadding -> Helps -> Xla issues\nXla -> Is used by -> Tensorflow and jax\n\nThis is a really useful trick, so remember it if you need to convert your own code to XLA!\n\n#### XLA Rule #3: XLA will need to recompile your model for every different input shape it sees\n\nThis is the big one. What this means is that if your input shapes are very variable, XLA will have to recompile your model over and over, which will create huge performance problems. This commonly arises in NLP models, where input texts have variable lengths after tokenization. In other modalities, static shapes are more common and this rule is much less of a problem.\n\nHow can you get around rule #3? The key is **padding** - if you pad all your inputs to the same length, and then use an `attention_mask`, you can get the same results as you\u2019d get from variable shapes, but without any XLA issues. However, excessive padding can cause severe slowdown too - if you pad all your samples to the maximum length in the whole dataset, you might end up with batches consisting endless padding tokens, which will waste a lot of compute and memory!\n\nThere isn\u2019t a perfect solution to this problem. However, you can try some tricks. One very useful trick is to **pad batches of samples up to a multiple of a number like 32 or 64 tokens.** This often only increases the number of tokens by a small amount, but it hugely reduces the number of unique input shapes, because every input shape now has to be a multiple of 32 or 64. Fewer unique input shapes means fewer XLA compilations!\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** Our tokenizers and data collators have methods that can help you here. You can use `padding=\"max_length\"` or `padding=\"longest\"` when calling tokenizers to get them to output padded data. Our tokenizers and data collators also have a `pad_to_multiple_of` argument that you can use to reduce the number of unique input shapes you see!\n\n</Tip>\n\n### How do I actually train my model on TPU?\n\nOnce your training is XLA-compatible and (if you\u2019re using TPU Node / Colab) your dataset has been prepared appropriately, running on TPU is surprisingly easy! All you really need to change in your code is to add a few lines to initialize your TPU, and to ensure that your model and dataset are created inside a `TPUStrategy` scope. Take a look at [our TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) to see this in action!\n\n### Summary\n\nThere was a lot in here, so let\u2019s summarize with a quick checklist you can follow when you want to get your model ready for TPU training:\n\n- Make sure your code follows the three rules of XLA\n- Compile your model with `jit_compile=True` on CPU/GPU and confirm that you can train it with XLA\n- Either load your dataset into memory or use a TPU-compatible dataset loading approach (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Migrate your code either to Colab (with accelerator set to \u201cTPU\u201d) or a TPU VM on Google Cloud\n- Add TPU initializer code (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Create your `TPUStrategy` and make sure dataset loading and model creation are inside the `strategy.scope()` (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Don\u2019t forget to take `jit_compile=True` out again when you move to TPU!\n- \ud83d\ude4f\ud83d\ude4f\ud83d\ude4f\ud83e\udd7a\ud83e\udd7a\ud83e\udd7a\n- Call model.fit()\n- You did it!"
            },
            {
                "score": 0.6034856808704087,
                "node_text": "Here are some facts extracted from the provided text:\n\nRule #3 -> Requires -> Recompilation for different input shapes\n\nWe\u2019ve distilled them into three core rules below:\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** We\u2019ve put a lot of effort into rewriting our TensorFlow models and loss functions to be XLA-compatible. Our models and loss functions generally obey rule #1 and #2 by default, so you can skip over them if you\u2019re using `transformers` models. Don\u2019t forget about these rules when writing your own models and loss functions, though!\n\n</Tip>\n\n#### XLA Rule #1: Your code cannot have \u201cdata-dependent conditionals\u201d\n\nWhat that means is that any `if` statement cannot depend on values inside a `tf.Tensor`. For example, this code block cannot be compiled with XLA!\n\n```python\nif tf.reduce_sum(tensor) > 10:\n    tensor = tensor / 2.0\n```\n\nThis might seem very restrictive at first, but most neural net code doesn\u2019t need to do this. You can often get around this restriction by using `tf.cond` (see the documentation [here](https://www.tensorflow.org/api_docs/python/tf/cond)) or by removing the conditional and finding a clever math trick with indicator variables instead, like so:\n\n```python\nsum_over_10 = tf.cast(tf.reduce_sum(tensor) > 10, tf.float32)\ntensor = tensor / (1.0 + sum_over_10)\n```\n\nThis code has exactly the same effect as the code above, but by avoiding a conditional, we ensure it will compile with XLA without problems!\n\n#### XLA Rule #2: Your code cannot have \u201cdata-dependent shapes\u201d\n\nWhat this means is that the shape of all of the `tf.Tensor` objects in your code cannot depend on their values. For example, the function `tf.unique` cannot be compiled with XLA, because it returns a `tensor` containing one instance of each unique value in the input. The shape of this output will obviously be different depending on how repetitive the input `Tensor` was, and so XLA refuses to handle it!\n\nIn general, most neural network code obeys rule #2 by default. However, there are a few common cases where it becomes a problem. One very common one is when you use **label masking**, setting your labels to a negative value to indicate that those positions should be ignored when computing the loss. If you look at NumPy or PyTorch loss functions that support label masking, you will often see code like this that uses [boolean indexing](https://numpy.org/doc/stable/user/basics.indexing.html#boolean-array-indexing):\n\n```python\nlabel_mask = labels >= 0\nmasked_outputs = outputs[label_mask]\nmasked_labels = labels[label_mask]\nloss = compute_loss(masked_outputs, masked_labels)\nmean_loss = torch.mean(loss)\n```\n\nThis code is totally fine in NumPy or PyTorch, but it breaks in XLA! Why? Because the shape of `masked_outputs` and `masked_labels` depends on how many positions are masked - that makes it a **data-dependent shape.** However, just like for rule #1, we can often rewrite this code to yield exactly the same output without any data-dependent shapes.\n\n```python\nlabel_mask = tf.cast(labels >= 0, tf.float32)\nloss = compute_loss(outputs, labels)\nloss = loss * label_mask  # Set negative label positions to 0\nmean_loss = tf.reduce_sum(loss) / tf.reduce_sum(label_mask)\n```\n\nHere, we avoid data-dependent shapes by computing the loss for every position, but zeroing out the masked positions in both the numerator and denominator when we calculate the mean, which yields exactly the same result as the first block while maintaining XLA compatibility. Note that we use the same trick as in rule #1 - converting a `tf.bool` to `tf.float32` and using it as an indicator variable. This is a really useful trick, so remember it if you need to convert your own code to XLA!\n\n#### XLA Rule #3: XLA will need to recompile your model for every different input shape it sees\n\nThis is the big one. What this means is that if your input shapes are very variable, XLA will have to recompile your model over and over, which will create huge performance problems. This commonly arises in NLP models, where input texts have variable lengths after tokenization. In other modalities, static shapes are more common and this rule is much less of a problem.\n\nHow can you get around rule #3? The key is **padding** - if you pad all your inputs to the same length, and then use an `attention_mask`, you can get the same results as you\u2019d get from variable shapes, but without any XLA issues."
            }
        ]
    },
    {
        "sample_idx": 66,
        "question": "What is a common case where XLA Rule #2 becomes a problem in neural network code?",
        "answer": "When you use label masking, setting your labels to a negative value to indicate that those positions should be ignored when computing the loss.",
        "rag_answer": "A common case where XLA Rule #2 becomes a problem in neural network code is when you use label masking, setting your labels to a negative value to indicate that those positions should be ignored when computing the loss.",
        "rag_score": 5,
        "rag_feedback": "The system's response is completely correct, accurate, and factual. It provides a clear and concise answer to the question, matching the expected answer.",
        "rag_context": [
            {
                "score": 1.0,
                "node_text": "Here are some facts extracted from the provided text:\n\nRule #2 -> Prohibits -> Data-dependent shapes\n\nWe\u2019ve distilled them into three core rules below:\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** We\u2019ve put a lot of effort into rewriting our TensorFlow models and loss functions to be XLA-compatible. Our models and loss functions generally obey rule #1 and #2 by default, so you can skip over them if you\u2019re using `transformers` models. Don\u2019t forget about these rules when writing your own models and loss functions, though!\n\n</Tip>\n\n#### XLA Rule #1: Your code cannot have \u201cdata-dependent conditionals\u201d\n\nWhat that means is that any `if` statement cannot depend on values inside a `tf.Tensor`. For example, this code block cannot be compiled with XLA!\n\n```python\nif tf.reduce_sum(tensor) > 10:\n    tensor = tensor / 2.0\n```\n\nThis might seem very restrictive at first, but most neural net code doesn\u2019t need to do this. You can often get around this restriction by using `tf.cond` (see the documentation [here](https://www.tensorflow.org/api_docs/python/tf/cond)) or by removing the conditional and finding a clever math trick with indicator variables instead, like so:\n\n```python\nsum_over_10 = tf.cast(tf.reduce_sum(tensor) > 10, tf.float32)\ntensor = tensor / (1.0 + sum_over_10)\n```\n\nThis code has exactly the same effect as the code above, but by avoiding a conditional, we ensure it will compile with XLA without problems!\n\n#### XLA Rule #2: Your code cannot have \u201cdata-dependent shapes\u201d\n\nWhat this means is that the shape of all of the `tf.Tensor` objects in your code cannot depend on their values. For example, the function `tf.unique` cannot be compiled with XLA, because it returns a `tensor` containing one instance of each unique value in the input. The shape of this output will obviously be different depending on how repetitive the input `Tensor` was, and so XLA refuses to handle it!\n\nIn general, most neural network code obeys rule #2 by default. However, there are a few common cases where it becomes a problem. One very common one is when you use **label masking**, setting your labels to a negative value to indicate that those positions should be ignored when computing the loss. If you look at NumPy or PyTorch loss functions that support label masking, you will often see code like this that uses [boolean indexing](https://numpy.org/doc/stable/user/basics.indexing.html#boolean-array-indexing):\n\n```python\nlabel_mask = labels >= 0\nmasked_outputs = outputs[label_mask]\nmasked_labels = labels[label_mask]\nloss = compute_loss(masked_outputs, masked_labels)\nmean_loss = torch.mean(loss)\n```\n\nThis code is totally fine in NumPy or PyTorch, but it breaks in XLA! Why? Because the shape of `masked_outputs` and `masked_labels` depends on how many positions are masked - that makes it a **data-dependent shape.** However, just like for rule #1, we can often rewrite this code to yield exactly the same output without any data-dependent shapes.\n\n```python\nlabel_mask = tf.cast(labels >= 0, tf.float32)\nloss = compute_loss(outputs, labels)\nloss = loss * label_mask  # Set negative label positions to 0\nmean_loss = tf.reduce_sum(loss) / tf.reduce_sum(label_mask)\n```\n\nHere, we avoid data-dependent shapes by computing the loss for every position, but zeroing out the masked positions in both the numerator and denominator when we calculate the mean, which yields exactly the same result as the first block while maintaining XLA compatibility. Note that we use the same trick as in rule #1 - converting a `tf.bool` to `tf.float32` and using it as an indicator variable. This is a really useful trick, so remember it if you need to convert your own code to XLA!\n\n#### XLA Rule #3: XLA will need to recompile your model for every different input shape it sees\n\nThis is the big one. What this means is that if your input shapes are very variable, XLA will have to recompile your model over and over, which will create huge performance problems. This commonly arises in NLP models, where input texts have variable lengths after tokenization. In other modalities, static shapes are more common and this rule is much less of a problem.\n\nHow can you get around rule #3? The key is **padding** - if you pad all your inputs to the same length, and then use an `attention_mask`, you can get the same results as you\u2019d get from variable shapes, but without any XLA issues."
            },
            {
                "score": 1.0,
                "node_text": "Here are some facts extracted from the provided text:\n\nXla -> Has -> Rule #2\n\nThis is a really useful trick, so remember it if you need to convert your own code to XLA!\n\n#### XLA Rule #3: XLA will need to recompile your model for every different input shape it sees\n\nThis is the big one. What this means is that if your input shapes are very variable, XLA will have to recompile your model over and over, which will create huge performance problems. This commonly arises in NLP models, where input texts have variable lengths after tokenization. In other modalities, static shapes are more common and this rule is much less of a problem.\n\nHow can you get around rule #3? The key is **padding** - if you pad all your inputs to the same length, and then use an `attention_mask`, you can get the same results as you\u2019d get from variable shapes, but without any XLA issues. However, excessive padding can cause severe slowdown too - if you pad all your samples to the maximum length in the whole dataset, you might end up with batches consisting endless padding tokens, which will waste a lot of compute and memory!\n\nThere isn\u2019t a perfect solution to this problem. However, you can try some tricks. One very useful trick is to **pad batches of samples up to a multiple of a number like 32 or 64 tokens.** This often only increases the number of tokens by a small amount, but it hugely reduces the number of unique input shapes, because every input shape now has to be a multiple of 32 or 64. Fewer unique input shapes means fewer XLA compilations!\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** Our tokenizers and data collators have methods that can help you here. You can use `padding=\"max_length\"` or `padding=\"longest\"` when calling tokenizers to get them to output padded data. Our tokenizers and data collators also have a `pad_to_multiple_of` argument that you can use to reduce the number of unique input shapes you see!\n\n</Tip>\n\n### How do I actually train my model on TPU?\n\nOnce your training is XLA-compatible and (if you\u2019re using TPU Node / Colab) your dataset has been prepared appropriately, running on TPU is surprisingly easy! All you really need to change in your code is to add a few lines to initialize your TPU, and to ensure that your model and dataset are created inside a `TPUStrategy` scope. Take a look at [our TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) to see this in action!\n\n### Summary\n\nThere was a lot in here, so let\u2019s summarize with a quick checklist you can follow when you want to get your model ready for TPU training:\n\n- Make sure your code follows the three rules of XLA\n- Compile your model with `jit_compile=True` on CPU/GPU and confirm that you can train it with XLA\n- Either load your dataset into memory or use a TPU-compatible dataset loading approach (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Migrate your code either to Colab (with accelerator set to \u201cTPU\u201d) or a TPU VM on Google Cloud\n- Add TPU initializer code (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Create your `TPUStrategy` and make sure dataset loading and model creation are inside the `strategy.scope()` (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Don\u2019t forget to take `jit_compile=True` out again when you move to TPU!\n- \ud83d\ude4f\ud83d\ude4f\ud83d\ude4f\ud83e\udd7a\ud83e\udd7a\ud83e\udd7a\n- Call model.fit()\n- You did it!"
            },
            {
                "score": 0.6903772911143622,
                "node_text": "Here are some facts extracted from the provided text:\n\nPadding -> Helps -> Avoid xla issues\nPadding -> Helps -> Xla issues\nTpu -> Used for -> Neural networks\nXla -> Is -> Optimizing compiler\nXla -> Is used by -> Tensorflow and jax\nXla -> Is mandatory on -> Tpu\nXla -> Recompile -> Model\nXla -> Has -> Rule #1\nXla -> Has -> Rule #2\nXla -> Needs -> Recompile\nXla -> Has -> Rule #3\n\nThis is a really useful trick, so remember it if you need to convert your own code to XLA!\n\n#### XLA Rule #3: XLA will need to recompile your model for every different input shape it sees\n\nThis is the big one. What this means is that if your input shapes are very variable, XLA will have to recompile your model over and over, which will create huge performance problems. This commonly arises in NLP models, where input texts have variable lengths after tokenization. In other modalities, static shapes are more common and this rule is much less of a problem.\n\nHow can you get around rule #3? The key is **padding** - if you pad all your inputs to the same length, and then use an `attention_mask`, you can get the same results as you\u2019d get from variable shapes, but without any XLA issues. However, excessive padding can cause severe slowdown too - if you pad all your samples to the maximum length in the whole dataset, you might end up with batches consisting endless padding tokens, which will waste a lot of compute and memory!\n\nThere isn\u2019t a perfect solution to this problem. However, you can try some tricks. One very useful trick is to **pad batches of samples up to a multiple of a number like 32 or 64 tokens.** This often only increases the number of tokens by a small amount, but it hugely reduces the number of unique input shapes, because every input shape now has to be a multiple of 32 or 64. Fewer unique input shapes means fewer XLA compilations!\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** Our tokenizers and data collators have methods that can help you here. You can use `padding=\"max_length\"` or `padding=\"longest\"` when calling tokenizers to get them to output padded data. Our tokenizers and data collators also have a `pad_to_multiple_of` argument that you can use to reduce the number of unique input shapes you see!\n\n</Tip>\n\n### How do I actually train my model on TPU?\n\nOnce your training is XLA-compatible and (if you\u2019re using TPU Node / Colab) your dataset has been prepared appropriately, running on TPU is surprisingly easy! All you really need to change in your code is to add a few lines to initialize your TPU, and to ensure that your model and dataset are created inside a `TPUStrategy` scope. Take a look at [our TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) to see this in action!\n\n### Summary\n\nThere was a lot in here, so let\u2019s summarize with a quick checklist you can follow when you want to get your model ready for TPU training:\n\n- Make sure your code follows the three rules of XLA\n- Compile your model with `jit_compile=True` on CPU/GPU and confirm that you can train it with XLA\n- Either load your dataset into memory or use a TPU-compatible dataset loading approach (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Migrate your code either to Colab (with accelerator set to \u201cTPU\u201d) or a TPU VM on Google Cloud\n- Add TPU initializer code (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Create your `TPUStrategy` and make sure dataset loading and model creation are inside the `strategy.scope()` (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Don\u2019t forget to take `jit_compile=True` out again when you move to TPU!\n- \ud83d\ude4f\ud83d\ude4f\ud83d\ude4f\ud83e\udd7a\ud83e\udd7a\ud83e\udd7a\n- Call model.fit()\n- You did it!"
            }
        ]
    },
    {
        "sample_idx": 67,
        "question": "Why does the code break in XLA?",
        "answer": "Because the shape of `masked_outputs` and `masked_labels` depends on how many positions are masked, making it a data-dependent shape.",
        "rag_answer": "The code breaks in XLA because of variable input shapes, which cause XLA to recompile the model over and over, leading to huge performance problems.",
        "rag_score": 4,
        "rag_feedback": "The system's response is mostly correct, accurate, and factual. It correctly identifies the issue with XLA as being related to variable input shapes, which causes XLA to recompile the model, leading to performance problems. However, it does not directly address the specific issue of the shape of `masked_outputs` and `masked_labels` depending on the number of masked positions.",
        "rag_context": [
            {
                "score": 0.8269476729542041,
                "node_text": "Here are some facts extracted from the provided text:\n\nPadding -> Helps -> Xla issues\nPadding -> Helps -> Avoid xla issues\nXla -> Is -> Optimizing compiler\nXla -> Is used by -> Tensorflow and jax\nXla -> Is mandatory on -> Tpu\nXla -> Recompile -> Model\nXla -> Has -> Rule #1\nXla -> Has -> Rule #2\nXla -> Needs -> Recompile\nXla -> Has -> Rule #3\n\nThis is a really useful trick, so remember it if you need to convert your own code to XLA!\n\n#### XLA Rule #3: XLA will need to recompile your model for every different input shape it sees\n\nThis is the big one. What this means is that if your input shapes are very variable, XLA will have to recompile your model over and over, which will create huge performance problems. This commonly arises in NLP models, where input texts have variable lengths after tokenization. In other modalities, static shapes are more common and this rule is much less of a problem.\n\nHow can you get around rule #3? The key is **padding** - if you pad all your inputs to the same length, and then use an `attention_mask`, you can get the same results as you\u2019d get from variable shapes, but without any XLA issues. However, excessive padding can cause severe slowdown too - if you pad all your samples to the maximum length in the whole dataset, you might end up with batches consisting endless padding tokens, which will waste a lot of compute and memory!\n\nThere isn\u2019t a perfect solution to this problem. However, you can try some tricks. One very useful trick is to **pad batches of samples up to a multiple of a number like 32 or 64 tokens.** This often only increases the number of tokens by a small amount, but it hugely reduces the number of unique input shapes, because every input shape now has to be a multiple of 32 or 64. Fewer unique input shapes means fewer XLA compilations!\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** Our tokenizers and data collators have methods that can help you here. You can use `padding=\"max_length\"` or `padding=\"longest\"` when calling tokenizers to get them to output padded data. Our tokenizers and data collators also have a `pad_to_multiple_of` argument that you can use to reduce the number of unique input shapes you see!\n\n</Tip>\n\n### How do I actually train my model on TPU?\n\nOnce your training is XLA-compatible and (if you\u2019re using TPU Node / Colab) your dataset has been prepared appropriately, running on TPU is surprisingly easy! All you really need to change in your code is to add a few lines to initialize your TPU, and to ensure that your model and dataset are created inside a `TPUStrategy` scope. Take a look at [our TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) to see this in action!\n\n### Summary\n\nThere was a lot in here, so let\u2019s summarize with a quick checklist you can follow when you want to get your model ready for TPU training:\n\n- Make sure your code follows the three rules of XLA\n- Compile your model with `jit_compile=True` on CPU/GPU and confirm that you can train it with XLA\n- Either load your dataset into memory or use a TPU-compatible dataset loading approach (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Migrate your code either to Colab (with accelerator set to \u201cTPU\u201d) or a TPU VM on Google Cloud\n- Add TPU initializer code (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Create your `TPUStrategy` and make sure dataset loading and model creation are inside the `strategy.scope()` (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Don\u2019t forget to take `jit_compile=True` out again when you move to TPU!\n- \ud83d\ude4f\ud83d\ude4f\ud83d\ude4f\ud83e\udd7a\ud83e\udd7a\ud83e\udd7a\n- Call model.fit()\n- You did it!"
            },
            {
                "score": 0.557287914299978,
                "node_text": "Here are some facts extracted from the provided text:\n\nSlider -> Has -> Maximum 15\n\nGradio Demo: blocks_random_slider\n\n\n```\n!pip install -q gradio \n```\n\n\n```\n\nimport gradio as gr\n\n\ndef func(slider_1, slider_2):\n    return slider_1 * 5 + slider_2\n\n\nwith gr.Blocks() as demo:\n    slider = gr.Slider(minimum=-10.2, maximum=15, label=\"Random Slider (Static)\", randomize=True)\n    slider_1 = gr.Slider(minimum=100, maximum=200, label=\"Random Slider (Input 1)\", randomize=True)\n    slider_2 = gr.Slider(minimum=10, maximum=23.2, label=\"Random Slider (Input 2)\", randomize=True)\n    slider_3 = gr.Slider(value=3, label=\"Non random slider\")\n    btn = gr.Button(\"Run\")\n    btn.click(func, inputs=[slider_1, slider_2], outputs=gr.Number())\n\nif __name__ == \"__main__\":\n    demo.launch()\n\n```"
            }
        ]
    },
    {
        "sample_idx": 68,
        "question": "How can the code be rewritten to avoid data-dependent shapes?",
        "answer": "By computing the loss for every position and zeroing out the masked positions in both the numerator and denominator when calculating the mean.",
        "rag_answer": "The code can be rewritten to avoid data-dependent shapes by computing the loss for every position, but zeroing out the masked positions in both the numerator and denominator when calculating the mean, which yields exactly the same result as the original code while maintaining XLA compatibility.",
        "rag_score": 5,
        "rag_feedback": "The system's response is completely correct, accurate, and factual. It directly answers the question by explaining how to rewrite the code to avoid data-dependent shapes, which is to compute the loss for every position and zero out the masked positions in both the numerator and denominator when calculating the mean.",
        "rag_context": [
            {
                "score": 0.8288149303206919,
                "node_text": "Here are some facts extracted from the provided text:\n\nRule #2 -> Prohibits -> Data-dependent shapes\nRule #3 -> Requires -> Recompilation for different input shapes\n\nWe\u2019ve distilled them into three core rules below:\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** We\u2019ve put a lot of effort into rewriting our TensorFlow models and loss functions to be XLA-compatible. Our models and loss functions generally obey rule #1 and #2 by default, so you can skip over them if you\u2019re using `transformers` models. Don\u2019t forget about these rules when writing your own models and loss functions, though!\n\n</Tip>\n\n#### XLA Rule #1: Your code cannot have \u201cdata-dependent conditionals\u201d\n\nWhat that means is that any `if` statement cannot depend on values inside a `tf.Tensor`. For example, this code block cannot be compiled with XLA!\n\n```python\nif tf.reduce_sum(tensor) > 10:\n    tensor = tensor / 2.0\n```\n\nThis might seem very restrictive at first, but most neural net code doesn\u2019t need to do this. You can often get around this restriction by using `tf.cond` (see the documentation [here](https://www.tensorflow.org/api_docs/python/tf/cond)) or by removing the conditional and finding a clever math trick with indicator variables instead, like so:\n\n```python\nsum_over_10 = tf.cast(tf.reduce_sum(tensor) > 10, tf.float32)\ntensor = tensor / (1.0 + sum_over_10)\n```\n\nThis code has exactly the same effect as the code above, but by avoiding a conditional, we ensure it will compile with XLA without problems!\n\n#### XLA Rule #2: Your code cannot have \u201cdata-dependent shapes\u201d\n\nWhat this means is that the shape of all of the `tf.Tensor` objects in your code cannot depend on their values. For example, the function `tf.unique` cannot be compiled with XLA, because it returns a `tensor` containing one instance of each unique value in the input. The shape of this output will obviously be different depending on how repetitive the input `Tensor` was, and so XLA refuses to handle it!\n\nIn general, most neural network code obeys rule #2 by default. However, there are a few common cases where it becomes a problem. One very common one is when you use **label masking**, setting your labels to a negative value to indicate that those positions should be ignored when computing the loss. If you look at NumPy or PyTorch loss functions that support label masking, you will often see code like this that uses [boolean indexing](https://numpy.org/doc/stable/user/basics.indexing.html#boolean-array-indexing):\n\n```python\nlabel_mask = labels >= 0\nmasked_outputs = outputs[label_mask]\nmasked_labels = labels[label_mask]\nloss = compute_loss(masked_outputs, masked_labels)\nmean_loss = torch.mean(loss)\n```\n\nThis code is totally fine in NumPy or PyTorch, but it breaks in XLA! Why? Because the shape of `masked_outputs` and `masked_labels` depends on how many positions are masked - that makes it a **data-dependent shape.** However, just like for rule #1, we can often rewrite this code to yield exactly the same output without any data-dependent shapes.\n\n```python\nlabel_mask = tf.cast(labels >= 0, tf.float32)\nloss = compute_loss(outputs, labels)\nloss = loss * label_mask  # Set negative label positions to 0\nmean_loss = tf.reduce_sum(loss) / tf.reduce_sum(label_mask)\n```\n\nHere, we avoid data-dependent shapes by computing the loss for every position, but zeroing out the masked positions in both the numerator and denominator when we calculate the mean, which yields exactly the same result as the first block while maintaining XLA compatibility. Note that we use the same trick as in rule #1 - converting a `tf.bool` to `tf.float32` and using it as an indicator variable. This is a really useful trick, so remember it if you need to convert your own code to XLA!\n\n#### XLA Rule #3: XLA will need to recompile your model for every different input shape it sees\n\nThis is the big one. What this means is that if your input shapes are very variable, XLA will have to recompile your model over and over, which will create huge performance problems. This commonly arises in NLP models, where input texts have variable lengths after tokenization. In other modalities, static shapes are more common and this rule is much less of a problem.\n\nHow can you get around rule #3? The key is **padding** - if you pad all your inputs to the same length, and then use an `attention_mask`, you can get the same results as you\u2019d get from variable shapes, but without any XLA issues."
            },
            {
                "score": 0.6208999589342343,
                "node_text": "Here are some facts extracted from the provided text:\n\nGradio -> Supports -> Hugging face models\n\nGradio Demo: blocks_random_slider\n\n\n```\n!pip install -q gradio \n```\n\n\n```\n\nimport gradio as gr\n\n\ndef func(slider_1, slider_2):\n    return slider_1 * 5 + slider_2\n\n\nwith gr.Blocks() as demo:\n    slider = gr.Slider(minimum=-10.2, maximum=15, label=\"Random Slider (Static)\", randomize=True)\n    slider_1 = gr.Slider(minimum=100, maximum=200, label=\"Random Slider (Input 1)\", randomize=True)\n    slider_2 = gr.Slider(minimum=10, maximum=23.2, label=\"Random Slider (Input 2)\", randomize=True)\n    slider_3 = gr.Slider(value=3, label=\"Non random slider\")\n    btn = gr.Button(\"Run\")\n    btn.click(func, inputs=[slider_1, slider_2], outputs=gr.Number())\n\nif __name__ == \"__main__\":\n    demo.launch()\n\n```"
            },
            {
                "score": 0.6036106609078443,
                "node_text": "Here are some facts extracted from the provided text:\n\nInput shape -> Is -> Variable\n\nThis is a really useful trick, so remember it if you need to convert your own code to XLA!\n\n#### XLA Rule #3: XLA will need to recompile your model for every different input shape it sees\n\nThis is the big one. What this means is that if your input shapes are very variable, XLA will have to recompile your model over and over, which will create huge performance problems. This commonly arises in NLP models, where input texts have variable lengths after tokenization. In other modalities, static shapes are more common and this rule is much less of a problem.\n\nHow can you get around rule #3? The key is **padding** - if you pad all your inputs to the same length, and then use an `attention_mask`, you can get the same results as you\u2019d get from variable shapes, but without any XLA issues. However, excessive padding can cause severe slowdown too - if you pad all your samples to the maximum length in the whole dataset, you might end up with batches consisting endless padding tokens, which will waste a lot of compute and memory!\n\nThere isn\u2019t a perfect solution to this problem. However, you can try some tricks. One very useful trick is to **pad batches of samples up to a multiple of a number like 32 or 64 tokens.** This often only increases the number of tokens by a small amount, but it hugely reduces the number of unique input shapes, because every input shape now has to be a multiple of 32 or 64. Fewer unique input shapes means fewer XLA compilations!\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** Our tokenizers and data collators have methods that can help you here. You can use `padding=\"max_length\"` or `padding=\"longest\"` when calling tokenizers to get them to output padded data. Our tokenizers and data collators also have a `pad_to_multiple_of` argument that you can use to reduce the number of unique input shapes you see!\n\n</Tip>\n\n### How do I actually train my model on TPU?\n\nOnce your training is XLA-compatible and (if you\u2019re using TPU Node / Colab) your dataset has been prepared appropriately, running on TPU is surprisingly easy! All you really need to change in your code is to add a few lines to initialize your TPU, and to ensure that your model and dataset are created inside a `TPUStrategy` scope. Take a look at [our TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) to see this in action!\n\n### Summary\n\nThere was a lot in here, so let\u2019s summarize with a quick checklist you can follow when you want to get your model ready for TPU training:\n\n- Make sure your code follows the three rules of XLA\n- Compile your model with `jit_compile=True` on CPU/GPU and confirm that you can train it with XLA\n- Either load your dataset into memory or use a TPU-compatible dataset loading approach (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Migrate your code either to Colab (with accelerator set to \u201cTPU\u201d) or a TPU VM on Google Cloud\n- Add TPU initializer code (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Create your `TPUStrategy` and make sure dataset loading and model creation are inside the `strategy.scope()` (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Don\u2019t forget to take `jit_compile=True` out again when you move to TPU!\n- \ud83d\ude4f\ud83d\ude4f\ud83d\ude4f\ud83e\udd7a\ud83e\udd7a\ud83e\udd7a\n- Call model.fit()\n- You did it!"
            },
            {
                "score": 0.6036106609078443,
                "node_text": "Here are some facts extracted from the provided text:\n\nModel -> Has -> Input shape\n\n!---\nCopyright 2022 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n-->\n\n# Token classification with LayoutLMv3 (PyTorch version)\n\nThis directory contains a script, `run_funsd_cord.py`, that can be used to fine-tune (or evaluate) LayoutLMv3 on form understanding datasets, such as [FUNSD](https://guillaumejaume.github.io/FUNSD/) and [CORD](https://github.com/clovaai/cord).\n\nThe script `run_funsd_cord.py` leverages the \ud83e\udd17 Datasets library and the Trainer API. You can easily customize it to your needs.\n\n## Fine-tuning on FUNSD\n\nFine-tuning LayoutLMv3 for token classification on [FUNSD](https://guillaumejaume.github.io/FUNSD/) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name funsd \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 1e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-funsd\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd. By specifying the `push_to_hub` flag, the model gets uploaded automatically to the hub (regularly), together with a model card, which includes metrics such as precision, recall and F1. Note that you can easily update the model card, as it's just a README file of the respective repo on the hub.\n\nThere's also the \"Training metrics\" [tab](https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd/tensorboard), which shows Tensorboard logs over the course of training. Pretty neat, huh?\n\n## Fine-tuning on CORD\n\nFine-tuning LayoutLMv3 for token classification on [CORD](https://github.com/clovaai/cord) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name cord \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 5e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-cord\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-cord. Note that a model card gets generated automatically in case you specify the `push_to_hub` flag."
            }
        ]
    },
    {
        "sample_idx": 69,
        "question": "What trick is used to convert a `tf.bool` to `tf.float32`?",
        "answer": "Converting a `tf.bool` to `tf.float32` and using it as an indicator variable.",
        "rag_answer": "There is no mention of converting a `tf.bool` to `tf.float32` in the provided context. The context discusses XLA, TPU, and training models on TPU with TensorFlow, but it does not mention this specific conversion trick.",
        "rag_score": 1,
        "rag_feedback": "The system's response does not provide a correct answer to the question. The response is a passage of text that discusses XLA, TPU, and training models on TPU with TensorFlow, but it does not mention the specific conversion trick of converting a `tf.bool` to `tf.float32`.",
        "rag_context": [
            {
                "score": 0.6564725678251851,
                "node_text": "Here are some facts extracted from the provided text:\n\nXla -> Is used by -> Tensorflow and jax\nTpu -> Is -> Tensor processing unit\n\nThis is a really useful trick, so remember it if you need to convert your own code to XLA!\n\n#### XLA Rule #3: XLA will need to recompile your model for every different input shape it sees\n\nThis is the big one. What this means is that if your input shapes are very variable, XLA will have to recompile your model over and over, which will create huge performance problems. This commonly arises in NLP models, where input texts have variable lengths after tokenization. In other modalities, static shapes are more common and this rule is much less of a problem.\n\nHow can you get around rule #3? The key is **padding** - if you pad all your inputs to the same length, and then use an `attention_mask`, you can get the same results as you\u2019d get from variable shapes, but without any XLA issues. However, excessive padding can cause severe slowdown too - if you pad all your samples to the maximum length in the whole dataset, you might end up with batches consisting endless padding tokens, which will waste a lot of compute and memory!\n\nThere isn\u2019t a perfect solution to this problem. However, you can try some tricks. One very useful trick is to **pad batches of samples up to a multiple of a number like 32 or 64 tokens.** This often only increases the number of tokens by a small amount, but it hugely reduces the number of unique input shapes, because every input shape now has to be a multiple of 32 or 64. Fewer unique input shapes means fewer XLA compilations!\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** Our tokenizers and data collators have methods that can help you here. You can use `padding=\"max_length\"` or `padding=\"longest\"` when calling tokenizers to get them to output padded data. Our tokenizers and data collators also have a `pad_to_multiple_of` argument that you can use to reduce the number of unique input shapes you see!\n\n</Tip>\n\n### How do I actually train my model on TPU?\n\nOnce your training is XLA-compatible and (if you\u2019re using TPU Node / Colab) your dataset has been prepared appropriately, running on TPU is surprisingly easy! All you really need to change in your code is to add a few lines to initialize your TPU, and to ensure that your model and dataset are created inside a `TPUStrategy` scope. Take a look at [our TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) to see this in action!\n\n### Summary\n\nThere was a lot in here, so let\u2019s summarize with a quick checklist you can follow when you want to get your model ready for TPU training:\n\n- Make sure your code follows the three rules of XLA\n- Compile your model with `jit_compile=True` on CPU/GPU and confirm that you can train it with XLA\n- Either load your dataset into memory or use a TPU-compatible dataset loading approach (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Migrate your code either to Colab (with accelerator set to \u201cTPU\u201d) or a TPU VM on Google Cloud\n- Add TPU initializer code (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Create your `TPUStrategy` and make sure dataset loading and model creation are inside the `strategy.scope()` (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Don\u2019t forget to take `jit_compile=True` out again when you move to TPU!\n- \ud83d\ude4f\ud83d\ude4f\ud83d\ude4f\ud83e\udd7a\ud83e\udd7a\ud83e\udd7a\n- Call model.fit()\n- You did it!"
            },
            {
                "score": 0.6319839709134143,
                "node_text": "Here are some facts extracted from the provided text:\n\nTensorflow models -> Are -> Keras models\nHuggingface ecosystem -> Includes -> Transformers and datasets\n\n!--Copyright 2023 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\nthe License. You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under the License is distributed on\nan \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n\n\u26a0\ufe0f Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be\nrendered properly in your Markdown viewer.\n\n-->\n\n# Training on TPU with TensorFlow\n\n<Tip>\n\nIf you don't need long explanations and just want TPU code samples to get started with, check out [our TPU example notebook!](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb)\n\n</Tip>\n\n### What is a TPU?\n\nA TPU is a **Tensor Processing Unit.** They are hardware designed by Google, which are used to greatly speed up the tensor computations within neural networks, much like GPUs. They can be used for both network training and inference. They are generally accessed through Google\u2019s cloud services, but small TPUs can also be accessed directly for free through Google Colab and Kaggle Kernels.\n\nBecause [all TensorFlow models in \ud83e\udd17 Transformers are Keras models](https://huggingface.co/blog/tensorflow-philosophy), most of the methods in this document are generally applicable to TPU training for any Keras model! However, there are a few points that are specific to the HuggingFace ecosystem (hug-o-system?) of Transformers and Datasets, and we\u2019ll make sure to flag them up when we get to them.\n\n### What kinds of TPU are available?\n\nNew users are often very confused by the range of TPUs, and the different ways to access them. The first key distinction to understand is the difference between **TPU Nodes** and **TPU VMs.**\n\nWhen you use a **TPU Node**, you are effectively indirectly accessing a remote TPU. You will need a separate VM, which will initialize your network and data pipeline and then forward them to the remote node. When you use a TPU on Google Colab, you are accessing it in the **TPU Node** style.\n\nUsing TPU Nodes can have some quite unexpected behaviour for people who aren\u2019t used to them! In particular, because the TPU is located on a physically different system to the machine you\u2019re running your Python code on, your data cannot be local to your machine - any data pipeline that loads from your machine\u2019s internal storage will totally fail! Instead, data must be stored in Google Cloud Storage where your data pipeline can still access it, even when the pipeline is running on the remote TPU node.\n\n<Tip>\n\nIf you can fit all your data in memory as `np.ndarray` or `tf.Tensor`, then you can `fit()` on that data even when using Colab or a TPU Node, without needing to upload it to Google Cloud Storage.\n\n</Tip>\n\n<Tip>\n\n**\ud83e\udd17Specific Hugging Face Tip\ud83e\udd17:** The methods `Dataset.to_tf_dataset()` and its higher-level wrapper `model.prepare_tf_dataset()` , which you will see throughout our TF code examples, will both fail on a TPU Node. The reason for this is that even though they create a `tf.data.Dataset` it is not a \u201cpure\u201d `tf.data` pipeline and uses `tf.numpy_function` or `Dataset.from_generator()` to stream data from the underlying HuggingFace `Dataset`. This HuggingFace `Dataset` is backed by data that is on a local disc and which the remote TPU Node will not be able to read.\n\n</Tip>\n\nThe second way to access a TPU is via a **TPU VM.** When using a TPU VM, you connect directly to the machine that the TPU is attached to, much like training on a GPU VM. TPU VMs are generally easier to work with, particularly when it comes to your data pipeline. All of the above warnings do not apply to TPU VMs!\n\nThis is an opinionated document, so here\u2019s our opinion: **Avoid using TPU Node if possible.** It is more confusing and more difficult to debug than TPU VMs. It is also likely to be unsupported in future - Google\u2019s latest TPU, TPUv4, can only be accessed as a TPU VM, which suggests that TPU Nodes are increasingly going to become a \u201clegacy\u201d access method."
            }
        ]
    },
    {
        "sample_idx": 70,
        "question": "What happens if XLA sees different input shapes?",
        "answer": "XLA will need to recompile the model for every different input shape it sees.",
        "rag_answer": "XLA will need to recompile the model for every different input shape it sees, which can create huge performance problems.",
        "rag_score": 5,
        "rag_feedback": "The system's response is completely correct, accurate, and factual. It matches the expected answer and provides additional relevant information about XLA recompiling the model for every different input shape it sees, which can create huge performance problems.",
        "rag_context": [
            {
                "score": 0.7332884278715976,
                "node_text": "Here are some facts extracted from the provided text:\n\nPadding -> Helps -> Xla issues\nPadding -> Helps -> Avoid xla issues\nXla -> Is -> Optimizing compiler\nXla -> Is used by -> Tensorflow and jax\nXla -> Is mandatory on -> Tpu\nXla -> Recompile -> Model\nXla -> Has -> Rule #1\nXla -> Has -> Rule #2\nXla -> Needs -> Recompile\nXla -> Has -> Rule #3\n\nThis is a really useful trick, so remember it if you need to convert your own code to XLA!\n\n#### XLA Rule #3: XLA will need to recompile your model for every different input shape it sees\n\nThis is the big one. What this means is that if your input shapes are very variable, XLA will have to recompile your model over and over, which will create huge performance problems. This commonly arises in NLP models, where input texts have variable lengths after tokenization. In other modalities, static shapes are more common and this rule is much less of a problem.\n\nHow can you get around rule #3? The key is **padding** - if you pad all your inputs to the same length, and then use an `attention_mask`, you can get the same results as you\u2019d get from variable shapes, but without any XLA issues. However, excessive padding can cause severe slowdown too - if you pad all your samples to the maximum length in the whole dataset, you might end up with batches consisting endless padding tokens, which will waste a lot of compute and memory!\n\nThere isn\u2019t a perfect solution to this problem. However, you can try some tricks. One very useful trick is to **pad batches of samples up to a multiple of a number like 32 or 64 tokens.** This often only increases the number of tokens by a small amount, but it hugely reduces the number of unique input shapes, because every input shape now has to be a multiple of 32 or 64. Fewer unique input shapes means fewer XLA compilations!\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** Our tokenizers and data collators have methods that can help you here. You can use `padding=\"max_length\"` or `padding=\"longest\"` when calling tokenizers to get them to output padded data. Our tokenizers and data collators also have a `pad_to_multiple_of` argument that you can use to reduce the number of unique input shapes you see!\n\n</Tip>\n\n### How do I actually train my model on TPU?\n\nOnce your training is XLA-compatible and (if you\u2019re using TPU Node / Colab) your dataset has been prepared appropriately, running on TPU is surprisingly easy! All you really need to change in your code is to add a few lines to initialize your TPU, and to ensure that your model and dataset are created inside a `TPUStrategy` scope. Take a look at [our TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) to see this in action!\n\n### Summary\n\nThere was a lot in here, so let\u2019s summarize with a quick checklist you can follow when you want to get your model ready for TPU training:\n\n- Make sure your code follows the three rules of XLA\n- Compile your model with `jit_compile=True` on CPU/GPU and confirm that you can train it with XLA\n- Either load your dataset into memory or use a TPU-compatible dataset loading approach (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Migrate your code either to Colab (with accelerator set to \u201cTPU\u201d) or a TPU VM on Google Cloud\n- Add TPU initializer code (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Create your `TPUStrategy` and make sure dataset loading and model creation are inside the `strategy.scope()` (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Don\u2019t forget to take `jit_compile=True` out again when you move to TPU!\n- \ud83d\ude4f\ud83d\ude4f\ud83d\ude4f\ud83e\udd7a\ud83e\udd7a\ud83e\udd7a\n- Call model.fit()\n- You did it!"
            },
            {
                "score": 0.6223856210250989,
                "node_text": "Here are some facts extracted from the provided text:\n\nRule #2 -> Prohibits -> Data-dependent shapes\n\nWe\u2019ve distilled them into three core rules below:\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** We\u2019ve put a lot of effort into rewriting our TensorFlow models and loss functions to be XLA-compatible. Our models and loss functions generally obey rule #1 and #2 by default, so you can skip over them if you\u2019re using `transformers` models. Don\u2019t forget about these rules when writing your own models and loss functions, though!\n\n</Tip>\n\n#### XLA Rule #1: Your code cannot have \u201cdata-dependent conditionals\u201d\n\nWhat that means is that any `if` statement cannot depend on values inside a `tf.Tensor`. For example, this code block cannot be compiled with XLA!\n\n```python\nif tf.reduce_sum(tensor) > 10:\n    tensor = tensor / 2.0\n```\n\nThis might seem very restrictive at first, but most neural net code doesn\u2019t need to do this. You can often get around this restriction by using `tf.cond` (see the documentation [here](https://www.tensorflow.org/api_docs/python/tf/cond)) or by removing the conditional and finding a clever math trick with indicator variables instead, like so:\n\n```python\nsum_over_10 = tf.cast(tf.reduce_sum(tensor) > 10, tf.float32)\ntensor = tensor / (1.0 + sum_over_10)\n```\n\nThis code has exactly the same effect as the code above, but by avoiding a conditional, we ensure it will compile with XLA without problems!\n\n#### XLA Rule #2: Your code cannot have \u201cdata-dependent shapes\u201d\n\nWhat this means is that the shape of all of the `tf.Tensor` objects in your code cannot depend on their values. For example, the function `tf.unique` cannot be compiled with XLA, because it returns a `tensor` containing one instance of each unique value in the input. The shape of this output will obviously be different depending on how repetitive the input `Tensor` was, and so XLA refuses to handle it!\n\nIn general, most neural network code obeys rule #2 by default. However, there are a few common cases where it becomes a problem. One very common one is when you use **label masking**, setting your labels to a negative value to indicate that those positions should be ignored when computing the loss. If you look at NumPy or PyTorch loss functions that support label masking, you will often see code like this that uses [boolean indexing](https://numpy.org/doc/stable/user/basics.indexing.html#boolean-array-indexing):\n\n```python\nlabel_mask = labels >= 0\nmasked_outputs = outputs[label_mask]\nmasked_labels = labels[label_mask]\nloss = compute_loss(masked_outputs, masked_labels)\nmean_loss = torch.mean(loss)\n```\n\nThis code is totally fine in NumPy or PyTorch, but it breaks in XLA! Why? Because the shape of `masked_outputs` and `masked_labels` depends on how many positions are masked - that makes it a **data-dependent shape.** However, just like for rule #1, we can often rewrite this code to yield exactly the same output without any data-dependent shapes.\n\n```python\nlabel_mask = tf.cast(labels >= 0, tf.float32)\nloss = compute_loss(outputs, labels)\nloss = loss * label_mask  # Set negative label positions to 0\nmean_loss = tf.reduce_sum(loss) / tf.reduce_sum(label_mask)\n```\n\nHere, we avoid data-dependent shapes by computing the loss for every position, but zeroing out the masked positions in both the numerator and denominator when we calculate the mean, which yields exactly the same result as the first block while maintaining XLA compatibility. Note that we use the same trick as in rule #1 - converting a `tf.bool` to `tf.float32` and using it as an indicator variable. This is a really useful trick, so remember it if you need to convert your own code to XLA!\n\n#### XLA Rule #3: XLA will need to recompile your model for every different input shape it sees\n\nThis is the big one. What this means is that if your input shapes are very variable, XLA will have to recompile your model over and over, which will create huge performance problems. This commonly arises in NLP models, where input texts have variable lengths after tokenization. In other modalities, static shapes are more common and this rule is much less of a problem.\n\nHow can you get around rule #3? The key is **padding** - if you pad all your inputs to the same length, and then use an `attention_mask`, you can get the same results as you\u2019d get from variable shapes, but without any XLA issues."
            }
        ]
    },
    {
        "sample_idx": 71,
        "question": "What kind of models are commonly affected by XLA Rule #3?",
        "answer": "NLP models, where input texts have variable lengths after tokenization.",
        "rag_answer": "NLP models are commonly affected by XLA Rule #3, particularly those where input texts have variable lengths after tokenization.",
        "rag_score": 5,
        "rag_feedback": "The system's response is completely correct, accurate, and factual. It provides a clear and concise answer to the question, stating that NLP models are commonly affected by XLA Rule #3, particularly those where input texts have variable lengths after tokenization. The response is well-supported by the provided context, which explains XLA Rule #3 and its implications on NLP models.",
        "rag_context": [
            {
                "score": 0.6904257334734036,
                "node_text": "Here are some facts extracted from the provided text:\n\nPadding -> Helps -> Avoid xla issues\nPadding -> Helps -> Xla issues\nXla -> Is -> Optimizing compiler\nXla -> Is used by -> Tensorflow and jax\nXla -> Is mandatory on -> Tpu\nXla -> Recompile -> Model\nXla -> Has -> Rule #1\nXla -> Has -> Rule #2\nXla -> Needs -> Recompile\nXla -> Has -> Rule #3\n\nThis is a really useful trick, so remember it if you need to convert your own code to XLA!\n\n#### XLA Rule #3: XLA will need to recompile your model for every different input shape it sees\n\nThis is the big one. What this means is that if your input shapes are very variable, XLA will have to recompile your model over and over, which will create huge performance problems. This commonly arises in NLP models, where input texts have variable lengths after tokenization. In other modalities, static shapes are more common and this rule is much less of a problem.\n\nHow can you get around rule #3? The key is **padding** - if you pad all your inputs to the same length, and then use an `attention_mask`, you can get the same results as you\u2019d get from variable shapes, but without any XLA issues. However, excessive padding can cause severe slowdown too - if you pad all your samples to the maximum length in the whole dataset, you might end up with batches consisting endless padding tokens, which will waste a lot of compute and memory!\n\nThere isn\u2019t a perfect solution to this problem. However, you can try some tricks. One very useful trick is to **pad batches of samples up to a multiple of a number like 32 or 64 tokens.** This often only increases the number of tokens by a small amount, but it hugely reduces the number of unique input shapes, because every input shape now has to be a multiple of 32 or 64. Fewer unique input shapes means fewer XLA compilations!\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** Our tokenizers and data collators have methods that can help you here. You can use `padding=\"max_length\"` or `padding=\"longest\"` when calling tokenizers to get them to output padded data. Our tokenizers and data collators also have a `pad_to_multiple_of` argument that you can use to reduce the number of unique input shapes you see!\n\n</Tip>\n\n### How do I actually train my model on TPU?\n\nOnce your training is XLA-compatible and (if you\u2019re using TPU Node / Colab) your dataset has been prepared appropriately, running on TPU is surprisingly easy! All you really need to change in your code is to add a few lines to initialize your TPU, and to ensure that your model and dataset are created inside a `TPUStrategy` scope. Take a look at [our TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) to see this in action!\n\n### Summary\n\nThere was a lot in here, so let\u2019s summarize with a quick checklist you can follow when you want to get your model ready for TPU training:\n\n- Make sure your code follows the three rules of XLA\n- Compile your model with `jit_compile=True` on CPU/GPU and confirm that you can train it with XLA\n- Either load your dataset into memory or use a TPU-compatible dataset loading approach (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Migrate your code either to Colab (with accelerator set to \u201cTPU\u201d) or a TPU VM on Google Cloud\n- Add TPU initializer code (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Create your `TPUStrategy` and make sure dataset loading and model creation are inside the `strategy.scope()` (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Don\u2019t forget to take `jit_compile=True` out again when you move to TPU!\n- \ud83d\ude4f\ud83d\ude4f\ud83d\ude4f\ud83e\udd7a\ud83e\udd7a\ud83e\udd7a\n- Call model.fit()\n- You did it!"
            },
            {
                "score": 0.6082156182164613,
                "node_text": "Here are some facts extracted from the provided text:\n\nRule #3 -> Requires -> Recompilation for different input shapes\n\nWe\u2019ve distilled them into three core rules below:\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** We\u2019ve put a lot of effort into rewriting our TensorFlow models and loss functions to be XLA-compatible. Our models and loss functions generally obey rule #1 and #2 by default, so you can skip over them if you\u2019re using `transformers` models. Don\u2019t forget about these rules when writing your own models and loss functions, though!\n\n</Tip>\n\n#### XLA Rule #1: Your code cannot have \u201cdata-dependent conditionals\u201d\n\nWhat that means is that any `if` statement cannot depend on values inside a `tf.Tensor`. For example, this code block cannot be compiled with XLA!\n\n```python\nif tf.reduce_sum(tensor) > 10:\n    tensor = tensor / 2.0\n```\n\nThis might seem very restrictive at first, but most neural net code doesn\u2019t need to do this. You can often get around this restriction by using `tf.cond` (see the documentation [here](https://www.tensorflow.org/api_docs/python/tf/cond)) or by removing the conditional and finding a clever math trick with indicator variables instead, like so:\n\n```python\nsum_over_10 = tf.cast(tf.reduce_sum(tensor) > 10, tf.float32)\ntensor = tensor / (1.0 + sum_over_10)\n```\n\nThis code has exactly the same effect as the code above, but by avoiding a conditional, we ensure it will compile with XLA without problems!\n\n#### XLA Rule #2: Your code cannot have \u201cdata-dependent shapes\u201d\n\nWhat this means is that the shape of all of the `tf.Tensor` objects in your code cannot depend on their values. For example, the function `tf.unique` cannot be compiled with XLA, because it returns a `tensor` containing one instance of each unique value in the input. The shape of this output will obviously be different depending on how repetitive the input `Tensor` was, and so XLA refuses to handle it!\n\nIn general, most neural network code obeys rule #2 by default. However, there are a few common cases where it becomes a problem. One very common one is when you use **label masking**, setting your labels to a negative value to indicate that those positions should be ignored when computing the loss. If you look at NumPy or PyTorch loss functions that support label masking, you will often see code like this that uses [boolean indexing](https://numpy.org/doc/stable/user/basics.indexing.html#boolean-array-indexing):\n\n```python\nlabel_mask = labels >= 0\nmasked_outputs = outputs[label_mask]\nmasked_labels = labels[label_mask]\nloss = compute_loss(masked_outputs, masked_labels)\nmean_loss = torch.mean(loss)\n```\n\nThis code is totally fine in NumPy or PyTorch, but it breaks in XLA! Why? Because the shape of `masked_outputs` and `masked_labels` depends on how many positions are masked - that makes it a **data-dependent shape.** However, just like for rule #1, we can often rewrite this code to yield exactly the same output without any data-dependent shapes.\n\n```python\nlabel_mask = tf.cast(labels >= 0, tf.float32)\nloss = compute_loss(outputs, labels)\nloss = loss * label_mask  # Set negative label positions to 0\nmean_loss = tf.reduce_sum(loss) / tf.reduce_sum(label_mask)\n```\n\nHere, we avoid data-dependent shapes by computing the loss for every position, but zeroing out the masked positions in both the numerator and denominator when we calculate the mean, which yields exactly the same result as the first block while maintaining XLA compatibility. Note that we use the same trick as in rule #1 - converting a `tf.bool` to `tf.float32` and using it as an indicator variable. This is a really useful trick, so remember it if you need to convert your own code to XLA!\n\n#### XLA Rule #3: XLA will need to recompile your model for every different input shape it sees\n\nThis is the big one. What this means is that if your input shapes are very variable, XLA will have to recompile your model over and over, which will create huge performance problems. This commonly arises in NLP models, where input texts have variable lengths after tokenization. In other modalities, static shapes are more common and this rule is much less of a problem.\n\nHow can you get around rule #3? The key is **padding** - if you pad all your inputs to the same length, and then use an `attention_mask`, you can get the same results as you\u2019d get from variable shapes, but without any XLA issues."
            }
        ]
    },
    {
        "sample_idx": 72,
        "question": "What is the key to getting around rule #3?",
        "answer": "The key is padding.",
        "rag_answer": "The key to getting around rule #3 is **padding** - if you pad all your inputs to the same length, and then use an `attention_mask`, you can get the same results as you\u2019d get from variable shapes, but without any XLA issues.",
        "rag_score": 5,
        "rag_feedback": "The system's response is completely correct, accurate, and factual. It provides a clear and concise answer to the question, stating that the key to getting around rule #3 is padding, and also provides additional context and explanation from the reference text.",
        "rag_context": [
            {
                "score": 0.688445194207505,
                "node_text": "Here are some facts extracted from the provided text:\n\nXla -> Has -> Rule #3\nXla -> Has -> Rule #2\nXla -> Has -> Rule #1\n\nThis is a really useful trick, so remember it if you need to convert your own code to XLA!\n\n#### XLA Rule #3: XLA will need to recompile your model for every different input shape it sees\n\nThis is the big one. What this means is that if your input shapes are very variable, XLA will have to recompile your model over and over, which will create huge performance problems. This commonly arises in NLP models, where input texts have variable lengths after tokenization. In other modalities, static shapes are more common and this rule is much less of a problem.\n\nHow can you get around rule #3? The key is **padding** - if you pad all your inputs to the same length, and then use an `attention_mask`, you can get the same results as you\u2019d get from variable shapes, but without any XLA issues. However, excessive padding can cause severe slowdown too - if you pad all your samples to the maximum length in the whole dataset, you might end up with batches consisting endless padding tokens, which will waste a lot of compute and memory!\n\nThere isn\u2019t a perfect solution to this problem. However, you can try some tricks. One very useful trick is to **pad batches of samples up to a multiple of a number like 32 or 64 tokens.** This often only increases the number of tokens by a small amount, but it hugely reduces the number of unique input shapes, because every input shape now has to be a multiple of 32 or 64. Fewer unique input shapes means fewer XLA compilations!\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** Our tokenizers and data collators have methods that can help you here. You can use `padding=\"max_length\"` or `padding=\"longest\"` when calling tokenizers to get them to output padded data. Our tokenizers and data collators also have a `pad_to_multiple_of` argument that you can use to reduce the number of unique input shapes you see!\n\n</Tip>\n\n### How do I actually train my model on TPU?\n\nOnce your training is XLA-compatible and (if you\u2019re using TPU Node / Colab) your dataset has been prepared appropriately, running on TPU is surprisingly easy! All you really need to change in your code is to add a few lines to initialize your TPU, and to ensure that your model and dataset are created inside a `TPUStrategy` scope. Take a look at [our TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) to see this in action!\n\n### Summary\n\nThere was a lot in here, so let\u2019s summarize with a quick checklist you can follow when you want to get your model ready for TPU training:\n\n- Make sure your code follows the three rules of XLA\n- Compile your model with `jit_compile=True` on CPU/GPU and confirm that you can train it with XLA\n- Either load your dataset into memory or use a TPU-compatible dataset loading approach (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Migrate your code either to Colab (with accelerator set to \u201cTPU\u201d) or a TPU VM on Google Cloud\n- Add TPU initializer code (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Create your `TPUStrategy` and make sure dataset loading and model creation are inside the `strategy.scope()` (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Don\u2019t forget to take `jit_compile=True` out again when you move to TPU!\n- \ud83d\ude4f\ud83d\ude4f\ud83d\ude4f\ud83e\udd7a\ud83e\udd7a\ud83e\udd7a\n- Call model.fit()\n- You did it!"
            },
            {
                "score": 0.688445194207505,
                "node_text": "Here are some facts extracted from the provided text:\n\nRule #3 -> Requires -> Recompilation for different input shapes\nRule #2 -> Prohibits -> Data-dependent shapes\nRule #1 -> Prohibits -> Data-dependent conditionals\n\nWe\u2019ve distilled them into three core rules below:\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** We\u2019ve put a lot of effort into rewriting our TensorFlow models and loss functions to be XLA-compatible. Our models and loss functions generally obey rule #1 and #2 by default, so you can skip over them if you\u2019re using `transformers` models. Don\u2019t forget about these rules when writing your own models and loss functions, though!\n\n</Tip>\n\n#### XLA Rule #1: Your code cannot have \u201cdata-dependent conditionals\u201d\n\nWhat that means is that any `if` statement cannot depend on values inside a `tf.Tensor`. For example, this code block cannot be compiled with XLA!\n\n```python\nif tf.reduce_sum(tensor) > 10:\n    tensor = tensor / 2.0\n```\n\nThis might seem very restrictive at first, but most neural net code doesn\u2019t need to do this. You can often get around this restriction by using `tf.cond` (see the documentation [here](https://www.tensorflow.org/api_docs/python/tf/cond)) or by removing the conditional and finding a clever math trick with indicator variables instead, like so:\n\n```python\nsum_over_10 = tf.cast(tf.reduce_sum(tensor) > 10, tf.float32)\ntensor = tensor / (1.0 + sum_over_10)\n```\n\nThis code has exactly the same effect as the code above, but by avoiding a conditional, we ensure it will compile with XLA without problems!\n\n#### XLA Rule #2: Your code cannot have \u201cdata-dependent shapes\u201d\n\nWhat this means is that the shape of all of the `tf.Tensor` objects in your code cannot depend on their values. For example, the function `tf.unique` cannot be compiled with XLA, because it returns a `tensor` containing one instance of each unique value in the input. The shape of this output will obviously be different depending on how repetitive the input `Tensor` was, and so XLA refuses to handle it!\n\nIn general, most neural network code obeys rule #2 by default. However, there are a few common cases where it becomes a problem. One very common one is when you use **label masking**, setting your labels to a negative value to indicate that those positions should be ignored when computing the loss. If you look at NumPy or PyTorch loss functions that support label masking, you will often see code like this that uses [boolean indexing](https://numpy.org/doc/stable/user/basics.indexing.html#boolean-array-indexing):\n\n```python\nlabel_mask = labels >= 0\nmasked_outputs = outputs[label_mask]\nmasked_labels = labels[label_mask]\nloss = compute_loss(masked_outputs, masked_labels)\nmean_loss = torch.mean(loss)\n```\n\nThis code is totally fine in NumPy or PyTorch, but it breaks in XLA! Why? Because the shape of `masked_outputs` and `masked_labels` depends on how many positions are masked - that makes it a **data-dependent shape.** However, just like for rule #1, we can often rewrite this code to yield exactly the same output without any data-dependent shapes.\n\n```python\nlabel_mask = tf.cast(labels >= 0, tf.float32)\nloss = compute_loss(outputs, labels)\nloss = loss * label_mask  # Set negative label positions to 0\nmean_loss = tf.reduce_sum(loss) / tf.reduce_sum(label_mask)\n```\n\nHere, we avoid data-dependent shapes by computing the loss for every position, but zeroing out the masked positions in both the numerator and denominator when we calculate the mean, which yields exactly the same result as the first block while maintaining XLA compatibility. Note that we use the same trick as in rule #1 - converting a `tf.bool` to `tf.float32` and using it as an indicator variable. This is a really useful trick, so remember it if you need to convert your own code to XLA!\n\n#### XLA Rule #3: XLA will need to recompile your model for every different input shape it sees\n\nThis is the big one. What this means is that if your input shapes are very variable, XLA will have to recompile your model over and over, which will create huge performance problems. This commonly arises in NLP models, where input texts have variable lengths after tokenization. In other modalities, static shapes are more common and this rule is much less of a problem.\n\nHow can you get around rule #3? The key is **padding** - if you pad all your inputs to the same length, and then use an `attention_mask`, you can get the same results as you\u2019d get from variable shapes, but without any XLA issues."
            },
            {
                "score": 0.59135522859783,
                "node_text": "Here are some facts extracted from the provided text:\n\nModel -> Needs -> Question\n\n!---\nCopyright 2022 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n-->\n\n# Token classification with LayoutLMv3 (PyTorch version)\n\nThis directory contains a script, `run_funsd_cord.py`, that can be used to fine-tune (or evaluate) LayoutLMv3 on form understanding datasets, such as [FUNSD](https://guillaumejaume.github.io/FUNSD/) and [CORD](https://github.com/clovaai/cord).\n\nThe script `run_funsd_cord.py` leverages the \ud83e\udd17 Datasets library and the Trainer API. You can easily customize it to your needs.\n\n## Fine-tuning on FUNSD\n\nFine-tuning LayoutLMv3 for token classification on [FUNSD](https://guillaumejaume.github.io/FUNSD/) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name funsd \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 1e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-funsd\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd. By specifying the `push_to_hub` flag, the model gets uploaded automatically to the hub (regularly), together with a model card, which includes metrics such as precision, recall and F1. Note that you can easily update the model card, as it's just a README file of the respective repo on the hub.\n\nThere's also the \"Training metrics\" [tab](https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd/tensorboard), which shows Tensorboard logs over the course of training. Pretty neat, huh?\n\n## Fine-tuning on CORD\n\nFine-tuning LayoutLMv3 for token classification on [CORD](https://github.com/clovaai/cord) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name cord \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 5e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-cord\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-cord. Note that a model card gets generated automatically in case you specify the `push_to_hub` flag."
            }
        ]
    },
    {
        "sample_idx": 73,
        "question": "What can excessive padding cause?",
        "answer": "Excessive padding can cause severe slowdown.",
        "rag_answer": "Excessive padding can cause severe slowdown.",
        "rag_score": 5,
        "rag_feedback": "The system's response is completely correct, accurate, and factual. It matches the expected answer exactly, stating that excessive padding can cause severe slowdown.",
        "rag_context": [
            {
                "score": 0.5688237528082103,
                "node_text": "Here are some facts extracted from the provided text:\n\nPadding -> Helps -> Avoid xla issues\nPadding -> Helps -> Xla issues\nTokenizers -> Have -> Padding methods\nAttention_mask -> Is used -> With padding\n\nThis is a really useful trick, so remember it if you need to convert your own code to XLA!\n\n#### XLA Rule #3: XLA will need to recompile your model for every different input shape it sees\n\nThis is the big one. What this means is that if your input shapes are very variable, XLA will have to recompile your model over and over, which will create huge performance problems. This commonly arises in NLP models, where input texts have variable lengths after tokenization. In other modalities, static shapes are more common and this rule is much less of a problem.\n\nHow can you get around rule #3? The key is **padding** - if you pad all your inputs to the same length, and then use an `attention_mask`, you can get the same results as you\u2019d get from variable shapes, but without any XLA issues. However, excessive padding can cause severe slowdown too - if you pad all your samples to the maximum length in the whole dataset, you might end up with batches consisting endless padding tokens, which will waste a lot of compute and memory!\n\nThere isn\u2019t a perfect solution to this problem. However, you can try some tricks. One very useful trick is to **pad batches of samples up to a multiple of a number like 32 or 64 tokens.** This often only increases the number of tokens by a small amount, but it hugely reduces the number of unique input shapes, because every input shape now has to be a multiple of 32 or 64. Fewer unique input shapes means fewer XLA compilations!\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** Our tokenizers and data collators have methods that can help you here. You can use `padding=\"max_length\"` or `padding=\"longest\"` when calling tokenizers to get them to output padded data. Our tokenizers and data collators also have a `pad_to_multiple_of` argument that you can use to reduce the number of unique input shapes you see!\n\n</Tip>\n\n### How do I actually train my model on TPU?\n\nOnce your training is XLA-compatible and (if you\u2019re using TPU Node / Colab) your dataset has been prepared appropriately, running on TPU is surprisingly easy! All you really need to change in your code is to add a few lines to initialize your TPU, and to ensure that your model and dataset are created inside a `TPUStrategy` scope. Take a look at [our TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) to see this in action!\n\n### Summary\n\nThere was a lot in here, so let\u2019s summarize with a quick checklist you can follow when you want to get your model ready for TPU training:\n\n- Make sure your code follows the three rules of XLA\n- Compile your model with `jit_compile=True` on CPU/GPU and confirm that you can train it with XLA\n- Either load your dataset into memory or use a TPU-compatible dataset loading approach (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Migrate your code either to Colab (with accelerator set to \u201cTPU\u201d) or a TPU VM on Google Cloud\n- Add TPU initializer code (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Create your `TPUStrategy` and make sure dataset loading and model creation are inside the `strategy.scope()` (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Don\u2019t forget to take `jit_compile=True` out again when you move to TPU!\n- \ud83d\ude4f\ud83d\ude4f\ud83d\ude4f\ud83e\udd7a\ud83e\udd7a\ud83e\udd7a\n- Call model.fit()\n- You did it!"
            },
            {
                "score": 0.4651570910737692,
                "node_text": "Here are some facts extracted from the provided text:\n\nFunc -> Takes -> Slider_1\n\nGradio Demo: blocks_random_slider\n\n\n```\n!pip install -q gradio \n```\n\n\n```\n\nimport gradio as gr\n\n\ndef func(slider_1, slider_2):\n    return slider_1 * 5 + slider_2\n\n\nwith gr.Blocks() as demo:\n    slider = gr.Slider(minimum=-10.2, maximum=15, label=\"Random Slider (Static)\", randomize=True)\n    slider_1 = gr.Slider(minimum=100, maximum=200, label=\"Random Slider (Input 1)\", randomize=True)\n    slider_2 = gr.Slider(minimum=10, maximum=23.2, label=\"Random Slider (Input 2)\", randomize=True)\n    slider_3 = gr.Slider(value=3, label=\"Non random slider\")\n    btn = gr.Button(\"Run\")\n    btn.click(func, inputs=[slider_1, slider_2], outputs=gr.Number())\n\nif __name__ == \"__main__\":\n    demo.launch()\n\n```"
            }
        ]
    },
    {
        "sample_idx": 74,
        "question": "What is a useful trick to reduce the number of unique input shapes?",
        "answer": "Pad batches of samples up to a multiple of a number like 32 or 64 tokens.",
        "rag_answer": "A useful trick to reduce the number of unique input shapes is to pad batches of samples up to a multiple of a number like 32 or 64 tokens.",
        "rag_score": 5,
        "rag_feedback": "The system's response is completely correct, accurate, and factual. It directly answers the question by stating that a useful trick to reduce the number of unique input shapes is to pad batches of samples up to a multiple of a number like 32 or 64 tokens.",
        "rag_context": [
            {
                "score": 0.6894417001430532,
                "node_text": "Here are some facts extracted from the provided text:\n\nRule #2 -> Prohibits -> Data-dependent shapes\nRule #3 -> Requires -> Recompilation for different input shapes\n\nWe\u2019ve distilled them into three core rules below:\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** We\u2019ve put a lot of effort into rewriting our TensorFlow models and loss functions to be XLA-compatible. Our models and loss functions generally obey rule #1 and #2 by default, so you can skip over them if you\u2019re using `transformers` models. Don\u2019t forget about these rules when writing your own models and loss functions, though!\n\n</Tip>\n\n#### XLA Rule #1: Your code cannot have \u201cdata-dependent conditionals\u201d\n\nWhat that means is that any `if` statement cannot depend on values inside a `tf.Tensor`. For example, this code block cannot be compiled with XLA!\n\n```python\nif tf.reduce_sum(tensor) > 10:\n    tensor = tensor / 2.0\n```\n\nThis might seem very restrictive at first, but most neural net code doesn\u2019t need to do this. You can often get around this restriction by using `tf.cond` (see the documentation [here](https://www.tensorflow.org/api_docs/python/tf/cond)) or by removing the conditional and finding a clever math trick with indicator variables instead, like so:\n\n```python\nsum_over_10 = tf.cast(tf.reduce_sum(tensor) > 10, tf.float32)\ntensor = tensor / (1.0 + sum_over_10)\n```\n\nThis code has exactly the same effect as the code above, but by avoiding a conditional, we ensure it will compile with XLA without problems!\n\n#### XLA Rule #2: Your code cannot have \u201cdata-dependent shapes\u201d\n\nWhat this means is that the shape of all of the `tf.Tensor` objects in your code cannot depend on their values. For example, the function `tf.unique` cannot be compiled with XLA, because it returns a `tensor` containing one instance of each unique value in the input. The shape of this output will obviously be different depending on how repetitive the input `Tensor` was, and so XLA refuses to handle it!\n\nIn general, most neural network code obeys rule #2 by default. However, there are a few common cases where it becomes a problem. One very common one is when you use **label masking**, setting your labels to a negative value to indicate that those positions should be ignored when computing the loss. If you look at NumPy or PyTorch loss functions that support label masking, you will often see code like this that uses [boolean indexing](https://numpy.org/doc/stable/user/basics.indexing.html#boolean-array-indexing):\n\n```python\nlabel_mask = labels >= 0\nmasked_outputs = outputs[label_mask]\nmasked_labels = labels[label_mask]\nloss = compute_loss(masked_outputs, masked_labels)\nmean_loss = torch.mean(loss)\n```\n\nThis code is totally fine in NumPy or PyTorch, but it breaks in XLA! Why? Because the shape of `masked_outputs` and `masked_labels` depends on how many positions are masked - that makes it a **data-dependent shape.** However, just like for rule #1, we can often rewrite this code to yield exactly the same output without any data-dependent shapes.\n\n```python\nlabel_mask = tf.cast(labels >= 0, tf.float32)\nloss = compute_loss(outputs, labels)\nloss = loss * label_mask  # Set negative label positions to 0\nmean_loss = tf.reduce_sum(loss) / tf.reduce_sum(label_mask)\n```\n\nHere, we avoid data-dependent shapes by computing the loss for every position, but zeroing out the masked positions in both the numerator and denominator when we calculate the mean, which yields exactly the same result as the first block while maintaining XLA compatibility. Note that we use the same trick as in rule #1 - converting a `tf.bool` to `tf.float32` and using it as an indicator variable. This is a really useful trick, so remember it if you need to convert your own code to XLA!\n\n#### XLA Rule #3: XLA will need to recompile your model for every different input shape it sees\n\nThis is the big one. What this means is that if your input shapes are very variable, XLA will have to recompile your model over and over, which will create huge performance problems. This commonly arises in NLP models, where input texts have variable lengths after tokenization. In other modalities, static shapes are more common and this rule is much less of a problem.\n\nHow can you get around rule #3? The key is **padding** - if you pad all your inputs to the same length, and then use an `attention_mask`, you can get the same results as you\u2019d get from variable shapes, but without any XLA issues."
            },
            {
                "score": 0.543354652962623,
                "node_text": "Here are some facts extracted from the provided text:\n\nGradio -> Supports -> Hugging face models\n\nGradio Demo: blocks_random_slider\n\n\n```\n!pip install -q gradio \n```\n\n\n```\n\nimport gradio as gr\n\n\ndef func(slider_1, slider_2):\n    return slider_1 * 5 + slider_2\n\n\nwith gr.Blocks() as demo:\n    slider = gr.Slider(minimum=-10.2, maximum=15, label=\"Random Slider (Static)\", randomize=True)\n    slider_1 = gr.Slider(minimum=100, maximum=200, label=\"Random Slider (Input 1)\", randomize=True)\n    slider_2 = gr.Slider(minimum=10, maximum=23.2, label=\"Random Slider (Input 2)\", randomize=True)\n    slider_3 = gr.Slider(value=3, label=\"Non random slider\")\n    btn = gr.Button(\"Run\")\n    btn.click(func, inputs=[slider_1, slider_2], outputs=gr.Number())\n\nif __name__ == \"__main__\":\n    demo.launch()\n\n```"
            },
            {
                "score": 0.537504862189674,
                "node_text": "Here are some facts extracted from the provided text:\n\nInput shape -> Is -> Variable\n\nThis is a really useful trick, so remember it if you need to convert your own code to XLA!\n\n#### XLA Rule #3: XLA will need to recompile your model for every different input shape it sees\n\nThis is the big one. What this means is that if your input shapes are very variable, XLA will have to recompile your model over and over, which will create huge performance problems. This commonly arises in NLP models, where input texts have variable lengths after tokenization. In other modalities, static shapes are more common and this rule is much less of a problem.\n\nHow can you get around rule #3? The key is **padding** - if you pad all your inputs to the same length, and then use an `attention_mask`, you can get the same results as you\u2019d get from variable shapes, but without any XLA issues. However, excessive padding can cause severe slowdown too - if you pad all your samples to the maximum length in the whole dataset, you might end up with batches consisting endless padding tokens, which will waste a lot of compute and memory!\n\nThere isn\u2019t a perfect solution to this problem. However, you can try some tricks. One very useful trick is to **pad batches of samples up to a multiple of a number like 32 or 64 tokens.** This often only increases the number of tokens by a small amount, but it hugely reduces the number of unique input shapes, because every input shape now has to be a multiple of 32 or 64. Fewer unique input shapes means fewer XLA compilations!\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** Our tokenizers and data collators have methods that can help you here. You can use `padding=\"max_length\"` or `padding=\"longest\"` when calling tokenizers to get them to output padded data. Our tokenizers and data collators also have a `pad_to_multiple_of` argument that you can use to reduce the number of unique input shapes you see!\n\n</Tip>\n\n### How do I actually train my model on TPU?\n\nOnce your training is XLA-compatible and (if you\u2019re using TPU Node / Colab) your dataset has been prepared appropriately, running on TPU is surprisingly easy! All you really need to change in your code is to add a few lines to initialize your TPU, and to ensure that your model and dataset are created inside a `TPUStrategy` scope. Take a look at [our TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) to see this in action!\n\n### Summary\n\nThere was a lot in here, so let\u2019s summarize with a quick checklist you can follow when you want to get your model ready for TPU training:\n\n- Make sure your code follows the three rules of XLA\n- Compile your model with `jit_compile=True` on CPU/GPU and confirm that you can train it with XLA\n- Either load your dataset into memory or use a TPU-compatible dataset loading approach (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Migrate your code either to Colab (with accelerator set to \u201cTPU\u201d) or a TPU VM on Google Cloud\n- Add TPU initializer code (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Create your `TPUStrategy` and make sure dataset loading and model creation are inside the `strategy.scope()` (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Don\u2019t forget to take `jit_compile=True` out again when you move to TPU!\n- \ud83d\ude4f\ud83d\ude4f\ud83d\ude4f\ud83e\udd7a\ud83e\udd7a\ud83e\udd7a\n- Call model.fit()\n- You did it!"
            },
            {
                "score": 0.537504862189674,
                "node_text": "Here are some facts extracted from the provided text:\n\nModel -> Has -> Input shape\n\n!---\nCopyright 2022 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n-->\n\n# Token classification with LayoutLMv3 (PyTorch version)\n\nThis directory contains a script, `run_funsd_cord.py`, that can be used to fine-tune (or evaluate) LayoutLMv3 on form understanding datasets, such as [FUNSD](https://guillaumejaume.github.io/FUNSD/) and [CORD](https://github.com/clovaai/cord).\n\nThe script `run_funsd_cord.py` leverages the \ud83e\udd17 Datasets library and the Trainer API. You can easily customize it to your needs.\n\n## Fine-tuning on FUNSD\n\nFine-tuning LayoutLMv3 for token classification on [FUNSD](https://guillaumejaume.github.io/FUNSD/) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name funsd \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 1e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-funsd\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd. By specifying the `push_to_hub` flag, the model gets uploaded automatically to the hub (regularly), together with a model card, which includes metrics such as precision, recall and F1. Note that you can easily update the model card, as it's just a README file of the respective repo on the hub.\n\nThere's also the \"Training metrics\" [tab](https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd/tensorboard), which shows Tensorboard logs over the course of training. Pretty neat, huh?\n\n## Fine-tuning on CORD\n\nFine-tuning LayoutLMv3 for token classification on [CORD](https://github.com/clovaai/cord) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name cord \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 5e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-cord\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-cord. Note that a model card gets generated automatically in case you specify the `push_to_hub` flag."
            }
        ]
    },
    {
        "sample_idx": 75,
        "question": "What is the benefit of padding to a multiple of 32 or 64 tokens?",
        "answer": "It hugely reduces the number of unique input shapes.",
        "rag_answer": "The benefit of padding to a multiple of 32 or 64 tokens is that it reduces the number of unique input shapes, which in turn reduces the number of XLA compilations, thereby improving performance.",
        "rag_score": 5,
        "rag_feedback": "The system's response is completely correct, accurate, and factual. It not only provides the correct answer but also provides additional context and explanations that support the answer.",
        "rag_context": [
            {
                "score": 0.6396963015411662,
                "node_text": "Here are some facts extracted from the provided text:\n\nTokenizers -> Have -> Padding methods\nPadding -> Helps -> Avoid xla issues\nPadding -> Helps -> Xla issues\nAttention_mask -> Is used -> With padding\n\nThis is a really useful trick, so remember it if you need to convert your own code to XLA!\n\n#### XLA Rule #3: XLA will need to recompile your model for every different input shape it sees\n\nThis is the big one. What this means is that if your input shapes are very variable, XLA will have to recompile your model over and over, which will create huge performance problems. This commonly arises in NLP models, where input texts have variable lengths after tokenization. In other modalities, static shapes are more common and this rule is much less of a problem.\n\nHow can you get around rule #3? The key is **padding** - if you pad all your inputs to the same length, and then use an `attention_mask`, you can get the same results as you\u2019d get from variable shapes, but without any XLA issues. However, excessive padding can cause severe slowdown too - if you pad all your samples to the maximum length in the whole dataset, you might end up with batches consisting endless padding tokens, which will waste a lot of compute and memory!\n\nThere isn\u2019t a perfect solution to this problem. However, you can try some tricks. One very useful trick is to **pad batches of samples up to a multiple of a number like 32 or 64 tokens.** This often only increases the number of tokens by a small amount, but it hugely reduces the number of unique input shapes, because every input shape now has to be a multiple of 32 or 64. Fewer unique input shapes means fewer XLA compilations!\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** Our tokenizers and data collators have methods that can help you here. You can use `padding=\"max_length\"` or `padding=\"longest\"` when calling tokenizers to get them to output padded data. Our tokenizers and data collators also have a `pad_to_multiple_of` argument that you can use to reduce the number of unique input shapes you see!\n\n</Tip>\n\n### How do I actually train my model on TPU?\n\nOnce your training is XLA-compatible and (if you\u2019re using TPU Node / Colab) your dataset has been prepared appropriately, running on TPU is surprisingly easy! All you really need to change in your code is to add a few lines to initialize your TPU, and to ensure that your model and dataset are created inside a `TPUStrategy` scope. Take a look at [our TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) to see this in action!\n\n### Summary\n\nThere was a lot in here, so let\u2019s summarize with a quick checklist you can follow when you want to get your model ready for TPU training:\n\n- Make sure your code follows the three rules of XLA\n- Compile your model with `jit_compile=True` on CPU/GPU and confirm that you can train it with XLA\n- Either load your dataset into memory or use a TPU-compatible dataset loading approach (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Migrate your code either to Colab (with accelerator set to \u201cTPU\u201d) or a TPU VM on Google Cloud\n- Add TPU initializer code (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Create your `TPUStrategy` and make sure dataset loading and model creation are inside the `strategy.scope()` (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Don\u2019t forget to take `jit_compile=True` out again when you move to TPU!\n- \ud83d\ude4f\ud83d\ude4f\ud83d\ude4f\ud83e\udd7a\ud83e\udd7a\ud83e\udd7a\n- Call model.fit()\n- You did it!"
            }
        ]
    },
    {
        "sample_idx": 76,
        "question": "What can be used to get tokenizers to output padded data?",
        "answer": "You can use 'padding=max_length' or 'padding=longest' when calling tokenizers.",
        "rag_answer": "`padding=\"max_length\"` or `padding=\"longest\"` can be used when calling tokenizers to get them to output padded data.",
        "rag_score": 5,
        "rag_feedback": "The system's response is completely correct, accurate, and factual. It directly answers the question by stating that 'padding=\"max_length\"' or 'padding=\"longest\"' can be used when calling tokenizers to get them to output padded data, which matches the expected answer.",
        "rag_context": [
            {
                "score": 0.6794082998693539,
                "node_text": "Here are some facts extracted from the provided text:\n\nTokenizers -> Have -> Padding methods\nHuggingface -> Provides -> Tokenizers\nPadding -> Helps -> Avoid xla issues\nPadding -> Helps -> Xla issues\n\nThis is a really useful trick, so remember it if you need to convert your own code to XLA!\n\n#### XLA Rule #3: XLA will need to recompile your model for every different input shape it sees\n\nThis is the big one. What this means is that if your input shapes are very variable, XLA will have to recompile your model over and over, which will create huge performance problems. This commonly arises in NLP models, where input texts have variable lengths after tokenization. In other modalities, static shapes are more common and this rule is much less of a problem.\n\nHow can you get around rule #3? The key is **padding** - if you pad all your inputs to the same length, and then use an `attention_mask`, you can get the same results as you\u2019d get from variable shapes, but without any XLA issues. However, excessive padding can cause severe slowdown too - if you pad all your samples to the maximum length in the whole dataset, you might end up with batches consisting endless padding tokens, which will waste a lot of compute and memory!\n\nThere isn\u2019t a perfect solution to this problem. However, you can try some tricks. One very useful trick is to **pad batches of samples up to a multiple of a number like 32 or 64 tokens.** This often only increases the number of tokens by a small amount, but it hugely reduces the number of unique input shapes, because every input shape now has to be a multiple of 32 or 64. Fewer unique input shapes means fewer XLA compilations!\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** Our tokenizers and data collators have methods that can help you here. You can use `padding=\"max_length\"` or `padding=\"longest\"` when calling tokenizers to get them to output padded data. Our tokenizers and data collators also have a `pad_to_multiple_of` argument that you can use to reduce the number of unique input shapes you see!\n\n</Tip>\n\n### How do I actually train my model on TPU?\n\nOnce your training is XLA-compatible and (if you\u2019re using TPU Node / Colab) your dataset has been prepared appropriately, running on TPU is surprisingly easy! All you really need to change in your code is to add a few lines to initialize your TPU, and to ensure that your model and dataset are created inside a `TPUStrategy` scope. Take a look at [our TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) to see this in action!\n\n### Summary\n\nThere was a lot in here, so let\u2019s summarize with a quick checklist you can follow when you want to get your model ready for TPU training:\n\n- Make sure your code follows the three rules of XLA\n- Compile your model with `jit_compile=True` on CPU/GPU and confirm that you can train it with XLA\n- Either load your dataset into memory or use a TPU-compatible dataset loading approach (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Migrate your code either to Colab (with accelerator set to \u201cTPU\u201d) or a TPU VM on Google Cloud\n- Add TPU initializer code (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Create your `TPUStrategy` and make sure dataset loading and model creation are inside the `strategy.scope()` (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Don\u2019t forget to take `jit_compile=True` out again when you move to TPU!\n- \ud83d\ude4f\ud83d\ude4f\ud83d\ude4f\ud83e\udd7a\ud83e\udd7a\ud83e\udd7a\n- Call model.fit()\n- You did it!"
            },
            {
                "score": 0.5914011566181435,
                "node_text": "Here are some facts extracted from the provided text:\n\nTrim_words -> Is -> Batch function\nTrim_words -> Accepts -> Two input lists\nTrim_words -> Returns -> Trimmed word list\n\ntqdm` \u81ea\u52a8\u62a5\u544a\u8fdb\u5ea6\u66f4\u65b0\uff0c\u8bf7\u5c06\u9ed8\u8ba4\u53c2\u6570\u8bbe\u7f6e\u4e3a `gr.Progress(track_tqdm=True)`\uff01\n\n## \u6279\u5904\u7406\u51fd\u6570 (Batch Functions)\n\nGradio \u652f\u6301\u4f20\u9012*\u6279\u5904\u7406*\u51fd\u6570\u3002\u6279\u5904\u7406\u51fd\u6570\u53ea\u662f\u63a5\u53d7\u8f93\u5165\u5217\u8868\u5e76\u8fd4\u56de\u9884\u6d4b\u5217\u8868\u7684\u51fd\u6570\u3002\n\n\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\u6279\u5904\u7406\u51fd\u6570\uff0c\u5b83\u63a5\u53d7\u4e24\u4e2a\u8f93\u5165\u5217\u8868\uff08\u4e00\u4e2a\u5355\u8bcd\u5217\u8868\u548c\u4e00\u4e2a\u6574\u6570\u5217\u8868\uff09\uff0c\u5e76\u8fd4\u56de\u4fee\u526a\u8fc7\u7684\u5355\u8bcd\u5217\u8868\u4f5c\u4e3a\u8f93\u51fa\uff1a\n\n```python\nimport time\n\ndef trim_words(words, lens):\n    trimmed_words = []\n    time.sleep(5)\n    for w, l in zip(words, lens):\n        trimmed_words.append(w[:int(l)])\n    return [trimmed_words]\n    for w, l in zip(words, lens):\n```\n\n\u4f7f\u7528\u6279\u5904\u7406\u51fd\u6570\u7684\u4f18\u70b9\u662f\uff0c\u5982\u679c\u542f\u7528\u4e86\u961f\u5217\uff0cGradio \u670d\u52a1\u5668\u53ef\u4ee5\u81ea\u52a8*\u6279\u5904\u7406*\u4f20\u5165\u7684\u8bf7\u6c42\u5e76\u5e76\u884c\u5904\u7406\u5b83\u4eec\uff0c\u4ece\u800c\u53ef\u80fd\u52a0\u5feb\u6f14\u793a\u901f\u5ea6\u3002\u4ee5\u4e0b\u662f Gradio \u4ee3\u7801\u7684\u793a\u4f8b\uff08\u8bf7\u6ce8\u610f `batch=True` \u548c `max_batch_size=16` - \u8fd9\u4e24\u4e2a\u53c2\u6570\u90fd\u53ef\u4ee5\u4f20\u9012\u7ed9\u4e8b\u4ef6\u89e6\u53d1\u5668\u6216 `Interface` \u7c7b\uff09\n\nwith `Interface`\uff1a\n\n```python\ndemo = gr.Interface(trim_words, [\"textbox\", \"number\"], [\"output\"],\n                    batch=True, max_batch_size=16)\ndemo.queue()\ndemo.launch()\n```\n\nwith `Blocks`\uff1a\n\n```python\nimport gradio as gr\n\nwith gr.Blocks() as demo:\n    with gr.Row():\n        word = gr.Textbox(label=\"word\")\n        leng = gr.Number(label=\"leng\")\n        output = gr.Textbox(label=\"Output\")\n    with gr.Row():\n        run = gr.Button()\n\n    event = run.click(trim_words, [word, leng], output, batch=True, max_batch_size=16)\n\ndemo.queue()\ndemo.launch()\n```\n\n\u5728\u4e0a\u9762\u7684\u793a\u4f8b\u4e2d\uff0c\u53ef\u4ee5\u5e76\u884c\u5904\u7406 16 \u4e2a\u8bf7\u6c42\uff08\u603b\u63a8\u7406\u65f6\u95f4\u4e3a 5 \u79d2\uff09\uff0c\u800c\u4e0d\u662f\u5206\u522b\u5904\u7406\u6bcf\u4e2a\u8bf7\u6c42\uff08\u603b\u63a8\u7406\u65f6\u95f4\u4e3a 80 \u79d2\uff09\u3002\u8bb8\u591a Hugging Face \u7684 `transformers` \u548c `diffusers` \u6a21\u578b\u5728 Gradio \u7684\u6279\u5904\u7406\u6a21\u5f0f\u4e0b\u81ea\u7136\u5de5\u4f5c\uff1a\u8fd9\u662f[\u4f7f\u7528\u6279\u5904\u7406\u751f\u6210\u56fe\u50cf\u7684\u793a\u4f8b\u6f14\u793a](https://github.com/gradio-app/gradio/blob/main/demo/diffusers_with_batching/run.py)\n\n\u6ce8\u610f\uff1a\u4f7f\u7528 Gradio \u7684\u6279\u5904\u7406\u51fd\u6570 **requires** \u5728\u5e95\u5c42 Interface \u6216 Blocks \u4e2d\u542f\u7528\u961f\u5217\uff08\u8bf7\u53c2\u9605\u4e0a\u9762\u7684\u961f\u5217\u90e8\u5206\uff09\u3002\n\n## Gradio \u7b14\u8bb0\u672c (Colab Notebooks)\n\nGradio \u53ef\u4ee5\u5728\u4efb\u4f55\u8fd0\u884c Python \u7684\u5730\u65b9\u8fd0\u884c\uff0c\u5305\u62ec\u672c\u5730 Jupyter \u7b14\u8bb0\u672c\u548c\u534f\u4f5c\u7b14\u8bb0\u672c\uff0c\u5982[Google Colab](https://colab.research.google.com/)\u3002\u5bf9\u4e8e\u672c\u5730 Jupyter \u7b14\u8bb0\u672c\u548c Google Colab \u7b14\u8bb0\u672c\uff0cGradio \u5728\u672c\u5730\u670d\u52a1\u5668\u4e0a\u8fd0\u884c\uff0c\u60a8\u53ef\u4ee5\u5728\u6d4f\u89c8\u5668\u4e2d\u4e0e\u4e4b\u4ea4\u4e92\u3002\uff08\u6ce8\u610f\uff1a\u5bf9\u4e8e Google Colab\uff0c\u8fd9\u662f\u901a\u8fc7[\u670d\u52a1\u5de5\u4f5c\u5668\u96a7\u9053](https://github.com/tensorflow/tensorboard/blob/master/docs/design/colab_integration.md)\u5b9e\u73b0\u7684\uff0c\u60a8\u7684\u6d4f\u89c8\u5668\u9700\u8981\u542f\u7528 cookies\u3002\uff09\u5bf9\u4e8e\u5176\u4ed6\u8fdc\u7a0b\u7b14\u8bb0\u672c\uff0cGradio \u4e5f\u5c06\u5728\u670d\u52a1\u5668\u4e0a\u8fd0\u884c\uff0c\u4f46\u60a8\u9700\u8981\u4f7f\u7528[SSH \u96a7\u9053](https://coderwall.com/p/ohk6cg/remote-access-to-ipython-notebooks-via-ssh)\u5728\u672c\u5730\u6d4f\u89c8\u5668\u4e2d\u67e5\u770b\u5e94\u7528\u7a0b\u5e8f\u3002\u901a\u5e38\uff0c\u66f4\u7b80\u5355\u7684\u9009\u62e9\u662f\u4f7f\u7528 Gradio \u5185\u7f6e\u7684\u516c\u5171\u94fe\u63a5\uff0c[\u5728\u4e0b\u4e00\u7bc7\u6307\u5357\u4e2d\u8ba8\u8bba](/sharing-your-app/#sharing-demos)\u3002"
            }
        ]
    },
    {
        "sample_idx": 77,
        "question": "What argument can be used to reduce the number of unique input shapes?",
        "answer": "The 'pad_to_multiple_of' argument can be used.",
        "rag_answer": "The argument that can be used to reduce the number of unique input shapes is `pad_to_multiple_of`.",
        "rag_score": 5,
        "rag_feedback": "The system's response is completely correct, accurate, and factual. It directly answers the question by stating that the 'pad_to_multiple_of' argument can be used to reduce the number of unique input shapes.",
        "rag_context": [
            {
                "score": 1.0,
                "node_text": "Here are some facts extracted from the provided text:\n\nInput shape -> Is -> Variable\n\nThis is a really useful trick, so remember it if you need to convert your own code to XLA!\n\n#### XLA Rule #3: XLA will need to recompile your model for every different input shape it sees\n\nThis is the big one. What this means is that if your input shapes are very variable, XLA will have to recompile your model over and over, which will create huge performance problems. This commonly arises in NLP models, where input texts have variable lengths after tokenization. In other modalities, static shapes are more common and this rule is much less of a problem.\n\nHow can you get around rule #3? The key is **padding** - if you pad all your inputs to the same length, and then use an `attention_mask`, you can get the same results as you\u2019d get from variable shapes, but without any XLA issues. However, excessive padding can cause severe slowdown too - if you pad all your samples to the maximum length in the whole dataset, you might end up with batches consisting endless padding tokens, which will waste a lot of compute and memory!\n\nThere isn\u2019t a perfect solution to this problem. However, you can try some tricks. One very useful trick is to **pad batches of samples up to a multiple of a number like 32 or 64 tokens.** This often only increases the number of tokens by a small amount, but it hugely reduces the number of unique input shapes, because every input shape now has to be a multiple of 32 or 64. Fewer unique input shapes means fewer XLA compilations!\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** Our tokenizers and data collators have methods that can help you here. You can use `padding=\"max_length\"` or `padding=\"longest\"` when calling tokenizers to get them to output padded data. Our tokenizers and data collators also have a `pad_to_multiple_of` argument that you can use to reduce the number of unique input shapes you see!\n\n</Tip>\n\n### How do I actually train my model on TPU?\n\nOnce your training is XLA-compatible and (if you\u2019re using TPU Node / Colab) your dataset has been prepared appropriately, running on TPU is surprisingly easy! All you really need to change in your code is to add a few lines to initialize your TPU, and to ensure that your model and dataset are created inside a `TPUStrategy` scope. Take a look at [our TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) to see this in action!\n\n### Summary\n\nThere was a lot in here, so let\u2019s summarize with a quick checklist you can follow when you want to get your model ready for TPU training:\n\n- Make sure your code follows the three rules of XLA\n- Compile your model with `jit_compile=True` on CPU/GPU and confirm that you can train it with XLA\n- Either load your dataset into memory or use a TPU-compatible dataset loading approach (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Migrate your code either to Colab (with accelerator set to \u201cTPU\u201d) or a TPU VM on Google Cloud\n- Add TPU initializer code (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Create your `TPUStrategy` and make sure dataset loading and model creation are inside the `strategy.scope()` (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Don\u2019t forget to take `jit_compile=True` out again when you move to TPU!\n- \ud83d\ude4f\ud83d\ude4f\ud83d\ude4f\ud83e\udd7a\ud83e\udd7a\ud83e\udd7a\n- Call model.fit()\n- You did it!"
            },
            {
                "score": 1.0,
                "node_text": "Here are some facts extracted from the provided text:\n\nModel -> Has -> Input shape\n\n!---\nCopyright 2022 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n-->\n\n# Token classification with LayoutLMv3 (PyTorch version)\n\nThis directory contains a script, `run_funsd_cord.py`, that can be used to fine-tune (or evaluate) LayoutLMv3 on form understanding datasets, such as [FUNSD](https://guillaumejaume.github.io/FUNSD/) and [CORD](https://github.com/clovaai/cord).\n\nThe script `run_funsd_cord.py` leverages the \ud83e\udd17 Datasets library and the Trainer API. You can easily customize it to your needs.\n\n## Fine-tuning on FUNSD\n\nFine-tuning LayoutLMv3 for token classification on [FUNSD](https://guillaumejaume.github.io/FUNSD/) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name funsd \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 1e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-funsd\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd. By specifying the `push_to_hub` flag, the model gets uploaded automatically to the hub (regularly), together with a model card, which includes metrics such as precision, recall and F1. Note that you can easily update the model card, as it's just a README file of the respective repo on the hub.\n\nThere's also the \"Training metrics\" [tab](https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd/tensorboard), which shows Tensorboard logs over the course of training. Pretty neat, huh?\n\n## Fine-tuning on CORD\n\nFine-tuning LayoutLMv3 for token classification on [CORD](https://github.com/clovaai/cord) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name cord \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 5e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-cord\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-cord. Note that a model card gets generated automatically in case you specify the `push_to_hub` flag."
            },
            {
                "score": 0.6993080001921489,
                "node_text": "Here are some facts extracted from the provided text:\n\nRule #2 -> Prohibits -> Data-dependent shapes\nRule #3 -> Requires -> Recompilation for different input shapes\n\nWe\u2019ve distilled them into three core rules below:\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** We\u2019ve put a lot of effort into rewriting our TensorFlow models and loss functions to be XLA-compatible. Our models and loss functions generally obey rule #1 and #2 by default, so you can skip over them if you\u2019re using `transformers` models. Don\u2019t forget about these rules when writing your own models and loss functions, though!\n\n</Tip>\n\n#### XLA Rule #1: Your code cannot have \u201cdata-dependent conditionals\u201d\n\nWhat that means is that any `if` statement cannot depend on values inside a `tf.Tensor`. For example, this code block cannot be compiled with XLA!\n\n```python\nif tf.reduce_sum(tensor) > 10:\n    tensor = tensor / 2.0\n```\n\nThis might seem very restrictive at first, but most neural net code doesn\u2019t need to do this. You can often get around this restriction by using `tf.cond` (see the documentation [here](https://www.tensorflow.org/api_docs/python/tf/cond)) or by removing the conditional and finding a clever math trick with indicator variables instead, like so:\n\n```python\nsum_over_10 = tf.cast(tf.reduce_sum(tensor) > 10, tf.float32)\ntensor = tensor / (1.0 + sum_over_10)\n```\n\nThis code has exactly the same effect as the code above, but by avoiding a conditional, we ensure it will compile with XLA without problems!\n\n#### XLA Rule #2: Your code cannot have \u201cdata-dependent shapes\u201d\n\nWhat this means is that the shape of all of the `tf.Tensor` objects in your code cannot depend on their values. For example, the function `tf.unique` cannot be compiled with XLA, because it returns a `tensor` containing one instance of each unique value in the input. The shape of this output will obviously be different depending on how repetitive the input `Tensor` was, and so XLA refuses to handle it!\n\nIn general, most neural network code obeys rule #2 by default. However, there are a few common cases where it becomes a problem. One very common one is when you use **label masking**, setting your labels to a negative value to indicate that those positions should be ignored when computing the loss. If you look at NumPy or PyTorch loss functions that support label masking, you will often see code like this that uses [boolean indexing](https://numpy.org/doc/stable/user/basics.indexing.html#boolean-array-indexing):\n\n```python\nlabel_mask = labels >= 0\nmasked_outputs = outputs[label_mask]\nmasked_labels = labels[label_mask]\nloss = compute_loss(masked_outputs, masked_labels)\nmean_loss = torch.mean(loss)\n```\n\nThis code is totally fine in NumPy or PyTorch, but it breaks in XLA! Why? Because the shape of `masked_outputs` and `masked_labels` depends on how many positions are masked - that makes it a **data-dependent shape.** However, just like for rule #1, we can often rewrite this code to yield exactly the same output without any data-dependent shapes.\n\n```python\nlabel_mask = tf.cast(labels >= 0, tf.float32)\nloss = compute_loss(outputs, labels)\nloss = loss * label_mask  # Set negative label positions to 0\nmean_loss = tf.reduce_sum(loss) / tf.reduce_sum(label_mask)\n```\n\nHere, we avoid data-dependent shapes by computing the loss for every position, but zeroing out the masked positions in both the numerator and denominator when we calculate the mean, which yields exactly the same result as the first block while maintaining XLA compatibility. Note that we use the same trick as in rule #1 - converting a `tf.bool` to `tf.float32` and using it as an indicator variable. This is a really useful trick, so remember it if you need to convert your own code to XLA!\n\n#### XLA Rule #3: XLA will need to recompile your model for every different input shape it sees\n\nThis is the big one. What this means is that if your input shapes are very variable, XLA will have to recompile your model over and over, which will create huge performance problems. This commonly arises in NLP models, where input texts have variable lengths after tokenization. In other modalities, static shapes are more common and this rule is much less of a problem.\n\nHow can you get around rule #3? The key is **padding** - if you pad all your inputs to the same length, and then use an `attention_mask`, you can get the same results as you\u2019d get from variable shapes, but without any XLA issues."
            },
            {
                "score": 0.5655792060135576,
                "node_text": "Here are some facts extracted from the provided text:\n\nGradio -> Supports -> Hugging face models\n\nGradio Demo: blocks_random_slider\n\n\n```\n!pip install -q gradio \n```\n\n\n```\n\nimport gradio as gr\n\n\ndef func(slider_1, slider_2):\n    return slider_1 * 5 + slider_2\n\n\nwith gr.Blocks() as demo:\n    slider = gr.Slider(minimum=-10.2, maximum=15, label=\"Random Slider (Static)\", randomize=True)\n    slider_1 = gr.Slider(minimum=100, maximum=200, label=\"Random Slider (Input 1)\", randomize=True)\n    slider_2 = gr.Slider(minimum=10, maximum=23.2, label=\"Random Slider (Input 2)\", randomize=True)\n    slider_3 = gr.Slider(value=3, label=\"Non random slider\")\n    btn = gr.Button(\"Run\")\n    btn.click(func, inputs=[slider_1, slider_2], outputs=gr.Number())\n\nif __name__ == \"__main__\":\n    demo.launch()\n\n```"
            }
        ]
    },
    {
        "sample_idx": 78,
        "question": "What is required to run a model on TPU?",
        "answer": "You need to add a few lines to initialize your TPU, and ensure that your model and dataset are created inside a 'TPUStrategy' scope.",
        "rag_answer": "To run a model on TPU, the model needs to be XLA-compatible, which means it should follow the three rules of XLA: no data-dependent conditionals, no dynamic shapes, and XLA will need to recompile the model for every different input shape it sees. Additionally, the dataset needs to be prepared appropriately, and the code needs to be migrated to either Colab (with accelerator set to \u201cTPU\u201d) or a TPU VM on Google Cloud. The TPU initializer code needs to be added, and the dataset loading and model creation should be inside the `strategy.scope()`.",
        "rag_score": 4,
        "rag_feedback": "The system's response is mostly correct, accurate, and factual. It provides a detailed explanation of what is required to run a model on TPU, including the need for XLA compatibility, preparing the dataset, and adding TPU initializer code. The response also provides additional information about TPUs, XLA, and how to make a model XLA compatible, which is relevant to the question. However, some of the information provided is not directly related to the question, making the response a bit lengthy and verbose.",
        "rag_context": [
            {
                "score": 0.735114865098365,
                "node_text": "Here are some facts extracted from the provided text:\n\nTpuv4 -> Can be accessed as -> Tpu vm\nTpu vm -> Is -> Machine\nTpu vm -> Is -> Machine with tpu attached\nTpu vm -> Connects to -> Tpu\nTpu node -> Is -> Difficult to debug\nTpu node -> Is -> Confusing\nTpu node -> Is -> Remote tpu\n\n</Tip>\n\nThe second way to access a TPU is via a **TPU VM.** When using a TPU VM, you connect directly to the machine that the TPU is attached to, much like training on a GPU VM. TPU VMs are generally easier to work with, particularly when it comes to your data pipeline. All of the above warnings do not apply to TPU VMs!\n\nThis is an opinionated document, so here\u2019s our opinion: **Avoid using TPU Node if possible.** It is more confusing and more difficult to debug than TPU VMs. It is also likely to be unsupported in future - Google\u2019s latest TPU, TPUv4, can only be accessed as a TPU VM, which suggests that TPU Nodes are increasingly going to become a \u201clegacy\u201d access method. However, we understand that the only free TPU access is on Colab and Kaggle Kernels, which uses TPU Node - so we\u2019ll try to explain how to handle it if you have to! Check the [TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) for code samples that explain this in more detail.\n\n### What sizes of TPU are available?\n\nA single TPU (a v2-8/v3-8/v4-8) runs 8 replicas. TPUs exist in **pods** that can run hundreds or thousands of replicas simultaneously. When you use more than a single TPU but less than a whole pod (for example, a v3-32), your TPU fleet is referred to as a **pod slice.**\n\nWhen you access a free TPU via Colab, you generally get a single v2-8 TPU.\n\n### I keep hearing about this XLA thing. What\u2019s XLA, and how does it relate to TPUs?\n\nXLA is an optimizing compiler, used by both TensorFlow and JAX. In JAX it is the only compiler, whereas in TensorFlow it is optional (but mandatory on TPU!). The easiest way to enable it when training a Keras model is to pass the argument `jit_compile=True` to `model.compile()`. If you don\u2019t get any errors and performance is good, that\u2019s a great sign that you\u2019re ready to move to TPU!\n\nDebugging on TPU is generally a bit harder than on CPU/GPU, so we recommend getting your code running on CPU/GPU with XLA first before trying it on TPU. You don\u2019t have to train for long, of course - just for a few steps to make sure that your model and data pipeline are working like you expect them to.\n\n<Tip>\n\nXLA compiled code is usually faster - so even if you\u2019re not planning to run on TPU, adding `jit_compile=True` can improve your performance. Be sure to note the caveats below about XLA compatibility, though!\n\n</Tip>\n\n<Tip warning={true}>\n\n**Tip born of painful experience:** Although using `jit_compile=True` is a good way to get a speed boost and test if your CPU/GPU code is XLA-compatible, it can actually cause a lot of problems if you leave it in when actually training on TPU. XLA compilation will happen implicitly on TPU, so remember to remove that line before actually running your code on a TPU!\n\n</Tip>\n\n### How do I make my model XLA compatible?\n\nIn many cases, your code is probably XLA-compatible already! However, there are a few things that work in normal TensorFlow that don\u2019t work in XLA. We\u2019ve distilled them into three core rules below:\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** We\u2019ve put a lot of effort into rewriting our TensorFlow models and loss functions to be XLA-compatible. Our models and loss functions generally obey rule #1 and #2 by default, so you can skip over them if you\u2019re using `transformers` models. Don\u2019t forget about these rules when writing your own models and loss functions, though!\n\n</Tip>\n\n#### XLA Rule #1: Your code cannot have \u201cdata-dependent conditionals\u201d\n\nWhat that means is that any `if` statement cannot depend on values inside a `tf.Tensor`. For example, this code block cannot be compiled with XLA!\n\n```python\nif tf.reduce_sum(tensor) > 10:\n    tensor = tensor / 2.0\n```\n\nThis might seem very restrictive at first, but most neural net code doesn\u2019t need to do this."
            },
            {
                "score": 0.7094030179687995,
                "node_text": "Here are some facts extracted from the provided text:\n\nTpu -> Is used -> For training\nXla -> Is mandatory on -> Tpu\nTpu -> Accessed through -> Google's cloud services\nTpu -> Is -> Tensor processing unit\nTpu -> Used for -> Neural networks\nTpu -> Exists in -> Pods\n\nThis is a really useful trick, so remember it if you need to convert your own code to XLA!\n\n#### XLA Rule #3: XLA will need to recompile your model for every different input shape it sees\n\nThis is the big one. What this means is that if your input shapes are very variable, XLA will have to recompile your model over and over, which will create huge performance problems. This commonly arises in NLP models, where input texts have variable lengths after tokenization. In other modalities, static shapes are more common and this rule is much less of a problem.\n\nHow can you get around rule #3? The key is **padding** - if you pad all your inputs to the same length, and then use an `attention_mask`, you can get the same results as you\u2019d get from variable shapes, but without any XLA issues. However, excessive padding can cause severe slowdown too - if you pad all your samples to the maximum length in the whole dataset, you might end up with batches consisting endless padding tokens, which will waste a lot of compute and memory!\n\nThere isn\u2019t a perfect solution to this problem. However, you can try some tricks. One very useful trick is to **pad batches of samples up to a multiple of a number like 32 or 64 tokens.** This often only increases the number of tokens by a small amount, but it hugely reduces the number of unique input shapes, because every input shape now has to be a multiple of 32 or 64. Fewer unique input shapes means fewer XLA compilations!\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** Our tokenizers and data collators have methods that can help you here. You can use `padding=\"max_length\"` or `padding=\"longest\"` when calling tokenizers to get them to output padded data. Our tokenizers and data collators also have a `pad_to_multiple_of` argument that you can use to reduce the number of unique input shapes you see!\n\n</Tip>\n\n### How do I actually train my model on TPU?\n\nOnce your training is XLA-compatible and (if you\u2019re using TPU Node / Colab) your dataset has been prepared appropriately, running on TPU is surprisingly easy! All you really need to change in your code is to add a few lines to initialize your TPU, and to ensure that your model and dataset are created inside a `TPUStrategy` scope. Take a look at [our TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) to see this in action!\n\n### Summary\n\nThere was a lot in here, so let\u2019s summarize with a quick checklist you can follow when you want to get your model ready for TPU training:\n\n- Make sure your code follows the three rules of XLA\n- Compile your model with `jit_compile=True` on CPU/GPU and confirm that you can train it with XLA\n- Either load your dataset into memory or use a TPU-compatible dataset loading approach (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Migrate your code either to Colab (with accelerator set to \u201cTPU\u201d) or a TPU VM on Google Cloud\n- Add TPU initializer code (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Create your `TPUStrategy` and make sure dataset loading and model creation are inside the `strategy.scope()` (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Don\u2019t forget to take `jit_compile=True` out again when you move to TPU!\n- \ud83d\ude4f\ud83d\ude4f\ud83d\ude4f\ud83e\udd7a\ud83e\udd7a\ud83e\udd7a\n- Call model.fit()\n- You did it!"
            },
            {
                "score": 0.7094030179687995,
                "node_text": "Here are some facts extracted from the provided text:\n\nGoogle -> Designed -> Tpu\n\n!--Copyright 2023 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\nthe License. You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under the License is distributed on\nan \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n\n\u26a0\ufe0f Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be\nrendered properly in your Markdown viewer.\n\n-->\n\n# Training on TPU with TensorFlow\n\n<Tip>\n\nIf you don't need long explanations and just want TPU code samples to get started with, check out [our TPU example notebook!](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb)\n\n</Tip>\n\n### What is a TPU?\n\nA TPU is a **Tensor Processing Unit.** They are hardware designed by Google, which are used to greatly speed up the tensor computations within neural networks, much like GPUs. They can be used for both network training and inference. They are generally accessed through Google\u2019s cloud services, but small TPUs can also be accessed directly for free through Google Colab and Kaggle Kernels.\n\nBecause [all TensorFlow models in \ud83e\udd17 Transformers are Keras models](https://huggingface.co/blog/tensorflow-philosophy), most of the methods in this document are generally applicable to TPU training for any Keras model! However, there are a few points that are specific to the HuggingFace ecosystem (hug-o-system?) of Transformers and Datasets, and we\u2019ll make sure to flag them up when we get to them.\n\n### What kinds of TPU are available?\n\nNew users are often very confused by the range of TPUs, and the different ways to access them. The first key distinction to understand is the difference between **TPU Nodes** and **TPU VMs.**\n\nWhen you use a **TPU Node**, you are effectively indirectly accessing a remote TPU. You will need a separate VM, which will initialize your network and data pipeline and then forward them to the remote node. When you use a TPU on Google Colab, you are accessing it in the **TPU Node** style.\n\nUsing TPU Nodes can have some quite unexpected behaviour for people who aren\u2019t used to them! In particular, because the TPU is located on a physically different system to the machine you\u2019re running your Python code on, your data cannot be local to your machine - any data pipeline that loads from your machine\u2019s internal storage will totally fail! Instead, data must be stored in Google Cloud Storage where your data pipeline can still access it, even when the pipeline is running on the remote TPU node.\n\n<Tip>\n\nIf you can fit all your data in memory as `np.ndarray` or `tf.Tensor`, then you can `fit()` on that data even when using Colab or a TPU Node, without needing to upload it to Google Cloud Storage.\n\n</Tip>\n\n<Tip>\n\n**\ud83e\udd17Specific Hugging Face Tip\ud83e\udd17:** The methods `Dataset.to_tf_dataset()` and its higher-level wrapper `model.prepare_tf_dataset()` , which you will see throughout our TF code examples, will both fail on a TPU Node. The reason for this is that even though they create a `tf.data.Dataset` it is not a \u201cpure\u201d `tf.data` pipeline and uses `tf.numpy_function` or `Dataset.from_generator()` to stream data from the underlying HuggingFace `Dataset`. This HuggingFace `Dataset` is backed by data that is on a local disc and which the remote TPU Node will not be able to read.\n\n</Tip>\n\nThe second way to access a TPU is via a **TPU VM.** When using a TPU VM, you connect directly to the machine that the TPU is attached to, much like training on a GPU VM. TPU VMs are generally easier to work with, particularly when it comes to your data pipeline. All of the above warnings do not apply to TPU VMs!\n\nThis is an opinionated document, so here\u2019s our opinion: **Avoid using TPU Node if possible.** It is more confusing and more difficult to debug than TPU VMs. It is also likely to be unsupported in future - Google\u2019s latest TPU, TPUv4, can only be accessed as a TPU VM, which suggests that TPU Nodes are increasingly going to become a \u201clegacy\u201d access method."
            }
        ]
    },
    {
        "sample_idx": 79,
        "question": "What is the purpose of setting jit_compile=True on CPU/GPU?",
        "answer": "To confirm that the model can be trained with XLA.",
        "rag_answer": "The purpose of setting `jit_compile=True` on CPU/GPU is to compile the model with XLA and confirm that it can be trained with XLA.",
        "rag_score": 5,
        "rag_feedback": "The system's response is completely correct, accurate, and factual. It correctly states the purpose of setting jit_compile=True on CPU/GPU, which is to compile the model with XLA and confirm that it can be trained with XLA.",
        "rag_context": [
            {
                "score": 0.6354662341181595,
                "node_text": "Here are some facts extracted from the provided text:\n\nXla -> Is -> Optimizing compiler\nXla -> Needs -> Recompile\n\nThis is a really useful trick, so remember it if you need to convert your own code to XLA!\n\n#### XLA Rule #3: XLA will need to recompile your model for every different input shape it sees\n\nThis is the big one. What this means is that if your input shapes are very variable, XLA will have to recompile your model over and over, which will create huge performance problems. This commonly arises in NLP models, where input texts have variable lengths after tokenization. In other modalities, static shapes are more common and this rule is much less of a problem.\n\nHow can you get around rule #3? The key is **padding** - if you pad all your inputs to the same length, and then use an `attention_mask`, you can get the same results as you\u2019d get from variable shapes, but without any XLA issues. However, excessive padding can cause severe slowdown too - if you pad all your samples to the maximum length in the whole dataset, you might end up with batches consisting endless padding tokens, which will waste a lot of compute and memory!\n\nThere isn\u2019t a perfect solution to this problem. However, you can try some tricks. One very useful trick is to **pad batches of samples up to a multiple of a number like 32 or 64 tokens.** This often only increases the number of tokens by a small amount, but it hugely reduces the number of unique input shapes, because every input shape now has to be a multiple of 32 or 64. Fewer unique input shapes means fewer XLA compilations!\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** Our tokenizers and data collators have methods that can help you here. You can use `padding=\"max_length\"` or `padding=\"longest\"` when calling tokenizers to get them to output padded data. Our tokenizers and data collators also have a `pad_to_multiple_of` argument that you can use to reduce the number of unique input shapes you see!\n\n</Tip>\n\n### How do I actually train my model on TPU?\n\nOnce your training is XLA-compatible and (if you\u2019re using TPU Node / Colab) your dataset has been prepared appropriately, running on TPU is surprisingly easy! All you really need to change in your code is to add a few lines to initialize your TPU, and to ensure that your model and dataset are created inside a `TPUStrategy` scope. Take a look at [our TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) to see this in action!\n\n### Summary\n\nThere was a lot in here, so let\u2019s summarize with a quick checklist you can follow when you want to get your model ready for TPU training:\n\n- Make sure your code follows the three rules of XLA\n- Compile your model with `jit_compile=True` on CPU/GPU and confirm that you can train it with XLA\n- Either load your dataset into memory or use a TPU-compatible dataset loading approach (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Migrate your code either to Colab (with accelerator set to \u201cTPU\u201d) or a TPU VM on Google Cloud\n- Add TPU initializer code (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Create your `TPUStrategy` and make sure dataset loading and model creation are inside the `strategy.scope()` (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Don\u2019t forget to take `jit_compile=True` out again when you move to TPU!\n- \ud83d\ude4f\ud83d\ude4f\ud83d\ude4f\ud83e\udd7a\ud83e\udd7a\ud83e\udd7a\n- Call model.fit()\n- You did it!"
            },
            {
                "score": 0.5773557497087218,
                "node_text": "Here are some facts extracted from the provided text:\n\nRule #3 -> Requires -> Recompilation for different input shapes\n\nWe\u2019ve distilled them into three core rules below:\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** We\u2019ve put a lot of effort into rewriting our TensorFlow models and loss functions to be XLA-compatible. Our models and loss functions generally obey rule #1 and #2 by default, so you can skip over them if you\u2019re using `transformers` models. Don\u2019t forget about these rules when writing your own models and loss functions, though!\n\n</Tip>\n\n#### XLA Rule #1: Your code cannot have \u201cdata-dependent conditionals\u201d\n\nWhat that means is that any `if` statement cannot depend on values inside a `tf.Tensor`. For example, this code block cannot be compiled with XLA!\n\n```python\nif tf.reduce_sum(tensor) > 10:\n    tensor = tensor / 2.0\n```\n\nThis might seem very restrictive at first, but most neural net code doesn\u2019t need to do this. You can often get around this restriction by using `tf.cond` (see the documentation [here](https://www.tensorflow.org/api_docs/python/tf/cond)) or by removing the conditional and finding a clever math trick with indicator variables instead, like so:\n\n```python\nsum_over_10 = tf.cast(tf.reduce_sum(tensor) > 10, tf.float32)\ntensor = tensor / (1.0 + sum_over_10)\n```\n\nThis code has exactly the same effect as the code above, but by avoiding a conditional, we ensure it will compile with XLA without problems!\n\n#### XLA Rule #2: Your code cannot have \u201cdata-dependent shapes\u201d\n\nWhat this means is that the shape of all of the `tf.Tensor` objects in your code cannot depend on their values. For example, the function `tf.unique` cannot be compiled with XLA, because it returns a `tensor` containing one instance of each unique value in the input. The shape of this output will obviously be different depending on how repetitive the input `Tensor` was, and so XLA refuses to handle it!\n\nIn general, most neural network code obeys rule #2 by default. However, there are a few common cases where it becomes a problem. One very common one is when you use **label masking**, setting your labels to a negative value to indicate that those positions should be ignored when computing the loss. If you look at NumPy or PyTorch loss functions that support label masking, you will often see code like this that uses [boolean indexing](https://numpy.org/doc/stable/user/basics.indexing.html#boolean-array-indexing):\n\n```python\nlabel_mask = labels >= 0\nmasked_outputs = outputs[label_mask]\nmasked_labels = labels[label_mask]\nloss = compute_loss(masked_outputs, masked_labels)\nmean_loss = torch.mean(loss)\n```\n\nThis code is totally fine in NumPy or PyTorch, but it breaks in XLA! Why? Because the shape of `masked_outputs` and `masked_labels` depends on how many positions are masked - that makes it a **data-dependent shape.** However, just like for rule #1, we can often rewrite this code to yield exactly the same output without any data-dependent shapes.\n\n```python\nlabel_mask = tf.cast(labels >= 0, tf.float32)\nloss = compute_loss(outputs, labels)\nloss = loss * label_mask  # Set negative label positions to 0\nmean_loss = tf.reduce_sum(loss) / tf.reduce_sum(label_mask)\n```\n\nHere, we avoid data-dependent shapes by computing the loss for every position, but zeroing out the masked positions in both the numerator and denominator when we calculate the mean, which yields exactly the same result as the first block while maintaining XLA compatibility. Note that we use the same trick as in rule #1 - converting a `tf.bool` to `tf.float32` and using it as an indicator variable. This is a really useful trick, so remember it if you need to convert your own code to XLA!\n\n#### XLA Rule #3: XLA will need to recompile your model for every different input shape it sees\n\nThis is the big one. What this means is that if your input shapes are very variable, XLA will have to recompile your model over and over, which will create huge performance problems. This commonly arises in NLP models, where input texts have variable lengths after tokenization. In other modalities, static shapes are more common and this rule is much less of a problem.\n\nHow can you get around rule #3? The key is **padding** - if you pad all your inputs to the same length, and then use an `attention_mask`, you can get the same results as you\u2019d get from variable shapes, but without any XLA issues."
            },
            {
                "score": 0.5733642070471758,
                "node_text": "Here are some facts extracted from the provided text:\n\nGlue benchmark -> Has -> Dedicated evaluation metric\n\nChoosing a metric for your task\n\n**So you've trained your model and want to see how well it\u2019s doing on a dataset of your choice. Where do you start?**\n\nThere is no \u201cone size fits all\u201d approach to choosing an evaluation metric, but some good guidelines to keep in mind are:\n\n## Categories of metrics\n\nThere are 3 high-level categories of metrics:\n\n1. *Generic metrics*, which can be applied to a variety of situations and datasets, such as precision and accuracy.\n2. *Task-specific metrics*, which are limited to a given task, such as Machine Translation (often evaluated using metrics [BLEU](https://huggingface.co/metrics/bleu) or [ROUGE](https://huggingface.co/metrics/rouge)) or Named Entity Recognition (often evaluated with [seqeval](https://huggingface.co/metrics/seqeval)).\n3. *Dataset-specific metrics*, which aim to measure model performance on specific benchmarks: for instance, the [GLUE benchmark](https://huggingface.co/datasets/glue) has a dedicated [evaluation metric](https://huggingface.co/metrics/glue).\n\nLet's look at each of these three cases:\n\n### Generic metrics\n\nMany of the metrics used in the Machine Learning community are quite generic and can be applied in a variety of tasks and datasets.\n\nThis is the case for metrics like [accuracy](https://huggingface.co/metrics/accuracy) and [precision](https://huggingface.co/metrics/precision), which can be used for evaluating labeled (supervised) datasets, as well as [perplexity](https://huggingface.co/metrics/perplexity), which can be used for evaluating different kinds of (unsupervised) generative tasks.\n\nTo see the input structure of a given metric, you can look at its metric card. For example, in the case of [precision](https://huggingface.co/metrics/precision), the format is:\n```\n>>> precision_metric = evaluate.load(\"precision\")\n>>> results = precision_metric.compute(references=[0, 1], predictions=[0, 1])\n>>> print(results)\n{'precision': 1.0}\n```\n\n### Task-specific metrics\n\nPopular ML tasks like Machine Translation and Named Entity Recognition have specific metrics that can be used to compare models. For example, a series of different metrics have been proposed for text generation, ranging from [BLEU](https://huggingface.co/metrics/bleu) and its derivatives such as [GoogleBLEU](https://huggingface.co/metrics/google_bleu) and [GLEU](https://huggingface.co/metrics/gleu), but also [ROUGE](https://huggingface.co/metrics/rouge), [MAUVE](https://huggingface.co/metrics/mauve), etc.\n\nYou can find the right metric for your task by:\n\n- **Looking at the [Task pages](https://huggingface.co/tasks)** to see what metrics can be used for evaluating models for a given task.\n- **Checking out leaderboards** on sites like [Papers With Code](https://paperswithcode.com/) (you can search by task and by dataset).\n-  **Reading the metric cards** for the relevant metrics and see which ones are a good fit for your use case. For example, see the [BLEU metric card](https://github.com/huggingface/evaluate/tree/main/metrics/bleu) or [SQuaD metric card](https://github.com/huggingface/evaluate/tree/main/metrics/squad).\n- **Looking at papers and blog posts** published on the topic and see what metrics they report. This can change over time, so try to pick papers from the last couple of years!\n\n### Dataset-specific metrics\n\nSome datasets have specific metrics associated with them -- this is especially in the case of popular benchmarks like [GLUE](https://huggingface.co/metrics/glue) and [SQuAD](https://huggingface.co/metrics/squad).\n\n<Tip warning={true}>\n\ud83d\udca1\nGLUE is actually a collection of different subsets on different tasks, so first you need to choose the one that corresponds to the NLI task, such as mnli, which is described as \u201ccrowdsourced collection of sentence pairs with textual entailment annotations\u201d\n</Tip>"
            }
        ]
    },
    {
        "sample_idx": 80,
        "question": "What are the two options to migrate code for TPU training?",
        "answer": "Colab with accelerator set to 'TPU' or a TPU VM on Google Cloud.",
        "rag_answer": "The two options to access a TPU are via a TPU Node and a TPU VM.",
        "rag_score": 3,
        "rag_feedback": "The system's response is somewhat correct, but it does not directly answer the question. The response mentions TPU Node and TPU VM as options to access a TPU, but it does not explicitly state that these are options for migrating code for TPU training. The response is more focused on explaining the differences between TPU Node and TPU VM, and providing additional information about TPUs and XLA.",
        "rag_context": [
            {
                "score": 0.6957881057402022,
                "node_text": "Here are some facts extracted from the provided text:\n\nTpu node -> Is -> Remote tpu\nTpuv4 -> Can be accessed as -> Tpu vm\nTpu vm -> Is -> Machine\nTpu vm -> Is -> Machine with tpu attached\nTpu vm -> Connects to -> Tpu\nTpu node -> Is -> Difficult to debug\nTpu node -> Is -> Confusing\n\n</Tip>\n\nThe second way to access a TPU is via a **TPU VM.** When using a TPU VM, you connect directly to the machine that the TPU is attached to, much like training on a GPU VM. TPU VMs are generally easier to work with, particularly when it comes to your data pipeline. All of the above warnings do not apply to TPU VMs!\n\nThis is an opinionated document, so here\u2019s our opinion: **Avoid using TPU Node if possible.** It is more confusing and more difficult to debug than TPU VMs. It is also likely to be unsupported in future - Google\u2019s latest TPU, TPUv4, can only be accessed as a TPU VM, which suggests that TPU Nodes are increasingly going to become a \u201clegacy\u201d access method. However, we understand that the only free TPU access is on Colab and Kaggle Kernels, which uses TPU Node - so we\u2019ll try to explain how to handle it if you have to! Check the [TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) for code samples that explain this in more detail.\n\n### What sizes of TPU are available?\n\nA single TPU (a v2-8/v3-8/v4-8) runs 8 replicas. TPUs exist in **pods** that can run hundreds or thousands of replicas simultaneously. When you use more than a single TPU but less than a whole pod (for example, a v3-32), your TPU fleet is referred to as a **pod slice.**\n\nWhen you access a free TPU via Colab, you generally get a single v2-8 TPU.\n\n### I keep hearing about this XLA thing. What\u2019s XLA, and how does it relate to TPUs?\n\nXLA is an optimizing compiler, used by both TensorFlow and JAX. In JAX it is the only compiler, whereas in TensorFlow it is optional (but mandatory on TPU!). The easiest way to enable it when training a Keras model is to pass the argument `jit_compile=True` to `model.compile()`. If you don\u2019t get any errors and performance is good, that\u2019s a great sign that you\u2019re ready to move to TPU!\n\nDebugging on TPU is generally a bit harder than on CPU/GPU, so we recommend getting your code running on CPU/GPU with XLA first before trying it on TPU. You don\u2019t have to train for long, of course - just for a few steps to make sure that your model and data pipeline are working like you expect them to.\n\n<Tip>\n\nXLA compiled code is usually faster - so even if you\u2019re not planning to run on TPU, adding `jit_compile=True` can improve your performance. Be sure to note the caveats below about XLA compatibility, though!\n\n</Tip>\n\n<Tip warning={true}>\n\n**Tip born of painful experience:** Although using `jit_compile=True` is a good way to get a speed boost and test if your CPU/GPU code is XLA-compatible, it can actually cause a lot of problems if you leave it in when actually training on TPU. XLA compilation will happen implicitly on TPU, so remember to remove that line before actually running your code on a TPU!\n\n</Tip>\n\n### How do I make my model XLA compatible?\n\nIn many cases, your code is probably XLA-compatible already! However, there are a few things that work in normal TensorFlow that don\u2019t work in XLA. We\u2019ve distilled them into three core rules below:\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** We\u2019ve put a lot of effort into rewriting our TensorFlow models and loss functions to be XLA-compatible. Our models and loss functions generally obey rule #1 and #2 by default, so you can skip over them if you\u2019re using `transformers` models. Don\u2019t forget about these rules when writing your own models and loss functions, though!\n\n</Tip>\n\n#### XLA Rule #1: Your code cannot have \u201cdata-dependent conditionals\u201d\n\nWhat that means is that any `if` statement cannot depend on values inside a `tf.Tensor`. For example, this code block cannot be compiled with XLA!\n\n```python\nif tf.reduce_sum(tensor) > 10:\n    tensor = tensor / 2.0\n```\n\nThis might seem very restrictive at first, but most neural net code doesn\u2019t need to do this."
            }
        ]
    },
    {
        "sample_idx": 81,
        "question": "Where can you find the TPU initializer code?",
        "answer": "In the provided notebook.",
        "rag_answer": "You can find the TPU initializer code in the TPU example notebook.",
        "rag_score": 4,
        "rag_feedback": "The system's response is mostly correct, accurate, and factual. It provides a relevant and detailed explanation of where to find the TPU initializer code, which is in the provided notebook. The response is supported by the context, which mentions the TPU example notebook as a resource for code samples.",
        "rag_context": [
            {
                "score": 0.7610572637462516,
                "node_text": "Here are some facts extracted from the provided text:\n\nTpuv4 -> Can be accessed as -> Tpu vm\nTpu vm -> Is -> Machine\nTpu vm -> Is -> Machine with tpu attached\nTpu vm -> Connects to -> Tpu\nTpu node -> Is -> Remote tpu\nTpu node -> Is -> Difficult to debug\nTpu node -> Is -> Confusing\n\n</Tip>\n\nThe second way to access a TPU is via a **TPU VM.** When using a TPU VM, you connect directly to the machine that the TPU is attached to, much like training on a GPU VM. TPU VMs are generally easier to work with, particularly when it comes to your data pipeline. All of the above warnings do not apply to TPU VMs!\n\nThis is an opinionated document, so here\u2019s our opinion: **Avoid using TPU Node if possible.** It is more confusing and more difficult to debug than TPU VMs. It is also likely to be unsupported in future - Google\u2019s latest TPU, TPUv4, can only be accessed as a TPU VM, which suggests that TPU Nodes are increasingly going to become a \u201clegacy\u201d access method. However, we understand that the only free TPU access is on Colab and Kaggle Kernels, which uses TPU Node - so we\u2019ll try to explain how to handle it if you have to! Check the [TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) for code samples that explain this in more detail.\n\n### What sizes of TPU are available?\n\nA single TPU (a v2-8/v3-8/v4-8) runs 8 replicas. TPUs exist in **pods** that can run hundreds or thousands of replicas simultaneously. When you use more than a single TPU but less than a whole pod (for example, a v3-32), your TPU fleet is referred to as a **pod slice.**\n\nWhen you access a free TPU via Colab, you generally get a single v2-8 TPU.\n\n### I keep hearing about this XLA thing. What\u2019s XLA, and how does it relate to TPUs?\n\nXLA is an optimizing compiler, used by both TensorFlow and JAX. In JAX it is the only compiler, whereas in TensorFlow it is optional (but mandatory on TPU!). The easiest way to enable it when training a Keras model is to pass the argument `jit_compile=True` to `model.compile()`. If you don\u2019t get any errors and performance is good, that\u2019s a great sign that you\u2019re ready to move to TPU!\n\nDebugging on TPU is generally a bit harder than on CPU/GPU, so we recommend getting your code running on CPU/GPU with XLA first before trying it on TPU. You don\u2019t have to train for long, of course - just for a few steps to make sure that your model and data pipeline are working like you expect them to.\n\n<Tip>\n\nXLA compiled code is usually faster - so even if you\u2019re not planning to run on TPU, adding `jit_compile=True` can improve your performance. Be sure to note the caveats below about XLA compatibility, though!\n\n</Tip>\n\n<Tip warning={true}>\n\n**Tip born of painful experience:** Although using `jit_compile=True` is a good way to get a speed boost and test if your CPU/GPU code is XLA-compatible, it can actually cause a lot of problems if you leave it in when actually training on TPU. XLA compilation will happen implicitly on TPU, so remember to remove that line before actually running your code on a TPU!\n\n</Tip>\n\n### How do I make my model XLA compatible?\n\nIn many cases, your code is probably XLA-compatible already! However, there are a few things that work in normal TensorFlow that don\u2019t work in XLA. We\u2019ve distilled them into three core rules below:\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** We\u2019ve put a lot of effort into rewriting our TensorFlow models and loss functions to be XLA-compatible. Our models and loss functions generally obey rule #1 and #2 by default, so you can skip over them if you\u2019re using `transformers` models. Don\u2019t forget about these rules when writing your own models and loss functions, though!\n\n</Tip>\n\n#### XLA Rule #1: Your code cannot have \u201cdata-dependent conditionals\u201d\n\nWhat that means is that any `if` statement cannot depend on values inside a `tf.Tensor`. For example, this code block cannot be compiled with XLA!\n\n```python\nif tf.reduce_sum(tensor) > 10:\n    tensor = tensor / 2.0\n```\n\nThis might seem very restrictive at first, but most neural net code doesn\u2019t need to do this."
            },
            {
                "score": 0.745932997379904,
                "node_text": "Here are some facts extracted from the provided text:\n\nTpu -> Is used -> For training\nXla -> Is mandatory on -> Tpu\nTpu -> Accessed through -> Google's cloud services\nTpu -> Is -> Tensor processing unit\nTpu -> Used for -> Neural networks\nTpu -> Exists in -> Pods\n\nThis is a really useful trick, so remember it if you need to convert your own code to XLA!\n\n#### XLA Rule #3: XLA will need to recompile your model for every different input shape it sees\n\nThis is the big one. What this means is that if your input shapes are very variable, XLA will have to recompile your model over and over, which will create huge performance problems. This commonly arises in NLP models, where input texts have variable lengths after tokenization. In other modalities, static shapes are more common and this rule is much less of a problem.\n\nHow can you get around rule #3? The key is **padding** - if you pad all your inputs to the same length, and then use an `attention_mask`, you can get the same results as you\u2019d get from variable shapes, but without any XLA issues. However, excessive padding can cause severe slowdown too - if you pad all your samples to the maximum length in the whole dataset, you might end up with batches consisting endless padding tokens, which will waste a lot of compute and memory!\n\nThere isn\u2019t a perfect solution to this problem. However, you can try some tricks. One very useful trick is to **pad batches of samples up to a multiple of a number like 32 or 64 tokens.** This often only increases the number of tokens by a small amount, but it hugely reduces the number of unique input shapes, because every input shape now has to be a multiple of 32 or 64. Fewer unique input shapes means fewer XLA compilations!\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** Our tokenizers and data collators have methods that can help you here. You can use `padding=\"max_length\"` or `padding=\"longest\"` when calling tokenizers to get them to output padded data. Our tokenizers and data collators also have a `pad_to_multiple_of` argument that you can use to reduce the number of unique input shapes you see!\n\n</Tip>\n\n### How do I actually train my model on TPU?\n\nOnce your training is XLA-compatible and (if you\u2019re using TPU Node / Colab) your dataset has been prepared appropriately, running on TPU is surprisingly easy! All you really need to change in your code is to add a few lines to initialize your TPU, and to ensure that your model and dataset are created inside a `TPUStrategy` scope. Take a look at [our TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) to see this in action!\n\n### Summary\n\nThere was a lot in here, so let\u2019s summarize with a quick checklist you can follow when you want to get your model ready for TPU training:\n\n- Make sure your code follows the three rules of XLA\n- Compile your model with `jit_compile=True` on CPU/GPU and confirm that you can train it with XLA\n- Either load your dataset into memory or use a TPU-compatible dataset loading approach (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Migrate your code either to Colab (with accelerator set to \u201cTPU\u201d) or a TPU VM on Google Cloud\n- Add TPU initializer code (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Create your `TPUStrategy` and make sure dataset loading and model creation are inside the `strategy.scope()` (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Don\u2019t forget to take `jit_compile=True` out again when you move to TPU!\n- \ud83d\ude4f\ud83d\ude4f\ud83d\ude4f\ud83e\udd7a\ud83e\udd7a\ud83e\udd7a\n- Call model.fit()\n- You did it!"
            },
            {
                "score": 0.745932997379904,
                "node_text": "Here are some facts extracted from the provided text:\n\nGoogle -> Designed -> Tpu\n\n!--Copyright 2023 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\nthe License. You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under the License is distributed on\nan \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n\n\u26a0\ufe0f Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be\nrendered properly in your Markdown viewer.\n\n-->\n\n# Training on TPU with TensorFlow\n\n<Tip>\n\nIf you don't need long explanations and just want TPU code samples to get started with, check out [our TPU example notebook!](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb)\n\n</Tip>\n\n### What is a TPU?\n\nA TPU is a **Tensor Processing Unit.** They are hardware designed by Google, which are used to greatly speed up the tensor computations within neural networks, much like GPUs. They can be used for both network training and inference. They are generally accessed through Google\u2019s cloud services, but small TPUs can also be accessed directly for free through Google Colab and Kaggle Kernels.\n\nBecause [all TensorFlow models in \ud83e\udd17 Transformers are Keras models](https://huggingface.co/blog/tensorflow-philosophy), most of the methods in this document are generally applicable to TPU training for any Keras model! However, there are a few points that are specific to the HuggingFace ecosystem (hug-o-system?) of Transformers and Datasets, and we\u2019ll make sure to flag them up when we get to them.\n\n### What kinds of TPU are available?\n\nNew users are often very confused by the range of TPUs, and the different ways to access them. The first key distinction to understand is the difference between **TPU Nodes** and **TPU VMs.**\n\nWhen you use a **TPU Node**, you are effectively indirectly accessing a remote TPU. You will need a separate VM, which will initialize your network and data pipeline and then forward them to the remote node. When you use a TPU on Google Colab, you are accessing it in the **TPU Node** style.\n\nUsing TPU Nodes can have some quite unexpected behaviour for people who aren\u2019t used to them! In particular, because the TPU is located on a physically different system to the machine you\u2019re running your Python code on, your data cannot be local to your machine - any data pipeline that loads from your machine\u2019s internal storage will totally fail! Instead, data must be stored in Google Cloud Storage where your data pipeline can still access it, even when the pipeline is running on the remote TPU node.\n\n<Tip>\n\nIf you can fit all your data in memory as `np.ndarray` or `tf.Tensor`, then you can `fit()` on that data even when using Colab or a TPU Node, without needing to upload it to Google Cloud Storage.\n\n</Tip>\n\n<Tip>\n\n**\ud83e\udd17Specific Hugging Face Tip\ud83e\udd17:** The methods `Dataset.to_tf_dataset()` and its higher-level wrapper `model.prepare_tf_dataset()` , which you will see throughout our TF code examples, will both fail on a TPU Node. The reason for this is that even though they create a `tf.data.Dataset` it is not a \u201cpure\u201d `tf.data` pipeline and uses `tf.numpy_function` or `Dataset.from_generator()` to stream data from the underlying HuggingFace `Dataset`. This HuggingFace `Dataset` is backed by data that is on a local disc and which the remote TPU Node will not be able to read.\n\n</Tip>\n\nThe second way to access a TPU is via a **TPU VM.** When using a TPU VM, you connect directly to the machine that the TPU is attached to, much like training on a GPU VM. TPU VMs are generally easier to work with, particularly when it comes to your data pipeline. All of the above warnings do not apply to TPU VMs!\n\nThis is an opinionated document, so here\u2019s our opinion: **Avoid using TPU Node if possible.** It is more confusing and more difficult to debug than TPU VMs. It is also likely to be unsupported in future - Google\u2019s latest TPU, TPUv4, can only be accessed as a TPU VM, which suggests that TPU Nodes are increasingly going to become a \u201clegacy\u201d access method."
            }
        ]
    },
    {
        "sample_idx": 82,
        "question": "What should you do with jit_compile=True when moving to TPU?",
        "answer": "Take it out.",
        "rag_answer": "You should remove `jit_compile=True` when moving to TPU.",
        "rag_score": 5,
        "rag_feedback": "The system's response is completely correct, accurate, and factual. It directly answers the question by stating that `jit_compile=True` should be removed when moving to TPU, which is in line with the expected answer.",
        "rag_context": [
            {
                "score": 1.0,
                "node_text": "Here are some facts extracted from the provided text:\n\nTpu -> Is -> Tensor processing unit\n\nThis is a really useful trick, so remember it if you need to convert your own code to XLA!\n\n#### XLA Rule #3: XLA will need to recompile your model for every different input shape it sees\n\nThis is the big one. What this means is that if your input shapes are very variable, XLA will have to recompile your model over and over, which will create huge performance problems. This commonly arises in NLP models, where input texts have variable lengths after tokenization. In other modalities, static shapes are more common and this rule is much less of a problem.\n\nHow can you get around rule #3? The key is **padding** - if you pad all your inputs to the same length, and then use an `attention_mask`, you can get the same results as you\u2019d get from variable shapes, but without any XLA issues. However, excessive padding can cause severe slowdown too - if you pad all your samples to the maximum length in the whole dataset, you might end up with batches consisting endless padding tokens, which will waste a lot of compute and memory!\n\nThere isn\u2019t a perfect solution to this problem. However, you can try some tricks. One very useful trick is to **pad batches of samples up to a multiple of a number like 32 or 64 tokens.** This often only increases the number of tokens by a small amount, but it hugely reduces the number of unique input shapes, because every input shape now has to be a multiple of 32 or 64. Fewer unique input shapes means fewer XLA compilations!\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** Our tokenizers and data collators have methods that can help you here. You can use `padding=\"max_length\"` or `padding=\"longest\"` when calling tokenizers to get them to output padded data. Our tokenizers and data collators also have a `pad_to_multiple_of` argument that you can use to reduce the number of unique input shapes you see!\n\n</Tip>\n\n### How do I actually train my model on TPU?\n\nOnce your training is XLA-compatible and (if you\u2019re using TPU Node / Colab) your dataset has been prepared appropriately, running on TPU is surprisingly easy! All you really need to change in your code is to add a few lines to initialize your TPU, and to ensure that your model and dataset are created inside a `TPUStrategy` scope. Take a look at [our TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) to see this in action!\n\n### Summary\n\nThere was a lot in here, so let\u2019s summarize with a quick checklist you can follow when you want to get your model ready for TPU training:\n\n- Make sure your code follows the three rules of XLA\n- Compile your model with `jit_compile=True` on CPU/GPU and confirm that you can train it with XLA\n- Either load your dataset into memory or use a TPU-compatible dataset loading approach (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Migrate your code either to Colab (with accelerator set to \u201cTPU\u201d) or a TPU VM on Google Cloud\n- Add TPU initializer code (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Create your `TPUStrategy` and make sure dataset loading and model creation are inside the `strategy.scope()` (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Don\u2019t forget to take `jit_compile=True` out again when you move to TPU!\n- \ud83d\ude4f\ud83d\ude4f\ud83d\ude4f\ud83e\udd7a\ud83e\udd7a\ud83e\udd7a\n- Call model.fit()\n- You did it!"
            },
            {
                "score": 0.6919836559078054,
                "node_text": "Here are some facts extracted from the provided text:\n\nTpuv4 -> Can be accessed as -> Tpu vm\nTpu vm -> Is -> Machine\nTpu vm -> Is -> Machine with tpu attached\nTpu vm -> Connects to -> Tpu\nTpu node -> Is -> Remote tpu\nTpu node -> Is -> Difficult to debug\nTpu node -> Is -> Confusing\n\n</Tip>\n\nThe second way to access a TPU is via a **TPU VM.** When using a TPU VM, you connect directly to the machine that the TPU is attached to, much like training on a GPU VM. TPU VMs are generally easier to work with, particularly when it comes to your data pipeline. All of the above warnings do not apply to TPU VMs!\n\nThis is an opinionated document, so here\u2019s our opinion: **Avoid using TPU Node if possible.** It is more confusing and more difficult to debug than TPU VMs. It is also likely to be unsupported in future - Google\u2019s latest TPU, TPUv4, can only be accessed as a TPU VM, which suggests that TPU Nodes are increasingly going to become a \u201clegacy\u201d access method. However, we understand that the only free TPU access is on Colab and Kaggle Kernels, which uses TPU Node - so we\u2019ll try to explain how to handle it if you have to! Check the [TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) for code samples that explain this in more detail.\n\n### What sizes of TPU are available?\n\nA single TPU (a v2-8/v3-8/v4-8) runs 8 replicas. TPUs exist in **pods** that can run hundreds or thousands of replicas simultaneously. When you use more than a single TPU but less than a whole pod (for example, a v3-32), your TPU fleet is referred to as a **pod slice.**\n\nWhen you access a free TPU via Colab, you generally get a single v2-8 TPU.\n\n### I keep hearing about this XLA thing. What\u2019s XLA, and how does it relate to TPUs?\n\nXLA is an optimizing compiler, used by both TensorFlow and JAX. In JAX it is the only compiler, whereas in TensorFlow it is optional (but mandatory on TPU!). The easiest way to enable it when training a Keras model is to pass the argument `jit_compile=True` to `model.compile()`. If you don\u2019t get any errors and performance is good, that\u2019s a great sign that you\u2019re ready to move to TPU!\n\nDebugging on TPU is generally a bit harder than on CPU/GPU, so we recommend getting your code running on CPU/GPU with XLA first before trying it on TPU. You don\u2019t have to train for long, of course - just for a few steps to make sure that your model and data pipeline are working like you expect them to.\n\n<Tip>\n\nXLA compiled code is usually faster - so even if you\u2019re not planning to run on TPU, adding `jit_compile=True` can improve your performance. Be sure to note the caveats below about XLA compatibility, though!\n\n</Tip>\n\n<Tip warning={true}>\n\n**Tip born of painful experience:** Although using `jit_compile=True` is a good way to get a speed boost and test if your CPU/GPU code is XLA-compatible, it can actually cause a lot of problems if you leave it in when actually training on TPU. XLA compilation will happen implicitly on TPU, so remember to remove that line before actually running your code on a TPU!\n\n</Tip>\n\n### How do I make my model XLA compatible?\n\nIn many cases, your code is probably XLA-compatible already! However, there are a few things that work in normal TensorFlow that don\u2019t work in XLA. We\u2019ve distilled them into three core rules below:\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** We\u2019ve put a lot of effort into rewriting our TensorFlow models and loss functions to be XLA-compatible. Our models and loss functions generally obey rule #1 and #2 by default, so you can skip over them if you\u2019re using `transformers` models. Don\u2019t forget about these rules when writing your own models and loss functions, though!\n\n</Tip>\n\n#### XLA Rule #1: Your code cannot have \u201cdata-dependent conditionals\u201d\n\nWhat that means is that any `if` statement cannot depend on values inside a `tf.Tensor`. For example, this code block cannot be compiled with XLA!\n\n```python\nif tf.reduce_sum(tensor) > 10:\n    tensor = tensor / 2.0\n```\n\nThis might seem very restrictive at first, but most neural net code doesn\u2019t need to do this."
            },
            {
                "score": 0.658081173863175,
                "node_text": "Here are some facts extracted from the provided text:\n\nTpu -> Is used -> For training\nXla -> Is mandatory on -> Tpu\nTpu -> Accessed through -> Google's cloud services\nTpu -> Is -> Tensor processing unit\nTpu -> Used for -> Neural networks\nTpu -> Exists in -> Pods\n\nThis is a really useful trick, so remember it if you need to convert your own code to XLA!\n\n#### XLA Rule #3: XLA will need to recompile your model for every different input shape it sees\n\nThis is the big one. What this means is that if your input shapes are very variable, XLA will have to recompile your model over and over, which will create huge performance problems. This commonly arises in NLP models, where input texts have variable lengths after tokenization. In other modalities, static shapes are more common and this rule is much less of a problem.\n\nHow can you get around rule #3? The key is **padding** - if you pad all your inputs to the same length, and then use an `attention_mask`, you can get the same results as you\u2019d get from variable shapes, but without any XLA issues. However, excessive padding can cause severe slowdown too - if you pad all your samples to the maximum length in the whole dataset, you might end up with batches consisting endless padding tokens, which will waste a lot of compute and memory!\n\nThere isn\u2019t a perfect solution to this problem. However, you can try some tricks. One very useful trick is to **pad batches of samples up to a multiple of a number like 32 or 64 tokens.** This often only increases the number of tokens by a small amount, but it hugely reduces the number of unique input shapes, because every input shape now has to be a multiple of 32 or 64. Fewer unique input shapes means fewer XLA compilations!\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** Our tokenizers and data collators have methods that can help you here. You can use `padding=\"max_length\"` or `padding=\"longest\"` when calling tokenizers to get them to output padded data. Our tokenizers and data collators also have a `pad_to_multiple_of` argument that you can use to reduce the number of unique input shapes you see!\n\n</Tip>\n\n### How do I actually train my model on TPU?\n\nOnce your training is XLA-compatible and (if you\u2019re using TPU Node / Colab) your dataset has been prepared appropriately, running on TPU is surprisingly easy! All you really need to change in your code is to add a few lines to initialize your TPU, and to ensure that your model and dataset are created inside a `TPUStrategy` scope. Take a look at [our TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) to see this in action!\n\n### Summary\n\nThere was a lot in here, so let\u2019s summarize with a quick checklist you can follow when you want to get your model ready for TPU training:\n\n- Make sure your code follows the three rules of XLA\n- Compile your model with `jit_compile=True` on CPU/GPU and confirm that you can train it with XLA\n- Either load your dataset into memory or use a TPU-compatible dataset loading approach (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Migrate your code either to Colab (with accelerator set to \u201cTPU\u201d) or a TPU VM on Google Cloud\n- Add TPU initializer code (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Create your `TPUStrategy` and make sure dataset loading and model creation are inside the `strategy.scope()` (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Don\u2019t forget to take `jit_compile=True` out again when you move to TPU!\n- \ud83d\ude4f\ud83d\ude4f\ud83d\ude4f\ud83e\udd7a\ud83e\udd7a\ud83e\udd7a\n- Call model.fit()\n- You did it!"
            },
            {
                "score": 0.658081173863175,
                "node_text": "Here are some facts extracted from the provided text:\n\nGoogle -> Designed -> Tpu\n\n!--Copyright 2023 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\nthe License. You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under the License is distributed on\nan \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n\n\u26a0\ufe0f Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be\nrendered properly in your Markdown viewer.\n\n-->\n\n# Training on TPU with TensorFlow\n\n<Tip>\n\nIf you don't need long explanations and just want TPU code samples to get started with, check out [our TPU example notebook!](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb)\n\n</Tip>\n\n### What is a TPU?\n\nA TPU is a **Tensor Processing Unit.** They are hardware designed by Google, which are used to greatly speed up the tensor computations within neural networks, much like GPUs. They can be used for both network training and inference. They are generally accessed through Google\u2019s cloud services, but small TPUs can also be accessed directly for free through Google Colab and Kaggle Kernels.\n\nBecause [all TensorFlow models in \ud83e\udd17 Transformers are Keras models](https://huggingface.co/blog/tensorflow-philosophy), most of the methods in this document are generally applicable to TPU training for any Keras model! However, there are a few points that are specific to the HuggingFace ecosystem (hug-o-system?) of Transformers and Datasets, and we\u2019ll make sure to flag them up when we get to them.\n\n### What kinds of TPU are available?\n\nNew users are often very confused by the range of TPUs, and the different ways to access them. The first key distinction to understand is the difference between **TPU Nodes** and **TPU VMs.**\n\nWhen you use a **TPU Node**, you are effectively indirectly accessing a remote TPU. You will need a separate VM, which will initialize your network and data pipeline and then forward them to the remote node. When you use a TPU on Google Colab, you are accessing it in the **TPU Node** style.\n\nUsing TPU Nodes can have some quite unexpected behaviour for people who aren\u2019t used to them! In particular, because the TPU is located on a physically different system to the machine you\u2019re running your Python code on, your data cannot be local to your machine - any data pipeline that loads from your machine\u2019s internal storage will totally fail! Instead, data must be stored in Google Cloud Storage where your data pipeline can still access it, even when the pipeline is running on the remote TPU node.\n\n<Tip>\n\nIf you can fit all your data in memory as `np.ndarray` or `tf.Tensor`, then you can `fit()` on that data even when using Colab or a TPU Node, without needing to upload it to Google Cloud Storage.\n\n</Tip>\n\n<Tip>\n\n**\ud83e\udd17Specific Hugging Face Tip\ud83e\udd17:** The methods `Dataset.to_tf_dataset()` and its higher-level wrapper `model.prepare_tf_dataset()` , which you will see throughout our TF code examples, will both fail on a TPU Node. The reason for this is that even though they create a `tf.data.Dataset` it is not a \u201cpure\u201d `tf.data` pipeline and uses `tf.numpy_function` or `Dataset.from_generator()` to stream data from the underlying HuggingFace `Dataset`. This HuggingFace `Dataset` is backed by data that is on a local disc and which the remote TPU Node will not be able to read.\n\n</Tip>\n\nThe second way to access a TPU is via a **TPU VM.** When using a TPU VM, you connect directly to the machine that the TPU is attached to, much like training on a GPU VM. TPU VMs are generally easier to work with, particularly when it comes to your data pipeline. All of the above warnings do not apply to TPU VMs!\n\nThis is an opinionated document, so here\u2019s our opinion: **Avoid using TPU Node if possible.** It is more confusing and more difficult to debug than TPU VMs. It is also likely to be unsupported in future - Google\u2019s latest TPU, TPUv4, can only be accessed as a TPU VM, which suggests that TPU Nodes are increasingly going to become a \u201clegacy\u201d access method."
            }
        ]
    },
    {
        "sample_idx": 83,
        "question": "What is the final step to train a model on TPU?",
        "answer": "Call model.fit().",
        "rag_answer": "The final step to train a model on TPU is to call model.fit().",
        "rag_score": 5,
        "rag_feedback": "The system's response is completely correct, accurate, and factual. It directly answers the question by stating that the final step to train a model on TPU is to call model.fit(). The response is clear and concise, and it matches the expected answer.",
        "rag_context": [
            {
                "score": 0.6906210974247977,
                "node_text": "Here are some facts extracted from the provided text:\n\nTpuv4 -> Can be accessed as -> Tpu vm\nTpu vm -> Is -> Machine\nTpu vm -> Is -> Machine with tpu attached\nTpu vm -> Connects to -> Tpu\nTpu node -> Is -> Difficult to debug\nTpu node -> Is -> Confusing\nTpu node -> Is -> Remote tpu\n\n</Tip>\n\nThe second way to access a TPU is via a **TPU VM.** When using a TPU VM, you connect directly to the machine that the TPU is attached to, much like training on a GPU VM. TPU VMs are generally easier to work with, particularly when it comes to your data pipeline. All of the above warnings do not apply to TPU VMs!\n\nThis is an opinionated document, so here\u2019s our opinion: **Avoid using TPU Node if possible.** It is more confusing and more difficult to debug than TPU VMs. It is also likely to be unsupported in future - Google\u2019s latest TPU, TPUv4, can only be accessed as a TPU VM, which suggests that TPU Nodes are increasingly going to become a \u201clegacy\u201d access method. However, we understand that the only free TPU access is on Colab and Kaggle Kernels, which uses TPU Node - so we\u2019ll try to explain how to handle it if you have to! Check the [TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) for code samples that explain this in more detail.\n\n### What sizes of TPU are available?\n\nA single TPU (a v2-8/v3-8/v4-8) runs 8 replicas. TPUs exist in **pods** that can run hundreds or thousands of replicas simultaneously. When you use more than a single TPU but less than a whole pod (for example, a v3-32), your TPU fleet is referred to as a **pod slice.**\n\nWhen you access a free TPU via Colab, you generally get a single v2-8 TPU.\n\n### I keep hearing about this XLA thing. What\u2019s XLA, and how does it relate to TPUs?\n\nXLA is an optimizing compiler, used by both TensorFlow and JAX. In JAX it is the only compiler, whereas in TensorFlow it is optional (but mandatory on TPU!). The easiest way to enable it when training a Keras model is to pass the argument `jit_compile=True` to `model.compile()`. If you don\u2019t get any errors and performance is good, that\u2019s a great sign that you\u2019re ready to move to TPU!\n\nDebugging on TPU is generally a bit harder than on CPU/GPU, so we recommend getting your code running on CPU/GPU with XLA first before trying it on TPU. You don\u2019t have to train for long, of course - just for a few steps to make sure that your model and data pipeline are working like you expect them to.\n\n<Tip>\n\nXLA compiled code is usually faster - so even if you\u2019re not planning to run on TPU, adding `jit_compile=True` can improve your performance. Be sure to note the caveats below about XLA compatibility, though!\n\n</Tip>\n\n<Tip warning={true}>\n\n**Tip born of painful experience:** Although using `jit_compile=True` is a good way to get a speed boost and test if your CPU/GPU code is XLA-compatible, it can actually cause a lot of problems if you leave it in when actually training on TPU. XLA compilation will happen implicitly on TPU, so remember to remove that line before actually running your code on a TPU!\n\n</Tip>\n\n### How do I make my model XLA compatible?\n\nIn many cases, your code is probably XLA-compatible already! However, there are a few things that work in normal TensorFlow that don\u2019t work in XLA. We\u2019ve distilled them into three core rules below:\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** We\u2019ve put a lot of effort into rewriting our TensorFlow models and loss functions to be XLA-compatible. Our models and loss functions generally obey rule #1 and #2 by default, so you can skip over them if you\u2019re using `transformers` models. Don\u2019t forget about these rules when writing your own models and loss functions, though!\n\n</Tip>\n\n#### XLA Rule #1: Your code cannot have \u201cdata-dependent conditionals\u201d\n\nWhat that means is that any `if` statement cannot depend on values inside a `tf.Tensor`. For example, this code block cannot be compiled with XLA!\n\n```python\nif tf.reduce_sum(tensor) > 10:\n    tensor = tensor / 2.0\n```\n\nThis might seem very restrictive at first, but most neural net code doesn\u2019t need to do this."
            },
            {
                "score": 0.6657733777410227,
                "node_text": "Here are some facts extracted from the provided text:\n\nTpu -> Is used -> For training\nXla -> Is mandatory on -> Tpu\nTpu -> Accessed through -> Google's cloud services\nTpu -> Is -> Tensor processing unit\nTpu -> Used for -> Neural networks\nTpu -> Exists in -> Pods\n\nThis is a really useful trick, so remember it if you need to convert your own code to XLA!\n\n#### XLA Rule #3: XLA will need to recompile your model for every different input shape it sees\n\nThis is the big one. What this means is that if your input shapes are very variable, XLA will have to recompile your model over and over, which will create huge performance problems. This commonly arises in NLP models, where input texts have variable lengths after tokenization. In other modalities, static shapes are more common and this rule is much less of a problem.\n\nHow can you get around rule #3? The key is **padding** - if you pad all your inputs to the same length, and then use an `attention_mask`, you can get the same results as you\u2019d get from variable shapes, but without any XLA issues. However, excessive padding can cause severe slowdown too - if you pad all your samples to the maximum length in the whole dataset, you might end up with batches consisting endless padding tokens, which will waste a lot of compute and memory!\n\nThere isn\u2019t a perfect solution to this problem. However, you can try some tricks. One very useful trick is to **pad batches of samples up to a multiple of a number like 32 or 64 tokens.** This often only increases the number of tokens by a small amount, but it hugely reduces the number of unique input shapes, because every input shape now has to be a multiple of 32 or 64. Fewer unique input shapes means fewer XLA compilations!\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** Our tokenizers and data collators have methods that can help you here. You can use `padding=\"max_length\"` or `padding=\"longest\"` when calling tokenizers to get them to output padded data. Our tokenizers and data collators also have a `pad_to_multiple_of` argument that you can use to reduce the number of unique input shapes you see!\n\n</Tip>\n\n### How do I actually train my model on TPU?\n\nOnce your training is XLA-compatible and (if you\u2019re using TPU Node / Colab) your dataset has been prepared appropriately, running on TPU is surprisingly easy! All you really need to change in your code is to add a few lines to initialize your TPU, and to ensure that your model and dataset are created inside a `TPUStrategy` scope. Take a look at [our TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) to see this in action!\n\n### Summary\n\nThere was a lot in here, so let\u2019s summarize with a quick checklist you can follow when you want to get your model ready for TPU training:\n\n- Make sure your code follows the three rules of XLA\n- Compile your model with `jit_compile=True` on CPU/GPU and confirm that you can train it with XLA\n- Either load your dataset into memory or use a TPU-compatible dataset loading approach (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Migrate your code either to Colab (with accelerator set to \u201cTPU\u201d) or a TPU VM on Google Cloud\n- Add TPU initializer code (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Create your `TPUStrategy` and make sure dataset loading and model creation are inside the `strategy.scope()` (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Don\u2019t forget to take `jit_compile=True` out again when you move to TPU!\n- \ud83d\ude4f\ud83d\ude4f\ud83d\ude4f\ud83e\udd7a\ud83e\udd7a\ud83e\udd7a\n- Call model.fit()\n- You did it!"
            },
            {
                "score": 0.6657733777410227,
                "node_text": "Here are some facts extracted from the provided text:\n\nGoogle -> Designed -> Tpu\n\n!--Copyright 2023 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\nthe License. You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under the License is distributed on\nan \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n\n\u26a0\ufe0f Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be\nrendered properly in your Markdown viewer.\n\n-->\n\n# Training on TPU with TensorFlow\n\n<Tip>\n\nIf you don't need long explanations and just want TPU code samples to get started with, check out [our TPU example notebook!](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb)\n\n</Tip>\n\n### What is a TPU?\n\nA TPU is a **Tensor Processing Unit.** They are hardware designed by Google, which are used to greatly speed up the tensor computations within neural networks, much like GPUs. They can be used for both network training and inference. They are generally accessed through Google\u2019s cloud services, but small TPUs can also be accessed directly for free through Google Colab and Kaggle Kernels.\n\nBecause [all TensorFlow models in \ud83e\udd17 Transformers are Keras models](https://huggingface.co/blog/tensorflow-philosophy), most of the methods in this document are generally applicable to TPU training for any Keras model! However, there are a few points that are specific to the HuggingFace ecosystem (hug-o-system?) of Transformers and Datasets, and we\u2019ll make sure to flag them up when we get to them.\n\n### What kinds of TPU are available?\n\nNew users are often very confused by the range of TPUs, and the different ways to access them. The first key distinction to understand is the difference between **TPU Nodes** and **TPU VMs.**\n\nWhen you use a **TPU Node**, you are effectively indirectly accessing a remote TPU. You will need a separate VM, which will initialize your network and data pipeline and then forward them to the remote node. When you use a TPU on Google Colab, you are accessing it in the **TPU Node** style.\n\nUsing TPU Nodes can have some quite unexpected behaviour for people who aren\u2019t used to them! In particular, because the TPU is located on a physically different system to the machine you\u2019re running your Python code on, your data cannot be local to your machine - any data pipeline that loads from your machine\u2019s internal storage will totally fail! Instead, data must be stored in Google Cloud Storage where your data pipeline can still access it, even when the pipeline is running on the remote TPU node.\n\n<Tip>\n\nIf you can fit all your data in memory as `np.ndarray` or `tf.Tensor`, then you can `fit()` on that data even when using Colab or a TPU Node, without needing to upload it to Google Cloud Storage.\n\n</Tip>\n\n<Tip>\n\n**\ud83e\udd17Specific Hugging Face Tip\ud83e\udd17:** The methods `Dataset.to_tf_dataset()` and its higher-level wrapper `model.prepare_tf_dataset()` , which you will see throughout our TF code examples, will both fail on a TPU Node. The reason for this is that even though they create a `tf.data.Dataset` it is not a \u201cpure\u201d `tf.data` pipeline and uses `tf.numpy_function` or `Dataset.from_generator()` to stream data from the underlying HuggingFace `Dataset`. This HuggingFace `Dataset` is backed by data that is on a local disc and which the remote TPU Node will not be able to read.\n\n</Tip>\n\nThe second way to access a TPU is via a **TPU VM.** When using a TPU VM, you connect directly to the machine that the TPU is attached to, much like training on a GPU VM. TPU VMs are generally easier to work with, particularly when it comes to your data pipeline. All of the above warnings do not apply to TPU VMs!\n\nThis is an opinionated document, so here\u2019s our opinion: **Avoid using TPU Node if possible.** It is more confusing and more difficult to debug than TPU VMs. It is also likely to be unsupported in future - Google\u2019s latest TPU, TPUv4, can only be accessed as a TPU VM, which suggests that TPU Nodes are increasingly going to become a \u201clegacy\u201d access method."
            }
        ]
    },
    {
        "sample_idx": 84,
        "question": "What is the minimum value of the 'Random Slider (Input 1)' in the Gradio demo?",
        "answer": "The minimum value is 100.",
        "rag_answer": "The minimum value of the 'Random Slider (Input 1)' in the Gradio demo is 100.",
        "rag_score": 5,
        "rag_feedback": "The system's response is completely correct, accurate, and factual. It correctly states the minimum value of the 'Random Slider (Input 1)' in the Gradio demo as 100, which matches the expected answer.",
        "rag_context": [
            {
                "score": 1.0,
                "node_text": "Here are some facts extracted from the provided text:\n\nBlocks -> Is -> Demo\n\nBlocks() as demo\uff1a\n    #.\ndemo.queue()\ndemo.launch()\n```\n\n\u60a8\u53ef\u4ee5\u901a\u8fc7\u4ee5\u4e0b\u65b9\u5f0f\u63a7\u5236\u4e00\u6b21\u5904\u7406\u7684\u8bf7\u6c42\u6570\u91cf\uff1a\n\n```python\ndemo.queue(concurrency_count=3)\n```\n\n\u67e5\u770b\u6709\u5173\u914d\u7f6e\u5176\u4ed6\u961f\u5217\u53c2\u6570\u7684[\u961f\u5217\u6587\u6863](/docs/#queue)\u3002\n\n\u5728 Blocks \u4e2d\u6307\u5b9a\u4ec5\u5bf9\u67d0\u4e9b\u51fd\u6570\u8fdb\u884c\u6392\u961f\uff1a\n\n```python\nwith gr.Blocks() as demo2\uff1a\n    num1 = gr.Number()\n    num2 = gr.Number()\n    output = gr.Number()\n    gr.Button(\"Add\").click(\n        lambda a, b: a + b, [num1, num2], output)\n    gr.Button(\"Multiply\").click(\n        lambda a, b: a * b, [num1, num2], output, queue=True)\ndemo2.launch()\n```\n\n## \u8fed\u4ee3\u8f93\u51fa (Iterative Outputs)\n\n\u5728\u67d0\u4e9b\u60c5\u51b5\u4e0b\uff0c\u60a8\u53ef\u80fd\u9700\u8981\u4f20\u8f93\u4e00\u7cfb\u5217\u8f93\u51fa\u800c\u4e0d\u662f\u4e00\u6b21\u663e\u793a\u5355\u4e2a\u8f93\u51fa\u3002\u4f8b\u5982\uff0c\u60a8\u53ef\u80fd\u6709\u4e00\u4e2a\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5e0c\u671b\u663e\u793a\u751f\u6210\u7684\u6bcf\u4e2a\u6b65\u9aa4\u7684\u56fe\u50cf\uff0c\u76f4\u5230\u6700\u7ec8\u56fe\u50cf\u3002\u6216\u8005\u60a8\u53ef\u80fd\u6709\u4e00\u4e2a\u804a\u5929\u673a\u5668\u4eba\uff0c\u5b83\u9010\u5b57\u9010\u53e5\u5730\u6d41\u5f0f\u4f20\u8f93\u54cd\u5e94\uff0c\u800c\u4e0d\u662f\u4e00\u6b21\u8fd4\u56de\u5168\u90e8\u54cd\u5e94\u3002\n\n\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u60a8\u53ef\u4ee5\u5c06**\u751f\u6210\u5668**\u51fd\u6570\u63d0\u4f9b\u7ed9 Gradio\uff0c\u800c\u4e0d\u662f\u5e38\u89c4\u51fd\u6570\u3002\u5728 Python \u4e2d\u521b\u5efa\u751f\u6210\u5668\u975e\u5e38\u7b80\u5355\uff1a\u51fd\u6570\u4e0d\u5e94\u8be5\u6709\u4e00\u4e2a\u5355\u72ec\u7684 `return` \u503c\uff0c\u800c\u662f\u5e94\u8be5 with `yield` \u8fde\u7eed\u8fd4\u56de\u4e00\u7cfb\u5217\u503c\u3002\u901a\u5e38\uff0c`yield` \u8bed\u53e5\u653e\u7f6e\u5728\u67d0\u79cd\u5faa\u73af\u4e2d\u3002\u4e0b\u9762\u662f\u4e00\u4e2a\u7b80\u5355\u793a\u4f8b\uff0c\u751f\u6210\u5668\u53ea\u662f\u7b80\u5355\u8ba1\u6570\u5230\u7ed9\u5b9a\u6570\u5b57\uff1a\n\n```python\ndef my_generator(x):\n    for i in range(x):\n        yield i\n```\n\n\u60a8\u4ee5\u4e0e\u5e38\u89c4\u51fd\u6570\u76f8\u540c\u7684\u65b9\u5f0f\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio\u3002\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\uff08\u865a\u62df\u7684\uff09\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5b83\u5728\u8f93\u51fa\u56fe\u50cf\u4e4b\u524d\u751f\u6210\u6570\u4e2a\u6b65\u9aa4\u7684\u566a\u97f3\uff1a\n\n$code_fake_diffusion\n$demo_fake_diffusion\n\n\u8bf7\u6ce8\u610f\uff0c\u6211\u4eec\u5728\u8fed\u4ee3\u5668\u4e2d\u6dfb\u52a0\u4e86 `time.sleep(1)`\uff0c\u4ee5\u521b\u5efa\u6b65\u9aa4\u4e4b\u95f4\u7684\u4eba\u5de5\u6682\u505c\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u89c2\u5bdf\u8fed\u4ee3\u5668\u7684\u6b65\u9aa4\uff08\u5728\u771f\u5b9e\u7684\u56fe\u50cf\u751f\u6210\u6a21\u578b\u4e2d\uff0c\u8fd9\u53ef\u80fd\u662f\u4e0d\u5fc5\u8981\u7684\uff09\u3002\n\n\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio **\u9700\u8981**\u5728\u5e95\u5c42 Interface \u6216 Blocks \u4e2d\u542f\u7528\u961f\u5217\uff08\u8bf7\u53c2\u9605\u4e0a\u9762\u7684\u961f\u5217\u90e8\u5206\uff09\u3002\n\n## \u8fdb\u5ea6\u6761\n\nGradio \u652f\u6301\u521b\u5efa\u81ea\u5b9a\u4e49\u8fdb\u5ea6\u6761\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u81ea\u5b9a\u4e49\u548c\u63a7\u5236\u5411\u7528\u6237\u663e\u793a\u7684\u8fdb\u5ea6\u66f4\u65b0\u3002\u8981\u542f\u7528\u6b64\u529f\u80fd\uff0c\u53ea\u9700\u4e3a\u65b9\u6cd5\u6dfb\u52a0\u4e00\u4e2a\u9ed8\u8ba4\u503c\u4e3a `gr.Progress` \u5b9e\u4f8b\u7684\u53c2\u6570\u5373\u53ef\u3002\u7136\u540e\uff0c\u60a8\u53ef\u4ee5\u76f4\u63a5\u8c03\u7528\u6b64\u5b9e\u4f8b\u5e76\u4f20\u5165 0 \u5230 1 \u4e4b\u95f4\u7684\u6d6e\u70b9\u6570\u6765\u66f4\u65b0\u8fdb\u5ea6\u7ea7\u522b\uff0c\u6216\u8005 with `Progress` \u5b9e\u4f8b\u7684 `tqdm()` \u65b9\u6cd5\u6765\u8ddf\u8e2a\u53ef\u8fed\u4ee3\u5bf9\u8c61\u4e0a\u7684\u8fdb\u5ea6\uff0c\u5982\u4e0b\u6240\u793a\u3002\u5fc5\u987b\u542f\u7528\u961f\u5217\u4ee5\u8fdb\u884c\u8fdb\u5ea6\u66f4\u65b0\u3002\n\n$code_progress_simple\n$demo_progress_simple\n\n\u5982\u679c\u60a8 with `tqdm` \u5e93\uff0c\u5e76\u4e14\u5e0c\u671b\u4ece\u51fd\u6570\u5185\u90e8\u7684\u4efb\u4f55 `tqdm.tqdm` \u81ea\u52a8\u62a5\u544a\u8fdb\u5ea6\u66f4\u65b0\uff0c\u8bf7\u5c06\u9ed8\u8ba4\u53c2\u6570\u8bbe\u7f6e\u4e3a `gr.Progress(track_tqdm=True)`\uff01\n\n## \u6279\u5904\u7406\u51fd\u6570 (Batch Functions)\n\nGradio \u652f\u6301\u4f20\u9012*\u6279\u5904\u7406*\u51fd\u6570\u3002\u6279\u5904\u7406\u51fd\u6570\u53ea\u662f\u63a5\u53d7\u8f93\u5165\u5217\u8868\u5e76\u8fd4\u56de\u9884\u6d4b\u5217\u8868\u7684\u51fd\u6570\u3002\n\n\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\u6279\u5904\u7406\u51fd\u6570\uff0c\u5b83\u63a5\u53d7\u4e24\u4e2a\u8f93\u5165\u5217\u8868\uff08\u4e00\u4e2a\u5355\u8bcd\u5217\u8868\u548c\u4e00\u4e2a\u6574\u6570\u5217\u8868\uff09\uff0c\u5e76\u8fd4\u56de\u4fee\u526a\u8fc7\u7684\u5355\u8bcd\u5217\u8868\u4f5c\u4e3a\u8f93\u51fa\uff1a\n\n```python\nimport time\n\ndef trim_words(words, lens):\n    trimmed_words = []\n    time.sleep(5)\n    for w, l in zip(words, lens):\n        trimmed_words.append(w[:int(l)])\n    return [trimmed_words]\n    for w, l in zip(words,"
            },
            {
                "score": 1.0,
                "node_text": "Here are some facts extracted from the provided text:\n\nSlider -> Has -> Minimum -10.2\nSlider -> Has -> Maximum 15\nSlider -> Is -> Gr.slider\nDemo -> Has method -> Queue\nDemo -> Is -> Instance of gr.blocks\nDemo -> Has method -> Launch\n\nGradio Demo: blocks_random_slider\n\n\n```\n!pip install -q gradio \n```\n\n\n```\n\nimport gradio as gr\n\n\ndef func(slider_1, slider_2):\n    return slider_1 * 5 + slider_2\n\n\nwith gr.Blocks() as demo:\n    slider = gr.Slider(minimum=-10.2, maximum=15, label=\"Random Slider (Static)\", randomize=True)\n    slider_1 = gr.Slider(minimum=100, maximum=200, label=\"Random Slider (Input 1)\", randomize=True)\n    slider_2 = gr.Slider(minimum=10, maximum=23.2, label=\"Random Slider (Input 2)\", randomize=True)\n    slider_3 = gr.Slider(value=3, label=\"Non random slider\")\n    btn = gr.Button(\"Run\")\n    btn.click(func, inputs=[slider_1, slider_2], outputs=gr.Number())\n\nif __name__ == \"__main__\":\n    demo.launch()\n\n```"
            },
            {
                "score": 0.6637803743528509,
                "node_text": "Here are some facts extracted from the provided text:\n\nGradio -> Provides -> Pre-built themes\nGradio -> Is -> Library\nGradio -> Supports -> Iterative outputs\nGradio -> Has feature -> \u6dfb\u52a0\u63cf\u8ff0\u5185\u5bb9\nGradio -> Converts -> Data format\nGradio -> Has feature -> \u8fdb\u5ea6\u6761\nGradio -> Automatically handles -> Preprocessing\nGradio -> Has feature -> \u8bbe\u7f6e\u65d7\u6807\nGradio -> Has feature -> \u8fed\u4ee3\u8f93\u51fa\nGradio -> Has feature -> \u9884\u5904\u7406\u548c\u540e\u5904\u7406\nGradio -> Installed by -> Pip\nGradio -> Has feature -> \u6392\u961f\u7528\u6237\nGradio -> Recognizes -> Data format\nGradio -> Automatically handles -> Postprocessing\nGradio -> Supports -> Hugging face models\nGradio -> Supports -> Batch functions\nGradio -> Enables -> Parallel processing\nGradio -> Has feature -> \u6279\u5904\u7406\u51fd\u6570\nGradio -> Has feature -> \u4f20\u9012\u81ea\u5b9a\u4e49\u9519\u8bef\u6d88\u606f\nGradio -> Can run -> In colab notebooks\nGradio -> Supports -> Progress bars\nGradio -> Includes -> Components\nGradio -> Has feature -> \u6837\u5f0f\u5316\u6f14\u793a\nGradio -> Has feature -> \u6dfb\u52a0\u793a\u4f8b\u8f93\u5165\nGr -> Is -> Alias of gradio\nSlider -> Has -> Minimum -10.2\nSlider -> Has -> Maximum 15\nSlider -> Is -> Gr.slider\n\nGradio Demo: blocks_random_slider\n\n\n```\n!pip install -q gradio \n```\n\n\n```\n\nimport gradio as gr\n\n\ndef func(slider_1, slider_2):\n    return slider_1 * 5 + slider_2\n\n\nwith gr.Blocks() as demo:\n    slider = gr.Slider(minimum=-10.2, maximum=15, label=\"Random Slider (Static)\", randomize=True)\n    slider_1 = gr.Slider(minimum=100, maximum=200, label=\"Random Slider (Input 1)\", randomize=True)\n    slider_2 = gr.Slider(minimum=10, maximum=23.2, label=\"Random Slider (Input 2)\", randomize=True)\n    slider_3 = gr.Slider(value=3, label=\"Non random slider\")\n    btn = gr.Button(\"Run\")\n    btn.click(func, inputs=[slider_1, slider_2], outputs=gr.Number())\n\nif __name__ == \"__main__\":\n    demo.launch()\n\n```"
            },
            {
                "score": 0.6571242637429061,
                "node_text": "Here are some facts extracted from the provided text:\n\nGenerator function -> Is -> Provided to gradio\n\nBlocks() as demo\uff1a\n    #.\ndemo.queue()\ndemo.launch()\n```\n\n\u60a8\u53ef\u4ee5\u901a\u8fc7\u4ee5\u4e0b\u65b9\u5f0f\u63a7\u5236\u4e00\u6b21\u5904\u7406\u7684\u8bf7\u6c42\u6570\u91cf\uff1a\n\n```python\ndemo.queue(concurrency_count=3)\n```\n\n\u67e5\u770b\u6709\u5173\u914d\u7f6e\u5176\u4ed6\u961f\u5217\u53c2\u6570\u7684[\u961f\u5217\u6587\u6863](/docs/#queue)\u3002\n\n\u5728 Blocks \u4e2d\u6307\u5b9a\u4ec5\u5bf9\u67d0\u4e9b\u51fd\u6570\u8fdb\u884c\u6392\u961f\uff1a\n\n```python\nwith gr.Blocks() as demo2\uff1a\n    num1 = gr.Number()\n    num2 = gr.Number()\n    output = gr.Number()\n    gr.Button(\"Add\").click(\n        lambda a, b: a + b, [num1, num2], output)\n    gr.Button(\"Multiply\").click(\n        lambda a, b: a * b, [num1, num2], output, queue=True)\ndemo2.launch()\n```\n\n## \u8fed\u4ee3\u8f93\u51fa (Iterative Outputs)\n\n\u5728\u67d0\u4e9b\u60c5\u51b5\u4e0b\uff0c\u60a8\u53ef\u80fd\u9700\u8981\u4f20\u8f93\u4e00\u7cfb\u5217\u8f93\u51fa\u800c\u4e0d\u662f\u4e00\u6b21\u663e\u793a\u5355\u4e2a\u8f93\u51fa\u3002\u4f8b\u5982\uff0c\u60a8\u53ef\u80fd\u6709\u4e00\u4e2a\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5e0c\u671b\u663e\u793a\u751f\u6210\u7684\u6bcf\u4e2a\u6b65\u9aa4\u7684\u56fe\u50cf\uff0c\u76f4\u5230\u6700\u7ec8\u56fe\u50cf\u3002\u6216\u8005\u60a8\u53ef\u80fd\u6709\u4e00\u4e2a\u804a\u5929\u673a\u5668\u4eba\uff0c\u5b83\u9010\u5b57\u9010\u53e5\u5730\u6d41\u5f0f\u4f20\u8f93\u54cd\u5e94\uff0c\u800c\u4e0d\u662f\u4e00\u6b21\u8fd4\u56de\u5168\u90e8\u54cd\u5e94\u3002\n\n\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u60a8\u53ef\u4ee5\u5c06**\u751f\u6210\u5668**\u51fd\u6570\u63d0\u4f9b\u7ed9 Gradio\uff0c\u800c\u4e0d\u662f\u5e38\u89c4\u51fd\u6570\u3002\u5728 Python \u4e2d\u521b\u5efa\u751f\u6210\u5668\u975e\u5e38\u7b80\u5355\uff1a\u51fd\u6570\u4e0d\u5e94\u8be5\u6709\u4e00\u4e2a\u5355\u72ec\u7684 `return` \u503c\uff0c\u800c\u662f\u5e94\u8be5 with `yield` \u8fde\u7eed\u8fd4\u56de\u4e00\u7cfb\u5217\u503c\u3002\u901a\u5e38\uff0c`yield` \u8bed\u53e5\u653e\u7f6e\u5728\u67d0\u79cd\u5faa\u73af\u4e2d\u3002\u4e0b\u9762\u662f\u4e00\u4e2a\u7b80\u5355\u793a\u4f8b\uff0c\u751f\u6210\u5668\u53ea\u662f\u7b80\u5355\u8ba1\u6570\u5230\u7ed9\u5b9a\u6570\u5b57\uff1a\n\n```python\ndef my_generator(x):\n    for i in range(x):\n        yield i\n```\n\n\u60a8\u4ee5\u4e0e\u5e38\u89c4\u51fd\u6570\u76f8\u540c\u7684\u65b9\u5f0f\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio\u3002\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\uff08\u865a\u62df\u7684\uff09\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5b83\u5728\u8f93\u51fa\u56fe\u50cf\u4e4b\u524d\u751f\u6210\u6570\u4e2a\u6b65\u9aa4\u7684\u566a\u97f3\uff1a\n\n$code_fake_diffusion\n$demo_fake_diffusion\n\n\u8bf7\u6ce8\u610f\uff0c\u6211\u4eec\u5728\u8fed\u4ee3\u5668\u4e2d\u6dfb\u52a0\u4e86 `time.sleep(1)`\uff0c\u4ee5\u521b\u5efa\u6b65\u9aa4\u4e4b\u95f4\u7684\u4eba\u5de5\u6682\u505c\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u89c2\u5bdf\u8fed\u4ee3\u5668\u7684\u6b65\u9aa4\uff08\u5728\u771f\u5b9e\u7684\u56fe\u50cf\u751f\u6210\u6a21\u578b\u4e2d\uff0c\u8fd9\u53ef\u80fd\u662f\u4e0d\u5fc5\u8981\u7684\uff09\u3002\n\n\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio **\u9700\u8981**\u5728\u5e95\u5c42 Interface \u6216 Blocks \u4e2d\u542f\u7528\u961f\u5217\uff08\u8bf7\u53c2\u9605\u4e0a\u9762\u7684\u961f\u5217\u90e8\u5206\uff09\u3002\n\n## \u8fdb\u5ea6\u6761\n\nGradio \u652f\u6301\u521b\u5efa\u81ea\u5b9a\u4e49\u8fdb\u5ea6\u6761\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u81ea\u5b9a\u4e49\u548c\u63a7\u5236\u5411\u7528\u6237\u663e\u793a\u7684\u8fdb\u5ea6\u66f4\u65b0\u3002\u8981\u542f\u7528\u6b64\u529f\u80fd\uff0c\u53ea\u9700\u4e3a\u65b9\u6cd5\u6dfb\u52a0\u4e00\u4e2a\u9ed8\u8ba4\u503c\u4e3a `gr.Progress` \u5b9e\u4f8b\u7684\u53c2\u6570\u5373\u53ef\u3002\u7136\u540e\uff0c\u60a8\u53ef\u4ee5\u76f4\u63a5\u8c03\u7528\u6b64\u5b9e\u4f8b\u5e76\u4f20\u5165 0 \u5230 1 \u4e4b\u95f4\u7684\u6d6e\u70b9\u6570\u6765\u66f4\u65b0\u8fdb\u5ea6\u7ea7\u522b\uff0c\u6216\u8005 with `Progress` \u5b9e\u4f8b\u7684 `tqdm()` \u65b9\u6cd5\u6765\u8ddf\u8e2a\u53ef\u8fed\u4ee3\u5bf9\u8c61\u4e0a\u7684\u8fdb\u5ea6\uff0c\u5982\u4e0b\u6240\u793a\u3002\u5fc5\u987b\u542f\u7528\u961f\u5217\u4ee5\u8fdb\u884c\u8fdb\u5ea6\u66f4\u65b0\u3002\n\n$code_progress_simple\n$demo_progress_simple\n\n\u5982\u679c\u60a8 with `tqdm` \u5e93\uff0c\u5e76\u4e14\u5e0c\u671b\u4ece\u51fd\u6570\u5185\u90e8\u7684\u4efb\u4f55 `tqdm.tqdm` \u81ea\u52a8\u62a5\u544a\u8fdb\u5ea6\u66f4\u65b0\uff0c\u8bf7\u5c06\u9ed8\u8ba4\u53c2\u6570\u8bbe\u7f6e\u4e3a `gr.Progress(track_tqdm=True)`\uff01\n\n## \u6279\u5904\u7406\u51fd\u6570 (Batch Functions)\n\nGradio \u652f\u6301\u4f20\u9012*\u6279\u5904\u7406*\u51fd\u6570\u3002\u6279\u5904\u7406\u51fd\u6570\u53ea\u662f\u63a5\u53d7\u8f93\u5165\u5217\u8868\u5e76\u8fd4\u56de\u9884\u6d4b\u5217\u8868\u7684\u51fd\u6570\u3002\n\n\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\u6279\u5904\u7406\u51fd\u6570\uff0c\u5b83\u63a5\u53d7\u4e24\u4e2a\u8f93\u5165\u5217\u8868\uff08\u4e00\u4e2a\u5355\u8bcd\u5217\u8868\u548c\u4e00\u4e2a\u6574\u6570\u5217\u8868\uff09\uff0c\u5e76\u8fd4\u56de\u4fee\u526a\u8fc7\u7684\u5355\u8bcd\u5217\u8868\u4f5c\u4e3a\u8f93\u51fa\uff1a\n\n```python\nimport time\n\ndef trim_words(words, lens):\n    trimmed_words = []\n    time.sleep(5)\n    for w, l in zip(words, lens):\n        trimmed_words.append(w[:int(l)])\n    return [trimmed_words]\n    for w, l in zip(words,"
            }
        ]
    },
    {
        "sample_idx": 85,
        "question": "What is the maximum value of the 'Random Slider (Static)' in the Gradio demo?",
        "answer": "The maximum value is 15.",
        "rag_answer": "The maximum value of the 'Random Slider (Static)' in the Gradio demo is 15.",
        "rag_score": 5,
        "rag_feedback": "The system's response is completely correct, accurate, and factual. It directly answers the question by stating the maximum value of the 'Random Slider (Static)' in the Gradio demo, which is 15.",
        "rag_context": [
            {
                "score": 1.0,
                "node_text": "Here are some facts extracted from the provided text:\n\nSlider -> Has -> Minimum -10.2\nSlider -> Has -> Maximum 15\nSlider -> Is -> Gr.slider\n\nGradio Demo: blocks_random_slider\n\n\n```\n!pip install -q gradio \n```\n\n\n```\n\nimport gradio as gr\n\n\ndef func(slider_1, slider_2):\n    return slider_1 * 5 + slider_2\n\n\nwith gr.Blocks() as demo:\n    slider = gr.Slider(minimum=-10.2, maximum=15, label=\"Random Slider (Static)\", randomize=True)\n    slider_1 = gr.Slider(minimum=100, maximum=200, label=\"Random Slider (Input 1)\", randomize=True)\n    slider_2 = gr.Slider(minimum=10, maximum=23.2, label=\"Random Slider (Input 2)\", randomize=True)\n    slider_3 = gr.Slider(value=3, label=\"Non random slider\")\n    btn = gr.Button(\"Run\")\n    btn.click(func, inputs=[slider_1, slider_2], outputs=gr.Number())\n\nif __name__ == \"__main__\":\n    demo.launch()\n\n```"
            },
            {
                "score": 0.656111467938368,
                "node_text": "Here are some facts extracted from the provided text:\n\nSlider -> Has -> Minimum -10.2\nSlider -> Has -> Maximum 15\nSlider -> Is -> Gr.slider\nGradio -> Provides -> Pre-built themes\nGradio -> Is -> Library\nGradio -> Supports -> Iterative outputs\nGradio -> Has feature -> \u6dfb\u52a0\u63cf\u8ff0\u5185\u5bb9\nGradio -> Converts -> Data format\nGradio -> Has feature -> \u8fdb\u5ea6\u6761\nGradio -> Automatically handles -> Preprocessing\nGradio -> Has feature -> \u8bbe\u7f6e\u65d7\u6807\nGradio -> Has feature -> \u8fed\u4ee3\u8f93\u51fa\nGradio -> Has feature -> \u9884\u5904\u7406\u548c\u540e\u5904\u7406\nGradio -> Installed by -> Pip\nGradio -> Has feature -> \u6392\u961f\u7528\u6237\nGradio -> Recognizes -> Data format\nGradio -> Automatically handles -> Postprocessing\nGradio -> Supports -> Hugging face models\nGradio -> Supports -> Batch functions\nGradio -> Enables -> Parallel processing\nGradio -> Has feature -> \u6279\u5904\u7406\u51fd\u6570\nGradio -> Has feature -> \u4f20\u9012\u81ea\u5b9a\u4e49\u9519\u8bef\u6d88\u606f\nGradio -> Can run -> In colab notebooks\nGradio -> Supports -> Progress bars\nGradio -> Includes -> Components\nGradio -> Has feature -> \u6837\u5f0f\u5316\u6f14\u793a\nGradio -> Has feature -> \u6dfb\u52a0\u793a\u4f8b\u8f93\u5165\nGr -> Is -> Alias of gradio\n\nGradio Demo: blocks_random_slider\n\n\n```\n!pip install -q gradio \n```\n\n\n```\n\nimport gradio as gr\n\n\ndef func(slider_1, slider_2):\n    return slider_1 * 5 + slider_2\n\n\nwith gr.Blocks() as demo:\n    slider = gr.Slider(minimum=-10.2, maximum=15, label=\"Random Slider (Static)\", randomize=True)\n    slider_1 = gr.Slider(minimum=100, maximum=200, label=\"Random Slider (Input 1)\", randomize=True)\n    slider_2 = gr.Slider(minimum=10, maximum=23.2, label=\"Random Slider (Input 2)\", randomize=True)\n    slider_3 = gr.Slider(value=3, label=\"Non random slider\")\n    btn = gr.Button(\"Run\")\n    btn.click(func, inputs=[slider_1, slider_2], outputs=gr.Number())\n\nif __name__ == \"__main__\":\n    demo.launch()\n\n```"
            },
            {
                "score": 0.6552391238746903,
                "node_text": "Here are some facts extracted from the provided text:\n\nGenerator function -> Is -> Provided to gradio\n\nBlocks() as demo\uff1a\n    #.\ndemo.queue()\ndemo.launch()\n```\n\n\u60a8\u53ef\u4ee5\u901a\u8fc7\u4ee5\u4e0b\u65b9\u5f0f\u63a7\u5236\u4e00\u6b21\u5904\u7406\u7684\u8bf7\u6c42\u6570\u91cf\uff1a\n\n```python\ndemo.queue(concurrency_count=3)\n```\n\n\u67e5\u770b\u6709\u5173\u914d\u7f6e\u5176\u4ed6\u961f\u5217\u53c2\u6570\u7684[\u961f\u5217\u6587\u6863](/docs/#queue)\u3002\n\n\u5728 Blocks \u4e2d\u6307\u5b9a\u4ec5\u5bf9\u67d0\u4e9b\u51fd\u6570\u8fdb\u884c\u6392\u961f\uff1a\n\n```python\nwith gr.Blocks() as demo2\uff1a\n    num1 = gr.Number()\n    num2 = gr.Number()\n    output = gr.Number()\n    gr.Button(\"Add\").click(\n        lambda a, b: a + b, [num1, num2], output)\n    gr.Button(\"Multiply\").click(\n        lambda a, b: a * b, [num1, num2], output, queue=True)\ndemo2.launch()\n```\n\n## \u8fed\u4ee3\u8f93\u51fa (Iterative Outputs)\n\n\u5728\u67d0\u4e9b\u60c5\u51b5\u4e0b\uff0c\u60a8\u53ef\u80fd\u9700\u8981\u4f20\u8f93\u4e00\u7cfb\u5217\u8f93\u51fa\u800c\u4e0d\u662f\u4e00\u6b21\u663e\u793a\u5355\u4e2a\u8f93\u51fa\u3002\u4f8b\u5982\uff0c\u60a8\u53ef\u80fd\u6709\u4e00\u4e2a\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5e0c\u671b\u663e\u793a\u751f\u6210\u7684\u6bcf\u4e2a\u6b65\u9aa4\u7684\u56fe\u50cf\uff0c\u76f4\u5230\u6700\u7ec8\u56fe\u50cf\u3002\u6216\u8005\u60a8\u53ef\u80fd\u6709\u4e00\u4e2a\u804a\u5929\u673a\u5668\u4eba\uff0c\u5b83\u9010\u5b57\u9010\u53e5\u5730\u6d41\u5f0f\u4f20\u8f93\u54cd\u5e94\uff0c\u800c\u4e0d\u662f\u4e00\u6b21\u8fd4\u56de\u5168\u90e8\u54cd\u5e94\u3002\n\n\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u60a8\u53ef\u4ee5\u5c06**\u751f\u6210\u5668**\u51fd\u6570\u63d0\u4f9b\u7ed9 Gradio\uff0c\u800c\u4e0d\u662f\u5e38\u89c4\u51fd\u6570\u3002\u5728 Python \u4e2d\u521b\u5efa\u751f\u6210\u5668\u975e\u5e38\u7b80\u5355\uff1a\u51fd\u6570\u4e0d\u5e94\u8be5\u6709\u4e00\u4e2a\u5355\u72ec\u7684 `return` \u503c\uff0c\u800c\u662f\u5e94\u8be5 with `yield` \u8fde\u7eed\u8fd4\u56de\u4e00\u7cfb\u5217\u503c\u3002\u901a\u5e38\uff0c`yield` \u8bed\u53e5\u653e\u7f6e\u5728\u67d0\u79cd\u5faa\u73af\u4e2d\u3002\u4e0b\u9762\u662f\u4e00\u4e2a\u7b80\u5355\u793a\u4f8b\uff0c\u751f\u6210\u5668\u53ea\u662f\u7b80\u5355\u8ba1\u6570\u5230\u7ed9\u5b9a\u6570\u5b57\uff1a\n\n```python\ndef my_generator(x):\n    for i in range(x):\n        yield i\n```\n\n\u60a8\u4ee5\u4e0e\u5e38\u89c4\u51fd\u6570\u76f8\u540c\u7684\u65b9\u5f0f\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio\u3002\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\uff08\u865a\u62df\u7684\uff09\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5b83\u5728\u8f93\u51fa\u56fe\u50cf\u4e4b\u524d\u751f\u6210\u6570\u4e2a\u6b65\u9aa4\u7684\u566a\u97f3\uff1a\n\n$code_fake_diffusion\n$demo_fake_diffusion\n\n\u8bf7\u6ce8\u610f\uff0c\u6211\u4eec\u5728\u8fed\u4ee3\u5668\u4e2d\u6dfb\u52a0\u4e86 `time.sleep(1)`\uff0c\u4ee5\u521b\u5efa\u6b65\u9aa4\u4e4b\u95f4\u7684\u4eba\u5de5\u6682\u505c\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u89c2\u5bdf\u8fed\u4ee3\u5668\u7684\u6b65\u9aa4\uff08\u5728\u771f\u5b9e\u7684\u56fe\u50cf\u751f\u6210\u6a21\u578b\u4e2d\uff0c\u8fd9\u53ef\u80fd\u662f\u4e0d\u5fc5\u8981\u7684\uff09\u3002\n\n\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio **\u9700\u8981**\u5728\u5e95\u5c42 Interface \u6216 Blocks \u4e2d\u542f\u7528\u961f\u5217\uff08\u8bf7\u53c2\u9605\u4e0a\u9762\u7684\u961f\u5217\u90e8\u5206\uff09\u3002\n\n## \u8fdb\u5ea6\u6761\n\nGradio \u652f\u6301\u521b\u5efa\u81ea\u5b9a\u4e49\u8fdb\u5ea6\u6761\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u81ea\u5b9a\u4e49\u548c\u63a7\u5236\u5411\u7528\u6237\u663e\u793a\u7684\u8fdb\u5ea6\u66f4\u65b0\u3002\u8981\u542f\u7528\u6b64\u529f\u80fd\uff0c\u53ea\u9700\u4e3a\u65b9\u6cd5\u6dfb\u52a0\u4e00\u4e2a\u9ed8\u8ba4\u503c\u4e3a `gr.Progress` \u5b9e\u4f8b\u7684\u53c2\u6570\u5373\u53ef\u3002\u7136\u540e\uff0c\u60a8\u53ef\u4ee5\u76f4\u63a5\u8c03\u7528\u6b64\u5b9e\u4f8b\u5e76\u4f20\u5165 0 \u5230 1 \u4e4b\u95f4\u7684\u6d6e\u70b9\u6570\u6765\u66f4\u65b0\u8fdb\u5ea6\u7ea7\u522b\uff0c\u6216\u8005 with `Progress` \u5b9e\u4f8b\u7684 `tqdm()` \u65b9\u6cd5\u6765\u8ddf\u8e2a\u53ef\u8fed\u4ee3\u5bf9\u8c61\u4e0a\u7684\u8fdb\u5ea6\uff0c\u5982\u4e0b\u6240\u793a\u3002\u5fc5\u987b\u542f\u7528\u961f\u5217\u4ee5\u8fdb\u884c\u8fdb\u5ea6\u66f4\u65b0\u3002\n\n$code_progress_simple\n$demo_progress_simple\n\n\u5982\u679c\u60a8 with `tqdm` \u5e93\uff0c\u5e76\u4e14\u5e0c\u671b\u4ece\u51fd\u6570\u5185\u90e8\u7684\u4efb\u4f55 `tqdm.tqdm` \u81ea\u52a8\u62a5\u544a\u8fdb\u5ea6\u66f4\u65b0\uff0c\u8bf7\u5c06\u9ed8\u8ba4\u53c2\u6570\u8bbe\u7f6e\u4e3a `gr.Progress(track_tqdm=True)`\uff01\n\n## \u6279\u5904\u7406\u51fd\u6570 (Batch Functions)\n\nGradio \u652f\u6301\u4f20\u9012*\u6279\u5904\u7406*\u51fd\u6570\u3002\u6279\u5904\u7406\u51fd\u6570\u53ea\u662f\u63a5\u53d7\u8f93\u5165\u5217\u8868\u5e76\u8fd4\u56de\u9884\u6d4b\u5217\u8868\u7684\u51fd\u6570\u3002\n\n\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\u6279\u5904\u7406\u51fd\u6570\uff0c\u5b83\u63a5\u53d7\u4e24\u4e2a\u8f93\u5165\u5217\u8868\uff08\u4e00\u4e2a\u5355\u8bcd\u5217\u8868\u548c\u4e00\u4e2a\u6574\u6570\u5217\u8868\uff09\uff0c\u5e76\u8fd4\u56de\u4fee\u526a\u8fc7\u7684\u5355\u8bcd\u5217\u8868\u4f5c\u4e3a\u8f93\u51fa\uff1a\n\n```python\nimport time\n\ndef trim_words(words, lens):\n    trimmed_words = []\n    time.sleep(5)\n    for w, l in zip(words, lens):\n        trimmed_words.append(w[:int(l)])\n    return [trimmed_words]\n    for w, l in zip(words,"
            }
        ]
    },
    {
        "sample_idx": 86,
        "question": "What is the label of the non-random slider in the Gradio demo?",
        "answer": "The label is 'Non random slider'.",
        "rag_answer": "The label of the non-random slider in the Gradio demo is \"Non random slider\".",
        "rag_score": 5,
        "rag_feedback": "The response is completely correct, accurate, and factual. It directly answers the question by stating the label of the non-random slider in the Gradio demo, which is 'Non random slider'.",
        "rag_context": [
            {
                "score": 1.0,
                "node_text": "Here are some facts extracted from the provided text:\n\nComponent -> Has -> Label\nInterface -> Has -> Flagging_options\nComponent -> Has -> Info\nInterface -> Has -> Flag button\n\n[annotated](/assets/guides/annotated.png)\n\n\u5982\u679c\u60a8\u4f7f\u7528\u7684\u662f `Blocks` API\uff0c\u5219\u53ef\u4ee5 with `gr.Markdown(...)` \u6216 `gr.HTML(...)` \u7ec4\u4ef6\u5728\u4efb\u4f55\u4f4d\u7f6e\u63d2\u5165\u6587\u672c\u3001Markdown \u6216 HTML\uff0c\u5176\u4e2d\u63cf\u8ff0\u6027\u5185\u5bb9\u4f4d\u4e8e `Component` \u6784\u9020\u51fd\u6570\u5185\u90e8\u3002\n\n\u53e6\u4e00\u4e2a\u6709\u7528\u7684\u5173\u952e\u5b57\u53c2\u6570\u662f `label=`\uff0c\u5b83\u5b58\u5728\u4e8e\u6bcf\u4e2a `Component` \u4e2d\u3002\u8fd9\u4fee\u6539\u4e86\u6bcf\u4e2a `Component` \u9876\u90e8\u7684\u6807\u7b7e\u6587\u672c\u3002\u8fd8\u53ef\u4ee5\u4e3a\u8bf8\u5982 `Textbox` \u6216 `Radio` \u4e4b\u7c7b\u7684\u8868\u5355\u5143\u7d20\u6dfb\u52a0 `info=` \u5173\u952e\u5b57\u53c2\u6570\uff0c\u4ee5\u63d0\u4f9b\u6709\u5173\u5176\u7528\u6cd5\u7684\u8fdb\u4e00\u6b65\u4fe1\u606f\u3002\n\n```python\ngr.Number(label='\u5e74\u9f84', info='\u4ee5\u5e74\u4e3a\u5355\u4f4d\uff0c\u5fc5\u987b\u5927\u4e8e0')\n```\n\n## \u65d7\u6807\n\n\u9ed8\u8ba4\u60c5\u51b5\u4e0b\uff0c\"Interface\" \u5c06\u6709\u4e00\u4e2a \"Flag\" \u6309\u94ae\u3002\u5f53\u7528\u6237\u6d4b\u8bd5\u60a8\u7684 `Interface` \u65f6\uff0c\u5982\u679c\u770b\u5230\u6709\u8da3\u7684\u8f93\u51fa\uff0c\u4f8b\u5982\u9519\u8bef\u6216\u610f\u5916\u7684\u6a21\u578b\u884c\u4e3a\uff0c\u4ed6\u4eec\u53ef\u4ee5\u5c06\u8f93\u5165\u6807\u8bb0\u4e3a\u60a8\u8fdb\u884c\u67e5\u770b\u3002\u5728\u7531 `Interface` \u6784\u9020\u51fd\u6570\u7684 `flagging_dir=` \u53c2\u6570\u63d0\u4f9b\u7684\u76ee\u5f55\u4e2d\uff0c\u5c06\u8bb0\u5f55\u6807\u8bb0\u7684\u8f93\u5165\u5230\u4e00\u4e2a CSV \u6587\u4ef6\u4e2d\u3002\u5982\u679c\u754c\u9762\u6d89\u53ca\u6587\u4ef6\u6570\u636e\uff0c\u4f8b\u5982\u56fe\u50cf\u548c\u97f3\u9891\u7ec4\u4ef6\uff0c\u5c06\u521b\u5efa\u6587\u4ef6\u5939\u6765\u5b58\u50a8\u8fd9\u4e9b\u6807\u8bb0\u7684\u6570\u636e\u3002\n\n\u4f8b\u5982\uff0c\u5bf9\u4e8e\u4e0a\u9762\u663e\u793a\u7684\u8ba1\u7b97\u5668\u754c\u9762\uff0c\u6211\u4eec\u5c06\u5728\u4e0b\u9762\u7684\u65d7\u6807\u76ee\u5f55\u4e2d\u5b58\u50a8\u6807\u8bb0\u7684\u6570\u636e\uff1a\n\n```directory\n+-- calculator.py\n+-- flagged/\n|   +-- logs.csv\n```\n\n_flagged/logs.csv_\n\n```csv\nnum1,operation,num2,Output\n5,add,7,12\n6,subtract,1.5,4.5\n```\n\n\u4e0e\u65e9\u671f\u663e\u793a\u7684\u51b7\u8272\u754c\u9762\u76f8\u5bf9\u5e94\uff0c\u6211\u4eec\u5c06\u5728\u4e0b\u9762\u7684\u65d7\u6807\u76ee\u5f55\u4e2d\u5b58\u50a8\u6807\u8bb0\u7684\u6570\u636e\uff1a\n\n```directory\n+-- sepia.py\n+-- flagged/\n|   +-- logs.csv\n|   +-- im/\n|   |   +-- 0.png\n|   |   +-- 1.png\n|   +-- Output/\n|   |   +-- 0.png\n|   |   +-- 1.png\n```\n\n_flagged/logs.csv_\n\n```csv\nim,Output\nim/0.png,Output/0.png\nim/1.png,Output/1.png\n```\n\n\u5982\u679c\u60a8\u5e0c\u671b\u7528\u6237\u63d0\u4f9b\u65d7\u6807\u539f\u56e0\uff0c\u53ef\u4ee5\u5c06\u5b57\u7b26\u4e32\u5217\u8868\u4f20\u9012\u7ed9 Interface \u7684 `flagging_options` \u53c2\u6570\u3002\u7528\u6237\u5728\u8fdb\u884c\u65d7\u6807\u65f6\u5fc5\u987b\u9009\u62e9\u5176\u4e2d\u4e00\u4e2a\u5b57\u7b26\u4e32\uff0c\u8fd9\u5c06\u4f5c\u4e3a\u9644\u52a0\u5217\u4fdd\u5b58\u5230 CSV \u4e2d\u3002\n\n## \u9884\u5904\u7406\u548c\u540e\u5904\u7406 (Preprocessing and Postprocessing)\n\n!"
            },
            {
                "score": 1.0,
                "node_text": "Here are some facts extracted from the provided text:\n\nBlocks -> Is -> Demo\n\nBlocks() as demo\uff1a\n    #.\ndemo.queue()\ndemo.launch()\n```\n\n\u60a8\u53ef\u4ee5\u901a\u8fc7\u4ee5\u4e0b\u65b9\u5f0f\u63a7\u5236\u4e00\u6b21\u5904\u7406\u7684\u8bf7\u6c42\u6570\u91cf\uff1a\n\n```python\ndemo.queue(concurrency_count=3)\n```\n\n\u67e5\u770b\u6709\u5173\u914d\u7f6e\u5176\u4ed6\u961f\u5217\u53c2\u6570\u7684[\u961f\u5217\u6587\u6863](/docs/#queue)\u3002\n\n\u5728 Blocks \u4e2d\u6307\u5b9a\u4ec5\u5bf9\u67d0\u4e9b\u51fd\u6570\u8fdb\u884c\u6392\u961f\uff1a\n\n```python\nwith gr.Blocks() as demo2\uff1a\n    num1 = gr.Number()\n    num2 = gr.Number()\n    output = gr.Number()\n    gr.Button(\"Add\").click(\n        lambda a, b: a + b, [num1, num2], output)\n    gr.Button(\"Multiply\").click(\n        lambda a, b: a * b, [num1, num2], output, queue=True)\ndemo2.launch()\n```\n\n## \u8fed\u4ee3\u8f93\u51fa (Iterative Outputs)\n\n\u5728\u67d0\u4e9b\u60c5\u51b5\u4e0b\uff0c\u60a8\u53ef\u80fd\u9700\u8981\u4f20\u8f93\u4e00\u7cfb\u5217\u8f93\u51fa\u800c\u4e0d\u662f\u4e00\u6b21\u663e\u793a\u5355\u4e2a\u8f93\u51fa\u3002\u4f8b\u5982\uff0c\u60a8\u53ef\u80fd\u6709\u4e00\u4e2a\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5e0c\u671b\u663e\u793a\u751f\u6210\u7684\u6bcf\u4e2a\u6b65\u9aa4\u7684\u56fe\u50cf\uff0c\u76f4\u5230\u6700\u7ec8\u56fe\u50cf\u3002\u6216\u8005\u60a8\u53ef\u80fd\u6709\u4e00\u4e2a\u804a\u5929\u673a\u5668\u4eba\uff0c\u5b83\u9010\u5b57\u9010\u53e5\u5730\u6d41\u5f0f\u4f20\u8f93\u54cd\u5e94\uff0c\u800c\u4e0d\u662f\u4e00\u6b21\u8fd4\u56de\u5168\u90e8\u54cd\u5e94\u3002\n\n\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u60a8\u53ef\u4ee5\u5c06**\u751f\u6210\u5668**\u51fd\u6570\u63d0\u4f9b\u7ed9 Gradio\uff0c\u800c\u4e0d\u662f\u5e38\u89c4\u51fd\u6570\u3002\u5728 Python \u4e2d\u521b\u5efa\u751f\u6210\u5668\u975e\u5e38\u7b80\u5355\uff1a\u51fd\u6570\u4e0d\u5e94\u8be5\u6709\u4e00\u4e2a\u5355\u72ec\u7684 `return` \u503c\uff0c\u800c\u662f\u5e94\u8be5 with `yield` \u8fde\u7eed\u8fd4\u56de\u4e00\u7cfb\u5217\u503c\u3002\u901a\u5e38\uff0c`yield` \u8bed\u53e5\u653e\u7f6e\u5728\u67d0\u79cd\u5faa\u73af\u4e2d\u3002\u4e0b\u9762\u662f\u4e00\u4e2a\u7b80\u5355\u793a\u4f8b\uff0c\u751f\u6210\u5668\u53ea\u662f\u7b80\u5355\u8ba1\u6570\u5230\u7ed9\u5b9a\u6570\u5b57\uff1a\n\n```python\ndef my_generator(x):\n    for i in range(x):\n        yield i\n```\n\n\u60a8\u4ee5\u4e0e\u5e38\u89c4\u51fd\u6570\u76f8\u540c\u7684\u65b9\u5f0f\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio\u3002\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\uff08\u865a\u62df\u7684\uff09\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5b83\u5728\u8f93\u51fa\u56fe\u50cf\u4e4b\u524d\u751f\u6210\u6570\u4e2a\u6b65\u9aa4\u7684\u566a\u97f3\uff1a\n\n$code_fake_diffusion\n$demo_fake_diffusion\n\n\u8bf7\u6ce8\u610f\uff0c\u6211\u4eec\u5728\u8fed\u4ee3\u5668\u4e2d\u6dfb\u52a0\u4e86 `time.sleep(1)`\uff0c\u4ee5\u521b\u5efa\u6b65\u9aa4\u4e4b\u95f4\u7684\u4eba\u5de5\u6682\u505c\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u89c2\u5bdf\u8fed\u4ee3\u5668\u7684\u6b65\u9aa4\uff08\u5728\u771f\u5b9e\u7684\u56fe\u50cf\u751f\u6210\u6a21\u578b\u4e2d\uff0c\u8fd9\u53ef\u80fd\u662f\u4e0d\u5fc5\u8981\u7684\uff09\u3002\n\n\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio **\u9700\u8981**\u5728\u5e95\u5c42 Interface \u6216 Blocks \u4e2d\u542f\u7528\u961f\u5217\uff08\u8bf7\u53c2\u9605\u4e0a\u9762\u7684\u961f\u5217\u90e8\u5206\uff09\u3002\n\n## \u8fdb\u5ea6\u6761\n\nGradio \u652f\u6301\u521b\u5efa\u81ea\u5b9a\u4e49\u8fdb\u5ea6\u6761\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u81ea\u5b9a\u4e49\u548c\u63a7\u5236\u5411\u7528\u6237\u663e\u793a\u7684\u8fdb\u5ea6\u66f4\u65b0\u3002\u8981\u542f\u7528\u6b64\u529f\u80fd\uff0c\u53ea\u9700\u4e3a\u65b9\u6cd5\u6dfb\u52a0\u4e00\u4e2a\u9ed8\u8ba4\u503c\u4e3a `gr.Progress` \u5b9e\u4f8b\u7684\u53c2\u6570\u5373\u53ef\u3002\u7136\u540e\uff0c\u60a8\u53ef\u4ee5\u76f4\u63a5\u8c03\u7528\u6b64\u5b9e\u4f8b\u5e76\u4f20\u5165 0 \u5230 1 \u4e4b\u95f4\u7684\u6d6e\u70b9\u6570\u6765\u66f4\u65b0\u8fdb\u5ea6\u7ea7\u522b\uff0c\u6216\u8005 with `Progress` \u5b9e\u4f8b\u7684 `tqdm()` \u65b9\u6cd5\u6765\u8ddf\u8e2a\u53ef\u8fed\u4ee3\u5bf9\u8c61\u4e0a\u7684\u8fdb\u5ea6\uff0c\u5982\u4e0b\u6240\u793a\u3002\u5fc5\u987b\u542f\u7528\u961f\u5217\u4ee5\u8fdb\u884c\u8fdb\u5ea6\u66f4\u65b0\u3002\n\n$code_progress_simple\n$demo_progress_simple\n\n\u5982\u679c\u60a8 with `tqdm` \u5e93\uff0c\u5e76\u4e14\u5e0c\u671b\u4ece\u51fd\u6570\u5185\u90e8\u7684\u4efb\u4f55 `tqdm.tqdm` \u81ea\u52a8\u62a5\u544a\u8fdb\u5ea6\u66f4\u65b0\uff0c\u8bf7\u5c06\u9ed8\u8ba4\u53c2\u6570\u8bbe\u7f6e\u4e3a `gr.Progress(track_tqdm=True)`\uff01\n\n## \u6279\u5904\u7406\u51fd\u6570 (Batch Functions)\n\nGradio \u652f\u6301\u4f20\u9012*\u6279\u5904\u7406*\u51fd\u6570\u3002\u6279\u5904\u7406\u51fd\u6570\u53ea\u662f\u63a5\u53d7\u8f93\u5165\u5217\u8868\u5e76\u8fd4\u56de\u9884\u6d4b\u5217\u8868\u7684\u51fd\u6570\u3002\n\n\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\u6279\u5904\u7406\u51fd\u6570\uff0c\u5b83\u63a5\u53d7\u4e24\u4e2a\u8f93\u5165\u5217\u8868\uff08\u4e00\u4e2a\u5355\u8bcd\u5217\u8868\u548c\u4e00\u4e2a\u6574\u6570\u5217\u8868\uff09\uff0c\u5e76\u8fd4\u56de\u4fee\u526a\u8fc7\u7684\u5355\u8bcd\u5217\u8868\u4f5c\u4e3a\u8f93\u51fa\uff1a\n\n```python\nimport time\n\ndef trim_words(words, lens):\n    trimmed_words = []\n    time.sleep(5)\n    for w, l in zip(words, lens):\n        trimmed_words.append(w[:int(l)])\n    return [trimmed_words]\n    for w, l in zip(words,"
            },
            {
                "score": 1.0,
                "node_text": "Here are some facts extracted from the provided text:\n\nSlider -> Has -> Minimum -10.2\nSlider -> Has -> Maximum 15\nSlider -> Is -> Gr.slider\nDemo -> Has method -> Queue\nDemo -> Is -> Instance of gr.blocks\nDemo -> Has method -> Launch\n\nGradio Demo: blocks_random_slider\n\n\n```\n!pip install -q gradio \n```\n\n\n```\n\nimport gradio as gr\n\n\ndef func(slider_1, slider_2):\n    return slider_1 * 5 + slider_2\n\n\nwith gr.Blocks() as demo:\n    slider = gr.Slider(minimum=-10.2, maximum=15, label=\"Random Slider (Static)\", randomize=True)\n    slider_1 = gr.Slider(minimum=100, maximum=200, label=\"Random Slider (Input 1)\", randomize=True)\n    slider_2 = gr.Slider(minimum=10, maximum=23.2, label=\"Random Slider (Input 2)\", randomize=True)\n    slider_3 = gr.Slider(value=3, label=\"Non random slider\")\n    btn = gr.Button(\"Run\")\n    btn.click(func, inputs=[slider_1, slider_2], outputs=gr.Number())\n\nif __name__ == \"__main__\":\n    demo.launch()\n\n```"
            },
            {
                "score": 0.7132085208354901,
                "node_text": "Here are some facts extracted from the provided text:\n\nGr -> Is -> Alias of gradio\nGradio -> Provides -> Pre-built themes\nGradio -> Is -> Library\nGradio -> Supports -> Iterative outputs\nGradio -> Has feature -> \u6dfb\u52a0\u63cf\u8ff0\u5185\u5bb9\nGradio -> Converts -> Data format\nGradio -> Has feature -> \u8fdb\u5ea6\u6761\nGradio -> Automatically handles -> Preprocessing\nGradio -> Has feature -> \u8bbe\u7f6e\u65d7\u6807\nGradio -> Has feature -> \u8fed\u4ee3\u8f93\u51fa\nGradio -> Has feature -> \u9884\u5904\u7406\u548c\u540e\u5904\u7406\nGradio -> Installed by -> Pip\nGradio -> Has feature -> \u6392\u961f\u7528\u6237\nGradio -> Recognizes -> Data format\nGradio -> Automatically handles -> Postprocessing\nGradio -> Supports -> Hugging face models\nGradio -> Supports -> Batch functions\nGradio -> Enables -> Parallel processing\nGradio -> Has feature -> \u6279\u5904\u7406\u51fd\u6570\nGradio -> Has feature -> \u4f20\u9012\u81ea\u5b9a\u4e49\u9519\u8bef\u6d88\u606f\nGradio -> Can run -> In colab notebooks\nGradio -> Supports -> Progress bars\nGradio -> Includes -> Components\nGradio -> Has feature -> \u6837\u5f0f\u5316\u6f14\u793a\nGradio -> Has feature -> \u6dfb\u52a0\u793a\u4f8b\u8f93\u5165\nSlider -> Is -> Gr.slider\n\nGradio Demo: blocks_random_slider\n\n\n```\n!pip install -q gradio \n```\n\n\n```\n\nimport gradio as gr\n\n\ndef func(slider_1, slider_2):\n    return slider_1 * 5 + slider_2\n\n\nwith gr.Blocks() as demo:\n    slider = gr.Slider(minimum=-10.2, maximum=15, label=\"Random Slider (Static)\", randomize=True)\n    slider_1 = gr.Slider(minimum=100, maximum=200, label=\"Random Slider (Input 1)\", randomize=True)\n    slider_2 = gr.Slider(minimum=10, maximum=23.2, label=\"Random Slider (Input 2)\", randomize=True)\n    slider_3 = gr.Slider(value=3, label=\"Non random slider\")\n    btn = gr.Button(\"Run\")\n    btn.click(func, inputs=[slider_1, slider_2], outputs=gr.Number())\n\nif __name__ == \"__main__\":\n    demo.launch()\n\n```"
            },
            {
                "score": 0.6891545182274696,
                "node_text": "Here are some facts extracted from the provided text:\n\nGenerator function -> Is -> Provided to gradio\n\nBlocks() as demo\uff1a\n    #.\ndemo.queue()\ndemo.launch()\n```\n\n\u60a8\u53ef\u4ee5\u901a\u8fc7\u4ee5\u4e0b\u65b9\u5f0f\u63a7\u5236\u4e00\u6b21\u5904\u7406\u7684\u8bf7\u6c42\u6570\u91cf\uff1a\n\n```python\ndemo.queue(concurrency_count=3)\n```\n\n\u67e5\u770b\u6709\u5173\u914d\u7f6e\u5176\u4ed6\u961f\u5217\u53c2\u6570\u7684[\u961f\u5217\u6587\u6863](/docs/#queue)\u3002\n\n\u5728 Blocks \u4e2d\u6307\u5b9a\u4ec5\u5bf9\u67d0\u4e9b\u51fd\u6570\u8fdb\u884c\u6392\u961f\uff1a\n\n```python\nwith gr.Blocks() as demo2\uff1a\n    num1 = gr.Number()\n    num2 = gr.Number()\n    output = gr.Number()\n    gr.Button(\"Add\").click(\n        lambda a, b: a + b, [num1, num2], output)\n    gr.Button(\"Multiply\").click(\n        lambda a, b: a * b, [num1, num2], output, queue=True)\ndemo2.launch()\n```\n\n## \u8fed\u4ee3\u8f93\u51fa (Iterative Outputs)\n\n\u5728\u67d0\u4e9b\u60c5\u51b5\u4e0b\uff0c\u60a8\u53ef\u80fd\u9700\u8981\u4f20\u8f93\u4e00\u7cfb\u5217\u8f93\u51fa\u800c\u4e0d\u662f\u4e00\u6b21\u663e\u793a\u5355\u4e2a\u8f93\u51fa\u3002\u4f8b\u5982\uff0c\u60a8\u53ef\u80fd\u6709\u4e00\u4e2a\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5e0c\u671b\u663e\u793a\u751f\u6210\u7684\u6bcf\u4e2a\u6b65\u9aa4\u7684\u56fe\u50cf\uff0c\u76f4\u5230\u6700\u7ec8\u56fe\u50cf\u3002\u6216\u8005\u60a8\u53ef\u80fd\u6709\u4e00\u4e2a\u804a\u5929\u673a\u5668\u4eba\uff0c\u5b83\u9010\u5b57\u9010\u53e5\u5730\u6d41\u5f0f\u4f20\u8f93\u54cd\u5e94\uff0c\u800c\u4e0d\u662f\u4e00\u6b21\u8fd4\u56de\u5168\u90e8\u54cd\u5e94\u3002\n\n\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u60a8\u53ef\u4ee5\u5c06**\u751f\u6210\u5668**\u51fd\u6570\u63d0\u4f9b\u7ed9 Gradio\uff0c\u800c\u4e0d\u662f\u5e38\u89c4\u51fd\u6570\u3002\u5728 Python \u4e2d\u521b\u5efa\u751f\u6210\u5668\u975e\u5e38\u7b80\u5355\uff1a\u51fd\u6570\u4e0d\u5e94\u8be5\u6709\u4e00\u4e2a\u5355\u72ec\u7684 `return` \u503c\uff0c\u800c\u662f\u5e94\u8be5 with `yield` \u8fde\u7eed\u8fd4\u56de\u4e00\u7cfb\u5217\u503c\u3002\u901a\u5e38\uff0c`yield` \u8bed\u53e5\u653e\u7f6e\u5728\u67d0\u79cd\u5faa\u73af\u4e2d\u3002\u4e0b\u9762\u662f\u4e00\u4e2a\u7b80\u5355\u793a\u4f8b\uff0c\u751f\u6210\u5668\u53ea\u662f\u7b80\u5355\u8ba1\u6570\u5230\u7ed9\u5b9a\u6570\u5b57\uff1a\n\n```python\ndef my_generator(x):\n    for i in range(x):\n        yield i\n```\n\n\u60a8\u4ee5\u4e0e\u5e38\u89c4\u51fd\u6570\u76f8\u540c\u7684\u65b9\u5f0f\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio\u3002\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\uff08\u865a\u62df\u7684\uff09\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5b83\u5728\u8f93\u51fa\u56fe\u50cf\u4e4b\u524d\u751f\u6210\u6570\u4e2a\u6b65\u9aa4\u7684\u566a\u97f3\uff1a\n\n$code_fake_diffusion\n$demo_fake_diffusion\n\n\u8bf7\u6ce8\u610f\uff0c\u6211\u4eec\u5728\u8fed\u4ee3\u5668\u4e2d\u6dfb\u52a0\u4e86 `time.sleep(1)`\uff0c\u4ee5\u521b\u5efa\u6b65\u9aa4\u4e4b\u95f4\u7684\u4eba\u5de5\u6682\u505c\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u89c2\u5bdf\u8fed\u4ee3\u5668\u7684\u6b65\u9aa4\uff08\u5728\u771f\u5b9e\u7684\u56fe\u50cf\u751f\u6210\u6a21\u578b\u4e2d\uff0c\u8fd9\u53ef\u80fd\u662f\u4e0d\u5fc5\u8981\u7684\uff09\u3002\n\n\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio **\u9700\u8981**\u5728\u5e95\u5c42 Interface \u6216 Blocks \u4e2d\u542f\u7528\u961f\u5217\uff08\u8bf7\u53c2\u9605\u4e0a\u9762\u7684\u961f\u5217\u90e8\u5206\uff09\u3002\n\n## \u8fdb\u5ea6\u6761\n\nGradio \u652f\u6301\u521b\u5efa\u81ea\u5b9a\u4e49\u8fdb\u5ea6\u6761\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u81ea\u5b9a\u4e49\u548c\u63a7\u5236\u5411\u7528\u6237\u663e\u793a\u7684\u8fdb\u5ea6\u66f4\u65b0\u3002\u8981\u542f\u7528\u6b64\u529f\u80fd\uff0c\u53ea\u9700\u4e3a\u65b9\u6cd5\u6dfb\u52a0\u4e00\u4e2a\u9ed8\u8ba4\u503c\u4e3a `gr.Progress` \u5b9e\u4f8b\u7684\u53c2\u6570\u5373\u53ef\u3002\u7136\u540e\uff0c\u60a8\u53ef\u4ee5\u76f4\u63a5\u8c03\u7528\u6b64\u5b9e\u4f8b\u5e76\u4f20\u5165 0 \u5230 1 \u4e4b\u95f4\u7684\u6d6e\u70b9\u6570\u6765\u66f4\u65b0\u8fdb\u5ea6\u7ea7\u522b\uff0c\u6216\u8005 with `Progress` \u5b9e\u4f8b\u7684 `tqdm()` \u65b9\u6cd5\u6765\u8ddf\u8e2a\u53ef\u8fed\u4ee3\u5bf9\u8c61\u4e0a\u7684\u8fdb\u5ea6\uff0c\u5982\u4e0b\u6240\u793a\u3002\u5fc5\u987b\u542f\u7528\u961f\u5217\u4ee5\u8fdb\u884c\u8fdb\u5ea6\u66f4\u65b0\u3002\n\n$code_progress_simple\n$demo_progress_simple\n\n\u5982\u679c\u60a8 with `tqdm` \u5e93\uff0c\u5e76\u4e14\u5e0c\u671b\u4ece\u51fd\u6570\u5185\u90e8\u7684\u4efb\u4f55 `tqdm.tqdm` \u81ea\u52a8\u62a5\u544a\u8fdb\u5ea6\u66f4\u65b0\uff0c\u8bf7\u5c06\u9ed8\u8ba4\u53c2\u6570\u8bbe\u7f6e\u4e3a `gr.Progress(track_tqdm=True)`\uff01\n\n## \u6279\u5904\u7406\u51fd\u6570 (Batch Functions)\n\nGradio \u652f\u6301\u4f20\u9012*\u6279\u5904\u7406*\u51fd\u6570\u3002\u6279\u5904\u7406\u51fd\u6570\u53ea\u662f\u63a5\u53d7\u8f93\u5165\u5217\u8868\u5e76\u8fd4\u56de\u9884\u6d4b\u5217\u8868\u7684\u51fd\u6570\u3002\n\n\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\u6279\u5904\u7406\u51fd\u6570\uff0c\u5b83\u63a5\u53d7\u4e24\u4e2a\u8f93\u5165\u5217\u8868\uff08\u4e00\u4e2a\u5355\u8bcd\u5217\u8868\u548c\u4e00\u4e2a\u6574\u6570\u5217\u8868\uff09\uff0c\u5e76\u8fd4\u56de\u4fee\u526a\u8fc7\u7684\u5355\u8bcd\u5217\u8868\u4f5c\u4e3a\u8f93\u51fa\uff1a\n\n```python\nimport time\n\ndef trim_words(words, lens):\n    trimmed_words = []\n    time.sleep(5)\n    for w, l in zip(words, lens):\n        trimmed_words.append(w[:int(l)])\n    return [trimmed_words]\n    for w, l in zip(words,"
            }
        ]
    },
    {
        "sample_idx": 87,
        "question": "What is the default value of the 'Non random slider' in the Gradio demo?",
        "answer": "The default value is 3.",
        "rag_answer": "The default value of the 'Non random slider' in the Gradio demo is 3.",
        "rag_score": 5,
        "rag_feedback": "The system's response is completely correct, accurate, and factual. It directly answers the question by stating that the default value of the 'Non random slider' in the Gradio demo is 3, which is supported by the provided code snippet.",
        "rag_context": [
            {
                "score": 1.0,
                "node_text": "Here are some facts extracted from the provided text:\n\nState object -> Has -> Default value\n\nState in Blocks\n\nWe covered [State in Interfaces](https://gradio.app/interface-state), this guide takes a look at state in Blocks, which works mostly the same.\n\n## Global State\n\nGlobal state in Blocks works the same as in Interface. Any variable created outside a function call is a reference shared between all users.\n\n## Session State\n\nGradio supports session **state**, where data persists across multiple submits within a page session, in Blocks apps as well. To reiterate, session data is _not_ shared between different users of your model. To store data in a session state, you need to do three things:\n\n1. Create a `gr.State()` object. If there is a default value to this stateful object, pass that into the constructor.\n2. In the event listener, put the `State` object as an input and output.\n3. In the event listener function, add the variable to the input parameters and the return value.\n\nLet's take a look at a game of hangman.\n\n$code_hangman\n$demo_hangman\n\nLet's see how we do each of the 3 steps listed above in this game:\n\n1. We store the used letters in `used_letters_var`. In the constructor of `State`, we set the initial value of this to `[]`, an empty list.\n2. In `btn.click()`, we have a reference to `used_letters_var` in both the inputs and outputs.\n3. In `guess_letter`, we pass the value of this `State` to `used_letters`, and then return an updated value of this `State` in the return statement.\n\nWith more complex apps, you will likely have many State variables storing session state in a single Blocks app.\n\nLearn more about `State` in the [docs](https://gradio.app/docs#state)."
            },
            {
                "score": 0.68787318193673,
                "node_text": "Here are some facts extracted from the provided text:\n\nGr -> Is -> Alias of gradio\nGradio -> Provides -> Pre-built themes\nGradio -> Is -> Library\nGradio -> Supports -> Iterative outputs\nGradio -> Has feature -> \u6dfb\u52a0\u63cf\u8ff0\u5185\u5bb9\nGradio -> Converts -> Data format\nGradio -> Has feature -> \u8fdb\u5ea6\u6761\nGradio -> Automatically handles -> Preprocessing\nGradio -> Has feature -> \u8bbe\u7f6e\u65d7\u6807\nGradio -> Has feature -> \u8fed\u4ee3\u8f93\u51fa\nGradio -> Has feature -> \u9884\u5904\u7406\u548c\u540e\u5904\u7406\nGradio -> Installed by -> Pip\nGradio -> Has feature -> \u6392\u961f\u7528\u6237\nGradio -> Recognizes -> Data format\nGradio -> Automatically handles -> Postprocessing\nGradio -> Supports -> Hugging face models\nGradio -> Supports -> Batch functions\nGradio -> Enables -> Parallel processing\nGradio -> Has feature -> \u6279\u5904\u7406\u51fd\u6570\nGradio -> Has feature -> \u4f20\u9012\u81ea\u5b9a\u4e49\u9519\u8bef\u6d88\u606f\nGradio -> Can run -> In colab notebooks\nGradio -> Supports -> Progress bars\nGradio -> Includes -> Components\nGradio -> Has feature -> \u6837\u5f0f\u5316\u6f14\u793a\nGradio -> Has feature -> \u6dfb\u52a0\u793a\u4f8b\u8f93\u5165\nSlider -> Has -> Minimum -10.2\nSlider -> Has -> Maximum 15\nSlider -> Is -> Gr.slider\n\nGradio Demo: blocks_random_slider\n\n\n```\n!pip install -q gradio \n```\n\n\n```\n\nimport gradio as gr\n\n\ndef func(slider_1, slider_2):\n    return slider_1 * 5 + slider_2\n\n\nwith gr.Blocks() as demo:\n    slider = gr.Slider(minimum=-10.2, maximum=15, label=\"Random Slider (Static)\", randomize=True)\n    slider_1 = gr.Slider(minimum=100, maximum=200, label=\"Random Slider (Input 1)\", randomize=True)\n    slider_2 = gr.Slider(minimum=10, maximum=23.2, label=\"Random Slider (Input 2)\", randomize=True)\n    slider_3 = gr.Slider(value=3, label=\"Non random slider\")\n    btn = gr.Button(\"Run\")\n    btn.click(func, inputs=[slider_1, slider_2], outputs=gr.Number())\n\nif __name__ == \"__main__\":\n    demo.launch()\n\n```"
            },
            {
                "score": 0.6697819971661443,
                "node_text": "Here are some facts extracted from the provided text:\n\nGenerator function -> Is -> Provided to gradio\n\nBlocks() as demo\uff1a\n    #.\ndemo.queue()\ndemo.launch()\n```\n\n\u60a8\u53ef\u4ee5\u901a\u8fc7\u4ee5\u4e0b\u65b9\u5f0f\u63a7\u5236\u4e00\u6b21\u5904\u7406\u7684\u8bf7\u6c42\u6570\u91cf\uff1a\n\n```python\ndemo.queue(concurrency_count=3)\n```\n\n\u67e5\u770b\u6709\u5173\u914d\u7f6e\u5176\u4ed6\u961f\u5217\u53c2\u6570\u7684[\u961f\u5217\u6587\u6863](/docs/#queue)\u3002\n\n\u5728 Blocks \u4e2d\u6307\u5b9a\u4ec5\u5bf9\u67d0\u4e9b\u51fd\u6570\u8fdb\u884c\u6392\u961f\uff1a\n\n```python\nwith gr.Blocks() as demo2\uff1a\n    num1 = gr.Number()\n    num2 = gr.Number()\n    output = gr.Number()\n    gr.Button(\"Add\").click(\n        lambda a, b: a + b, [num1, num2], output)\n    gr.Button(\"Multiply\").click(\n        lambda a, b: a * b, [num1, num2], output, queue=True)\ndemo2.launch()\n```\n\n## \u8fed\u4ee3\u8f93\u51fa (Iterative Outputs)\n\n\u5728\u67d0\u4e9b\u60c5\u51b5\u4e0b\uff0c\u60a8\u53ef\u80fd\u9700\u8981\u4f20\u8f93\u4e00\u7cfb\u5217\u8f93\u51fa\u800c\u4e0d\u662f\u4e00\u6b21\u663e\u793a\u5355\u4e2a\u8f93\u51fa\u3002\u4f8b\u5982\uff0c\u60a8\u53ef\u80fd\u6709\u4e00\u4e2a\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5e0c\u671b\u663e\u793a\u751f\u6210\u7684\u6bcf\u4e2a\u6b65\u9aa4\u7684\u56fe\u50cf\uff0c\u76f4\u5230\u6700\u7ec8\u56fe\u50cf\u3002\u6216\u8005\u60a8\u53ef\u80fd\u6709\u4e00\u4e2a\u804a\u5929\u673a\u5668\u4eba\uff0c\u5b83\u9010\u5b57\u9010\u53e5\u5730\u6d41\u5f0f\u4f20\u8f93\u54cd\u5e94\uff0c\u800c\u4e0d\u662f\u4e00\u6b21\u8fd4\u56de\u5168\u90e8\u54cd\u5e94\u3002\n\n\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u60a8\u53ef\u4ee5\u5c06**\u751f\u6210\u5668**\u51fd\u6570\u63d0\u4f9b\u7ed9 Gradio\uff0c\u800c\u4e0d\u662f\u5e38\u89c4\u51fd\u6570\u3002\u5728 Python \u4e2d\u521b\u5efa\u751f\u6210\u5668\u975e\u5e38\u7b80\u5355\uff1a\u51fd\u6570\u4e0d\u5e94\u8be5\u6709\u4e00\u4e2a\u5355\u72ec\u7684 `return` \u503c\uff0c\u800c\u662f\u5e94\u8be5 with `yield` \u8fde\u7eed\u8fd4\u56de\u4e00\u7cfb\u5217\u503c\u3002\u901a\u5e38\uff0c`yield` \u8bed\u53e5\u653e\u7f6e\u5728\u67d0\u79cd\u5faa\u73af\u4e2d\u3002\u4e0b\u9762\u662f\u4e00\u4e2a\u7b80\u5355\u793a\u4f8b\uff0c\u751f\u6210\u5668\u53ea\u662f\u7b80\u5355\u8ba1\u6570\u5230\u7ed9\u5b9a\u6570\u5b57\uff1a\n\n```python\ndef my_generator(x):\n    for i in range(x):\n        yield i\n```\n\n\u60a8\u4ee5\u4e0e\u5e38\u89c4\u51fd\u6570\u76f8\u540c\u7684\u65b9\u5f0f\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio\u3002\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\uff08\u865a\u62df\u7684\uff09\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5b83\u5728\u8f93\u51fa\u56fe\u50cf\u4e4b\u524d\u751f\u6210\u6570\u4e2a\u6b65\u9aa4\u7684\u566a\u97f3\uff1a\n\n$code_fake_diffusion\n$demo_fake_diffusion\n\n\u8bf7\u6ce8\u610f\uff0c\u6211\u4eec\u5728\u8fed\u4ee3\u5668\u4e2d\u6dfb\u52a0\u4e86 `time.sleep(1)`\uff0c\u4ee5\u521b\u5efa\u6b65\u9aa4\u4e4b\u95f4\u7684\u4eba\u5de5\u6682\u505c\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u89c2\u5bdf\u8fed\u4ee3\u5668\u7684\u6b65\u9aa4\uff08\u5728\u771f\u5b9e\u7684\u56fe\u50cf\u751f\u6210\u6a21\u578b\u4e2d\uff0c\u8fd9\u53ef\u80fd\u662f\u4e0d\u5fc5\u8981\u7684\uff09\u3002\n\n\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio **\u9700\u8981**\u5728\u5e95\u5c42 Interface \u6216 Blocks \u4e2d\u542f\u7528\u961f\u5217\uff08\u8bf7\u53c2\u9605\u4e0a\u9762\u7684\u961f\u5217\u90e8\u5206\uff09\u3002\n\n## \u8fdb\u5ea6\u6761\n\nGradio \u652f\u6301\u521b\u5efa\u81ea\u5b9a\u4e49\u8fdb\u5ea6\u6761\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u81ea\u5b9a\u4e49\u548c\u63a7\u5236\u5411\u7528\u6237\u663e\u793a\u7684\u8fdb\u5ea6\u66f4\u65b0\u3002\u8981\u542f\u7528\u6b64\u529f\u80fd\uff0c\u53ea\u9700\u4e3a\u65b9\u6cd5\u6dfb\u52a0\u4e00\u4e2a\u9ed8\u8ba4\u503c\u4e3a `gr.Progress` \u5b9e\u4f8b\u7684\u53c2\u6570\u5373\u53ef\u3002\u7136\u540e\uff0c\u60a8\u53ef\u4ee5\u76f4\u63a5\u8c03\u7528\u6b64\u5b9e\u4f8b\u5e76\u4f20\u5165 0 \u5230 1 \u4e4b\u95f4\u7684\u6d6e\u70b9\u6570\u6765\u66f4\u65b0\u8fdb\u5ea6\u7ea7\u522b\uff0c\u6216\u8005 with `Progress` \u5b9e\u4f8b\u7684 `tqdm()` \u65b9\u6cd5\u6765\u8ddf\u8e2a\u53ef\u8fed\u4ee3\u5bf9\u8c61\u4e0a\u7684\u8fdb\u5ea6\uff0c\u5982\u4e0b\u6240\u793a\u3002\u5fc5\u987b\u542f\u7528\u961f\u5217\u4ee5\u8fdb\u884c\u8fdb\u5ea6\u66f4\u65b0\u3002\n\n$code_progress_simple\n$demo_progress_simple\n\n\u5982\u679c\u60a8 with `tqdm` \u5e93\uff0c\u5e76\u4e14\u5e0c\u671b\u4ece\u51fd\u6570\u5185\u90e8\u7684\u4efb\u4f55 `tqdm.tqdm` \u81ea\u52a8\u62a5\u544a\u8fdb\u5ea6\u66f4\u65b0\uff0c\u8bf7\u5c06\u9ed8\u8ba4\u53c2\u6570\u8bbe\u7f6e\u4e3a `gr.Progress(track_tqdm=True)`\uff01\n\n## \u6279\u5904\u7406\u51fd\u6570 (Batch Functions)\n\nGradio \u652f\u6301\u4f20\u9012*\u6279\u5904\u7406*\u51fd\u6570\u3002\u6279\u5904\u7406\u51fd\u6570\u53ea\u662f\u63a5\u53d7\u8f93\u5165\u5217\u8868\u5e76\u8fd4\u56de\u9884\u6d4b\u5217\u8868\u7684\u51fd\u6570\u3002\n\n\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\u6279\u5904\u7406\u51fd\u6570\uff0c\u5b83\u63a5\u53d7\u4e24\u4e2a\u8f93\u5165\u5217\u8868\uff08\u4e00\u4e2a\u5355\u8bcd\u5217\u8868\u548c\u4e00\u4e2a\u6574\u6570\u5217\u8868\uff09\uff0c\u5e76\u8fd4\u56de\u4fee\u526a\u8fc7\u7684\u5355\u8bcd\u5217\u8868\u4f5c\u4e3a\u8f93\u51fa\uff1a\n\n```python\nimport time\n\ndef trim_words(words, lens):\n    trimmed_words = []\n    time.sleep(5)\n    for w, l in zip(words, lens):\n        trimmed_words.append(w[:int(l)])\n    return [trimmed_words]\n    for w, l in zip(words,"
            }
        ]
    },
    {
        "sample_idx": 88,
        "question": "What is the maximum value of the 'Random Slider (Input 2)' in the Gradio demo?",
        "answer": "The maximum value is 23.2.",
        "rag_answer": "The maximum value of the 'Random Slider (Input 2)' in the Gradio demo is 23.2.",
        "rag_score": 5,
        "rag_feedback": "The system's response is completely correct, accurate, and factual. It directly answers the question by stating the maximum value of the 'Random Slider (Input 2)' in the Gradio demo, which is 23.2.",
        "rag_context": [
            {
                "score": 0.6574646542504724,
                "node_text": "Here are some facts extracted from the provided text:\n\nSlider -> Has -> Minimum -10.2\nSlider -> Has -> Maximum 15\nSlider -> Is -> Gr.slider\nGradio -> Provides -> Pre-built themes\nGradio -> Is -> Library\nGradio -> Supports -> Iterative outputs\nGradio -> Has feature -> \u6dfb\u52a0\u63cf\u8ff0\u5185\u5bb9\nGradio -> Converts -> Data format\nGradio -> Has feature -> \u8fdb\u5ea6\u6761\nGradio -> Automatically handles -> Preprocessing\nGradio -> Has feature -> \u8bbe\u7f6e\u65d7\u6807\nGradio -> Has feature -> \u8fed\u4ee3\u8f93\u51fa\nGradio -> Has feature -> \u9884\u5904\u7406\u548c\u540e\u5904\u7406\nGradio -> Installed by -> Pip\nGradio -> Has feature -> \u6392\u961f\u7528\u6237\nGradio -> Recognizes -> Data format\nGradio -> Automatically handles -> Postprocessing\nGradio -> Supports -> Hugging face models\nGradio -> Supports -> Batch functions\nGradio -> Enables -> Parallel processing\nGradio -> Has feature -> \u6279\u5904\u7406\u51fd\u6570\nGradio -> Has feature -> \u4f20\u9012\u81ea\u5b9a\u4e49\u9519\u8bef\u6d88\u606f\nGradio -> Can run -> In colab notebooks\nGradio -> Supports -> Progress bars\nGradio -> Includes -> Components\nGradio -> Has feature -> \u6837\u5f0f\u5316\u6f14\u793a\nGradio -> Has feature -> \u6dfb\u52a0\u793a\u4f8b\u8f93\u5165\n\nGradio Demo: blocks_random_slider\n\n\n```\n!pip install -q gradio \n```\n\n\n```\n\nimport gradio as gr\n\n\ndef func(slider_1, slider_2):\n    return slider_1 * 5 + slider_2\n\n\nwith gr.Blocks() as demo:\n    slider = gr.Slider(minimum=-10.2, maximum=15, label=\"Random Slider (Static)\", randomize=True)\n    slider_1 = gr.Slider(minimum=100, maximum=200, label=\"Random Slider (Input 1)\", randomize=True)\n    slider_2 = gr.Slider(minimum=10, maximum=23.2, label=\"Random Slider (Input 2)\", randomize=True)\n    slider_3 = gr.Slider(value=3, label=\"Non random slider\")\n    btn = gr.Button(\"Run\")\n    btn.click(func, inputs=[slider_1, slider_2], outputs=gr.Number())\n\nif __name__ == \"__main__\":\n    demo.launch()\n\n```"
            },
            {
                "score": 0.6459091443131477,
                "node_text": "Here are some facts extracted from the provided text:\n\nGenerator function -> Is -> Provided to gradio\n\nBlocks() as demo\uff1a\n    #.\ndemo.queue()\ndemo.launch()\n```\n\n\u60a8\u53ef\u4ee5\u901a\u8fc7\u4ee5\u4e0b\u65b9\u5f0f\u63a7\u5236\u4e00\u6b21\u5904\u7406\u7684\u8bf7\u6c42\u6570\u91cf\uff1a\n\n```python\ndemo.queue(concurrency_count=3)\n```\n\n\u67e5\u770b\u6709\u5173\u914d\u7f6e\u5176\u4ed6\u961f\u5217\u53c2\u6570\u7684[\u961f\u5217\u6587\u6863](/docs/#queue)\u3002\n\n\u5728 Blocks \u4e2d\u6307\u5b9a\u4ec5\u5bf9\u67d0\u4e9b\u51fd\u6570\u8fdb\u884c\u6392\u961f\uff1a\n\n```python\nwith gr.Blocks() as demo2\uff1a\n    num1 = gr.Number()\n    num2 = gr.Number()\n    output = gr.Number()\n    gr.Button(\"Add\").click(\n        lambda a, b: a + b, [num1, num2], output)\n    gr.Button(\"Multiply\").click(\n        lambda a, b: a * b, [num1, num2], output, queue=True)\ndemo2.launch()\n```\n\n## \u8fed\u4ee3\u8f93\u51fa (Iterative Outputs)\n\n\u5728\u67d0\u4e9b\u60c5\u51b5\u4e0b\uff0c\u60a8\u53ef\u80fd\u9700\u8981\u4f20\u8f93\u4e00\u7cfb\u5217\u8f93\u51fa\u800c\u4e0d\u662f\u4e00\u6b21\u663e\u793a\u5355\u4e2a\u8f93\u51fa\u3002\u4f8b\u5982\uff0c\u60a8\u53ef\u80fd\u6709\u4e00\u4e2a\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5e0c\u671b\u663e\u793a\u751f\u6210\u7684\u6bcf\u4e2a\u6b65\u9aa4\u7684\u56fe\u50cf\uff0c\u76f4\u5230\u6700\u7ec8\u56fe\u50cf\u3002\u6216\u8005\u60a8\u53ef\u80fd\u6709\u4e00\u4e2a\u804a\u5929\u673a\u5668\u4eba\uff0c\u5b83\u9010\u5b57\u9010\u53e5\u5730\u6d41\u5f0f\u4f20\u8f93\u54cd\u5e94\uff0c\u800c\u4e0d\u662f\u4e00\u6b21\u8fd4\u56de\u5168\u90e8\u54cd\u5e94\u3002\n\n\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u60a8\u53ef\u4ee5\u5c06**\u751f\u6210\u5668**\u51fd\u6570\u63d0\u4f9b\u7ed9 Gradio\uff0c\u800c\u4e0d\u662f\u5e38\u89c4\u51fd\u6570\u3002\u5728 Python \u4e2d\u521b\u5efa\u751f\u6210\u5668\u975e\u5e38\u7b80\u5355\uff1a\u51fd\u6570\u4e0d\u5e94\u8be5\u6709\u4e00\u4e2a\u5355\u72ec\u7684 `return` \u503c\uff0c\u800c\u662f\u5e94\u8be5 with `yield` \u8fde\u7eed\u8fd4\u56de\u4e00\u7cfb\u5217\u503c\u3002\u901a\u5e38\uff0c`yield` \u8bed\u53e5\u653e\u7f6e\u5728\u67d0\u79cd\u5faa\u73af\u4e2d\u3002\u4e0b\u9762\u662f\u4e00\u4e2a\u7b80\u5355\u793a\u4f8b\uff0c\u751f\u6210\u5668\u53ea\u662f\u7b80\u5355\u8ba1\u6570\u5230\u7ed9\u5b9a\u6570\u5b57\uff1a\n\n```python\ndef my_generator(x):\n    for i in range(x):\n        yield i\n```\n\n\u60a8\u4ee5\u4e0e\u5e38\u89c4\u51fd\u6570\u76f8\u540c\u7684\u65b9\u5f0f\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio\u3002\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\uff08\u865a\u62df\u7684\uff09\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5b83\u5728\u8f93\u51fa\u56fe\u50cf\u4e4b\u524d\u751f\u6210\u6570\u4e2a\u6b65\u9aa4\u7684\u566a\u97f3\uff1a\n\n$code_fake_diffusion\n$demo_fake_diffusion\n\n\u8bf7\u6ce8\u610f\uff0c\u6211\u4eec\u5728\u8fed\u4ee3\u5668\u4e2d\u6dfb\u52a0\u4e86 `time.sleep(1)`\uff0c\u4ee5\u521b\u5efa\u6b65\u9aa4\u4e4b\u95f4\u7684\u4eba\u5de5\u6682\u505c\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u89c2\u5bdf\u8fed\u4ee3\u5668\u7684\u6b65\u9aa4\uff08\u5728\u771f\u5b9e\u7684\u56fe\u50cf\u751f\u6210\u6a21\u578b\u4e2d\uff0c\u8fd9\u53ef\u80fd\u662f\u4e0d\u5fc5\u8981\u7684\uff09\u3002\n\n\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio **\u9700\u8981**\u5728\u5e95\u5c42 Interface \u6216 Blocks \u4e2d\u542f\u7528\u961f\u5217\uff08\u8bf7\u53c2\u9605\u4e0a\u9762\u7684\u961f\u5217\u90e8\u5206\uff09\u3002\n\n## \u8fdb\u5ea6\u6761\n\nGradio \u652f\u6301\u521b\u5efa\u81ea\u5b9a\u4e49\u8fdb\u5ea6\u6761\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u81ea\u5b9a\u4e49\u548c\u63a7\u5236\u5411\u7528\u6237\u663e\u793a\u7684\u8fdb\u5ea6\u66f4\u65b0\u3002\u8981\u542f\u7528\u6b64\u529f\u80fd\uff0c\u53ea\u9700\u4e3a\u65b9\u6cd5\u6dfb\u52a0\u4e00\u4e2a\u9ed8\u8ba4\u503c\u4e3a `gr.Progress` \u5b9e\u4f8b\u7684\u53c2\u6570\u5373\u53ef\u3002\u7136\u540e\uff0c\u60a8\u53ef\u4ee5\u76f4\u63a5\u8c03\u7528\u6b64\u5b9e\u4f8b\u5e76\u4f20\u5165 0 \u5230 1 \u4e4b\u95f4\u7684\u6d6e\u70b9\u6570\u6765\u66f4\u65b0\u8fdb\u5ea6\u7ea7\u522b\uff0c\u6216\u8005 with `Progress` \u5b9e\u4f8b\u7684 `tqdm()` \u65b9\u6cd5\u6765\u8ddf\u8e2a\u53ef\u8fed\u4ee3\u5bf9\u8c61\u4e0a\u7684\u8fdb\u5ea6\uff0c\u5982\u4e0b\u6240\u793a\u3002\u5fc5\u987b\u542f\u7528\u961f\u5217\u4ee5\u8fdb\u884c\u8fdb\u5ea6\u66f4\u65b0\u3002\n\n$code_progress_simple\n$demo_progress_simple\n\n\u5982\u679c\u60a8 with `tqdm` \u5e93\uff0c\u5e76\u4e14\u5e0c\u671b\u4ece\u51fd\u6570\u5185\u90e8\u7684\u4efb\u4f55 `tqdm.tqdm` \u81ea\u52a8\u62a5\u544a\u8fdb\u5ea6\u66f4\u65b0\uff0c\u8bf7\u5c06\u9ed8\u8ba4\u53c2\u6570\u8bbe\u7f6e\u4e3a `gr.Progress(track_tqdm=True)`\uff01\n\n## \u6279\u5904\u7406\u51fd\u6570 (Batch Functions)\n\nGradio \u652f\u6301\u4f20\u9012*\u6279\u5904\u7406*\u51fd\u6570\u3002\u6279\u5904\u7406\u51fd\u6570\u53ea\u662f\u63a5\u53d7\u8f93\u5165\u5217\u8868\u5e76\u8fd4\u56de\u9884\u6d4b\u5217\u8868\u7684\u51fd\u6570\u3002\n\n\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\u6279\u5904\u7406\u51fd\u6570\uff0c\u5b83\u63a5\u53d7\u4e24\u4e2a\u8f93\u5165\u5217\u8868\uff08\u4e00\u4e2a\u5355\u8bcd\u5217\u8868\u548c\u4e00\u4e2a\u6574\u6570\u5217\u8868\uff09\uff0c\u5e76\u8fd4\u56de\u4fee\u526a\u8fc7\u7684\u5355\u8bcd\u5217\u8868\u4f5c\u4e3a\u8f93\u51fa\uff1a\n\n```python\nimport time\n\ndef trim_words(words, lens):\n    trimmed_words = []\n    time.sleep(5)\n    for w, l in zip(words, lens):\n        trimmed_words.append(w[:int(l)])\n    return [trimmed_words]\n    for w, l in zip(words,"
            }
        ]
    },
    {
        "sample_idx": 89,
        "question": "What is the minimum value of the 'Random Slider (Static)' in the Gradio demo?",
        "answer": "The minimum value is -10.2.",
        "rag_answer": "The minimum value of the 'Random Slider (Static)' in the Gradio demo is -10.2.",
        "rag_score": 5,
        "rag_feedback": "The system's response is completely correct, accurate, and factual. It directly answers the question by stating the minimum value of the 'Random Slider (Static)' in the Gradio demo, which is -10.2.",
        "rag_context": [
            {
                "score": 1.0,
                "node_text": "Here are some facts extracted from the provided text:\n\nSlider -> Has -> Minimum -10.2\nSlider -> Has -> Maximum 15\nSlider -> Is -> Gr.slider\n\nGradio Demo: blocks_random_slider\n\n\n```\n!pip install -q gradio \n```\n\n\n```\n\nimport gradio as gr\n\n\ndef func(slider_1, slider_2):\n    return slider_1 * 5 + slider_2\n\n\nwith gr.Blocks() as demo:\n    slider = gr.Slider(minimum=-10.2, maximum=15, label=\"Random Slider (Static)\", randomize=True)\n    slider_1 = gr.Slider(minimum=100, maximum=200, label=\"Random Slider (Input 1)\", randomize=True)\n    slider_2 = gr.Slider(minimum=10, maximum=23.2, label=\"Random Slider (Input 2)\", randomize=True)\n    slider_3 = gr.Slider(value=3, label=\"Non random slider\")\n    btn = gr.Button(\"Run\")\n    btn.click(func, inputs=[slider_1, slider_2], outputs=gr.Number())\n\nif __name__ == \"__main__\":\n    demo.launch()\n\n```"
            },
            {
                "score": 0.6644706637627259,
                "node_text": "Here are some facts extracted from the provided text:\n\nGr -> Is -> Alias of gradio\nGradio -> Provides -> Pre-built themes\nGradio -> Is -> Library\nGradio -> Supports -> Iterative outputs\nGradio -> Has feature -> \u6dfb\u52a0\u63cf\u8ff0\u5185\u5bb9\nGradio -> Converts -> Data format\nGradio -> Has feature -> \u8fdb\u5ea6\u6761\nGradio -> Automatically handles -> Preprocessing\nGradio -> Has feature -> \u8bbe\u7f6e\u65d7\u6807\nGradio -> Has feature -> \u8fed\u4ee3\u8f93\u51fa\nGradio -> Has feature -> \u9884\u5904\u7406\u548c\u540e\u5904\u7406\nGradio -> Installed by -> Pip\nGradio -> Has feature -> \u6392\u961f\u7528\u6237\nGradio -> Recognizes -> Data format\nGradio -> Automatically handles -> Postprocessing\nGradio -> Supports -> Hugging face models\nGradio -> Supports -> Batch functions\nGradio -> Enables -> Parallel processing\nGradio -> Has feature -> \u6279\u5904\u7406\u51fd\u6570\nGradio -> Has feature -> \u4f20\u9012\u81ea\u5b9a\u4e49\u9519\u8bef\u6d88\u606f\nGradio -> Can run -> In colab notebooks\nGradio -> Supports -> Progress bars\nGradio -> Includes -> Components\nGradio -> Has feature -> \u6837\u5f0f\u5316\u6f14\u793a\nGradio -> Has feature -> \u6dfb\u52a0\u793a\u4f8b\u8f93\u5165\nSlider -> Has -> Minimum -10.2\nSlider -> Has -> Maximum 15\nSlider -> Is -> Gr.slider\n\nGradio Demo: blocks_random_slider\n\n\n```\n!pip install -q gradio \n```\n\n\n```\n\nimport gradio as gr\n\n\ndef func(slider_1, slider_2):\n    return slider_1 * 5 + slider_2\n\n\nwith gr.Blocks() as demo:\n    slider = gr.Slider(minimum=-10.2, maximum=15, label=\"Random Slider (Static)\", randomize=True)\n    slider_1 = gr.Slider(minimum=100, maximum=200, label=\"Random Slider (Input 1)\", randomize=True)\n    slider_2 = gr.Slider(minimum=10, maximum=23.2, label=\"Random Slider (Input 2)\", randomize=True)\n    slider_3 = gr.Slider(value=3, label=\"Non random slider\")\n    btn = gr.Button(\"Run\")\n    btn.click(func, inputs=[slider_1, slider_2], outputs=gr.Number())\n\nif __name__ == \"__main__\":\n    demo.launch()\n\n```"
            },
            {
                "score": 0.6616235701348201,
                "node_text": "Here are some facts extracted from the provided text:\n\nGenerator function -> Is -> Provided to gradio\n\nBlocks() as demo\uff1a\n    #.\ndemo.queue()\ndemo.launch()\n```\n\n\u60a8\u53ef\u4ee5\u901a\u8fc7\u4ee5\u4e0b\u65b9\u5f0f\u63a7\u5236\u4e00\u6b21\u5904\u7406\u7684\u8bf7\u6c42\u6570\u91cf\uff1a\n\n```python\ndemo.queue(concurrency_count=3)\n```\n\n\u67e5\u770b\u6709\u5173\u914d\u7f6e\u5176\u4ed6\u961f\u5217\u53c2\u6570\u7684[\u961f\u5217\u6587\u6863](/docs/#queue)\u3002\n\n\u5728 Blocks \u4e2d\u6307\u5b9a\u4ec5\u5bf9\u67d0\u4e9b\u51fd\u6570\u8fdb\u884c\u6392\u961f\uff1a\n\n```python\nwith gr.Blocks() as demo2\uff1a\n    num1 = gr.Number()\n    num2 = gr.Number()\n    output = gr.Number()\n    gr.Button(\"Add\").click(\n        lambda a, b: a + b, [num1, num2], output)\n    gr.Button(\"Multiply\").click(\n        lambda a, b: a * b, [num1, num2], output, queue=True)\ndemo2.launch()\n```\n\n## \u8fed\u4ee3\u8f93\u51fa (Iterative Outputs)\n\n\u5728\u67d0\u4e9b\u60c5\u51b5\u4e0b\uff0c\u60a8\u53ef\u80fd\u9700\u8981\u4f20\u8f93\u4e00\u7cfb\u5217\u8f93\u51fa\u800c\u4e0d\u662f\u4e00\u6b21\u663e\u793a\u5355\u4e2a\u8f93\u51fa\u3002\u4f8b\u5982\uff0c\u60a8\u53ef\u80fd\u6709\u4e00\u4e2a\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5e0c\u671b\u663e\u793a\u751f\u6210\u7684\u6bcf\u4e2a\u6b65\u9aa4\u7684\u56fe\u50cf\uff0c\u76f4\u5230\u6700\u7ec8\u56fe\u50cf\u3002\u6216\u8005\u60a8\u53ef\u80fd\u6709\u4e00\u4e2a\u804a\u5929\u673a\u5668\u4eba\uff0c\u5b83\u9010\u5b57\u9010\u53e5\u5730\u6d41\u5f0f\u4f20\u8f93\u54cd\u5e94\uff0c\u800c\u4e0d\u662f\u4e00\u6b21\u8fd4\u56de\u5168\u90e8\u54cd\u5e94\u3002\n\n\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u60a8\u53ef\u4ee5\u5c06**\u751f\u6210\u5668**\u51fd\u6570\u63d0\u4f9b\u7ed9 Gradio\uff0c\u800c\u4e0d\u662f\u5e38\u89c4\u51fd\u6570\u3002\u5728 Python \u4e2d\u521b\u5efa\u751f\u6210\u5668\u975e\u5e38\u7b80\u5355\uff1a\u51fd\u6570\u4e0d\u5e94\u8be5\u6709\u4e00\u4e2a\u5355\u72ec\u7684 `return` \u503c\uff0c\u800c\u662f\u5e94\u8be5 with `yield` \u8fde\u7eed\u8fd4\u56de\u4e00\u7cfb\u5217\u503c\u3002\u901a\u5e38\uff0c`yield` \u8bed\u53e5\u653e\u7f6e\u5728\u67d0\u79cd\u5faa\u73af\u4e2d\u3002\u4e0b\u9762\u662f\u4e00\u4e2a\u7b80\u5355\u793a\u4f8b\uff0c\u751f\u6210\u5668\u53ea\u662f\u7b80\u5355\u8ba1\u6570\u5230\u7ed9\u5b9a\u6570\u5b57\uff1a\n\n```python\ndef my_generator(x):\n    for i in range(x):\n        yield i\n```\n\n\u60a8\u4ee5\u4e0e\u5e38\u89c4\u51fd\u6570\u76f8\u540c\u7684\u65b9\u5f0f\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio\u3002\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\uff08\u865a\u62df\u7684\uff09\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5b83\u5728\u8f93\u51fa\u56fe\u50cf\u4e4b\u524d\u751f\u6210\u6570\u4e2a\u6b65\u9aa4\u7684\u566a\u97f3\uff1a\n\n$code_fake_diffusion\n$demo_fake_diffusion\n\n\u8bf7\u6ce8\u610f\uff0c\u6211\u4eec\u5728\u8fed\u4ee3\u5668\u4e2d\u6dfb\u52a0\u4e86 `time.sleep(1)`\uff0c\u4ee5\u521b\u5efa\u6b65\u9aa4\u4e4b\u95f4\u7684\u4eba\u5de5\u6682\u505c\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u89c2\u5bdf\u8fed\u4ee3\u5668\u7684\u6b65\u9aa4\uff08\u5728\u771f\u5b9e\u7684\u56fe\u50cf\u751f\u6210\u6a21\u578b\u4e2d\uff0c\u8fd9\u53ef\u80fd\u662f\u4e0d\u5fc5\u8981\u7684\uff09\u3002\n\n\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio **\u9700\u8981**\u5728\u5e95\u5c42 Interface \u6216 Blocks \u4e2d\u542f\u7528\u961f\u5217\uff08\u8bf7\u53c2\u9605\u4e0a\u9762\u7684\u961f\u5217\u90e8\u5206\uff09\u3002\n\n## \u8fdb\u5ea6\u6761\n\nGradio \u652f\u6301\u521b\u5efa\u81ea\u5b9a\u4e49\u8fdb\u5ea6\u6761\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u81ea\u5b9a\u4e49\u548c\u63a7\u5236\u5411\u7528\u6237\u663e\u793a\u7684\u8fdb\u5ea6\u66f4\u65b0\u3002\u8981\u542f\u7528\u6b64\u529f\u80fd\uff0c\u53ea\u9700\u4e3a\u65b9\u6cd5\u6dfb\u52a0\u4e00\u4e2a\u9ed8\u8ba4\u503c\u4e3a `gr.Progress` \u5b9e\u4f8b\u7684\u53c2\u6570\u5373\u53ef\u3002\u7136\u540e\uff0c\u60a8\u53ef\u4ee5\u76f4\u63a5\u8c03\u7528\u6b64\u5b9e\u4f8b\u5e76\u4f20\u5165 0 \u5230 1 \u4e4b\u95f4\u7684\u6d6e\u70b9\u6570\u6765\u66f4\u65b0\u8fdb\u5ea6\u7ea7\u522b\uff0c\u6216\u8005 with `Progress` \u5b9e\u4f8b\u7684 `tqdm()` \u65b9\u6cd5\u6765\u8ddf\u8e2a\u53ef\u8fed\u4ee3\u5bf9\u8c61\u4e0a\u7684\u8fdb\u5ea6\uff0c\u5982\u4e0b\u6240\u793a\u3002\u5fc5\u987b\u542f\u7528\u961f\u5217\u4ee5\u8fdb\u884c\u8fdb\u5ea6\u66f4\u65b0\u3002\n\n$code_progress_simple\n$demo_progress_simple\n\n\u5982\u679c\u60a8 with `tqdm` \u5e93\uff0c\u5e76\u4e14\u5e0c\u671b\u4ece\u51fd\u6570\u5185\u90e8\u7684\u4efb\u4f55 `tqdm.tqdm` \u81ea\u52a8\u62a5\u544a\u8fdb\u5ea6\u66f4\u65b0\uff0c\u8bf7\u5c06\u9ed8\u8ba4\u53c2\u6570\u8bbe\u7f6e\u4e3a `gr.Progress(track_tqdm=True)`\uff01\n\n## \u6279\u5904\u7406\u51fd\u6570 (Batch Functions)\n\nGradio \u652f\u6301\u4f20\u9012*\u6279\u5904\u7406*\u51fd\u6570\u3002\u6279\u5904\u7406\u51fd\u6570\u53ea\u662f\u63a5\u53d7\u8f93\u5165\u5217\u8868\u5e76\u8fd4\u56de\u9884\u6d4b\u5217\u8868\u7684\u51fd\u6570\u3002\n\n\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\u6279\u5904\u7406\u51fd\u6570\uff0c\u5b83\u63a5\u53d7\u4e24\u4e2a\u8f93\u5165\u5217\u8868\uff08\u4e00\u4e2a\u5355\u8bcd\u5217\u8868\u548c\u4e00\u4e2a\u6574\u6570\u5217\u8868\uff09\uff0c\u5e76\u8fd4\u56de\u4fee\u526a\u8fc7\u7684\u5355\u8bcd\u5217\u8868\u4f5c\u4e3a\u8f93\u51fa\uff1a\n\n```python\nimport time\n\ndef trim_words(words, lens):\n    trimmed_words = []\n    time.sleep(5)\n    for w, l in zip(words, lens):\n        trimmed_words.append(w[:int(l)])\n    return [trimmed_words]\n    for w, l in zip(words,"
            }
        ]
    },
    {
        "sample_idx": 90,
        "question": "Where are SSH keys usually located on Mac and Linux?",
        "answer": "SSH keys are usually located under ~/.ssh on Mac & Linux.",
        "rag_answer": "SSH keys are usually located under ~/.ssh on Mac and Linux.",
        "rag_score": 5,
        "rag_feedback": "The system's response is completely correct, accurate, and factual. It exactly matches the expected answer, stating that SSH keys are usually located under ~/.ssh on Mac and Linux.",
        "rag_context": [
            {
                "score": 0.7755090632003996,
                "node_text": "Here are some facts extracted from the provided text:\n\nSsh keys -> Located under -> ~/.ssh on mac & linux\nSsh keys -> Located under -> C:\\\\users\\\\<username>\\\\.ssh on windows\nHuggingface.co account -> Manage -> Ssh keys\nSsh key -> Add to -> Huggingface.co account\n\nGit over SSH\n\nYou can access and write data in repositories on huggingface.co using SSH (Secure Shell Protocol). When you connect via SSH, you authenticate using a private key file on your local machine.\n\nSome actions, such as pushing changes, or cloning private repositories, will require you to upload your SSH public key to your account on huggingface.co.\n\nYou can use a pre-existing SSH key, or generate a new one specifically for huggingface.co.\n\n## Checking for existing SSH keys\n\nIf you have an existing SSH key, you can use that key to authenticate Git operations over SSH.\n\nSSH keys are usually located under `~/.ssh` on Mac & Linux, and under `C:\\\\Users\\\\<username>\\\\.ssh` on Windows. List files under that directory and look for files of the form:\n\n- id_rsa.pub\n- id_ecdsa.pub\n- id_ed25519.pub\n\nThose files contain your SSH public key.\n\nIf you don't have such file under `~/.ssh`, you will have to [generate a new key](#generating-a-new-ssh-keypair). Otherwise, you can [add your existing SSH public key(s) to your huggingface.co account](#add-a-ssh-key-to-your-account).\n\n## Generating a new SSH keypair\n\nIf you don't have any SSH keys on your machine, you can use `ssh-keygen` to generate a new SSH key pair (public + private keys):\n\n```\n$ ssh-keygen -t ed25519 -C \"your.email@example.co\"\n```\n\nWe recommend entering a passphrase when you are prompted to. A passphrase is an extra layer of security: it is a password that will be prompted whenever you use your SSH key.\n\nOnce your new key is generated, add it to your SSH agent with `ssh-add`:\n\n```\n$ ssh-add ~/.ssh/id_ed25519\n```\n\nIf you chose a different location than the default to store your SSH key, you would have to replace `~/.ssh/id_ed25519` with the file location you used.\n\n## Add a SSH key to your account\n\nTo access private repositories with SSH, or to push changes via SSH, you will need to add your SSH public key to your huggingface.co account. You can manage your SSH keys [in your user settings](https://huggingface.co/settings/keys).\n\nTo add a SSH key to your account, click on the \"Add SSH key\" button.\n\nThen, enter a name for this key (for example, \"Personal computer\"), and copy and paste the content of your **public** SSH key in the area below. The public key is located in the `~/.ssh/id_XXXX.pub` file you found or generated in the previous steps.\n\nClick on \"Add key\", and voil\u00e0! You have added a SSH key to your huggingface.co account.\n\n\n## Testing your SSH authentication\n\nOnce you have added your SSH key to your huggingface.co account, you can test that the connection works as expected.\n\nIn a terminal, run:\n```\n$ ssh -T git@hf.co\n```\n\nIf you see a message with your username, congrats! Everything went well, you are ready to use git over SSH.\n\nOtherwise, if the message states something like the following, make sure your SSH key is actually used by your SSH agent.\n```\nHi anonymous, welcome to Hugging Face.\n```"
            }
        ]
    },
    {
        "sample_idx": 91,
        "question": "Where are SSH keys usually located on Windows?",
        "answer": "SSH keys are usually located under C:\\Users\\<username>\\.ssh on Windows.",
        "rag_answer": "SSH keys are usually located under C:\\\\users\\\\<username>\\\\.ssh on Windows.",
        "rag_score": 5,
        "rag_feedback": "The response is completely correct, accurate, and factual. It provides the exact location of SSH keys on Windows, which is C:\\\\users\\\\<username>\\\\.ssh.",
        "rag_context": [
            {
                "score": 0.7146049788218277,
                "node_text": "Here are some facts extracted from the provided text:\n\nSsh keys -> Located under -> C:\\\\users\\\\<username>\\\\.ssh on windows\nSsh keys -> Located under -> ~/.ssh on mac & linux\nHuggingface.co account -> Manage -> Ssh keys\nSsh key -> Add to -> Huggingface.co account\n\nGit over SSH\n\nYou can access and write data in repositories on huggingface.co using SSH (Secure Shell Protocol). When you connect via SSH, you authenticate using a private key file on your local machine.\n\nSome actions, such as pushing changes, or cloning private repositories, will require you to upload your SSH public key to your account on huggingface.co.\n\nYou can use a pre-existing SSH key, or generate a new one specifically for huggingface.co.\n\n## Checking for existing SSH keys\n\nIf you have an existing SSH key, you can use that key to authenticate Git operations over SSH.\n\nSSH keys are usually located under `~/.ssh` on Mac & Linux, and under `C:\\\\Users\\\\<username>\\\\.ssh` on Windows. List files under that directory and look for files of the form:\n\n- id_rsa.pub\n- id_ecdsa.pub\n- id_ed25519.pub\n\nThose files contain your SSH public key.\n\nIf you don't have such file under `~/.ssh`, you will have to [generate a new key](#generating-a-new-ssh-keypair). Otherwise, you can [add your existing SSH public key(s) to your huggingface.co account](#add-a-ssh-key-to-your-account).\n\n## Generating a new SSH keypair\n\nIf you don't have any SSH keys on your machine, you can use `ssh-keygen` to generate a new SSH key pair (public + private keys):\n\n```\n$ ssh-keygen -t ed25519 -C \"your.email@example.co\"\n```\n\nWe recommend entering a passphrase when you are prompted to. A passphrase is an extra layer of security: it is a password that will be prompted whenever you use your SSH key.\n\nOnce your new key is generated, add it to your SSH agent with `ssh-add`:\n\n```\n$ ssh-add ~/.ssh/id_ed25519\n```\n\nIf you chose a different location than the default to store your SSH key, you would have to replace `~/.ssh/id_ed25519` with the file location you used.\n\n## Add a SSH key to your account\n\nTo access private repositories with SSH, or to push changes via SSH, you will need to add your SSH public key to your huggingface.co account. You can manage your SSH keys [in your user settings](https://huggingface.co/settings/keys).\n\nTo add a SSH key to your account, click on the \"Add SSH key\" button.\n\nThen, enter a name for this key (for example, \"Personal computer\"), and copy and paste the content of your **public** SSH key in the area below. The public key is located in the `~/.ssh/id_XXXX.pub` file you found or generated in the previous steps.\n\nClick on \"Add key\", and voil\u00e0! You have added a SSH key to your huggingface.co account.\n\n\n## Testing your SSH authentication\n\nOnce you have added your SSH key to your huggingface.co account, you can test that the connection works as expected.\n\nIn a terminal, run:\n```\n$ ssh -T git@hf.co\n```\n\nIf you see a message with your username, congrats! Everything went well, you are ready to use git over SSH.\n\nOtherwise, if the message states something like the following, make sure your SSH key is actually used by your SSH agent.\n```\nHi anonymous, welcome to Hugging Face.\n```"
            }
        ]
    },
    {
        "sample_idx": 92,
        "question": "What is the command to generate a new SSH key pair?",
        "answer": "The command to generate a new SSH key pair is ssh-keygen -t ed25519 -C \"your.email@example.co\".",
        "rag_answer": "The command to generate a new SSH key pair is `ssh-keygen -t ed25519 -C \"your.email@example.co\"`.",
        "rag_score": 5,
        "rag_feedback": "The system's response is completely correct, accurate, and factual. It provides the exact command to generate a new SSH key pair, which matches the expected answer.",
        "rag_context": [
            {
                "score": 1.0,
                "node_text": "Here are some facts extracted from the provided text:\n\nSsh-keygen -> Generate -> New ssh key pair\n\nGit over SSH\n\nYou can access and write data in repositories on huggingface.co using SSH (Secure Shell Protocol). When you connect via SSH, you authenticate using a private key file on your local machine.\n\nSome actions, such as pushing changes, or cloning private repositories, will require you to upload your SSH public key to your account on huggingface.co.\n\nYou can use a pre-existing SSH key, or generate a new one specifically for huggingface.co.\n\n## Checking for existing SSH keys\n\nIf you have an existing SSH key, you can use that key to authenticate Git operations over SSH.\n\nSSH keys are usually located under `~/.ssh` on Mac & Linux, and under `C:\\\\Users\\\\<username>\\\\.ssh` on Windows. List files under that directory and look for files of the form:\n\n- id_rsa.pub\n- id_ecdsa.pub\n- id_ed25519.pub\n\nThose files contain your SSH public key.\n\nIf you don't have such file under `~/.ssh`, you will have to [generate a new key](#generating-a-new-ssh-keypair). Otherwise, you can [add your existing SSH public key(s) to your huggingface.co account](#add-a-ssh-key-to-your-account).\n\n## Generating a new SSH keypair\n\nIf you don't have any SSH keys on your machine, you can use `ssh-keygen` to generate a new SSH key pair (public + private keys):\n\n```\n$ ssh-keygen -t ed25519 -C \"your.email@example.co\"\n```\n\nWe recommend entering a passphrase when you are prompted to. A passphrase is an extra layer of security: it is a password that will be prompted whenever you use your SSH key.\n\nOnce your new key is generated, add it to your SSH agent with `ssh-add`:\n\n```\n$ ssh-add ~/.ssh/id_ed25519\n```\n\nIf you chose a different location than the default to store your SSH key, you would have to replace `~/.ssh/id_ed25519` with the file location you used.\n\n## Add a SSH key to your account\n\nTo access private repositories with SSH, or to push changes via SSH, you will need to add your SSH public key to your huggingface.co account. You can manage your SSH keys [in your user settings](https://huggingface.co/settings/keys).\n\nTo add a SSH key to your account, click on the \"Add SSH key\" button.\n\nThen, enter a name for this key (for example, \"Personal computer\"), and copy and paste the content of your **public** SSH key in the area below. The public key is located in the `~/.ssh/id_XXXX.pub` file you found or generated in the previous steps.\n\nClick on \"Add key\", and voil\u00e0! You have added a SSH key to your huggingface.co account.\n\n\n## Testing your SSH authentication\n\nOnce you have added your SSH key to your huggingface.co account, you can test that the connection works as expected.\n\nIn a terminal, run:\n```\n$ ssh -T git@hf.co\n```\n\nIf you see a message with your username, congrats! Everything went well, you are ready to use git over SSH.\n\nOtherwise, if the message states something like the following, make sure your SSH key is actually used by your SSH agent.\n```\nHi anonymous, welcome to Hugging Face.\n```"
            },
            {
                "score": 0.7849119462411009,
                "node_text": "Here are some facts extracted from the provided text:\n\nSsh-keygen -> Generate -> New ssh key pair\nSsh keys -> Located under -> ~/.ssh on mac & linux\nSsh keys -> Located under -> C:\\\\users\\\\<username>\\\\.ssh on windows\nHuggingface.co account -> Manage -> Ssh keys\n\nGit over SSH\n\nYou can access and write data in repositories on huggingface.co using SSH (Secure Shell Protocol). When you connect via SSH, you authenticate using a private key file on your local machine.\n\nSome actions, such as pushing changes, or cloning private repositories, will require you to upload your SSH public key to your account on huggingface.co.\n\nYou can use a pre-existing SSH key, or generate a new one specifically for huggingface.co.\n\n## Checking for existing SSH keys\n\nIf you have an existing SSH key, you can use that key to authenticate Git operations over SSH.\n\nSSH keys are usually located under `~/.ssh` on Mac & Linux, and under `C:\\\\Users\\\\<username>\\\\.ssh` on Windows. List files under that directory and look for files of the form:\n\n- id_rsa.pub\n- id_ecdsa.pub\n- id_ed25519.pub\n\nThose files contain your SSH public key.\n\nIf you don't have such file under `~/.ssh`, you will have to [generate a new key](#generating-a-new-ssh-keypair). Otherwise, you can [add your existing SSH public key(s) to your huggingface.co account](#add-a-ssh-key-to-your-account).\n\n## Generating a new SSH keypair\n\nIf you don't have any SSH keys on your machine, you can use `ssh-keygen` to generate a new SSH key pair (public + private keys):\n\n```\n$ ssh-keygen -t ed25519 -C \"your.email@example.co\"\n```\n\nWe recommend entering a passphrase when you are prompted to. A passphrase is an extra layer of security: it is a password that will be prompted whenever you use your SSH key.\n\nOnce your new key is generated, add it to your SSH agent with `ssh-add`:\n\n```\n$ ssh-add ~/.ssh/id_ed25519\n```\n\nIf you chose a different location than the default to store your SSH key, you would have to replace `~/.ssh/id_ed25519` with the file location you used.\n\n## Add a SSH key to your account\n\nTo access private repositories with SSH, or to push changes via SSH, you will need to add your SSH public key to your huggingface.co account. You can manage your SSH keys [in your user settings](https://huggingface.co/settings/keys).\n\nTo add a SSH key to your account, click on the \"Add SSH key\" button.\n\nThen, enter a name for this key (for example, \"Personal computer\"), and copy and paste the content of your **public** SSH key in the area below. The public key is located in the `~/.ssh/id_XXXX.pub` file you found or generated in the previous steps.\n\nClick on \"Add key\", and voil\u00e0! You have added a SSH key to your huggingface.co account.\n\n\n## Testing your SSH authentication\n\nOnce you have added your SSH key to your huggingface.co account, you can test that the connection works as expected.\n\nIn a terminal, run:\n```\n$ ssh -T git@hf.co\n```\n\nIf you see a message with your username, congrats! Everything went well, you are ready to use git over SSH.\n\nOtherwise, if the message states something like the following, make sure your SSH key is actually used by your SSH agent.\n```\nHi anonymous, welcome to Hugging Face.\n```"
            }
        ]
    },
    {
        "sample_idx": 93,
        "question": "What is the purpose of a passphrase when generating an SSH key?",
        "answer": "A passphrase is an extra layer of security: it is a password that will be prompted whenever you use your SSH key.",
        "rag_answer": "The purpose of a passphrase when generating an SSH key is to provide an extra layer of security. It is a password that will be prompted whenever you use your SSH key.",
        "rag_score": 5,
        "rag_feedback": "The system's response is completely correct, accurate, and factual. It provides the same information as the expected answer, stating that a passphrase is an extra layer of security that is prompted whenever the SSH key is used.",
        "rag_context": [
            {
                "score": 0.6685132622213644,
                "node_text": "Here are some facts extracted from the provided text:\n\nSsh-keygen -> Generate -> New ssh key pair\nSsh key -> Add to -> Huggingface.co account\nSsh keys -> Located under -> ~/.ssh on mac & linux\nSsh keys -> Located under -> C:\\\\users\\\\<username>\\\\.ssh on windows\nHuggingface.co account -> Manage -> Ssh keys\n\nGit over SSH\n\nYou can access and write data in repositories on huggingface.co using SSH (Secure Shell Protocol). When you connect via SSH, you authenticate using a private key file on your local machine.\n\nSome actions, such as pushing changes, or cloning private repositories, will require you to upload your SSH public key to your account on huggingface.co.\n\nYou can use a pre-existing SSH key, or generate a new one specifically for huggingface.co.\n\n## Checking for existing SSH keys\n\nIf you have an existing SSH key, you can use that key to authenticate Git operations over SSH.\n\nSSH keys are usually located under `~/.ssh` on Mac & Linux, and under `C:\\\\Users\\\\<username>\\\\.ssh` on Windows. List files under that directory and look for files of the form:\n\n- id_rsa.pub\n- id_ecdsa.pub\n- id_ed25519.pub\n\nThose files contain your SSH public key.\n\nIf you don't have such file under `~/.ssh`, you will have to [generate a new key](#generating-a-new-ssh-keypair). Otherwise, you can [add your existing SSH public key(s) to your huggingface.co account](#add-a-ssh-key-to-your-account).\n\n## Generating a new SSH keypair\n\nIf you don't have any SSH keys on your machine, you can use `ssh-keygen` to generate a new SSH key pair (public + private keys):\n\n```\n$ ssh-keygen -t ed25519 -C \"your.email@example.co\"\n```\n\nWe recommend entering a passphrase when you are prompted to. A passphrase is an extra layer of security: it is a password that will be prompted whenever you use your SSH key.\n\nOnce your new key is generated, add it to your SSH agent with `ssh-add`:\n\n```\n$ ssh-add ~/.ssh/id_ed25519\n```\n\nIf you chose a different location than the default to store your SSH key, you would have to replace `~/.ssh/id_ed25519` with the file location you used.\n\n## Add a SSH key to your account\n\nTo access private repositories with SSH, or to push changes via SSH, you will need to add your SSH public key to your huggingface.co account. You can manage your SSH keys [in your user settings](https://huggingface.co/settings/keys).\n\nTo add a SSH key to your account, click on the \"Add SSH key\" button.\n\nThen, enter a name for this key (for example, \"Personal computer\"), and copy and paste the content of your **public** SSH key in the area below. The public key is located in the `~/.ssh/id_XXXX.pub` file you found or generated in the previous steps.\n\nClick on \"Add key\", and voil\u00e0! You have added a SSH key to your huggingface.co account.\n\n\n## Testing your SSH authentication\n\nOnce you have added your SSH key to your huggingface.co account, you can test that the connection works as expected.\n\nIn a terminal, run:\n```\n$ ssh -T git@hf.co\n```\n\nIf you see a message with your username, congrats! Everything went well, you are ready to use git over SSH.\n\nOtherwise, if the message states something like the following, make sure your SSH key is actually used by your SSH agent.\n```\nHi anonymous, welcome to Hugging Face.\n```"
            }
        ]
    },
    {
        "sample_idx": 94,
        "question": "What command is used to add a new SSH key to the SSH agent?",
        "answer": "The command ssh-add is used to add a new SSH key to the SSH agent.",
        "rag_answer": "The command used to add a new SSH key to the SSH agent is `ssh-add`.",
        "rag_score": 5,
        "rag_feedback": "The system's response is completely correct, accurate, and factual. It directly answers the question by stating that the command 'ssh-add' is used to add a new SSH key to the SSH agent.",
        "rag_context": [
            {
                "score": 0.7390693568001607,
                "node_text": "Here are some facts extracted from the provided text:\n\nSsh-keygen -> Generate -> New ssh key pair\nSsh keys -> Located under -> ~/.ssh on mac & linux\nSsh keys -> Located under -> C:\\\\users\\\\<username>\\\\.ssh on windows\nHuggingface.co account -> Manage -> Ssh keys\nSsh key -> Add to -> Huggingface.co account\n\nGit over SSH\n\nYou can access and write data in repositories on huggingface.co using SSH (Secure Shell Protocol). When you connect via SSH, you authenticate using a private key file on your local machine.\n\nSome actions, such as pushing changes, or cloning private repositories, will require you to upload your SSH public key to your account on huggingface.co.\n\nYou can use a pre-existing SSH key, or generate a new one specifically for huggingface.co.\n\n## Checking for existing SSH keys\n\nIf you have an existing SSH key, you can use that key to authenticate Git operations over SSH.\n\nSSH keys are usually located under `~/.ssh` on Mac & Linux, and under `C:\\\\Users\\\\<username>\\\\.ssh` on Windows. List files under that directory and look for files of the form:\n\n- id_rsa.pub\n- id_ecdsa.pub\n- id_ed25519.pub\n\nThose files contain your SSH public key.\n\nIf you don't have such file under `~/.ssh`, you will have to [generate a new key](#generating-a-new-ssh-keypair). Otherwise, you can [add your existing SSH public key(s) to your huggingface.co account](#add-a-ssh-key-to-your-account).\n\n## Generating a new SSH keypair\n\nIf you don't have any SSH keys on your machine, you can use `ssh-keygen` to generate a new SSH key pair (public + private keys):\n\n```\n$ ssh-keygen -t ed25519 -C \"your.email@example.co\"\n```\n\nWe recommend entering a passphrase when you are prompted to. A passphrase is an extra layer of security: it is a password that will be prompted whenever you use your SSH key.\n\nOnce your new key is generated, add it to your SSH agent with `ssh-add`:\n\n```\n$ ssh-add ~/.ssh/id_ed25519\n```\n\nIf you chose a different location than the default to store your SSH key, you would have to replace `~/.ssh/id_ed25519` with the file location you used.\n\n## Add a SSH key to your account\n\nTo access private repositories with SSH, or to push changes via SSH, you will need to add your SSH public key to your huggingface.co account. You can manage your SSH keys [in your user settings](https://huggingface.co/settings/keys).\n\nTo add a SSH key to your account, click on the \"Add SSH key\" button.\n\nThen, enter a name for this key (for example, \"Personal computer\"), and copy and paste the content of your **public** SSH key in the area below. The public key is located in the `~/.ssh/id_XXXX.pub` file you found or generated in the previous steps.\n\nClick on \"Add key\", and voil\u00e0! You have added a SSH key to your huggingface.co account.\n\n\n## Testing your SSH authentication\n\nOnce you have added your SSH key to your huggingface.co account, you can test that the connection works as expected.\n\nIn a terminal, run:\n```\n$ ssh -T git@hf.co\n```\n\nIf you see a message with your username, congrats! Everything went well, you are ready to use git over SSH.\n\nOtherwise, if the message states something like the following, make sure your SSH key is actually used by your SSH agent.\n```\nHi anonymous, welcome to Hugging Face.\n```"
            }
        ]
    },
    {
        "sample_idx": 95,
        "question": "Where is the public SSH key located?",
        "answer": "The public key is located in the ~/.ssh/id_XXXX.pub file.",
        "rag_answer": "The public SSH key is located in the `~/.ssh/id_XXXX.pub` file.",
        "rag_score": 5,
        "rag_feedback": "The system's response is completely correct, accurate, and factual. It directly answers the question by stating that the public SSH key is located in the `~/.ssh/id_XXXX.pub` file, which matches the expected answer.",
        "rag_context": [
            {
                "score": 1.0,
                "node_text": "Here are some facts extracted from the provided text:\n\nSsh public key -> Upload to -> Huggingface.co account\n\nGit over SSH\n\nYou can access and write data in repositories on huggingface.co using SSH (Secure Shell Protocol). When you connect via SSH, you authenticate using a private key file on your local machine.\n\nSome actions, such as pushing changes, or cloning private repositories, will require you to upload your SSH public key to your account on huggingface.co.\n\nYou can use a pre-existing SSH key, or generate a new one specifically for huggingface.co.\n\n## Checking for existing SSH keys\n\nIf you have an existing SSH key, you can use that key to authenticate Git operations over SSH.\n\nSSH keys are usually located under `~/.ssh` on Mac & Linux, and under `C:\\\\Users\\\\<username>\\\\.ssh` on Windows. List files under that directory and look for files of the form:\n\n- id_rsa.pub\n- id_ecdsa.pub\n- id_ed25519.pub\n\nThose files contain your SSH public key.\n\nIf you don't have such file under `~/.ssh`, you will have to [generate a new key](#generating-a-new-ssh-keypair). Otherwise, you can [add your existing SSH public key(s) to your huggingface.co account](#add-a-ssh-key-to-your-account).\n\n## Generating a new SSH keypair\n\nIf you don't have any SSH keys on your machine, you can use `ssh-keygen` to generate a new SSH key pair (public + private keys):\n\n```\n$ ssh-keygen -t ed25519 -C \"your.email@example.co\"\n```\n\nWe recommend entering a passphrase when you are prompted to. A passphrase is an extra layer of security: it is a password that will be prompted whenever you use your SSH key.\n\nOnce your new key is generated, add it to your SSH agent with `ssh-add`:\n\n```\n$ ssh-add ~/.ssh/id_ed25519\n```\n\nIf you chose a different location than the default to store your SSH key, you would have to replace `~/.ssh/id_ed25519` with the file location you used.\n\n## Add a SSH key to your account\n\nTo access private repositories with SSH, or to push changes via SSH, you will need to add your SSH public key to your huggingface.co account. You can manage your SSH keys [in your user settings](https://huggingface.co/settings/keys).\n\nTo add a SSH key to your account, click on the \"Add SSH key\" button.\n\nThen, enter a name for this key (for example, \"Personal computer\"), and copy and paste the content of your **public** SSH key in the area below. The public key is located in the `~/.ssh/id_XXXX.pub` file you found or generated in the previous steps.\n\nClick on \"Add key\", and voil\u00e0! You have added a SSH key to your huggingface.co account.\n\n\n## Testing your SSH authentication\n\nOnce you have added your SSH key to your huggingface.co account, you can test that the connection works as expected.\n\nIn a terminal, run:\n```\n$ ssh -T git@hf.co\n```\n\nIf you see a message with your username, congrats! Everything went well, you are ready to use git over SSH.\n\nOtherwise, if the message states something like the following, make sure your SSH key is actually used by your SSH agent.\n```\nHi anonymous, welcome to Hugging Face.\n```"
            },
            {
                "score": 0.6871849305739588,
                "node_text": "Here are some facts extracted from the provided text:\n\nSsh public key -> Upload to -> Huggingface.co account\nSsh keys -> Located under -> ~/.ssh on mac & linux\nSsh keys -> Located under -> C:\\\\users\\\\<username>\\\\.ssh on windows\nHuggingface.co account -> Manage -> Ssh keys\nSsh key -> Add to -> Huggingface.co account\n\nGit over SSH\n\nYou can access and write data in repositories on huggingface.co using SSH (Secure Shell Protocol). When you connect via SSH, you authenticate using a private key file on your local machine.\n\nSome actions, such as pushing changes, or cloning private repositories, will require you to upload your SSH public key to your account on huggingface.co.\n\nYou can use a pre-existing SSH key, or generate a new one specifically for huggingface.co.\n\n## Checking for existing SSH keys\n\nIf you have an existing SSH key, you can use that key to authenticate Git operations over SSH.\n\nSSH keys are usually located under `~/.ssh` on Mac & Linux, and under `C:\\\\Users\\\\<username>\\\\.ssh` on Windows. List files under that directory and look for files of the form:\n\n- id_rsa.pub\n- id_ecdsa.pub\n- id_ed25519.pub\n\nThose files contain your SSH public key.\n\nIf you don't have such file under `~/.ssh`, you will have to [generate a new key](#generating-a-new-ssh-keypair). Otherwise, you can [add your existing SSH public key(s) to your huggingface.co account](#add-a-ssh-key-to-your-account).\n\n## Generating a new SSH keypair\n\nIf you don't have any SSH keys on your machine, you can use `ssh-keygen` to generate a new SSH key pair (public + private keys):\n\n```\n$ ssh-keygen -t ed25519 -C \"your.email@example.co\"\n```\n\nWe recommend entering a passphrase when you are prompted to. A passphrase is an extra layer of security: it is a password that will be prompted whenever you use your SSH key.\n\nOnce your new key is generated, add it to your SSH agent with `ssh-add`:\n\n```\n$ ssh-add ~/.ssh/id_ed25519\n```\n\nIf you chose a different location than the default to store your SSH key, you would have to replace `~/.ssh/id_ed25519` with the file location you used.\n\n## Add a SSH key to your account\n\nTo access private repositories with SSH, or to push changes via SSH, you will need to add your SSH public key to your huggingface.co account. You can manage your SSH keys [in your user settings](https://huggingface.co/settings/keys).\n\nTo add a SSH key to your account, click on the \"Add SSH key\" button.\n\nThen, enter a name for this key (for example, \"Personal computer\"), and copy and paste the content of your **public** SSH key in the area below. The public key is located in the `~/.ssh/id_XXXX.pub` file you found or generated in the previous steps.\n\nClick on \"Add key\", and voil\u00e0! You have added a SSH key to your huggingface.co account.\n\n\n## Testing your SSH authentication\n\nOnce you have added your SSH key to your huggingface.co account, you can test that the connection works as expected.\n\nIn a terminal, run:\n```\n$ ssh -T git@hf.co\n```\n\nIf you see a message with your username, congrats! Everything went well, you are ready to use git over SSH.\n\nOtherwise, if the message states something like the following, make sure your SSH key is actually used by your SSH agent.\n```\nHi anonymous, welcome to Hugging Face.\n```"
            }
        ]
    },
    {
        "sample_idx": 96,
        "question": "What command should you run in a terminal to test SSH authentication?",
        "answer": "You should run $ ssh -T git@hf.co.",
        "rag_answer": "You should run `$ ssh -T git@hf.co` in a terminal to test SSH authentication.",
        "rag_score": 5,
        "rag_feedback": "The system's response is completely correct, accurate, and factual. It provides the exact command to test SSH authentication, which is $ ssh -T git@hf.co, and also provides additional context and information about SSH keys and authentication.",
        "rag_context": [
            {
                "score": 0.6274026914622024,
                "node_text": "Here are some facts extracted from the provided text:\n\nSsh keys -> Located under -> ~/.ssh on mac & linux\nSsh keys -> Located under -> C:\\\\users\\\\<username>\\\\.ssh on windows\nSsh-keygen -> Generate -> New ssh key pair\n\nGit over SSH\n\nYou can access and write data in repositories on huggingface.co using SSH (Secure Shell Protocol). When you connect via SSH, you authenticate using a private key file on your local machine.\n\nSome actions, such as pushing changes, or cloning private repositories, will require you to upload your SSH public key to your account on huggingface.co.\n\nYou can use a pre-existing SSH key, or generate a new one specifically for huggingface.co.\n\n## Checking for existing SSH keys\n\nIf you have an existing SSH key, you can use that key to authenticate Git operations over SSH.\n\nSSH keys are usually located under `~/.ssh` on Mac & Linux, and under `C:\\\\Users\\\\<username>\\\\.ssh` on Windows. List files under that directory and look for files of the form:\n\n- id_rsa.pub\n- id_ecdsa.pub\n- id_ed25519.pub\n\nThose files contain your SSH public key.\n\nIf you don't have such file under `~/.ssh`, you will have to [generate a new key](#generating-a-new-ssh-keypair). Otherwise, you can [add your existing SSH public key(s) to your huggingface.co account](#add-a-ssh-key-to-your-account).\n\n## Generating a new SSH keypair\n\nIf you don't have any SSH keys on your machine, you can use `ssh-keygen` to generate a new SSH key pair (public + private keys):\n\n```\n$ ssh-keygen -t ed25519 -C \"your.email@example.co\"\n```\n\nWe recommend entering a passphrase when you are prompted to. A passphrase is an extra layer of security: it is a password that will be prompted whenever you use your SSH key.\n\nOnce your new key is generated, add it to your SSH agent with `ssh-add`:\n\n```\n$ ssh-add ~/.ssh/id_ed25519\n```\n\nIf you chose a different location than the default to store your SSH key, you would have to replace `~/.ssh/id_ed25519` with the file location you used.\n\n## Add a SSH key to your account\n\nTo access private repositories with SSH, or to push changes via SSH, you will need to add your SSH public key to your huggingface.co account. You can manage your SSH keys [in your user settings](https://huggingface.co/settings/keys).\n\nTo add a SSH key to your account, click on the \"Add SSH key\" button.\n\nThen, enter a name for this key (for example, \"Personal computer\"), and copy and paste the content of your **public** SSH key in the area below. The public key is located in the `~/.ssh/id_XXXX.pub` file you found or generated in the previous steps.\n\nClick on \"Add key\", and voil\u00e0! You have added a SSH key to your huggingface.co account.\n\n\n## Testing your SSH authentication\n\nOnce you have added your SSH key to your huggingface.co account, you can test that the connection works as expected.\n\nIn a terminal, run:\n```\n$ ssh -T git@hf.co\n```\n\nIf you see a message with your username, congrats! Everything went well, you are ready to use git over SSH.\n\nOtherwise, if the message states something like the following, make sure your SSH key is actually used by your SSH agent.\n```\nHi anonymous, welcome to Hugging Face.\n```"
            }
        ]
    },
    {
        "sample_idx": 97,
        "question": "What does it mean if you see a message with your username after running the SSH authentication test?",
        "answer": "It means everything went well, you are ready to use git over SSH.",
        "rag_answer": "It means that everything went well, and you are ready to use Git over SSH.",
        "rag_score": 5,
        "rag_feedback": "The system's response is completely correct, accurate, and factual. It matches the expected answer, stating that seeing a message with your username after running the SSH authentication test means everything went well and you are ready to use Git over SSH.",
        "rag_context": [
            {
                "score": 0.6740465117206949,
                "node_text": "Here are some facts extracted from the provided text:\n\nSsh keys -> Located under -> C:\\\\users\\\\<username>\\\\.ssh on windows\nSsh keys -> Located under -> ~/.ssh on mac & linux\nSsh-keygen -> Generate -> New ssh key pair\nSsh public key -> Upload to -> Huggingface.co account\n\nGit over SSH\n\nYou can access and write data in repositories on huggingface.co using SSH (Secure Shell Protocol). When you connect via SSH, you authenticate using a private key file on your local machine.\n\nSome actions, such as pushing changes, or cloning private repositories, will require you to upload your SSH public key to your account on huggingface.co.\n\nYou can use a pre-existing SSH key, or generate a new one specifically for huggingface.co.\n\n## Checking for existing SSH keys\n\nIf you have an existing SSH key, you can use that key to authenticate Git operations over SSH.\n\nSSH keys are usually located under `~/.ssh` on Mac & Linux, and under `C:\\\\Users\\\\<username>\\\\.ssh` on Windows. List files under that directory and look for files of the form:\n\n- id_rsa.pub\n- id_ecdsa.pub\n- id_ed25519.pub\n\nThose files contain your SSH public key.\n\nIf you don't have such file under `~/.ssh`, you will have to [generate a new key](#generating-a-new-ssh-keypair). Otherwise, you can [add your existing SSH public key(s) to your huggingface.co account](#add-a-ssh-key-to-your-account).\n\n## Generating a new SSH keypair\n\nIf you don't have any SSH keys on your machine, you can use `ssh-keygen` to generate a new SSH key pair (public + private keys):\n\n```\n$ ssh-keygen -t ed25519 -C \"your.email@example.co\"\n```\n\nWe recommend entering a passphrase when you are prompted to. A passphrase is an extra layer of security: it is a password that will be prompted whenever you use your SSH key.\n\nOnce your new key is generated, add it to your SSH agent with `ssh-add`:\n\n```\n$ ssh-add ~/.ssh/id_ed25519\n```\n\nIf you chose a different location than the default to store your SSH key, you would have to replace `~/.ssh/id_ed25519` with the file location you used.\n\n## Add a SSH key to your account\n\nTo access private repositories with SSH, or to push changes via SSH, you will need to add your SSH public key to your huggingface.co account. You can manage your SSH keys [in your user settings](https://huggingface.co/settings/keys).\n\nTo add a SSH key to your account, click on the \"Add SSH key\" button.\n\nThen, enter a name for this key (for example, \"Personal computer\"), and copy and paste the content of your **public** SSH key in the area below. The public key is located in the `~/.ssh/id_XXXX.pub` file you found or generated in the previous steps.\n\nClick on \"Add key\", and voil\u00e0! You have added a SSH key to your huggingface.co account.\n\n\n## Testing your SSH authentication\n\nOnce you have added your SSH key to your huggingface.co account, you can test that the connection works as expected.\n\nIn a terminal, run:\n```\n$ ssh -T git@hf.co\n```\n\nIf you see a message with your username, congrats! Everything went well, you are ready to use git over SSH.\n\nOtherwise, if the message states something like the following, make sure your SSH key is actually used by your SSH agent.\n```\nHi anonymous, welcome to Hugging Face.\n```"
            }
        ]
    },
    {
        "sample_idx": 98,
        "question": "What does it mean if you see the message 'Hi anonymous, welcome to Hugging Face.' after running the SSH authentication test?",
        "answer": "It means your SSH key is not actually used by your SSH agent.",
        "rag_answer": "It means that your SSH key is not being used by your SSH agent, and therefore, the authentication test failed.",
        "rag_score": 5,
        "rag_feedback": "The response is completely correct, accurate, and factual. It correctly interprets the message 'Hi anonymous, welcome to Hugging Face.' as an indication that the SSH key is not being used by the SSH agent, which is in line with the expected answer.",
        "rag_context": [
            {
                "score": 0.6478478209638507,
                "node_text": "Here are some facts extracted from the provided text:\n\nSsh keys -> Located under -> ~/.ssh on mac & linux\nSsh-keygen -> Generate -> New ssh key pair\nSsh public key -> Upload to -> Huggingface.co account\nSsh -> Is -> Secure shell protocol\nSsh -> Authenticate -> Private key file\n\nGit over SSH\n\nYou can access and write data in repositories on huggingface.co using SSH (Secure Shell Protocol). When you connect via SSH, you authenticate using a private key file on your local machine.\n\nSome actions, such as pushing changes, or cloning private repositories, will require you to upload your SSH public key to your account on huggingface.co.\n\nYou can use a pre-existing SSH key, or generate a new one specifically for huggingface.co.\n\n## Checking for existing SSH keys\n\nIf you have an existing SSH key, you can use that key to authenticate Git operations over SSH.\n\nSSH keys are usually located under `~/.ssh` on Mac & Linux, and under `C:\\\\Users\\\\<username>\\\\.ssh` on Windows. List files under that directory and look for files of the form:\n\n- id_rsa.pub\n- id_ecdsa.pub\n- id_ed25519.pub\n\nThose files contain your SSH public key.\n\nIf you don't have such file under `~/.ssh`, you will have to [generate a new key](#generating-a-new-ssh-keypair). Otherwise, you can [add your existing SSH public key(s) to your huggingface.co account](#add-a-ssh-key-to-your-account).\n\n## Generating a new SSH keypair\n\nIf you don't have any SSH keys on your machine, you can use `ssh-keygen` to generate a new SSH key pair (public + private keys):\n\n```\n$ ssh-keygen -t ed25519 -C \"your.email@example.co\"\n```\n\nWe recommend entering a passphrase when you are prompted to. A passphrase is an extra layer of security: it is a password that will be prompted whenever you use your SSH key.\n\nOnce your new key is generated, add it to your SSH agent with `ssh-add`:\n\n```\n$ ssh-add ~/.ssh/id_ed25519\n```\n\nIf you chose a different location than the default to store your SSH key, you would have to replace `~/.ssh/id_ed25519` with the file location you used.\n\n## Add a SSH key to your account\n\nTo access private repositories with SSH, or to push changes via SSH, you will need to add your SSH public key to your huggingface.co account. You can manage your SSH keys [in your user settings](https://huggingface.co/settings/keys).\n\nTo add a SSH key to your account, click on the \"Add SSH key\" button.\n\nThen, enter a name for this key (for example, \"Personal computer\"), and copy and paste the content of your **public** SSH key in the area below. The public key is located in the `~/.ssh/id_XXXX.pub` file you found or generated in the previous steps.\n\nClick on \"Add key\", and voil\u00e0! You have added a SSH key to your huggingface.co account.\n\n\n## Testing your SSH authentication\n\nOnce you have added your SSH key to your huggingface.co account, you can test that the connection works as expected.\n\nIn a terminal, run:\n```\n$ ssh -T git@hf.co\n```\n\nIf you see a message with your username, congrats! Everything went well, you are ready to use git over SSH.\n\nOtherwise, if the message states something like the following, make sure your SSH key is actually used by your SSH agent.\n```\nHi anonymous, welcome to Hugging Face.\n```"
            }
        ]
    },
    {
        "sample_idx": 99,
        "question": "What is the license under which the file is licensed?",
        "answer": "The file is licensed under the Apache License, Version 2.0.",
        "rag_answer": "The file is licensed under the Apache License, Version 2.0.",
        "rag_score": 5,
        "rag_feedback": "The system's response is completely correct, accurate, and factual. It exactly matches the expected answer, stating that the file is licensed under the Apache License, Version 2.0.",
        "rag_context": [
            {
                "score": 0.7456044442787906,
                "node_text": "Here are some facts extracted from the provided text:\n\nLicense -> Has -> Version 2.0\nLicense -> Is -> Apache license\nApache license -> Is -> Version 2.0\nThe huggingface team -> Has -> Copyright\n\n!---\nCopyright 2022 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n-->\n\n# Token classification with LayoutLMv3 (PyTorch version)\n\nThis directory contains a script, `run_funsd_cord.py`, that can be used to fine-tune (or evaluate) LayoutLMv3 on form understanding datasets, such as [FUNSD](https://guillaumejaume.github.io/FUNSD/) and [CORD](https://github.com/clovaai/cord).\n\nThe script `run_funsd_cord.py` leverages the \ud83e\udd17 Datasets library and the Trainer API. You can easily customize it to your needs.\n\n## Fine-tuning on FUNSD\n\nFine-tuning LayoutLMv3 for token classification on [FUNSD](https://guillaumejaume.github.io/FUNSD/) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name funsd \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 1e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-funsd\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd. By specifying the `push_to_hub` flag, the model gets uploaded automatically to the hub (regularly), together with a model card, which includes metrics such as precision, recall and F1. Note that you can easily update the model card, as it's just a README file of the respective repo on the hub.\n\nThere's also the \"Training metrics\" [tab](https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd/tensorboard), which shows Tensorboard logs over the course of training. Pretty neat, huh?\n\n## Fine-tuning on CORD\n\nFine-tuning LayoutLMv3 for token classification on [CORD](https://github.com/clovaai/cord) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name cord \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 5e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-cord\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-cord. Note that a model card gets generated automatically in case you specify the `push_to_hub` flag."
            },
            {
                "score": 0.6432005405262257,
                "node_text": "Here are some facts extracted from the provided text:\n\nPrivate key file -> Located on -> Local machine\nSsh -> Authenticate -> Private key file\n\nGit over SSH\n\nYou can access and write data in repositories on huggingface.co using SSH (Secure Shell Protocol). When you connect via SSH, you authenticate using a private key file on your local machine.\n\nSome actions, such as pushing changes, or cloning private repositories, will require you to upload your SSH public key to your account on huggingface.co.\n\nYou can use a pre-existing SSH key, or generate a new one specifically for huggingface.co.\n\n## Checking for existing SSH keys\n\nIf you have an existing SSH key, you can use that key to authenticate Git operations over SSH.\n\nSSH keys are usually located under `~/.ssh` on Mac & Linux, and under `C:\\\\Users\\\\<username>\\\\.ssh` on Windows. List files under that directory and look for files of the form:\n\n- id_rsa.pub\n- id_ecdsa.pub\n- id_ed25519.pub\n\nThose files contain your SSH public key.\n\nIf you don't have such file under `~/.ssh`, you will have to [generate a new key](#generating-a-new-ssh-keypair). Otherwise, you can [add your existing SSH public key(s) to your huggingface.co account](#add-a-ssh-key-to-your-account).\n\n## Generating a new SSH keypair\n\nIf you don't have any SSH keys on your machine, you can use `ssh-keygen` to generate a new SSH key pair (public + private keys):\n\n```\n$ ssh-keygen -t ed25519 -C \"your.email@example.co\"\n```\n\nWe recommend entering a passphrase when you are prompted to. A passphrase is an extra layer of security: it is a password that will be prompted whenever you use your SSH key.\n\nOnce your new key is generated, add it to your SSH agent with `ssh-add`:\n\n```\n$ ssh-add ~/.ssh/id_ed25519\n```\n\nIf you chose a different location than the default to store your SSH key, you would have to replace `~/.ssh/id_ed25519` with the file location you used.\n\n## Add a SSH key to your account\n\nTo access private repositories with SSH, or to push changes via SSH, you will need to add your SSH public key to your huggingface.co account. You can manage your SSH keys [in your user settings](https://huggingface.co/settings/keys).\n\nTo add a SSH key to your account, click on the \"Add SSH key\" button.\n\nThen, enter a name for this key (for example, \"Personal computer\"), and copy and paste the content of your **public** SSH key in the area below. The public key is located in the `~/.ssh/id_XXXX.pub` file you found or generated in the previous steps.\n\nClick on \"Add key\", and voil\u00e0! You have added a SSH key to your huggingface.co account.\n\n\n## Testing your SSH authentication\n\nOnce you have added your SSH key to your huggingface.co account, you can test that the connection works as expected.\n\nIn a terminal, run:\n```\n$ ssh -T git@hf.co\n```\n\nIf you see a message with your username, congrats! Everything went well, you are ready to use git over SSH.\n\nOtherwise, if the message states something like the following, make sure your SSH key is actually used by your SSH agent.\n```\nHi anonymous, welcome to Hugging Face.\n```"
            }
        ]
    },
    {
        "sample_idx": 100,
        "question": "What is the purpose of the script run_funsd_cord.py?",
        "answer": "The script run_funsd_cord.py is used to fine-tune or evaluate LayoutLMv3 on form understanding datasets.",
        "rag_answer": "The script run_funsd_cord.py is used to fine-tune or evaluate LayoutLMv3 on form understanding datasets.",
        "rag_score": 5,
        "rag_feedback": "The system's response is completely correct, accurate, and factual. It exactly matches the expected answer, providing the purpose of the script run_funsd_cord.py, which is to fine-tune or evaluate LayoutLMv3 on form understanding datasets.",
        "rag_context": [
            {
                "score": 0.8097352127219237,
                "node_text": "Here are some facts extracted from the provided text:\n\nRun_funsd_cord.py -> Is -> Script\nFunsd -> Is -> Form understanding dataset\nCord -> Is -> Form understanding dataset\n\n!---\nCopyright 2022 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n-->\n\n# Token classification with LayoutLMv3 (PyTorch version)\n\nThis directory contains a script, `run_funsd_cord.py`, that can be used to fine-tune (or evaluate) LayoutLMv3 on form understanding datasets, such as [FUNSD](https://guillaumejaume.github.io/FUNSD/) and [CORD](https://github.com/clovaai/cord).\n\nThe script `run_funsd_cord.py` leverages the \ud83e\udd17 Datasets library and the Trainer API. You can easily customize it to your needs.\n\n## Fine-tuning on FUNSD\n\nFine-tuning LayoutLMv3 for token classification on [FUNSD](https://guillaumejaume.github.io/FUNSD/) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name funsd \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 1e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-funsd\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd. By specifying the `push_to_hub` flag, the model gets uploaded automatically to the hub (regularly), together with a model card, which includes metrics such as precision, recall and F1. Note that you can easily update the model card, as it's just a README file of the respective repo on the hub.\n\nThere's also the \"Training metrics\" [tab](https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd/tensorboard), which shows Tensorboard logs over the course of training. Pretty neat, huh?\n\n## Fine-tuning on CORD\n\nFine-tuning LayoutLMv3 for token classification on [CORD](https://github.com/clovaai/cord) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name cord \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 5e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-cord\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-cord. Note that a model card gets generated automatically in case you specify the `push_to_hub` flag."
            },
            {
                "score": 0.6252333746519999,
                "node_text": "Here are some facts extracted from the provided text:\n\nFunc -> Takes -> Slider_1\nFunc -> Takes -> Slider_2\nFunc -> Returns -> Slider_1 * 5 + slider_2\n\nGradio Demo: blocks_random_slider\n\n\n```\n!pip install -q gradio \n```\n\n\n```\n\nimport gradio as gr\n\n\ndef func(slider_1, slider_2):\n    return slider_1 * 5 + slider_2\n\n\nwith gr.Blocks() as demo:\n    slider = gr.Slider(minimum=-10.2, maximum=15, label=\"Random Slider (Static)\", randomize=True)\n    slider_1 = gr.Slider(minimum=100, maximum=200, label=\"Random Slider (Input 1)\", randomize=True)\n    slider_2 = gr.Slider(minimum=10, maximum=23.2, label=\"Random Slider (Input 2)\", randomize=True)\n    slider_3 = gr.Slider(value=3, label=\"Non random slider\")\n    btn = gr.Button(\"Run\")\n    btn.click(func, inputs=[slider_1, slider_2], outputs=gr.Number())\n\nif __name__ == \"__main__\":\n    demo.launch()\n\n```"
            }
        ]
    },
    {
        "sample_idx": 101,
        "question": "What datasets can the script run_funsd_cord.py be used with?",
        "answer": "The script run_funsd_cord.py can be used with form understanding datasets such as FUNSD and CORD.",
        "rag_answer": "The script run_funsd_cord.py can be used with form understanding datasets, such as FUNSD and CORD.",
        "rag_score": 5,
        "rag_feedback": "The system's response is completely correct, accurate, and factual. It directly answers the question by stating that the script run_funsd_cord.py can be used with form understanding datasets such as FUNSD and CORD.",
        "rag_context": [
            {
                "score": 0.7994031584006954,
                "node_text": "Here are some facts extracted from the provided text:\n\nRun_funsd_cord.py -> Is -> Script\nFunsd -> Is -> Form understanding dataset\n\n!---\nCopyright 2022 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n-->\n\n# Token classification with LayoutLMv3 (PyTorch version)\n\nThis directory contains a script, `run_funsd_cord.py`, that can be used to fine-tune (or evaluate) LayoutLMv3 on form understanding datasets, such as [FUNSD](https://guillaumejaume.github.io/FUNSD/) and [CORD](https://github.com/clovaai/cord).\n\nThe script `run_funsd_cord.py` leverages the \ud83e\udd17 Datasets library and the Trainer API. You can easily customize it to your needs.\n\n## Fine-tuning on FUNSD\n\nFine-tuning LayoutLMv3 for token classification on [FUNSD](https://guillaumejaume.github.io/FUNSD/) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name funsd \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 1e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-funsd\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd. By specifying the `push_to_hub` flag, the model gets uploaded automatically to the hub (regularly), together with a model card, which includes metrics such as precision, recall and F1. Note that you can easily update the model card, as it's just a README file of the respective repo on the hub.\n\nThere's also the \"Training metrics\" [tab](https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd/tensorboard), which shows Tensorboard logs over the course of training. Pretty neat, huh?\n\n## Fine-tuning on CORD\n\nFine-tuning LayoutLMv3 for token classification on [CORD](https://github.com/clovaai/cord) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name cord \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 5e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-cord\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-cord. Note that a model card gets generated automatically in case you specify the `push_to_hub` flag."
            },
            {
                "score": 0.6445891252965738,
                "node_text": "Here are some facts extracted from the provided text:\n\nInference widget -> Is used for -> Testing endpoint\n\nCreate an Endpoint\n\nAfter your first login, you will be directed to the [Endpoint creation page](https://ui.endpoints.huggingface.co/new). As an example, this guide will go through the steps to deploy [distilbert-base-uncased-finetuned-sst-2-english](https://huggingface.co/distilbert-base-uncased-finetuned-sst-2-english) for text classification. \n\n## 1. Enter the Hugging Face Repository ID and your desired endpoint name:\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_repository.png\" alt=\"select repository\" />\n\n## 2. Select your Cloud Provider and region. Initially, only AWS will be available as a Cloud Provider with the `us-east-1` and `eu-west-1` regions. We will add Azure soon, and if you need to test Endpoints with other Cloud Providers or regions, please let us know.\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_region.png\" alt=\"select region\" />\n\n## 3. Define the [Security Level](security) for the Endpoint:\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_security.png\" alt=\"define security\" />\n\n## 4. Create your Endpoint by clicking **Create Endpoint**. By default, your Endpoint is created with a medium CPU (2 x 4GB vCPUs with Intel Xeon Ice Lake) The cost estimate assumes the Endpoint will be up for an entire month, and does not take autoscaling into account.\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_create_cost.png\" alt=\"create endpoint\" />\n\n## 5. Wait for the Endpoint to build, initialize and run which can take between 1 to 5 minutes.\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/overview.png\" alt=\"overview\" />\n\n## 6. Test your Endpoint in the overview with the Inference widget \ud83c\udfc1 \ud83c\udf89!\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_inference.png\" alt=\"run inference\" />"
            },
            {
                "score": 0.6413869219491268,
                "node_text": "Here are some facts extracted from the provided text:\n\nHuggingface ecosystem -> Includes -> Transformers and datasets\n\n!--Copyright 2023 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\nthe License. You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under the License is distributed on\nan \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n\n\u26a0\ufe0f Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be\nrendered properly in your Markdown viewer.\n\n-->\n\n# Training on TPU with TensorFlow\n\n<Tip>\n\nIf you don't need long explanations and just want TPU code samples to get started with, check out [our TPU example notebook!](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb)\n\n</Tip>\n\n### What is a TPU?\n\nA TPU is a **Tensor Processing Unit.** They are hardware designed by Google, which are used to greatly speed up the tensor computations within neural networks, much like GPUs. They can be used for both network training and inference. They are generally accessed through Google\u2019s cloud services, but small TPUs can also be accessed directly for free through Google Colab and Kaggle Kernels.\n\nBecause [all TensorFlow models in \ud83e\udd17 Transformers are Keras models](https://huggingface.co/blog/tensorflow-philosophy), most of the methods in this document are generally applicable to TPU training for any Keras model! However, there are a few points that are specific to the HuggingFace ecosystem (hug-o-system?) of Transformers and Datasets, and we\u2019ll make sure to flag them up when we get to them.\n\n### What kinds of TPU are available?\n\nNew users are often very confused by the range of TPUs, and the different ways to access them. The first key distinction to understand is the difference between **TPU Nodes** and **TPU VMs.**\n\nWhen you use a **TPU Node**, you are effectively indirectly accessing a remote TPU. You will need a separate VM, which will initialize your network and data pipeline and then forward them to the remote node. When you use a TPU on Google Colab, you are accessing it in the **TPU Node** style.\n\nUsing TPU Nodes can have some quite unexpected behaviour for people who aren\u2019t used to them! In particular, because the TPU is located on a physically different system to the machine you\u2019re running your Python code on, your data cannot be local to your machine - any data pipeline that loads from your machine\u2019s internal storage will totally fail! Instead, data must be stored in Google Cloud Storage where your data pipeline can still access it, even when the pipeline is running on the remote TPU node.\n\n<Tip>\n\nIf you can fit all your data in memory as `np.ndarray` or `tf.Tensor`, then you can `fit()` on that data even when using Colab or a TPU Node, without needing to upload it to Google Cloud Storage.\n\n</Tip>\n\n<Tip>\n\n**\ud83e\udd17Specific Hugging Face Tip\ud83e\udd17:** The methods `Dataset.to_tf_dataset()` and its higher-level wrapper `model.prepare_tf_dataset()` , which you will see throughout our TF code examples, will both fail on a TPU Node. The reason for this is that even though they create a `tf.data.Dataset` it is not a \u201cpure\u201d `tf.data` pipeline and uses `tf.numpy_function` or `Dataset.from_generator()` to stream data from the underlying HuggingFace `Dataset`. This HuggingFace `Dataset` is backed by data that is on a local disc and which the remote TPU Node will not be able to read.\n\n</Tip>\n\nThe second way to access a TPU is via a **TPU VM.** When using a TPU VM, you connect directly to the machine that the TPU is attached to, much like training on a GPU VM. TPU VMs are generally easier to work with, particularly when it comes to your data pipeline. All of the above warnings do not apply to TPU VMs!\n\nThis is an opinionated document, so here\u2019s our opinion: **Avoid using TPU Node if possible.** It is more confusing and more difficult to debug than TPU VMs. It is also likely to be unsupported in future - Google\u2019s latest TPU, TPUv4, can only be accessed as a TPU VM, which suggests that TPU Nodes are increasingly going to become a \u201clegacy\u201d access method."
            }
        ]
    },
    {
        "sample_idx": 102,
        "question": "What is the name of the model that can be fine-tuned for token classification on FUNSD?",
        "answer": "The model that can be fine-tuned for token classification on FUNSD is LayoutLMv3-base.",
        "rag_answer": "The name of the model that can be fine-tuned for token classification on FUNSD is LayoutLMv3.",
        "rag_score": 4,
        "rag_feedback": "The response is mostly correct, accurate, and factual. It correctly identifies the model that can be fine-tuned for token classification on FUNSD as LayoutLMv3, but it omits the '-base' suffix, which is present in the expected answer.",
        "rag_context": [
            {
                "score": 1.0,
                "node_text": "Here are some facts extracted from the provided text:\n\nNamed entity recognition -> Evaluated with -> Seqeval\n\nChoosing a metric for your task\n\n**So you've trained your model and want to see how well it\u2019s doing on a dataset of your choice. Where do you start?**\n\nThere is no \u201cone size fits all\u201d approach to choosing an evaluation metric, but some good guidelines to keep in mind are:\n\n## Categories of metrics\n\nThere are 3 high-level categories of metrics:\n\n1. *Generic metrics*, which can be applied to a variety of situations and datasets, such as precision and accuracy.\n2. *Task-specific metrics*, which are limited to a given task, such as Machine Translation (often evaluated using metrics [BLEU](https://huggingface.co/metrics/bleu) or [ROUGE](https://huggingface.co/metrics/rouge)) or Named Entity Recognition (often evaluated with [seqeval](https://huggingface.co/metrics/seqeval)).\n3. *Dataset-specific metrics*, which aim to measure model performance on specific benchmarks: for instance, the [GLUE benchmark](https://huggingface.co/datasets/glue) has a dedicated [evaluation metric](https://huggingface.co/metrics/glue).\n\nLet's look at each of these three cases:\n\n### Generic metrics\n\nMany of the metrics used in the Machine Learning community are quite generic and can be applied in a variety of tasks and datasets.\n\nThis is the case for metrics like [accuracy](https://huggingface.co/metrics/accuracy) and [precision](https://huggingface.co/metrics/precision), which can be used for evaluating labeled (supervised) datasets, as well as [perplexity](https://huggingface.co/metrics/perplexity), which can be used for evaluating different kinds of (unsupervised) generative tasks.\n\nTo see the input structure of a given metric, you can look at its metric card. For example, in the case of [precision](https://huggingface.co/metrics/precision), the format is:\n```\n>>> precision_metric = evaluate.load(\"precision\")\n>>> results = precision_metric.compute(references=[0, 1], predictions=[0, 1])\n>>> print(results)\n{'precision': 1.0}\n```\n\n### Task-specific metrics\n\nPopular ML tasks like Machine Translation and Named Entity Recognition have specific metrics that can be used to compare models. For example, a series of different metrics have been proposed for text generation, ranging from [BLEU](https://huggingface.co/metrics/bleu) and its derivatives such as [GoogleBLEU](https://huggingface.co/metrics/google_bleu) and [GLEU](https://huggingface.co/metrics/gleu), but also [ROUGE](https://huggingface.co/metrics/rouge), [MAUVE](https://huggingface.co/metrics/mauve), etc.\n\nYou can find the right metric for your task by:\n\n- **Looking at the [Task pages](https://huggingface.co/tasks)** to see what metrics can be used for evaluating models for a given task.\n- **Checking out leaderboards** on sites like [Papers With Code](https://paperswithcode.com/) (you can search by task and by dataset).\n-  **Reading the metric cards** for the relevant metrics and see which ones are a good fit for your use case. For example, see the [BLEU metric card](https://github.com/huggingface/evaluate/tree/main/metrics/bleu) or [SQuaD metric card](https://github.com/huggingface/evaluate/tree/main/metrics/squad).\n- **Looking at papers and blog posts** published on the topic and see what metrics they report. This can change over time, so try to pick papers from the last couple of years!\n\n### Dataset-specific metrics\n\nSome datasets have specific metrics associated with them -- this is especially in the case of popular benchmarks like [GLUE](https://huggingface.co/metrics/glue) and [SQuAD](https://huggingface.co/metrics/squad).\n\n<Tip warning={true}>\n\ud83d\udca1\nGLUE is actually a collection of different subsets on different tasks, so first you need to choose the one that corresponds to the NLI task, such as mnli, which is described as \u201ccrowdsourced collection of sentence pairs with textual entailment annotations\u201d\n</Tip>"
            },
            {
                "score": 0.6792482484394124,
                "node_text": "Here are some facts extracted from the provided text:\n\nFunsd -> Is -> Form understanding dataset\nNielsr/layoutlmv3-finetuned-funsd -> Is -> Model\n\n!---\nCopyright 2022 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n-->\n\n# Token classification with LayoutLMv3 (PyTorch version)\n\nThis directory contains a script, `run_funsd_cord.py`, that can be used to fine-tune (or evaluate) LayoutLMv3 on form understanding datasets, such as [FUNSD](https://guillaumejaume.github.io/FUNSD/) and [CORD](https://github.com/clovaai/cord).\n\nThe script `run_funsd_cord.py` leverages the \ud83e\udd17 Datasets library and the Trainer API. You can easily customize it to your needs.\n\n## Fine-tuning on FUNSD\n\nFine-tuning LayoutLMv3 for token classification on [FUNSD](https://guillaumejaume.github.io/FUNSD/) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name funsd \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 1e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-funsd\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd. By specifying the `push_to_hub` flag, the model gets uploaded automatically to the hub (regularly), together with a model card, which includes metrics such as precision, recall and F1. Note that you can easily update the model card, as it's just a README file of the respective repo on the hub.\n\nThere's also the \"Training metrics\" [tab](https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd/tensorboard), which shows Tensorboard logs over the course of training. Pretty neat, huh?\n\n## Fine-tuning on CORD\n\nFine-tuning LayoutLMv3 for token classification on [CORD](https://github.com/clovaai/cord) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name cord \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 5e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-cord\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-cord. Note that a model card gets generated automatically in case you specify the `push_to_hub` flag."
            },
            {
                "score": 0.62279138434123,
                "node_text": "Here are some facts extracted from the provided text:\n\nNlp models -> Have -> Variable lengths\nTokenizers -> Have -> Padding methods\nHuggingface -> Provides -> Tokenizers\n\nThis is a really useful trick, so remember it if you need to convert your own code to XLA!\n\n#### XLA Rule #3: XLA will need to recompile your model for every different input shape it sees\n\nThis is the big one. What this means is that if your input shapes are very variable, XLA will have to recompile your model over and over, which will create huge performance problems. This commonly arises in NLP models, where input texts have variable lengths after tokenization. In other modalities, static shapes are more common and this rule is much less of a problem.\n\nHow can you get around rule #3? The key is **padding** - if you pad all your inputs to the same length, and then use an `attention_mask`, you can get the same results as you\u2019d get from variable shapes, but without any XLA issues. However, excessive padding can cause severe slowdown too - if you pad all your samples to the maximum length in the whole dataset, you might end up with batches consisting endless padding tokens, which will waste a lot of compute and memory!\n\nThere isn\u2019t a perfect solution to this problem. However, you can try some tricks. One very useful trick is to **pad batches of samples up to a multiple of a number like 32 or 64 tokens.** This often only increases the number of tokens by a small amount, but it hugely reduces the number of unique input shapes, because every input shape now has to be a multiple of 32 or 64. Fewer unique input shapes means fewer XLA compilations!\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** Our tokenizers and data collators have methods that can help you here. You can use `padding=\"max_length\"` or `padding=\"longest\"` when calling tokenizers to get them to output padded data. Our tokenizers and data collators also have a `pad_to_multiple_of` argument that you can use to reduce the number of unique input shapes you see!\n\n</Tip>\n\n### How do I actually train my model on TPU?\n\nOnce your training is XLA-compatible and (if you\u2019re using TPU Node / Colab) your dataset has been prepared appropriately, running on TPU is surprisingly easy! All you really need to change in your code is to add a few lines to initialize your TPU, and to ensure that your model and dataset are created inside a `TPUStrategy` scope. Take a look at [our TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) to see this in action!\n\n### Summary\n\nThere was a lot in here, so let\u2019s summarize with a quick checklist you can follow when you want to get your model ready for TPU training:\n\n- Make sure your code follows the three rules of XLA\n- Compile your model with `jit_compile=True` on CPU/GPU and confirm that you can train it with XLA\n- Either load your dataset into memory or use a TPU-compatible dataset loading approach (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Migrate your code either to Colab (with accelerator set to \u201cTPU\u201d) or a TPU VM on Google Cloud\n- Add TPU initializer code (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Create your `TPUStrategy` and make sure dataset loading and model creation are inside the `strategy.scope()` (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Don\u2019t forget to take `jit_compile=True` out again when you move to TPU!\n- \ud83d\ude4f\ud83d\ude4f\ud83d\ude4f\ud83e\udd7a\ud83e\udd7a\ud83e\udd7a\n- Call model.fit()\n- You did it!"
            }
        ]
    },
    {
        "sample_idx": 103,
        "question": "Where can the resulting model be found?",
        "answer": "The resulting model can be found at https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd.",
        "rag_answer": "The resulting model can be found at https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd and https://huggingface.co/nielsr/layoutlmv3-finetuned-cord.",
        "rag_score": 4,
        "rag_feedback": "The system's response is mostly correct, accurate, and factual. It provides the correct URL where the resulting model can be found, which is https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd. However, it also provides an additional URL, https://huggingface.co/nielsr/layoutlmv3-finetuned-cord, which is not requested in the question.",
        "rag_context": [
            {
                "score": 0.6473720702453738,
                "node_text": "Here are some facts extracted from the provided text:\n\nMicrosoft/layoutlmv3-base -> Is -> Model name or path\nModel -> Needs -> Question\nModel -> Has -> Input shape\nModel -> Needs -> Context\nModel -> Evaluates on -> Squad\nNielsr/layoutlmv3-finetuned-funsd -> Is -> Model\nModel -> Returns -> Prediction_text\n\n!---\nCopyright 2022 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n-->\n\n# Token classification with LayoutLMv3 (PyTorch version)\n\nThis directory contains a script, `run_funsd_cord.py`, that can be used to fine-tune (or evaluate) LayoutLMv3 on form understanding datasets, such as [FUNSD](https://guillaumejaume.github.io/FUNSD/) and [CORD](https://github.com/clovaai/cord).\n\nThe script `run_funsd_cord.py` leverages the \ud83e\udd17 Datasets library and the Trainer API. You can easily customize it to your needs.\n\n## Fine-tuning on FUNSD\n\nFine-tuning LayoutLMv3 for token classification on [FUNSD](https://guillaumejaume.github.io/FUNSD/) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name funsd \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 1e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-funsd\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd. By specifying the `push_to_hub` flag, the model gets uploaded automatically to the hub (regularly), together with a model card, which includes metrics such as precision, recall and F1. Note that you can easily update the model card, as it's just a README file of the respective repo on the hub.\n\nThere's also the \"Training metrics\" [tab](https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd/tensorboard), which shows Tensorboard logs over the course of training. Pretty neat, huh?\n\n## Fine-tuning on CORD\n\nFine-tuning LayoutLMv3 for token classification on [CORD](https://github.com/clovaai/cord) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name cord \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 5e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-cord\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-cord. Note that a model card gets generated automatically in case you specify the `push_to_hub` flag."
            },
            {
                "score": 0.6408430189527913,
                "node_text": "Here are some facts extracted from the provided text:\n\nXla -> Recompile -> Model\nNlp models -> Have -> Variable lengths\n\nThis is a really useful trick, so remember it if you need to convert your own code to XLA!\n\n#### XLA Rule #3: XLA will need to recompile your model for every different input shape it sees\n\nThis is the big one. What this means is that if your input shapes are very variable, XLA will have to recompile your model over and over, which will create huge performance problems. This commonly arises in NLP models, where input texts have variable lengths after tokenization. In other modalities, static shapes are more common and this rule is much less of a problem.\n\nHow can you get around rule #3? The key is **padding** - if you pad all your inputs to the same length, and then use an `attention_mask`, you can get the same results as you\u2019d get from variable shapes, but without any XLA issues. However, excessive padding can cause severe slowdown too - if you pad all your samples to the maximum length in the whole dataset, you might end up with batches consisting endless padding tokens, which will waste a lot of compute and memory!\n\nThere isn\u2019t a perfect solution to this problem. However, you can try some tricks. One very useful trick is to **pad batches of samples up to a multiple of a number like 32 or 64 tokens.** This often only increases the number of tokens by a small amount, but it hugely reduces the number of unique input shapes, because every input shape now has to be a multiple of 32 or 64. Fewer unique input shapes means fewer XLA compilations!\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** Our tokenizers and data collators have methods that can help you here. You can use `padding=\"max_length\"` or `padding=\"longest\"` when calling tokenizers to get them to output padded data. Our tokenizers and data collators also have a `pad_to_multiple_of` argument that you can use to reduce the number of unique input shapes you see!\n\n</Tip>\n\n### How do I actually train my model on TPU?\n\nOnce your training is XLA-compatible and (if you\u2019re using TPU Node / Colab) your dataset has been prepared appropriately, running on TPU is surprisingly easy! All you really need to change in your code is to add a few lines to initialize your TPU, and to ensure that your model and dataset are created inside a `TPUStrategy` scope. Take a look at [our TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) to see this in action!\n\n### Summary\n\nThere was a lot in here, so let\u2019s summarize with a quick checklist you can follow when you want to get your model ready for TPU training:\n\n- Make sure your code follows the three rules of XLA\n- Compile your model with `jit_compile=True` on CPU/GPU and confirm that you can train it with XLA\n- Either load your dataset into memory or use a TPU-compatible dataset loading approach (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Migrate your code either to Colab (with accelerator set to \u201cTPU\u201d) or a TPU VM on Google Cloud\n- Add TPU initializer code (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Create your `TPUStrategy` and make sure dataset loading and model creation are inside the `strategy.scope()` (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Don\u2019t forget to take `jit_compile=True` out again when you move to TPU!\n- \ud83d\ude4f\ud83d\ude4f\ud83d\ude4f\ud83e\udd7a\ud83e\udd7a\ud83e\udd7a\n- Call model.fit()\n- You did it!"
            },
            {
                "score": 0.6106314117379626,
                "node_text": "Here are some facts extracted from the provided text:\n\nTensorflow models -> Are -> Keras models\n\n!--Copyright 2023 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\nthe License. You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under the License is distributed on\nan \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n\n\u26a0\ufe0f Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be\nrendered properly in your Markdown viewer.\n\n-->\n\n# Training on TPU with TensorFlow\n\n<Tip>\n\nIf you don't need long explanations and just want TPU code samples to get started with, check out [our TPU example notebook!](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb)\n\n</Tip>\n\n### What is a TPU?\n\nA TPU is a **Tensor Processing Unit.** They are hardware designed by Google, which are used to greatly speed up the tensor computations within neural networks, much like GPUs. They can be used for both network training and inference. They are generally accessed through Google\u2019s cloud services, but small TPUs can also be accessed directly for free through Google Colab and Kaggle Kernels.\n\nBecause [all TensorFlow models in \ud83e\udd17 Transformers are Keras models](https://huggingface.co/blog/tensorflow-philosophy), most of the methods in this document are generally applicable to TPU training for any Keras model! However, there are a few points that are specific to the HuggingFace ecosystem (hug-o-system?) of Transformers and Datasets, and we\u2019ll make sure to flag them up when we get to them.\n\n### What kinds of TPU are available?\n\nNew users are often very confused by the range of TPUs, and the different ways to access them. The first key distinction to understand is the difference between **TPU Nodes** and **TPU VMs.**\n\nWhen you use a **TPU Node**, you are effectively indirectly accessing a remote TPU. You will need a separate VM, which will initialize your network and data pipeline and then forward them to the remote node. When you use a TPU on Google Colab, you are accessing it in the **TPU Node** style.\n\nUsing TPU Nodes can have some quite unexpected behaviour for people who aren\u2019t used to them! In particular, because the TPU is located on a physically different system to the machine you\u2019re running your Python code on, your data cannot be local to your machine - any data pipeline that loads from your machine\u2019s internal storage will totally fail! Instead, data must be stored in Google Cloud Storage where your data pipeline can still access it, even when the pipeline is running on the remote TPU node.\n\n<Tip>\n\nIf you can fit all your data in memory as `np.ndarray` or `tf.Tensor`, then you can `fit()` on that data even when using Colab or a TPU Node, without needing to upload it to Google Cloud Storage.\n\n</Tip>\n\n<Tip>\n\n**\ud83e\udd17Specific Hugging Face Tip\ud83e\udd17:** The methods `Dataset.to_tf_dataset()` and its higher-level wrapper `model.prepare_tf_dataset()` , which you will see throughout our TF code examples, will both fail on a TPU Node. The reason for this is that even though they create a `tf.data.Dataset` it is not a \u201cpure\u201d `tf.data` pipeline and uses `tf.numpy_function` or `Dataset.from_generator()` to stream data from the underlying HuggingFace `Dataset`. This HuggingFace `Dataset` is backed by data that is on a local disc and which the remote TPU Node will not be able to read.\n\n</Tip>\n\nThe second way to access a TPU is via a **TPU VM.** When using a TPU VM, you connect directly to the machine that the TPU is attached to, much like training on a GPU VM. TPU VMs are generally easier to work with, particularly when it comes to your data pipeline. All of the above warnings do not apply to TPU VMs!\n\nThis is an opinionated document, so here\u2019s our opinion: **Avoid using TPU Node if possible.** It is more confusing and more difficult to debug than TPU VMs. It is also likely to be unsupported in future - Google\u2019s latest TPU, TPUv4, can only be accessed as a TPU VM, which suggests that TPU Nodes are increasingly going to become a \u201clegacy\u201d access method."
            }
        ]
    },
    {
        "sample_idx": 104,
        "question": "What is the name of the tab that shows Tensorboard logs over the course of training?",
        "answer": "The 'Training metrics' tab.",
        "rag_answer": "There is no mention of Tensorboard or a specific tab for showing logs in the provided context. The context primarily discusses training models on Tensor Processing Units (TPUs) with TensorFlow and provides tips for preparing models for TPU training. It does not mention Tensorboard or logging.",
        "rag_score": 1,
        "rag_feedback": "The system's response is completely incorrect, inaccurate, and/or not factual. The response does not provide any information related to the question about the name of the tab that shows Tensorboard logs over the course of training. Instead, it provides a lengthy response about training models on Tensor Processing Units (TPUs) with TensorFlow and provides tips for preparing models for TPU training.",
        "rag_context": [
            {
                "score": 0.6140805206010977,
                "node_text": "Here are some facts extracted from the provided text:\n\nTpu -> Is -> Tensor processing unit\nTpu -> Is used -> For training\nTpu -> Used for -> Neural networks\n\nThis is a really useful trick, so remember it if you need to convert your own code to XLA!\n\n#### XLA Rule #3: XLA will need to recompile your model for every different input shape it sees\n\nThis is the big one. What this means is that if your input shapes are very variable, XLA will have to recompile your model over and over, which will create huge performance problems. This commonly arises in NLP models, where input texts have variable lengths after tokenization. In other modalities, static shapes are more common and this rule is much less of a problem.\n\nHow can you get around rule #3? The key is **padding** - if you pad all your inputs to the same length, and then use an `attention_mask`, you can get the same results as you\u2019d get from variable shapes, but without any XLA issues. However, excessive padding can cause severe slowdown too - if you pad all your samples to the maximum length in the whole dataset, you might end up with batches consisting endless padding tokens, which will waste a lot of compute and memory!\n\nThere isn\u2019t a perfect solution to this problem. However, you can try some tricks. One very useful trick is to **pad batches of samples up to a multiple of a number like 32 or 64 tokens.** This often only increases the number of tokens by a small amount, but it hugely reduces the number of unique input shapes, because every input shape now has to be a multiple of 32 or 64. Fewer unique input shapes means fewer XLA compilations!\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** Our tokenizers and data collators have methods that can help you here. You can use `padding=\"max_length\"` or `padding=\"longest\"` when calling tokenizers to get them to output padded data. Our tokenizers and data collators also have a `pad_to_multiple_of` argument that you can use to reduce the number of unique input shapes you see!\n\n</Tip>\n\n### How do I actually train my model on TPU?\n\nOnce your training is XLA-compatible and (if you\u2019re using TPU Node / Colab) your dataset has been prepared appropriately, running on TPU is surprisingly easy! All you really need to change in your code is to add a few lines to initialize your TPU, and to ensure that your model and dataset are created inside a `TPUStrategy` scope. Take a look at [our TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) to see this in action!\n\n### Summary\n\nThere was a lot in here, so let\u2019s summarize with a quick checklist you can follow when you want to get your model ready for TPU training:\n\n- Make sure your code follows the three rules of XLA\n- Compile your model with `jit_compile=True` on CPU/GPU and confirm that you can train it with XLA\n- Either load your dataset into memory or use a TPU-compatible dataset loading approach (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Migrate your code either to Colab (with accelerator set to \u201cTPU\u201d) or a TPU VM on Google Cloud\n- Add TPU initializer code (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Create your `TPUStrategy` and make sure dataset loading and model creation are inside the `strategy.scope()` (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Don\u2019t forget to take `jit_compile=True` out again when you move to TPU!\n- \ud83d\ude4f\ud83d\ude4f\ud83d\ude4f\ud83e\udd7a\ud83e\udd7a\ud83e\udd7a\n- Call model.fit()\n- You did it!"
            },
            {
                "score": 0.584842900981626,
                "node_text": "Here are some facts extracted from the provided text:\n\nTensorflow models -> Are -> Keras models\n\n!--Copyright 2023 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\nthe License. You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under the License is distributed on\nan \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n\n\u26a0\ufe0f Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be\nrendered properly in your Markdown viewer.\n\n-->\n\n# Training on TPU with TensorFlow\n\n<Tip>\n\nIf you don't need long explanations and just want TPU code samples to get started with, check out [our TPU example notebook!](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb)\n\n</Tip>\n\n### What is a TPU?\n\nA TPU is a **Tensor Processing Unit.** They are hardware designed by Google, which are used to greatly speed up the tensor computations within neural networks, much like GPUs. They can be used for both network training and inference. They are generally accessed through Google\u2019s cloud services, but small TPUs can also be accessed directly for free through Google Colab and Kaggle Kernels.\n\nBecause [all TensorFlow models in \ud83e\udd17 Transformers are Keras models](https://huggingface.co/blog/tensorflow-philosophy), most of the methods in this document are generally applicable to TPU training for any Keras model! However, there are a few points that are specific to the HuggingFace ecosystem (hug-o-system?) of Transformers and Datasets, and we\u2019ll make sure to flag them up when we get to them.\n\n### What kinds of TPU are available?\n\nNew users are often very confused by the range of TPUs, and the different ways to access them. The first key distinction to understand is the difference between **TPU Nodes** and **TPU VMs.**\n\nWhen you use a **TPU Node**, you are effectively indirectly accessing a remote TPU. You will need a separate VM, which will initialize your network and data pipeline and then forward them to the remote node. When you use a TPU on Google Colab, you are accessing it in the **TPU Node** style.\n\nUsing TPU Nodes can have some quite unexpected behaviour for people who aren\u2019t used to them! In particular, because the TPU is located on a physically different system to the machine you\u2019re running your Python code on, your data cannot be local to your machine - any data pipeline that loads from your machine\u2019s internal storage will totally fail! Instead, data must be stored in Google Cloud Storage where your data pipeline can still access it, even when the pipeline is running on the remote TPU node.\n\n<Tip>\n\nIf you can fit all your data in memory as `np.ndarray` or `tf.Tensor`, then you can `fit()` on that data even when using Colab or a TPU Node, without needing to upload it to Google Cloud Storage.\n\n</Tip>\n\n<Tip>\n\n**\ud83e\udd17Specific Hugging Face Tip\ud83e\udd17:** The methods `Dataset.to_tf_dataset()` and its higher-level wrapper `model.prepare_tf_dataset()` , which you will see throughout our TF code examples, will both fail on a TPU Node. The reason for this is that even though they create a `tf.data.Dataset` it is not a \u201cpure\u201d `tf.data` pipeline and uses `tf.numpy_function` or `Dataset.from_generator()` to stream data from the underlying HuggingFace `Dataset`. This HuggingFace `Dataset` is backed by data that is on a local disc and which the remote TPU Node will not be able to read.\n\n</Tip>\n\nThe second way to access a TPU is via a **TPU VM.** When using a TPU VM, you connect directly to the machine that the TPU is attached to, much like training on a GPU VM. TPU VMs are generally easier to work with, particularly when it comes to your data pipeline. All of the above warnings do not apply to TPU VMs!\n\nThis is an opinionated document, so here\u2019s our opinion: **Avoid using TPU Node if possible.** It is more confusing and more difficult to debug than TPU VMs. It is also likely to be unsupported in future - Google\u2019s latest TPU, TPUv4, can only be accessed as a TPU VM, which suggests that TPU Nodes are increasingly going to become a \u201clegacy\u201d access method."
            }
        ]
    },
    {
        "sample_idx": 105,
        "question": "What is the name of the dataset used for fine-tuning LayoutLMv3 for token classification?",
        "answer": "CORD.",
        "rag_answer": "The names of the datasets used for fine-tuning LayoutLMv3 for token classification are FUNSD and CORD.",
        "rag_score": 4,
        "rag_feedback": "The system's response is mostly correct, accurate, and factual. It provides the correct answer, CORD, along with another dataset, FUNSD, which is also relevant to the context. The response is a bit lengthy and includes unnecessary information, but it does contain the expected answer.",
        "rag_context": [
            {
                "score": 0.6805213619006873,
                "node_text": "Here are some facts extracted from the provided text:\n\nLayoutlmv3 -> Is -> Pytorch version\nScript -> Fine-tunes -> Layoutlmv3\nNielsr/layoutlmv3-finetuned-funsd -> Is -> Model\n\n!---\nCopyright 2022 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n-->\n\n# Token classification with LayoutLMv3 (PyTorch version)\n\nThis directory contains a script, `run_funsd_cord.py`, that can be used to fine-tune (or evaluate) LayoutLMv3 on form understanding datasets, such as [FUNSD](https://guillaumejaume.github.io/FUNSD/) and [CORD](https://github.com/clovaai/cord).\n\nThe script `run_funsd_cord.py` leverages the \ud83e\udd17 Datasets library and the Trainer API. You can easily customize it to your needs.\n\n## Fine-tuning on FUNSD\n\nFine-tuning LayoutLMv3 for token classification on [FUNSD](https://guillaumejaume.github.io/FUNSD/) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name funsd \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 1e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-funsd\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd. By specifying the `push_to_hub` flag, the model gets uploaded automatically to the hub (regularly), together with a model card, which includes metrics such as precision, recall and F1. Note that you can easily update the model card, as it's just a README file of the respective repo on the hub.\n\nThere's also the \"Training metrics\" [tab](https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd/tensorboard), which shows Tensorboard logs over the course of training. Pretty neat, huh?\n\n## Fine-tuning on CORD\n\nFine-tuning LayoutLMv3 for token classification on [CORD](https://github.com/clovaai/cord) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name cord \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 5e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-cord\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-cord. Note that a model card gets generated automatically in case you specify the `push_to_hub` flag."
            },
            {
                "score": 0.6744085213199497,
                "node_text": "Here are some facts extracted from the provided text:\n\nTokenizers -> Have -> Padding methods\nHuggingface -> Provides -> Tokenizers\nTpu -> Is used -> For training\n\nThis is a really useful trick, so remember it if you need to convert your own code to XLA!\n\n#### XLA Rule #3: XLA will need to recompile your model for every different input shape it sees\n\nThis is the big one. What this means is that if your input shapes are very variable, XLA will have to recompile your model over and over, which will create huge performance problems. This commonly arises in NLP models, where input texts have variable lengths after tokenization. In other modalities, static shapes are more common and this rule is much less of a problem.\n\nHow can you get around rule #3? The key is **padding** - if you pad all your inputs to the same length, and then use an `attention_mask`, you can get the same results as you\u2019d get from variable shapes, but without any XLA issues. However, excessive padding can cause severe slowdown too - if you pad all your samples to the maximum length in the whole dataset, you might end up with batches consisting endless padding tokens, which will waste a lot of compute and memory!\n\nThere isn\u2019t a perfect solution to this problem. However, you can try some tricks. One very useful trick is to **pad batches of samples up to a multiple of a number like 32 or 64 tokens.** This often only increases the number of tokens by a small amount, but it hugely reduces the number of unique input shapes, because every input shape now has to be a multiple of 32 or 64. Fewer unique input shapes means fewer XLA compilations!\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** Our tokenizers and data collators have methods that can help you here. You can use `padding=\"max_length\"` or `padding=\"longest\"` when calling tokenizers to get them to output padded data. Our tokenizers and data collators also have a `pad_to_multiple_of` argument that you can use to reduce the number of unique input shapes you see!\n\n</Tip>\n\n### How do I actually train my model on TPU?\n\nOnce your training is XLA-compatible and (if you\u2019re using TPU Node / Colab) your dataset has been prepared appropriately, running on TPU is surprisingly easy! All you really need to change in your code is to add a few lines to initialize your TPU, and to ensure that your model and dataset are created inside a `TPUStrategy` scope. Take a look at [our TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) to see this in action!\n\n### Summary\n\nThere was a lot in here, so let\u2019s summarize with a quick checklist you can follow when you want to get your model ready for TPU training:\n\n- Make sure your code follows the three rules of XLA\n- Compile your model with `jit_compile=True` on CPU/GPU and confirm that you can train it with XLA\n- Either load your dataset into memory or use a TPU-compatible dataset loading approach (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Migrate your code either to Colab (with accelerator set to \u201cTPU\u201d) or a TPU VM on Google Cloud\n- Add TPU initializer code (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Create your `TPUStrategy` and make sure dataset loading and model creation are inside the `strategy.scope()` (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Don\u2019t forget to take `jit_compile=True` out again when you move to TPU!\n- \ud83d\ude4f\ud83d\ude4f\ud83d\ude4f\ud83e\udd7a\ud83e\udd7a\ud83e\udd7a\n- Call model.fit()\n- You did it!"
            }
        ]
    },
    {
        "sample_idx": 106,
        "question": "What is the model_id of the resulting model after fine-tuning LayoutLMv3 on CORD?",
        "answer": "layoutlmv3-finetuned-cord.",
        "rag_answer": "The model_id of the resulting model after fine-tuning LayoutLMv3 on CORD is layoutlmv3-finetuned-cord.",
        "rag_score": 5,
        "rag_feedback": "The system's response is completely correct, accurate, and factual. It directly answers the question by stating that the model_id of the resulting model after fine-tuning LayoutLMv3 on CORD is indeed 'layoutlmv3-finetuned-cord'.",
        "rag_context": [
            {
                "score": 1.0,
                "node_text": "Here are some facts extracted from the provided text:\n\nDistilbert-base-uncased-finetuned-sst-2-english -> Is used for -> Text classification\n\nCreate an Endpoint\n\nAfter your first login, you will be directed to the [Endpoint creation page](https://ui.endpoints.huggingface.co/new). As an example, this guide will go through the steps to deploy [distilbert-base-uncased-finetuned-sst-2-english](https://huggingface.co/distilbert-base-uncased-finetuned-sst-2-english) for text classification. \n\n## 1. Enter the Hugging Face Repository ID and your desired endpoint name:\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_repository.png\" alt=\"select repository\" />\n\n## 2. Select your Cloud Provider and region. Initially, only AWS will be available as a Cloud Provider with the `us-east-1` and `eu-west-1` regions. We will add Azure soon, and if you need to test Endpoints with other Cloud Providers or regions, please let us know.\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_region.png\" alt=\"select region\" />\n\n## 3. Define the [Security Level](security) for the Endpoint:\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_security.png\" alt=\"define security\" />\n\n## 4. Create your Endpoint by clicking **Create Endpoint**. By default, your Endpoint is created with a medium CPU (2 x 4GB vCPUs with Intel Xeon Ice Lake) The cost estimate assumes the Endpoint will be up for an entire month, and does not take autoscaling into account.\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_create_cost.png\" alt=\"create endpoint\" />\n\n## 5. Wait for the Endpoint to build, initialize and run which can take between 1 to 5 minutes.\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/overview.png\" alt=\"overview\" />\n\n## 6. Test your Endpoint in the overview with the Inference widget \ud83c\udfc1 \ud83c\udf89!\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_inference.png\" alt=\"run inference\" />"
            },
            {
                "score": 0.6857920162569264,
                "node_text": "Here are some facts extracted from the provided text:\n\nLayoutlmv3 -> Is -> Pytorch version\nScript -> Fine-tunes -> Layoutlmv3\nNielsr/layoutlmv3-finetuned-funsd -> Is -> Model\nCord -> Is -> Form understanding dataset\nRun_funsd_cord.py -> Is -> Script\n\n!---\nCopyright 2022 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n-->\n\n# Token classification with LayoutLMv3 (PyTorch version)\n\nThis directory contains a script, `run_funsd_cord.py`, that can be used to fine-tune (or evaluate) LayoutLMv3 on form understanding datasets, such as [FUNSD](https://guillaumejaume.github.io/FUNSD/) and [CORD](https://github.com/clovaai/cord).\n\nThe script `run_funsd_cord.py` leverages the \ud83e\udd17 Datasets library and the Trainer API. You can easily customize it to your needs.\n\n## Fine-tuning on FUNSD\n\nFine-tuning LayoutLMv3 for token classification on [FUNSD](https://guillaumejaume.github.io/FUNSD/) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name funsd \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 1e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-funsd\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd. By specifying the `push_to_hub` flag, the model gets uploaded automatically to the hub (regularly), together with a model card, which includes metrics such as precision, recall and F1. Note that you can easily update the model card, as it's just a README file of the respective repo on the hub.\n\nThere's also the \"Training metrics\" [tab](https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd/tensorboard), which shows Tensorboard logs over the course of training. Pretty neat, huh?\n\n## Fine-tuning on CORD\n\nFine-tuning LayoutLMv3 for token classification on [CORD](https://github.com/clovaai/cord) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name cord \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 5e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-cord\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-cord. Note that a model card gets generated automatically in case you specify the `push_to_hub` flag."
            }
        ]
    },
    {
        "sample_idx": 107,
        "question": "What flag needs to be specified to generate a model card automatically?",
        "answer": "The 'push_to_hub' flag.",
        "rag_answer": "The flag that needs to be specified to generate a model card automatically is `push_to_hub`.",
        "rag_score": 5,
        "rag_feedback": "The system's response is completely correct, accurate, and factual. It directly answers the question by stating that the flag that needs to be specified to generate a model card automatically is `push_to_hub`. The response is supported by a relevant and accurate context from the provided text.",
        "rag_context": [
            {
                "score": 0.6238018177979417,
                "node_text": "Here are some facts extracted from the provided text:\n\nModel -> Needs -> Question\nModel -> Has -> Input shape\nModel -> Needs -> Context\nModel -> Evaluates on -> Squad\nNielsr/layoutlmv3-finetuned-funsd -> Is -> Model\nModel -> Returns -> Prediction_text\nMicrosoft/layoutlmv3-base -> Is -> Model name or path\n\n!---\nCopyright 2022 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n-->\n\n# Token classification with LayoutLMv3 (PyTorch version)\n\nThis directory contains a script, `run_funsd_cord.py`, that can be used to fine-tune (or evaluate) LayoutLMv3 on form understanding datasets, such as [FUNSD](https://guillaumejaume.github.io/FUNSD/) and [CORD](https://github.com/clovaai/cord).\n\nThe script `run_funsd_cord.py` leverages the \ud83e\udd17 Datasets library and the Trainer API. You can easily customize it to your needs.\n\n## Fine-tuning on FUNSD\n\nFine-tuning LayoutLMv3 for token classification on [FUNSD](https://guillaumejaume.github.io/FUNSD/) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name funsd \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 1e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-funsd\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd. By specifying the `push_to_hub` flag, the model gets uploaded automatically to the hub (regularly), together with a model card, which includes metrics such as precision, recall and F1. Note that you can easily update the model card, as it's just a README file of the respective repo on the hub.\n\nThere's also the \"Training metrics\" [tab](https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd/tensorboard), which shows Tensorboard logs over the course of training. Pretty neat, huh?\n\n## Fine-tuning on CORD\n\nFine-tuning LayoutLMv3 for token classification on [CORD](https://github.com/clovaai/cord) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name cord \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 5e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-cord\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-cord. Note that a model card gets generated automatically in case you specify the `push_to_hub` flag."
            },
            {
                "score": 0.6238018177979417,
                "node_text": "Here are some facts extracted from the provided text:\n\nXla -> Recompile -> Model\n\nThis is a really useful trick, so remember it if you need to convert your own code to XLA!\n\n#### XLA Rule #3: XLA will need to recompile your model for every different input shape it sees\n\nThis is the big one. What this means is that if your input shapes are very variable, XLA will have to recompile your model over and over, which will create huge performance problems. This commonly arises in NLP models, where input texts have variable lengths after tokenization. In other modalities, static shapes are more common and this rule is much less of a problem.\n\nHow can you get around rule #3? The key is **padding** - if you pad all your inputs to the same length, and then use an `attention_mask`, you can get the same results as you\u2019d get from variable shapes, but without any XLA issues. However, excessive padding can cause severe slowdown too - if you pad all your samples to the maximum length in the whole dataset, you might end up with batches consisting endless padding tokens, which will waste a lot of compute and memory!\n\nThere isn\u2019t a perfect solution to this problem. However, you can try some tricks. One very useful trick is to **pad batches of samples up to a multiple of a number like 32 or 64 tokens.** This often only increases the number of tokens by a small amount, but it hugely reduces the number of unique input shapes, because every input shape now has to be a multiple of 32 or 64. Fewer unique input shapes means fewer XLA compilations!\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** Our tokenizers and data collators have methods that can help you here. You can use `padding=\"max_length\"` or `padding=\"longest\"` when calling tokenizers to get them to output padded data. Our tokenizers and data collators also have a `pad_to_multiple_of` argument that you can use to reduce the number of unique input shapes you see!\n\n</Tip>\n\n### How do I actually train my model on TPU?\n\nOnce your training is XLA-compatible and (if you\u2019re using TPU Node / Colab) your dataset has been prepared appropriately, running on TPU is surprisingly easy! All you really need to change in your code is to add a few lines to initialize your TPU, and to ensure that your model and dataset are created inside a `TPUStrategy` scope. Take a look at [our TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) to see this in action!\n\n### Summary\n\nThere was a lot in here, so let\u2019s summarize with a quick checklist you can follow when you want to get your model ready for TPU training:\n\n- Make sure your code follows the three rules of XLA\n- Compile your model with `jit_compile=True` on CPU/GPU and confirm that you can train it with XLA\n- Either load your dataset into memory or use a TPU-compatible dataset loading approach (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Migrate your code either to Colab (with accelerator set to \u201cTPU\u201d) or a TPU VM on Google Cloud\n- Add TPU initializer code (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Create your `TPUStrategy` and make sure dataset loading and model creation are inside the `strategy.scope()` (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Don\u2019t forget to take `jit_compile=True` out again when you move to TPU!\n- \ud83d\ude4f\ud83d\ude4f\ud83d\ude4f\ud83e\udd7a\ud83e\udd7a\ud83e\udd7a\n- Call model.fit()\n- You did it!"
            },
            {
                "score": 0.5934277478176994,
                "node_text": "Here are some facts extracted from the provided text:\n\nInference widget -> Is used for -> Testing endpoint\n\nCreate an Endpoint\n\nAfter your first login, you will be directed to the [Endpoint creation page](https://ui.endpoints.huggingface.co/new). As an example, this guide will go through the steps to deploy [distilbert-base-uncased-finetuned-sst-2-english](https://huggingface.co/distilbert-base-uncased-finetuned-sst-2-english) for text classification. \n\n## 1. Enter the Hugging Face Repository ID and your desired endpoint name:\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_repository.png\" alt=\"select repository\" />\n\n## 2. Select your Cloud Provider and region. Initially, only AWS will be available as a Cloud Provider with the `us-east-1` and `eu-west-1` regions. We will add Azure soon, and if you need to test Endpoints with other Cloud Providers or regions, please let us know.\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_region.png\" alt=\"select region\" />\n\n## 3. Define the [Security Level](security) for the Endpoint:\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_security.png\" alt=\"define security\" />\n\n## 4. Create your Endpoint by clicking **Create Endpoint**. By default, your Endpoint is created with a medium CPU (2 x 4GB vCPUs with Intel Xeon Ice Lake) The cost estimate assumes the Endpoint will be up for an entire month, and does not take autoscaling into account.\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_create_cost.png\" alt=\"create endpoint\" />\n\n## 5. Wait for the Endpoint to build, initialize and run which can take between 1 to 5 minutes.\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/overview.png\" alt=\"overview\" />\n\n## 6. Test your Endpoint in the overview with the Inference widget \ud83c\udfc1 \ud83c\udf89!\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_inference.png\" alt=\"run inference\" />"
            },
            {
                "score": 0.5868540756790134,
                "node_text": "Here are some facts extracted from the provided text:\n\nGradio -> Supports -> Hugging face models\n\nGradio Demo: blocks_random_slider\n\n\n```\n!pip install -q gradio \n```\n\n\n```\n\nimport gradio as gr\n\n\ndef func(slider_1, slider_2):\n    return slider_1 * 5 + slider_2\n\n\nwith gr.Blocks() as demo:\n    slider = gr.Slider(minimum=-10.2, maximum=15, label=\"Random Slider (Static)\", randomize=True)\n    slider_1 = gr.Slider(minimum=100, maximum=200, label=\"Random Slider (Input 1)\", randomize=True)\n    slider_2 = gr.Slider(minimum=10, maximum=23.2, label=\"Random Slider (Input 2)\", randomize=True)\n    slider_3 = gr.Slider(value=3, label=\"Non random slider\")\n    btn = gr.Button(\"Run\")\n    btn.click(func, inputs=[slider_1, slider_2], outputs=gr.Number())\n\nif __name__ == \"__main__\":\n    demo.launch()\n\n```"
            }
        ]
    },
    {
        "sample_idx": 108,
        "question": "How does global state in Blocks work?",
        "answer": "Global state in Blocks works the same as in Interface, where any variable created outside a function call is a reference shared between all users.",
        "rag_answer": "Global state in Blocks works the same as in Interface. Any variable created outside a function call is a reference shared between all users.",
        "rag_score": 5,
        "rag_feedback": "The system's response is completely correct, accurate, and factual. It matches the expected answer and provides additional relevant information about global state in Blocks.",
        "rag_context": [
            {
                "score": 0.7033546060411434,
                "node_text": "Here are some facts extracted from the provided text:\n\nGlobal state -> Is -> Reference shared between all users\nState in blocks -> Works -> Same as in interface\nState object -> Has -> Default value\n\nState in Blocks\n\nWe covered [State in Interfaces](https://gradio.app/interface-state), this guide takes a look at state in Blocks, which works mostly the same.\n\n## Global State\n\nGlobal state in Blocks works the same as in Interface. Any variable created outside a function call is a reference shared between all users.\n\n## Session State\n\nGradio supports session **state**, where data persists across multiple submits within a page session, in Blocks apps as well. To reiterate, session data is _not_ shared between different users of your model. To store data in a session state, you need to do three things:\n\n1. Create a `gr.State()` object. If there is a default value to this stateful object, pass that into the constructor.\n2. In the event listener, put the `State` object as an input and output.\n3. In the event listener function, add the variable to the input parameters and the return value.\n\nLet's take a look at a game of hangman.\n\n$code_hangman\n$demo_hangman\n\nLet's see how we do each of the 3 steps listed above in this game:\n\n1. We store the used letters in `used_letters_var`. In the constructor of `State`, we set the initial value of this to `[]`, an empty list.\n2. In `btn.click()`, we have a reference to `used_letters_var` in both the inputs and outputs.\n3. In `guess_letter`, we pass the value of this `State` to `used_letters`, and then return an updated value of this `State` in the return statement.\n\nWith more complex apps, you will likely have many State variables storing session state in a single Blocks app.\n\nLearn more about `State` in the [docs](https://gradio.app/docs#state)."
            },
            {
                "score": 0.6583093473641121,
                "node_text": "Here are some facts extracted from the provided text:\n\nBlocks -> Is -> Demo\n\nBlocks() as demo\uff1a\n    #.\ndemo.queue()\ndemo.launch()\n```\n\n\u60a8\u53ef\u4ee5\u901a\u8fc7\u4ee5\u4e0b\u65b9\u5f0f\u63a7\u5236\u4e00\u6b21\u5904\u7406\u7684\u8bf7\u6c42\u6570\u91cf\uff1a\n\n```python\ndemo.queue(concurrency_count=3)\n```\n\n\u67e5\u770b\u6709\u5173\u914d\u7f6e\u5176\u4ed6\u961f\u5217\u53c2\u6570\u7684[\u961f\u5217\u6587\u6863](/docs/#queue)\u3002\n\n\u5728 Blocks \u4e2d\u6307\u5b9a\u4ec5\u5bf9\u67d0\u4e9b\u51fd\u6570\u8fdb\u884c\u6392\u961f\uff1a\n\n```python\nwith gr.Blocks() as demo2\uff1a\n    num1 = gr.Number()\n    num2 = gr.Number()\n    output = gr.Number()\n    gr.Button(\"Add\").click(\n        lambda a, b: a + b, [num1, num2], output)\n    gr.Button(\"Multiply\").click(\n        lambda a, b: a * b, [num1, num2], output, queue=True)\ndemo2.launch()\n```\n\n## \u8fed\u4ee3\u8f93\u51fa (Iterative Outputs)\n\n\u5728\u67d0\u4e9b\u60c5\u51b5\u4e0b\uff0c\u60a8\u53ef\u80fd\u9700\u8981\u4f20\u8f93\u4e00\u7cfb\u5217\u8f93\u51fa\u800c\u4e0d\u662f\u4e00\u6b21\u663e\u793a\u5355\u4e2a\u8f93\u51fa\u3002\u4f8b\u5982\uff0c\u60a8\u53ef\u80fd\u6709\u4e00\u4e2a\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5e0c\u671b\u663e\u793a\u751f\u6210\u7684\u6bcf\u4e2a\u6b65\u9aa4\u7684\u56fe\u50cf\uff0c\u76f4\u5230\u6700\u7ec8\u56fe\u50cf\u3002\u6216\u8005\u60a8\u53ef\u80fd\u6709\u4e00\u4e2a\u804a\u5929\u673a\u5668\u4eba\uff0c\u5b83\u9010\u5b57\u9010\u53e5\u5730\u6d41\u5f0f\u4f20\u8f93\u54cd\u5e94\uff0c\u800c\u4e0d\u662f\u4e00\u6b21\u8fd4\u56de\u5168\u90e8\u54cd\u5e94\u3002\n\n\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u60a8\u53ef\u4ee5\u5c06**\u751f\u6210\u5668**\u51fd\u6570\u63d0\u4f9b\u7ed9 Gradio\uff0c\u800c\u4e0d\u662f\u5e38\u89c4\u51fd\u6570\u3002\u5728 Python \u4e2d\u521b\u5efa\u751f\u6210\u5668\u975e\u5e38\u7b80\u5355\uff1a\u51fd\u6570\u4e0d\u5e94\u8be5\u6709\u4e00\u4e2a\u5355\u72ec\u7684 `return` \u503c\uff0c\u800c\u662f\u5e94\u8be5 with `yield` \u8fde\u7eed\u8fd4\u56de\u4e00\u7cfb\u5217\u503c\u3002\u901a\u5e38\uff0c`yield` \u8bed\u53e5\u653e\u7f6e\u5728\u67d0\u79cd\u5faa\u73af\u4e2d\u3002\u4e0b\u9762\u662f\u4e00\u4e2a\u7b80\u5355\u793a\u4f8b\uff0c\u751f\u6210\u5668\u53ea\u662f\u7b80\u5355\u8ba1\u6570\u5230\u7ed9\u5b9a\u6570\u5b57\uff1a\n\n```python\ndef my_generator(x):\n    for i in range(x):\n        yield i\n```\n\n\u60a8\u4ee5\u4e0e\u5e38\u89c4\u51fd\u6570\u76f8\u540c\u7684\u65b9\u5f0f\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio\u3002\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\uff08\u865a\u62df\u7684\uff09\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5b83\u5728\u8f93\u51fa\u56fe\u50cf\u4e4b\u524d\u751f\u6210\u6570\u4e2a\u6b65\u9aa4\u7684\u566a\u97f3\uff1a\n\n$code_fake_diffusion\n$demo_fake_diffusion\n\n\u8bf7\u6ce8\u610f\uff0c\u6211\u4eec\u5728\u8fed\u4ee3\u5668\u4e2d\u6dfb\u52a0\u4e86 `time.sleep(1)`\uff0c\u4ee5\u521b\u5efa\u6b65\u9aa4\u4e4b\u95f4\u7684\u4eba\u5de5\u6682\u505c\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u89c2\u5bdf\u8fed\u4ee3\u5668\u7684\u6b65\u9aa4\uff08\u5728\u771f\u5b9e\u7684\u56fe\u50cf\u751f\u6210\u6a21\u578b\u4e2d\uff0c\u8fd9\u53ef\u80fd\u662f\u4e0d\u5fc5\u8981\u7684\uff09\u3002\n\n\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio **\u9700\u8981**\u5728\u5e95\u5c42 Interface \u6216 Blocks \u4e2d\u542f\u7528\u961f\u5217\uff08\u8bf7\u53c2\u9605\u4e0a\u9762\u7684\u961f\u5217\u90e8\u5206\uff09\u3002\n\n## \u8fdb\u5ea6\u6761\n\nGradio \u652f\u6301\u521b\u5efa\u81ea\u5b9a\u4e49\u8fdb\u5ea6\u6761\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u81ea\u5b9a\u4e49\u548c\u63a7\u5236\u5411\u7528\u6237\u663e\u793a\u7684\u8fdb\u5ea6\u66f4\u65b0\u3002\u8981\u542f\u7528\u6b64\u529f\u80fd\uff0c\u53ea\u9700\u4e3a\u65b9\u6cd5\u6dfb\u52a0\u4e00\u4e2a\u9ed8\u8ba4\u503c\u4e3a `gr.Progress` \u5b9e\u4f8b\u7684\u53c2\u6570\u5373\u53ef\u3002\u7136\u540e\uff0c\u60a8\u53ef\u4ee5\u76f4\u63a5\u8c03\u7528\u6b64\u5b9e\u4f8b\u5e76\u4f20\u5165 0 \u5230 1 \u4e4b\u95f4\u7684\u6d6e\u70b9\u6570\u6765\u66f4\u65b0\u8fdb\u5ea6\u7ea7\u522b\uff0c\u6216\u8005 with `Progress` \u5b9e\u4f8b\u7684 `tqdm()` \u65b9\u6cd5\u6765\u8ddf\u8e2a\u53ef\u8fed\u4ee3\u5bf9\u8c61\u4e0a\u7684\u8fdb\u5ea6\uff0c\u5982\u4e0b\u6240\u793a\u3002\u5fc5\u987b\u542f\u7528\u961f\u5217\u4ee5\u8fdb\u884c\u8fdb\u5ea6\u66f4\u65b0\u3002\n\n$code_progress_simple\n$demo_progress_simple\n\n\u5982\u679c\u60a8 with `tqdm` \u5e93\uff0c\u5e76\u4e14\u5e0c\u671b\u4ece\u51fd\u6570\u5185\u90e8\u7684\u4efb\u4f55 `tqdm.tqdm` \u81ea\u52a8\u62a5\u544a\u8fdb\u5ea6\u66f4\u65b0\uff0c\u8bf7\u5c06\u9ed8\u8ba4\u53c2\u6570\u8bbe\u7f6e\u4e3a `gr.Progress(track_tqdm=True)`\uff01\n\n## \u6279\u5904\u7406\u51fd\u6570 (Batch Functions)\n\nGradio \u652f\u6301\u4f20\u9012*\u6279\u5904\u7406*\u51fd\u6570\u3002\u6279\u5904\u7406\u51fd\u6570\u53ea\u662f\u63a5\u53d7\u8f93\u5165\u5217\u8868\u5e76\u8fd4\u56de\u9884\u6d4b\u5217\u8868\u7684\u51fd\u6570\u3002\n\n\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\u6279\u5904\u7406\u51fd\u6570\uff0c\u5b83\u63a5\u53d7\u4e24\u4e2a\u8f93\u5165\u5217\u8868\uff08\u4e00\u4e2a\u5355\u8bcd\u5217\u8868\u548c\u4e00\u4e2a\u6574\u6570\u5217\u8868\uff09\uff0c\u5e76\u8fd4\u56de\u4fee\u526a\u8fc7\u7684\u5355\u8bcd\u5217\u8868\u4f5c\u4e3a\u8f93\u51fa\uff1a\n\n```python\nimport time\n\ndef trim_words(words, lens):\n    trimmed_words = []\n    time.sleep(5)\n    for w, l in zip(words, lens):\n        trimmed_words.append(w[:int(l)])\n    return [trimmed_words]\n    for w, l in zip(words,"
            }
        ]
    },
    {
        "sample_idx": 109,
        "question": "What is session state in Gradio Blocks apps?",
        "answer": "Session state is where data persists across multiple submits within a page session, but is not shared between different users of your model.",
        "rag_answer": "Session state in Gradio Blocks apps is where data persists across multiple submits within a page session, and it is not shared between different users of your model.",
        "rag_score": 5,
        "rag_feedback": "The system's response is completely correct, accurate, and factual. It provides a clear and concise definition of session state in Gradio Blocks apps, which matches the expected answer.",
        "rag_context": [
            {
                "score": 0.7084756561473455,
                "node_text": "Here are some facts extracted from the provided text:\n\nSession state -> Persists -> Across multiple submits within a page session\nSession data -> Is not -> Shared between different users\n\nState in Blocks\n\nWe covered [State in Interfaces](https://gradio.app/interface-state), this guide takes a look at state in Blocks, which works mostly the same.\n\n## Global State\n\nGlobal state in Blocks works the same as in Interface. Any variable created outside a function call is a reference shared between all users.\n\n## Session State\n\nGradio supports session **state**, where data persists across multiple submits within a page session, in Blocks apps as well. To reiterate, session data is _not_ shared between different users of your model. To store data in a session state, you need to do three things:\n\n1. Create a `gr.State()` object. If there is a default value to this stateful object, pass that into the constructor.\n2. In the event listener, put the `State` object as an input and output.\n3. In the event listener function, add the variable to the input parameters and the return value.\n\nLet's take a look at a game of hangman.\n\n$code_hangman\n$demo_hangman\n\nLet's see how we do each of the 3 steps listed above in this game:\n\n1. We store the used letters in `used_letters_var`. In the constructor of `State`, we set the initial value of this to `[]`, an empty list.\n2. In `btn.click()`, we have a reference to `used_letters_var` in both the inputs and outputs.\n3. In `guess_letter`, we pass the value of this `State` to `used_letters`, and then return an updated value of this `State` in the return statement.\n\nWith more complex apps, you will likely have many State variables storing session state in a single Blocks app.\n\nLearn more about `State` in the [docs](https://gradio.app/docs#state)."
            },
            {
                "score": 0.6793520695914432,
                "node_text": "Here are some facts extracted from the provided text:\n\nGenerator function -> Is -> Provided to gradio\n\nBlocks() as demo\uff1a\n    #.\ndemo.queue()\ndemo.launch()\n```\n\n\u60a8\u53ef\u4ee5\u901a\u8fc7\u4ee5\u4e0b\u65b9\u5f0f\u63a7\u5236\u4e00\u6b21\u5904\u7406\u7684\u8bf7\u6c42\u6570\u91cf\uff1a\n\n```python\ndemo.queue(concurrency_count=3)\n```\n\n\u67e5\u770b\u6709\u5173\u914d\u7f6e\u5176\u4ed6\u961f\u5217\u53c2\u6570\u7684[\u961f\u5217\u6587\u6863](/docs/#queue)\u3002\n\n\u5728 Blocks \u4e2d\u6307\u5b9a\u4ec5\u5bf9\u67d0\u4e9b\u51fd\u6570\u8fdb\u884c\u6392\u961f\uff1a\n\n```python\nwith gr.Blocks() as demo2\uff1a\n    num1 = gr.Number()\n    num2 = gr.Number()\n    output = gr.Number()\n    gr.Button(\"Add\").click(\n        lambda a, b: a + b, [num1, num2], output)\n    gr.Button(\"Multiply\").click(\n        lambda a, b: a * b, [num1, num2], output, queue=True)\ndemo2.launch()\n```\n\n## \u8fed\u4ee3\u8f93\u51fa (Iterative Outputs)\n\n\u5728\u67d0\u4e9b\u60c5\u51b5\u4e0b\uff0c\u60a8\u53ef\u80fd\u9700\u8981\u4f20\u8f93\u4e00\u7cfb\u5217\u8f93\u51fa\u800c\u4e0d\u662f\u4e00\u6b21\u663e\u793a\u5355\u4e2a\u8f93\u51fa\u3002\u4f8b\u5982\uff0c\u60a8\u53ef\u80fd\u6709\u4e00\u4e2a\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5e0c\u671b\u663e\u793a\u751f\u6210\u7684\u6bcf\u4e2a\u6b65\u9aa4\u7684\u56fe\u50cf\uff0c\u76f4\u5230\u6700\u7ec8\u56fe\u50cf\u3002\u6216\u8005\u60a8\u53ef\u80fd\u6709\u4e00\u4e2a\u804a\u5929\u673a\u5668\u4eba\uff0c\u5b83\u9010\u5b57\u9010\u53e5\u5730\u6d41\u5f0f\u4f20\u8f93\u54cd\u5e94\uff0c\u800c\u4e0d\u662f\u4e00\u6b21\u8fd4\u56de\u5168\u90e8\u54cd\u5e94\u3002\n\n\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u60a8\u53ef\u4ee5\u5c06**\u751f\u6210\u5668**\u51fd\u6570\u63d0\u4f9b\u7ed9 Gradio\uff0c\u800c\u4e0d\u662f\u5e38\u89c4\u51fd\u6570\u3002\u5728 Python \u4e2d\u521b\u5efa\u751f\u6210\u5668\u975e\u5e38\u7b80\u5355\uff1a\u51fd\u6570\u4e0d\u5e94\u8be5\u6709\u4e00\u4e2a\u5355\u72ec\u7684 `return` \u503c\uff0c\u800c\u662f\u5e94\u8be5 with `yield` \u8fde\u7eed\u8fd4\u56de\u4e00\u7cfb\u5217\u503c\u3002\u901a\u5e38\uff0c`yield` \u8bed\u53e5\u653e\u7f6e\u5728\u67d0\u79cd\u5faa\u73af\u4e2d\u3002\u4e0b\u9762\u662f\u4e00\u4e2a\u7b80\u5355\u793a\u4f8b\uff0c\u751f\u6210\u5668\u53ea\u662f\u7b80\u5355\u8ba1\u6570\u5230\u7ed9\u5b9a\u6570\u5b57\uff1a\n\n```python\ndef my_generator(x):\n    for i in range(x):\n        yield i\n```\n\n\u60a8\u4ee5\u4e0e\u5e38\u89c4\u51fd\u6570\u76f8\u540c\u7684\u65b9\u5f0f\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio\u3002\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\uff08\u865a\u62df\u7684\uff09\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5b83\u5728\u8f93\u51fa\u56fe\u50cf\u4e4b\u524d\u751f\u6210\u6570\u4e2a\u6b65\u9aa4\u7684\u566a\u97f3\uff1a\n\n$code_fake_diffusion\n$demo_fake_diffusion\n\n\u8bf7\u6ce8\u610f\uff0c\u6211\u4eec\u5728\u8fed\u4ee3\u5668\u4e2d\u6dfb\u52a0\u4e86 `time.sleep(1)`\uff0c\u4ee5\u521b\u5efa\u6b65\u9aa4\u4e4b\u95f4\u7684\u4eba\u5de5\u6682\u505c\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u89c2\u5bdf\u8fed\u4ee3\u5668\u7684\u6b65\u9aa4\uff08\u5728\u771f\u5b9e\u7684\u56fe\u50cf\u751f\u6210\u6a21\u578b\u4e2d\uff0c\u8fd9\u53ef\u80fd\u662f\u4e0d\u5fc5\u8981\u7684\uff09\u3002\n\n\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio **\u9700\u8981**\u5728\u5e95\u5c42 Interface \u6216 Blocks \u4e2d\u542f\u7528\u961f\u5217\uff08\u8bf7\u53c2\u9605\u4e0a\u9762\u7684\u961f\u5217\u90e8\u5206\uff09\u3002\n\n## \u8fdb\u5ea6\u6761\n\nGradio \u652f\u6301\u521b\u5efa\u81ea\u5b9a\u4e49\u8fdb\u5ea6\u6761\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u81ea\u5b9a\u4e49\u548c\u63a7\u5236\u5411\u7528\u6237\u663e\u793a\u7684\u8fdb\u5ea6\u66f4\u65b0\u3002\u8981\u542f\u7528\u6b64\u529f\u80fd\uff0c\u53ea\u9700\u4e3a\u65b9\u6cd5\u6dfb\u52a0\u4e00\u4e2a\u9ed8\u8ba4\u503c\u4e3a `gr.Progress` \u5b9e\u4f8b\u7684\u53c2\u6570\u5373\u53ef\u3002\u7136\u540e\uff0c\u60a8\u53ef\u4ee5\u76f4\u63a5\u8c03\u7528\u6b64\u5b9e\u4f8b\u5e76\u4f20\u5165 0 \u5230 1 \u4e4b\u95f4\u7684\u6d6e\u70b9\u6570\u6765\u66f4\u65b0\u8fdb\u5ea6\u7ea7\u522b\uff0c\u6216\u8005 with `Progress` \u5b9e\u4f8b\u7684 `tqdm()` \u65b9\u6cd5\u6765\u8ddf\u8e2a\u53ef\u8fed\u4ee3\u5bf9\u8c61\u4e0a\u7684\u8fdb\u5ea6\uff0c\u5982\u4e0b\u6240\u793a\u3002\u5fc5\u987b\u542f\u7528\u961f\u5217\u4ee5\u8fdb\u884c\u8fdb\u5ea6\u66f4\u65b0\u3002\n\n$code_progress_simple\n$demo_progress_simple\n\n\u5982\u679c\u60a8 with `tqdm` \u5e93\uff0c\u5e76\u4e14\u5e0c\u671b\u4ece\u51fd\u6570\u5185\u90e8\u7684\u4efb\u4f55 `tqdm.tqdm` \u81ea\u52a8\u62a5\u544a\u8fdb\u5ea6\u66f4\u65b0\uff0c\u8bf7\u5c06\u9ed8\u8ba4\u53c2\u6570\u8bbe\u7f6e\u4e3a `gr.Progress(track_tqdm=True)`\uff01\n\n## \u6279\u5904\u7406\u51fd\u6570 (Batch Functions)\n\nGradio \u652f\u6301\u4f20\u9012*\u6279\u5904\u7406*\u51fd\u6570\u3002\u6279\u5904\u7406\u51fd\u6570\u53ea\u662f\u63a5\u53d7\u8f93\u5165\u5217\u8868\u5e76\u8fd4\u56de\u9884\u6d4b\u5217\u8868\u7684\u51fd\u6570\u3002\n\n\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\u6279\u5904\u7406\u51fd\u6570\uff0c\u5b83\u63a5\u53d7\u4e24\u4e2a\u8f93\u5165\u5217\u8868\uff08\u4e00\u4e2a\u5355\u8bcd\u5217\u8868\u548c\u4e00\u4e2a\u6574\u6570\u5217\u8868\uff09\uff0c\u5e76\u8fd4\u56de\u4fee\u526a\u8fc7\u7684\u5355\u8bcd\u5217\u8868\u4f5c\u4e3a\u8f93\u51fa\uff1a\n\n```python\nimport time\n\ndef trim_words(words, lens):\n    trimmed_words = []\n    time.sleep(5)\n    for w, l in zip(words, lens):\n        trimmed_words.append(w[:int(l)])\n    return [trimmed_words]\n    for w, l in zip(words,"
            },
            {
                "score": 0.6737033490760611,
                "node_text": "Here are some facts extracted from the provided text:\n\nGr -> Is -> Alias of gradio\n\nGradio Demo: blocks_random_slider\n\n\n```\n!pip install -q gradio \n```\n\n\n```\n\nimport gradio as gr\n\n\ndef func(slider_1, slider_2):\n    return slider_1 * 5 + slider_2\n\n\nwith gr.Blocks() as demo:\n    slider = gr.Slider(minimum=-10.2, maximum=15, label=\"Random Slider (Static)\", randomize=True)\n    slider_1 = gr.Slider(minimum=100, maximum=200, label=\"Random Slider (Input 1)\", randomize=True)\n    slider_2 = gr.Slider(minimum=10, maximum=23.2, label=\"Random Slider (Input 2)\", randomize=True)\n    slider_3 = gr.Slider(value=3, label=\"Non random slider\")\n    btn = gr.Button(\"Run\")\n    btn.click(func, inputs=[slider_1, slider_2], outputs=gr.Number())\n\nif __name__ == \"__main__\":\n    demo.launch()\n\n```"
            }
        ]
    },
    {
        "sample_idx": 110,
        "question": "What are the three things needed to store data in a session state in Gradio Blocks?",
        "answer": "To store data in a session state, you need to create a gr.State() object, put the State object as an input and output in the event listener, and add the variable to the input parameters and the return value in the event listener function.",
        "rag_answer": "To store data in a session state in Gradio Blocks, you need to do three things: \n\n1. Create a `gr.State()` object, and if there is a default value to this stateful object, pass that into the constructor.\n\n2. In the event listener, put the `State` object as an input and output.\n\n3. In the event listener function, add the variable to the input parameters and the return value.",
        "rag_score": 5,
        "rag_feedback": "The system's response is completely correct, accurate, and factual. It provides the three necessary steps to store data in a session state in Gradio Blocks, which are creating a gr.State() object, putting the State object as an input and output in the event listener, and adding the variable to the input parameters and the return value in the event listener function.",
        "rag_context": [
            {
                "score": 1.0,
                "node_text": "Here are some facts extracted from the provided text:\n\nSession state -> Persists -> Across multiple submits within a page session\n\nState in Blocks\n\nWe covered [State in Interfaces](https://gradio.app/interface-state), this guide takes a look at state in Blocks, which works mostly the same.\n\n## Global State\n\nGlobal state in Blocks works the same as in Interface. Any variable created outside a function call is a reference shared between all users.\n\n## Session State\n\nGradio supports session **state**, where data persists across multiple submits within a page session, in Blocks apps as well. To reiterate, session data is _not_ shared between different users of your model. To store data in a session state, you need to do three things:\n\n1. Create a `gr.State()` object. If there is a default value to this stateful object, pass that into the constructor.\n2. In the event listener, put the `State` object as an input and output.\n3. In the event listener function, add the variable to the input parameters and the return value.\n\nLet's take a look at a game of hangman.\n\n$code_hangman\n$demo_hangman\n\nLet's see how we do each of the 3 steps listed above in this game:\n\n1. We store the used letters in `used_letters_var`. In the constructor of `State`, we set the initial value of this to `[]`, an empty list.\n2. In `btn.click()`, we have a reference to `used_letters_var` in both the inputs and outputs.\n3. In `guess_letter`, we pass the value of this `State` to `used_letters`, and then return an updated value of this `State` in the return statement.\n\nWith more complex apps, you will likely have many State variables storing session state in a single Blocks app.\n\nLearn more about `State` in the [docs](https://gradio.app/docs#state)."
            },
            {
                "score": 0.6489085394618402,
                "node_text": "Here are some facts extracted from the provided text:\n\nGr -> Is -> Alias of gradio\nGradio -> Provides -> Pre-built themes\nGradio -> Is -> Library\nGradio -> Supports -> Iterative outputs\nGradio -> Has feature -> \u6dfb\u52a0\u63cf\u8ff0\u5185\u5bb9\nGradio -> Converts -> Data format\nGradio -> Has feature -> \u8fdb\u5ea6\u6761\nGradio -> Automatically handles -> Preprocessing\nGradio -> Has feature -> \u8bbe\u7f6e\u65d7\u6807\nGradio -> Has feature -> \u8fed\u4ee3\u8f93\u51fa\nGradio -> Has feature -> \u9884\u5904\u7406\u548c\u540e\u5904\u7406\nGradio -> Installed by -> Pip\nGradio -> Has feature -> \u6392\u961f\u7528\u6237\nGradio -> Recognizes -> Data format\nGradio -> Automatically handles -> Postprocessing\nGradio -> Supports -> Hugging face models\nGradio -> Supports -> Batch functions\nGradio -> Enables -> Parallel processing\nGradio -> Has feature -> \u6279\u5904\u7406\u51fd\u6570\nGradio -> Has feature -> \u4f20\u9012\u81ea\u5b9a\u4e49\u9519\u8bef\u6d88\u606f\nGradio -> Can run -> In colab notebooks\nGradio -> Supports -> Progress bars\nGradio -> Includes -> Components\nGradio -> Has feature -> \u6837\u5f0f\u5316\u6f14\u793a\nGradio -> Has feature -> \u6dfb\u52a0\u793a\u4f8b\u8f93\u5165\n\nGradio Demo: blocks_random_slider\n\n\n```\n!pip install -q gradio \n```\n\n\n```\n\nimport gradio as gr\n\n\ndef func(slider_1, slider_2):\n    return slider_1 * 5 + slider_2\n\n\nwith gr.Blocks() as demo:\n    slider = gr.Slider(minimum=-10.2, maximum=15, label=\"Random Slider (Static)\", randomize=True)\n    slider_1 = gr.Slider(minimum=100, maximum=200, label=\"Random Slider (Input 1)\", randomize=True)\n    slider_2 = gr.Slider(minimum=10, maximum=23.2, label=\"Random Slider (Input 2)\", randomize=True)\n    slider_3 = gr.Slider(value=3, label=\"Non random slider\")\n    btn = gr.Button(\"Run\")\n    btn.click(func, inputs=[slider_1, slider_2], outputs=gr.Number())\n\nif __name__ == \"__main__\":\n    demo.launch()\n\n```"
            },
            {
                "score": 0.6443359094726282,
                "node_text": "Here are some facts extracted from the provided text:\n\nGenerator function -> Is -> Provided to gradio\n\nBlocks() as demo\uff1a\n    #.\ndemo.queue()\ndemo.launch()\n```\n\n\u60a8\u53ef\u4ee5\u901a\u8fc7\u4ee5\u4e0b\u65b9\u5f0f\u63a7\u5236\u4e00\u6b21\u5904\u7406\u7684\u8bf7\u6c42\u6570\u91cf\uff1a\n\n```python\ndemo.queue(concurrency_count=3)\n```\n\n\u67e5\u770b\u6709\u5173\u914d\u7f6e\u5176\u4ed6\u961f\u5217\u53c2\u6570\u7684[\u961f\u5217\u6587\u6863](/docs/#queue)\u3002\n\n\u5728 Blocks \u4e2d\u6307\u5b9a\u4ec5\u5bf9\u67d0\u4e9b\u51fd\u6570\u8fdb\u884c\u6392\u961f\uff1a\n\n```python\nwith gr.Blocks() as demo2\uff1a\n    num1 = gr.Number()\n    num2 = gr.Number()\n    output = gr.Number()\n    gr.Button(\"Add\").click(\n        lambda a, b: a + b, [num1, num2], output)\n    gr.Button(\"Multiply\").click(\n        lambda a, b: a * b, [num1, num2], output, queue=True)\ndemo2.launch()\n```\n\n## \u8fed\u4ee3\u8f93\u51fa (Iterative Outputs)\n\n\u5728\u67d0\u4e9b\u60c5\u51b5\u4e0b\uff0c\u60a8\u53ef\u80fd\u9700\u8981\u4f20\u8f93\u4e00\u7cfb\u5217\u8f93\u51fa\u800c\u4e0d\u662f\u4e00\u6b21\u663e\u793a\u5355\u4e2a\u8f93\u51fa\u3002\u4f8b\u5982\uff0c\u60a8\u53ef\u80fd\u6709\u4e00\u4e2a\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5e0c\u671b\u663e\u793a\u751f\u6210\u7684\u6bcf\u4e2a\u6b65\u9aa4\u7684\u56fe\u50cf\uff0c\u76f4\u5230\u6700\u7ec8\u56fe\u50cf\u3002\u6216\u8005\u60a8\u53ef\u80fd\u6709\u4e00\u4e2a\u804a\u5929\u673a\u5668\u4eba\uff0c\u5b83\u9010\u5b57\u9010\u53e5\u5730\u6d41\u5f0f\u4f20\u8f93\u54cd\u5e94\uff0c\u800c\u4e0d\u662f\u4e00\u6b21\u8fd4\u56de\u5168\u90e8\u54cd\u5e94\u3002\n\n\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u60a8\u53ef\u4ee5\u5c06**\u751f\u6210\u5668**\u51fd\u6570\u63d0\u4f9b\u7ed9 Gradio\uff0c\u800c\u4e0d\u662f\u5e38\u89c4\u51fd\u6570\u3002\u5728 Python \u4e2d\u521b\u5efa\u751f\u6210\u5668\u975e\u5e38\u7b80\u5355\uff1a\u51fd\u6570\u4e0d\u5e94\u8be5\u6709\u4e00\u4e2a\u5355\u72ec\u7684 `return` \u503c\uff0c\u800c\u662f\u5e94\u8be5 with `yield` \u8fde\u7eed\u8fd4\u56de\u4e00\u7cfb\u5217\u503c\u3002\u901a\u5e38\uff0c`yield` \u8bed\u53e5\u653e\u7f6e\u5728\u67d0\u79cd\u5faa\u73af\u4e2d\u3002\u4e0b\u9762\u662f\u4e00\u4e2a\u7b80\u5355\u793a\u4f8b\uff0c\u751f\u6210\u5668\u53ea\u662f\u7b80\u5355\u8ba1\u6570\u5230\u7ed9\u5b9a\u6570\u5b57\uff1a\n\n```python\ndef my_generator(x):\n    for i in range(x):\n        yield i\n```\n\n\u60a8\u4ee5\u4e0e\u5e38\u89c4\u51fd\u6570\u76f8\u540c\u7684\u65b9\u5f0f\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio\u3002\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\uff08\u865a\u62df\u7684\uff09\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5b83\u5728\u8f93\u51fa\u56fe\u50cf\u4e4b\u524d\u751f\u6210\u6570\u4e2a\u6b65\u9aa4\u7684\u566a\u97f3\uff1a\n\n$code_fake_diffusion\n$demo_fake_diffusion\n\n\u8bf7\u6ce8\u610f\uff0c\u6211\u4eec\u5728\u8fed\u4ee3\u5668\u4e2d\u6dfb\u52a0\u4e86 `time.sleep(1)`\uff0c\u4ee5\u521b\u5efa\u6b65\u9aa4\u4e4b\u95f4\u7684\u4eba\u5de5\u6682\u505c\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u89c2\u5bdf\u8fed\u4ee3\u5668\u7684\u6b65\u9aa4\uff08\u5728\u771f\u5b9e\u7684\u56fe\u50cf\u751f\u6210\u6a21\u578b\u4e2d\uff0c\u8fd9\u53ef\u80fd\u662f\u4e0d\u5fc5\u8981\u7684\uff09\u3002\n\n\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio **\u9700\u8981**\u5728\u5e95\u5c42 Interface \u6216 Blocks \u4e2d\u542f\u7528\u961f\u5217\uff08\u8bf7\u53c2\u9605\u4e0a\u9762\u7684\u961f\u5217\u90e8\u5206\uff09\u3002\n\n## \u8fdb\u5ea6\u6761\n\nGradio \u652f\u6301\u521b\u5efa\u81ea\u5b9a\u4e49\u8fdb\u5ea6\u6761\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u81ea\u5b9a\u4e49\u548c\u63a7\u5236\u5411\u7528\u6237\u663e\u793a\u7684\u8fdb\u5ea6\u66f4\u65b0\u3002\u8981\u542f\u7528\u6b64\u529f\u80fd\uff0c\u53ea\u9700\u4e3a\u65b9\u6cd5\u6dfb\u52a0\u4e00\u4e2a\u9ed8\u8ba4\u503c\u4e3a `gr.Progress` \u5b9e\u4f8b\u7684\u53c2\u6570\u5373\u53ef\u3002\u7136\u540e\uff0c\u60a8\u53ef\u4ee5\u76f4\u63a5\u8c03\u7528\u6b64\u5b9e\u4f8b\u5e76\u4f20\u5165 0 \u5230 1 \u4e4b\u95f4\u7684\u6d6e\u70b9\u6570\u6765\u66f4\u65b0\u8fdb\u5ea6\u7ea7\u522b\uff0c\u6216\u8005 with `Progress` \u5b9e\u4f8b\u7684 `tqdm()` \u65b9\u6cd5\u6765\u8ddf\u8e2a\u53ef\u8fed\u4ee3\u5bf9\u8c61\u4e0a\u7684\u8fdb\u5ea6\uff0c\u5982\u4e0b\u6240\u793a\u3002\u5fc5\u987b\u542f\u7528\u961f\u5217\u4ee5\u8fdb\u884c\u8fdb\u5ea6\u66f4\u65b0\u3002\n\n$code_progress_simple\n$demo_progress_simple\n\n\u5982\u679c\u60a8 with `tqdm` \u5e93\uff0c\u5e76\u4e14\u5e0c\u671b\u4ece\u51fd\u6570\u5185\u90e8\u7684\u4efb\u4f55 `tqdm.tqdm` \u81ea\u52a8\u62a5\u544a\u8fdb\u5ea6\u66f4\u65b0\uff0c\u8bf7\u5c06\u9ed8\u8ba4\u53c2\u6570\u8bbe\u7f6e\u4e3a `gr.Progress(track_tqdm=True)`\uff01\n\n## \u6279\u5904\u7406\u51fd\u6570 (Batch Functions)\n\nGradio \u652f\u6301\u4f20\u9012*\u6279\u5904\u7406*\u51fd\u6570\u3002\u6279\u5904\u7406\u51fd\u6570\u53ea\u662f\u63a5\u53d7\u8f93\u5165\u5217\u8868\u5e76\u8fd4\u56de\u9884\u6d4b\u5217\u8868\u7684\u51fd\u6570\u3002\n\n\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\u6279\u5904\u7406\u51fd\u6570\uff0c\u5b83\u63a5\u53d7\u4e24\u4e2a\u8f93\u5165\u5217\u8868\uff08\u4e00\u4e2a\u5355\u8bcd\u5217\u8868\u548c\u4e00\u4e2a\u6574\u6570\u5217\u8868\uff09\uff0c\u5e76\u8fd4\u56de\u4fee\u526a\u8fc7\u7684\u5355\u8bcd\u5217\u8868\u4f5c\u4e3a\u8f93\u51fa\uff1a\n\n```python\nimport time\n\ndef trim_words(words, lens):\n    trimmed_words = []\n    time.sleep(5)\n    for w, l in zip(words, lens):\n        trimmed_words.append(w[:int(l)])\n    return [trimmed_words]\n    for w, l in zip(words,"
            }
        ]
    },
    {
        "sample_idx": 111,
        "question": "What is the purpose of the gr.State() object in Gradio Blocks?",
        "answer": "The gr.State() object is used to store data in a session state, and can be initialized with a default value.",
        "rag_answer": "There is no mention of the `gr.State()` object in the provided context information. The context only discusses various features and functionalities of Gradio, such as pre-built themes, iterative outputs, progress bars, batch functions, and more, but it does not mention the `gr.State()` object. Therefore, it is not possible to determine the purpose of the `gr.State()` object based on the provided context.",
        "rag_score": 1,
        "rag_feedback": "The system's response is completely incorrect, inaccurate, and/or not factual. It does not provide any information about the purpose of the gr.State() object in Gradio Blocks, instead, it mentions that there is no mention of the gr.State() object in the provided context information.",
        "rag_context": [
            {
                "score": 0.7202120691415583,
                "node_text": "Here are some facts extracted from the provided text:\n\nGr -> Is -> Alias of gradio\nGradio -> Provides -> Pre-built themes\nGradio -> Is -> Library\nGradio -> Supports -> Iterative outputs\nGradio -> Has feature -> \u6dfb\u52a0\u63cf\u8ff0\u5185\u5bb9\nGradio -> Converts -> Data format\nGradio -> Has feature -> \u8fdb\u5ea6\u6761\nGradio -> Automatically handles -> Preprocessing\nGradio -> Has feature -> \u8bbe\u7f6e\u65d7\u6807\nGradio -> Has feature -> \u8fed\u4ee3\u8f93\u51fa\nGradio -> Has feature -> \u9884\u5904\u7406\u548c\u540e\u5904\u7406\nGradio -> Installed by -> Pip\nGradio -> Has feature -> \u6392\u961f\u7528\u6237\nGradio -> Recognizes -> Data format\nGradio -> Automatically handles -> Postprocessing\nGradio -> Supports -> Hugging face models\nGradio -> Supports -> Batch functions\nGradio -> Enables -> Parallel processing\nGradio -> Has feature -> \u6279\u5904\u7406\u51fd\u6570\nGradio -> Has feature -> \u4f20\u9012\u81ea\u5b9a\u4e49\u9519\u8bef\u6d88\u606f\nGradio -> Can run -> In colab notebooks\nGradio -> Supports -> Progress bars\nGradio -> Includes -> Components\nGradio -> Has feature -> \u6837\u5f0f\u5316\u6f14\u793a\nGradio -> Has feature -> \u6dfb\u52a0\u793a\u4f8b\u8f93\u5165\nDemo -> Is -> Instance of gr.blocks\n\nGradio Demo: blocks_random_slider\n\n\n```\n!pip install -q gradio \n```\n\n\n```\n\nimport gradio as gr\n\n\ndef func(slider_1, slider_2):\n    return slider_1 * 5 + slider_2\n\n\nwith gr.Blocks() as demo:\n    slider = gr.Slider(minimum=-10.2, maximum=15, label=\"Random Slider (Static)\", randomize=True)\n    slider_1 = gr.Slider(minimum=100, maximum=200, label=\"Random Slider (Input 1)\", randomize=True)\n    slider_2 = gr.Slider(minimum=10, maximum=23.2, label=\"Random Slider (Input 2)\", randomize=True)\n    slider_3 = gr.Slider(value=3, label=\"Non random slider\")\n    btn = gr.Button(\"Run\")\n    btn.click(func, inputs=[slider_1, slider_2], outputs=gr.Number())\n\nif __name__ == \"__main__\":\n    demo.launch()\n\n```"
            },
            {
                "score": 0.6986252240005131,
                "node_text": "Here are some facts extracted from the provided text:\n\nGenerator function -> Is -> Provided to gradio\n\nBlocks() as demo\uff1a\n    #.\ndemo.queue()\ndemo.launch()\n```\n\n\u60a8\u53ef\u4ee5\u901a\u8fc7\u4ee5\u4e0b\u65b9\u5f0f\u63a7\u5236\u4e00\u6b21\u5904\u7406\u7684\u8bf7\u6c42\u6570\u91cf\uff1a\n\n```python\ndemo.queue(concurrency_count=3)\n```\n\n\u67e5\u770b\u6709\u5173\u914d\u7f6e\u5176\u4ed6\u961f\u5217\u53c2\u6570\u7684[\u961f\u5217\u6587\u6863](/docs/#queue)\u3002\n\n\u5728 Blocks \u4e2d\u6307\u5b9a\u4ec5\u5bf9\u67d0\u4e9b\u51fd\u6570\u8fdb\u884c\u6392\u961f\uff1a\n\n```python\nwith gr.Blocks() as demo2\uff1a\n    num1 = gr.Number()\n    num2 = gr.Number()\n    output = gr.Number()\n    gr.Button(\"Add\").click(\n        lambda a, b: a + b, [num1, num2], output)\n    gr.Button(\"Multiply\").click(\n        lambda a, b: a * b, [num1, num2], output, queue=True)\ndemo2.launch()\n```\n\n## \u8fed\u4ee3\u8f93\u51fa (Iterative Outputs)\n\n\u5728\u67d0\u4e9b\u60c5\u51b5\u4e0b\uff0c\u60a8\u53ef\u80fd\u9700\u8981\u4f20\u8f93\u4e00\u7cfb\u5217\u8f93\u51fa\u800c\u4e0d\u662f\u4e00\u6b21\u663e\u793a\u5355\u4e2a\u8f93\u51fa\u3002\u4f8b\u5982\uff0c\u60a8\u53ef\u80fd\u6709\u4e00\u4e2a\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5e0c\u671b\u663e\u793a\u751f\u6210\u7684\u6bcf\u4e2a\u6b65\u9aa4\u7684\u56fe\u50cf\uff0c\u76f4\u5230\u6700\u7ec8\u56fe\u50cf\u3002\u6216\u8005\u60a8\u53ef\u80fd\u6709\u4e00\u4e2a\u804a\u5929\u673a\u5668\u4eba\uff0c\u5b83\u9010\u5b57\u9010\u53e5\u5730\u6d41\u5f0f\u4f20\u8f93\u54cd\u5e94\uff0c\u800c\u4e0d\u662f\u4e00\u6b21\u8fd4\u56de\u5168\u90e8\u54cd\u5e94\u3002\n\n\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u60a8\u53ef\u4ee5\u5c06**\u751f\u6210\u5668**\u51fd\u6570\u63d0\u4f9b\u7ed9 Gradio\uff0c\u800c\u4e0d\u662f\u5e38\u89c4\u51fd\u6570\u3002\u5728 Python \u4e2d\u521b\u5efa\u751f\u6210\u5668\u975e\u5e38\u7b80\u5355\uff1a\u51fd\u6570\u4e0d\u5e94\u8be5\u6709\u4e00\u4e2a\u5355\u72ec\u7684 `return` \u503c\uff0c\u800c\u662f\u5e94\u8be5 with `yield` \u8fde\u7eed\u8fd4\u56de\u4e00\u7cfb\u5217\u503c\u3002\u901a\u5e38\uff0c`yield` \u8bed\u53e5\u653e\u7f6e\u5728\u67d0\u79cd\u5faa\u73af\u4e2d\u3002\u4e0b\u9762\u662f\u4e00\u4e2a\u7b80\u5355\u793a\u4f8b\uff0c\u751f\u6210\u5668\u53ea\u662f\u7b80\u5355\u8ba1\u6570\u5230\u7ed9\u5b9a\u6570\u5b57\uff1a\n\n```python\ndef my_generator(x):\n    for i in range(x):\n        yield i\n```\n\n\u60a8\u4ee5\u4e0e\u5e38\u89c4\u51fd\u6570\u76f8\u540c\u7684\u65b9\u5f0f\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio\u3002\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\uff08\u865a\u62df\u7684\uff09\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5b83\u5728\u8f93\u51fa\u56fe\u50cf\u4e4b\u524d\u751f\u6210\u6570\u4e2a\u6b65\u9aa4\u7684\u566a\u97f3\uff1a\n\n$code_fake_diffusion\n$demo_fake_diffusion\n\n\u8bf7\u6ce8\u610f\uff0c\u6211\u4eec\u5728\u8fed\u4ee3\u5668\u4e2d\u6dfb\u52a0\u4e86 `time.sleep(1)`\uff0c\u4ee5\u521b\u5efa\u6b65\u9aa4\u4e4b\u95f4\u7684\u4eba\u5de5\u6682\u505c\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u89c2\u5bdf\u8fed\u4ee3\u5668\u7684\u6b65\u9aa4\uff08\u5728\u771f\u5b9e\u7684\u56fe\u50cf\u751f\u6210\u6a21\u578b\u4e2d\uff0c\u8fd9\u53ef\u80fd\u662f\u4e0d\u5fc5\u8981\u7684\uff09\u3002\n\n\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio **\u9700\u8981**\u5728\u5e95\u5c42 Interface \u6216 Blocks \u4e2d\u542f\u7528\u961f\u5217\uff08\u8bf7\u53c2\u9605\u4e0a\u9762\u7684\u961f\u5217\u90e8\u5206\uff09\u3002\n\n## \u8fdb\u5ea6\u6761\n\nGradio \u652f\u6301\u521b\u5efa\u81ea\u5b9a\u4e49\u8fdb\u5ea6\u6761\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u81ea\u5b9a\u4e49\u548c\u63a7\u5236\u5411\u7528\u6237\u663e\u793a\u7684\u8fdb\u5ea6\u66f4\u65b0\u3002\u8981\u542f\u7528\u6b64\u529f\u80fd\uff0c\u53ea\u9700\u4e3a\u65b9\u6cd5\u6dfb\u52a0\u4e00\u4e2a\u9ed8\u8ba4\u503c\u4e3a `gr.Progress` \u5b9e\u4f8b\u7684\u53c2\u6570\u5373\u53ef\u3002\u7136\u540e\uff0c\u60a8\u53ef\u4ee5\u76f4\u63a5\u8c03\u7528\u6b64\u5b9e\u4f8b\u5e76\u4f20\u5165 0 \u5230 1 \u4e4b\u95f4\u7684\u6d6e\u70b9\u6570\u6765\u66f4\u65b0\u8fdb\u5ea6\u7ea7\u522b\uff0c\u6216\u8005 with `Progress` \u5b9e\u4f8b\u7684 `tqdm()` \u65b9\u6cd5\u6765\u8ddf\u8e2a\u53ef\u8fed\u4ee3\u5bf9\u8c61\u4e0a\u7684\u8fdb\u5ea6\uff0c\u5982\u4e0b\u6240\u793a\u3002\u5fc5\u987b\u542f\u7528\u961f\u5217\u4ee5\u8fdb\u884c\u8fdb\u5ea6\u66f4\u65b0\u3002\n\n$code_progress_simple\n$demo_progress_simple\n\n\u5982\u679c\u60a8 with `tqdm` \u5e93\uff0c\u5e76\u4e14\u5e0c\u671b\u4ece\u51fd\u6570\u5185\u90e8\u7684\u4efb\u4f55 `tqdm.tqdm` \u81ea\u52a8\u62a5\u544a\u8fdb\u5ea6\u66f4\u65b0\uff0c\u8bf7\u5c06\u9ed8\u8ba4\u53c2\u6570\u8bbe\u7f6e\u4e3a `gr.Progress(track_tqdm=True)`\uff01\n\n## \u6279\u5904\u7406\u51fd\u6570 (Batch Functions)\n\nGradio \u652f\u6301\u4f20\u9012*\u6279\u5904\u7406*\u51fd\u6570\u3002\u6279\u5904\u7406\u51fd\u6570\u53ea\u662f\u63a5\u53d7\u8f93\u5165\u5217\u8868\u5e76\u8fd4\u56de\u9884\u6d4b\u5217\u8868\u7684\u51fd\u6570\u3002\n\n\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\u6279\u5904\u7406\u51fd\u6570\uff0c\u5b83\u63a5\u53d7\u4e24\u4e2a\u8f93\u5165\u5217\u8868\uff08\u4e00\u4e2a\u5355\u8bcd\u5217\u8868\u548c\u4e00\u4e2a\u6574\u6570\u5217\u8868\uff09\uff0c\u5e76\u8fd4\u56de\u4fee\u526a\u8fc7\u7684\u5355\u8bcd\u5217\u8868\u4f5c\u4e3a\u8f93\u51fa\uff1a\n\n```python\nimport time\n\ndef trim_words(words, lens):\n    trimmed_words = []\n    time.sleep(5)\n    for w, l in zip(words, lens):\n        trimmed_words.append(w[:int(l)])\n    return [trimmed_words]\n    for w, l in zip(words,"
            }
        ]
    },
    {
        "sample_idx": 112,
        "question": "Where can you learn more about State in Gradio Blocks?",
        "answer": "You can learn more about State in the Gradio docs.",
        "rag_answer": "You can learn more about `State` in the [docs](https://gradio.app/docs#state).",
        "rag_score": 5,
        "rag_feedback": "The response is completely correct, accurate, and factual. It provides a direct link to the Gradio docs, which is the expected answer.",
        "rag_context": [
            {
                "score": 0.7341192535921527,
                "node_text": "Here are some facts extracted from the provided text:\n\nGenerator function -> Is -> Provided to gradio\n\nBlocks() as demo\uff1a\n    #.\ndemo.queue()\ndemo.launch()\n```\n\n\u60a8\u53ef\u4ee5\u901a\u8fc7\u4ee5\u4e0b\u65b9\u5f0f\u63a7\u5236\u4e00\u6b21\u5904\u7406\u7684\u8bf7\u6c42\u6570\u91cf\uff1a\n\n```python\ndemo.queue(concurrency_count=3)\n```\n\n\u67e5\u770b\u6709\u5173\u914d\u7f6e\u5176\u4ed6\u961f\u5217\u53c2\u6570\u7684[\u961f\u5217\u6587\u6863](/docs/#queue)\u3002\n\n\u5728 Blocks \u4e2d\u6307\u5b9a\u4ec5\u5bf9\u67d0\u4e9b\u51fd\u6570\u8fdb\u884c\u6392\u961f\uff1a\n\n```python\nwith gr.Blocks() as demo2\uff1a\n    num1 = gr.Number()\n    num2 = gr.Number()\n    output = gr.Number()\n    gr.Button(\"Add\").click(\n        lambda a, b: a + b, [num1, num2], output)\n    gr.Button(\"Multiply\").click(\n        lambda a, b: a * b, [num1, num2], output, queue=True)\ndemo2.launch()\n```\n\n## \u8fed\u4ee3\u8f93\u51fa (Iterative Outputs)\n\n\u5728\u67d0\u4e9b\u60c5\u51b5\u4e0b\uff0c\u60a8\u53ef\u80fd\u9700\u8981\u4f20\u8f93\u4e00\u7cfb\u5217\u8f93\u51fa\u800c\u4e0d\u662f\u4e00\u6b21\u663e\u793a\u5355\u4e2a\u8f93\u51fa\u3002\u4f8b\u5982\uff0c\u60a8\u53ef\u80fd\u6709\u4e00\u4e2a\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5e0c\u671b\u663e\u793a\u751f\u6210\u7684\u6bcf\u4e2a\u6b65\u9aa4\u7684\u56fe\u50cf\uff0c\u76f4\u5230\u6700\u7ec8\u56fe\u50cf\u3002\u6216\u8005\u60a8\u53ef\u80fd\u6709\u4e00\u4e2a\u804a\u5929\u673a\u5668\u4eba\uff0c\u5b83\u9010\u5b57\u9010\u53e5\u5730\u6d41\u5f0f\u4f20\u8f93\u54cd\u5e94\uff0c\u800c\u4e0d\u662f\u4e00\u6b21\u8fd4\u56de\u5168\u90e8\u54cd\u5e94\u3002\n\n\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u60a8\u53ef\u4ee5\u5c06**\u751f\u6210\u5668**\u51fd\u6570\u63d0\u4f9b\u7ed9 Gradio\uff0c\u800c\u4e0d\u662f\u5e38\u89c4\u51fd\u6570\u3002\u5728 Python \u4e2d\u521b\u5efa\u751f\u6210\u5668\u975e\u5e38\u7b80\u5355\uff1a\u51fd\u6570\u4e0d\u5e94\u8be5\u6709\u4e00\u4e2a\u5355\u72ec\u7684 `return` \u503c\uff0c\u800c\u662f\u5e94\u8be5 with `yield` \u8fde\u7eed\u8fd4\u56de\u4e00\u7cfb\u5217\u503c\u3002\u901a\u5e38\uff0c`yield` \u8bed\u53e5\u653e\u7f6e\u5728\u67d0\u79cd\u5faa\u73af\u4e2d\u3002\u4e0b\u9762\u662f\u4e00\u4e2a\u7b80\u5355\u793a\u4f8b\uff0c\u751f\u6210\u5668\u53ea\u662f\u7b80\u5355\u8ba1\u6570\u5230\u7ed9\u5b9a\u6570\u5b57\uff1a\n\n```python\ndef my_generator(x):\n    for i in range(x):\n        yield i\n```\n\n\u60a8\u4ee5\u4e0e\u5e38\u89c4\u51fd\u6570\u76f8\u540c\u7684\u65b9\u5f0f\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio\u3002\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\uff08\u865a\u62df\u7684\uff09\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5b83\u5728\u8f93\u51fa\u56fe\u50cf\u4e4b\u524d\u751f\u6210\u6570\u4e2a\u6b65\u9aa4\u7684\u566a\u97f3\uff1a\n\n$code_fake_diffusion\n$demo_fake_diffusion\n\n\u8bf7\u6ce8\u610f\uff0c\u6211\u4eec\u5728\u8fed\u4ee3\u5668\u4e2d\u6dfb\u52a0\u4e86 `time.sleep(1)`\uff0c\u4ee5\u521b\u5efa\u6b65\u9aa4\u4e4b\u95f4\u7684\u4eba\u5de5\u6682\u505c\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u89c2\u5bdf\u8fed\u4ee3\u5668\u7684\u6b65\u9aa4\uff08\u5728\u771f\u5b9e\u7684\u56fe\u50cf\u751f\u6210\u6a21\u578b\u4e2d\uff0c\u8fd9\u53ef\u80fd\u662f\u4e0d\u5fc5\u8981\u7684\uff09\u3002\n\n\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio **\u9700\u8981**\u5728\u5e95\u5c42 Interface \u6216 Blocks \u4e2d\u542f\u7528\u961f\u5217\uff08\u8bf7\u53c2\u9605\u4e0a\u9762\u7684\u961f\u5217\u90e8\u5206\uff09\u3002\n\n## \u8fdb\u5ea6\u6761\n\nGradio \u652f\u6301\u521b\u5efa\u81ea\u5b9a\u4e49\u8fdb\u5ea6\u6761\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u81ea\u5b9a\u4e49\u548c\u63a7\u5236\u5411\u7528\u6237\u663e\u793a\u7684\u8fdb\u5ea6\u66f4\u65b0\u3002\u8981\u542f\u7528\u6b64\u529f\u80fd\uff0c\u53ea\u9700\u4e3a\u65b9\u6cd5\u6dfb\u52a0\u4e00\u4e2a\u9ed8\u8ba4\u503c\u4e3a `gr.Progress` \u5b9e\u4f8b\u7684\u53c2\u6570\u5373\u53ef\u3002\u7136\u540e\uff0c\u60a8\u53ef\u4ee5\u76f4\u63a5\u8c03\u7528\u6b64\u5b9e\u4f8b\u5e76\u4f20\u5165 0 \u5230 1 \u4e4b\u95f4\u7684\u6d6e\u70b9\u6570\u6765\u66f4\u65b0\u8fdb\u5ea6\u7ea7\u522b\uff0c\u6216\u8005 with `Progress` \u5b9e\u4f8b\u7684 `tqdm()` \u65b9\u6cd5\u6765\u8ddf\u8e2a\u53ef\u8fed\u4ee3\u5bf9\u8c61\u4e0a\u7684\u8fdb\u5ea6\uff0c\u5982\u4e0b\u6240\u793a\u3002\u5fc5\u987b\u542f\u7528\u961f\u5217\u4ee5\u8fdb\u884c\u8fdb\u5ea6\u66f4\u65b0\u3002\n\n$code_progress_simple\n$demo_progress_simple\n\n\u5982\u679c\u60a8 with `tqdm` \u5e93\uff0c\u5e76\u4e14\u5e0c\u671b\u4ece\u51fd\u6570\u5185\u90e8\u7684\u4efb\u4f55 `tqdm.tqdm` \u81ea\u52a8\u62a5\u544a\u8fdb\u5ea6\u66f4\u65b0\uff0c\u8bf7\u5c06\u9ed8\u8ba4\u53c2\u6570\u8bbe\u7f6e\u4e3a `gr.Progress(track_tqdm=True)`\uff01\n\n## \u6279\u5904\u7406\u51fd\u6570 (Batch Functions)\n\nGradio \u652f\u6301\u4f20\u9012*\u6279\u5904\u7406*\u51fd\u6570\u3002\u6279\u5904\u7406\u51fd\u6570\u53ea\u662f\u63a5\u53d7\u8f93\u5165\u5217\u8868\u5e76\u8fd4\u56de\u9884\u6d4b\u5217\u8868\u7684\u51fd\u6570\u3002\n\n\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\u6279\u5904\u7406\u51fd\u6570\uff0c\u5b83\u63a5\u53d7\u4e24\u4e2a\u8f93\u5165\u5217\u8868\uff08\u4e00\u4e2a\u5355\u8bcd\u5217\u8868\u548c\u4e00\u4e2a\u6574\u6570\u5217\u8868\uff09\uff0c\u5e76\u8fd4\u56de\u4fee\u526a\u8fc7\u7684\u5355\u8bcd\u5217\u8868\u4f5c\u4e3a\u8f93\u51fa\uff1a\n\n```python\nimport time\n\ndef trim_words(words, lens):\n    trimmed_words = []\n    time.sleep(5)\n    for w, l in zip(words, lens):\n        trimmed_words.append(w[:int(l)])\n    return [trimmed_words]\n    for w, l in zip(words,"
            },
            {
                "score": 0.7315869742901429,
                "node_text": "Here are some facts extracted from the provided text:\n\nGradio -> Provides -> Pre-built themes\nGradio -> Is -> Library\nGradio -> Supports -> Iterative outputs\nGradio -> Has feature -> \u6dfb\u52a0\u63cf\u8ff0\u5185\u5bb9\nGradio -> Converts -> Data format\nGradio -> Has feature -> \u8fdb\u5ea6\u6761\nGradio -> Automatically handles -> Preprocessing\nGradio -> Has feature -> \u8bbe\u7f6e\u65d7\u6807\nGradio -> Has feature -> \u8fed\u4ee3\u8f93\u51fa\nGradio -> Has feature -> \u9884\u5904\u7406\u548c\u540e\u5904\u7406\nGradio -> Installed by -> Pip\nGradio -> Has feature -> \u6392\u961f\u7528\u6237\nGradio -> Recognizes -> Data format\nGradio -> Automatically handles -> Postprocessing\nGradio -> Supports -> Hugging face models\nGradio -> Supports -> Batch functions\nGradio -> Enables -> Parallel processing\nGradio -> Has feature -> \u6279\u5904\u7406\u51fd\u6570\nGradio -> Has feature -> \u4f20\u9012\u81ea\u5b9a\u4e49\u9519\u8bef\u6d88\u606f\nGradio -> Can run -> In colab notebooks\nGradio -> Supports -> Progress bars\nGradio -> Includes -> Components\nGradio -> Has feature -> \u6837\u5f0f\u5316\u6f14\u793a\nGradio -> Has feature -> \u6dfb\u52a0\u793a\u4f8b\u8f93\u5165\nGr -> Is -> Alias of gradio\n\nGradio Demo: blocks_random_slider\n\n\n```\n!pip install -q gradio \n```\n\n\n```\n\nimport gradio as gr\n\n\ndef func(slider_1, slider_2):\n    return slider_1 * 5 + slider_2\n\n\nwith gr.Blocks() as demo:\n    slider = gr.Slider(minimum=-10.2, maximum=15, label=\"Random Slider (Static)\", randomize=True)\n    slider_1 = gr.Slider(minimum=100, maximum=200, label=\"Random Slider (Input 1)\", randomize=True)\n    slider_2 = gr.Slider(minimum=10, maximum=23.2, label=\"Random Slider (Input 2)\", randomize=True)\n    slider_3 = gr.Slider(value=3, label=\"Non random slider\")\n    btn = gr.Button(\"Run\")\n    btn.click(func, inputs=[slider_1, slider_2], outputs=gr.Number())\n\nif __name__ == \"__main__\":\n    demo.launch()\n\n```"
            },
            {
                "score": 0.7009218741891674,
                "node_text": "Here are some facts extracted from the provided text:\n\nState in blocks -> Works -> Same as in interface\n\nState in Blocks\n\nWe covered [State in Interfaces](https://gradio.app/interface-state), this guide takes a look at state in Blocks, which works mostly the same.\n\n## Global State\n\nGlobal state in Blocks works the same as in Interface. Any variable created outside a function call is a reference shared between all users.\n\n## Session State\n\nGradio supports session **state**, where data persists across multiple submits within a page session, in Blocks apps as well. To reiterate, session data is _not_ shared between different users of your model. To store data in a session state, you need to do three things:\n\n1. Create a `gr.State()` object. If there is a default value to this stateful object, pass that into the constructor.\n2. In the event listener, put the `State` object as an input and output.\n3. In the event listener function, add the variable to the input parameters and the return value.\n\nLet's take a look at a game of hangman.\n\n$code_hangman\n$demo_hangman\n\nLet's see how we do each of the 3 steps listed above in this game:\n\n1. We store the used letters in `used_letters_var`. In the constructor of `State`, we set the initial value of this to `[]`, an empty list.\n2. In `btn.click()`, we have a reference to `used_letters_var` in both the inputs and outputs.\n3. In `guess_letter`, we pass the value of this `State` to `used_letters`, and then return an updated value of this `State` in the return statement.\n\nWith more complex apps, you will likely have many State variables storing session state in a single Blocks app.\n\nLearn more about `State` in the [docs](https://gradio.app/docs#state)."
            }
        ]
    },
    {
        "sample_idx": 113,
        "question": "What is the name of the library used to create various maps in this guide?",
        "answer": "Plotly",
        "rag_answer": "There is no mention of a library used to create various maps in this guide. The context information discusses machine translation, evaluation metrics, and a library called Gradio, which is used to create interactive demos, but it does not mention maps.",
        "rag_score": 5,
        "rag_feedback": "The system's response is completely correct, accurate, and factual. It correctly states that there is no mention of a library used to create various maps in the given context, and provides relevant information about the context discussing machine translation, evaluation metrics, and the library Gradio.",
        "rag_context": [
            {
                "score": 0.6016512118246768,
                "node_text": "Here are some facts extracted from the provided text:\n\nMachine translation -> Evaluated using -> Rouge\n\nChoosing a metric for your task\n\n**So you've trained your model and want to see how well it\u2019s doing on a dataset of your choice. Where do you start?**\n\nThere is no \u201cone size fits all\u201d approach to choosing an evaluation metric, but some good guidelines to keep in mind are:\n\n## Categories of metrics\n\nThere are 3 high-level categories of metrics:\n\n1. *Generic metrics*, which can be applied to a variety of situations and datasets, such as precision and accuracy.\n2. *Task-specific metrics*, which are limited to a given task, such as Machine Translation (often evaluated using metrics [BLEU](https://huggingface.co/metrics/bleu) or [ROUGE](https://huggingface.co/metrics/rouge)) or Named Entity Recognition (often evaluated with [seqeval](https://huggingface.co/metrics/seqeval)).\n3. *Dataset-specific metrics*, which aim to measure model performance on specific benchmarks: for instance, the [GLUE benchmark](https://huggingface.co/datasets/glue) has a dedicated [evaluation metric](https://huggingface.co/metrics/glue).\n\nLet's look at each of these three cases:\n\n### Generic metrics\n\nMany of the metrics used in the Machine Learning community are quite generic and can be applied in a variety of tasks and datasets.\n\nThis is the case for metrics like [accuracy](https://huggingface.co/metrics/accuracy) and [precision](https://huggingface.co/metrics/precision), which can be used for evaluating labeled (supervised) datasets, as well as [perplexity](https://huggingface.co/metrics/perplexity), which can be used for evaluating different kinds of (unsupervised) generative tasks.\n\nTo see the input structure of a given metric, you can look at its metric card. For example, in the case of [precision](https://huggingface.co/metrics/precision), the format is:\n```\n>>> precision_metric = evaluate.load(\"precision\")\n>>> results = precision_metric.compute(references=[0, 1], predictions=[0, 1])\n>>> print(results)\n{'precision': 1.0}\n```\n\n### Task-specific metrics\n\nPopular ML tasks like Machine Translation and Named Entity Recognition have specific metrics that can be used to compare models. For example, a series of different metrics have been proposed for text generation, ranging from [BLEU](https://huggingface.co/metrics/bleu) and its derivatives such as [GoogleBLEU](https://huggingface.co/metrics/google_bleu) and [GLEU](https://huggingface.co/metrics/gleu), but also [ROUGE](https://huggingface.co/metrics/rouge), [MAUVE](https://huggingface.co/metrics/mauve), etc.\n\nYou can find the right metric for your task by:\n\n- **Looking at the [Task pages](https://huggingface.co/tasks)** to see what metrics can be used for evaluating models for a given task.\n- **Checking out leaderboards** on sites like [Papers With Code](https://paperswithcode.com/) (you can search by task and by dataset).\n-  **Reading the metric cards** for the relevant metrics and see which ones are a good fit for your use case. For example, see the [BLEU metric card](https://github.com/huggingface/evaluate/tree/main/metrics/bleu) or [SQuaD metric card](https://github.com/huggingface/evaluate/tree/main/metrics/squad).\n- **Looking at papers and blog posts** published on the topic and see what metrics they report. This can change over time, so try to pick papers from the last couple of years!\n\n### Dataset-specific metrics\n\nSome datasets have specific metrics associated with them -- this is especially in the case of popular benchmarks like [GLUE](https://huggingface.co/metrics/glue) and [SQuAD](https://huggingface.co/metrics/squad).\n\n<Tip warning={true}>\n\ud83d\udca1\nGLUE is actually a collection of different subsets on different tasks, so first you need to choose the one that corresponds to the NLI task, such as mnli, which is described as \u201ccrowdsourced collection of sentence pairs with textual entailment annotations\u201d\n</Tip>"
            },
            {
                "score": 0.5812782793082287,
                "node_text": "Here are some facts extracted from the provided text:\n\nGradio -> Is -> Library\nGradio -> Provides -> Pre-built themes\nGradio -> Supports -> Iterative outputs\nGradio -> Has feature -> \u6dfb\u52a0\u63cf\u8ff0\u5185\u5bb9\nGradio -> Converts -> Data format\nGradio -> Has feature -> \u8fdb\u5ea6\u6761\nGradio -> Automatically handles -> Preprocessing\nGradio -> Has feature -> \u8bbe\u7f6e\u65d7\u6807\nGradio -> Has feature -> \u8fed\u4ee3\u8f93\u51fa\nGradio -> Has feature -> \u9884\u5904\u7406\u548c\u540e\u5904\u7406\nGradio -> Installed by -> Pip\nGradio -> Has feature -> \u6392\u961f\u7528\u6237\nGradio -> Recognizes -> Data format\nGradio -> Automatically handles -> Postprocessing\nGradio -> Supports -> Hugging face models\nGradio -> Supports -> Batch functions\nGradio -> Enables -> Parallel processing\nGradio -> Has feature -> \u6279\u5904\u7406\u51fd\u6570\nGradio -> Has feature -> \u4f20\u9012\u81ea\u5b9a\u4e49\u9519\u8bef\u6d88\u606f\nGradio -> Can run -> In colab notebooks\nGradio -> Supports -> Progress bars\nGradio -> Includes -> Components\nGradio -> Has feature -> \u6837\u5f0f\u5316\u6f14\u793a\nGradio -> Has feature -> \u6dfb\u52a0\u793a\u4f8b\u8f93\u5165\nGr -> Is -> Alias of gradio\n\nGradio Demo: blocks_random_slider\n\n\n```\n!pip install -q gradio \n```\n\n\n```\n\nimport gradio as gr\n\n\ndef func(slider_1, slider_2):\n    return slider_1 * 5 + slider_2\n\n\nwith gr.Blocks() as demo:\n    slider = gr.Slider(minimum=-10.2, maximum=15, label=\"Random Slider (Static)\", randomize=True)\n    slider_1 = gr.Slider(minimum=100, maximum=200, label=\"Random Slider (Input 1)\", randomize=True)\n    slider_2 = gr.Slider(minimum=10, maximum=23.2, label=\"Random Slider (Input 2)\", randomize=True)\n    slider_3 = gr.Slider(value=3, label=\"Non random slider\")\n    btn = gr.Button(\"Run\")\n    btn.click(func, inputs=[slider_1, slider_2], outputs=gr.Number())\n\nif __name__ == \"__main__\":\n    demo.launch()\n\n```"
            }
        ]
    },
    {
        "sample_idx": 114,
        "question": "What is the name of the dataset used in this guide?",
        "answer": "New York City Airbnb Open Data",
        "rag_answer": "The names of the datasets used in this guide are FUNSD, CORD, and SQuAD.",
        "rag_score": 1,
        "rag_feedback": "The system's response is completely incorrect, inaccurate, and/or not factual. The expected answer is 'New York City Airbnb Open Data', but the system's response mentions 'FUNSD, CORD, and SQuAD' which are unrelated datasets.",
        "rag_context": [
            {
                "score": 0.6879543212435316,
                "node_text": "Here are some facts extracted from the provided text:\n\nHuggingface ecosystem -> Includes -> Transformers and datasets\n\n!--Copyright 2023 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\nthe License. You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under the License is distributed on\nan \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n\n\u26a0\ufe0f Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be\nrendered properly in your Markdown viewer.\n\n-->\n\n# Training on TPU with TensorFlow\n\n<Tip>\n\nIf you don't need long explanations and just want TPU code samples to get started with, check out [our TPU example notebook!](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb)\n\n</Tip>\n\n### What is a TPU?\n\nA TPU is a **Tensor Processing Unit.** They are hardware designed by Google, which are used to greatly speed up the tensor computations within neural networks, much like GPUs. They can be used for both network training and inference. They are generally accessed through Google\u2019s cloud services, but small TPUs can also be accessed directly for free through Google Colab and Kaggle Kernels.\n\nBecause [all TensorFlow models in \ud83e\udd17 Transformers are Keras models](https://huggingface.co/blog/tensorflow-philosophy), most of the methods in this document are generally applicable to TPU training for any Keras model! However, there are a few points that are specific to the HuggingFace ecosystem (hug-o-system?) of Transformers and Datasets, and we\u2019ll make sure to flag them up when we get to them.\n\n### What kinds of TPU are available?\n\nNew users are often very confused by the range of TPUs, and the different ways to access them. The first key distinction to understand is the difference between **TPU Nodes** and **TPU VMs.**\n\nWhen you use a **TPU Node**, you are effectively indirectly accessing a remote TPU. You will need a separate VM, which will initialize your network and data pipeline and then forward them to the remote node. When you use a TPU on Google Colab, you are accessing it in the **TPU Node** style.\n\nUsing TPU Nodes can have some quite unexpected behaviour for people who aren\u2019t used to them! In particular, because the TPU is located on a physically different system to the machine you\u2019re running your Python code on, your data cannot be local to your machine - any data pipeline that loads from your machine\u2019s internal storage will totally fail! Instead, data must be stored in Google Cloud Storage where your data pipeline can still access it, even when the pipeline is running on the remote TPU node.\n\n<Tip>\n\nIf you can fit all your data in memory as `np.ndarray` or `tf.Tensor`, then you can `fit()` on that data even when using Colab or a TPU Node, without needing to upload it to Google Cloud Storage.\n\n</Tip>\n\n<Tip>\n\n**\ud83e\udd17Specific Hugging Face Tip\ud83e\udd17:** The methods `Dataset.to_tf_dataset()` and its higher-level wrapper `model.prepare_tf_dataset()` , which you will see throughout our TF code examples, will both fail on a TPU Node. The reason for this is that even though they create a `tf.data.Dataset` it is not a \u201cpure\u201d `tf.data` pipeline and uses `tf.numpy_function` or `Dataset.from_generator()` to stream data from the underlying HuggingFace `Dataset`. This HuggingFace `Dataset` is backed by data that is on a local disc and which the remote TPU Node will not be able to read.\n\n</Tip>\n\nThe second way to access a TPU is via a **TPU VM.** When using a TPU VM, you connect directly to the machine that the TPU is attached to, much like training on a GPU VM. TPU VMs are generally easier to work with, particularly when it comes to your data pipeline. All of the above warnings do not apply to TPU VMs!\n\nThis is an opinionated document, so here\u2019s our opinion: **Avoid using TPU Node if possible.** It is more confusing and more difficult to debug than TPU VMs. It is also likely to be unsupported in future - Google\u2019s latest TPU, TPUv4, can only be accessed as a TPU VM, which suggests that TPU Nodes are increasingly going to become a \u201clegacy\u201d access method."
            },
            {
                "score": 0.6713633545018531,
                "node_text": "Here are some facts extracted from the provided text:\n\nSquad -> Is -> Dataset\n\nIf you are evaluating your model on a benchmark dataset like the ones mentioned above, you can use its dedicated evaluation metric. Make sure you respect the format that they require. For example, to evaluate your model on the [SQuAD](https://huggingface.co/datasets/squad) dataset, you need to feed the `question` and `context` into your model and return the `prediction_text`, which should be compared with the `references` (based on matching the `id` of the question) :\n\n```\n>>> from evaluate import load\n>>> squad_metric = load(\"squad\")\n>>> predictions = [{'prediction_text': '1976', 'id': '56e10a3be3433e1400422b22'}]\n>>> references = [{'answers': {'answer_start': [97], 'text': ['1976']}, 'id': '56e10a3be3433e1400422b22'}]\n>>> results = squad_metric.compute(predictions=predictions, references=references)\n>>> results\n{'exact_match': 100.0, 'f1': 100.0}\n```\n\nYou can find examples of dataset structures by consulting the \"Dataset Preview\" function or the dataset card for a given dataset, and you can see how to use its dedicated evaluation function based on the metric card."
            },
            {
                "score": 0.6463157976477081,
                "node_text": "Here are some facts extracted from the provided text:\n\nGenerator function -> Is -> Provided to gradio\n\nBlocks() as demo\uff1a\n    #.\ndemo.queue()\ndemo.launch()\n```\n\n\u60a8\u53ef\u4ee5\u901a\u8fc7\u4ee5\u4e0b\u65b9\u5f0f\u63a7\u5236\u4e00\u6b21\u5904\u7406\u7684\u8bf7\u6c42\u6570\u91cf\uff1a\n\n```python\ndemo.queue(concurrency_count=3)\n```\n\n\u67e5\u770b\u6709\u5173\u914d\u7f6e\u5176\u4ed6\u961f\u5217\u53c2\u6570\u7684[\u961f\u5217\u6587\u6863](/docs/#queue)\u3002\n\n\u5728 Blocks \u4e2d\u6307\u5b9a\u4ec5\u5bf9\u67d0\u4e9b\u51fd\u6570\u8fdb\u884c\u6392\u961f\uff1a\n\n```python\nwith gr.Blocks() as demo2\uff1a\n    num1 = gr.Number()\n    num2 = gr.Number()\n    output = gr.Number()\n    gr.Button(\"Add\").click(\n        lambda a, b: a + b, [num1, num2], output)\n    gr.Button(\"Multiply\").click(\n        lambda a, b: a * b, [num1, num2], output, queue=True)\ndemo2.launch()\n```\n\n## \u8fed\u4ee3\u8f93\u51fa (Iterative Outputs)\n\n\u5728\u67d0\u4e9b\u60c5\u51b5\u4e0b\uff0c\u60a8\u53ef\u80fd\u9700\u8981\u4f20\u8f93\u4e00\u7cfb\u5217\u8f93\u51fa\u800c\u4e0d\u662f\u4e00\u6b21\u663e\u793a\u5355\u4e2a\u8f93\u51fa\u3002\u4f8b\u5982\uff0c\u60a8\u53ef\u80fd\u6709\u4e00\u4e2a\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5e0c\u671b\u663e\u793a\u751f\u6210\u7684\u6bcf\u4e2a\u6b65\u9aa4\u7684\u56fe\u50cf\uff0c\u76f4\u5230\u6700\u7ec8\u56fe\u50cf\u3002\u6216\u8005\u60a8\u53ef\u80fd\u6709\u4e00\u4e2a\u804a\u5929\u673a\u5668\u4eba\uff0c\u5b83\u9010\u5b57\u9010\u53e5\u5730\u6d41\u5f0f\u4f20\u8f93\u54cd\u5e94\uff0c\u800c\u4e0d\u662f\u4e00\u6b21\u8fd4\u56de\u5168\u90e8\u54cd\u5e94\u3002\n\n\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u60a8\u53ef\u4ee5\u5c06**\u751f\u6210\u5668**\u51fd\u6570\u63d0\u4f9b\u7ed9 Gradio\uff0c\u800c\u4e0d\u662f\u5e38\u89c4\u51fd\u6570\u3002\u5728 Python \u4e2d\u521b\u5efa\u751f\u6210\u5668\u975e\u5e38\u7b80\u5355\uff1a\u51fd\u6570\u4e0d\u5e94\u8be5\u6709\u4e00\u4e2a\u5355\u72ec\u7684 `return` \u503c\uff0c\u800c\u662f\u5e94\u8be5 with `yield` \u8fde\u7eed\u8fd4\u56de\u4e00\u7cfb\u5217\u503c\u3002\u901a\u5e38\uff0c`yield` \u8bed\u53e5\u653e\u7f6e\u5728\u67d0\u79cd\u5faa\u73af\u4e2d\u3002\u4e0b\u9762\u662f\u4e00\u4e2a\u7b80\u5355\u793a\u4f8b\uff0c\u751f\u6210\u5668\u53ea\u662f\u7b80\u5355\u8ba1\u6570\u5230\u7ed9\u5b9a\u6570\u5b57\uff1a\n\n```python\ndef my_generator(x):\n    for i in range(x):\n        yield i\n```\n\n\u60a8\u4ee5\u4e0e\u5e38\u89c4\u51fd\u6570\u76f8\u540c\u7684\u65b9\u5f0f\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio\u3002\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\uff08\u865a\u62df\u7684\uff09\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5b83\u5728\u8f93\u51fa\u56fe\u50cf\u4e4b\u524d\u751f\u6210\u6570\u4e2a\u6b65\u9aa4\u7684\u566a\u97f3\uff1a\n\n$code_fake_diffusion\n$demo_fake_diffusion\n\n\u8bf7\u6ce8\u610f\uff0c\u6211\u4eec\u5728\u8fed\u4ee3\u5668\u4e2d\u6dfb\u52a0\u4e86 `time.sleep(1)`\uff0c\u4ee5\u521b\u5efa\u6b65\u9aa4\u4e4b\u95f4\u7684\u4eba\u5de5\u6682\u505c\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u89c2\u5bdf\u8fed\u4ee3\u5668\u7684\u6b65\u9aa4\uff08\u5728\u771f\u5b9e\u7684\u56fe\u50cf\u751f\u6210\u6a21\u578b\u4e2d\uff0c\u8fd9\u53ef\u80fd\u662f\u4e0d\u5fc5\u8981\u7684\uff09\u3002\n\n\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio **\u9700\u8981**\u5728\u5e95\u5c42 Interface \u6216 Blocks \u4e2d\u542f\u7528\u961f\u5217\uff08\u8bf7\u53c2\u9605\u4e0a\u9762\u7684\u961f\u5217\u90e8\u5206\uff09\u3002\n\n## \u8fdb\u5ea6\u6761\n\nGradio \u652f\u6301\u521b\u5efa\u81ea\u5b9a\u4e49\u8fdb\u5ea6\u6761\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u81ea\u5b9a\u4e49\u548c\u63a7\u5236\u5411\u7528\u6237\u663e\u793a\u7684\u8fdb\u5ea6\u66f4\u65b0\u3002\u8981\u542f\u7528\u6b64\u529f\u80fd\uff0c\u53ea\u9700\u4e3a\u65b9\u6cd5\u6dfb\u52a0\u4e00\u4e2a\u9ed8\u8ba4\u503c\u4e3a `gr.Progress` \u5b9e\u4f8b\u7684\u53c2\u6570\u5373\u53ef\u3002\u7136\u540e\uff0c\u60a8\u53ef\u4ee5\u76f4\u63a5\u8c03\u7528\u6b64\u5b9e\u4f8b\u5e76\u4f20\u5165 0 \u5230 1 \u4e4b\u95f4\u7684\u6d6e\u70b9\u6570\u6765\u66f4\u65b0\u8fdb\u5ea6\u7ea7\u522b\uff0c\u6216\u8005 with `Progress` \u5b9e\u4f8b\u7684 `tqdm()` \u65b9\u6cd5\u6765\u8ddf\u8e2a\u53ef\u8fed\u4ee3\u5bf9\u8c61\u4e0a\u7684\u8fdb\u5ea6\uff0c\u5982\u4e0b\u6240\u793a\u3002\u5fc5\u987b\u542f\u7528\u961f\u5217\u4ee5\u8fdb\u884c\u8fdb\u5ea6\u66f4\u65b0\u3002\n\n$code_progress_simple\n$demo_progress_simple\n\n\u5982\u679c\u60a8 with `tqdm` \u5e93\uff0c\u5e76\u4e14\u5e0c\u671b\u4ece\u51fd\u6570\u5185\u90e8\u7684\u4efb\u4f55 `tqdm.tqdm` \u81ea\u52a8\u62a5\u544a\u8fdb\u5ea6\u66f4\u65b0\uff0c\u8bf7\u5c06\u9ed8\u8ba4\u53c2\u6570\u8bbe\u7f6e\u4e3a `gr.Progress(track_tqdm=True)`\uff01\n\n## \u6279\u5904\u7406\u51fd\u6570 (Batch Functions)\n\nGradio \u652f\u6301\u4f20\u9012*\u6279\u5904\u7406*\u51fd\u6570\u3002\u6279\u5904\u7406\u51fd\u6570\u53ea\u662f\u63a5\u53d7\u8f93\u5165\u5217\u8868\u5e76\u8fd4\u56de\u9884\u6d4b\u5217\u8868\u7684\u51fd\u6570\u3002\n\n\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\u6279\u5904\u7406\u51fd\u6570\uff0c\u5b83\u63a5\u53d7\u4e24\u4e2a\u8f93\u5165\u5217\u8868\uff08\u4e00\u4e2a\u5355\u8bcd\u5217\u8868\u548c\u4e00\u4e2a\u6574\u6570\u5217\u8868\uff09\uff0c\u5e76\u8fd4\u56de\u4fee\u526a\u8fc7\u7684\u5355\u8bcd\u5217\u8868\u4f5c\u4e3a\u8f93\u51fa\uff1a\n\n```python\nimport time\n\ndef trim_words(words, lens):\n    trimmed_words = []\n    time.sleep(5)\n    for w, l in zip(words, lens):\n        trimmed_words.append(w[:int(l)])\n    return [trimmed_words]\n    for w, l in zip(words,"
            },
            {
                "score": 0.6409438324823695,
                "node_text": "Here are some facts extracted from the provided text:\n\nFunsd -> Is -> Form understanding dataset\nCord -> Is -> Form understanding dataset\n\n!---\nCopyright 2022 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n-->\n\n# Token classification with LayoutLMv3 (PyTorch version)\n\nThis directory contains a script, `run_funsd_cord.py`, that can be used to fine-tune (or evaluate) LayoutLMv3 on form understanding datasets, such as [FUNSD](https://guillaumejaume.github.io/FUNSD/) and [CORD](https://github.com/clovaai/cord).\n\nThe script `run_funsd_cord.py` leverages the \ud83e\udd17 Datasets library and the Trainer API. You can easily customize it to your needs.\n\n## Fine-tuning on FUNSD\n\nFine-tuning LayoutLMv3 for token classification on [FUNSD](https://guillaumejaume.github.io/FUNSD/) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name funsd \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 1e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-funsd\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd. By specifying the `push_to_hub` flag, the model gets uploaded automatically to the hub (regularly), together with a model card, which includes metrics such as precision, recall and F1. Note that you can easily update the model card, as it's just a README file of the respective repo on the hub.\n\nThere's also the \"Training metrics\" [tab](https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd/tensorboard), which shows Tensorboard logs over the course of training. Pretty neat, huh?\n\n## Fine-tuning on CORD\n\nFine-tuning LayoutLMv3 for token classification on [CORD](https://github.com/clovaai/cord) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name cord \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 5e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-cord\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-cord. Note that a model card gets generated automatically in case you specify the `push_to_hub` flag."
            }
        ]
    },
    {
        "sample_idx": 115,
        "question": "Where is the dataset hosted?",
        "answer": "Kaggle",
        "rag_answer": "The dataset is hosted on Google Cloud Storage.",
        "rag_score": 1,
        "rag_feedback": "The system's response is completely incorrect, inaccurate, and/or not factual. The expected answer is 'Kaggle', but the system's response is a long text about TPUs, Google Cloud Storage, and other unrelated topics.",
        "rag_context": [
            {
                "score": 0.670608427723271,
                "node_text": "Here are some facts extracted from the provided text:\n\nHuggingface ecosystem -> Includes -> Transformers and datasets\n\n!--Copyright 2023 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\nthe License. You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under the License is distributed on\nan \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n\n\u26a0\ufe0f Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be\nrendered properly in your Markdown viewer.\n\n-->\n\n# Training on TPU with TensorFlow\n\n<Tip>\n\nIf you don't need long explanations and just want TPU code samples to get started with, check out [our TPU example notebook!](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb)\n\n</Tip>\n\n### What is a TPU?\n\nA TPU is a **Tensor Processing Unit.** They are hardware designed by Google, which are used to greatly speed up the tensor computations within neural networks, much like GPUs. They can be used for both network training and inference. They are generally accessed through Google\u2019s cloud services, but small TPUs can also be accessed directly for free through Google Colab and Kaggle Kernels.\n\nBecause [all TensorFlow models in \ud83e\udd17 Transformers are Keras models](https://huggingface.co/blog/tensorflow-philosophy), most of the methods in this document are generally applicable to TPU training for any Keras model! However, there are a few points that are specific to the HuggingFace ecosystem (hug-o-system?) of Transformers and Datasets, and we\u2019ll make sure to flag them up when we get to them.\n\n### What kinds of TPU are available?\n\nNew users are often very confused by the range of TPUs, and the different ways to access them. The first key distinction to understand is the difference between **TPU Nodes** and **TPU VMs.**\n\nWhen you use a **TPU Node**, you are effectively indirectly accessing a remote TPU. You will need a separate VM, which will initialize your network and data pipeline and then forward them to the remote node. When you use a TPU on Google Colab, you are accessing it in the **TPU Node** style.\n\nUsing TPU Nodes can have some quite unexpected behaviour for people who aren\u2019t used to them! In particular, because the TPU is located on a physically different system to the machine you\u2019re running your Python code on, your data cannot be local to your machine - any data pipeline that loads from your machine\u2019s internal storage will totally fail! Instead, data must be stored in Google Cloud Storage where your data pipeline can still access it, even when the pipeline is running on the remote TPU node.\n\n<Tip>\n\nIf you can fit all your data in memory as `np.ndarray` or `tf.Tensor`, then you can `fit()` on that data even when using Colab or a TPU Node, without needing to upload it to Google Cloud Storage.\n\n</Tip>\n\n<Tip>\n\n**\ud83e\udd17Specific Hugging Face Tip\ud83e\udd17:** The methods `Dataset.to_tf_dataset()` and its higher-level wrapper `model.prepare_tf_dataset()` , which you will see throughout our TF code examples, will both fail on a TPU Node. The reason for this is that even though they create a `tf.data.Dataset` it is not a \u201cpure\u201d `tf.data` pipeline and uses `tf.numpy_function` or `Dataset.from_generator()` to stream data from the underlying HuggingFace `Dataset`. This HuggingFace `Dataset` is backed by data that is on a local disc and which the remote TPU Node will not be able to read.\n\n</Tip>\n\nThe second way to access a TPU is via a **TPU VM.** When using a TPU VM, you connect directly to the machine that the TPU is attached to, much like training on a GPU VM. TPU VMs are generally easier to work with, particularly when it comes to your data pipeline. All of the above warnings do not apply to TPU VMs!\n\nThis is an opinionated document, so here\u2019s our opinion: **Avoid using TPU Node if possible.** It is more confusing and more difficult to debug than TPU VMs. It is also likely to be unsupported in future - Google\u2019s latest TPU, TPUv4, can only be accessed as a TPU VM, which suggests that TPU Nodes are increasingly going to become a \u201clegacy\u201d access method."
            },
            {
                "score": 0.6644194732084682,
                "node_text": "Here are some facts extracted from the provided text:\n\nSquad -> Is -> Dataset\n\nIf you are evaluating your model on a benchmark dataset like the ones mentioned above, you can use its dedicated evaluation metric. Make sure you respect the format that they require. For example, to evaluate your model on the [SQuAD](https://huggingface.co/datasets/squad) dataset, you need to feed the `question` and `context` into your model and return the `prediction_text`, which should be compared with the `references` (based on matching the `id` of the question) :\n\n```\n>>> from evaluate import load\n>>> squad_metric = load(\"squad\")\n>>> predictions = [{'prediction_text': '1976', 'id': '56e10a3be3433e1400422b22'}]\n>>> references = [{'answers': {'answer_start': [97], 'text': ['1976']}, 'id': '56e10a3be3433e1400422b22'}]\n>>> results = squad_metric.compute(predictions=predictions, references=references)\n>>> results\n{'exact_match': 100.0, 'f1': 100.0}\n```\n\nYou can find examples of dataset structures by consulting the \"Dataset Preview\" function or the dataset card for a given dataset, and you can see how to use its dedicated evaluation function based on the metric card."
            },
            {
                "score": 0.6342859355957499,
                "node_text": "Here are some facts extracted from the provided text:\n\nGradio -> Converts -> Data format\nGradio -> Recognizes -> Data format\n\nGradio Demo: blocks_random_slider\n\n\n```\n!pip install -q gradio \n```\n\n\n```\n\nimport gradio as gr\n\n\ndef func(slider_1, slider_2):\n    return slider_1 * 5 + slider_2\n\n\nwith gr.Blocks() as demo:\n    slider = gr.Slider(minimum=-10.2, maximum=15, label=\"Random Slider (Static)\", randomize=True)\n    slider_1 = gr.Slider(minimum=100, maximum=200, label=\"Random Slider (Input 1)\", randomize=True)\n    slider_2 = gr.Slider(minimum=10, maximum=23.2, label=\"Random Slider (Input 2)\", randomize=True)\n    slider_3 = gr.Slider(value=3, label=\"Non random slider\")\n    btn = gr.Button(\"Run\")\n    btn.click(func, inputs=[slider_1, slider_2], outputs=gr.Number())\n\nif __name__ == \"__main__\":\n    demo.launch()\n\n```"
            },
            {
                "score": 0.626672778290081,
                "node_text": "Here are some facts extracted from the provided text:\n\nFunsd -> Is -> Form understanding dataset\nCord -> Is -> Form understanding dataset\n\n!---\nCopyright 2022 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n-->\n\n# Token classification with LayoutLMv3 (PyTorch version)\n\nThis directory contains a script, `run_funsd_cord.py`, that can be used to fine-tune (or evaluate) LayoutLMv3 on form understanding datasets, such as [FUNSD](https://guillaumejaume.github.io/FUNSD/) and [CORD](https://github.com/clovaai/cord).\n\nThe script `run_funsd_cord.py` leverages the \ud83e\udd17 Datasets library and the Trainer API. You can easily customize it to your needs.\n\n## Fine-tuning on FUNSD\n\nFine-tuning LayoutLMv3 for token classification on [FUNSD](https://guillaumejaume.github.io/FUNSD/) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name funsd \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 1e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-funsd\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd. By specifying the `push_to_hub` flag, the model gets uploaded automatically to the hub (regularly), together with a model card, which includes metrics such as precision, recall and F1. Note that you can easily update the model card, as it's just a README file of the respective repo on the hub.\n\nThere's also the \"Training metrics\" [tab](https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd/tensorboard), which shows Tensorboard logs over the course of training. Pretty neat, huh?\n\n## Fine-tuning on CORD\n\nFine-tuning LayoutLMv3 for token classification on [CORD](https://github.com/clovaai/cord) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name cord \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 5e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-cord\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-cord. Note that a model card gets generated automatically in case you specify the `push_to_hub` flag."
            }
        ]
    },
    {
        "sample_idx": 116,
        "question": "What is the name of the hub where the dataset is uploaded for easy use and download?",
        "answer": "Hugging Face Hub",
        "rag_answer": "The hub where the dataset is uploaded for easy use and download is the Hugging Face hub.",
        "rag_score": 5,
        "rag_feedback": "The system's response is completely correct, accurate, and factual. It directly answers the question by stating that the hub where the dataset is uploaded for easy use and download is the Hugging Face hub.",
        "rag_context": [
            {
                "score": 0.7149573978736757,
                "node_text": "Here are some facts extracted from the provided text:\n\nSquad -> Is -> Dataset\n\nIf you are evaluating your model on a benchmark dataset like the ones mentioned above, you can use its dedicated evaluation metric. Make sure you respect the format that they require. For example, to evaluate your model on the [SQuAD](https://huggingface.co/datasets/squad) dataset, you need to feed the `question` and `context` into your model and return the `prediction_text`, which should be compared with the `references` (based on matching the `id` of the question) :\n\n```\n>>> from evaluate import load\n>>> squad_metric = load(\"squad\")\n>>> predictions = [{'prediction_text': '1976', 'id': '56e10a3be3433e1400422b22'}]\n>>> references = [{'answers': {'answer_start': [97], 'text': ['1976']}, 'id': '56e10a3be3433e1400422b22'}]\n>>> results = squad_metric.compute(predictions=predictions, references=references)\n>>> results\n{'exact_match': 100.0, 'f1': 100.0}\n```\n\nYou can find examples of dataset structures by consulting the \"Dataset Preview\" function or the dataset card for a given dataset, and you can see how to use its dedicated evaluation function based on the metric card."
            },
            {
                "score": 0.6749707027691703,
                "node_text": "Here are some facts extracted from the provided text:\n\nHuggingface ecosystem -> Includes -> Transformers and datasets\n\n!--Copyright 2023 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\nthe License. You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under the License is distributed on\nan \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n\n\u26a0\ufe0f Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be\nrendered properly in your Markdown viewer.\n\n-->\n\n# Training on TPU with TensorFlow\n\n<Tip>\n\nIf you don't need long explanations and just want TPU code samples to get started with, check out [our TPU example notebook!](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb)\n\n</Tip>\n\n### What is a TPU?\n\nA TPU is a **Tensor Processing Unit.** They are hardware designed by Google, which are used to greatly speed up the tensor computations within neural networks, much like GPUs. They can be used for both network training and inference. They are generally accessed through Google\u2019s cloud services, but small TPUs can also be accessed directly for free through Google Colab and Kaggle Kernels.\n\nBecause [all TensorFlow models in \ud83e\udd17 Transformers are Keras models](https://huggingface.co/blog/tensorflow-philosophy), most of the methods in this document are generally applicable to TPU training for any Keras model! However, there are a few points that are specific to the HuggingFace ecosystem (hug-o-system?) of Transformers and Datasets, and we\u2019ll make sure to flag them up when we get to them.\n\n### What kinds of TPU are available?\n\nNew users are often very confused by the range of TPUs, and the different ways to access them. The first key distinction to understand is the difference between **TPU Nodes** and **TPU VMs.**\n\nWhen you use a **TPU Node**, you are effectively indirectly accessing a remote TPU. You will need a separate VM, which will initialize your network and data pipeline and then forward them to the remote node. When you use a TPU on Google Colab, you are accessing it in the **TPU Node** style.\n\nUsing TPU Nodes can have some quite unexpected behaviour for people who aren\u2019t used to them! In particular, because the TPU is located on a physically different system to the machine you\u2019re running your Python code on, your data cannot be local to your machine - any data pipeline that loads from your machine\u2019s internal storage will totally fail! Instead, data must be stored in Google Cloud Storage where your data pipeline can still access it, even when the pipeline is running on the remote TPU node.\n\n<Tip>\n\nIf you can fit all your data in memory as `np.ndarray` or `tf.Tensor`, then you can `fit()` on that data even when using Colab or a TPU Node, without needing to upload it to Google Cloud Storage.\n\n</Tip>\n\n<Tip>\n\n**\ud83e\udd17Specific Hugging Face Tip\ud83e\udd17:** The methods `Dataset.to_tf_dataset()` and its higher-level wrapper `model.prepare_tf_dataset()` , which you will see throughout our TF code examples, will both fail on a TPU Node. The reason for this is that even though they create a `tf.data.Dataset` it is not a \u201cpure\u201d `tf.data` pipeline and uses `tf.numpy_function` or `Dataset.from_generator()` to stream data from the underlying HuggingFace `Dataset`. This HuggingFace `Dataset` is backed by data that is on a local disc and which the remote TPU Node will not be able to read.\n\n</Tip>\n\nThe second way to access a TPU is via a **TPU VM.** When using a TPU VM, you connect directly to the machine that the TPU is attached to, much like training on a GPU VM. TPU VMs are generally easier to work with, particularly when it comes to your data pipeline. All of the above warnings do not apply to TPU VMs!\n\nThis is an opinionated document, so here\u2019s our opinion: **Avoid using TPU Node if possible.** It is more confusing and more difficult to debug than TPU VMs. It is also likely to be unsupported in future - Google\u2019s latest TPU, TPUv4, can only be accessed as a TPU VM, which suggests that TPU Nodes are increasingly going to become a \u201clegacy\u201d access method."
            },
            {
                "score": 0.6704468420963897,
                "node_text": "Here are some facts extracted from the provided text:\n\nFunsd -> Is -> Form understanding dataset\nCord -> Is -> Form understanding dataset\n\n!---\nCopyright 2022 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n-->\n\n# Token classification with LayoutLMv3 (PyTorch version)\n\nThis directory contains a script, `run_funsd_cord.py`, that can be used to fine-tune (or evaluate) LayoutLMv3 on form understanding datasets, such as [FUNSD](https://guillaumejaume.github.io/FUNSD/) and [CORD](https://github.com/clovaai/cord).\n\nThe script `run_funsd_cord.py` leverages the \ud83e\udd17 Datasets library and the Trainer API. You can easily customize it to your needs.\n\n## Fine-tuning on FUNSD\n\nFine-tuning LayoutLMv3 for token classification on [FUNSD](https://guillaumejaume.github.io/FUNSD/) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name funsd \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 1e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-funsd\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd. By specifying the `push_to_hub` flag, the model gets uploaded automatically to the hub (regularly), together with a model card, which includes metrics such as precision, recall and F1. Note that you can easily update the model card, as it's just a README file of the respective repo on the hub.\n\nThere's also the \"Training metrics\" [tab](https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd/tensorboard), which shows Tensorboard logs over the course of training. Pretty neat, huh?\n\n## Fine-tuning on CORD\n\nFine-tuning LayoutLMv3 for token classification on [CORD](https://github.com/clovaai/cord) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name cord \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 5e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-cord\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-cord. Note that a model card gets generated automatically in case you specify the `push_to_hub` flag."
            },
            {
                "score": 0.6579948499452257,
                "node_text": "Here are some facts extracted from the provided text:\n\nGradio -> Converts -> Data format\nGradio -> Recognizes -> Data format\n\nGradio Demo: blocks_random_slider\n\n\n```\n!pip install -q gradio \n```\n\n\n```\n\nimport gradio as gr\n\n\ndef func(slider_1, slider_2):\n    return slider_1 * 5 + slider_2\n\n\nwith gr.Blocks() as demo:\n    slider = gr.Slider(minimum=-10.2, maximum=15, label=\"Random Slider (Static)\", randomize=True)\n    slider_1 = gr.Slider(minimum=100, maximum=200, label=\"Random Slider (Input 1)\", randomize=True)\n    slider_2 = gr.Slider(minimum=10, maximum=23.2, label=\"Random Slider (Input 2)\", randomize=True)\n    slider_3 = gr.Slider(value=3, label=\"Non random slider\")\n    btn = gr.Button(\"Run\")\n    btn.click(func, inputs=[slider_1, slider_2], outputs=gr.Number())\n\nif __name__ == \"__main__\":\n    demo.launch()\n\n```"
            }
        ]
    },
    {
        "sample_idx": 117,
        "question": "What is the purpose of the filter_map function?",
        "answer": "To filter data based on price and location",
        "rag_answer": "There is no mention of a \"filter_map\" function in the provided context information. The context discusses XLA rules, padding, attention masks, and Gradio batch functions, but it does not mention a \"filter_map\" function. Therefore, it is not possible to determine the purpose of this function based on the provided context.",
        "rag_score": 1,
        "rag_feedback": "The system's response is completely incorrect, inaccurate, and/or not factual. The response does not provide any information about the purpose of the filter_map function, instead, it mentions that there is no mention of a 'filter_map' function in the provided context information.",
        "rag_context": [
            {
                "score": 0.6173244833766081,
                "node_text": "Here are some facts extracted from the provided text:\n\nAttention_mask -> Is used -> With padding\n\nThis is a really useful trick, so remember it if you need to convert your own code to XLA!\n\n#### XLA Rule #3: XLA will need to recompile your model for every different input shape it sees\n\nThis is the big one. What this means is that if your input shapes are very variable, XLA will have to recompile your model over and over, which will create huge performance problems. This commonly arises in NLP models, where input texts have variable lengths after tokenization. In other modalities, static shapes are more common and this rule is much less of a problem.\n\nHow can you get around rule #3? The key is **padding** - if you pad all your inputs to the same length, and then use an `attention_mask`, you can get the same results as you\u2019d get from variable shapes, but without any XLA issues. However, excessive padding can cause severe slowdown too - if you pad all your samples to the maximum length in the whole dataset, you might end up with batches consisting endless padding tokens, which will waste a lot of compute and memory!\n\nThere isn\u2019t a perfect solution to this problem. However, you can try some tricks. One very useful trick is to **pad batches of samples up to a multiple of a number like 32 or 64 tokens.** This often only increases the number of tokens by a small amount, but it hugely reduces the number of unique input shapes, because every input shape now has to be a multiple of 32 or 64. Fewer unique input shapes means fewer XLA compilations!\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** Our tokenizers and data collators have methods that can help you here. You can use `padding=\"max_length\"` or `padding=\"longest\"` when calling tokenizers to get them to output padded data. Our tokenizers and data collators also have a `pad_to_multiple_of` argument that you can use to reduce the number of unique input shapes you see!\n\n</Tip>\n\n### How do I actually train my model on TPU?\n\nOnce your training is XLA-compatible and (if you\u2019re using TPU Node / Colab) your dataset has been prepared appropriately, running on TPU is surprisingly easy! All you really need to change in your code is to add a few lines to initialize your TPU, and to ensure that your model and dataset are created inside a `TPUStrategy` scope. Take a look at [our TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) to see this in action!\n\n### Summary\n\nThere was a lot in here, so let\u2019s summarize with a quick checklist you can follow when you want to get your model ready for TPU training:\n\n- Make sure your code follows the three rules of XLA\n- Compile your model with `jit_compile=True` on CPU/GPU and confirm that you can train it with XLA\n- Either load your dataset into memory or use a TPU-compatible dataset loading approach (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Migrate your code either to Colab (with accelerator set to \u201cTPU\u201d) or a TPU VM on Google Cloud\n- Add TPU initializer code (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Create your `TPUStrategy` and make sure dataset loading and model creation are inside the `strategy.scope()` (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Don\u2019t forget to take `jit_compile=True` out again when you move to TPU!\n- \ud83d\ude4f\ud83d\ude4f\ud83d\ude4f\ud83e\udd7a\ud83e\udd7a\ud83e\udd7a\n- Call model.fit()\n- You did it!"
            },
            {
                "score": 0.616750610287872,
                "node_text": "Here are some facts extracted from the provided text:\n\nBatch functions -> Accept -> Input lists\nBatch functions -> Return -> Prediction lists\nTrim_words -> Is -> Batch function\n\ntqdm` \u81ea\u52a8\u62a5\u544a\u8fdb\u5ea6\u66f4\u65b0\uff0c\u8bf7\u5c06\u9ed8\u8ba4\u53c2\u6570\u8bbe\u7f6e\u4e3a `gr.Progress(track_tqdm=True)`\uff01\n\n## \u6279\u5904\u7406\u51fd\u6570 (Batch Functions)\n\nGradio \u652f\u6301\u4f20\u9012*\u6279\u5904\u7406*\u51fd\u6570\u3002\u6279\u5904\u7406\u51fd\u6570\u53ea\u662f\u63a5\u53d7\u8f93\u5165\u5217\u8868\u5e76\u8fd4\u56de\u9884\u6d4b\u5217\u8868\u7684\u51fd\u6570\u3002\n\n\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\u6279\u5904\u7406\u51fd\u6570\uff0c\u5b83\u63a5\u53d7\u4e24\u4e2a\u8f93\u5165\u5217\u8868\uff08\u4e00\u4e2a\u5355\u8bcd\u5217\u8868\u548c\u4e00\u4e2a\u6574\u6570\u5217\u8868\uff09\uff0c\u5e76\u8fd4\u56de\u4fee\u526a\u8fc7\u7684\u5355\u8bcd\u5217\u8868\u4f5c\u4e3a\u8f93\u51fa\uff1a\n\n```python\nimport time\n\ndef trim_words(words, lens):\n    trimmed_words = []\n    time.sleep(5)\n    for w, l in zip(words, lens):\n        trimmed_words.append(w[:int(l)])\n    return [trimmed_words]\n    for w, l in zip(words, lens):\n```\n\n\u4f7f\u7528\u6279\u5904\u7406\u51fd\u6570\u7684\u4f18\u70b9\u662f\uff0c\u5982\u679c\u542f\u7528\u4e86\u961f\u5217\uff0cGradio \u670d\u52a1\u5668\u53ef\u4ee5\u81ea\u52a8*\u6279\u5904\u7406*\u4f20\u5165\u7684\u8bf7\u6c42\u5e76\u5e76\u884c\u5904\u7406\u5b83\u4eec\uff0c\u4ece\u800c\u53ef\u80fd\u52a0\u5feb\u6f14\u793a\u901f\u5ea6\u3002\u4ee5\u4e0b\u662f Gradio \u4ee3\u7801\u7684\u793a\u4f8b\uff08\u8bf7\u6ce8\u610f `batch=True` \u548c `max_batch_size=16` - \u8fd9\u4e24\u4e2a\u53c2\u6570\u90fd\u53ef\u4ee5\u4f20\u9012\u7ed9\u4e8b\u4ef6\u89e6\u53d1\u5668\u6216 `Interface` \u7c7b\uff09\n\nwith `Interface`\uff1a\n\n```python\ndemo = gr.Interface(trim_words, [\"textbox\", \"number\"], [\"output\"],\n                    batch=True, max_batch_size=16)\ndemo.queue()\ndemo.launch()\n```\n\nwith `Blocks`\uff1a\n\n```python\nimport gradio as gr\n\nwith gr.Blocks() as demo:\n    with gr.Row():\n        word = gr.Textbox(label=\"word\")\n        leng = gr.Number(label=\"leng\")\n        output = gr.Textbox(label=\"Output\")\n    with gr.Row():\n        run = gr.Button()\n\n    event = run.click(trim_words, [word, leng], output, batch=True, max_batch_size=16)\n\ndemo.queue()\ndemo.launch()\n```\n\n\u5728\u4e0a\u9762\u7684\u793a\u4f8b\u4e2d\uff0c\u53ef\u4ee5\u5e76\u884c\u5904\u7406 16 \u4e2a\u8bf7\u6c42\uff08\u603b\u63a8\u7406\u65f6\u95f4\u4e3a 5 \u79d2\uff09\uff0c\u800c\u4e0d\u662f\u5206\u522b\u5904\u7406\u6bcf\u4e2a\u8bf7\u6c42\uff08\u603b\u63a8\u7406\u65f6\u95f4\u4e3a 80 \u79d2\uff09\u3002\u8bb8\u591a Hugging Face \u7684 `transformers` \u548c `diffusers` \u6a21\u578b\u5728 Gradio \u7684\u6279\u5904\u7406\u6a21\u5f0f\u4e0b\u81ea\u7136\u5de5\u4f5c\uff1a\u8fd9\u662f[\u4f7f\u7528\u6279\u5904\u7406\u751f\u6210\u56fe\u50cf\u7684\u793a\u4f8b\u6f14\u793a](https://github.com/gradio-app/gradio/blob/main/demo/diffusers_with_batching/run.py)\n\n\u6ce8\u610f\uff1a\u4f7f\u7528 Gradio \u7684\u6279\u5904\u7406\u51fd\u6570 **requires** \u5728\u5e95\u5c42 Interface \u6216 Blocks \u4e2d\u542f\u7528\u961f\u5217\uff08\u8bf7\u53c2\u9605\u4e0a\u9762\u7684\u961f\u5217\u90e8\u5206\uff09\u3002\n\n## Gradio \u7b14\u8bb0\u672c (Colab Notebooks)\n\nGradio \u53ef\u4ee5\u5728\u4efb\u4f55\u8fd0\u884c Python \u7684\u5730\u65b9\u8fd0\u884c\uff0c\u5305\u62ec\u672c\u5730 Jupyter \u7b14\u8bb0\u672c\u548c\u534f\u4f5c\u7b14\u8bb0\u672c\uff0c\u5982[Google Colab](https://colab.research.google.com/)\u3002\u5bf9\u4e8e\u672c\u5730 Jupyter \u7b14\u8bb0\u672c\u548c Google Colab \u7b14\u8bb0\u672c\uff0cGradio \u5728\u672c\u5730\u670d\u52a1\u5668\u4e0a\u8fd0\u884c\uff0c\u60a8\u53ef\u4ee5\u5728\u6d4f\u89c8\u5668\u4e2d\u4e0e\u4e4b\u4ea4\u4e92\u3002\uff08\u6ce8\u610f\uff1a\u5bf9\u4e8e Google Colab\uff0c\u8fd9\u662f\u901a\u8fc7[\u670d\u52a1\u5de5\u4f5c\u5668\u96a7\u9053](https://github.com/tensorflow/tensorboard/blob/master/docs/design/colab_integration.md)\u5b9e\u73b0\u7684\uff0c\u60a8\u7684\u6d4f\u89c8\u5668\u9700\u8981\u542f\u7528 cookies\u3002\uff09\u5bf9\u4e8e\u5176\u4ed6\u8fdc\u7a0b\u7b14\u8bb0\u672c\uff0cGradio \u4e5f\u5c06\u5728\u670d\u52a1\u5668\u4e0a\u8fd0\u884c\uff0c\u4f46\u60a8\u9700\u8981\u4f7f\u7528[SSH \u96a7\u9053](https://coderwall.com/p/ohk6cg/remote-access-to-ipython-notebooks-via-ssh)\u5728\u672c\u5730\u6d4f\u89c8\u5668\u4e2d\u67e5\u770b\u5e94\u7528\u7a0b\u5e8f\u3002\u901a\u5e38\uff0c\u66f4\u7b80\u5355\u7684\u9009\u62e9\u662f\u4f7f\u7528 Gradio \u5185\u7f6e\u7684\u516c\u5171\u94fe\u63a5\uff0c[\u5728\u4e0b\u4e00\u7bc7\u6307\u5357\u4e2d\u8ba8\u8bba](/sharing-your-app/#sharing-demos)\u3002"
            },
            {
                "score": 0.616750610287872,
                "node_text": "Here are some facts extracted from the provided text:\n\nGradio -> Supports -> Batch functions\nGradio -> Automatically handles -> Postprocessing\n\nGradio Demo: blocks_random_slider\n\n\n```\n!pip install -q gradio \n```\n\n\n```\n\nimport gradio as gr\n\n\ndef func(slider_1, slider_2):\n    return slider_1 * 5 + slider_2\n\n\nwith gr.Blocks() as demo:\n    slider = gr.Slider(minimum=-10.2, maximum=15, label=\"Random Slider (Static)\", randomize=True)\n    slider_1 = gr.Slider(minimum=100, maximum=200, label=\"Random Slider (Input 1)\", randomize=True)\n    slider_2 = gr.Slider(minimum=10, maximum=23.2, label=\"Random Slider (Input 2)\", randomize=True)\n    slider_3 = gr.Slider(value=3, label=\"Non random slider\")\n    btn = gr.Button(\"Run\")\n    btn.click(func, inputs=[slider_1, slider_2], outputs=gr.Number())\n\nif __name__ == \"__main__\":\n    demo.launch()\n\n```"
            }
        ]
    },
    {
        "sample_idx": 118,
        "question": "What is the library used to load the CSV data?",
        "answer": "datasets",
        "rag_answer": "There is no mention of loading CSV data or a library used for it in the provided context information. The context discusses Hugging Face ecosystem, TPU training with TensorFlow, and Gradio library, but it does not mention CSV data or a library for loading it.",
        "rag_score": 1,
        "rag_feedback": "The system's response is completely incorrect, inaccurate, and/or not factual. The question asks about the library used to load CSV data, but the system's response does not mention CSV data or a library for loading it. Instead, it provides information about the Hugging Face ecosystem, TPU training with TensorFlow, and the Gradio library, which is not relevant to the question.",
        "rag_context": [
            {
                "score": 0.639473233782418,
                "node_text": "Here are some facts extracted from the provided text:\n\nHuggingface ecosystem -> Includes -> Transformers and datasets\n\n!--Copyright 2023 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\nthe License. You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under the License is distributed on\nan \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n\n\u26a0\ufe0f Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be\nrendered properly in your Markdown viewer.\n\n-->\n\n# Training on TPU with TensorFlow\n\n<Tip>\n\nIf you don't need long explanations and just want TPU code samples to get started with, check out [our TPU example notebook!](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb)\n\n</Tip>\n\n### What is a TPU?\n\nA TPU is a **Tensor Processing Unit.** They are hardware designed by Google, which are used to greatly speed up the tensor computations within neural networks, much like GPUs. They can be used for both network training and inference. They are generally accessed through Google\u2019s cloud services, but small TPUs can also be accessed directly for free through Google Colab and Kaggle Kernels.\n\nBecause [all TensorFlow models in \ud83e\udd17 Transformers are Keras models](https://huggingface.co/blog/tensorflow-philosophy), most of the methods in this document are generally applicable to TPU training for any Keras model! However, there are a few points that are specific to the HuggingFace ecosystem (hug-o-system?) of Transformers and Datasets, and we\u2019ll make sure to flag them up when we get to them.\n\n### What kinds of TPU are available?\n\nNew users are often very confused by the range of TPUs, and the different ways to access them. The first key distinction to understand is the difference between **TPU Nodes** and **TPU VMs.**\n\nWhen you use a **TPU Node**, you are effectively indirectly accessing a remote TPU. You will need a separate VM, which will initialize your network and data pipeline and then forward them to the remote node. When you use a TPU on Google Colab, you are accessing it in the **TPU Node** style.\n\nUsing TPU Nodes can have some quite unexpected behaviour for people who aren\u2019t used to them! In particular, because the TPU is located on a physically different system to the machine you\u2019re running your Python code on, your data cannot be local to your machine - any data pipeline that loads from your machine\u2019s internal storage will totally fail! Instead, data must be stored in Google Cloud Storage where your data pipeline can still access it, even when the pipeline is running on the remote TPU node.\n\n<Tip>\n\nIf you can fit all your data in memory as `np.ndarray` or `tf.Tensor`, then you can `fit()` on that data even when using Colab or a TPU Node, without needing to upload it to Google Cloud Storage.\n\n</Tip>\n\n<Tip>\n\n**\ud83e\udd17Specific Hugging Face Tip\ud83e\udd17:** The methods `Dataset.to_tf_dataset()` and its higher-level wrapper `model.prepare_tf_dataset()` , which you will see throughout our TF code examples, will both fail on a TPU Node. The reason for this is that even though they create a `tf.data.Dataset` it is not a \u201cpure\u201d `tf.data` pipeline and uses `tf.numpy_function` or `Dataset.from_generator()` to stream data from the underlying HuggingFace `Dataset`. This HuggingFace `Dataset` is backed by data that is on a local disc and which the remote TPU Node will not be able to read.\n\n</Tip>\n\nThe second way to access a TPU is via a **TPU VM.** When using a TPU VM, you connect directly to the machine that the TPU is attached to, much like training on a GPU VM. TPU VMs are generally easier to work with, particularly when it comes to your data pipeline. All of the above warnings do not apply to TPU VMs!\n\nThis is an opinionated document, so here\u2019s our opinion: **Avoid using TPU Node if possible.** It is more confusing and more difficult to debug than TPU VMs. It is also likely to be unsupported in future - Google\u2019s latest TPU, TPUv4, can only be accessed as a TPU VM, which suggests that TPU Nodes are increasingly going to become a \u201clegacy\u201d access method."
            },
            {
                "score": 0.6233595936346427,
                "node_text": "Here are some facts extracted from the provided text:\n\nGradio -> Is -> Library\nGradio -> Converts -> Data format\nGradio -> Recognizes -> Data format\n\nGradio Demo: blocks_random_slider\n\n\n```\n!pip install -q gradio \n```\n\n\n```\n\nimport gradio as gr\n\n\ndef func(slider_1, slider_2):\n    return slider_1 * 5 + slider_2\n\n\nwith gr.Blocks() as demo:\n    slider = gr.Slider(minimum=-10.2, maximum=15, label=\"Random Slider (Static)\", randomize=True)\n    slider_1 = gr.Slider(minimum=100, maximum=200, label=\"Random Slider (Input 1)\", randomize=True)\n    slider_2 = gr.Slider(minimum=10, maximum=23.2, label=\"Random Slider (Input 2)\", randomize=True)\n    slider_3 = gr.Slider(value=3, label=\"Non random slider\")\n    btn = gr.Button(\"Run\")\n    btn.click(func, inputs=[slider_1, slider_2], outputs=gr.Number())\n\nif __name__ == \"__main__\":\n    demo.launch()\n\n```"
            },
            {
                "score": 0.6198847072625414,
                "node_text": "Here are some facts extracted from the provided text:\n\nComponents -> Can handle -> Various data types\n\n[annotated](/assets/img/dataflow.svg)\n\n\u5982\u60a8\u6240\u89c1\uff0cGradio \u5305\u62ec\u53ef\u4ee5\u5904\u7406\u5404\u79cd\u4e0d\u540c\u6570\u636e\u7c7b\u578b\u7684\u7ec4\u4ef6\uff0c\u4f8b\u5982\u56fe\u50cf\u3001\u97f3\u9891\u548c\u89c6\u9891\u3002\u5927\u591a\u6570\u7ec4\u4ef6\u90fd\u53ef\u4ee5\u7528\u4f5c\u8f93\u5165\u6216\u8f93\u51fa\u3002\n\n\u5f53\u7ec4\u4ef6\u7528\u4f5c\u8f93\u5165\u65f6\uff0cGradio \u81ea\u52a8\u5904\u7406*\u9884\u5904\u7406*\uff0c\u5c06\u6570\u636e\u4ece\u7528\u6237\u6d4f\u89c8\u5668\u53d1\u9001\u7684\u7c7b\u578b\uff08\u4f8b\u5982\u7f51\u7edc\u6444\u50cf\u5934\u5feb\u7167\u7684 base64 \u8868\u793a\uff09\u8f6c\u6362\u4e3a\u60a8\u7684\u51fd\u6570\u53ef\u4ee5\u63a5\u53d7\u7684\u5f62\u5f0f\uff08\u4f8b\u5982 `numpy` \u6570\u7ec4\uff09\u3002\n\n\u540c\u6837\uff0c\u5f53\u7ec4\u4ef6\u7528\u4f5c\u8f93\u51fa\u65f6\uff0cGradio \u81ea\u52a8\u5904\u7406*\u540e\u5904\u7406*\uff0c\u5c06\u6570\u636e\u4ece\u51fd\u6570\u8fd4\u56de\u7684\u5f62\u5f0f\uff08\u4f8b\u5982\u56fe\u50cf\u8def\u5f84\u5217\u8868\uff09\u8f6c\u6362\u4e3a\u53ef\u4ee5\u5728\u7528\u6237\u6d4f\u89c8\u5668\u4e2d\u663e\u793a\u7684\u5f62\u5f0f\uff08\u4f8b\u5982\u4ee5 base64 \u683c\u5f0f\u663e\u793a\u56fe\u50cf\u7684 `Gallery`\uff09\u3002\n\n\u60a8\u53ef\u4ee5\u4f7f\u7528\u6784\u5efa\u56fe\u50cf\u7ec4\u4ef6\u65f6\u7684\u53c2\u6570\u63a7\u5236*\u9884\u5904\u7406*\u3002\u4f8b\u5982\uff0c\u5982\u679c\u60a8\u4f7f\u7528\u4ee5\u4e0b\u53c2\u6570\u5b9e\u4f8b\u5316 `Image` \u7ec4\u4ef6\uff0c\u5b83\u5c06\u5c06\u56fe\u50cf\u8f6c\u6362\u4e3a `PIL` \u7c7b\u578b\uff0c\u5e76\u5c06\u5176\u91cd\u5851\u4e3a`(100, 100)`\uff0c\u800c\u4e0d\u7ba1\u63d0\u4ea4\u65f6\u7684\u539f\u59cb\u5927\u5c0f\u5982\u4f55\uff1a\n\n```py\nimg = gr.Image(shape=(100, 100), type=\"pil\")\n```\n\n\u76f8\u53cd\uff0c\u8fd9\u91cc\u6211\u4eec\u4fdd\u7559\u56fe\u50cf\u7684\u539f\u59cb\u5927\u5c0f\uff0c\u4f46\u5728\u5c06\u5176\u8f6c\u6362\u4e3a numpy \u6570\u7ec4\u4e4b\u524d\u53cd\u8f6c\u989c\u8272\uff1a\n\n```py\nimg = gr.Image(invert_colors=True, type=\"numpy\")\n```\n\n\u540e\u5904\u7406\u8981\u5bb9\u6613\u5f97\u591a\uff01Gradio \u81ea\u52a8\u8bc6\u522b\u8fd4\u56de\u6570\u636e\u7684\u683c\u5f0f\uff08\u4f8b\u5982 `Image` \u662f `numpy` \u6570\u7ec4\u8fd8\u662f `str` \u6587\u4ef6\u8def\u5f84\uff1f\uff09\uff0c\u5e76\u5c06\u5176\u540e\u5904\u7406\u4e3a\u53ef\u4ee5\u7531\u6d4f\u89c8\u5668\u663e\u793a\u7684\u683c\u5f0f\u3002\n\n\u8bf7\u67e5\u770b[\u6587\u6863](https://gradio.app/docs)\uff0c\u4e86\u89e3\u6bcf\u4e2a\u7ec4\u4ef6\u7684\u6240\u6709\u4e0e\u9884\u5904\u7406\u76f8\u5173\u7684\u53c2\u6570\u3002\n\n## \u6837\u5f0f (Styling)\n\nGradio \u4e3b\u9898\u662f\u81ea\u5b9a\u4e49\u5e94\u7528\u7a0b\u5e8f\u5916\u89c2\u548c\u611f\u89c9\u7684\u6700\u7b80\u5355\u65b9\u6cd5\u3002\u60a8\u53ef\u4ee5\u9009\u62e9\u591a\u79cd\u4e3b\u9898\u6216\u521b\u5efa\u81ea\u5df1\u7684\u4e3b\u9898\u3002\u8981\u8fd9\u6837\u505a\uff0c\u8bf7\u5c06 `theme=` \u53c2\u6570\u4f20\u9012\u7ed9 `Interface` \u6784\u9020\u51fd\u6570\u3002\u4f8b\u5982\uff1a\n\n```python\ndemo = gr.Interface(..., theme=gr.themes.Monochrome())\n```\n\nGradio \u5e26\u6709\u4e00\u7ec4\u9884\u5148\u6784\u5efa\u7684\u4e3b\u9898\uff0c\u60a8\u53ef\u4ee5\u4ece `gr.themes.*` \u52a0\u8f7d\u3002\u60a8\u53ef\u4ee5\u6269\u5c55\u8fd9\u4e9b\u4e3b\u9898\u6216\u4ece\u5934\u5f00\u59cb\u521b\u5efa\u81ea\u5df1\u7684\u4e3b\u9898 - \u6709\u5173\u66f4\u591a\u8be6\u7ec6\u4fe1\u606f\uff0c\u8bf7\u53c2\u9605[\u4e3b\u9898\u6307\u5357](https://gradio.app/theming-guide)\u3002\n\n\u8981\u589e\u52a0\u989d\u5916\u7684\u6837\u5f0f\u80fd\u529b\uff0c\u60a8\u53ef\u4ee5 with `css=` \u5173\u952e\u5b57\u5c06\u4efb\u4f55 CSS \u4f20\u9012\u7ed9\u60a8\u7684\u5e94\u7528\u7a0b\u5e8f\u3002\nGradio \u5e94\u7528\u7a0b\u5e8f\u7684\u57fa\u7c7b\u662f `gradio-container`\uff0c\u56e0\u6b64\u4ee5\u4e0b\u662f\u4e00\u4e2a\u66f4\u6539 Gradio \u5e94\u7528\u7a0b\u5e8f\u80cc\u666f\u989c\u8272\u7684\u793a\u4f8b\uff1a\n\n```python\nwith `gr.Interface(css=\".gradio-container {background-color: red}\") as demo:\n    .\n```\n\n## \u961f\u5217 (Queuing)\n\n\u5982\u679c\u60a8\u7684\u5e94\u7528\u7a0b\u5e8f\u9884\u8ba1\u4f1a\u6709\u5927\u91cf\u6d41\u91cf\uff0c\u8bf7 with `queue()` \u65b9\u6cd5\u6765\u63a7\u5236\u5904\u7406\u901f\u7387\u3002\u8fd9\u5c06\u6392\u961f\u5904\u7406\u8c03\u7528\uff0c\u56e0\u6b64\u4e00\u6b21\u53ea\u5904\u7406\u4e00\u5b9a\u6570\u91cf\u7684\u8bf7\u6c42\u3002\u961f\u5217\u4f7f\u7528 Websockets\uff0c\u8fd8\u53ef\u4ee5\u9632\u6b62\u7f51\u7edc\u8d85\u65f6\uff0c\u56e0\u6b64\u5982\u679c\u60a8\u7684\u51fd\u6570\u7684\u63a8\u7406\u65f6\u95f4\u5f88\u957f\uff08> 1 \u5206\u949f\uff09\uff0c\u5e94\u4f7f\u7528\u961f\u5217\u3002\n\nwith `Interface`\uff1a\n\n```python\ndemo = gr.Interface(.).queue()\ndemo.launch()\n```\n\nwith `Blocks`\uff1a\n\n```python\nwith gr.Blocks() as demo\uff1a\n    #.\ndemo.queue()\ndemo.launch()\n```\n\n\u60a8\u53ef\u4ee5\u901a\u8fc7\u4ee5\u4e0b\u65b9\u5f0f\u63a7\u5236\u4e00\u6b21\u5904\u7406\u7684\u8bf7\u6c42\u6570\u91cf\uff1a\n\n```python\ndemo.queue(concurrency_count=3)\n```\n\n\u67e5\u770b\u6709\u5173\u914d\u7f6e\u5176\u4ed6\u961f\u5217\u53c2\u6570\u7684[\u961f\u5217\u6587\u6863](/docs/#queue)\u3002\n\n\u5728 Blocks \u4e2d\u6307\u5b9a\u4ec5\u5bf9\u67d0\u4e9b\u51fd\u6570\u8fdb\u884c\u6392\u961f\uff1a\n\n```python\nwith gr.Blocks() as demo2\uff1a\n    num1 = gr.Number()\n    num2 = gr.Number()\n    output = gr.Number()\n    gr.Button(\"Add\").click(\n        lambda a, b: a + b, [num1, num2], output)\n    gr.Button(\"Multiply\").click(\n        lambda a, b: a * b, [num1, num2], output, queue=True)\ndemo2."
            }
        ]
    },
    {
        "sample_idx": 119,
        "question": "What is the name of the Plotly module used to create the map chart?",
        "answer": "plotly.graph_objects",
        "rag_answer": "There is no mention of Plotly or a map chart in the provided context information. The context appears to be related to Gradio, TPUs, and XLA, but it does not mention Plotly or map charts. Therefore, it is not possible to answer this query based on the provided context.",
        "rag_score": 1,
        "rag_feedback": "The system's response is completely incorrect, inaccurate, and not factual. The question asks about the Plotly module used to create a map chart, but the system's response is unrelated to Plotly or map charts. It appears to be a response to a different question or context, discussing Gradio, TPUs, and XLA.",
        "rag_context": [
            {
                "score": 0.604566875332239,
                "node_text": "Here are some facts extracted from the provided text:\n\nSlider -> Is -> Gr.slider\nGradio -> Can run -> In colab notebooks\n\nGradio Demo: blocks_random_slider\n\n\n```\n!pip install -q gradio \n```\n\n\n```\n\nimport gradio as gr\n\n\ndef func(slider_1, slider_2):\n    return slider_1 * 5 + slider_2\n\n\nwith gr.Blocks() as demo:\n    slider = gr.Slider(minimum=-10.2, maximum=15, label=\"Random Slider (Static)\", randomize=True)\n    slider_1 = gr.Slider(minimum=100, maximum=200, label=\"Random Slider (Input 1)\", randomize=True)\n    slider_2 = gr.Slider(minimum=10, maximum=23.2, label=\"Random Slider (Input 2)\", randomize=True)\n    slider_3 = gr.Slider(value=3, label=\"Non random slider\")\n    btn = gr.Button(\"Run\")\n    btn.click(func, inputs=[slider_1, slider_2], outputs=gr.Number())\n\nif __name__ == \"__main__\":\n    demo.launch()\n\n```"
            },
            {
                "score": 0.5849405500154966,
                "node_text": "Here are some facts extracted from the provided text:\n\nImage component -> Can be controlled -> Preprocessing parameters\n\n[annotated](/assets/img/dataflow.svg)\n\n\u5982\u60a8\u6240\u89c1\uff0cGradio \u5305\u62ec\u53ef\u4ee5\u5904\u7406\u5404\u79cd\u4e0d\u540c\u6570\u636e\u7c7b\u578b\u7684\u7ec4\u4ef6\uff0c\u4f8b\u5982\u56fe\u50cf\u3001\u97f3\u9891\u548c\u89c6\u9891\u3002\u5927\u591a\u6570\u7ec4\u4ef6\u90fd\u53ef\u4ee5\u7528\u4f5c\u8f93\u5165\u6216\u8f93\u51fa\u3002\n\n\u5f53\u7ec4\u4ef6\u7528\u4f5c\u8f93\u5165\u65f6\uff0cGradio \u81ea\u52a8\u5904\u7406*\u9884\u5904\u7406*\uff0c\u5c06\u6570\u636e\u4ece\u7528\u6237\u6d4f\u89c8\u5668\u53d1\u9001\u7684\u7c7b\u578b\uff08\u4f8b\u5982\u7f51\u7edc\u6444\u50cf\u5934\u5feb\u7167\u7684 base64 \u8868\u793a\uff09\u8f6c\u6362\u4e3a\u60a8\u7684\u51fd\u6570\u53ef\u4ee5\u63a5\u53d7\u7684\u5f62\u5f0f\uff08\u4f8b\u5982 `numpy` \u6570\u7ec4\uff09\u3002\n\n\u540c\u6837\uff0c\u5f53\u7ec4\u4ef6\u7528\u4f5c\u8f93\u51fa\u65f6\uff0cGradio \u81ea\u52a8\u5904\u7406*\u540e\u5904\u7406*\uff0c\u5c06\u6570\u636e\u4ece\u51fd\u6570\u8fd4\u56de\u7684\u5f62\u5f0f\uff08\u4f8b\u5982\u56fe\u50cf\u8def\u5f84\u5217\u8868\uff09\u8f6c\u6362\u4e3a\u53ef\u4ee5\u5728\u7528\u6237\u6d4f\u89c8\u5668\u4e2d\u663e\u793a\u7684\u5f62\u5f0f\uff08\u4f8b\u5982\u4ee5 base64 \u683c\u5f0f\u663e\u793a\u56fe\u50cf\u7684 `Gallery`\uff09\u3002\n\n\u60a8\u53ef\u4ee5\u4f7f\u7528\u6784\u5efa\u56fe\u50cf\u7ec4\u4ef6\u65f6\u7684\u53c2\u6570\u63a7\u5236*\u9884\u5904\u7406*\u3002\u4f8b\u5982\uff0c\u5982\u679c\u60a8\u4f7f\u7528\u4ee5\u4e0b\u53c2\u6570\u5b9e\u4f8b\u5316 `Image` \u7ec4\u4ef6\uff0c\u5b83\u5c06\u5c06\u56fe\u50cf\u8f6c\u6362\u4e3a `PIL` \u7c7b\u578b\uff0c\u5e76\u5c06\u5176\u91cd\u5851\u4e3a`(100, 100)`\uff0c\u800c\u4e0d\u7ba1\u63d0\u4ea4\u65f6\u7684\u539f\u59cb\u5927\u5c0f\u5982\u4f55\uff1a\n\n```py\nimg = gr.Image(shape=(100, 100), type=\"pil\")\n```\n\n\u76f8\u53cd\uff0c\u8fd9\u91cc\u6211\u4eec\u4fdd\u7559\u56fe\u50cf\u7684\u539f\u59cb\u5927\u5c0f\uff0c\u4f46\u5728\u5c06\u5176\u8f6c\u6362\u4e3a numpy \u6570\u7ec4\u4e4b\u524d\u53cd\u8f6c\u989c\u8272\uff1a\n\n```py\nimg = gr.Image(invert_colors=True, type=\"numpy\")\n```\n\n\u540e\u5904\u7406\u8981\u5bb9\u6613\u5f97\u591a\uff01Gradio \u81ea\u52a8\u8bc6\u522b\u8fd4\u56de\u6570\u636e\u7684\u683c\u5f0f\uff08\u4f8b\u5982 `Image` \u662f `numpy` \u6570\u7ec4\u8fd8\u662f `str` \u6587\u4ef6\u8def\u5f84\uff1f\uff09\uff0c\u5e76\u5c06\u5176\u540e\u5904\u7406\u4e3a\u53ef\u4ee5\u7531\u6d4f\u89c8\u5668\u663e\u793a\u7684\u683c\u5f0f\u3002\n\n\u8bf7\u67e5\u770b[\u6587\u6863](https://gradio.app/docs)\uff0c\u4e86\u89e3\u6bcf\u4e2a\u7ec4\u4ef6\u7684\u6240\u6709\u4e0e\u9884\u5904\u7406\u76f8\u5173\u7684\u53c2\u6570\u3002\n\n## \u6837\u5f0f (Styling)\n\nGradio \u4e3b\u9898\u662f\u81ea\u5b9a\u4e49\u5e94\u7528\u7a0b\u5e8f\u5916\u89c2\u548c\u611f\u89c9\u7684\u6700\u7b80\u5355\u65b9\u6cd5\u3002\u60a8\u53ef\u4ee5\u9009\u62e9\u591a\u79cd\u4e3b\u9898\u6216\u521b\u5efa\u81ea\u5df1\u7684\u4e3b\u9898\u3002\u8981\u8fd9\u6837\u505a\uff0c\u8bf7\u5c06 `theme=` \u53c2\u6570\u4f20\u9012\u7ed9 `Interface` \u6784\u9020\u51fd\u6570\u3002\u4f8b\u5982\uff1a\n\n```python\ndemo = gr.Interface(..., theme=gr.themes.Monochrome())\n```\n\nGradio \u5e26\u6709\u4e00\u7ec4\u9884\u5148\u6784\u5efa\u7684\u4e3b\u9898\uff0c\u60a8\u53ef\u4ee5\u4ece `gr.themes.*` \u52a0\u8f7d\u3002\u60a8\u53ef\u4ee5\u6269\u5c55\u8fd9\u4e9b\u4e3b\u9898\u6216\u4ece\u5934\u5f00\u59cb\u521b\u5efa\u81ea\u5df1\u7684\u4e3b\u9898 - \u6709\u5173\u66f4\u591a\u8be6\u7ec6\u4fe1\u606f\uff0c\u8bf7\u53c2\u9605[\u4e3b\u9898\u6307\u5357](https://gradio.app/theming-guide)\u3002\n\n\u8981\u589e\u52a0\u989d\u5916\u7684\u6837\u5f0f\u80fd\u529b\uff0c\u60a8\u53ef\u4ee5 with `css=` \u5173\u952e\u5b57\u5c06\u4efb\u4f55 CSS \u4f20\u9012\u7ed9\u60a8\u7684\u5e94\u7528\u7a0b\u5e8f\u3002\nGradio \u5e94\u7528\u7a0b\u5e8f\u7684\u57fa\u7c7b\u662f `gradio-container`\uff0c\u56e0\u6b64\u4ee5\u4e0b\u662f\u4e00\u4e2a\u66f4\u6539 Gradio \u5e94\u7528\u7a0b\u5e8f\u80cc\u666f\u989c\u8272\u7684\u793a\u4f8b\uff1a\n\n```python\nwith `gr.Interface(css=\".gradio-container {background-color: red}\") as demo:\n    .\n```\n\n## \u961f\u5217 (Queuing)\n\n\u5982\u679c\u60a8\u7684\u5e94\u7528\u7a0b\u5e8f\u9884\u8ba1\u4f1a\u6709\u5927\u91cf\u6d41\u91cf\uff0c\u8bf7 with `queue()` \u65b9\u6cd5\u6765\u63a7\u5236\u5904\u7406\u901f\u7387\u3002\u8fd9\u5c06\u6392\u961f\u5904\u7406\u8c03\u7528\uff0c\u56e0\u6b64\u4e00\u6b21\u53ea\u5904\u7406\u4e00\u5b9a\u6570\u91cf\u7684\u8bf7\u6c42\u3002\u961f\u5217\u4f7f\u7528 Websockets\uff0c\u8fd8\u53ef\u4ee5\u9632\u6b62\u7f51\u7edc\u8d85\u65f6\uff0c\u56e0\u6b64\u5982\u679c\u60a8\u7684\u51fd\u6570\u7684\u63a8\u7406\u65f6\u95f4\u5f88\u957f\uff08> 1 \u5206\u949f\uff09\uff0c\u5e94\u4f7f\u7528\u961f\u5217\u3002\n\nwith `Interface`\uff1a\n\n```python\ndemo = gr.Interface(.).queue()\ndemo.launch()\n```\n\nwith `Blocks`\uff1a\n\n```python\nwith gr.Blocks() as demo\uff1a\n    #.\ndemo.queue()\ndemo.launch()\n```\n\n\u60a8\u53ef\u4ee5\u901a\u8fc7\u4ee5\u4e0b\u65b9\u5f0f\u63a7\u5236\u4e00\u6b21\u5904\u7406\u7684\u8bf7\u6c42\u6570\u91cf\uff1a\n\n```python\ndemo.queue(concurrency_count=3)\n```\n\n\u67e5\u770b\u6709\u5173\u914d\u7f6e\u5176\u4ed6\u961f\u5217\u53c2\u6570\u7684[\u961f\u5217\u6587\u6863](/docs/#queue)\u3002\n\n\u5728 Blocks \u4e2d\u6307\u5b9a\u4ec5\u5bf9\u67d0\u4e9b\u51fd\u6570\u8fdb\u884c\u6392\u961f\uff1a\n\n```python\nwith gr.Blocks() as demo2\uff1a\n    num1 = gr.Number()\n    num2 = gr.Number()\n    output = gr.Number()\n    gr.Button(\"Add\").click(\n        lambda a, b: a + b, [num1, num2], output)\n    gr.Button(\"Multiply\").click(\n        lambda a, b: a * b, [num1, num2], output, queue=True)\ndemo2."
            },
            {
                "score": 0.5782836483935945,
                "node_text": "Here are some facts extracted from the provided text:\n\nPods -> Can run -> Hundreds or thousands of replicas\n\n</Tip>\n\nThe second way to access a TPU is via a **TPU VM.** When using a TPU VM, you connect directly to the machine that the TPU is attached to, much like training on a GPU VM. TPU VMs are generally easier to work with, particularly when it comes to your data pipeline. All of the above warnings do not apply to TPU VMs!\n\nThis is an opinionated document, so here\u2019s our opinion: **Avoid using TPU Node if possible.** It is more confusing and more difficult to debug than TPU VMs. It is also likely to be unsupported in future - Google\u2019s latest TPU, TPUv4, can only be accessed as a TPU VM, which suggests that TPU Nodes are increasingly going to become a \u201clegacy\u201d access method. However, we understand that the only free TPU access is on Colab and Kaggle Kernels, which uses TPU Node - so we\u2019ll try to explain how to handle it if you have to! Check the [TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) for code samples that explain this in more detail.\n\n### What sizes of TPU are available?\n\nA single TPU (a v2-8/v3-8/v4-8) runs 8 replicas. TPUs exist in **pods** that can run hundreds or thousands of replicas simultaneously. When you use more than a single TPU but less than a whole pod (for example, a v3-32), your TPU fleet is referred to as a **pod slice.**\n\nWhen you access a free TPU via Colab, you generally get a single v2-8 TPU.\n\n### I keep hearing about this XLA thing. What\u2019s XLA, and how does it relate to TPUs?\n\nXLA is an optimizing compiler, used by both TensorFlow and JAX. In JAX it is the only compiler, whereas in TensorFlow it is optional (but mandatory on TPU!). The easiest way to enable it when training a Keras model is to pass the argument `jit_compile=True` to `model.compile()`. If you don\u2019t get any errors and performance is good, that\u2019s a great sign that you\u2019re ready to move to TPU!\n\nDebugging on TPU is generally a bit harder than on CPU/GPU, so we recommend getting your code running on CPU/GPU with XLA first before trying it on TPU. You don\u2019t have to train for long, of course - just for a few steps to make sure that your model and data pipeline are working like you expect them to.\n\n<Tip>\n\nXLA compiled code is usually faster - so even if you\u2019re not planning to run on TPU, adding `jit_compile=True` can improve your performance. Be sure to note the caveats below about XLA compatibility, though!\n\n</Tip>\n\n<Tip warning={true}>\n\n**Tip born of painful experience:** Although using `jit_compile=True` is a good way to get a speed boost and test if your CPU/GPU code is XLA-compatible, it can actually cause a lot of problems if you leave it in when actually training on TPU. XLA compilation will happen implicitly on TPU, so remember to remove that line before actually running your code on a TPU!\n\n</Tip>\n\n### How do I make my model XLA compatible?\n\nIn many cases, your code is probably XLA-compatible already! However, there are a few things that work in normal TensorFlow that don\u2019t work in XLA. We\u2019ve distilled them into three core rules below:\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** We\u2019ve put a lot of effort into rewriting our TensorFlow models and loss functions to be XLA-compatible. Our models and loss functions generally obey rule #1 and #2 by default, so you can skip over them if you\u2019re using `transformers` models. Don\u2019t forget about these rules when writing your own models and loss functions, though!\n\n</Tip>\n\n#### XLA Rule #1: Your code cannot have \u201cdata-dependent conditionals\u201d\n\nWhat that means is that any `if` statement cannot depend on values inside a `tf.Tensor`. For example, this code block cannot be compiled with XLA!\n\n```python\nif tf.reduce_sum(tensor) > 10:\n    tensor = tensor / 2.0\n```\n\nThis might seem very restrictive at first, but most neural net code doesn\u2019t need to do this."
            },
            {
                "score": 0.5782836483935945,
                "node_text": "Here are some facts extracted from the provided text:\n\nTpu -> Exists in -> Pods\n\nThis is a really useful trick, so remember it if you need to convert your own code to XLA!\n\n#### XLA Rule #3: XLA will need to recompile your model for every different input shape it sees\n\nThis is the big one. What this means is that if your input shapes are very variable, XLA will have to recompile your model over and over, which will create huge performance problems. This commonly arises in NLP models, where input texts have variable lengths after tokenization. In other modalities, static shapes are more common and this rule is much less of a problem.\n\nHow can you get around rule #3? The key is **padding** - if you pad all your inputs to the same length, and then use an `attention_mask`, you can get the same results as you\u2019d get from variable shapes, but without any XLA issues. However, excessive padding can cause severe slowdown too - if you pad all your samples to the maximum length in the whole dataset, you might end up with batches consisting endless padding tokens, which will waste a lot of compute and memory!\n\nThere isn\u2019t a perfect solution to this problem. However, you can try some tricks. One very useful trick is to **pad batches of samples up to a multiple of a number like 32 or 64 tokens.** This often only increases the number of tokens by a small amount, but it hugely reduces the number of unique input shapes, because every input shape now has to be a multiple of 32 or 64. Fewer unique input shapes means fewer XLA compilations!\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** Our tokenizers and data collators have methods that can help you here. You can use `padding=\"max_length\"` or `padding=\"longest\"` when calling tokenizers to get them to output padded data. Our tokenizers and data collators also have a `pad_to_multiple_of` argument that you can use to reduce the number of unique input shapes you see!\n\n</Tip>\n\n### How do I actually train my model on TPU?\n\nOnce your training is XLA-compatible and (if you\u2019re using TPU Node / Colab) your dataset has been prepared appropriately, running on TPU is surprisingly easy! All you really need to change in your code is to add a few lines to initialize your TPU, and to ensure that your model and dataset are created inside a `TPUStrategy` scope. Take a look at [our TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) to see this in action!\n\n### Summary\n\nThere was a lot in here, so let\u2019s summarize with a quick checklist you can follow when you want to get your model ready for TPU training:\n\n- Make sure your code follows the three rules of XLA\n- Compile your model with `jit_compile=True` on CPU/GPU and confirm that you can train it with XLA\n- Either load your dataset into memory or use a TPU-compatible dataset loading approach (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Migrate your code either to Colab (with accelerator set to \u201cTPU\u201d) or a TPU VM on Google Cloud\n- Add TPU initializer code (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Create your `TPUStrategy` and make sure dataset loading and model creation are inside the `strategy.scope()` (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Don\u2019t forget to take `jit_compile=True` out again when you move to TPU!\n- \ud83d\ude4f\ud83d\ude4f\ud83d\ude4f\ud83e\udd7a\ud83e\udd7a\ud83e\udd7a\n- Call model.fit()\n- You did it!"
            }
        ]
    },
    {
        "sample_idx": 120,
        "question": "What is the name of the model that can be used to extract image features?",
        "answer": "seresnet152d",
        "rag_answer": "There is no mention of a model that can be used to extract image features in the provided context information. The context information primarily discusses LayoutLMv3, a model used for token classification, and provides information about fine-tuning it on form understanding datasets such as FUNSD and CORD. It also discusses XLA, TPU, and TensorFlow, but does not mention a model for extracting image features.",
        "rag_score": 1,
        "rag_feedback": "The system's response is completely incorrect, inaccurate, and not factual. The response does not mention the model 'seresnet152d' at all, instead, it provides information about LayoutLMv3, a model used for token classification, and discusses XLA, TPU, and TensorFlow.",
        "rag_context": [
            {
                "score": 0.6046650523702299,
                "node_text": "Here are some facts extracted from the provided text:\n\nGradio -> Supports -> Hugging face models\n\nGradio Demo: blocks_random_slider\n\n\n```\n!pip install -q gradio \n```\n\n\n```\n\nimport gradio as gr\n\n\ndef func(slider_1, slider_2):\n    return slider_1 * 5 + slider_2\n\n\nwith gr.Blocks() as demo:\n    slider = gr.Slider(minimum=-10.2, maximum=15, label=\"Random Slider (Static)\", randomize=True)\n    slider_1 = gr.Slider(minimum=100, maximum=200, label=\"Random Slider (Input 1)\", randomize=True)\n    slider_2 = gr.Slider(minimum=10, maximum=23.2, label=\"Random Slider (Input 2)\", randomize=True)\n    slider_3 = gr.Slider(value=3, label=\"Non random slider\")\n    btn = gr.Button(\"Run\")\n    btn.click(func, inputs=[slider_1, slider_2], outputs=gr.Number())\n\nif __name__ == \"__main__\":\n    demo.launch()\n\n```"
            },
            {
                "score": 0.5712261737607897,
                "node_text": "Here are some facts extracted from the provided text:\n\nModel -> Needs -> Question\nModel -> Has -> Input shape\nModel -> Needs -> Context\nModel -> Evaluates on -> Squad\nNielsr/layoutlmv3-finetuned-funsd -> Is -> Model\nModel -> Returns -> Prediction_text\nMicrosoft/layoutlmv3-base -> Is -> Model name or path\n\n!---\nCopyright 2022 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n-->\n\n# Token classification with LayoutLMv3 (PyTorch version)\n\nThis directory contains a script, `run_funsd_cord.py`, that can be used to fine-tune (or evaluate) LayoutLMv3 on form understanding datasets, such as [FUNSD](https://guillaumejaume.github.io/FUNSD/) and [CORD](https://github.com/clovaai/cord).\n\nThe script `run_funsd_cord.py` leverages the \ud83e\udd17 Datasets library and the Trainer API. You can easily customize it to your needs.\n\n## Fine-tuning on FUNSD\n\nFine-tuning LayoutLMv3 for token classification on [FUNSD](https://guillaumejaume.github.io/FUNSD/) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name funsd \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 1e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-funsd\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd. By specifying the `push_to_hub` flag, the model gets uploaded automatically to the hub (regularly), together with a model card, which includes metrics such as precision, recall and F1. Note that you can easily update the model card, as it's just a README file of the respective repo on the hub.\n\nThere's also the \"Training metrics\" [tab](https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd/tensorboard), which shows Tensorboard logs over the course of training. Pretty neat, huh?\n\n## Fine-tuning on CORD\n\nFine-tuning LayoutLMv3 for token classification on [CORD](https://github.com/clovaai/cord) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name cord \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 5e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-cord\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-cord. Note that a model card gets generated automatically in case you specify the `push_to_hub` flag."
            },
            {
                "score": 0.5712261737607897,
                "node_text": "Here are some facts extracted from the provided text:\n\nXla -> Recompile -> Model\n\nThis is a really useful trick, so remember it if you need to convert your own code to XLA!\n\n#### XLA Rule #3: XLA will need to recompile your model for every different input shape it sees\n\nThis is the big one. What this means is that if your input shapes are very variable, XLA will have to recompile your model over and over, which will create huge performance problems. This commonly arises in NLP models, where input texts have variable lengths after tokenization. In other modalities, static shapes are more common and this rule is much less of a problem.\n\nHow can you get around rule #3? The key is **padding** - if you pad all your inputs to the same length, and then use an `attention_mask`, you can get the same results as you\u2019d get from variable shapes, but without any XLA issues. However, excessive padding can cause severe slowdown too - if you pad all your samples to the maximum length in the whole dataset, you might end up with batches consisting endless padding tokens, which will waste a lot of compute and memory!\n\nThere isn\u2019t a perfect solution to this problem. However, you can try some tricks. One very useful trick is to **pad batches of samples up to a multiple of a number like 32 or 64 tokens.** This often only increases the number of tokens by a small amount, but it hugely reduces the number of unique input shapes, because every input shape now has to be a multiple of 32 or 64. Fewer unique input shapes means fewer XLA compilations!\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** Our tokenizers and data collators have methods that can help you here. You can use `padding=\"max_length\"` or `padding=\"longest\"` when calling tokenizers to get them to output padded data. Our tokenizers and data collators also have a `pad_to_multiple_of` argument that you can use to reduce the number of unique input shapes you see!\n\n</Tip>\n\n### How do I actually train my model on TPU?\n\nOnce your training is XLA-compatible and (if you\u2019re using TPU Node / Colab) your dataset has been prepared appropriately, running on TPU is surprisingly easy! All you really need to change in your code is to add a few lines to initialize your TPU, and to ensure that your model and dataset are created inside a `TPUStrategy` scope. Take a look at [our TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) to see this in action!\n\n### Summary\n\nThere was a lot in here, so let\u2019s summarize with a quick checklist you can follow when you want to get your model ready for TPU training:\n\n- Make sure your code follows the three rules of XLA\n- Compile your model with `jit_compile=True` on CPU/GPU and confirm that you can train it with XLA\n- Either load your dataset into memory or use a TPU-compatible dataset loading approach (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Migrate your code either to Colab (with accelerator set to \u201cTPU\u201d) or a TPU VM on Google Cloud\n- Add TPU initializer code (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Create your `TPUStrategy` and make sure dataset loading and model creation are inside the `strategy.scope()` (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Don\u2019t forget to take `jit_compile=True` out again when you move to TPU!\n- \ud83d\ude4f\ud83d\ude4f\ud83d\ude4f\ud83e\udd7a\ud83e\udd7a\ud83e\udd7a\n- Call model.fit()\n- You did it!"
            },
            {
                "score": 0.5597298223856593,
                "node_text": "Here are some facts extracted from the provided text:\n\nTensorflow models -> Are -> Keras models\n\n!--Copyright 2023 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\nthe License. You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under the License is distributed on\nan \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n\n\u26a0\ufe0f Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be\nrendered properly in your Markdown viewer.\n\n-->\n\n# Training on TPU with TensorFlow\n\n<Tip>\n\nIf you don't need long explanations and just want TPU code samples to get started with, check out [our TPU example notebook!](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb)\n\n</Tip>\n\n### What is a TPU?\n\nA TPU is a **Tensor Processing Unit.** They are hardware designed by Google, which are used to greatly speed up the tensor computations within neural networks, much like GPUs. They can be used for both network training and inference. They are generally accessed through Google\u2019s cloud services, but small TPUs can also be accessed directly for free through Google Colab and Kaggle Kernels.\n\nBecause [all TensorFlow models in \ud83e\udd17 Transformers are Keras models](https://huggingface.co/blog/tensorflow-philosophy), most of the methods in this document are generally applicable to TPU training for any Keras model! However, there are a few points that are specific to the HuggingFace ecosystem (hug-o-system?) of Transformers and Datasets, and we\u2019ll make sure to flag them up when we get to them.\n\n### What kinds of TPU are available?\n\nNew users are often very confused by the range of TPUs, and the different ways to access them. The first key distinction to understand is the difference between **TPU Nodes** and **TPU VMs.**\n\nWhen you use a **TPU Node**, you are effectively indirectly accessing a remote TPU. You will need a separate VM, which will initialize your network and data pipeline and then forward them to the remote node. When you use a TPU on Google Colab, you are accessing it in the **TPU Node** style.\n\nUsing TPU Nodes can have some quite unexpected behaviour for people who aren\u2019t used to them! In particular, because the TPU is located on a physically different system to the machine you\u2019re running your Python code on, your data cannot be local to your machine - any data pipeline that loads from your machine\u2019s internal storage will totally fail! Instead, data must be stored in Google Cloud Storage where your data pipeline can still access it, even when the pipeline is running on the remote TPU node.\n\n<Tip>\n\nIf you can fit all your data in memory as `np.ndarray` or `tf.Tensor`, then you can `fit()` on that data even when using Colab or a TPU Node, without needing to upload it to Google Cloud Storage.\n\n</Tip>\n\n<Tip>\n\n**\ud83e\udd17Specific Hugging Face Tip\ud83e\udd17:** The methods `Dataset.to_tf_dataset()` and its higher-level wrapper `model.prepare_tf_dataset()` , which you will see throughout our TF code examples, will both fail on a TPU Node. The reason for this is that even though they create a `tf.data.Dataset` it is not a \u201cpure\u201d `tf.data` pipeline and uses `tf.numpy_function` or `Dataset.from_generator()` to stream data from the underlying HuggingFace `Dataset`. This HuggingFace `Dataset` is backed by data that is on a local disc and which the remote TPU Node will not be able to read.\n\n</Tip>\n\nThe second way to access a TPU is via a **TPU VM.** When using a TPU VM, you connect directly to the machine that the TPU is attached to, much like training on a GPU VM. TPU VMs are generally easier to work with, particularly when it comes to your data pipeline. All of the above warnings do not apply to TPU VMs!\n\nThis is an opinionated document, so here\u2019s our opinion: **Avoid using TPU Node if possible.** It is more confusing and more difficult to debug than TPU VMs. It is also likely to be unsupported in future - Google\u2019s latest TPU, TPUv4, can only be accessed as a TPU VM, which suggests that TPU Nodes are increasingly going to become a \u201clegacy\u201d access method."
            }
        ]
    },
    {
        "sample_idx": 121,
        "question": "How many top categories per image are printed in the given code?",
        "answer": "5",
        "rag_answer": "There is no code provided that prints top categories per image. The code snippets provided are related to Gradio, a framework for building machine learning demos, and they don't seem to be related to image classification or printing top categories per image.",
        "rag_score": 1,
        "rag_feedback": "The system's response is completely incorrect, inaccurate, and/or not factual. The question asks about the number of top categories per image printed in the given code, but the system's response does not provide any information about the code or the number of top categories per image. Instead, it provides a lengthy response about Gradio, a framework for building machine learning demos, which is not relevant to the question.",
        "rag_context": [
            {
                "score": 0.6396424060389481,
                "node_text": "Here are some facts extracted from the provided text:\n\nImage component -> Can be controlled -> Preprocessing parameters\n\n[annotated](/assets/img/dataflow.svg)\n\n\u5982\u60a8\u6240\u89c1\uff0cGradio \u5305\u62ec\u53ef\u4ee5\u5904\u7406\u5404\u79cd\u4e0d\u540c\u6570\u636e\u7c7b\u578b\u7684\u7ec4\u4ef6\uff0c\u4f8b\u5982\u56fe\u50cf\u3001\u97f3\u9891\u548c\u89c6\u9891\u3002\u5927\u591a\u6570\u7ec4\u4ef6\u90fd\u53ef\u4ee5\u7528\u4f5c\u8f93\u5165\u6216\u8f93\u51fa\u3002\n\n\u5f53\u7ec4\u4ef6\u7528\u4f5c\u8f93\u5165\u65f6\uff0cGradio \u81ea\u52a8\u5904\u7406*\u9884\u5904\u7406*\uff0c\u5c06\u6570\u636e\u4ece\u7528\u6237\u6d4f\u89c8\u5668\u53d1\u9001\u7684\u7c7b\u578b\uff08\u4f8b\u5982\u7f51\u7edc\u6444\u50cf\u5934\u5feb\u7167\u7684 base64 \u8868\u793a\uff09\u8f6c\u6362\u4e3a\u60a8\u7684\u51fd\u6570\u53ef\u4ee5\u63a5\u53d7\u7684\u5f62\u5f0f\uff08\u4f8b\u5982 `numpy` \u6570\u7ec4\uff09\u3002\n\n\u540c\u6837\uff0c\u5f53\u7ec4\u4ef6\u7528\u4f5c\u8f93\u51fa\u65f6\uff0cGradio \u81ea\u52a8\u5904\u7406*\u540e\u5904\u7406*\uff0c\u5c06\u6570\u636e\u4ece\u51fd\u6570\u8fd4\u56de\u7684\u5f62\u5f0f\uff08\u4f8b\u5982\u56fe\u50cf\u8def\u5f84\u5217\u8868\uff09\u8f6c\u6362\u4e3a\u53ef\u4ee5\u5728\u7528\u6237\u6d4f\u89c8\u5668\u4e2d\u663e\u793a\u7684\u5f62\u5f0f\uff08\u4f8b\u5982\u4ee5 base64 \u683c\u5f0f\u663e\u793a\u56fe\u50cf\u7684 `Gallery`\uff09\u3002\n\n\u60a8\u53ef\u4ee5\u4f7f\u7528\u6784\u5efa\u56fe\u50cf\u7ec4\u4ef6\u65f6\u7684\u53c2\u6570\u63a7\u5236*\u9884\u5904\u7406*\u3002\u4f8b\u5982\uff0c\u5982\u679c\u60a8\u4f7f\u7528\u4ee5\u4e0b\u53c2\u6570\u5b9e\u4f8b\u5316 `Image` \u7ec4\u4ef6\uff0c\u5b83\u5c06\u5c06\u56fe\u50cf\u8f6c\u6362\u4e3a `PIL` \u7c7b\u578b\uff0c\u5e76\u5c06\u5176\u91cd\u5851\u4e3a`(100, 100)`\uff0c\u800c\u4e0d\u7ba1\u63d0\u4ea4\u65f6\u7684\u539f\u59cb\u5927\u5c0f\u5982\u4f55\uff1a\n\n```py\nimg = gr.Image(shape=(100, 100), type=\"pil\")\n```\n\n\u76f8\u53cd\uff0c\u8fd9\u91cc\u6211\u4eec\u4fdd\u7559\u56fe\u50cf\u7684\u539f\u59cb\u5927\u5c0f\uff0c\u4f46\u5728\u5c06\u5176\u8f6c\u6362\u4e3a numpy \u6570\u7ec4\u4e4b\u524d\u53cd\u8f6c\u989c\u8272\uff1a\n\n```py\nimg = gr.Image(invert_colors=True, type=\"numpy\")\n```\n\n\u540e\u5904\u7406\u8981\u5bb9\u6613\u5f97\u591a\uff01Gradio \u81ea\u52a8\u8bc6\u522b\u8fd4\u56de\u6570\u636e\u7684\u683c\u5f0f\uff08\u4f8b\u5982 `Image` \u662f `numpy` \u6570\u7ec4\u8fd8\u662f `str` \u6587\u4ef6\u8def\u5f84\uff1f\uff09\uff0c\u5e76\u5c06\u5176\u540e\u5904\u7406\u4e3a\u53ef\u4ee5\u7531\u6d4f\u89c8\u5668\u663e\u793a\u7684\u683c\u5f0f\u3002\n\n\u8bf7\u67e5\u770b[\u6587\u6863](https://gradio.app/docs)\uff0c\u4e86\u89e3\u6bcf\u4e2a\u7ec4\u4ef6\u7684\u6240\u6709\u4e0e\u9884\u5904\u7406\u76f8\u5173\u7684\u53c2\u6570\u3002\n\n## \u6837\u5f0f (Styling)\n\nGradio \u4e3b\u9898\u662f\u81ea\u5b9a\u4e49\u5e94\u7528\u7a0b\u5e8f\u5916\u89c2\u548c\u611f\u89c9\u7684\u6700\u7b80\u5355\u65b9\u6cd5\u3002\u60a8\u53ef\u4ee5\u9009\u62e9\u591a\u79cd\u4e3b\u9898\u6216\u521b\u5efa\u81ea\u5df1\u7684\u4e3b\u9898\u3002\u8981\u8fd9\u6837\u505a\uff0c\u8bf7\u5c06 `theme=` \u53c2\u6570\u4f20\u9012\u7ed9 `Interface` \u6784\u9020\u51fd\u6570\u3002\u4f8b\u5982\uff1a\n\n```python\ndemo = gr.Interface(..., theme=gr.themes.Monochrome())\n```\n\nGradio \u5e26\u6709\u4e00\u7ec4\u9884\u5148\u6784\u5efa\u7684\u4e3b\u9898\uff0c\u60a8\u53ef\u4ee5\u4ece `gr.themes.*` \u52a0\u8f7d\u3002\u60a8\u53ef\u4ee5\u6269\u5c55\u8fd9\u4e9b\u4e3b\u9898\u6216\u4ece\u5934\u5f00\u59cb\u521b\u5efa\u81ea\u5df1\u7684\u4e3b\u9898 - \u6709\u5173\u66f4\u591a\u8be6\u7ec6\u4fe1\u606f\uff0c\u8bf7\u53c2\u9605[\u4e3b\u9898\u6307\u5357](https://gradio.app/theming-guide)\u3002\n\n\u8981\u589e\u52a0\u989d\u5916\u7684\u6837\u5f0f\u80fd\u529b\uff0c\u60a8\u53ef\u4ee5 with `css=` \u5173\u952e\u5b57\u5c06\u4efb\u4f55 CSS \u4f20\u9012\u7ed9\u60a8\u7684\u5e94\u7528\u7a0b\u5e8f\u3002\nGradio \u5e94\u7528\u7a0b\u5e8f\u7684\u57fa\u7c7b\u662f `gradio-container`\uff0c\u56e0\u6b64\u4ee5\u4e0b\u662f\u4e00\u4e2a\u66f4\u6539 Gradio \u5e94\u7528\u7a0b\u5e8f\u80cc\u666f\u989c\u8272\u7684\u793a\u4f8b\uff1a\n\n```python\nwith `gr.Interface(css=\".gradio-container {background-color: red}\") as demo:\n    .\n```\n\n## \u961f\u5217 (Queuing)\n\n\u5982\u679c\u60a8\u7684\u5e94\u7528\u7a0b\u5e8f\u9884\u8ba1\u4f1a\u6709\u5927\u91cf\u6d41\u91cf\uff0c\u8bf7 with `queue()` \u65b9\u6cd5\u6765\u63a7\u5236\u5904\u7406\u901f\u7387\u3002\u8fd9\u5c06\u6392\u961f\u5904\u7406\u8c03\u7528\uff0c\u56e0\u6b64\u4e00\u6b21\u53ea\u5904\u7406\u4e00\u5b9a\u6570\u91cf\u7684\u8bf7\u6c42\u3002\u961f\u5217\u4f7f\u7528 Websockets\uff0c\u8fd8\u53ef\u4ee5\u9632\u6b62\u7f51\u7edc\u8d85\u65f6\uff0c\u56e0\u6b64\u5982\u679c\u60a8\u7684\u51fd\u6570\u7684\u63a8\u7406\u65f6\u95f4\u5f88\u957f\uff08> 1 \u5206\u949f\uff09\uff0c\u5e94\u4f7f\u7528\u961f\u5217\u3002\n\nwith `Interface`\uff1a\n\n```python\ndemo = gr.Interface(.).queue()\ndemo.launch()\n```\n\nwith `Blocks`\uff1a\n\n```python\nwith gr.Blocks() as demo\uff1a\n    #.\ndemo.queue()\ndemo.launch()\n```\n\n\u60a8\u53ef\u4ee5\u901a\u8fc7\u4ee5\u4e0b\u65b9\u5f0f\u63a7\u5236\u4e00\u6b21\u5904\u7406\u7684\u8bf7\u6c42\u6570\u91cf\uff1a\n\n```python\ndemo.queue(concurrency_count=3)\n```\n\n\u67e5\u770b\u6709\u5173\u914d\u7f6e\u5176\u4ed6\u961f\u5217\u53c2\u6570\u7684[\u961f\u5217\u6587\u6863](/docs/#queue)\u3002\n\n\u5728 Blocks \u4e2d\u6307\u5b9a\u4ec5\u5bf9\u67d0\u4e9b\u51fd\u6570\u8fdb\u884c\u6392\u961f\uff1a\n\n```python\nwith gr.Blocks() as demo2\uff1a\n    num1 = gr.Number()\n    num2 = gr.Number()\n    output = gr.Number()\n    gr.Button(\"Add\").click(\n        lambda a, b: a + b, [num1, num2], output)\n    gr.Button(\"Multiply\").click(\n        lambda a, b: a * b, [num1, num2], output, queue=True)\ndemo2."
            },
            {
                "score": 0.5878787605411524,
                "node_text": "Here are some facts extracted from the provided text:\n\nBatch functions -> Accept -> Input lists\nBatch functions -> Return -> Prediction lists\n\ntqdm` \u81ea\u52a8\u62a5\u544a\u8fdb\u5ea6\u66f4\u65b0\uff0c\u8bf7\u5c06\u9ed8\u8ba4\u53c2\u6570\u8bbe\u7f6e\u4e3a `gr.Progress(track_tqdm=True)`\uff01\n\n## \u6279\u5904\u7406\u51fd\u6570 (Batch Functions)\n\nGradio \u652f\u6301\u4f20\u9012*\u6279\u5904\u7406*\u51fd\u6570\u3002\u6279\u5904\u7406\u51fd\u6570\u53ea\u662f\u63a5\u53d7\u8f93\u5165\u5217\u8868\u5e76\u8fd4\u56de\u9884\u6d4b\u5217\u8868\u7684\u51fd\u6570\u3002\n\n\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\u6279\u5904\u7406\u51fd\u6570\uff0c\u5b83\u63a5\u53d7\u4e24\u4e2a\u8f93\u5165\u5217\u8868\uff08\u4e00\u4e2a\u5355\u8bcd\u5217\u8868\u548c\u4e00\u4e2a\u6574\u6570\u5217\u8868\uff09\uff0c\u5e76\u8fd4\u56de\u4fee\u526a\u8fc7\u7684\u5355\u8bcd\u5217\u8868\u4f5c\u4e3a\u8f93\u51fa\uff1a\n\n```python\nimport time\n\ndef trim_words(words, lens):\n    trimmed_words = []\n    time.sleep(5)\n    for w, l in zip(words, lens):\n        trimmed_words.append(w[:int(l)])\n    return [trimmed_words]\n    for w, l in zip(words, lens):\n```\n\n\u4f7f\u7528\u6279\u5904\u7406\u51fd\u6570\u7684\u4f18\u70b9\u662f\uff0c\u5982\u679c\u542f\u7528\u4e86\u961f\u5217\uff0cGradio \u670d\u52a1\u5668\u53ef\u4ee5\u81ea\u52a8*\u6279\u5904\u7406*\u4f20\u5165\u7684\u8bf7\u6c42\u5e76\u5e76\u884c\u5904\u7406\u5b83\u4eec\uff0c\u4ece\u800c\u53ef\u80fd\u52a0\u5feb\u6f14\u793a\u901f\u5ea6\u3002\u4ee5\u4e0b\u662f Gradio \u4ee3\u7801\u7684\u793a\u4f8b\uff08\u8bf7\u6ce8\u610f `batch=True` \u548c `max_batch_size=16` - \u8fd9\u4e24\u4e2a\u53c2\u6570\u90fd\u53ef\u4ee5\u4f20\u9012\u7ed9\u4e8b\u4ef6\u89e6\u53d1\u5668\u6216 `Interface` \u7c7b\uff09\n\nwith `Interface`\uff1a\n\n```python\ndemo = gr.Interface(trim_words, [\"textbox\", \"number\"], [\"output\"],\n                    batch=True, max_batch_size=16)\ndemo.queue()\ndemo.launch()\n```\n\nwith `Blocks`\uff1a\n\n```python\nimport gradio as gr\n\nwith gr.Blocks() as demo:\n    with gr.Row():\n        word = gr.Textbox(label=\"word\")\n        leng = gr.Number(label=\"leng\")\n        output = gr.Textbox(label=\"Output\")\n    with gr.Row():\n        run = gr.Button()\n\n    event = run.click(trim_words, [word, leng], output, batch=True, max_batch_size=16)\n\ndemo.queue()\ndemo.launch()\n```\n\n\u5728\u4e0a\u9762\u7684\u793a\u4f8b\u4e2d\uff0c\u53ef\u4ee5\u5e76\u884c\u5904\u7406 16 \u4e2a\u8bf7\u6c42\uff08\u603b\u63a8\u7406\u65f6\u95f4\u4e3a 5 \u79d2\uff09\uff0c\u800c\u4e0d\u662f\u5206\u522b\u5904\u7406\u6bcf\u4e2a\u8bf7\u6c42\uff08\u603b\u63a8\u7406\u65f6\u95f4\u4e3a 80 \u79d2\uff09\u3002\u8bb8\u591a Hugging Face \u7684 `transformers` \u548c `diffusers` \u6a21\u578b\u5728 Gradio \u7684\u6279\u5904\u7406\u6a21\u5f0f\u4e0b\u81ea\u7136\u5de5\u4f5c\uff1a\u8fd9\u662f[\u4f7f\u7528\u6279\u5904\u7406\u751f\u6210\u56fe\u50cf\u7684\u793a\u4f8b\u6f14\u793a](https://github.com/gradio-app/gradio/blob/main/demo/diffusers_with_batching/run.py)\n\n\u6ce8\u610f\uff1a\u4f7f\u7528 Gradio \u7684\u6279\u5904\u7406\u51fd\u6570 **requires** \u5728\u5e95\u5c42 Interface \u6216 Blocks \u4e2d\u542f\u7528\u961f\u5217\uff08\u8bf7\u53c2\u9605\u4e0a\u9762\u7684\u961f\u5217\u90e8\u5206\uff09\u3002\n\n## Gradio \u7b14\u8bb0\u672c (Colab Notebooks)\n\nGradio \u53ef\u4ee5\u5728\u4efb\u4f55\u8fd0\u884c Python \u7684\u5730\u65b9\u8fd0\u884c\uff0c\u5305\u62ec\u672c\u5730 Jupyter \u7b14\u8bb0\u672c\u548c\u534f\u4f5c\u7b14\u8bb0\u672c\uff0c\u5982[Google Colab](https://colab.research.google.com/)\u3002\u5bf9\u4e8e\u672c\u5730 Jupyter \u7b14\u8bb0\u672c\u548c Google Colab \u7b14\u8bb0\u672c\uff0cGradio \u5728\u672c\u5730\u670d\u52a1\u5668\u4e0a\u8fd0\u884c\uff0c\u60a8\u53ef\u4ee5\u5728\u6d4f\u89c8\u5668\u4e2d\u4e0e\u4e4b\u4ea4\u4e92\u3002\uff08\u6ce8\u610f\uff1a\u5bf9\u4e8e Google Colab\uff0c\u8fd9\u662f\u901a\u8fc7[\u670d\u52a1\u5de5\u4f5c\u5668\u96a7\u9053](https://github.com/tensorflow/tensorboard/blob/master/docs/design/colab_integration.md)\u5b9e\u73b0\u7684\uff0c\u60a8\u7684\u6d4f\u89c8\u5668\u9700\u8981\u542f\u7528 cookies\u3002\uff09\u5bf9\u4e8e\u5176\u4ed6\u8fdc\u7a0b\u7b14\u8bb0\u672c\uff0cGradio \u4e5f\u5c06\u5728\u670d\u52a1\u5668\u4e0a\u8fd0\u884c\uff0c\u4f46\u60a8\u9700\u8981\u4f7f\u7528[SSH \u96a7\u9053](https://coderwall.com/p/ohk6cg/remote-access-to-ipython-notebooks-via-ssh)\u5728\u672c\u5730\u6d4f\u89c8\u5668\u4e2d\u67e5\u770b\u5e94\u7528\u7a0b\u5e8f\u3002\u901a\u5e38\uff0c\u66f4\u7b80\u5355\u7684\u9009\u62e9\u662f\u4f7f\u7528 Gradio \u5185\u7f6e\u7684\u516c\u5171\u94fe\u63a5\uff0c[\u5728\u4e0b\u4e00\u7bc7\u6307\u5357\u4e2d\u8ba8\u8bba](/sharing-your-app/#sharing-demos)\u3002"
            },
            {
                "score": 0.5878787605411524,
                "node_text": "Here are some facts extracted from the provided text:\n\nGradio -> Supports -> Batch functions\nGradio -> Automatically handles -> Postprocessing\nGradio -> Supports -> Iterative outputs\n\nGradio Demo: blocks_random_slider\n\n\n```\n!pip install -q gradio \n```\n\n\n```\n\nimport gradio as gr\n\n\ndef func(slider_1, slider_2):\n    return slider_1 * 5 + slider_2\n\n\nwith gr.Blocks() as demo:\n    slider = gr.Slider(minimum=-10.2, maximum=15, label=\"Random Slider (Static)\", randomize=True)\n    slider_1 = gr.Slider(minimum=100, maximum=200, label=\"Random Slider (Input 1)\", randomize=True)\n    slider_2 = gr.Slider(minimum=10, maximum=23.2, label=\"Random Slider (Input 2)\", randomize=True)\n    slider_3 = gr.Slider(value=3, label=\"Non random slider\")\n    btn = gr.Button(\"Run\")\n    btn.click(func, inputs=[slider_1, slider_2], outputs=gr.Number())\n\nif __name__ == \"__main__\":\n    demo.launch()\n\n```"
            }
        ]
    },
    {
        "sample_idx": 122,
        "question": "What is the name of the repository where the training script can be found?",
        "answer": "pytorch-image-models",
        "rag_answer": "The query is asking about the repository where the training script can be found. Based on the provided context, the answer is not explicitly mentioned. However, there is a mention of a TPU example notebook in the context, which is linked to https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb. This suggests that the repository might be related to HuggingFace, but the exact name of the repository is not provided.",
        "rag_score": 2,
        "rag_feedback": "The system's response is mostly incorrect, inaccurate, and/or not factual. It does not provide the correct answer to the question, which is 'pytorch-image-models'. Instead, it provides a lengthy and irrelevant response that discusses various topics such as TPU, HuggingFace, and Gradio.",
        "rag_context": [
            {
                "score": 0.6786730489318082,
                "node_text": "Here are some facts extracted from the provided text:\n\nTpu -> Is used -> For training\n\nThis is a really useful trick, so remember it if you need to convert your own code to XLA!\n\n#### XLA Rule #3: XLA will need to recompile your model for every different input shape it sees\n\nThis is the big one. What this means is that if your input shapes are very variable, XLA will have to recompile your model over and over, which will create huge performance problems. This commonly arises in NLP models, where input texts have variable lengths after tokenization. In other modalities, static shapes are more common and this rule is much less of a problem.\n\nHow can you get around rule #3? The key is **padding** - if you pad all your inputs to the same length, and then use an `attention_mask`, you can get the same results as you\u2019d get from variable shapes, but without any XLA issues. However, excessive padding can cause severe slowdown too - if you pad all your samples to the maximum length in the whole dataset, you might end up with batches consisting endless padding tokens, which will waste a lot of compute and memory!\n\nThere isn\u2019t a perfect solution to this problem. However, you can try some tricks. One very useful trick is to **pad batches of samples up to a multiple of a number like 32 or 64 tokens.** This often only increases the number of tokens by a small amount, but it hugely reduces the number of unique input shapes, because every input shape now has to be a multiple of 32 or 64. Fewer unique input shapes means fewer XLA compilations!\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** Our tokenizers and data collators have methods that can help you here. You can use `padding=\"max_length\"` or `padding=\"longest\"` when calling tokenizers to get them to output padded data. Our tokenizers and data collators also have a `pad_to_multiple_of` argument that you can use to reduce the number of unique input shapes you see!\n\n</Tip>\n\n### How do I actually train my model on TPU?\n\nOnce your training is XLA-compatible and (if you\u2019re using TPU Node / Colab) your dataset has been prepared appropriately, running on TPU is surprisingly easy! All you really need to change in your code is to add a few lines to initialize your TPU, and to ensure that your model and dataset are created inside a `TPUStrategy` scope. Take a look at [our TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) to see this in action!\n\n### Summary\n\nThere was a lot in here, so let\u2019s summarize with a quick checklist you can follow when you want to get your model ready for TPU training:\n\n- Make sure your code follows the three rules of XLA\n- Compile your model with `jit_compile=True` on CPU/GPU and confirm that you can train it with XLA\n- Either load your dataset into memory or use a TPU-compatible dataset loading approach (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Migrate your code either to Colab (with accelerator set to \u201cTPU\u201d) or a TPU VM on Google Cloud\n- Add TPU initializer code (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Create your `TPUStrategy` and make sure dataset loading and model creation are inside the `strategy.scope()` (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Don\u2019t forget to take `jit_compile=True` out again when you move to TPU!\n- \ud83d\ude4f\ud83d\ude4f\ud83d\ude4f\ud83e\udd7a\ud83e\udd7a\ud83e\udd7a\n- Call model.fit()\n- You did it!"
            },
            {
                "score": 0.605072466419542,
                "node_text": "Here are some facts extracted from the provided text:\n\nTensorflow models -> Are -> Keras models\n\n!--Copyright 2023 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\nthe License. You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under the License is distributed on\nan \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n\n\u26a0\ufe0f Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be\nrendered properly in your Markdown viewer.\n\n-->\n\n# Training on TPU with TensorFlow\n\n<Tip>\n\nIf you don't need long explanations and just want TPU code samples to get started with, check out [our TPU example notebook!](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb)\n\n</Tip>\n\n### What is a TPU?\n\nA TPU is a **Tensor Processing Unit.** They are hardware designed by Google, which are used to greatly speed up the tensor computations within neural networks, much like GPUs. They can be used for both network training and inference. They are generally accessed through Google\u2019s cloud services, but small TPUs can also be accessed directly for free through Google Colab and Kaggle Kernels.\n\nBecause [all TensorFlow models in \ud83e\udd17 Transformers are Keras models](https://huggingface.co/blog/tensorflow-philosophy), most of the methods in this document are generally applicable to TPU training for any Keras model! However, there are a few points that are specific to the HuggingFace ecosystem (hug-o-system?) of Transformers and Datasets, and we\u2019ll make sure to flag them up when we get to them.\n\n### What kinds of TPU are available?\n\nNew users are often very confused by the range of TPUs, and the different ways to access them. The first key distinction to understand is the difference between **TPU Nodes** and **TPU VMs.**\n\nWhen you use a **TPU Node**, you are effectively indirectly accessing a remote TPU. You will need a separate VM, which will initialize your network and data pipeline and then forward them to the remote node. When you use a TPU on Google Colab, you are accessing it in the **TPU Node** style.\n\nUsing TPU Nodes can have some quite unexpected behaviour for people who aren\u2019t used to them! In particular, because the TPU is located on a physically different system to the machine you\u2019re running your Python code on, your data cannot be local to your machine - any data pipeline that loads from your machine\u2019s internal storage will totally fail! Instead, data must be stored in Google Cloud Storage where your data pipeline can still access it, even when the pipeline is running on the remote TPU node.\n\n<Tip>\n\nIf you can fit all your data in memory as `np.ndarray` or `tf.Tensor`, then you can `fit()` on that data even when using Colab or a TPU Node, without needing to upload it to Google Cloud Storage.\n\n</Tip>\n\n<Tip>\n\n**\ud83e\udd17Specific Hugging Face Tip\ud83e\udd17:** The methods `Dataset.to_tf_dataset()` and its higher-level wrapper `model.prepare_tf_dataset()` , which you will see throughout our TF code examples, will both fail on a TPU Node. The reason for this is that even though they create a `tf.data.Dataset` it is not a \u201cpure\u201d `tf.data` pipeline and uses `tf.numpy_function` or `Dataset.from_generator()` to stream data from the underlying HuggingFace `Dataset`. This HuggingFace `Dataset` is backed by data that is on a local disc and which the remote TPU Node will not be able to read.\n\n</Tip>\n\nThe second way to access a TPU is via a **TPU VM.** When using a TPU VM, you connect directly to the machine that the TPU is attached to, much like training on a GPU VM. TPU VMs are generally easier to work with, particularly when it comes to your data pipeline. All of the above warnings do not apply to TPU VMs!\n\nThis is an opinionated document, so here\u2019s our opinion: **Avoid using TPU Node if possible.** It is more confusing and more difficult to debug than TPU VMs. It is also likely to be unsupported in future - Google\u2019s latest TPU, TPUv4, can only be accessed as a TPU VM, which suggests that TPU Nodes are increasingly going to become a \u201clegacy\u201d access method."
            },
            {
                "score": 0.6025895276266439,
                "node_text": "Here are some facts extracted from the provided text:\n\nTrim_words -> Is -> Batch function\n\ntqdm` \u81ea\u52a8\u62a5\u544a\u8fdb\u5ea6\u66f4\u65b0\uff0c\u8bf7\u5c06\u9ed8\u8ba4\u53c2\u6570\u8bbe\u7f6e\u4e3a `gr.Progress(track_tqdm=True)`\uff01\n\n## \u6279\u5904\u7406\u51fd\u6570 (Batch Functions)\n\nGradio \u652f\u6301\u4f20\u9012*\u6279\u5904\u7406*\u51fd\u6570\u3002\u6279\u5904\u7406\u51fd\u6570\u53ea\u662f\u63a5\u53d7\u8f93\u5165\u5217\u8868\u5e76\u8fd4\u56de\u9884\u6d4b\u5217\u8868\u7684\u51fd\u6570\u3002\n\n\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\u6279\u5904\u7406\u51fd\u6570\uff0c\u5b83\u63a5\u53d7\u4e24\u4e2a\u8f93\u5165\u5217\u8868\uff08\u4e00\u4e2a\u5355\u8bcd\u5217\u8868\u548c\u4e00\u4e2a\u6574\u6570\u5217\u8868\uff09\uff0c\u5e76\u8fd4\u56de\u4fee\u526a\u8fc7\u7684\u5355\u8bcd\u5217\u8868\u4f5c\u4e3a\u8f93\u51fa\uff1a\n\n```python\nimport time\n\ndef trim_words(words, lens):\n    trimmed_words = []\n    time.sleep(5)\n    for w, l in zip(words, lens):\n        trimmed_words.append(w[:int(l)])\n    return [trimmed_words]\n    for w, l in zip(words, lens):\n```\n\n\u4f7f\u7528\u6279\u5904\u7406\u51fd\u6570\u7684\u4f18\u70b9\u662f\uff0c\u5982\u679c\u542f\u7528\u4e86\u961f\u5217\uff0cGradio \u670d\u52a1\u5668\u53ef\u4ee5\u81ea\u52a8*\u6279\u5904\u7406*\u4f20\u5165\u7684\u8bf7\u6c42\u5e76\u5e76\u884c\u5904\u7406\u5b83\u4eec\uff0c\u4ece\u800c\u53ef\u80fd\u52a0\u5feb\u6f14\u793a\u901f\u5ea6\u3002\u4ee5\u4e0b\u662f Gradio \u4ee3\u7801\u7684\u793a\u4f8b\uff08\u8bf7\u6ce8\u610f `batch=True` \u548c `max_batch_size=16` - \u8fd9\u4e24\u4e2a\u53c2\u6570\u90fd\u53ef\u4ee5\u4f20\u9012\u7ed9\u4e8b\u4ef6\u89e6\u53d1\u5668\u6216 `Interface` \u7c7b\uff09\n\nwith `Interface`\uff1a\n\n```python\ndemo = gr.Interface(trim_words, [\"textbox\", \"number\"], [\"output\"],\n                    batch=True, max_batch_size=16)\ndemo.queue()\ndemo.launch()\n```\n\nwith `Blocks`\uff1a\n\n```python\nimport gradio as gr\n\nwith gr.Blocks() as demo:\n    with gr.Row():\n        word = gr.Textbox(label=\"word\")\n        leng = gr.Number(label=\"leng\")\n        output = gr.Textbox(label=\"Output\")\n    with gr.Row():\n        run = gr.Button()\n\n    event = run.click(trim_words, [word, leng], output, batch=True, max_batch_size=16)\n\ndemo.queue()\ndemo.launch()\n```\n\n\u5728\u4e0a\u9762\u7684\u793a\u4f8b\u4e2d\uff0c\u53ef\u4ee5\u5e76\u884c\u5904\u7406 16 \u4e2a\u8bf7\u6c42\uff08\u603b\u63a8\u7406\u65f6\u95f4\u4e3a 5 \u79d2\uff09\uff0c\u800c\u4e0d\u662f\u5206\u522b\u5904\u7406\u6bcf\u4e2a\u8bf7\u6c42\uff08\u603b\u63a8\u7406\u65f6\u95f4\u4e3a 80 \u79d2\uff09\u3002\u8bb8\u591a Hugging Face \u7684 `transformers` \u548c `diffusers` \u6a21\u578b\u5728 Gradio \u7684\u6279\u5904\u7406\u6a21\u5f0f\u4e0b\u81ea\u7136\u5de5\u4f5c\uff1a\u8fd9\u662f[\u4f7f\u7528\u6279\u5904\u7406\u751f\u6210\u56fe\u50cf\u7684\u793a\u4f8b\u6f14\u793a](https://github.com/gradio-app/gradio/blob/main/demo/diffusers_with_batching/run.py)\n\n\u6ce8\u610f\uff1a\u4f7f\u7528 Gradio \u7684\u6279\u5904\u7406\u51fd\u6570 **requires** \u5728\u5e95\u5c42 Interface \u6216 Blocks \u4e2d\u542f\u7528\u961f\u5217\uff08\u8bf7\u53c2\u9605\u4e0a\u9762\u7684\u961f\u5217\u90e8\u5206\uff09\u3002\n\n## Gradio \u7b14\u8bb0\u672c (Colab Notebooks)\n\nGradio \u53ef\u4ee5\u5728\u4efb\u4f55\u8fd0\u884c Python \u7684\u5730\u65b9\u8fd0\u884c\uff0c\u5305\u62ec\u672c\u5730 Jupyter \u7b14\u8bb0\u672c\u548c\u534f\u4f5c\u7b14\u8bb0\u672c\uff0c\u5982[Google Colab](https://colab.research.google.com/)\u3002\u5bf9\u4e8e\u672c\u5730 Jupyter \u7b14\u8bb0\u672c\u548c Google Colab \u7b14\u8bb0\u672c\uff0cGradio \u5728\u672c\u5730\u670d\u52a1\u5668\u4e0a\u8fd0\u884c\uff0c\u60a8\u53ef\u4ee5\u5728\u6d4f\u89c8\u5668\u4e2d\u4e0e\u4e4b\u4ea4\u4e92\u3002\uff08\u6ce8\u610f\uff1a\u5bf9\u4e8e Google Colab\uff0c\u8fd9\u662f\u901a\u8fc7[\u670d\u52a1\u5de5\u4f5c\u5668\u96a7\u9053](https://github.com/tensorflow/tensorboard/blob/master/docs/design/colab_integration.md)\u5b9e\u73b0\u7684\uff0c\u60a8\u7684\u6d4f\u89c8\u5668\u9700\u8981\u542f\u7528 cookies\u3002\uff09\u5bf9\u4e8e\u5176\u4ed6\u8fdc\u7a0b\u7b14\u8bb0\u672c\uff0cGradio \u4e5f\u5c06\u5728\u670d\u52a1\u5668\u4e0a\u8fd0\u884c\uff0c\u4f46\u60a8\u9700\u8981\u4f7f\u7528[SSH \u96a7\u9053](https://coderwall.com/p/ohk6cg/remote-access-to-ipython-notebooks-via-ssh)\u5728\u672c\u5730\u6d4f\u89c8\u5668\u4e2d\u67e5\u770b\u5e94\u7528\u7a0b\u5e8f\u3002\u901a\u5e38\uff0c\u66f4\u7b80\u5355\u7684\u9009\u62e9\u662f\u4f7f\u7528 Gradio \u5185\u7f6e\u7684\u516c\u5171\u94fe\u63a5\uff0c[\u5728\u4e0b\u4e00\u7bc7\u6307\u5357\u4e2d\u8ba8\u8bba](/sharing-your-app/#sharing-demos)\u3002"
            },
            {
                "score": 0.5991283544859964,
                "node_text": "Here are some facts extracted from the provided text:\n\nInference widget -> Is used for -> Testing endpoint\n\nCreate an Endpoint\n\nAfter your first login, you will be directed to the [Endpoint creation page](https://ui.endpoints.huggingface.co/new). As an example, this guide will go through the steps to deploy [distilbert-base-uncased-finetuned-sst-2-english](https://huggingface.co/distilbert-base-uncased-finetuned-sst-2-english) for text classification. \n\n## 1. Enter the Hugging Face Repository ID and your desired endpoint name:\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_repository.png\" alt=\"select repository\" />\n\n## 2. Select your Cloud Provider and region. Initially, only AWS will be available as a Cloud Provider with the `us-east-1` and `eu-west-1` regions. We will add Azure soon, and if you need to test Endpoints with other Cloud Providers or regions, please let us know.\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_region.png\" alt=\"select region\" />\n\n## 3. Define the [Security Level](security) for the Endpoint:\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_security.png\" alt=\"define security\" />\n\n## 4. Create your Endpoint by clicking **Create Endpoint**. By default, your Endpoint is created with a medium CPU (2 x 4GB vCPUs with Intel Xeon Ice Lake) The cost estimate assumes the Endpoint will be up for an entire month, and does not take autoscaling into account.\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_create_cost.png\" alt=\"create endpoint\" />\n\n## 5. Wait for the Endpoint to build, initialize and run which can take between 1 to 5 minutes.\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/overview.png\" alt=\"overview\" />\n\n## 6. Test your Endpoint in the overview with the Inference widget \ud83c\udfc1 \ud83c\udf89!\n\n<img src=\"https://raw.githubusercontent.com/huggingface/hf-endpoints-documentation/main/assets/1_inference.png\" alt=\"run inference\" />"
            }
        ]
    },
    {
        "sample_idx": 123,
        "question": "What is the title of the paper cited in the BibTeX citation?",
        "answer": "Squeeze-and-Excitation Networks",
        "rag_answer": "There is no paper cited in the provided context, so there is no title to provide. The context appears to be a tutorial or documentation on evaluating models, metrics, and datasets, with examples in Python using libraries like Gradio and Hugging Face.",
        "rag_score": 1,
        "rag_feedback": "The system's response is completely incorrect, inaccurate, and/or not factual. The question asks for the title of a paper cited in a BibTeX citation, but the system's response is a long text about evaluating models, metrics, and datasets, with examples in Python using libraries like Gradio and Hugging Face. There is no mention of a paper or its title.",
        "rag_context": [
            {
                "score": 0.6629063715364246,
                "node_text": "Here are some facts extracted from the provided text:\n\nReferences -> Based on -> Id\nPrediction_text -> Compares with -> References\n\nIf you are evaluating your model on a benchmark dataset like the ones mentioned above, you can use its dedicated evaluation metric. Make sure you respect the format that they require. For example, to evaluate your model on the [SQuAD](https://huggingface.co/datasets/squad) dataset, you need to feed the `question` and `context` into your model and return the `prediction_text`, which should be compared with the `references` (based on matching the `id` of the question) :\n\n```\n>>> from evaluate import load\n>>> squad_metric = load(\"squad\")\n>>> predictions = [{'prediction_text': '1976', 'id': '56e10a3be3433e1400422b22'}]\n>>> references = [{'answers': {'answer_start': [97], 'text': ['1976']}, 'id': '56e10a3be3433e1400422b22'}]\n>>> results = squad_metric.compute(predictions=predictions, references=references)\n>>> results\n{'exact_match': 100.0, 'f1': 100.0}\n```\n\nYou can find examples of dataset structures by consulting the \"Dataset Preview\" function or the dataset card for a given dataset, and you can see how to use its dedicated evaluation function based on the metric card."
            },
            {
                "score": 0.6167641362048044,
                "node_text": "Here are some facts extracted from the provided text:\n\nGradio -> Can run -> In colab notebooks\n\nGradio Demo: blocks_random_slider\n\n\n```\n!pip install -q gradio \n```\n\n\n```\n\nimport gradio as gr\n\n\ndef func(slider_1, slider_2):\n    return slider_1 * 5 + slider_2\n\n\nwith gr.Blocks() as demo:\n    slider = gr.Slider(minimum=-10.2, maximum=15, label=\"Random Slider (Static)\", randomize=True)\n    slider_1 = gr.Slider(minimum=100, maximum=200, label=\"Random Slider (Input 1)\", randomize=True)\n    slider_2 = gr.Slider(minimum=10, maximum=23.2, label=\"Random Slider (Input 2)\", randomize=True)\n    slider_3 = gr.Slider(value=3, label=\"Non random slider\")\n    btn = gr.Button(\"Run\")\n    btn.click(func, inputs=[slider_1, slider_2], outputs=gr.Number())\n\nif __name__ == \"__main__\":\n    demo.launch()\n\n```"
            },
            {
                "score": 0.6055997083561202,
                "node_text": "Here are some facts extracted from the provided text:\n\nNamed entity recognition -> Evaluated with -> Seqeval\n\nChoosing a metric for your task\n\n**So you've trained your model and want to see how well it\u2019s doing on a dataset of your choice. Where do you start?**\n\nThere is no \u201cone size fits all\u201d approach to choosing an evaluation metric, but some good guidelines to keep in mind are:\n\n## Categories of metrics\n\nThere are 3 high-level categories of metrics:\n\n1. *Generic metrics*, which can be applied to a variety of situations and datasets, such as precision and accuracy.\n2. *Task-specific metrics*, which are limited to a given task, such as Machine Translation (often evaluated using metrics [BLEU](https://huggingface.co/metrics/bleu) or [ROUGE](https://huggingface.co/metrics/rouge)) or Named Entity Recognition (often evaluated with [seqeval](https://huggingface.co/metrics/seqeval)).\n3. *Dataset-specific metrics*, which aim to measure model performance on specific benchmarks: for instance, the [GLUE benchmark](https://huggingface.co/datasets/glue) has a dedicated [evaluation metric](https://huggingface.co/metrics/glue).\n\nLet's look at each of these three cases:\n\n### Generic metrics\n\nMany of the metrics used in the Machine Learning community are quite generic and can be applied in a variety of tasks and datasets.\n\nThis is the case for metrics like [accuracy](https://huggingface.co/metrics/accuracy) and [precision](https://huggingface.co/metrics/precision), which can be used for evaluating labeled (supervised) datasets, as well as [perplexity](https://huggingface.co/metrics/perplexity), which can be used for evaluating different kinds of (unsupervised) generative tasks.\n\nTo see the input structure of a given metric, you can look at its metric card. For example, in the case of [precision](https://huggingface.co/metrics/precision), the format is:\n```\n>>> precision_metric = evaluate.load(\"precision\")\n>>> results = precision_metric.compute(references=[0, 1], predictions=[0, 1])\n>>> print(results)\n{'precision': 1.0}\n```\n\n### Task-specific metrics\n\nPopular ML tasks like Machine Translation and Named Entity Recognition have specific metrics that can be used to compare models. For example, a series of different metrics have been proposed for text generation, ranging from [BLEU](https://huggingface.co/metrics/bleu) and its derivatives such as [GoogleBLEU](https://huggingface.co/metrics/google_bleu) and [GLEU](https://huggingface.co/metrics/gleu), but also [ROUGE](https://huggingface.co/metrics/rouge), [MAUVE](https://huggingface.co/metrics/mauve), etc.\n\nYou can find the right metric for your task by:\n\n- **Looking at the [Task pages](https://huggingface.co/tasks)** to see what metrics can be used for evaluating models for a given task.\n- **Checking out leaderboards** on sites like [Papers With Code](https://paperswithcode.com/) (you can search by task and by dataset).\n-  **Reading the metric cards** for the relevant metrics and see which ones are a good fit for your use case. For example, see the [BLEU metric card](https://github.com/huggingface/evaluate/tree/main/metrics/bleu) or [SQuaD metric card](https://github.com/huggingface/evaluate/tree/main/metrics/squad).\n- **Looking at papers and blog posts** published on the topic and see what metrics they report. This can change over time, so try to pick papers from the last couple of years!\n\n### Dataset-specific metrics\n\nSome datasets have specific metrics associated with them -- this is especially in the case of popular benchmarks like [GLUE](https://huggingface.co/metrics/glue) and [SQuAD](https://huggingface.co/metrics/squad).\n\n<Tip warning={true}>\n\ud83d\udca1\nGLUE is actually a collection of different subsets on different tasks, so first you need to choose the one that corresponds to the NLI task, such as mnli, which is described as \u201ccrowdsourced collection of sentence pairs with textual entailment annotations\u201d\n</Tip>"
            },
            {
                "score": 0.6035594311133693,
                "node_text": "Here are some facts extracted from the provided text:\n\nGr.blocks -> Has parameter -> Concurrency_count\n\nBlocks() as demo\uff1a\n    #.\ndemo.queue()\ndemo.launch()\n```\n\n\u60a8\u53ef\u4ee5\u901a\u8fc7\u4ee5\u4e0b\u65b9\u5f0f\u63a7\u5236\u4e00\u6b21\u5904\u7406\u7684\u8bf7\u6c42\u6570\u91cf\uff1a\n\n```python\ndemo.queue(concurrency_count=3)\n```\n\n\u67e5\u770b\u6709\u5173\u914d\u7f6e\u5176\u4ed6\u961f\u5217\u53c2\u6570\u7684[\u961f\u5217\u6587\u6863](/docs/#queue)\u3002\n\n\u5728 Blocks \u4e2d\u6307\u5b9a\u4ec5\u5bf9\u67d0\u4e9b\u51fd\u6570\u8fdb\u884c\u6392\u961f\uff1a\n\n```python\nwith gr.Blocks() as demo2\uff1a\n    num1 = gr.Number()\n    num2 = gr.Number()\n    output = gr.Number()\n    gr.Button(\"Add\").click(\n        lambda a, b: a + b, [num1, num2], output)\n    gr.Button(\"Multiply\").click(\n        lambda a, b: a * b, [num1, num2], output, queue=True)\ndemo2.launch()\n```\n\n## \u8fed\u4ee3\u8f93\u51fa (Iterative Outputs)\n\n\u5728\u67d0\u4e9b\u60c5\u51b5\u4e0b\uff0c\u60a8\u53ef\u80fd\u9700\u8981\u4f20\u8f93\u4e00\u7cfb\u5217\u8f93\u51fa\u800c\u4e0d\u662f\u4e00\u6b21\u663e\u793a\u5355\u4e2a\u8f93\u51fa\u3002\u4f8b\u5982\uff0c\u60a8\u53ef\u80fd\u6709\u4e00\u4e2a\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5e0c\u671b\u663e\u793a\u751f\u6210\u7684\u6bcf\u4e2a\u6b65\u9aa4\u7684\u56fe\u50cf\uff0c\u76f4\u5230\u6700\u7ec8\u56fe\u50cf\u3002\u6216\u8005\u60a8\u53ef\u80fd\u6709\u4e00\u4e2a\u804a\u5929\u673a\u5668\u4eba\uff0c\u5b83\u9010\u5b57\u9010\u53e5\u5730\u6d41\u5f0f\u4f20\u8f93\u54cd\u5e94\uff0c\u800c\u4e0d\u662f\u4e00\u6b21\u8fd4\u56de\u5168\u90e8\u54cd\u5e94\u3002\n\n\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u60a8\u53ef\u4ee5\u5c06**\u751f\u6210\u5668**\u51fd\u6570\u63d0\u4f9b\u7ed9 Gradio\uff0c\u800c\u4e0d\u662f\u5e38\u89c4\u51fd\u6570\u3002\u5728 Python \u4e2d\u521b\u5efa\u751f\u6210\u5668\u975e\u5e38\u7b80\u5355\uff1a\u51fd\u6570\u4e0d\u5e94\u8be5\u6709\u4e00\u4e2a\u5355\u72ec\u7684 `return` \u503c\uff0c\u800c\u662f\u5e94\u8be5 with `yield` \u8fde\u7eed\u8fd4\u56de\u4e00\u7cfb\u5217\u503c\u3002\u901a\u5e38\uff0c`yield` \u8bed\u53e5\u653e\u7f6e\u5728\u67d0\u79cd\u5faa\u73af\u4e2d\u3002\u4e0b\u9762\u662f\u4e00\u4e2a\u7b80\u5355\u793a\u4f8b\uff0c\u751f\u6210\u5668\u53ea\u662f\u7b80\u5355\u8ba1\u6570\u5230\u7ed9\u5b9a\u6570\u5b57\uff1a\n\n```python\ndef my_generator(x):\n    for i in range(x):\n        yield i\n```\n\n\u60a8\u4ee5\u4e0e\u5e38\u89c4\u51fd\u6570\u76f8\u540c\u7684\u65b9\u5f0f\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio\u3002\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\uff08\u865a\u62df\u7684\uff09\u56fe\u50cf\u751f\u6210\u6a21\u578b\uff0c\u5b83\u5728\u8f93\u51fa\u56fe\u50cf\u4e4b\u524d\u751f\u6210\u6570\u4e2a\u6b65\u9aa4\u7684\u566a\u97f3\uff1a\n\n$code_fake_diffusion\n$demo_fake_diffusion\n\n\u8bf7\u6ce8\u610f\uff0c\u6211\u4eec\u5728\u8fed\u4ee3\u5668\u4e2d\u6dfb\u52a0\u4e86 `time.sleep(1)`\uff0c\u4ee5\u521b\u5efa\u6b65\u9aa4\u4e4b\u95f4\u7684\u4eba\u5de5\u6682\u505c\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u89c2\u5bdf\u8fed\u4ee3\u5668\u7684\u6b65\u9aa4\uff08\u5728\u771f\u5b9e\u7684\u56fe\u50cf\u751f\u6210\u6a21\u578b\u4e2d\uff0c\u8fd9\u53ef\u80fd\u662f\u4e0d\u5fc5\u8981\u7684\uff09\u3002\n\n\u5c06\u751f\u6210\u5668\u63d0\u4f9b\u7ed9 Gradio **\u9700\u8981**\u5728\u5e95\u5c42 Interface \u6216 Blocks \u4e2d\u542f\u7528\u961f\u5217\uff08\u8bf7\u53c2\u9605\u4e0a\u9762\u7684\u961f\u5217\u90e8\u5206\uff09\u3002\n\n## \u8fdb\u5ea6\u6761\n\nGradio \u652f\u6301\u521b\u5efa\u81ea\u5b9a\u4e49\u8fdb\u5ea6\u6761\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u81ea\u5b9a\u4e49\u548c\u63a7\u5236\u5411\u7528\u6237\u663e\u793a\u7684\u8fdb\u5ea6\u66f4\u65b0\u3002\u8981\u542f\u7528\u6b64\u529f\u80fd\uff0c\u53ea\u9700\u4e3a\u65b9\u6cd5\u6dfb\u52a0\u4e00\u4e2a\u9ed8\u8ba4\u503c\u4e3a `gr.Progress` \u5b9e\u4f8b\u7684\u53c2\u6570\u5373\u53ef\u3002\u7136\u540e\uff0c\u60a8\u53ef\u4ee5\u76f4\u63a5\u8c03\u7528\u6b64\u5b9e\u4f8b\u5e76\u4f20\u5165 0 \u5230 1 \u4e4b\u95f4\u7684\u6d6e\u70b9\u6570\u6765\u66f4\u65b0\u8fdb\u5ea6\u7ea7\u522b\uff0c\u6216\u8005 with `Progress` \u5b9e\u4f8b\u7684 `tqdm()` \u65b9\u6cd5\u6765\u8ddf\u8e2a\u53ef\u8fed\u4ee3\u5bf9\u8c61\u4e0a\u7684\u8fdb\u5ea6\uff0c\u5982\u4e0b\u6240\u793a\u3002\u5fc5\u987b\u542f\u7528\u961f\u5217\u4ee5\u8fdb\u884c\u8fdb\u5ea6\u66f4\u65b0\u3002\n\n$code_progress_simple\n$demo_progress_simple\n\n\u5982\u679c\u60a8 with `tqdm` \u5e93\uff0c\u5e76\u4e14\u5e0c\u671b\u4ece\u51fd\u6570\u5185\u90e8\u7684\u4efb\u4f55 `tqdm.tqdm` \u81ea\u52a8\u62a5\u544a\u8fdb\u5ea6\u66f4\u65b0\uff0c\u8bf7\u5c06\u9ed8\u8ba4\u53c2\u6570\u8bbe\u7f6e\u4e3a `gr.Progress(track_tqdm=True)`\uff01\n\n## \u6279\u5904\u7406\u51fd\u6570 (Batch Functions)\n\nGradio \u652f\u6301\u4f20\u9012*\u6279\u5904\u7406*\u51fd\u6570\u3002\u6279\u5904\u7406\u51fd\u6570\u53ea\u662f\u63a5\u53d7\u8f93\u5165\u5217\u8868\u5e76\u8fd4\u56de\u9884\u6d4b\u5217\u8868\u7684\u51fd\u6570\u3002\n\n\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\u6279\u5904\u7406\u51fd\u6570\uff0c\u5b83\u63a5\u53d7\u4e24\u4e2a\u8f93\u5165\u5217\u8868\uff08\u4e00\u4e2a\u5355\u8bcd\u5217\u8868\u548c\u4e00\u4e2a\u6574\u6570\u5217\u8868\uff09\uff0c\u5e76\u8fd4\u56de\u4fee\u526a\u8fc7\u7684\u5355\u8bcd\u5217\u8868\u4f5c\u4e3a\u8f93\u51fa\uff1a\n\n```python\nimport time\n\ndef trim_words(words, lens):\n    trimmed_words = []\n    time.sleep(5)\n    for w, l in zip(words, lens):\n        trimmed_words.append(w[:int(l)])\n    return [trimmed_words]\n    for w, l in zip(words,"
            }
        ]
    },
    {
        "sample_idx": 124,
        "question": "In what year was the paper 'Squeeze-and-Excitation Networks' published?",
        "answer": "2019",
        "rag_answer": "There is no information about the paper 'Squeeze-and-Excitation Networks' in the provided context. The context only mentions TPU, XLA, NLP models, tokenization, padding, HuggingFace, Gradio, and SQuAD dataset, but not the paper 'Squeeze-and-Excitation Networks'. Therefore, it is not possible to determine the year the paper was published based on the provided context.",
        "rag_score": 1,
        "rag_feedback": "The system's response is completely incorrect, inaccurate, and/or not factual. The system claims that there is no information about the paper 'Squeeze-and-Excitation Networks' in the provided context, which is true, but it does not provide the correct answer or any relevant information.",
        "rag_context": [
            {
                "score": 0.5987346159582739,
                "node_text": "Here are some facts extracted from the provided text:\n\nTpu -> Used for -> Neural networks\n\nThis is a really useful trick, so remember it if you need to convert your own code to XLA!\n\n#### XLA Rule #3: XLA will need to recompile your model for every different input shape it sees\n\nThis is the big one. What this means is that if your input shapes are very variable, XLA will have to recompile your model over and over, which will create huge performance problems. This commonly arises in NLP models, where input texts have variable lengths after tokenization. In other modalities, static shapes are more common and this rule is much less of a problem.\n\nHow can you get around rule #3? The key is **padding** - if you pad all your inputs to the same length, and then use an `attention_mask`, you can get the same results as you\u2019d get from variable shapes, but without any XLA issues. However, excessive padding can cause severe slowdown too - if you pad all your samples to the maximum length in the whole dataset, you might end up with batches consisting endless padding tokens, which will waste a lot of compute and memory!\n\nThere isn\u2019t a perfect solution to this problem. However, you can try some tricks. One very useful trick is to **pad batches of samples up to a multiple of a number like 32 or 64 tokens.** This often only increases the number of tokens by a small amount, but it hugely reduces the number of unique input shapes, because every input shape now has to be a multiple of 32 or 64. Fewer unique input shapes means fewer XLA compilations!\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** Our tokenizers and data collators have methods that can help you here. You can use `padding=\"max_length\"` or `padding=\"longest\"` when calling tokenizers to get them to output padded data. Our tokenizers and data collators also have a `pad_to_multiple_of` argument that you can use to reduce the number of unique input shapes you see!\n\n</Tip>\n\n### How do I actually train my model on TPU?\n\nOnce your training is XLA-compatible and (if you\u2019re using TPU Node / Colab) your dataset has been prepared appropriately, running on TPU is surprisingly easy! All you really need to change in your code is to add a few lines to initialize your TPU, and to ensure that your model and dataset are created inside a `TPUStrategy` scope. Take a look at [our TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) to see this in action!\n\n### Summary\n\nThere was a lot in here, so let\u2019s summarize with a quick checklist you can follow when you want to get your model ready for TPU training:\n\n- Make sure your code follows the three rules of XLA\n- Compile your model with `jit_compile=True` on CPU/GPU and confirm that you can train it with XLA\n- Either load your dataset into memory or use a TPU-compatible dataset loading approach (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Migrate your code either to Colab (with accelerator set to \u201cTPU\u201d) or a TPU VM on Google Cloud\n- Add TPU initializer code (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Create your `TPUStrategy` and make sure dataset loading and model creation are inside the `strategy.scope()` (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Don\u2019t forget to take `jit_compile=True` out again when you move to TPU!\n- \ud83d\ude4f\ud83d\ude4f\ud83d\ude4f\ud83e\udd7a\ud83e\udd7a\ud83e\udd7a\n- Call model.fit()\n- You did it!"
            },
            {
                "score": 0.5698564913181879,
                "node_text": "Here are some facts extracted from the provided text:\n\nFunc -> Takes -> Slider_2\nFunc -> Takes -> Slider_1\n\nGradio Demo: blocks_random_slider\n\n\n```\n!pip install -q gradio \n```\n\n\n```\n\nimport gradio as gr\n\n\ndef func(slider_1, slider_2):\n    return slider_1 * 5 + slider_2\n\n\nwith gr.Blocks() as demo:\n    slider = gr.Slider(minimum=-10.2, maximum=15, label=\"Random Slider (Static)\", randomize=True)\n    slider_1 = gr.Slider(minimum=100, maximum=200, label=\"Random Slider (Input 1)\", randomize=True)\n    slider_2 = gr.Slider(minimum=10, maximum=23.2, label=\"Random Slider (Input 2)\", randomize=True)\n    slider_3 = gr.Slider(value=3, label=\"Non random slider\")\n    btn = gr.Button(\"Run\")\n    btn.click(func, inputs=[slider_1, slider_2], outputs=gr.Number())\n\nif __name__ == \"__main__\":\n    demo.launch()\n\n```"
            },
            {
                "score": 0.5499455259877807,
                "node_text": "Here are some facts extracted from the provided text:\n\nReferences -> Based on -> Id\nPrediction_text -> Compares with -> References\n\nIf you are evaluating your model on a benchmark dataset like the ones mentioned above, you can use its dedicated evaluation metric. Make sure you respect the format that they require. For example, to evaluate your model on the [SQuAD](https://huggingface.co/datasets/squad) dataset, you need to feed the `question` and `context` into your model and return the `prediction_text`, which should be compared with the `references` (based on matching the `id` of the question) :\n\n```\n>>> from evaluate import load\n>>> squad_metric = load(\"squad\")\n>>> predictions = [{'prediction_text': '1976', 'id': '56e10a3be3433e1400422b22'}]\n>>> references = [{'answers': {'answer_start': [97], 'text': ['1976']}, 'id': '56e10a3be3433e1400422b22'}]\n>>> results = squad_metric.compute(predictions=predictions, references=references)\n>>> results\n{'exact_match': 100.0, 'f1': 100.0}\n```\n\nYou can find examples of dataset structures by consulting the \"Dataset Preview\" function or the dataset card for a given dataset, and you can see how to use its dedicated evaluation function based on the metric card."
            }
        ]
    },
    {
        "sample_idx": 125,
        "question": "What is the ID of the model?",
        "answer": "seresnet50",
        "rag_answer": "The ID of the model is layoutlmv3-finetuned-funsd or layoutlmv3-finetuned-cord, depending on the dataset used for fine-tuning (FUNSD or CORD).",
        "rag_score": 1,
        "rag_feedback": "The system's response is completely incorrect, inaccurate, and/or not factual. The expected answer is 'seresnet50', but the system's response is about layoutlmv3-finetuned-funsd or layoutlmv3-finetuned-cord, which is unrelated to the question.",
        "rag_context": [
            {
                "score": 0.7085730620175282,
                "node_text": "Here are some facts extracted from the provided text:\n\nMicrosoft/layoutlmv3-base -> Is -> Model name or path\nModel -> Needs -> Question\nModel -> Has -> Input shape\nModel -> Needs -> Context\nModel -> Evaluates on -> Squad\nNielsr/layoutlmv3-finetuned-funsd -> Is -> Model\nModel -> Returns -> Prediction_text\n\n!---\nCopyright 2022 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n-->\n\n# Token classification with LayoutLMv3 (PyTorch version)\n\nThis directory contains a script, `run_funsd_cord.py`, that can be used to fine-tune (or evaluate) LayoutLMv3 on form understanding datasets, such as [FUNSD](https://guillaumejaume.github.io/FUNSD/) and [CORD](https://github.com/clovaai/cord).\n\nThe script `run_funsd_cord.py` leverages the \ud83e\udd17 Datasets library and the Trainer API. You can easily customize it to your needs.\n\n## Fine-tuning on FUNSD\n\nFine-tuning LayoutLMv3 for token classification on [FUNSD](https://guillaumejaume.github.io/FUNSD/) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name funsd \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 1e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-funsd\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd. By specifying the `push_to_hub` flag, the model gets uploaded automatically to the hub (regularly), together with a model card, which includes metrics such as precision, recall and F1. Note that you can easily update the model card, as it's just a README file of the respective repo on the hub.\n\nThere's also the \"Training metrics\" [tab](https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd/tensorboard), which shows Tensorboard logs over the course of training. Pretty neat, huh?\n\n## Fine-tuning on CORD\n\nFine-tuning LayoutLMv3 for token classification on [CORD](https://github.com/clovaai/cord) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name cord \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 5e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-cord\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-cord. Note that a model card gets generated automatically in case you specify the `push_to_hub` flag."
            },
            {
                "score": 0.6971107679457929,
                "node_text": "Here are some facts extracted from the provided text:\n\nXla -> Recompile -> Model\n\nThis is a really useful trick, so remember it if you need to convert your own code to XLA!\n\n#### XLA Rule #3: XLA will need to recompile your model for every different input shape it sees\n\nThis is the big one. What this means is that if your input shapes are very variable, XLA will have to recompile your model over and over, which will create huge performance problems. This commonly arises in NLP models, where input texts have variable lengths after tokenization. In other modalities, static shapes are more common and this rule is much less of a problem.\n\nHow can you get around rule #3? The key is **padding** - if you pad all your inputs to the same length, and then use an `attention_mask`, you can get the same results as you\u2019d get from variable shapes, but without any XLA issues. However, excessive padding can cause severe slowdown too - if you pad all your samples to the maximum length in the whole dataset, you might end up with batches consisting endless padding tokens, which will waste a lot of compute and memory!\n\nThere isn\u2019t a perfect solution to this problem. However, you can try some tricks. One very useful trick is to **pad batches of samples up to a multiple of a number like 32 or 64 tokens.** This often only increases the number of tokens by a small amount, but it hugely reduces the number of unique input shapes, because every input shape now has to be a multiple of 32 or 64. Fewer unique input shapes means fewer XLA compilations!\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** Our tokenizers and data collators have methods that can help you here. You can use `padding=\"max_length\"` or `padding=\"longest\"` when calling tokenizers to get them to output padded data. Our tokenizers and data collators also have a `pad_to_multiple_of` argument that you can use to reduce the number of unique input shapes you see!\n\n</Tip>\n\n### How do I actually train my model on TPU?\n\nOnce your training is XLA-compatible and (if you\u2019re using TPU Node / Colab) your dataset has been prepared appropriately, running on TPU is surprisingly easy! All you really need to change in your code is to add a few lines to initialize your TPU, and to ensure that your model and dataset are created inside a `TPUStrategy` scope. Take a look at [our TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) to see this in action!\n\n### Summary\n\nThere was a lot in here, so let\u2019s summarize with a quick checklist you can follow when you want to get your model ready for TPU training:\n\n- Make sure your code follows the three rules of XLA\n- Compile your model with `jit_compile=True` on CPU/GPU and confirm that you can train it with XLA\n- Either load your dataset into memory or use a TPU-compatible dataset loading approach (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Migrate your code either to Colab (with accelerator set to \u201cTPU\u201d) or a TPU VM on Google Cloud\n- Add TPU initializer code (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Create your `TPUStrategy` and make sure dataset loading and model creation are inside the `strategy.scope()` (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Don\u2019t forget to take `jit_compile=True` out again when you move to TPU!\n- \ud83d\ude4f\ud83d\ude4f\ud83d\ude4f\ud83e\udd7a\ud83e\udd7a\ud83e\udd7a\n- Call model.fit()\n- You did it!"
            },
            {
                "score": 0.6522636141231551,
                "node_text": "Here are some facts extracted from the provided text:\n\nTensorflow models -> Are -> Keras models\n\n!--Copyright 2023 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\nthe License. You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under the License is distributed on\nan \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n\n\u26a0\ufe0f Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be\nrendered properly in your Markdown viewer.\n\n-->\n\n# Training on TPU with TensorFlow\n\n<Tip>\n\nIf you don't need long explanations and just want TPU code samples to get started with, check out [our TPU example notebook!](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb)\n\n</Tip>\n\n### What is a TPU?\n\nA TPU is a **Tensor Processing Unit.** They are hardware designed by Google, which are used to greatly speed up the tensor computations within neural networks, much like GPUs. They can be used for both network training and inference. They are generally accessed through Google\u2019s cloud services, but small TPUs can also be accessed directly for free through Google Colab and Kaggle Kernels.\n\nBecause [all TensorFlow models in \ud83e\udd17 Transformers are Keras models](https://huggingface.co/blog/tensorflow-philosophy), most of the methods in this document are generally applicable to TPU training for any Keras model! However, there are a few points that are specific to the HuggingFace ecosystem (hug-o-system?) of Transformers and Datasets, and we\u2019ll make sure to flag them up when we get to them.\n\n### What kinds of TPU are available?\n\nNew users are often very confused by the range of TPUs, and the different ways to access them. The first key distinction to understand is the difference between **TPU Nodes** and **TPU VMs.**\n\nWhen you use a **TPU Node**, you are effectively indirectly accessing a remote TPU. You will need a separate VM, which will initialize your network and data pipeline and then forward them to the remote node. When you use a TPU on Google Colab, you are accessing it in the **TPU Node** style.\n\nUsing TPU Nodes can have some quite unexpected behaviour for people who aren\u2019t used to them! In particular, because the TPU is located on a physically different system to the machine you\u2019re running your Python code on, your data cannot be local to your machine - any data pipeline that loads from your machine\u2019s internal storage will totally fail! Instead, data must be stored in Google Cloud Storage where your data pipeline can still access it, even when the pipeline is running on the remote TPU node.\n\n<Tip>\n\nIf you can fit all your data in memory as `np.ndarray` or `tf.Tensor`, then you can `fit()` on that data even when using Colab or a TPU Node, without needing to upload it to Google Cloud Storage.\n\n</Tip>\n\n<Tip>\n\n**\ud83e\udd17Specific Hugging Face Tip\ud83e\udd17:** The methods `Dataset.to_tf_dataset()` and its higher-level wrapper `model.prepare_tf_dataset()` , which you will see throughout our TF code examples, will both fail on a TPU Node. The reason for this is that even though they create a `tf.data.Dataset` it is not a \u201cpure\u201d `tf.data` pipeline and uses `tf.numpy_function` or `Dataset.from_generator()` to stream data from the underlying HuggingFace `Dataset`. This HuggingFace `Dataset` is backed by data that is on a local disc and which the remote TPU Node will not be able to read.\n\n</Tip>\n\nThe second way to access a TPU is via a **TPU VM.** When using a TPU VM, you connect directly to the machine that the TPU is attached to, much like training on a GPU VM. TPU VMs are generally easier to work with, particularly when it comes to your data pipeline. All of the above warnings do not apply to TPU VMs!\n\nThis is an opinionated document, so here\u2019s our opinion: **Avoid using TPU Node if possible.** It is more confusing and more difficult to debug than TPU VMs. It is also likely to be unsupported in future - Google\u2019s latest TPU, TPUv4, can only be accessed as a TPU VM, which suggests that TPU Nodes are increasingly going to become a \u201clegacy\u201d access method."
            }
        ]
    },
    {
        "sample_idx": 126,
        "question": "What is the learning rate of the model?",
        "answer": "0.6",
        "rag_answer": "There is no information about the learning rate of the model in the provided context.",
        "rag_score": 1,
        "rag_feedback": "The system's response does not provide the learning rate of the model, which is 0.6. Instead, it provides a lengthy text about TPUs, XLA, and metrics, which is not relevant to the question. The system's response is completely incorrect, inaccurate, and/or not factual.",
        "rag_context": [
            {
                "score": 0.6222629902461201,
                "node_text": "Here are some facts extracted from the provided text:\n\nTensorflow models -> Are -> Keras models\n\n!--Copyright 2023 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\nthe License. You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under the License is distributed on\nan \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n\n\u26a0\ufe0f Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be\nrendered properly in your Markdown viewer.\n\n-->\n\n# Training on TPU with TensorFlow\n\n<Tip>\n\nIf you don't need long explanations and just want TPU code samples to get started with, check out [our TPU example notebook!](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb)\n\n</Tip>\n\n### What is a TPU?\n\nA TPU is a **Tensor Processing Unit.** They are hardware designed by Google, which are used to greatly speed up the tensor computations within neural networks, much like GPUs. They can be used for both network training and inference. They are generally accessed through Google\u2019s cloud services, but small TPUs can also be accessed directly for free through Google Colab and Kaggle Kernels.\n\nBecause [all TensorFlow models in \ud83e\udd17 Transformers are Keras models](https://huggingface.co/blog/tensorflow-philosophy), most of the methods in this document are generally applicable to TPU training for any Keras model! However, there are a few points that are specific to the HuggingFace ecosystem (hug-o-system?) of Transformers and Datasets, and we\u2019ll make sure to flag them up when we get to them.\n\n### What kinds of TPU are available?\n\nNew users are often very confused by the range of TPUs, and the different ways to access them. The first key distinction to understand is the difference between **TPU Nodes** and **TPU VMs.**\n\nWhen you use a **TPU Node**, you are effectively indirectly accessing a remote TPU. You will need a separate VM, which will initialize your network and data pipeline and then forward them to the remote node. When you use a TPU on Google Colab, you are accessing it in the **TPU Node** style.\n\nUsing TPU Nodes can have some quite unexpected behaviour for people who aren\u2019t used to them! In particular, because the TPU is located on a physically different system to the machine you\u2019re running your Python code on, your data cannot be local to your machine - any data pipeline that loads from your machine\u2019s internal storage will totally fail! Instead, data must be stored in Google Cloud Storage where your data pipeline can still access it, even when the pipeline is running on the remote TPU node.\n\n<Tip>\n\nIf you can fit all your data in memory as `np.ndarray` or `tf.Tensor`, then you can `fit()` on that data even when using Colab or a TPU Node, without needing to upload it to Google Cloud Storage.\n\n</Tip>\n\n<Tip>\n\n**\ud83e\udd17Specific Hugging Face Tip\ud83e\udd17:** The methods `Dataset.to_tf_dataset()` and its higher-level wrapper `model.prepare_tf_dataset()` , which you will see throughout our TF code examples, will both fail on a TPU Node. The reason for this is that even though they create a `tf.data.Dataset` it is not a \u201cpure\u201d `tf.data` pipeline and uses `tf.numpy_function` or `Dataset.from_generator()` to stream data from the underlying HuggingFace `Dataset`. This HuggingFace `Dataset` is backed by data that is on a local disc and which the remote TPU Node will not be able to read.\n\n</Tip>\n\nThe second way to access a TPU is via a **TPU VM.** When using a TPU VM, you connect directly to the machine that the TPU is attached to, much like training on a GPU VM. TPU VMs are generally easier to work with, particularly when it comes to your data pipeline. All of the above warnings do not apply to TPU VMs!\n\nThis is an opinionated document, so here\u2019s our opinion: **Avoid using TPU Node if possible.** It is more confusing and more difficult to debug than TPU VMs. It is also likely to be unsupported in future - Google\u2019s latest TPU, TPUv4, can only be accessed as a TPU VM, which suggests that TPU Nodes are increasingly going to become a \u201clegacy\u201d access method."
            },
            {
                "score": 0.5924115578215777,
                "node_text": "Here are some facts extracted from the provided text:\n\nTpu -> Is used -> For training\n\nThis is a really useful trick, so remember it if you need to convert your own code to XLA!\n\n#### XLA Rule #3: XLA will need to recompile your model for every different input shape it sees\n\nThis is the big one. What this means is that if your input shapes are very variable, XLA will have to recompile your model over and over, which will create huge performance problems. This commonly arises in NLP models, where input texts have variable lengths after tokenization. In other modalities, static shapes are more common and this rule is much less of a problem.\n\nHow can you get around rule #3? The key is **padding** - if you pad all your inputs to the same length, and then use an `attention_mask`, you can get the same results as you\u2019d get from variable shapes, but without any XLA issues. However, excessive padding can cause severe slowdown too - if you pad all your samples to the maximum length in the whole dataset, you might end up with batches consisting endless padding tokens, which will waste a lot of compute and memory!\n\nThere isn\u2019t a perfect solution to this problem. However, you can try some tricks. One very useful trick is to **pad batches of samples up to a multiple of a number like 32 or 64 tokens.** This often only increases the number of tokens by a small amount, but it hugely reduces the number of unique input shapes, because every input shape now has to be a multiple of 32 or 64. Fewer unique input shapes means fewer XLA compilations!\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** Our tokenizers and data collators have methods that can help you here. You can use `padding=\"max_length\"` or `padding=\"longest\"` when calling tokenizers to get them to output padded data. Our tokenizers and data collators also have a `pad_to_multiple_of` argument that you can use to reduce the number of unique input shapes you see!\n\n</Tip>\n\n### How do I actually train my model on TPU?\n\nOnce your training is XLA-compatible and (if you\u2019re using TPU Node / Colab) your dataset has been prepared appropriately, running on TPU is surprisingly easy! All you really need to change in your code is to add a few lines to initialize your TPU, and to ensure that your model and dataset are created inside a `TPUStrategy` scope. Take a look at [our TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) to see this in action!\n\n### Summary\n\nThere was a lot in here, so let\u2019s summarize with a quick checklist you can follow when you want to get your model ready for TPU training:\n\n- Make sure your code follows the three rules of XLA\n- Compile your model with `jit_compile=True` on CPU/GPU and confirm that you can train it with XLA\n- Either load your dataset into memory or use a TPU-compatible dataset loading approach (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Migrate your code either to Colab (with accelerator set to \u201cTPU\u201d) or a TPU VM on Google Cloud\n- Add TPU initializer code (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Create your `TPUStrategy` and make sure dataset loading and model creation are inside the `strategy.scope()` (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Don\u2019t forget to take `jit_compile=True` out again when you move to TPU!\n- \ud83d\ude4f\ud83d\ude4f\ud83d\ude4f\ud83e\udd7a\ud83e\udd7a\ud83e\udd7a\n- Call model.fit()\n- You did it!"
            },
            {
                "score": 0.5857407653107477,
                "node_text": "Here are some facts extracted from the provided text:\n\nBleu -> Is -> Task-specific metric\n\nChoosing a metric for your task\n\n**So you've trained your model and want to see how well it\u2019s doing on a dataset of your choice. Where do you start?**\n\nThere is no \u201cone size fits all\u201d approach to choosing an evaluation metric, but some good guidelines to keep in mind are:\n\n## Categories of metrics\n\nThere are 3 high-level categories of metrics:\n\n1. *Generic metrics*, which can be applied to a variety of situations and datasets, such as precision and accuracy.\n2. *Task-specific metrics*, which are limited to a given task, such as Machine Translation (often evaluated using metrics [BLEU](https://huggingface.co/metrics/bleu) or [ROUGE](https://huggingface.co/metrics/rouge)) or Named Entity Recognition (often evaluated with [seqeval](https://huggingface.co/metrics/seqeval)).\n3. *Dataset-specific metrics*, which aim to measure model performance on specific benchmarks: for instance, the [GLUE benchmark](https://huggingface.co/datasets/glue) has a dedicated [evaluation metric](https://huggingface.co/metrics/glue).\n\nLet's look at each of these three cases:\n\n### Generic metrics\n\nMany of the metrics used in the Machine Learning community are quite generic and can be applied in a variety of tasks and datasets.\n\nThis is the case for metrics like [accuracy](https://huggingface.co/metrics/accuracy) and [precision](https://huggingface.co/metrics/precision), which can be used for evaluating labeled (supervised) datasets, as well as [perplexity](https://huggingface.co/metrics/perplexity), which can be used for evaluating different kinds of (unsupervised) generative tasks.\n\nTo see the input structure of a given metric, you can look at its metric card. For example, in the case of [precision](https://huggingface.co/metrics/precision), the format is:\n```\n>>> precision_metric = evaluate.load(\"precision\")\n>>> results = precision_metric.compute(references=[0, 1], predictions=[0, 1])\n>>> print(results)\n{'precision': 1.0}\n```\n\n### Task-specific metrics\n\nPopular ML tasks like Machine Translation and Named Entity Recognition have specific metrics that can be used to compare models. For example, a series of different metrics have been proposed for text generation, ranging from [BLEU](https://huggingface.co/metrics/bleu) and its derivatives such as [GoogleBLEU](https://huggingface.co/metrics/google_bleu) and [GLEU](https://huggingface.co/metrics/gleu), but also [ROUGE](https://huggingface.co/metrics/rouge), [MAUVE](https://huggingface.co/metrics/mauve), etc.\n\nYou can find the right metric for your task by:\n\n- **Looking at the [Task pages](https://huggingface.co/tasks)** to see what metrics can be used for evaluating models for a given task.\n- **Checking out leaderboards** on sites like [Papers With Code](https://paperswithcode.com/) (you can search by task and by dataset).\n-  **Reading the metric cards** for the relevant metrics and see which ones are a good fit for your use case. For example, see the [BLEU metric card](https://github.com/huggingface/evaluate/tree/main/metrics/bleu) or [SQuaD metric card](https://github.com/huggingface/evaluate/tree/main/metrics/squad).\n- **Looking at papers and blog posts** published on the topic and see what metrics they report. This can change over time, so try to pick papers from the last couple of years!\n\n### Dataset-specific metrics\n\nSome datasets have specific metrics associated with them -- this is especially in the case of popular benchmarks like [GLUE](https://huggingface.co/metrics/glue) and [SQuAD](https://huggingface.co/metrics/squad).\n\n<Tip warning={true}>\n\ud83d\udca1\nGLUE is actually a collection of different subsets on different tasks, so first you need to choose the one that corresponds to the NLI task, such as mnli, which is described as \u201ccrowdsourced collection of sentence pairs with textual entailment annotations\u201d\n</Tip>"
            }
        ]
    },
    {
        "sample_idx": 127,
        "question": "How many epochs did the model train for?",
        "answer": "100",
        "rag_answer": "There is no information in the provided context about the number of epochs the model trained for. The context discusses TPUs, XLA, and metrics, but it does not mention the number of epochs.",
        "rag_score": 1,
        "rag_feedback": "The system's response is completely incorrect, inaccurate, and/or not factual. The system did not provide an answer to the question about the number of epochs the model trained for, instead, it provided a lengthy response about TPUs, XLA, and metrics, which is not relevant to the question.",
        "rag_context": [
            {
                "score": 0.6101973096968033,
                "node_text": "Here are some facts extracted from the provided text:\n\nTensorflow models -> Are -> Keras models\n\n!--Copyright 2023 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\nthe License. You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under the License is distributed on\nan \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n\n\u26a0\ufe0f Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be\nrendered properly in your Markdown viewer.\n\n-->\n\n# Training on TPU with TensorFlow\n\n<Tip>\n\nIf you don't need long explanations and just want TPU code samples to get started with, check out [our TPU example notebook!](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb)\n\n</Tip>\n\n### What is a TPU?\n\nA TPU is a **Tensor Processing Unit.** They are hardware designed by Google, which are used to greatly speed up the tensor computations within neural networks, much like GPUs. They can be used for both network training and inference. They are generally accessed through Google\u2019s cloud services, but small TPUs can also be accessed directly for free through Google Colab and Kaggle Kernels.\n\nBecause [all TensorFlow models in \ud83e\udd17 Transformers are Keras models](https://huggingface.co/blog/tensorflow-philosophy), most of the methods in this document are generally applicable to TPU training for any Keras model! However, there are a few points that are specific to the HuggingFace ecosystem (hug-o-system?) of Transformers and Datasets, and we\u2019ll make sure to flag them up when we get to them.\n\n### What kinds of TPU are available?\n\nNew users are often very confused by the range of TPUs, and the different ways to access them. The first key distinction to understand is the difference between **TPU Nodes** and **TPU VMs.**\n\nWhen you use a **TPU Node**, you are effectively indirectly accessing a remote TPU. You will need a separate VM, which will initialize your network and data pipeline and then forward them to the remote node. When you use a TPU on Google Colab, you are accessing it in the **TPU Node** style.\n\nUsing TPU Nodes can have some quite unexpected behaviour for people who aren\u2019t used to them! In particular, because the TPU is located on a physically different system to the machine you\u2019re running your Python code on, your data cannot be local to your machine - any data pipeline that loads from your machine\u2019s internal storage will totally fail! Instead, data must be stored in Google Cloud Storage where your data pipeline can still access it, even when the pipeline is running on the remote TPU node.\n\n<Tip>\n\nIf you can fit all your data in memory as `np.ndarray` or `tf.Tensor`, then you can `fit()` on that data even when using Colab or a TPU Node, without needing to upload it to Google Cloud Storage.\n\n</Tip>\n\n<Tip>\n\n**\ud83e\udd17Specific Hugging Face Tip\ud83e\udd17:** The methods `Dataset.to_tf_dataset()` and its higher-level wrapper `model.prepare_tf_dataset()` , which you will see throughout our TF code examples, will both fail on a TPU Node. The reason for this is that even though they create a `tf.data.Dataset` it is not a \u201cpure\u201d `tf.data` pipeline and uses `tf.numpy_function` or `Dataset.from_generator()` to stream data from the underlying HuggingFace `Dataset`. This HuggingFace `Dataset` is backed by data that is on a local disc and which the remote TPU Node will not be able to read.\n\n</Tip>\n\nThe second way to access a TPU is via a **TPU VM.** When using a TPU VM, you connect directly to the machine that the TPU is attached to, much like training on a GPU VM. TPU VMs are generally easier to work with, particularly when it comes to your data pipeline. All of the above warnings do not apply to TPU VMs!\n\nThis is an opinionated document, so here\u2019s our opinion: **Avoid using TPU Node if possible.** It is more confusing and more difficult to debug than TPU VMs. It is also likely to be unsupported in future - Google\u2019s latest TPU, TPUv4, can only be accessed as a TPU VM, which suggests that TPU Nodes are increasingly going to become a \u201clegacy\u201d access method."
            },
            {
                "score": 0.6043508816900814,
                "node_text": "Here are some facts extracted from the provided text:\n\nTpu -> Is used -> For training\n\nThis is a really useful trick, so remember it if you need to convert your own code to XLA!\n\n#### XLA Rule #3: XLA will need to recompile your model for every different input shape it sees\n\nThis is the big one. What this means is that if your input shapes are very variable, XLA will have to recompile your model over and over, which will create huge performance problems. This commonly arises in NLP models, where input texts have variable lengths after tokenization. In other modalities, static shapes are more common and this rule is much less of a problem.\n\nHow can you get around rule #3? The key is **padding** - if you pad all your inputs to the same length, and then use an `attention_mask`, you can get the same results as you\u2019d get from variable shapes, but without any XLA issues. However, excessive padding can cause severe slowdown too - if you pad all your samples to the maximum length in the whole dataset, you might end up with batches consisting endless padding tokens, which will waste a lot of compute and memory!\n\nThere isn\u2019t a perfect solution to this problem. However, you can try some tricks. One very useful trick is to **pad batches of samples up to a multiple of a number like 32 or 64 tokens.** This often only increases the number of tokens by a small amount, but it hugely reduces the number of unique input shapes, because every input shape now has to be a multiple of 32 or 64. Fewer unique input shapes means fewer XLA compilations!\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** Our tokenizers and data collators have methods that can help you here. You can use `padding=\"max_length\"` or `padding=\"longest\"` when calling tokenizers to get them to output padded data. Our tokenizers and data collators also have a `pad_to_multiple_of` argument that you can use to reduce the number of unique input shapes you see!\n\n</Tip>\n\n### How do I actually train my model on TPU?\n\nOnce your training is XLA-compatible and (if you\u2019re using TPU Node / Colab) your dataset has been prepared appropriately, running on TPU is surprisingly easy! All you really need to change in your code is to add a few lines to initialize your TPU, and to ensure that your model and dataset are created inside a `TPUStrategy` scope. Take a look at [our TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) to see this in action!\n\n### Summary\n\nThere was a lot in here, so let\u2019s summarize with a quick checklist you can follow when you want to get your model ready for TPU training:\n\n- Make sure your code follows the three rules of XLA\n- Compile your model with `jit_compile=True` on CPU/GPU and confirm that you can train it with XLA\n- Either load your dataset into memory or use a TPU-compatible dataset loading approach (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Migrate your code either to Colab (with accelerator set to \u201cTPU\u201d) or a TPU VM on Google Cloud\n- Add TPU initializer code (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Create your `TPUStrategy` and make sure dataset loading and model creation are inside the `strategy.scope()` (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Don\u2019t forget to take `jit_compile=True` out again when you move to TPU!\n- \ud83d\ude4f\ud83d\ude4f\ud83d\ude4f\ud83e\udd7a\ud83e\udd7a\ud83e\udd7a\n- Call model.fit()\n- You did it!"
            },
            {
                "score": 0.5970062448990361,
                "node_text": "Here are some facts extracted from the provided text:\n\nBleu -> Is -> Task-specific metric\n\nChoosing a metric for your task\n\n**So you've trained your model and want to see how well it\u2019s doing on a dataset of your choice. Where do you start?**\n\nThere is no \u201cone size fits all\u201d approach to choosing an evaluation metric, but some good guidelines to keep in mind are:\n\n## Categories of metrics\n\nThere are 3 high-level categories of metrics:\n\n1. *Generic metrics*, which can be applied to a variety of situations and datasets, such as precision and accuracy.\n2. *Task-specific metrics*, which are limited to a given task, such as Machine Translation (often evaluated using metrics [BLEU](https://huggingface.co/metrics/bleu) or [ROUGE](https://huggingface.co/metrics/rouge)) or Named Entity Recognition (often evaluated with [seqeval](https://huggingface.co/metrics/seqeval)).\n3. *Dataset-specific metrics*, which aim to measure model performance on specific benchmarks: for instance, the [GLUE benchmark](https://huggingface.co/datasets/glue) has a dedicated [evaluation metric](https://huggingface.co/metrics/glue).\n\nLet's look at each of these three cases:\n\n### Generic metrics\n\nMany of the metrics used in the Machine Learning community are quite generic and can be applied in a variety of tasks and datasets.\n\nThis is the case for metrics like [accuracy](https://huggingface.co/metrics/accuracy) and [precision](https://huggingface.co/metrics/precision), which can be used for evaluating labeled (supervised) datasets, as well as [perplexity](https://huggingface.co/metrics/perplexity), which can be used for evaluating different kinds of (unsupervised) generative tasks.\n\nTo see the input structure of a given metric, you can look at its metric card. For example, in the case of [precision](https://huggingface.co/metrics/precision), the format is:\n```\n>>> precision_metric = evaluate.load(\"precision\")\n>>> results = precision_metric.compute(references=[0, 1], predictions=[0, 1])\n>>> print(results)\n{'precision': 1.0}\n```\n\n### Task-specific metrics\n\nPopular ML tasks like Machine Translation and Named Entity Recognition have specific metrics that can be used to compare models. For example, a series of different metrics have been proposed for text generation, ranging from [BLEU](https://huggingface.co/metrics/bleu) and its derivatives such as [GoogleBLEU](https://huggingface.co/metrics/google_bleu) and [GLEU](https://huggingface.co/metrics/gleu), but also [ROUGE](https://huggingface.co/metrics/rouge), [MAUVE](https://huggingface.co/metrics/mauve), etc.\n\nYou can find the right metric for your task by:\n\n- **Looking at the [Task pages](https://huggingface.co/tasks)** to see what metrics can be used for evaluating models for a given task.\n- **Checking out leaderboards** on sites like [Papers With Code](https://paperswithcode.com/) (you can search by task and by dataset).\n-  **Reading the metric cards** for the relevant metrics and see which ones are a good fit for your use case. For example, see the [BLEU metric card](https://github.com/huggingface/evaluate/tree/main/metrics/bleu) or [SQuaD metric card](https://github.com/huggingface/evaluate/tree/main/metrics/squad).\n- **Looking at papers and blog posts** published on the topic and see what metrics they report. This can change over time, so try to pick papers from the last couple of years!\n\n### Dataset-specific metrics\n\nSome datasets have specific metrics associated with them -- this is especially in the case of popular benchmarks like [GLUE](https://huggingface.co/metrics/glue) and [SQuAD](https://huggingface.co/metrics/squad).\n\n<Tip warning={true}>\n\ud83d\udca1\nGLUE is actually a collection of different subsets on different tasks, so first you need to choose the one that corresponds to the NLI task, such as mnli, which is described as \u201ccrowdsourced collection of sentence pairs with textual entailment annotations\u201d\n</Tip>"
            }
        ]
    },
    {
        "sample_idx": 128,
        "question": "How many layers does the model have?",
        "answer": "50",
        "rag_answer": "The context information does not provide the number of layers in the model. It only mentions that the model is a LayoutLMv3 model and provides information on how to fine-tune it for token classification tasks. Therefore, it is not possible to determine the number of layers in the model based on the provided context.",
        "rag_score": 1,
        "rag_feedback": "The system's response is completely incorrect, inaccurate, and/or not factual. The system did not provide the number of layers in the model, instead, it stated that it is not possible to determine the number of layers in the model based on the provided context.",
        "rag_context": [
            {
                "score": 0.636910114204191,
                "node_text": "Here are some facts extracted from the provided text:\n\nModel -> Needs -> Question\nModel -> Has -> Input shape\nModel -> Needs -> Context\nModel -> Evaluates on -> Squad\nNielsr/layoutlmv3-finetuned-funsd -> Is -> Model\nModel -> Returns -> Prediction_text\n\n!---\nCopyright 2022 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n-->\n\n# Token classification with LayoutLMv3 (PyTorch version)\n\nThis directory contains a script, `run_funsd_cord.py`, that can be used to fine-tune (or evaluate) LayoutLMv3 on form understanding datasets, such as [FUNSD](https://guillaumejaume.github.io/FUNSD/) and [CORD](https://github.com/clovaai/cord).\n\nThe script `run_funsd_cord.py` leverages the \ud83e\udd17 Datasets library and the Trainer API. You can easily customize it to your needs.\n\n## Fine-tuning on FUNSD\n\nFine-tuning LayoutLMv3 for token classification on [FUNSD](https://guillaumejaume.github.io/FUNSD/) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name funsd \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 1e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-funsd\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd. By specifying the `push_to_hub` flag, the model gets uploaded automatically to the hub (regularly), together with a model card, which includes metrics such as precision, recall and F1. Note that you can easily update the model card, as it's just a README file of the respective repo on the hub.\n\nThere's also the \"Training metrics\" [tab](https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd/tensorboard), which shows Tensorboard logs over the course of training. Pretty neat, huh?\n\n## Fine-tuning on CORD\n\nFine-tuning LayoutLMv3 for token classification on [CORD](https://github.com/clovaai/cord) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name cord \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 5e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-cord\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-cord. Note that a model card gets generated automatically in case you specify the `push_to_hub` flag."
            },
            {
                "score": 0.636910114204191,
                "node_text": "Here are some facts extracted from the provided text:\n\nXla -> Recompile -> Model\nNlp models -> Have -> Variable lengths\nTpu -> Used for -> Neural networks\n\nThis is a really useful trick, so remember it if you need to convert your own code to XLA!\n\n#### XLA Rule #3: XLA will need to recompile your model for every different input shape it sees\n\nThis is the big one. What this means is that if your input shapes are very variable, XLA will have to recompile your model over and over, which will create huge performance problems. This commonly arises in NLP models, where input texts have variable lengths after tokenization. In other modalities, static shapes are more common and this rule is much less of a problem.\n\nHow can you get around rule #3? The key is **padding** - if you pad all your inputs to the same length, and then use an `attention_mask`, you can get the same results as you\u2019d get from variable shapes, but without any XLA issues. However, excessive padding can cause severe slowdown too - if you pad all your samples to the maximum length in the whole dataset, you might end up with batches consisting endless padding tokens, which will waste a lot of compute and memory!\n\nThere isn\u2019t a perfect solution to this problem. However, you can try some tricks. One very useful trick is to **pad batches of samples up to a multiple of a number like 32 or 64 tokens.** This often only increases the number of tokens by a small amount, but it hugely reduces the number of unique input shapes, because every input shape now has to be a multiple of 32 or 64. Fewer unique input shapes means fewer XLA compilations!\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** Our tokenizers and data collators have methods that can help you here. You can use `padding=\"max_length\"` or `padding=\"longest\"` when calling tokenizers to get them to output padded data. Our tokenizers and data collators also have a `pad_to_multiple_of` argument that you can use to reduce the number of unique input shapes you see!\n\n</Tip>\n\n### How do I actually train my model on TPU?\n\nOnce your training is XLA-compatible and (if you\u2019re using TPU Node / Colab) your dataset has been prepared appropriately, running on TPU is surprisingly easy! All you really need to change in your code is to add a few lines to initialize your TPU, and to ensure that your model and dataset are created inside a `TPUStrategy` scope. Take a look at [our TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) to see this in action!\n\n### Summary\n\nThere was a lot in here, so let\u2019s summarize with a quick checklist you can follow when you want to get your model ready for TPU training:\n\n- Make sure your code follows the three rules of XLA\n- Compile your model with `jit_compile=True` on CPU/GPU and confirm that you can train it with XLA\n- Either load your dataset into memory or use a TPU-compatible dataset loading approach (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Migrate your code either to Colab (with accelerator set to \u201cTPU\u201d) or a TPU VM on Google Cloud\n- Add TPU initializer code (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Create your `TPUStrategy` and make sure dataset loading and model creation are inside the `strategy.scope()` (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Don\u2019t forget to take `jit_compile=True` out again when you move to TPU!\n- \ud83d\ude4f\ud83d\ude4f\ud83d\ude4f\ud83e\udd7a\ud83e\udd7a\ud83e\udd7a\n- Call model.fit()\n- You did it!"
            },
            {
                "score": 0.6065795463505077,
                "node_text": "Here are some facts extracted from the provided text:\n\nPods -> Can run -> Hundreds or thousands of replicas\n\n</Tip>\n\nThe second way to access a TPU is via a **TPU VM.** When using a TPU VM, you connect directly to the machine that the TPU is attached to, much like training on a GPU VM. TPU VMs are generally easier to work with, particularly when it comes to your data pipeline. All of the above warnings do not apply to TPU VMs!\n\nThis is an opinionated document, so here\u2019s our opinion: **Avoid using TPU Node if possible.** It is more confusing and more difficult to debug than TPU VMs. It is also likely to be unsupported in future - Google\u2019s latest TPU, TPUv4, can only be accessed as a TPU VM, which suggests that TPU Nodes are increasingly going to become a \u201clegacy\u201d access method. However, we understand that the only free TPU access is on Colab and Kaggle Kernels, which uses TPU Node - so we\u2019ll try to explain how to handle it if you have to! Check the [TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) for code samples that explain this in more detail.\n\n### What sizes of TPU are available?\n\nA single TPU (a v2-8/v3-8/v4-8) runs 8 replicas. TPUs exist in **pods** that can run hundreds or thousands of replicas simultaneously. When you use more than a single TPU but less than a whole pod (for example, a v3-32), your TPU fleet is referred to as a **pod slice.**\n\nWhen you access a free TPU via Colab, you generally get a single v2-8 TPU.\n\n### I keep hearing about this XLA thing. What\u2019s XLA, and how does it relate to TPUs?\n\nXLA is an optimizing compiler, used by both TensorFlow and JAX. In JAX it is the only compiler, whereas in TensorFlow it is optional (but mandatory on TPU!). The easiest way to enable it when training a Keras model is to pass the argument `jit_compile=True` to `model.compile()`. If you don\u2019t get any errors and performance is good, that\u2019s a great sign that you\u2019re ready to move to TPU!\n\nDebugging on TPU is generally a bit harder than on CPU/GPU, so we recommend getting your code running on CPU/GPU with XLA first before trying it on TPU. You don\u2019t have to train for long, of course - just for a few steps to make sure that your model and data pipeline are working like you expect them to.\n\n<Tip>\n\nXLA compiled code is usually faster - so even if you\u2019re not planning to run on TPU, adding `jit_compile=True` can improve your performance. Be sure to note the caveats below about XLA compatibility, though!\n\n</Tip>\n\n<Tip warning={true}>\n\n**Tip born of painful experience:** Although using `jit_compile=True` is a good way to get a speed boost and test if your CPU/GPU code is XLA-compatible, it can actually cause a lot of problems if you leave it in when actually training on TPU. XLA compilation will happen implicitly on TPU, so remember to remove that line before actually running your code on a TPU!\n\n</Tip>\n\n### How do I make my model XLA compatible?\n\nIn many cases, your code is probably XLA-compatible already! However, there are a few things that work in normal TensorFlow that don\u2019t work in XLA. We\u2019ve distilled them into three core rules below:\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** We\u2019ve put a lot of effort into rewriting our TensorFlow models and loss functions to be XLA-compatible. Our models and loss functions generally obey rule #1 and #2 by default, so you can skip over them if you\u2019re using `transformers` models. Don\u2019t forget about these rules when writing your own models and loss functions, though!\n\n</Tip>\n\n#### XLA Rule #1: Your code cannot have \u201cdata-dependent conditionals\u201d\n\nWhat that means is that any `if` statement cannot depend on values inside a `tf.Tensor`. For example, this code block cannot be compiled with XLA!\n\n```python\nif tf.reduce_sum(tensor) > 10:\n    tensor = tensor / 2.0\n```\n\nThis might seem very restrictive at first, but most neural net code doesn\u2019t need to do this."
            }
        ]
    },
    {
        "sample_idx": 129,
        "question": "What is the dropout rate of the model?",
        "answer": "0.2",
        "rag_answer": "There is no information about the dropout rate of the model in the provided context.",
        "rag_score": 1,
        "rag_feedback": "The system's response does not provide the dropout rate of the model, which is the expected answer. Instead, it provides a lengthy text that seems to be unrelated to the question. The response does not contain any information about the dropout rate, making it completely incorrect, inaccurate, and not factual.",
        "rag_context": [
            {
                "score": 0.5773801096667618,
                "node_text": "Here are some facts extracted from the provided text:\n\nNlp models -> Have -> Variable lengths\nXla -> Recompile -> Model\n\nThis is a really useful trick, so remember it if you need to convert your own code to XLA!\n\n#### XLA Rule #3: XLA will need to recompile your model for every different input shape it sees\n\nThis is the big one. What this means is that if your input shapes are very variable, XLA will have to recompile your model over and over, which will create huge performance problems. This commonly arises in NLP models, where input texts have variable lengths after tokenization. In other modalities, static shapes are more common and this rule is much less of a problem.\n\nHow can you get around rule #3? The key is **padding** - if you pad all your inputs to the same length, and then use an `attention_mask`, you can get the same results as you\u2019d get from variable shapes, but without any XLA issues. However, excessive padding can cause severe slowdown too - if you pad all your samples to the maximum length in the whole dataset, you might end up with batches consisting endless padding tokens, which will waste a lot of compute and memory!\n\nThere isn\u2019t a perfect solution to this problem. However, you can try some tricks. One very useful trick is to **pad batches of samples up to a multiple of a number like 32 or 64 tokens.** This often only increases the number of tokens by a small amount, but it hugely reduces the number of unique input shapes, because every input shape now has to be a multiple of 32 or 64. Fewer unique input shapes means fewer XLA compilations!\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** Our tokenizers and data collators have methods that can help you here. You can use `padding=\"max_length\"` or `padding=\"longest\"` when calling tokenizers to get them to output padded data. Our tokenizers and data collators also have a `pad_to_multiple_of` argument that you can use to reduce the number of unique input shapes you see!\n\n</Tip>\n\n### How do I actually train my model on TPU?\n\nOnce your training is XLA-compatible and (if you\u2019re using TPU Node / Colab) your dataset has been prepared appropriately, running on TPU is surprisingly easy! All you really need to change in your code is to add a few lines to initialize your TPU, and to ensure that your model and dataset are created inside a `TPUStrategy` scope. Take a look at [our TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) to see this in action!\n\n### Summary\n\nThere was a lot in here, so let\u2019s summarize with a quick checklist you can follow when you want to get your model ready for TPU training:\n\n- Make sure your code follows the three rules of XLA\n- Compile your model with `jit_compile=True` on CPU/GPU and confirm that you can train it with XLA\n- Either load your dataset into memory or use a TPU-compatible dataset loading approach (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Migrate your code either to Colab (with accelerator set to \u201cTPU\u201d) or a TPU VM on Google Cloud\n- Add TPU initializer code (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Create your `TPUStrategy` and make sure dataset loading and model creation are inside the `strategy.scope()` (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Don\u2019t forget to take `jit_compile=True` out again when you move to TPU!\n- \ud83d\ude4f\ud83d\ude4f\ud83d\ude4f\ud83e\udd7a\ud83e\udd7a\ud83e\udd7a\n- Call model.fit()\n- You did it!"
            },
            {
                "score": 0.5707054336835632,
                "node_text": "Here are some facts extracted from the provided text:\n\nTensorflow models -> Are -> Keras models\n\n!--Copyright 2023 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\nthe License. You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under the License is distributed on\nan \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n\n\u26a0\ufe0f Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be\nrendered properly in your Markdown viewer.\n\n-->\n\n# Training on TPU with TensorFlow\n\n<Tip>\n\nIf you don't need long explanations and just want TPU code samples to get started with, check out [our TPU example notebook!](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb)\n\n</Tip>\n\n### What is a TPU?\n\nA TPU is a **Tensor Processing Unit.** They are hardware designed by Google, which are used to greatly speed up the tensor computations within neural networks, much like GPUs. They can be used for both network training and inference. They are generally accessed through Google\u2019s cloud services, but small TPUs can also be accessed directly for free through Google Colab and Kaggle Kernels.\n\nBecause [all TensorFlow models in \ud83e\udd17 Transformers are Keras models](https://huggingface.co/blog/tensorflow-philosophy), most of the methods in this document are generally applicable to TPU training for any Keras model! However, there are a few points that are specific to the HuggingFace ecosystem (hug-o-system?) of Transformers and Datasets, and we\u2019ll make sure to flag them up when we get to them.\n\n### What kinds of TPU are available?\n\nNew users are often very confused by the range of TPUs, and the different ways to access them. The first key distinction to understand is the difference between **TPU Nodes** and **TPU VMs.**\n\nWhen you use a **TPU Node**, you are effectively indirectly accessing a remote TPU. You will need a separate VM, which will initialize your network and data pipeline and then forward them to the remote node. When you use a TPU on Google Colab, you are accessing it in the **TPU Node** style.\n\nUsing TPU Nodes can have some quite unexpected behaviour for people who aren\u2019t used to them! In particular, because the TPU is located on a physically different system to the machine you\u2019re running your Python code on, your data cannot be local to your machine - any data pipeline that loads from your machine\u2019s internal storage will totally fail! Instead, data must be stored in Google Cloud Storage where your data pipeline can still access it, even when the pipeline is running on the remote TPU node.\n\n<Tip>\n\nIf you can fit all your data in memory as `np.ndarray` or `tf.Tensor`, then you can `fit()` on that data even when using Colab or a TPU Node, without needing to upload it to Google Cloud Storage.\n\n</Tip>\n\n<Tip>\n\n**\ud83e\udd17Specific Hugging Face Tip\ud83e\udd17:** The methods `Dataset.to_tf_dataset()` and its higher-level wrapper `model.prepare_tf_dataset()` , which you will see throughout our TF code examples, will both fail on a TPU Node. The reason for this is that even though they create a `tf.data.Dataset` it is not a \u201cpure\u201d `tf.data` pipeline and uses `tf.numpy_function` or `Dataset.from_generator()` to stream data from the underlying HuggingFace `Dataset`. This HuggingFace `Dataset` is backed by data that is on a local disc and which the remote TPU Node will not be able to read.\n\n</Tip>\n\nThe second way to access a TPU is via a **TPU VM.** When using a TPU VM, you connect directly to the machine that the TPU is attached to, much like training on a GPU VM. TPU VMs are generally easier to work with, particularly when it comes to your data pipeline. All of the above warnings do not apply to TPU VMs!\n\nThis is an opinionated document, so here\u2019s our opinion: **Avoid using TPU Node if possible.** It is more confusing and more difficult to debug than TPU VMs. It is also likely to be unsupported in future - Google\u2019s latest TPU, TPUv4, can only be accessed as a TPU VM, which suggests that TPU Nodes are increasingly going to become a \u201clegacy\u201d access method."
            },
            {
                "score": 0.5622467688717355,
                "node_text": "Here are some facts extracted from the provided text:\n\nModel -> Needs -> Question\nModel -> Has -> Input shape\nModel -> Needs -> Context\nModel -> Evaluates on -> Squad\nNielsr/layoutlmv3-finetuned-funsd -> Is -> Model\nModel -> Returns -> Prediction_text\n\n!---\nCopyright 2022 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n-->\n\n# Token classification with LayoutLMv3 (PyTorch version)\n\nThis directory contains a script, `run_funsd_cord.py`, that can be used to fine-tune (or evaluate) LayoutLMv3 on form understanding datasets, such as [FUNSD](https://guillaumejaume.github.io/FUNSD/) and [CORD](https://github.com/clovaai/cord).\n\nThe script `run_funsd_cord.py` leverages the \ud83e\udd17 Datasets library and the Trainer API. You can easily customize it to your needs.\n\n## Fine-tuning on FUNSD\n\nFine-tuning LayoutLMv3 for token classification on [FUNSD](https://guillaumejaume.github.io/FUNSD/) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name funsd \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 1e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-funsd\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd. By specifying the `push_to_hub` flag, the model gets uploaded automatically to the hub (regularly), together with a model card, which includes metrics such as precision, recall and F1. Note that you can easily update the model card, as it's just a README file of the respective repo on the hub.\n\nThere's also the \"Training metrics\" [tab](https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd/tensorboard), which shows Tensorboard logs over the course of training. Pretty neat, huh?\n\n## Fine-tuning on CORD\n\nFine-tuning LayoutLMv3 for token classification on [CORD](https://github.com/clovaai/cord) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name cord \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 5e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-cord\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-cord. Note that a model card gets generated automatically in case you specify the `push_to_hub` flag."
            }
        ]
    },
    {
        "sample_idx": 130,
        "question": "What is the momentum of the model?",
        "answer": "0.9",
        "rag_answer": "There is no mention of momentum in the provided context information. The context discusses Gradio, Hugging Face models, XLA, TPU, and model training, but it does not mention momentum. Therefore, it is not possible to determine the momentum of the model based on the provided information.",
        "rag_score": 1,
        "rag_feedback": "The system's response is completely incorrect, inaccurate, and/or not factual. The expected answer is a specific value (0.9), but the system's response is a lengthy text that does not provide the answer and instead discusses unrelated topics such as Gradio, Hugging Face models, XLA, TPU, and model training.",
        "rag_context": [
            {
                "score": 0.5625623571616376,
                "node_text": "Here are some facts extracted from the provided text:\n\nGradio -> Supports -> Hugging face models\n\nGradio Demo: blocks_random_slider\n\n\n```\n!pip install -q gradio \n```\n\n\n```\n\nimport gradio as gr\n\n\ndef func(slider_1, slider_2):\n    return slider_1 * 5 + slider_2\n\n\nwith gr.Blocks() as demo:\n    slider = gr.Slider(minimum=-10.2, maximum=15, label=\"Random Slider (Static)\", randomize=True)\n    slider_1 = gr.Slider(minimum=100, maximum=200, label=\"Random Slider (Input 1)\", randomize=True)\n    slider_2 = gr.Slider(minimum=10, maximum=23.2, label=\"Random Slider (Input 2)\", randomize=True)\n    slider_3 = gr.Slider(value=3, label=\"Non random slider\")\n    btn = gr.Button(\"Run\")\n    btn.click(func, inputs=[slider_1, slider_2], outputs=gr.Number())\n\nif __name__ == \"__main__\":\n    demo.launch()\n\n```"
            },
            {
                "score": 0.5555841263899685,
                "node_text": "Here are some facts extracted from the provided text:\n\nNlp models -> Have -> Variable lengths\nXla -> Recompile -> Model\n\nThis is a really useful trick, so remember it if you need to convert your own code to XLA!\n\n#### XLA Rule #3: XLA will need to recompile your model for every different input shape it sees\n\nThis is the big one. What this means is that if your input shapes are very variable, XLA will have to recompile your model over and over, which will create huge performance problems. This commonly arises in NLP models, where input texts have variable lengths after tokenization. In other modalities, static shapes are more common and this rule is much less of a problem.\n\nHow can you get around rule #3? The key is **padding** - if you pad all your inputs to the same length, and then use an `attention_mask`, you can get the same results as you\u2019d get from variable shapes, but without any XLA issues. However, excessive padding can cause severe slowdown too - if you pad all your samples to the maximum length in the whole dataset, you might end up with batches consisting endless padding tokens, which will waste a lot of compute and memory!\n\nThere isn\u2019t a perfect solution to this problem. However, you can try some tricks. One very useful trick is to **pad batches of samples up to a multiple of a number like 32 or 64 tokens.** This often only increases the number of tokens by a small amount, but it hugely reduces the number of unique input shapes, because every input shape now has to be a multiple of 32 or 64. Fewer unique input shapes means fewer XLA compilations!\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** Our tokenizers and data collators have methods that can help you here. You can use `padding=\"max_length\"` or `padding=\"longest\"` when calling tokenizers to get them to output padded data. Our tokenizers and data collators also have a `pad_to_multiple_of` argument that you can use to reduce the number of unique input shapes you see!\n\n</Tip>\n\n### How do I actually train my model on TPU?\n\nOnce your training is XLA-compatible and (if you\u2019re using TPU Node / Colab) your dataset has been prepared appropriately, running on TPU is surprisingly easy! All you really need to change in your code is to add a few lines to initialize your TPU, and to ensure that your model and dataset are created inside a `TPUStrategy` scope. Take a look at [our TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) to see this in action!\n\n### Summary\n\nThere was a lot in here, so let\u2019s summarize with a quick checklist you can follow when you want to get your model ready for TPU training:\n\n- Make sure your code follows the three rules of XLA\n- Compile your model with `jit_compile=True` on CPU/GPU and confirm that you can train it with XLA\n- Either load your dataset into memory or use a TPU-compatible dataset loading approach (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Migrate your code either to Colab (with accelerator set to \u201cTPU\u201d) or a TPU VM on Google Cloud\n- Add TPU initializer code (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Create your `TPUStrategy` and make sure dataset loading and model creation are inside the `strategy.scope()` (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Don\u2019t forget to take `jit_compile=True` out again when you move to TPU!\n- \ud83d\ude4f\ud83d\ude4f\ud83d\ude4f\ud83e\udd7a\ud83e\udd7a\ud83e\udd7a\n- Call model.fit()\n- You did it!"
            },
            {
                "score": 0.5450873030452057,
                "node_text": "Here are some facts extracted from the provided text:\n\nModel -> Needs -> Question\nModel -> Has -> Input shape\nModel -> Needs -> Context\nModel -> Evaluates on -> Squad\nNielsr/layoutlmv3-finetuned-funsd -> Is -> Model\nModel -> Returns -> Prediction_text\n\n!---\nCopyright 2022 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n-->\n\n# Token classification with LayoutLMv3 (PyTorch version)\n\nThis directory contains a script, `run_funsd_cord.py`, that can be used to fine-tune (or evaluate) LayoutLMv3 on form understanding datasets, such as [FUNSD](https://guillaumejaume.github.io/FUNSD/) and [CORD](https://github.com/clovaai/cord).\n\nThe script `run_funsd_cord.py` leverages the \ud83e\udd17 Datasets library and the Trainer API. You can easily customize it to your needs.\n\n## Fine-tuning on FUNSD\n\nFine-tuning LayoutLMv3 for token classification on [FUNSD](https://guillaumejaume.github.io/FUNSD/) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name funsd \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 1e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-funsd\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd. By specifying the `push_to_hub` flag, the model gets uploaded automatically to the hub (regularly), together with a model card, which includes metrics such as precision, recall and F1. Note that you can easily update the model card, as it's just a README file of the respective repo on the hub.\n\nThere's also the \"Training metrics\" [tab](https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd/tensorboard), which shows Tensorboard logs over the course of training. Pretty neat, huh?\n\n## Fine-tuning on CORD\n\nFine-tuning LayoutLMv3 for token classification on [CORD](https://github.com/clovaai/cord) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name cord \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 5e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-cord\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-cord. Note that a model card gets generated automatically in case you specify the `push_to_hub` flag."
            },
            {
                "score": 0.5277608519860867,
                "node_text": "Here are some facts extracted from the provided text:\n\nTensorflow models -> Are -> Keras models\n\n!--Copyright 2023 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\nthe License. You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under the License is distributed on\nan \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n\n\u26a0\ufe0f Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be\nrendered properly in your Markdown viewer.\n\n-->\n\n# Training on TPU with TensorFlow\n\n<Tip>\n\nIf you don't need long explanations and just want TPU code samples to get started with, check out [our TPU example notebook!](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb)\n\n</Tip>\n\n### What is a TPU?\n\nA TPU is a **Tensor Processing Unit.** They are hardware designed by Google, which are used to greatly speed up the tensor computations within neural networks, much like GPUs. They can be used for both network training and inference. They are generally accessed through Google\u2019s cloud services, but small TPUs can also be accessed directly for free through Google Colab and Kaggle Kernels.\n\nBecause [all TensorFlow models in \ud83e\udd17 Transformers are Keras models](https://huggingface.co/blog/tensorflow-philosophy), most of the methods in this document are generally applicable to TPU training for any Keras model! However, there are a few points that are specific to the HuggingFace ecosystem (hug-o-system?) of Transformers and Datasets, and we\u2019ll make sure to flag them up when we get to them.\n\n### What kinds of TPU are available?\n\nNew users are often very confused by the range of TPUs, and the different ways to access them. The first key distinction to understand is the difference between **TPU Nodes** and **TPU VMs.**\n\nWhen you use a **TPU Node**, you are effectively indirectly accessing a remote TPU. You will need a separate VM, which will initialize your network and data pipeline and then forward them to the remote node. When you use a TPU on Google Colab, you are accessing it in the **TPU Node** style.\n\nUsing TPU Nodes can have some quite unexpected behaviour for people who aren\u2019t used to them! In particular, because the TPU is located on a physically different system to the machine you\u2019re running your Python code on, your data cannot be local to your machine - any data pipeline that loads from your machine\u2019s internal storage will totally fail! Instead, data must be stored in Google Cloud Storage where your data pipeline can still access it, even when the pipeline is running on the remote TPU node.\n\n<Tip>\n\nIf you can fit all your data in memory as `np.ndarray` or `tf.Tensor`, then you can `fit()` on that data even when using Colab or a TPU Node, without needing to upload it to Google Cloud Storage.\n\n</Tip>\n\n<Tip>\n\n**\ud83e\udd17Specific Hugging Face Tip\ud83e\udd17:** The methods `Dataset.to_tf_dataset()` and its higher-level wrapper `model.prepare_tf_dataset()` , which you will see throughout our TF code examples, will both fail on a TPU Node. The reason for this is that even though they create a `tf.data.Dataset` it is not a \u201cpure\u201d `tf.data` pipeline and uses `tf.numpy_function` or `Dataset.from_generator()` to stream data from the underlying HuggingFace `Dataset`. This HuggingFace `Dataset` is backed by data that is on a local disc and which the remote TPU Node will not be able to read.\n\n</Tip>\n\nThe second way to access a TPU is via a **TPU VM.** When using a TPU VM, you connect directly to the machine that the TPU is attached to, much like training on a GPU VM. TPU VMs are generally easier to work with, particularly when it comes to your data pipeline. All of the above warnings do not apply to TPU VMs!\n\nThis is an opinionated document, so here\u2019s our opinion: **Avoid using TPU Node if possible.** It is more confusing and more difficult to debug than TPU VMs. It is also likely to be unsupported in future - Google\u2019s latest TPU, TPUv4, can only be accessed as a TPU VM, which suggests that TPU Nodes are increasingly going to become a \u201clegacy\u201d access method."
            }
        ]
    },
    {
        "sample_idx": 131,
        "question": "What is the batch size of the model?",
        "answer": "1024",
        "rag_answer": "The batch size of the model is 16.",
        "rag_score": 1,
        "rag_feedback": "The system's response is incorrect. The expected answer is 1024, but the system's response is 16, which is mentioned in the context as the max_batch_size in a Gradio example, not the batch size of the model.",
        "rag_context": [
            {
                "score": 0.5925639999764704,
                "node_text": "Here are some facts extracted from the provided text:\n\nBatch functions -> Accept -> Input lists\nBatch functions -> Return -> Prediction lists\nTrim_words -> Is -> Batch function\n\ntqdm` \u81ea\u52a8\u62a5\u544a\u8fdb\u5ea6\u66f4\u65b0\uff0c\u8bf7\u5c06\u9ed8\u8ba4\u53c2\u6570\u8bbe\u7f6e\u4e3a `gr.Progress(track_tqdm=True)`\uff01\n\n## \u6279\u5904\u7406\u51fd\u6570 (Batch Functions)\n\nGradio \u652f\u6301\u4f20\u9012*\u6279\u5904\u7406*\u51fd\u6570\u3002\u6279\u5904\u7406\u51fd\u6570\u53ea\u662f\u63a5\u53d7\u8f93\u5165\u5217\u8868\u5e76\u8fd4\u56de\u9884\u6d4b\u5217\u8868\u7684\u51fd\u6570\u3002\n\n\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\u6279\u5904\u7406\u51fd\u6570\uff0c\u5b83\u63a5\u53d7\u4e24\u4e2a\u8f93\u5165\u5217\u8868\uff08\u4e00\u4e2a\u5355\u8bcd\u5217\u8868\u548c\u4e00\u4e2a\u6574\u6570\u5217\u8868\uff09\uff0c\u5e76\u8fd4\u56de\u4fee\u526a\u8fc7\u7684\u5355\u8bcd\u5217\u8868\u4f5c\u4e3a\u8f93\u51fa\uff1a\n\n```python\nimport time\n\ndef trim_words(words, lens):\n    trimmed_words = []\n    time.sleep(5)\n    for w, l in zip(words, lens):\n        trimmed_words.append(w[:int(l)])\n    return [trimmed_words]\n    for w, l in zip(words, lens):\n```\n\n\u4f7f\u7528\u6279\u5904\u7406\u51fd\u6570\u7684\u4f18\u70b9\u662f\uff0c\u5982\u679c\u542f\u7528\u4e86\u961f\u5217\uff0cGradio \u670d\u52a1\u5668\u53ef\u4ee5\u81ea\u52a8*\u6279\u5904\u7406*\u4f20\u5165\u7684\u8bf7\u6c42\u5e76\u5e76\u884c\u5904\u7406\u5b83\u4eec\uff0c\u4ece\u800c\u53ef\u80fd\u52a0\u5feb\u6f14\u793a\u901f\u5ea6\u3002\u4ee5\u4e0b\u662f Gradio \u4ee3\u7801\u7684\u793a\u4f8b\uff08\u8bf7\u6ce8\u610f `batch=True` \u548c `max_batch_size=16` - \u8fd9\u4e24\u4e2a\u53c2\u6570\u90fd\u53ef\u4ee5\u4f20\u9012\u7ed9\u4e8b\u4ef6\u89e6\u53d1\u5668\u6216 `Interface` \u7c7b\uff09\n\nwith `Interface`\uff1a\n\n```python\ndemo = gr.Interface(trim_words, [\"textbox\", \"number\"], [\"output\"],\n                    batch=True, max_batch_size=16)\ndemo.queue()\ndemo.launch()\n```\n\nwith `Blocks`\uff1a\n\n```python\nimport gradio as gr\n\nwith gr.Blocks() as demo:\n    with gr.Row():\n        word = gr.Textbox(label=\"word\")\n        leng = gr.Number(label=\"leng\")\n        output = gr.Textbox(label=\"Output\")\n    with gr.Row():\n        run = gr.Button()\n\n    event = run.click(trim_words, [word, leng], output, batch=True, max_batch_size=16)\n\ndemo.queue()\ndemo.launch()\n```\n\n\u5728\u4e0a\u9762\u7684\u793a\u4f8b\u4e2d\uff0c\u53ef\u4ee5\u5e76\u884c\u5904\u7406 16 \u4e2a\u8bf7\u6c42\uff08\u603b\u63a8\u7406\u65f6\u95f4\u4e3a 5 \u79d2\uff09\uff0c\u800c\u4e0d\u662f\u5206\u522b\u5904\u7406\u6bcf\u4e2a\u8bf7\u6c42\uff08\u603b\u63a8\u7406\u65f6\u95f4\u4e3a 80 \u79d2\uff09\u3002\u8bb8\u591a Hugging Face \u7684 `transformers` \u548c `diffusers` \u6a21\u578b\u5728 Gradio \u7684\u6279\u5904\u7406\u6a21\u5f0f\u4e0b\u81ea\u7136\u5de5\u4f5c\uff1a\u8fd9\u662f[\u4f7f\u7528\u6279\u5904\u7406\u751f\u6210\u56fe\u50cf\u7684\u793a\u4f8b\u6f14\u793a](https://github.com/gradio-app/gradio/blob/main/demo/diffusers_with_batching/run.py)\n\n\u6ce8\u610f\uff1a\u4f7f\u7528 Gradio \u7684\u6279\u5904\u7406\u51fd\u6570 **requires** \u5728\u5e95\u5c42 Interface \u6216 Blocks \u4e2d\u542f\u7528\u961f\u5217\uff08\u8bf7\u53c2\u9605\u4e0a\u9762\u7684\u961f\u5217\u90e8\u5206\uff09\u3002\n\n## Gradio \u7b14\u8bb0\u672c (Colab Notebooks)\n\nGradio \u53ef\u4ee5\u5728\u4efb\u4f55\u8fd0\u884c Python \u7684\u5730\u65b9\u8fd0\u884c\uff0c\u5305\u62ec\u672c\u5730 Jupyter \u7b14\u8bb0\u672c\u548c\u534f\u4f5c\u7b14\u8bb0\u672c\uff0c\u5982[Google Colab](https://colab.research.google.com/)\u3002\u5bf9\u4e8e\u672c\u5730 Jupyter \u7b14\u8bb0\u672c\u548c Google Colab \u7b14\u8bb0\u672c\uff0cGradio \u5728\u672c\u5730\u670d\u52a1\u5668\u4e0a\u8fd0\u884c\uff0c\u60a8\u53ef\u4ee5\u5728\u6d4f\u89c8\u5668\u4e2d\u4e0e\u4e4b\u4ea4\u4e92\u3002\uff08\u6ce8\u610f\uff1a\u5bf9\u4e8e Google Colab\uff0c\u8fd9\u662f\u901a\u8fc7[\u670d\u52a1\u5de5\u4f5c\u5668\u96a7\u9053](https://github.com/tensorflow/tensorboard/blob/master/docs/design/colab_integration.md)\u5b9e\u73b0\u7684\uff0c\u60a8\u7684\u6d4f\u89c8\u5668\u9700\u8981\u542f\u7528 cookies\u3002\uff09\u5bf9\u4e8e\u5176\u4ed6\u8fdc\u7a0b\u7b14\u8bb0\u672c\uff0cGradio \u4e5f\u5c06\u5728\u670d\u52a1\u5668\u4e0a\u8fd0\u884c\uff0c\u4f46\u60a8\u9700\u8981\u4f7f\u7528[SSH \u96a7\u9053](https://coderwall.com/p/ohk6cg/remote-access-to-ipython-notebooks-via-ssh)\u5728\u672c\u5730\u6d4f\u89c8\u5668\u4e2d\u67e5\u770b\u5e94\u7528\u7a0b\u5e8f\u3002\u901a\u5e38\uff0c\u66f4\u7b80\u5355\u7684\u9009\u62e9\u662f\u4f7f\u7528 Gradio \u5185\u7f6e\u7684\u516c\u5171\u94fe\u63a5\uff0c[\u5728\u4e0b\u4e00\u7bc7\u6307\u5357\u4e2d\u8ba8\u8bba](/sharing-your-app/#sharing-demos)\u3002"
            },
            {
                "score": 0.5925639999764704,
                "node_text": "Here are some facts extracted from the provided text:\n\nGradio -> Supports -> Batch functions\n\nGradio Demo: blocks_random_slider\n\n\n```\n!pip install -q gradio \n```\n\n\n```\n\nimport gradio as gr\n\n\ndef func(slider_1, slider_2):\n    return slider_1 * 5 + slider_2\n\n\nwith gr.Blocks() as demo:\n    slider = gr.Slider(minimum=-10.2, maximum=15, label=\"Random Slider (Static)\", randomize=True)\n    slider_1 = gr.Slider(minimum=100, maximum=200, label=\"Random Slider (Input 1)\", randomize=True)\n    slider_2 = gr.Slider(minimum=10, maximum=23.2, label=\"Random Slider (Input 2)\", randomize=True)\n    slider_3 = gr.Slider(value=3, label=\"Non random slider\")\n    btn = gr.Button(\"Run\")\n    btn.click(func, inputs=[slider_1, slider_2], outputs=gr.Number())\n\nif __name__ == \"__main__\":\n    demo.launch()\n\n```"
            },
            {
                "score": 0.5791250985168698,
                "node_text": "Here are some facts extracted from the provided text:\n\nTensorflow models -> Are -> Keras models\n\n!--Copyright 2023 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\nthe License. You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under the License is distributed on\nan \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n\n\u26a0\ufe0f Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be\nrendered properly in your Markdown viewer.\n\n-->\n\n# Training on TPU with TensorFlow\n\n<Tip>\n\nIf you don't need long explanations and just want TPU code samples to get started with, check out [our TPU example notebook!](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb)\n\n</Tip>\n\n### What is a TPU?\n\nA TPU is a **Tensor Processing Unit.** They are hardware designed by Google, which are used to greatly speed up the tensor computations within neural networks, much like GPUs. They can be used for both network training and inference. They are generally accessed through Google\u2019s cloud services, but small TPUs can also be accessed directly for free through Google Colab and Kaggle Kernels.\n\nBecause [all TensorFlow models in \ud83e\udd17 Transformers are Keras models](https://huggingface.co/blog/tensorflow-philosophy), most of the methods in this document are generally applicable to TPU training for any Keras model! However, there are a few points that are specific to the HuggingFace ecosystem (hug-o-system?) of Transformers and Datasets, and we\u2019ll make sure to flag them up when we get to them.\n\n### What kinds of TPU are available?\n\nNew users are often very confused by the range of TPUs, and the different ways to access them. The first key distinction to understand is the difference between **TPU Nodes** and **TPU VMs.**\n\nWhen you use a **TPU Node**, you are effectively indirectly accessing a remote TPU. You will need a separate VM, which will initialize your network and data pipeline and then forward them to the remote node. When you use a TPU on Google Colab, you are accessing it in the **TPU Node** style.\n\nUsing TPU Nodes can have some quite unexpected behaviour for people who aren\u2019t used to them! In particular, because the TPU is located on a physically different system to the machine you\u2019re running your Python code on, your data cannot be local to your machine - any data pipeline that loads from your machine\u2019s internal storage will totally fail! Instead, data must be stored in Google Cloud Storage where your data pipeline can still access it, even when the pipeline is running on the remote TPU node.\n\n<Tip>\n\nIf you can fit all your data in memory as `np.ndarray` or `tf.Tensor`, then you can `fit()` on that data even when using Colab or a TPU Node, without needing to upload it to Google Cloud Storage.\n\n</Tip>\n\n<Tip>\n\n**\ud83e\udd17Specific Hugging Face Tip\ud83e\udd17:** The methods `Dataset.to_tf_dataset()` and its higher-level wrapper `model.prepare_tf_dataset()` , which you will see throughout our TF code examples, will both fail on a TPU Node. The reason for this is that even though they create a `tf.data.Dataset` it is not a \u201cpure\u201d `tf.data` pipeline and uses `tf.numpy_function` or `Dataset.from_generator()` to stream data from the underlying HuggingFace `Dataset`. This HuggingFace `Dataset` is backed by data that is on a local disc and which the remote TPU Node will not be able to read.\n\n</Tip>\n\nThe second way to access a TPU is via a **TPU VM.** When using a TPU VM, you connect directly to the machine that the TPU is attached to, much like training on a GPU VM. TPU VMs are generally easier to work with, particularly when it comes to your data pipeline. All of the above warnings do not apply to TPU VMs!\n\nThis is an opinionated document, so here\u2019s our opinion: **Avoid using TPU Node if possible.** It is more confusing and more difficult to debug than TPU VMs. It is also likely to be unsupported in future - Google\u2019s latest TPU, TPUv4, can only be accessed as a TPU VM, which suggests that TPU Nodes are increasingly going to become a \u201clegacy\u201d access method."
            }
        ]
    },
    {
        "sample_idx": 132,
        "question": "What is the image size of the model?",
        "answer": "224",
        "rag_answer": "The image size of the model is not explicitly mentioned in the context information. However, in the Gradio component section, it is mentioned that the image component can be controlled by preprocessing parameters, and an example is given where the image is reshaped to (100, 100) regardless of its original size.",
        "rag_score": 2,
        "rag_feedback": "The system's response is mostly incorrect, inaccurate, and/or not factual. It does not provide a direct answer to the question about the image size of the model, instead, it provides information about how the image component can be controlled by preprocessing parameters and gives an example of reshaping an image to (100, 100).",
        "rag_context": [
            {
                "score": 0.6269808174077881,
                "node_text": "Here are some facts extracted from the provided text:\n\nGradio -> Supports -> Hugging face models\n\nGradio Demo: blocks_random_slider\n\n\n```\n!pip install -q gradio \n```\n\n\n```\n\nimport gradio as gr\n\n\ndef func(slider_1, slider_2):\n    return slider_1 * 5 + slider_2\n\n\nwith gr.Blocks() as demo:\n    slider = gr.Slider(minimum=-10.2, maximum=15, label=\"Random Slider (Static)\", randomize=True)\n    slider_1 = gr.Slider(minimum=100, maximum=200, label=\"Random Slider (Input 1)\", randomize=True)\n    slider_2 = gr.Slider(minimum=10, maximum=23.2, label=\"Random Slider (Input 2)\", randomize=True)\n    slider_3 = gr.Slider(value=3, label=\"Non random slider\")\n    btn = gr.Button(\"Run\")\n    btn.click(func, inputs=[slider_1, slider_2], outputs=gr.Number())\n\nif __name__ == \"__main__\":\n    demo.launch()\n\n```"
            },
            {
                "score": 0.626934221729562,
                "node_text": "Here are some facts extracted from the provided text:\n\nModel -> Needs -> Question\nModel -> Has -> Input shape\nModel -> Needs -> Context\nModel -> Evaluates on -> Squad\nNielsr/layoutlmv3-finetuned-funsd -> Is -> Model\nModel -> Returns -> Prediction_text\nMicrosoft/layoutlmv3-base -> Is -> Model name or path\n\n!---\nCopyright 2022 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n-->\n\n# Token classification with LayoutLMv3 (PyTorch version)\n\nThis directory contains a script, `run_funsd_cord.py`, that can be used to fine-tune (or evaluate) LayoutLMv3 on form understanding datasets, such as [FUNSD](https://guillaumejaume.github.io/FUNSD/) and [CORD](https://github.com/clovaai/cord).\n\nThe script `run_funsd_cord.py` leverages the \ud83e\udd17 Datasets library and the Trainer API. You can easily customize it to your needs.\n\n## Fine-tuning on FUNSD\n\nFine-tuning LayoutLMv3 for token classification on [FUNSD](https://guillaumejaume.github.io/FUNSD/) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name funsd \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 1e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-funsd\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd. By specifying the `push_to_hub` flag, the model gets uploaded automatically to the hub (regularly), together with a model card, which includes metrics such as precision, recall and F1. Note that you can easily update the model card, as it's just a README file of the respective repo on the hub.\n\nThere's also the \"Training metrics\" [tab](https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd/tensorboard), which shows Tensorboard logs over the course of training. Pretty neat, huh?\n\n## Fine-tuning on CORD\n\nFine-tuning LayoutLMv3 for token classification on [CORD](https://github.com/clovaai/cord) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name cord \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 5e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-cord\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-cord. Note that a model card gets generated automatically in case you specify the `push_to_hub` flag."
            },
            {
                "score": 0.626934221729562,
                "node_text": "Here are some facts extracted from the provided text:\n\nXla -> Recompile -> Model\n\nThis is a really useful trick, so remember it if you need to convert your own code to XLA!\n\n#### XLA Rule #3: XLA will need to recompile your model for every different input shape it sees\n\nThis is the big one. What this means is that if your input shapes are very variable, XLA will have to recompile your model over and over, which will create huge performance problems. This commonly arises in NLP models, where input texts have variable lengths after tokenization. In other modalities, static shapes are more common and this rule is much less of a problem.\n\nHow can you get around rule #3? The key is **padding** - if you pad all your inputs to the same length, and then use an `attention_mask`, you can get the same results as you\u2019d get from variable shapes, but without any XLA issues. However, excessive padding can cause severe slowdown too - if you pad all your samples to the maximum length in the whole dataset, you might end up with batches consisting endless padding tokens, which will waste a lot of compute and memory!\n\nThere isn\u2019t a perfect solution to this problem. However, you can try some tricks. One very useful trick is to **pad batches of samples up to a multiple of a number like 32 or 64 tokens.** This often only increases the number of tokens by a small amount, but it hugely reduces the number of unique input shapes, because every input shape now has to be a multiple of 32 or 64. Fewer unique input shapes means fewer XLA compilations!\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** Our tokenizers and data collators have methods that can help you here. You can use `padding=\"max_length\"` or `padding=\"longest\"` when calling tokenizers to get them to output padded data. Our tokenizers and data collators also have a `pad_to_multiple_of` argument that you can use to reduce the number of unique input shapes you see!\n\n</Tip>\n\n### How do I actually train my model on TPU?\n\nOnce your training is XLA-compatible and (if you\u2019re using TPU Node / Colab) your dataset has been prepared appropriately, running on TPU is surprisingly easy! All you really need to change in your code is to add a few lines to initialize your TPU, and to ensure that your model and dataset are created inside a `TPUStrategy` scope. Take a look at [our TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) to see this in action!\n\n### Summary\n\nThere was a lot in here, so let\u2019s summarize with a quick checklist you can follow when you want to get your model ready for TPU training:\n\n- Make sure your code follows the three rules of XLA\n- Compile your model with `jit_compile=True` on CPU/GPU and confirm that you can train it with XLA\n- Either load your dataset into memory or use a TPU-compatible dataset loading approach (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Migrate your code either to Colab (with accelerator set to \u201cTPU\u201d) or a TPU VM on Google Cloud\n- Add TPU initializer code (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Create your `TPUStrategy` and make sure dataset loading and model creation are inside the `strategy.scope()` (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Don\u2019t forget to take `jit_compile=True` out again when you move to TPU!\n- \ud83d\ude4f\ud83d\ude4f\ud83d\ude4f\ud83e\udd7a\ud83e\udd7a\ud83e\udd7a\n- Call model.fit()\n- You did it!"
            },
            {
                "score": 0.589716932679011,
                "node_text": "Here are some facts extracted from the provided text:\n\nImage component -> Can be controlled -> Preprocessing parameters\n\n[annotated](/assets/img/dataflow.svg)\n\n\u5982\u60a8\u6240\u89c1\uff0cGradio \u5305\u62ec\u53ef\u4ee5\u5904\u7406\u5404\u79cd\u4e0d\u540c\u6570\u636e\u7c7b\u578b\u7684\u7ec4\u4ef6\uff0c\u4f8b\u5982\u56fe\u50cf\u3001\u97f3\u9891\u548c\u89c6\u9891\u3002\u5927\u591a\u6570\u7ec4\u4ef6\u90fd\u53ef\u4ee5\u7528\u4f5c\u8f93\u5165\u6216\u8f93\u51fa\u3002\n\n\u5f53\u7ec4\u4ef6\u7528\u4f5c\u8f93\u5165\u65f6\uff0cGradio \u81ea\u52a8\u5904\u7406*\u9884\u5904\u7406*\uff0c\u5c06\u6570\u636e\u4ece\u7528\u6237\u6d4f\u89c8\u5668\u53d1\u9001\u7684\u7c7b\u578b\uff08\u4f8b\u5982\u7f51\u7edc\u6444\u50cf\u5934\u5feb\u7167\u7684 base64 \u8868\u793a\uff09\u8f6c\u6362\u4e3a\u60a8\u7684\u51fd\u6570\u53ef\u4ee5\u63a5\u53d7\u7684\u5f62\u5f0f\uff08\u4f8b\u5982 `numpy` \u6570\u7ec4\uff09\u3002\n\n\u540c\u6837\uff0c\u5f53\u7ec4\u4ef6\u7528\u4f5c\u8f93\u51fa\u65f6\uff0cGradio \u81ea\u52a8\u5904\u7406*\u540e\u5904\u7406*\uff0c\u5c06\u6570\u636e\u4ece\u51fd\u6570\u8fd4\u56de\u7684\u5f62\u5f0f\uff08\u4f8b\u5982\u56fe\u50cf\u8def\u5f84\u5217\u8868\uff09\u8f6c\u6362\u4e3a\u53ef\u4ee5\u5728\u7528\u6237\u6d4f\u89c8\u5668\u4e2d\u663e\u793a\u7684\u5f62\u5f0f\uff08\u4f8b\u5982\u4ee5 base64 \u683c\u5f0f\u663e\u793a\u56fe\u50cf\u7684 `Gallery`\uff09\u3002\n\n\u60a8\u53ef\u4ee5\u4f7f\u7528\u6784\u5efa\u56fe\u50cf\u7ec4\u4ef6\u65f6\u7684\u53c2\u6570\u63a7\u5236*\u9884\u5904\u7406*\u3002\u4f8b\u5982\uff0c\u5982\u679c\u60a8\u4f7f\u7528\u4ee5\u4e0b\u53c2\u6570\u5b9e\u4f8b\u5316 `Image` \u7ec4\u4ef6\uff0c\u5b83\u5c06\u5c06\u56fe\u50cf\u8f6c\u6362\u4e3a `PIL` \u7c7b\u578b\uff0c\u5e76\u5c06\u5176\u91cd\u5851\u4e3a`(100, 100)`\uff0c\u800c\u4e0d\u7ba1\u63d0\u4ea4\u65f6\u7684\u539f\u59cb\u5927\u5c0f\u5982\u4f55\uff1a\n\n```py\nimg = gr.Image(shape=(100, 100), type=\"pil\")\n```\n\n\u76f8\u53cd\uff0c\u8fd9\u91cc\u6211\u4eec\u4fdd\u7559\u56fe\u50cf\u7684\u539f\u59cb\u5927\u5c0f\uff0c\u4f46\u5728\u5c06\u5176\u8f6c\u6362\u4e3a numpy \u6570\u7ec4\u4e4b\u524d\u53cd\u8f6c\u989c\u8272\uff1a\n\n```py\nimg = gr.Image(invert_colors=True, type=\"numpy\")\n```\n\n\u540e\u5904\u7406\u8981\u5bb9\u6613\u5f97\u591a\uff01Gradio \u81ea\u52a8\u8bc6\u522b\u8fd4\u56de\u6570\u636e\u7684\u683c\u5f0f\uff08\u4f8b\u5982 `Image` \u662f `numpy` \u6570\u7ec4\u8fd8\u662f `str` \u6587\u4ef6\u8def\u5f84\uff1f\uff09\uff0c\u5e76\u5c06\u5176\u540e\u5904\u7406\u4e3a\u53ef\u4ee5\u7531\u6d4f\u89c8\u5668\u663e\u793a\u7684\u683c\u5f0f\u3002\n\n\u8bf7\u67e5\u770b[\u6587\u6863](https://gradio.app/docs)\uff0c\u4e86\u89e3\u6bcf\u4e2a\u7ec4\u4ef6\u7684\u6240\u6709\u4e0e\u9884\u5904\u7406\u76f8\u5173\u7684\u53c2\u6570\u3002\n\n## \u6837\u5f0f (Styling)\n\nGradio \u4e3b\u9898\u662f\u81ea\u5b9a\u4e49\u5e94\u7528\u7a0b\u5e8f\u5916\u89c2\u548c\u611f\u89c9\u7684\u6700\u7b80\u5355\u65b9\u6cd5\u3002\u60a8\u53ef\u4ee5\u9009\u62e9\u591a\u79cd\u4e3b\u9898\u6216\u521b\u5efa\u81ea\u5df1\u7684\u4e3b\u9898\u3002\u8981\u8fd9\u6837\u505a\uff0c\u8bf7\u5c06 `theme=` \u53c2\u6570\u4f20\u9012\u7ed9 `Interface` \u6784\u9020\u51fd\u6570\u3002\u4f8b\u5982\uff1a\n\n```python\ndemo = gr.Interface(..., theme=gr.themes.Monochrome())\n```\n\nGradio \u5e26\u6709\u4e00\u7ec4\u9884\u5148\u6784\u5efa\u7684\u4e3b\u9898\uff0c\u60a8\u53ef\u4ee5\u4ece `gr.themes.*` \u52a0\u8f7d\u3002\u60a8\u53ef\u4ee5\u6269\u5c55\u8fd9\u4e9b\u4e3b\u9898\u6216\u4ece\u5934\u5f00\u59cb\u521b\u5efa\u81ea\u5df1\u7684\u4e3b\u9898 - \u6709\u5173\u66f4\u591a\u8be6\u7ec6\u4fe1\u606f\uff0c\u8bf7\u53c2\u9605[\u4e3b\u9898\u6307\u5357](https://gradio.app/theming-guide)\u3002\n\n\u8981\u589e\u52a0\u989d\u5916\u7684\u6837\u5f0f\u80fd\u529b\uff0c\u60a8\u53ef\u4ee5 with `css=` \u5173\u952e\u5b57\u5c06\u4efb\u4f55 CSS \u4f20\u9012\u7ed9\u60a8\u7684\u5e94\u7528\u7a0b\u5e8f\u3002\nGradio \u5e94\u7528\u7a0b\u5e8f\u7684\u57fa\u7c7b\u662f `gradio-container`\uff0c\u56e0\u6b64\u4ee5\u4e0b\u662f\u4e00\u4e2a\u66f4\u6539 Gradio \u5e94\u7528\u7a0b\u5e8f\u80cc\u666f\u989c\u8272\u7684\u793a\u4f8b\uff1a\n\n```python\nwith `gr.Interface(css=\".gradio-container {background-color: red}\") as demo:\n    .\n```\n\n## \u961f\u5217 (Queuing)\n\n\u5982\u679c\u60a8\u7684\u5e94\u7528\u7a0b\u5e8f\u9884\u8ba1\u4f1a\u6709\u5927\u91cf\u6d41\u91cf\uff0c\u8bf7 with `queue()` \u65b9\u6cd5\u6765\u63a7\u5236\u5904\u7406\u901f\u7387\u3002\u8fd9\u5c06\u6392\u961f\u5904\u7406\u8c03\u7528\uff0c\u56e0\u6b64\u4e00\u6b21\u53ea\u5904\u7406\u4e00\u5b9a\u6570\u91cf\u7684\u8bf7\u6c42\u3002\u961f\u5217\u4f7f\u7528 Websockets\uff0c\u8fd8\u53ef\u4ee5\u9632\u6b62\u7f51\u7edc\u8d85\u65f6\uff0c\u56e0\u6b64\u5982\u679c\u60a8\u7684\u51fd\u6570\u7684\u63a8\u7406\u65f6\u95f4\u5f88\u957f\uff08> 1 \u5206\u949f\uff09\uff0c\u5e94\u4f7f\u7528\u961f\u5217\u3002\n\nwith `Interface`\uff1a\n\n```python\ndemo = gr.Interface(.).queue()\ndemo.launch()\n```\n\nwith `Blocks`\uff1a\n\n```python\nwith gr.Blocks() as demo\uff1a\n    #.\ndemo.queue()\ndemo.launch()\n```\n\n\u60a8\u53ef\u4ee5\u901a\u8fc7\u4ee5\u4e0b\u65b9\u5f0f\u63a7\u5236\u4e00\u6b21\u5904\u7406\u7684\u8bf7\u6c42\u6570\u91cf\uff1a\n\n```python\ndemo.queue(concurrency_count=3)\n```\n\n\u67e5\u770b\u6709\u5173\u914d\u7f6e\u5176\u4ed6\u961f\u5217\u53c2\u6570\u7684[\u961f\u5217\u6587\u6863](/docs/#queue)\u3002\n\n\u5728 Blocks \u4e2d\u6307\u5b9a\u4ec5\u5bf9\u67d0\u4e9b\u51fd\u6570\u8fdb\u884c\u6392\u961f\uff1a\n\n```python\nwith gr.Blocks() as demo2\uff1a\n    num1 = gr.Number()\n    num2 = gr.Number()\n    output = gr.Number()\n    gr.Button(\"Add\").click(\n        lambda a, b: a + b, [num1, num2], output)\n    gr.Button(\"Multiply\").click(\n        lambda a, b: a * b, [num1, num2], output, queue=True)\ndemo2."
            }
        ]
    },
    {
        "sample_idx": 133,
        "question": "What interpolation method is used by the model?",
        "answer": "bicubic",
        "rag_answer": "There is no information about the interpolation method used by the model in the provided context. The context discusses token classification with LayoutLMv3, fine-tuning on FUNSD and CORD, XLA rules, training on TPU, and choosing evaluation metrics, but it does not mention interpolation methods.",
        "rag_score": 1,
        "rag_feedback": "The system's response is completely incorrect, inaccurate, and/or not factual. The system did not provide any information about the interpolation method used by the model, instead, it provided a lot of irrelevant information about token classification with LayoutLMv3, fine-tuning on FUNSD and CORD, XLA rules, training on TPU, and choosing evaluation metrics.",
        "rag_context": [
            {
                "score": 0.6104532389315886,
                "node_text": "Here are some facts extracted from the provided text:\n\nModel -> Needs -> Question\nModel -> Has -> Input shape\nModel -> Needs -> Context\nModel -> Evaluates on -> Squad\nNielsr/layoutlmv3-finetuned-funsd -> Is -> Model\nModel -> Returns -> Prediction_text\nMicrosoft/layoutlmv3-base -> Is -> Model name or path\n\n!---\nCopyright 2022 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n-->\n\n# Token classification with LayoutLMv3 (PyTorch version)\n\nThis directory contains a script, `run_funsd_cord.py`, that can be used to fine-tune (or evaluate) LayoutLMv3 on form understanding datasets, such as [FUNSD](https://guillaumejaume.github.io/FUNSD/) and [CORD](https://github.com/clovaai/cord).\n\nThe script `run_funsd_cord.py` leverages the \ud83e\udd17 Datasets library and the Trainer API. You can easily customize it to your needs.\n\n## Fine-tuning on FUNSD\n\nFine-tuning LayoutLMv3 for token classification on [FUNSD](https://guillaumejaume.github.io/FUNSD/) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name funsd \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 1e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-funsd\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd. By specifying the `push_to_hub` flag, the model gets uploaded automatically to the hub (regularly), together with a model card, which includes metrics such as precision, recall and F1. Note that you can easily update the model card, as it's just a README file of the respective repo on the hub.\n\nThere's also the \"Training metrics\" [tab](https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd/tensorboard), which shows Tensorboard logs over the course of training. Pretty neat, huh?\n\n## Fine-tuning on CORD\n\nFine-tuning LayoutLMv3 for token classification on [CORD](https://github.com/clovaai/cord) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name cord \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 5e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-cord\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-cord. Note that a model card gets generated automatically in case you specify the `push_to_hub` flag."
            },
            {
                "score": 0.6104532389315886,
                "node_text": "Here are some facts extracted from the provided text:\n\nXla -> Recompile -> Model\nNlp models -> Have -> Variable lengths\n\nThis is a really useful trick, so remember it if you need to convert your own code to XLA!\n\n#### XLA Rule #3: XLA will need to recompile your model for every different input shape it sees\n\nThis is the big one. What this means is that if your input shapes are very variable, XLA will have to recompile your model over and over, which will create huge performance problems. This commonly arises in NLP models, where input texts have variable lengths after tokenization. In other modalities, static shapes are more common and this rule is much less of a problem.\n\nHow can you get around rule #3? The key is **padding** - if you pad all your inputs to the same length, and then use an `attention_mask`, you can get the same results as you\u2019d get from variable shapes, but without any XLA issues. However, excessive padding can cause severe slowdown too - if you pad all your samples to the maximum length in the whole dataset, you might end up with batches consisting endless padding tokens, which will waste a lot of compute and memory!\n\nThere isn\u2019t a perfect solution to this problem. However, you can try some tricks. One very useful trick is to **pad batches of samples up to a multiple of a number like 32 or 64 tokens.** This often only increases the number of tokens by a small amount, but it hugely reduces the number of unique input shapes, because every input shape now has to be a multiple of 32 or 64. Fewer unique input shapes means fewer XLA compilations!\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** Our tokenizers and data collators have methods that can help you here. You can use `padding=\"max_length\"` or `padding=\"longest\"` when calling tokenizers to get them to output padded data. Our tokenizers and data collators also have a `pad_to_multiple_of` argument that you can use to reduce the number of unique input shapes you see!\n\n</Tip>\n\n### How do I actually train my model on TPU?\n\nOnce your training is XLA-compatible and (if you\u2019re using TPU Node / Colab) your dataset has been prepared appropriately, running on TPU is surprisingly easy! All you really need to change in your code is to add a few lines to initialize your TPU, and to ensure that your model and dataset are created inside a `TPUStrategy` scope. Take a look at [our TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) to see this in action!\n\n### Summary\n\nThere was a lot in here, so let\u2019s summarize with a quick checklist you can follow when you want to get your model ready for TPU training:\n\n- Make sure your code follows the three rules of XLA\n- Compile your model with `jit_compile=True` on CPU/GPU and confirm that you can train it with XLA\n- Either load your dataset into memory or use a TPU-compatible dataset loading approach (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Migrate your code either to Colab (with accelerator set to \u201cTPU\u201d) or a TPU VM on Google Cloud\n- Add TPU initializer code (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Create your `TPUStrategy` and make sure dataset loading and model creation are inside the `strategy.scope()` (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Don\u2019t forget to take `jit_compile=True` out again when you move to TPU!\n- \ud83d\ude4f\ud83d\ude4f\ud83d\ude4f\ud83e\udd7a\ud83e\udd7a\ud83e\udd7a\n- Call model.fit()\n- You did it!"
            },
            {
                "score": 0.5739605069955762,
                "node_text": "Here are some facts extracted from the provided text:\n\nAccuracy -> Is -> Generic metric\n\nChoosing a metric for your task\n\n**So you've trained your model and want to see how well it\u2019s doing on a dataset of your choice. Where do you start?**\n\nThere is no \u201cone size fits all\u201d approach to choosing an evaluation metric, but some good guidelines to keep in mind are:\n\n## Categories of metrics\n\nThere are 3 high-level categories of metrics:\n\n1. *Generic metrics*, which can be applied to a variety of situations and datasets, such as precision and accuracy.\n2. *Task-specific metrics*, which are limited to a given task, such as Machine Translation (often evaluated using metrics [BLEU](https://huggingface.co/metrics/bleu) or [ROUGE](https://huggingface.co/metrics/rouge)) or Named Entity Recognition (often evaluated with [seqeval](https://huggingface.co/metrics/seqeval)).\n3. *Dataset-specific metrics*, which aim to measure model performance on specific benchmarks: for instance, the [GLUE benchmark](https://huggingface.co/datasets/glue) has a dedicated [evaluation metric](https://huggingface.co/metrics/glue).\n\nLet's look at each of these three cases:\n\n### Generic metrics\n\nMany of the metrics used in the Machine Learning community are quite generic and can be applied in a variety of tasks and datasets.\n\nThis is the case for metrics like [accuracy](https://huggingface.co/metrics/accuracy) and [precision](https://huggingface.co/metrics/precision), which can be used for evaluating labeled (supervised) datasets, as well as [perplexity](https://huggingface.co/metrics/perplexity), which can be used for evaluating different kinds of (unsupervised) generative tasks.\n\nTo see the input structure of a given metric, you can look at its metric card. For example, in the case of [precision](https://huggingface.co/metrics/precision), the format is:\n```\n>>> precision_metric = evaluate.load(\"precision\")\n>>> results = precision_metric.compute(references=[0, 1], predictions=[0, 1])\n>>> print(results)\n{'precision': 1.0}\n```\n\n### Task-specific metrics\n\nPopular ML tasks like Machine Translation and Named Entity Recognition have specific metrics that can be used to compare models. For example, a series of different metrics have been proposed for text generation, ranging from [BLEU](https://huggingface.co/metrics/bleu) and its derivatives such as [GoogleBLEU](https://huggingface.co/metrics/google_bleu) and [GLEU](https://huggingface.co/metrics/gleu), but also [ROUGE](https://huggingface.co/metrics/rouge), [MAUVE](https://huggingface.co/metrics/mauve), etc.\n\nYou can find the right metric for your task by:\n\n- **Looking at the [Task pages](https://huggingface.co/tasks)** to see what metrics can be used for evaluating models for a given task.\n- **Checking out leaderboards** on sites like [Papers With Code](https://paperswithcode.com/) (you can search by task and by dataset).\n-  **Reading the metric cards** for the relevant metrics and see which ones are a good fit for your use case. For example, see the [BLEU metric card](https://github.com/huggingface/evaluate/tree/main/metrics/bleu) or [SQuaD metric card](https://github.com/huggingface/evaluate/tree/main/metrics/squad).\n- **Looking at papers and blog posts** published on the topic and see what metrics they report. This can change over time, so try to pick papers from the last couple of years!\n\n### Dataset-specific metrics\n\nSome datasets have specific metrics associated with them -- this is especially in the case of popular benchmarks like [GLUE](https://huggingface.co/metrics/glue) and [SQuAD](https://huggingface.co/metrics/squad).\n\n<Tip warning={true}>\n\ud83d\udca1\nGLUE is actually a collection of different subsets on different tasks, so first you need to choose the one that corresponds to the NLI task, such as mnli, which is described as \u201ccrowdsourced collection of sentence pairs with textual entailment annotations\u201d\n</Tip>"
            }
        ]
    },
    {
        "sample_idx": 134,
        "question": "What is the top 1 accuracy of the model on ImageNet?",
        "answer": "80.26%",
        "rag_answer": "There is no information about the top 1 accuracy of the model on ImageNet in the provided context. The context discusses TensorFlow models, Keras models, TPU training, XLA rules, and evaluation metrics, but it does not mention ImageNet or any specific model's performance on it.",
        "rag_score": 1,
        "rag_feedback": "The system's response is completely incorrect, inaccurate, and/or not factual. The response does not provide any information about the top 1 accuracy of the model on ImageNet, which is the expected answer. Instead, it provides a lengthy text about TensorFlow models, Keras models, TPU training, XLA rules, and evaluation metrics, but it does not mention ImageNet or any specific model's performance on it.",
        "rag_context": [
            {
                "score": 0.6112003593894263,
                "node_text": "Here are some facts extracted from the provided text:\n\nTensorflow models -> Are -> Keras models\n\n!--Copyright 2023 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\nthe License. You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under the License is distributed on\nan \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n\n\u26a0\ufe0f Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be\nrendered properly in your Markdown viewer.\n\n-->\n\n# Training on TPU with TensorFlow\n\n<Tip>\n\nIf you don't need long explanations and just want TPU code samples to get started with, check out [our TPU example notebook!](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb)\n\n</Tip>\n\n### What is a TPU?\n\nA TPU is a **Tensor Processing Unit.** They are hardware designed by Google, which are used to greatly speed up the tensor computations within neural networks, much like GPUs. They can be used for both network training and inference. They are generally accessed through Google\u2019s cloud services, but small TPUs can also be accessed directly for free through Google Colab and Kaggle Kernels.\n\nBecause [all TensorFlow models in \ud83e\udd17 Transformers are Keras models](https://huggingface.co/blog/tensorflow-philosophy), most of the methods in this document are generally applicable to TPU training for any Keras model! However, there are a few points that are specific to the HuggingFace ecosystem (hug-o-system?) of Transformers and Datasets, and we\u2019ll make sure to flag them up when we get to them.\n\n### What kinds of TPU are available?\n\nNew users are often very confused by the range of TPUs, and the different ways to access them. The first key distinction to understand is the difference between **TPU Nodes** and **TPU VMs.**\n\nWhen you use a **TPU Node**, you are effectively indirectly accessing a remote TPU. You will need a separate VM, which will initialize your network and data pipeline and then forward them to the remote node. When you use a TPU on Google Colab, you are accessing it in the **TPU Node** style.\n\nUsing TPU Nodes can have some quite unexpected behaviour for people who aren\u2019t used to them! In particular, because the TPU is located on a physically different system to the machine you\u2019re running your Python code on, your data cannot be local to your machine - any data pipeline that loads from your machine\u2019s internal storage will totally fail! Instead, data must be stored in Google Cloud Storage where your data pipeline can still access it, even when the pipeline is running on the remote TPU node.\n\n<Tip>\n\nIf you can fit all your data in memory as `np.ndarray` or `tf.Tensor`, then you can `fit()` on that data even when using Colab or a TPU Node, without needing to upload it to Google Cloud Storage.\n\n</Tip>\n\n<Tip>\n\n**\ud83e\udd17Specific Hugging Face Tip\ud83e\udd17:** The methods `Dataset.to_tf_dataset()` and its higher-level wrapper `model.prepare_tf_dataset()` , which you will see throughout our TF code examples, will both fail on a TPU Node. The reason for this is that even though they create a `tf.data.Dataset` it is not a \u201cpure\u201d `tf.data` pipeline and uses `tf.numpy_function` or `Dataset.from_generator()` to stream data from the underlying HuggingFace `Dataset`. This HuggingFace `Dataset` is backed by data that is on a local disc and which the remote TPU Node will not be able to read.\n\n</Tip>\n\nThe second way to access a TPU is via a **TPU VM.** When using a TPU VM, you connect directly to the machine that the TPU is attached to, much like training on a GPU VM. TPU VMs are generally easier to work with, particularly when it comes to your data pipeline. All of the above warnings do not apply to TPU VMs!\n\nThis is an opinionated document, so here\u2019s our opinion: **Avoid using TPU Node if possible.** It is more confusing and more difficult to debug than TPU VMs. It is also likely to be unsupported in future - Google\u2019s latest TPU, TPUv4, can only be accessed as a TPU VM, which suggests that TPU Nodes are increasingly going to become a \u201clegacy\u201d access method."
            },
            {
                "score": 0.5953460996853503,
                "node_text": "Here are some facts extracted from the provided text:\n\nTpu -> Used for -> Neural networks\n\nThis is a really useful trick, so remember it if you need to convert your own code to XLA!\n\n#### XLA Rule #3: XLA will need to recompile your model for every different input shape it sees\n\nThis is the big one. What this means is that if your input shapes are very variable, XLA will have to recompile your model over and over, which will create huge performance problems. This commonly arises in NLP models, where input texts have variable lengths after tokenization. In other modalities, static shapes are more common and this rule is much less of a problem.\n\nHow can you get around rule #3? The key is **padding** - if you pad all your inputs to the same length, and then use an `attention_mask`, you can get the same results as you\u2019d get from variable shapes, but without any XLA issues. However, excessive padding can cause severe slowdown too - if you pad all your samples to the maximum length in the whole dataset, you might end up with batches consisting endless padding tokens, which will waste a lot of compute and memory!\n\nThere isn\u2019t a perfect solution to this problem. However, you can try some tricks. One very useful trick is to **pad batches of samples up to a multiple of a number like 32 or 64 tokens.** This often only increases the number of tokens by a small amount, but it hugely reduces the number of unique input shapes, because every input shape now has to be a multiple of 32 or 64. Fewer unique input shapes means fewer XLA compilations!\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** Our tokenizers and data collators have methods that can help you here. You can use `padding=\"max_length\"` or `padding=\"longest\"` when calling tokenizers to get them to output padded data. Our tokenizers and data collators also have a `pad_to_multiple_of` argument that you can use to reduce the number of unique input shapes you see!\n\n</Tip>\n\n### How do I actually train my model on TPU?\n\nOnce your training is XLA-compatible and (if you\u2019re using TPU Node / Colab) your dataset has been prepared appropriately, running on TPU is surprisingly easy! All you really need to change in your code is to add a few lines to initialize your TPU, and to ensure that your model and dataset are created inside a `TPUStrategy` scope. Take a look at [our TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) to see this in action!\n\n### Summary\n\nThere was a lot in here, so let\u2019s summarize with a quick checklist you can follow when you want to get your model ready for TPU training:\n\n- Make sure your code follows the three rules of XLA\n- Compile your model with `jit_compile=True` on CPU/GPU and confirm that you can train it with XLA\n- Either load your dataset into memory or use a TPU-compatible dataset loading approach (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Migrate your code either to Colab (with accelerator set to \u201cTPU\u201d) or a TPU VM on Google Cloud\n- Add TPU initializer code (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Create your `TPUStrategy` and make sure dataset loading and model creation are inside the `strategy.scope()` (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Don\u2019t forget to take `jit_compile=True` out again when you move to TPU!\n- \ud83d\ude4f\ud83d\ude4f\ud83d\ude4f\ud83e\udd7a\ud83e\udd7a\ud83e\udd7a\n- Call model.fit()\n- You did it!"
            },
            {
                "score": 0.5815549477561233,
                "node_text": "Here are some facts extracted from the provided text:\n\nBleu -> Is -> Task-specific metric\n\nChoosing a metric for your task\n\n**So you've trained your model and want to see how well it\u2019s doing on a dataset of your choice. Where do you start?**\n\nThere is no \u201cone size fits all\u201d approach to choosing an evaluation metric, but some good guidelines to keep in mind are:\n\n## Categories of metrics\n\nThere are 3 high-level categories of metrics:\n\n1. *Generic metrics*, which can be applied to a variety of situations and datasets, such as precision and accuracy.\n2. *Task-specific metrics*, which are limited to a given task, such as Machine Translation (often evaluated using metrics [BLEU](https://huggingface.co/metrics/bleu) or [ROUGE](https://huggingface.co/metrics/rouge)) or Named Entity Recognition (often evaluated with [seqeval](https://huggingface.co/metrics/seqeval)).\n3. *Dataset-specific metrics*, which aim to measure model performance on specific benchmarks: for instance, the [GLUE benchmark](https://huggingface.co/datasets/glue) has a dedicated [evaluation metric](https://huggingface.co/metrics/glue).\n\nLet's look at each of these three cases:\n\n### Generic metrics\n\nMany of the metrics used in the Machine Learning community are quite generic and can be applied in a variety of tasks and datasets.\n\nThis is the case for metrics like [accuracy](https://huggingface.co/metrics/accuracy) and [precision](https://huggingface.co/metrics/precision), which can be used for evaluating labeled (supervised) datasets, as well as [perplexity](https://huggingface.co/metrics/perplexity), which can be used for evaluating different kinds of (unsupervised) generative tasks.\n\nTo see the input structure of a given metric, you can look at its metric card. For example, in the case of [precision](https://huggingface.co/metrics/precision), the format is:\n```\n>>> precision_metric = evaluate.load(\"precision\")\n>>> results = precision_metric.compute(references=[0, 1], predictions=[0, 1])\n>>> print(results)\n{'precision': 1.0}\n```\n\n### Task-specific metrics\n\nPopular ML tasks like Machine Translation and Named Entity Recognition have specific metrics that can be used to compare models. For example, a series of different metrics have been proposed for text generation, ranging from [BLEU](https://huggingface.co/metrics/bleu) and its derivatives such as [GoogleBLEU](https://huggingface.co/metrics/google_bleu) and [GLEU](https://huggingface.co/metrics/gleu), but also [ROUGE](https://huggingface.co/metrics/rouge), [MAUVE](https://huggingface.co/metrics/mauve), etc.\n\nYou can find the right metric for your task by:\n\n- **Looking at the [Task pages](https://huggingface.co/tasks)** to see what metrics can be used for evaluating models for a given task.\n- **Checking out leaderboards** on sites like [Papers With Code](https://paperswithcode.com/) (you can search by task and by dataset).\n-  **Reading the metric cards** for the relevant metrics and see which ones are a good fit for your use case. For example, see the [BLEU metric card](https://github.com/huggingface/evaluate/tree/main/metrics/bleu) or [SQuaD metric card](https://github.com/huggingface/evaluate/tree/main/metrics/squad).\n- **Looking at papers and blog posts** published on the topic and see what metrics they report. This can change over time, so try to pick papers from the last couple of years!\n\n### Dataset-specific metrics\n\nSome datasets have specific metrics associated with them -- this is especially in the case of popular benchmarks like [GLUE](https://huggingface.co/metrics/glue) and [SQuAD](https://huggingface.co/metrics/squad).\n\n<Tip warning={true}>\n\ud83d\udca1\nGLUE is actually a collection of different subsets on different tasks, so first you need to choose the one that corresponds to the NLI task, such as mnli, which is described as \u201ccrowdsourced collection of sentence pairs with textual entailment annotations\u201d\n</Tip>"
            }
        ]
    },
    {
        "sample_idx": 135,
        "question": "What is the top 5 accuracy of the model on ImageNet?",
        "answer": "95.07%",
        "rag_answer": "There is no information about the top 5 accuracy of a model on ImageNet in the provided context. The context discusses TensorFlow models, Keras models, TPUs, XLA, and evaluation metrics, but it does not mention ImageNet or any specific model's performance on it.",
        "rag_score": 1,
        "rag_feedback": "The system's response is completely incorrect, inaccurate, and/or not factual. The question asks about the top 5 accuracy of a model on ImageNet, but the system's response does not provide any information related to ImageNet or the top 5 accuracy of a model.",
        "rag_context": [
            {
                "score": 0.6066287646707732,
                "node_text": "Here are some facts extracted from the provided text:\n\nTensorflow models -> Are -> Keras models\n\n!--Copyright 2023 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\nthe License. You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under the License is distributed on\nan \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n\n\u26a0\ufe0f Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be\nrendered properly in your Markdown viewer.\n\n-->\n\n# Training on TPU with TensorFlow\n\n<Tip>\n\nIf you don't need long explanations and just want TPU code samples to get started with, check out [our TPU example notebook!](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb)\n\n</Tip>\n\n### What is a TPU?\n\nA TPU is a **Tensor Processing Unit.** They are hardware designed by Google, which are used to greatly speed up the tensor computations within neural networks, much like GPUs. They can be used for both network training and inference. They are generally accessed through Google\u2019s cloud services, but small TPUs can also be accessed directly for free through Google Colab and Kaggle Kernels.\n\nBecause [all TensorFlow models in \ud83e\udd17 Transformers are Keras models](https://huggingface.co/blog/tensorflow-philosophy), most of the methods in this document are generally applicable to TPU training for any Keras model! However, there are a few points that are specific to the HuggingFace ecosystem (hug-o-system?) of Transformers and Datasets, and we\u2019ll make sure to flag them up when we get to them.\n\n### What kinds of TPU are available?\n\nNew users are often very confused by the range of TPUs, and the different ways to access them. The first key distinction to understand is the difference between **TPU Nodes** and **TPU VMs.**\n\nWhen you use a **TPU Node**, you are effectively indirectly accessing a remote TPU. You will need a separate VM, which will initialize your network and data pipeline and then forward them to the remote node. When you use a TPU on Google Colab, you are accessing it in the **TPU Node** style.\n\nUsing TPU Nodes can have some quite unexpected behaviour for people who aren\u2019t used to them! In particular, because the TPU is located on a physically different system to the machine you\u2019re running your Python code on, your data cannot be local to your machine - any data pipeline that loads from your machine\u2019s internal storage will totally fail! Instead, data must be stored in Google Cloud Storage where your data pipeline can still access it, even when the pipeline is running on the remote TPU node.\n\n<Tip>\n\nIf you can fit all your data in memory as `np.ndarray` or `tf.Tensor`, then you can `fit()` on that data even when using Colab or a TPU Node, without needing to upload it to Google Cloud Storage.\n\n</Tip>\n\n<Tip>\n\n**\ud83e\udd17Specific Hugging Face Tip\ud83e\udd17:** The methods `Dataset.to_tf_dataset()` and its higher-level wrapper `model.prepare_tf_dataset()` , which you will see throughout our TF code examples, will both fail on a TPU Node. The reason for this is that even though they create a `tf.data.Dataset` it is not a \u201cpure\u201d `tf.data` pipeline and uses `tf.numpy_function` or `Dataset.from_generator()` to stream data from the underlying HuggingFace `Dataset`. This HuggingFace `Dataset` is backed by data that is on a local disc and which the remote TPU Node will not be able to read.\n\n</Tip>\n\nThe second way to access a TPU is via a **TPU VM.** When using a TPU VM, you connect directly to the machine that the TPU is attached to, much like training on a GPU VM. TPU VMs are generally easier to work with, particularly when it comes to your data pipeline. All of the above warnings do not apply to TPU VMs!\n\nThis is an opinionated document, so here\u2019s our opinion: **Avoid using TPU Node if possible.** It is more confusing and more difficult to debug than TPU VMs. It is also likely to be unsupported in future - Google\u2019s latest TPU, TPUv4, can only be accessed as a TPU VM, which suggests that TPU Nodes are increasingly going to become a \u201clegacy\u201d access method."
            },
            {
                "score": 0.5908214759797132,
                "node_text": "Here are some facts extracted from the provided text:\n\nTpu -> Used for -> Neural networks\n\nThis is a really useful trick, so remember it if you need to convert your own code to XLA!\n\n#### XLA Rule #3: XLA will need to recompile your model for every different input shape it sees\n\nThis is the big one. What this means is that if your input shapes are very variable, XLA will have to recompile your model over and over, which will create huge performance problems. This commonly arises in NLP models, where input texts have variable lengths after tokenization. In other modalities, static shapes are more common and this rule is much less of a problem.\n\nHow can you get around rule #3? The key is **padding** - if you pad all your inputs to the same length, and then use an `attention_mask`, you can get the same results as you\u2019d get from variable shapes, but without any XLA issues. However, excessive padding can cause severe slowdown too - if you pad all your samples to the maximum length in the whole dataset, you might end up with batches consisting endless padding tokens, which will waste a lot of compute and memory!\n\nThere isn\u2019t a perfect solution to this problem. However, you can try some tricks. One very useful trick is to **pad batches of samples up to a multiple of a number like 32 or 64 tokens.** This often only increases the number of tokens by a small amount, but it hugely reduces the number of unique input shapes, because every input shape now has to be a multiple of 32 or 64. Fewer unique input shapes means fewer XLA compilations!\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** Our tokenizers and data collators have methods that can help you here. You can use `padding=\"max_length\"` or `padding=\"longest\"` when calling tokenizers to get them to output padded data. Our tokenizers and data collators also have a `pad_to_multiple_of` argument that you can use to reduce the number of unique input shapes you see!\n\n</Tip>\n\n### How do I actually train my model on TPU?\n\nOnce your training is XLA-compatible and (if you\u2019re using TPU Node / Colab) your dataset has been prepared appropriately, running on TPU is surprisingly easy! All you really need to change in your code is to add a few lines to initialize your TPU, and to ensure that your model and dataset are created inside a `TPUStrategy` scope. Take a look at [our TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) to see this in action!\n\n### Summary\n\nThere was a lot in here, so let\u2019s summarize with a quick checklist you can follow when you want to get your model ready for TPU training:\n\n- Make sure your code follows the three rules of XLA\n- Compile your model with `jit_compile=True` on CPU/GPU and confirm that you can train it with XLA\n- Either load your dataset into memory or use a TPU-compatible dataset loading approach (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Migrate your code either to Colab (with accelerator set to \u201cTPU\u201d) or a TPU VM on Google Cloud\n- Add TPU initializer code (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Create your `TPUStrategy` and make sure dataset loading and model creation are inside the `strategy.scope()` (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Don\u2019t forget to take `jit_compile=True` out again when you move to TPU!\n- \ud83d\ude4f\ud83d\ude4f\ud83d\ude4f\ud83e\udd7a\ud83e\udd7a\ud83e\udd7a\n- Call model.fit()\n- You did it!"
            },
            {
                "score": 0.576155518370673,
                "node_text": "Here are some facts extracted from the provided text:\n\nBleu -> Is -> Task-specific metric\n\nChoosing a metric for your task\n\n**So you've trained your model and want to see how well it\u2019s doing on a dataset of your choice. Where do you start?**\n\nThere is no \u201cone size fits all\u201d approach to choosing an evaluation metric, but some good guidelines to keep in mind are:\n\n## Categories of metrics\n\nThere are 3 high-level categories of metrics:\n\n1. *Generic metrics*, which can be applied to a variety of situations and datasets, such as precision and accuracy.\n2. *Task-specific metrics*, which are limited to a given task, such as Machine Translation (often evaluated using metrics [BLEU](https://huggingface.co/metrics/bleu) or [ROUGE](https://huggingface.co/metrics/rouge)) or Named Entity Recognition (often evaluated with [seqeval](https://huggingface.co/metrics/seqeval)).\n3. *Dataset-specific metrics*, which aim to measure model performance on specific benchmarks: for instance, the [GLUE benchmark](https://huggingface.co/datasets/glue) has a dedicated [evaluation metric](https://huggingface.co/metrics/glue).\n\nLet's look at each of these three cases:\n\n### Generic metrics\n\nMany of the metrics used in the Machine Learning community are quite generic and can be applied in a variety of tasks and datasets.\n\nThis is the case for metrics like [accuracy](https://huggingface.co/metrics/accuracy) and [precision](https://huggingface.co/metrics/precision), which can be used for evaluating labeled (supervised) datasets, as well as [perplexity](https://huggingface.co/metrics/perplexity), which can be used for evaluating different kinds of (unsupervised) generative tasks.\n\nTo see the input structure of a given metric, you can look at its metric card. For example, in the case of [precision](https://huggingface.co/metrics/precision), the format is:\n```\n>>> precision_metric = evaluate.load(\"precision\")\n>>> results = precision_metric.compute(references=[0, 1], predictions=[0, 1])\n>>> print(results)\n{'precision': 1.0}\n```\n\n### Task-specific metrics\n\nPopular ML tasks like Machine Translation and Named Entity Recognition have specific metrics that can be used to compare models. For example, a series of different metrics have been proposed for text generation, ranging from [BLEU](https://huggingface.co/metrics/bleu) and its derivatives such as [GoogleBLEU](https://huggingface.co/metrics/google_bleu) and [GLEU](https://huggingface.co/metrics/gleu), but also [ROUGE](https://huggingface.co/metrics/rouge), [MAUVE](https://huggingface.co/metrics/mauve), etc.\n\nYou can find the right metric for your task by:\n\n- **Looking at the [Task pages](https://huggingface.co/tasks)** to see what metrics can be used for evaluating models for a given task.\n- **Checking out leaderboards** on sites like [Papers With Code](https://paperswithcode.com/) (you can search by task and by dataset).\n-  **Reading the metric cards** for the relevant metrics and see which ones are a good fit for your use case. For example, see the [BLEU metric card](https://github.com/huggingface/evaluate/tree/main/metrics/bleu) or [SQuaD metric card](https://github.com/huggingface/evaluate/tree/main/metrics/squad).\n- **Looking at papers and blog posts** published on the topic and see what metrics they report. This can change over time, so try to pick papers from the last couple of years!\n\n### Dataset-specific metrics\n\nSome datasets have specific metrics associated with them -- this is especially in the case of popular benchmarks like [GLUE](https://huggingface.co/metrics/glue) and [SQuAD](https://huggingface.co/metrics/squad).\n\n<Tip warning={true}>\n\ud83d\udca1\nGLUE is actually a collection of different subsets on different tasks, so first you need to choose the one that corresponds to the NLI task, such as mnli, which is described as \u201ccrowdsourced collection of sentence pairs with textual entailment annotations\u201d\n</Tip>"
            }
        ]
    },
    {
        "sample_idx": 136,
        "question": "What dataset is used for training the model?",
        "answer": "ImageNet",
        "rag_answer": "The dataset used for training the model is either FUNSD or CORD, depending on the specific fine-tuning task.",
        "rag_score": 1,
        "rag_feedback": "The system's response is completely incorrect, inaccurate, and/or not factual. The expected answer is 'ImageNet', but the system's response mentions 'FUNSD' and 'CORD' datasets, which are unrelated to the question.",
        "rag_context": [
            {
                "score": 0.6730080285752994,
                "node_text": "Here are some facts extracted from the provided text:\n\nHuggingface ecosystem -> Includes -> Transformers and datasets\nTensorflow models -> Are -> Keras models\n\n!--Copyright 2023 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\nthe License. You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under the License is distributed on\nan \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n\n\u26a0\ufe0f Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be\nrendered properly in your Markdown viewer.\n\n-->\n\n# Training on TPU with TensorFlow\n\n<Tip>\n\nIf you don't need long explanations and just want TPU code samples to get started with, check out [our TPU example notebook!](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb)\n\n</Tip>\n\n### What is a TPU?\n\nA TPU is a **Tensor Processing Unit.** They are hardware designed by Google, which are used to greatly speed up the tensor computations within neural networks, much like GPUs. They can be used for both network training and inference. They are generally accessed through Google\u2019s cloud services, but small TPUs can also be accessed directly for free through Google Colab and Kaggle Kernels.\n\nBecause [all TensorFlow models in \ud83e\udd17 Transformers are Keras models](https://huggingface.co/blog/tensorflow-philosophy), most of the methods in this document are generally applicable to TPU training for any Keras model! However, there are a few points that are specific to the HuggingFace ecosystem (hug-o-system?) of Transformers and Datasets, and we\u2019ll make sure to flag them up when we get to them.\n\n### What kinds of TPU are available?\n\nNew users are often very confused by the range of TPUs, and the different ways to access them. The first key distinction to understand is the difference between **TPU Nodes** and **TPU VMs.**\n\nWhen you use a **TPU Node**, you are effectively indirectly accessing a remote TPU. You will need a separate VM, which will initialize your network and data pipeline and then forward them to the remote node. When you use a TPU on Google Colab, you are accessing it in the **TPU Node** style.\n\nUsing TPU Nodes can have some quite unexpected behaviour for people who aren\u2019t used to them! In particular, because the TPU is located on a physically different system to the machine you\u2019re running your Python code on, your data cannot be local to your machine - any data pipeline that loads from your machine\u2019s internal storage will totally fail! Instead, data must be stored in Google Cloud Storage where your data pipeline can still access it, even when the pipeline is running on the remote TPU node.\n\n<Tip>\n\nIf you can fit all your data in memory as `np.ndarray` or `tf.Tensor`, then you can `fit()` on that data even when using Colab or a TPU Node, without needing to upload it to Google Cloud Storage.\n\n</Tip>\n\n<Tip>\n\n**\ud83e\udd17Specific Hugging Face Tip\ud83e\udd17:** The methods `Dataset.to_tf_dataset()` and its higher-level wrapper `model.prepare_tf_dataset()` , which you will see throughout our TF code examples, will both fail on a TPU Node. The reason for this is that even though they create a `tf.data.Dataset` it is not a \u201cpure\u201d `tf.data` pipeline and uses `tf.numpy_function` or `Dataset.from_generator()` to stream data from the underlying HuggingFace `Dataset`. This HuggingFace `Dataset` is backed by data that is on a local disc and which the remote TPU Node will not be able to read.\n\n</Tip>\n\nThe second way to access a TPU is via a **TPU VM.** When using a TPU VM, you connect directly to the machine that the TPU is attached to, much like training on a GPU VM. TPU VMs are generally easier to work with, particularly when it comes to your data pipeline. All of the above warnings do not apply to TPU VMs!\n\nThis is an opinionated document, so here\u2019s our opinion: **Avoid using TPU Node if possible.** It is more confusing and more difficult to debug than TPU VMs. It is also likely to be unsupported in future - Google\u2019s latest TPU, TPUv4, can only be accessed as a TPU VM, which suggests that TPU Nodes are increasingly going to become a \u201clegacy\u201d access method."
            },
            {
                "score": 0.6636206807763944,
                "node_text": "Here are some facts extracted from the provided text:\n\nTpu -> Is used -> For training\n\nThis is a really useful trick, so remember it if you need to convert your own code to XLA!\n\n#### XLA Rule #3: XLA will need to recompile your model for every different input shape it sees\n\nThis is the big one. What this means is that if your input shapes are very variable, XLA will have to recompile your model over and over, which will create huge performance problems. This commonly arises in NLP models, where input texts have variable lengths after tokenization. In other modalities, static shapes are more common and this rule is much less of a problem.\n\nHow can you get around rule #3? The key is **padding** - if you pad all your inputs to the same length, and then use an `attention_mask`, you can get the same results as you\u2019d get from variable shapes, but without any XLA issues. However, excessive padding can cause severe slowdown too - if you pad all your samples to the maximum length in the whole dataset, you might end up with batches consisting endless padding tokens, which will waste a lot of compute and memory!\n\nThere isn\u2019t a perfect solution to this problem. However, you can try some tricks. One very useful trick is to **pad batches of samples up to a multiple of a number like 32 or 64 tokens.** This often only increases the number of tokens by a small amount, but it hugely reduces the number of unique input shapes, because every input shape now has to be a multiple of 32 or 64. Fewer unique input shapes means fewer XLA compilations!\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** Our tokenizers and data collators have methods that can help you here. You can use `padding=\"max_length\"` or `padding=\"longest\"` when calling tokenizers to get them to output padded data. Our tokenizers and data collators also have a `pad_to_multiple_of` argument that you can use to reduce the number of unique input shapes you see!\n\n</Tip>\n\n### How do I actually train my model on TPU?\n\nOnce your training is XLA-compatible and (if you\u2019re using TPU Node / Colab) your dataset has been prepared appropriately, running on TPU is surprisingly easy! All you really need to change in your code is to add a few lines to initialize your TPU, and to ensure that your model and dataset are created inside a `TPUStrategy` scope. Take a look at [our TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) to see this in action!\n\n### Summary\n\nThere was a lot in here, so let\u2019s summarize with a quick checklist you can follow when you want to get your model ready for TPU training:\n\n- Make sure your code follows the three rules of XLA\n- Compile your model with `jit_compile=True` on CPU/GPU and confirm that you can train it with XLA\n- Either load your dataset into memory or use a TPU-compatible dataset loading approach (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Migrate your code either to Colab (with accelerator set to \u201cTPU\u201d) or a TPU VM on Google Cloud\n- Add TPU initializer code (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Create your `TPUStrategy` and make sure dataset loading and model creation are inside the `strategy.scope()` (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Don\u2019t forget to take `jit_compile=True` out again when you move to TPU!\n- \ud83d\ude4f\ud83d\ude4f\ud83d\ude4f\ud83e\udd7a\ud83e\udd7a\ud83e\udd7a\n- Call model.fit()\n- You did it!"
            },
            {
                "score": 0.6384037754287696,
                "node_text": "Here are some facts extracted from the provided text:\n\nFunsd -> Is -> Form understanding dataset\nCord -> Is -> Form understanding dataset\n\n!---\nCopyright 2022 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n-->\n\n# Token classification with LayoutLMv3 (PyTorch version)\n\nThis directory contains a script, `run_funsd_cord.py`, that can be used to fine-tune (or evaluate) LayoutLMv3 on form understanding datasets, such as [FUNSD](https://guillaumejaume.github.io/FUNSD/) and [CORD](https://github.com/clovaai/cord).\n\nThe script `run_funsd_cord.py` leverages the \ud83e\udd17 Datasets library and the Trainer API. You can easily customize it to your needs.\n\n## Fine-tuning on FUNSD\n\nFine-tuning LayoutLMv3 for token classification on [FUNSD](https://guillaumejaume.github.io/FUNSD/) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name funsd \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 1e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-funsd\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd. By specifying the `push_to_hub` flag, the model gets uploaded automatically to the hub (regularly), together with a model card, which includes metrics such as precision, recall and F1. Note that you can easily update the model card, as it's just a README file of the respective repo on the hub.\n\nThere's also the \"Training metrics\" [tab](https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd/tensorboard), which shows Tensorboard logs over the course of training. Pretty neat, huh?\n\n## Fine-tuning on CORD\n\nFine-tuning LayoutLMv3 for token classification on [CORD](https://github.com/clovaai/cord) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name cord \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 5e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-cord\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-cord. Note that a model card gets generated automatically in case you specify the `push_to_hub` flag."
            }
        ]
    },
    {
        "sample_idx": 137,
        "question": "What training techniques are used by the model?",
        "answer": "Label Smoothing, SGD with Momentum, Weight Decay",
        "rag_answer": "Based on the provided context, the model uses techniques such as padding, specifically padding batches of samples up to a multiple of a number like 32 or 64 tokens, to reduce the number of unique input shapes and minimize XLA compilations. Additionally, the model uses attention masks to achieve the same results as variable shapes without XLA issues.",
        "rag_score": 1,
        "rag_feedback": "The system's response is completely incorrect, inaccurate, and/or not factual. The expected answer is about the training techniques used by the model, which are Label Smoothing, SGD with Momentum, and Weight Decay. However, the system's response talks about padding, attention masks, and XLA compilations, which are unrelated to the expected answer.",
        "rag_context": [
            {
                "score": 0.6607020826341463,
                "node_text": "Here are some facts extracted from the provided text:\n\nTpu -> Is used -> For training\nNlp models -> Have -> Variable lengths\nXla -> Recompile -> Model\n\nThis is a really useful trick, so remember it if you need to convert your own code to XLA!\n\n#### XLA Rule #3: XLA will need to recompile your model for every different input shape it sees\n\nThis is the big one. What this means is that if your input shapes are very variable, XLA will have to recompile your model over and over, which will create huge performance problems. This commonly arises in NLP models, where input texts have variable lengths after tokenization. In other modalities, static shapes are more common and this rule is much less of a problem.\n\nHow can you get around rule #3? The key is **padding** - if you pad all your inputs to the same length, and then use an `attention_mask`, you can get the same results as you\u2019d get from variable shapes, but without any XLA issues. However, excessive padding can cause severe slowdown too - if you pad all your samples to the maximum length in the whole dataset, you might end up with batches consisting endless padding tokens, which will waste a lot of compute and memory!\n\nThere isn\u2019t a perfect solution to this problem. However, you can try some tricks. One very useful trick is to **pad batches of samples up to a multiple of a number like 32 or 64 tokens.** This often only increases the number of tokens by a small amount, but it hugely reduces the number of unique input shapes, because every input shape now has to be a multiple of 32 or 64. Fewer unique input shapes means fewer XLA compilations!\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** Our tokenizers and data collators have methods that can help you here. You can use `padding=\"max_length\"` or `padding=\"longest\"` when calling tokenizers to get them to output padded data. Our tokenizers and data collators also have a `pad_to_multiple_of` argument that you can use to reduce the number of unique input shapes you see!\n\n</Tip>\n\n### How do I actually train my model on TPU?\n\nOnce your training is XLA-compatible and (if you\u2019re using TPU Node / Colab) your dataset has been prepared appropriately, running on TPU is surprisingly easy! All you really need to change in your code is to add a few lines to initialize your TPU, and to ensure that your model and dataset are created inside a `TPUStrategy` scope. Take a look at [our TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) to see this in action!\n\n### Summary\n\nThere was a lot in here, so let\u2019s summarize with a quick checklist you can follow when you want to get your model ready for TPU training:\n\n- Make sure your code follows the three rules of XLA\n- Compile your model with `jit_compile=True` on CPU/GPU and confirm that you can train it with XLA\n- Either load your dataset into memory or use a TPU-compatible dataset loading approach (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Migrate your code either to Colab (with accelerator set to \u201cTPU\u201d) or a TPU VM on Google Cloud\n- Add TPU initializer code (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Create your `TPUStrategy` and make sure dataset loading and model creation are inside the `strategy.scope()` (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Don\u2019t forget to take `jit_compile=True` out again when you move to TPU!\n- \ud83d\ude4f\ud83d\ude4f\ud83d\ude4f\ud83e\udd7a\ud83e\udd7a\ud83e\udd7a\n- Call model.fit()\n- You did it!"
            },
            {
                "score": 0.6337021902344334,
                "node_text": "Here are some facts extracted from the provided text:\n\nTensorflow models -> Are -> Keras models\n\n!--Copyright 2023 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\nthe License. You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under the License is distributed on\nan \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n\n\u26a0\ufe0f Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be\nrendered properly in your Markdown viewer.\n\n-->\n\n# Training on TPU with TensorFlow\n\n<Tip>\n\nIf you don't need long explanations and just want TPU code samples to get started with, check out [our TPU example notebook!](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb)\n\n</Tip>\n\n### What is a TPU?\n\nA TPU is a **Tensor Processing Unit.** They are hardware designed by Google, which are used to greatly speed up the tensor computations within neural networks, much like GPUs. They can be used for both network training and inference. They are generally accessed through Google\u2019s cloud services, but small TPUs can also be accessed directly for free through Google Colab and Kaggle Kernels.\n\nBecause [all TensorFlow models in \ud83e\udd17 Transformers are Keras models](https://huggingface.co/blog/tensorflow-philosophy), most of the methods in this document are generally applicable to TPU training for any Keras model! However, there are a few points that are specific to the HuggingFace ecosystem (hug-o-system?) of Transformers and Datasets, and we\u2019ll make sure to flag them up when we get to them.\n\n### What kinds of TPU are available?\n\nNew users are often very confused by the range of TPUs, and the different ways to access them. The first key distinction to understand is the difference between **TPU Nodes** and **TPU VMs.**\n\nWhen you use a **TPU Node**, you are effectively indirectly accessing a remote TPU. You will need a separate VM, which will initialize your network and data pipeline and then forward them to the remote node. When you use a TPU on Google Colab, you are accessing it in the **TPU Node** style.\n\nUsing TPU Nodes can have some quite unexpected behaviour for people who aren\u2019t used to them! In particular, because the TPU is located on a physically different system to the machine you\u2019re running your Python code on, your data cannot be local to your machine - any data pipeline that loads from your machine\u2019s internal storage will totally fail! Instead, data must be stored in Google Cloud Storage where your data pipeline can still access it, even when the pipeline is running on the remote TPU node.\n\n<Tip>\n\nIf you can fit all your data in memory as `np.ndarray` or `tf.Tensor`, then you can `fit()` on that data even when using Colab or a TPU Node, without needing to upload it to Google Cloud Storage.\n\n</Tip>\n\n<Tip>\n\n**\ud83e\udd17Specific Hugging Face Tip\ud83e\udd17:** The methods `Dataset.to_tf_dataset()` and its higher-level wrapper `model.prepare_tf_dataset()` , which you will see throughout our TF code examples, will both fail on a TPU Node. The reason for this is that even though they create a `tf.data.Dataset` it is not a \u201cpure\u201d `tf.data` pipeline and uses `tf.numpy_function` or `Dataset.from_generator()` to stream data from the underlying HuggingFace `Dataset`. This HuggingFace `Dataset` is backed by data that is on a local disc and which the remote TPU Node will not be able to read.\n\n</Tip>\n\nThe second way to access a TPU is via a **TPU VM.** When using a TPU VM, you connect directly to the machine that the TPU is attached to, much like training on a GPU VM. TPU VMs are generally easier to work with, particularly when it comes to your data pipeline. All of the above warnings do not apply to TPU VMs!\n\nThis is an opinionated document, so here\u2019s our opinion: **Avoid using TPU Node if possible.** It is more confusing and more difficult to debug than TPU VMs. It is also likely to be unsupported in future - Google\u2019s latest TPU, TPUv4, can only be accessed as a TPU VM, which suggests that TPU Nodes are increasingly going to become a \u201clegacy\u201d access method."
            },
            {
                "score": 0.6107238784543557,
                "node_text": "Here are some facts extracted from the provided text:\n\nModel -> Needs -> Question\nModel -> Has -> Input shape\nModel -> Needs -> Context\nModel -> Evaluates on -> Squad\nNielsr/layoutlmv3-finetuned-funsd -> Is -> Model\nModel -> Returns -> Prediction_text\n\n!---\nCopyright 2022 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n-->\n\n# Token classification with LayoutLMv3 (PyTorch version)\n\nThis directory contains a script, `run_funsd_cord.py`, that can be used to fine-tune (or evaluate) LayoutLMv3 on form understanding datasets, such as [FUNSD](https://guillaumejaume.github.io/FUNSD/) and [CORD](https://github.com/clovaai/cord).\n\nThe script `run_funsd_cord.py` leverages the \ud83e\udd17 Datasets library and the Trainer API. You can easily customize it to your needs.\n\n## Fine-tuning on FUNSD\n\nFine-tuning LayoutLMv3 for token classification on [FUNSD](https://guillaumejaume.github.io/FUNSD/) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name funsd \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 1e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-funsd\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd. By specifying the `push_to_hub` flag, the model gets uploaded automatically to the hub (regularly), together with a model card, which includes metrics such as precision, recall and F1. Note that you can easily update the model card, as it's just a README file of the respective repo on the hub.\n\nThere's also the \"Training metrics\" [tab](https://huggingface.co/nielsr/layoutlmv3-finetuned-funsd/tensorboard), which shows Tensorboard logs over the course of training. Pretty neat, huh?\n\n## Fine-tuning on CORD\n\nFine-tuning LayoutLMv3 for token classification on [CORD](https://github.com/clovaai/cord) can be done as follows:\n\n```bash\npython run_funsd_cord.py \\\n  --model_name_or_path microsoft/layoutlmv3-base \\\n  --dataset_name cord \\\n  --output_dir layoutlmv3-test \\\n  --do_train \\\n  --do_eval \\\n  --max_steps 1000 \\\n  --evaluation_strategy steps \\\n  --eval_steps 100 \\\n  --learning_rate 5e-5 \\\n  --load_best_model_at_end \\\n  --metric_for_best_model \"eval_f1\" \\\n  --push_to_hub \\\n  --push_to_hub\u00b0model_id layoutlmv3-finetuned-cord\n```\n\n\ud83d\udc40 The resulting model can be found here: https://huggingface.co/nielsr/layoutlmv3-finetuned-cord. Note that a model card gets generated automatically in case you specify the `push_to_hub` flag."
            }
        ]
    },
    {
        "sample_idx": 138,
        "question": "How many NVIDIA Titan X GPUs are used for training?",
        "answer": "8",
        "rag_answer": "There is no mention of NVIDIA Titan X GPUs being used for training in the provided context information. The context only discusses TPUs (Tensor Processing Units) and their usage for training neural networks.",
        "rag_score": 1,
        "rag_feedback": "The system's response is completely incorrect, inaccurate, and/or not factual. The response states that there is no mention of NVIDIA Titan X GPUs being used for training in the provided context information, which is correct. However, the expected answer is 8, which is not supported by the context.",
        "rag_context": [
            {
                "score": 1.0,
                "node_text": "Here are some facts extracted from the provided text:\n\nTpu -> Used for -> Neural networks\n\nThis is a really useful trick, so remember it if you need to convert your own code to XLA!\n\n#### XLA Rule #3: XLA will need to recompile your model for every different input shape it sees\n\nThis is the big one. What this means is that if your input shapes are very variable, XLA will have to recompile your model over and over, which will create huge performance problems. This commonly arises in NLP models, where input texts have variable lengths after tokenization. In other modalities, static shapes are more common and this rule is much less of a problem.\n\nHow can you get around rule #3? The key is **padding** - if you pad all your inputs to the same length, and then use an `attention_mask`, you can get the same results as you\u2019d get from variable shapes, but without any XLA issues. However, excessive padding can cause severe slowdown too - if you pad all your samples to the maximum length in the whole dataset, you might end up with batches consisting endless padding tokens, which will waste a lot of compute and memory!\n\nThere isn\u2019t a perfect solution to this problem. However, you can try some tricks. One very useful trick is to **pad batches of samples up to a multiple of a number like 32 or 64 tokens.** This often only increases the number of tokens by a small amount, but it hugely reduces the number of unique input shapes, because every input shape now has to be a multiple of 32 or 64. Fewer unique input shapes means fewer XLA compilations!\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** Our tokenizers and data collators have methods that can help you here. You can use `padding=\"max_length\"` or `padding=\"longest\"` when calling tokenizers to get them to output padded data. Our tokenizers and data collators also have a `pad_to_multiple_of` argument that you can use to reduce the number of unique input shapes you see!\n\n</Tip>\n\n### How do I actually train my model on TPU?\n\nOnce your training is XLA-compatible and (if you\u2019re using TPU Node / Colab) your dataset has been prepared appropriately, running on TPU is surprisingly easy! All you really need to change in your code is to add a few lines to initialize your TPU, and to ensure that your model and dataset are created inside a `TPUStrategy` scope. Take a look at [our TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) to see this in action!\n\n### Summary\n\nThere was a lot in here, so let\u2019s summarize with a quick checklist you can follow when you want to get your model ready for TPU training:\n\n- Make sure your code follows the three rules of XLA\n- Compile your model with `jit_compile=True` on CPU/GPU and confirm that you can train it with XLA\n- Either load your dataset into memory or use a TPU-compatible dataset loading approach (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Migrate your code either to Colab (with accelerator set to \u201cTPU\u201d) or a TPU VM on Google Cloud\n- Add TPU initializer code (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Create your `TPUStrategy` and make sure dataset loading and model creation are inside the `strategy.scope()` (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Don\u2019t forget to take `jit_compile=True` out again when you move to TPU!\n- \ud83d\ude4f\ud83d\ude4f\ud83d\ude4f\ud83e\udd7a\ud83e\udd7a\ud83e\udd7a\n- Call model.fit()\n- You did it!"
            },
            {
                "score": 0.6264705611321547,
                "node_text": "Here are some facts extracted from the provided text:\n\nTpu -> Is -> Tensor processing unit\nTpu -> Is used -> For training\n\nThis is a really useful trick, so remember it if you need to convert your own code to XLA!\n\n#### XLA Rule #3: XLA will need to recompile your model for every different input shape it sees\n\nThis is the big one. What this means is that if your input shapes are very variable, XLA will have to recompile your model over and over, which will create huge performance problems. This commonly arises in NLP models, where input texts have variable lengths after tokenization. In other modalities, static shapes are more common and this rule is much less of a problem.\n\nHow can you get around rule #3? The key is **padding** - if you pad all your inputs to the same length, and then use an `attention_mask`, you can get the same results as you\u2019d get from variable shapes, but without any XLA issues. However, excessive padding can cause severe slowdown too - if you pad all your samples to the maximum length in the whole dataset, you might end up with batches consisting endless padding tokens, which will waste a lot of compute and memory!\n\nThere isn\u2019t a perfect solution to this problem. However, you can try some tricks. One very useful trick is to **pad batches of samples up to a multiple of a number like 32 or 64 tokens.** This often only increases the number of tokens by a small amount, but it hugely reduces the number of unique input shapes, because every input shape now has to be a multiple of 32 or 64. Fewer unique input shapes means fewer XLA compilations!\n\n<Tip>\n\n**\ud83e\udd17Specific HuggingFace Tip\ud83e\udd17:** Our tokenizers and data collators have methods that can help you here. You can use `padding=\"max_length\"` or `padding=\"longest\"` when calling tokenizers to get them to output padded data. Our tokenizers and data collators also have a `pad_to_multiple_of` argument that you can use to reduce the number of unique input shapes you see!\n\n</Tip>\n\n### How do I actually train my model on TPU?\n\nOnce your training is XLA-compatible and (if you\u2019re using TPU Node / Colab) your dataset has been prepared appropriately, running on TPU is surprisingly easy! All you really need to change in your code is to add a few lines to initialize your TPU, and to ensure that your model and dataset are created inside a `TPUStrategy` scope. Take a look at [our TPU example notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb) to see this in action!\n\n### Summary\n\nThere was a lot in here, so let\u2019s summarize with a quick checklist you can follow when you want to get your model ready for TPU training:\n\n- Make sure your code follows the three rules of XLA\n- Compile your model with `jit_compile=True` on CPU/GPU and confirm that you can train it with XLA\n- Either load your dataset into memory or use a TPU-compatible dataset loading approach (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Migrate your code either to Colab (with accelerator set to \u201cTPU\u201d) or a TPU VM on Google Cloud\n- Add TPU initializer code (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Create your `TPUStrategy` and make sure dataset loading and model creation are inside the `strategy.scope()` (see [notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb))\n- Don\u2019t forget to take `jit_compile=True` out again when you move to TPU!\n- \ud83d\ude4f\ud83d\ude4f\ud83d\ude4f\ud83e\udd7a\ud83e\udd7a\ud83e\udd7a\n- Call model.fit()\n- You did it!"
            },
            {
                "score": 0.589615324262015,
                "node_text": "Here are some facts extracted from the provided text:\n\nTensorflow models -> Are -> Keras models\n\n!--Copyright 2023 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\nthe License. You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under the License is distributed on\nan \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n\n\u26a0\ufe0f Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be\nrendered properly in your Markdown viewer.\n\n-->\n\n# Training on TPU with TensorFlow\n\n<Tip>\n\nIf you don't need long explanations and just want TPU code samples to get started with, check out [our TPU example notebook!](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/tpu_training-tf.ipynb)\n\n</Tip>\n\n### What is a TPU?\n\nA TPU is a **Tensor Processing Unit.** They are hardware designed by Google, which are used to greatly speed up the tensor computations within neural networks, much like GPUs. They can be used for both network training and inference. They are generally accessed through Google\u2019s cloud services, but small TPUs can also be accessed directly for free through Google Colab and Kaggle Kernels.\n\nBecause [all TensorFlow models in \ud83e\udd17 Transformers are Keras models](https://huggingface.co/blog/tensorflow-philosophy), most of the methods in this document are generally applicable to TPU training for any Keras model! However, there are a few points that are specific to the HuggingFace ecosystem (hug-o-system?) of Transformers and Datasets, and we\u2019ll make sure to flag them up when we get to them.\n\n### What kinds of TPU are available?\n\nNew users are often very confused by the range of TPUs, and the different ways to access them. The first key distinction to understand is the difference between **TPU Nodes** and **TPU VMs.**\n\nWhen you use a **TPU Node**, you are effectively indirectly accessing a remote TPU. You will need a separate VM, which will initialize your network and data pipeline and then forward them to the remote node. When you use a TPU on Google Colab, you are accessing it in the **TPU Node** style.\n\nUsing TPU Nodes can have some quite unexpected behaviour for people who aren\u2019t used to them! In particular, because the TPU is located on a physically different system to the machine you\u2019re running your Python code on, your data cannot be local to your machine - any data pipeline that loads from your machine\u2019s internal storage will totally fail! Instead, data must be stored in Google Cloud Storage where your data pipeline can still access it, even when the pipeline is running on the remote TPU node.\n\n<Tip>\n\nIf you can fit all your data in memory as `np.ndarray` or `tf.Tensor`, then you can `fit()` on that data even when using Colab or a TPU Node, without needing to upload it to Google Cloud Storage.\n\n</Tip>\n\n<Tip>\n\n**\ud83e\udd17Specific Hugging Face Tip\ud83e\udd17:** The methods `Dataset.to_tf_dataset()` and its higher-level wrapper `model.prepare_tf_dataset()` , which you will see throughout our TF code examples, will both fail on a TPU Node. The reason for this is that even though they create a `tf.data.Dataset` it is not a \u201cpure\u201d `tf.data` pipeline and uses `tf.numpy_function` or `Dataset.from_generator()` to stream data from the underlying HuggingFace `Dataset`. This HuggingFace `Dataset` is backed by data that is on a local disc and which the remote TPU Node will not be able to read.\n\n</Tip>\n\nThe second way to access a TPU is via a **TPU VM.** When using a TPU VM, you connect directly to the machine that the TPU is attached to, much like training on a GPU VM. TPU VMs are generally easier to work with, particularly when it comes to your data pipeline. All of the above warnings do not apply to TPU VMs!\n\nThis is an opinionated document, so here\u2019s our opinion: **Avoid using TPU Node if possible.** It is more confusing and more difficult to debug than TPU VMs. It is also likely to be unsupported in future - Google\u2019s latest TPU, TPUv4, can only be accessed as a TPU VM, which suggests that TPU Nodes are increasingly going to become a \u201clegacy\u201d access method."
            }
        ]
    }
]